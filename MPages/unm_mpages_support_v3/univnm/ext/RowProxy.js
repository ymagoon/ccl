/* Class: univnm.ext.RowProxy
	(proxy type = row) model proxy that can load via <univnm.db.query> and save/destroy
	via <univnm.db.saveRow>

	This proxy depends on meta data set in the model to work properly, see
	*Model Properties*  and *Field Properties* below

	Model Properties:
		table			-	String.
							Name of the table the model represents

		fields			-	Array.
							Some extra properties are available on fields. See
							*Field Extras* below

		reloadAfterSave	-	Boolean, default false,
							Should values be reloaded from the DB after saves?
							Normally the values generated by the save in the
							primary table are applied to the saved row. This
							should only be necessary if the model includes meta
							fields that need to be queried via _readSql_

		readSql			-	String, default "select * from {table} t where {conditions}"
							This sql string will be used in load operations. You
							generally only need to set it if your model has meta
							columns that are not in the underlying table. Note
							that the main table is aliased to "t" this is
							important as any conditions the proxy generates will
							also use this alias.



	FieldExtras:
		naturalKey		-	Boolean, default false.
							Set to true for fields that form a natural key. This
							can be used to to update fields when you don't know the
							primary key value

		meta			-	Boolena, default false.
							Set to true for fields that are not in the underlying
							table. A great use for this is in bridge tables that
							are only associating foreign keys, but you want to
							display columns from the foreign tables. Meta columns
							are ignored in save and destroy operations

		sqlDefault		-	String|Number|Date|Array|Struct, default undefined.
							SQL default value. This will be passed as the value
							to <univnm.db.saveRow> when no value is explicitly set.
							the same data conversion rules apply as with saveRow


	Example:
	(code)
		Ext.define('MPAGE.model.Application', {
			extend: 'Ext.data.Model',
			proxy:"row",
			table:"cust_applications",
			fields:[
				{name:"id", sqlDefault:"#cust_applications_seq.nextval"},
				{name:"display_name"},
				{name:"app_name", naturalKey:true},
				{name:"is_portlet", sqlDefault:"#null"},
				{name:"description", sqlDefault:"#null"}
			]
		});
		var app = MPAGE.model.Application.load(10,{
			callback:function(record){
				record.set("description",record.get("name") + " is awesome!");
				record.save()
			}
		})

		Ext.define('MPAGE.model.Perm', {
			extend: 'Ext.data.Model',
			proxy:"row",
			table:"cust_aros_acos",
			fields:[
				{name:"id",				sqlDefault:"#cust_aros_acos_seq.nextval"},

				{name:"aro_id",			naturalKey:true},
				{name:"aco_id",			naturalKey:true},

				{name:"app_id",			meta:true},
				{name:"right_name",		meta:true},
				{name:"app_name",		meta:true},
				{name:"display_name",	meta:true},
				{name:"group_name",		meta:true}
			],
			reloadAfterSave:true,
			readSql:[
				"Select ",
				"	t.id, ",
				"	t.aro_id, ",
				"	t.aco_id, ",
				"	co.foreign_key app_id, ",
				"	co.alias right_name, ",
				"	app.app_name, ",
				"	app.display_name, ",
				"	ro.alias ",
				"group_name ",
				"From ",
				"	cust_aros_acos t ",
				"		join cust_acos co on( co.id = t.aco_id ",
				") ",
				"	join cust_aros ro on( ro.id = t.aro_id ",
				") ",
				"left ",
				"	join cust_applications app on( app.id = co.foreign_key ",
				") ",
				"Where ",
				"	1=1 ",
				"	and ro.model = 'Role' ",
				"	and co.model='Right' ",
				"   and {conditions} "
			]
		});

		var perm = new MPAGE.model.Perm({
			aro_id:1334,
			aco_id:6653
		}).save({
			callback:function(record){
				// This represents the id that was generated by the sequence, if
				// this was an insert, or the existing id if this was an update
				// This behavior does NOT require reloadAfterSave:true
				console.log(record.get("id"))

				// Because we set readSql, and reloadAfterSave:true, a second
				// callback using readSql was performed, and by now  group_name
				// is available in resulting record
				console.log(record.get("group_name"))
			}
		})


	(end)

*/
Ext.define('univnm.ext.RowProxy', {
	extend: 'Ext.data.proxy.Client',
	alias: 'proxy.row',
	constructor: function(config) {
		this.callParent([config]);
		//ensures that the reader has been instantiated properly
		this.setReader(this.reader);
	},
	readSql:"select * from {table} t where {conditions}",
	reloadAfterSave:false,
	loadDataByNaturalKey:function(values,cb){
		var modelClass = this.getModel();
		var def = new modelClass();
		var sql = def.readSql||this.readSql;
		univnm.db.query(
			sql,
			{
				table:def.table,
				conditions:def.fields.items
					.filter(function(f){
						return f.naturalKey;
					}).map(function(f){
						return "t.{0} = {1}".format(
							f.name,
							univnm.db.toSql(values[f.name]).replace(/~/g,"_TILDE_")
							.replace(/\|/g,"_PIPE_").replace(/\^/g, "_CARET_")
						);
					}).join(" and ")
			},
			function(result){
				if (result.length == 1){
					if (cb) cb(result[0]);
				} else {
					throw new error("expecting a single row response for natural key.");
				}
			}
		);
	},
	stripMetaColumns:function(data){
		var modelClass = this.getModel();
		var def = new modelClass();
		var result = {};
		def.fields.items.forEach(function(f){
			if (!f.meta) {
				result[f.name] = data[f.name];
			}
		});

		return result;
	},
	hasValue:function(value){
		return value || value === 0;
	},
	create: function(operation,callback,scope) {
		var records = operation.getRecords();
		var $this = this;
		//check metadata and cache results
		var modelClass = this.getModel();
		var def = new modelClass();

		//cache some metadata
		if (!("naturalKeys" in modelClass)){
			modelClass.naturalKeys = def.fields.items.filter(function(f){
				return f.naturalKey;
			});
		}

		//Using marshal here because this may, or may not be an async operation.
		//Regardless, then() will fire and the op will complete
		univnm.jslib.async.marshal(function(opDone){
			//exit early if there is nothing to do. This effectively makes the
			//operation synchronous
			if (!records.length) return opDone();

			//only get here if there are records to save

			//inner marshal to handle individual rows
			univnm.jslib.async.marshal(
				// run each of these async
				records.filter(function(record){
					//skip any unmodified records
					return record.dirty;
				}).map(function(record){

					var hasValidNatualKey = false;
					var data =$this.stripMetaColumns(record.getData());
					// determine criteria: primary key or natural key
					if ( $this.hasValue(data[def.idProperty]) ){
						data[def.idProperty + " ="] = data[def.idProperty];
						delete data[def.idProperty];

					} else if (modelClass.naturalKeys.length){
						hasValidNaturalKey =modelClass.naturalKeys.every(function(f){
							var prop = f.name;
							if ( $this.hasValue(data[prop]) ){
								data[prop +" ="] = data[prop];
								delete data[prop];
								return true;
							} else return false;
						});

						if (!hasValidNaturalKey) {
							console.log("Unable to save record",record);
							throw new Error(
								"Unable to save record. No naturalKey defined (or naturalKey "
								+ "fields have no value) and primary key has no value."
							);
						}
					} else {
						console.log("Unable to save record",record);
						throw new Error(
							"Unable to save record. No naturalKey defined and primary key has no value."
						);
					}


					// set sqlDefaults where appropriate
					$O(data).getKeys().forEach(function(prop){
						if ( !$this.hasValue(data[prop]) ){
							data[prop] = def.fields.map[prop].sqlDefault;
						}
					});

					//return async callback function that will save the record
					return function(rowDone){
						univnm.db.saveRow(
							def.table,
							'set',
							data,
							function(result){
								if (result.length){
									record.set(result.first());
								}

								var reloadAfterSave = record.reloadAfterSave;
								if ("reloadAfterSave" in operation){
									reloadAfterSave = operation.reloadAfterSave;
								}

								if (reloadAfterSave){
									// Do another callback to update this record.
									// We'll wait until the record is updated to let
									// async know this row is done
									if ($this.hasValue(record.get(def.idProperty))){
										modelClass.load(
											record.get(def.idProperty),
											{
												callback:function(response){
													record.set(response.getData());
													rowDone();
												}
											}
										);
									} else if (hasValidNaturalKey) {
										$this.loadDataByNaturalKey(record.data,function(data){
											record.set(data);
											//let async know this row is done
											rowDone();
										});
									} else rowDone();//can't reload
								} else rowDone();//let async know this row is done
							}
						);
					};
				})
			).then(opDone);//all records created

		}).then(function(){
		//commit records
			records.forEach(function(record){
				record.commit();
			});

			//complete operation
			operation.setCompleted();
			operation.setSuccessful();
			Ext.callback(callback, scope || this, [operation]);
		});

	},
	update: function() {
		this.create.apply(this, arguments);
	},

	destroy: function(operation,callback,scope) {
		var records = operation.getRecords();
		var $this = this;
		//Using marshal here because this may, or may not be an async operation.
		//Regardless, then() will fire and the op will complete
		univnm.jslib.async.marshal(function(opDone){
			//exit early if there is nothing to do. This effectively makes the
			//operation synchronous
			if (!records.length) return opDone();

			//only get here if there are records to delete
			var def = records[0];
			//inner marshal to handle individual rows
			univnm.jslib.async.marshal(
				// run each of these async
				records.map(function(record){
					var data =$this.stripMetaColumns(record.getData());
					var criteria ={};

					if (
						typeof def.idProperty == "string"
						&& (
							data[def.idProperty]
							|| data[def.idProperty] === 0
						)
					){
						criteria[def.idProperty] = data[def.idProperty];

					} else {
						var naturalKeys = $O(data).getKeys()
							.filter(function(prop){
								return def.fields.map[prop].naturalKey;
							});
						var hasNaturalKey =naturalKeys.length
							&& naturalKeys.every(function(prop){
									criteria[prop] = data[prop];
								return data[prop] || data[prop] === 0;
							});

						if (!hasNaturalKey) {
							throw new Error(
								"Unable to delete record. No naturalKey defined (or naturalKey "
								+ "fields have no value) and primary key has no value."
							);
						}
					}

					//return async callback function that will save the record
					return function(rowDone){
						univnm.db.saveRow(
							def.table,
							'remove',
							criteria,
							rowDone//let async know this row is done
						);
					};
				})
			).then(opDone);//all records created

		}).then(function(){
			//commit records
			records.forEach(function(record){
				record.commit();
				record.stores.forEach(function(store){
					store.remove(record);
				});
			});

			//complete operation
			operation.setCompleted();
			operation.setSuccessful();

			Ext.callback(callback, scope || this, [operation]);
		});
	},

	read: function(operation, callback, scope) {
		var modelClass = this.getModel();
		var def = new modelClass();
		var idCol = def.idProperty;
		var idVal = operation.id;


		if (!idVal && idVal !== 0){
			operation.setCompleted();
			operation.setException(new Error("Id is required for read operation on RowProxy"));
			Ext.callback(callback, scope || me, [operation]);
		}else {
			var sql = def.readSql||this.readSql;
			univnm.db.query(
				sql,
				{
					table:def.table,
					conditions:"t.{idCol} = {idVal}".format({
						idCol:idCol,
						idVal:univnm.db.toSql(idVal)
					})
				},
				function(result){
					if (result.length){
						operation.records = result.map(function(data){
							return new modelClass(data);
						});
					}
					operation.setCompleted();
					operation.setSuccessful();
					Ext.callback(callback, scope || this, [operation]);
				}
			);

		}

		/* //console.log("called read against rowProxy:",operation)
		var proxyClass= Ext.ClassManager.get("univnm.ext.QueryProxy");
		if (proxyClass){
			var modelClass= this.getModel();
			var def = new modelClass();
			new proxyClass({
				sql:"select * from {}".format(def.table)
			})
		} else {
			operation.setCompleted();
			operation.setException(new Error("univnm.ext.QueryProxy is required for read operations"));
			Ext.callback(callback, scope || me, [operation]);
		} */
	},

	clear: Ext.emptyFn
});


