const Server = require("karma").Server;
const config = require("../config");
const fs = require("fs");
const path = require("path");
const { evidencePathConfig } = require("../constants/pathConfiguration");

/**
 * This function checks the evidence folder for the code coverage report. If its there it resolves with the
 * folder path, if not it resolves with false.
 * @function checkCodeCoverage
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that resolves with either a file path or false
 */
const checkCodeCoverage = (gaia, args) =>
    new Promise((ok, err) => {
        const evidenceFolder = path.resolve(process.cwd(), evidencePathConfig.htmlDirectoryPath);
        fs.access(evidenceFolder, fs.constants.R_OK, (error) => error ? err(error) : ok(evidenceFolder));
    });


/**
 * This function attempts to read the JSON file that is output by the JsonResultReporter
 * @function readResults
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that resolves with the data from the report in JSON form
 */
const readResults = (gaia, args) =>
    new Promise((ok, err) => {
        fs.readFile(path.resolve(process.cwd(), evidencePathConfig.jsonFileName), (err, data) => {
            if (err) throw err;
            const obj = JSON.parse(data);
            ok(obj);
        });
    });

/**
 * This function defines the 'run' command for the plugin.
 * It checks the gaia.json config file and then passes that config as an arg to the
 * executeKarma function.
 * @function run
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that calls readConfig then executeKarma
 */
const run = (gaia, args) =>
    readConfig(gaia, args)
        .then((config) => {
            const updatedConfig = args.cli ?
                Object.assign({}, config, {
                    browser: [ "PhantomJS" ],
                    singleRun: true
                })
                : config;
            Object.assign(args, {
                config: updatedConfig
            });
            console.log(updatedConfig);
            return executeKarma(gaia, args);
        });

/**
 * This function will start a karma Server and run it with the karma.conf setup.
 * The config should be passed in through the "config" arg.
 * @function executeKarma
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that starts the karma server
 */
const executeKarma = (gaia, args) =>
    new Promise((ok, err) => {
        const karmaConfig = config.karma(args.config);

        const karmaServer = new Server(karmaConfig, (exitCode) => {
            console.log(`Karma has exited with ${exitCode}`);
            if (args.cli) {
                process.exit(Number(exitCode));
            }
            ok();
        });
        karmaServer.start();
    });

/**
 * This function reads the config file (gaia.json) that may or may not exist
 * and checks for any unit-testing settings
 * @function readConfig
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that contains the config object for unit-testing or {}
 */
const readConfig = (gaia, args) =>
    gaia.runCommand(
        "config",
        "read",
        Object.assign(args, {
            plugin: "unit-testing"
        })
    )
        .then((config) =>
            // setting default value to avoid breaking existing consumers
            "unitTestPath" in config
                ? config
                : Object.assign({}, config, {
                    unitTestPath: "src/__tests__"
                })
        );

/**
 * This function reads the existing gaia.json config then
 * it saves config passed to it from the settings arg. The command line will come in as a string,
 * so it is parsed to JSON. The Config tab is passed as JSON already. The passed config is added to the existing
 * gaia.json settings. Then the config is written out to the gaia.json.
 * NOTE: When sending settings from cmd line, your keys must be in escaped quotes
 * if sending more than one setting you must also escape your brackets
 * ie: npm run gaia unit-testing:saveConfig settings={\"singleRun\":false}
 * ie: npm run gaia unit-testing:saveConfig settings=\{\"singleRun\":false,\"usesFusion\":true\}
 * @function saveConfig
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that calls readConfig then writes the config to gaia.json
 */
const saveConfig = (gaia, args) =>
    readConfig(gaia, args)
        .then(
            (config) => gaia.runCommand(
                    "config",
                    "write",
                    {
                        plugin: "unit-testing",
                        config: Object.assign(
                            {},
                            config,
                            typeof args.settings === "string" ? JSON.parse(args.settings) : args.settings
                        )
                    }
                )
        );

module.exports = {
    run,
    readResults,
    saveConfig,
    readConfig,
    checkCodeCoverage
};
