import { atomic, composite, UIComponent } from "MPageFusion";
import { runCommand, EVENTS } from "Gaia";
import "../styles/Linter.less";
import "../styles/LoadSpinner.less";
import ReportBanner from "./ReportBanner";

const { banner: { BannerItem }, form: { FormCheckbox } } = composite;

const {
    table: { Table },
    indicator: { LoadingSpinner },
    label: { Anchor },
    button: { Button }
} = atomic;

const SuccessIcon = atomic.icon.svg.alert.Success;
const ErrorIcon = atomic.icon.svg.alert.Error;
const WarningIcon = atomic.icon.svg.alert.Warning;

// enum for the text in the severity column
const SEVERITY = {
    1: "Warning",
    2: "Error"
};

// enum for the color of the text in the severity column
const TEXT_SEVERITY_COLOR = {
    1: "linter-text-warning",
    2: "linter-text-error"
};

// enum for the color of the banner (based on highest level problem)
const BANNER_SEVERITY_COLOR = {
    0: "linter-perfect-colors",
    1: "linter-warning-colors",
    2: "linter-error-colors"
};

const CELL_ANCHOR_CLICK = "LINTER::CELL::ANCHOR::CLICK";

const PRIVATE_EVENTS = {
    RUN_LINTER: "Linter::runLinter",
    AUTOFIX_SELECTION_CHANGE: "Linter::autoFixSelectionChange"
};

/**
 * This function takes the key from the clicked cell and creates the relevant webpage link.
 * It will launch the ESLint rule webpage based on which rule is clicked.
 * @param {String} key The key from the clicked cell
 */
const clickCellLink = key =>
    window.open(`http://eslint.org/docs/rules/${key}`, "_blank");

/**
 * This function parses through the JSON of a subsection and builds out the
 * values for each column for a row of data.
 * @param {Array} rowsJSON The JSON of a subsection of data
 * @returns {Array} The row data in a format the table can consume
 */
const parseRows = rowsJSON =>
    rowsJSON.map((messages, index) => ({
        key: `row ${index}`,
        data: [
            {
                display: `${messages.line}:${messages.column}`
            },
            {
                contentClassNames: TEXT_SEVERITY_COLOR[messages.severity],
                display: SEVERITY[messages.severity]
            },
            {
                display: `${messages.message}`
            },
            {
                content: [
                    new Anchor({
                        display: `${messages.ruleId}`,
                        key: `${messages.ruleId}`,
                        clickEventName: CELL_ANCHOR_CLICK
                    })
                ]
            }
        ]
    }));

/**
 * Given a word and a count, append an s if count is not one.
 * @param {string} word A word in its singular form.
 * @param {int} count A number controlling whether word should be pluralized.
 * @returns {string} The original word with an s on the end if count is not one.
 */
const pluralize = (word, count) => (count === 1 ? word : `${word}s`);

/**
 * Renders text along the template of x problems (x errors, x warnings)
 * @param {int} totalErrors Total errors
 * @param {int} totalWarnings Total warnings
 * @returns {string} The formatted string, pluralized where necessary
 */
const renderSummary = (totalErrors, totalWarnings) => {
    const totalProblems = totalErrors + totalWarnings;
    const prefix = `${totalProblems} ${pluralize("problem", totalProblems)}`;

    return totalProblems !== 0
        ? `${prefix} (${totalErrors} ${pluralize(
              "error",
              totalErrors
          )}, ${totalWarnings} ${pluralize("warning", totalWarnings)})`
        : prefix;
};

/**
 * Get the color based on whether there are errors/warnings
 * @param {int} totalErrors Total errors
 * @param {int} totalWarnings Total warnings
 * @returns {int} The color code (0 = green, 1 = yellow, 2 = red)
 */
const renderColor = (totalErrors, totalWarnings) =>
    (totalErrors && 2) || (totalWarnings && 1) || 0;

/**
 * This function parses through the JSON of ESLint results and builds out a subsection
 * for each different file that was linted.
 * @param {Array} jsonResult The JSON of the ESLint results
 * @returns {Array} The subsections and their results for the table data
 */
const parseSubsections = jsonResult =>
    jsonResult
        .filter(files => {
            return files.errorCount + files.warningCount;
        })
        .map((files, index) => ({
            display: `${files.filePath} -- ${renderSummary(
                files.errorCount,
                files.warningCount
            )}`,
            expand: false,
            key: `section ${index}`,
            rows: parseRows(files.messages)
        }));

/**
 * This function runs the linter command determineSrcPath and then returns that path
 * @param control The current control making the call
 * @returns {Promise} The path that was returned from determineSrcPath
 */
const checkConfigPath = control =>
    runCommand("linter", "determineSrcPath").then(path =>
        Promise.resolve(path)
    );

/**
 * This function runs the linter command run and then updates the UI.
 * @param linter The current Linter object
 * @param path The path of files to be linted
 * @param autoFix The boolean value indicating the fix mode
 */
const runLinter = (linter, { lintPath, autoFix = false }) => {
    linter
        .emit(EVENTS.TAB_LABEL_CHANGE, {
            id: linter.getProp("id"),
            icon: new LoadingSpinner({
                isLoading: true,
                size: LoadingSpinner.SIZE.XSMALL
            })
        })
        .setProp("isRunning", true)
        .update();

    return runCommand("linter", "run", {
        srcDir: lintPath,
        webFlag: true,
        fix: autoFix
    })
        .then(resultObj => {
            linter.getChild("spinner").setProp("isLoading", false);
            linter
                .getChild("outputTable")
                .setProp("subSections", parseSubsections(resultObj.results));
            linter.getChild("reportBanner").setProps({
                generatedDate: new Date().toString(),
                summaryText: renderSummary(
                    resultObj.errorCount,
                    resultObj.warningCount
                ),
                bannerClasses:
                    BANNER_SEVERITY_COLOR[
                        renderColor(
                            resultObj.errorCount,
                            resultObj.warningCount
                        )
                    ]
            });

            const issueCount = resultObj.warningCount + resultObj.errorCount;
            const issueIcon =
                issueCount && resultObj.errorCount > 0
                    ? new ErrorIcon()
                    : new WarningIcon();
            linter.emit(EVENTS.TAB_LABEL_CHANGE, {
                id: linter.getProp("id"),
                label: issueCount
                    ? `MPages Linter (${issueCount})`
                    : "MPages Linter",
                icon: issueCount ? issueIcon : new SuccessIcon()
            });

            linter.setProps({
                isRunning: false,
                showTable: true
            });

            linter.update();
        })
        .catch(error => {
            const errMsg = error.message || error;
            console.log(errMsg);

            linter.getChild("spinner").setProp("isLoading", false);
            linter.getChild("alertBanner").setProp("description", errMsg);

            linter.setProps({
                showError: true,
                isRunning: false
            });

            linter.emit(EVENTS.TAB_LABEL_CHANGE, {
                id: linter.getProp("id"),
                icon: null
            });

            linter.update();
        });
};

/**
 * @class Linter
 */
class Linter extends UIComponent {
    initialProps() {
        return {
            showError: false,
            showTable: false,
            isRunning: false,
            isFixIssuesSelected: false
        };
    }

    createChildren() {
        return [
            {
                alertBanner: new BannerItem({
                    description: "Something went wrong",
                    type: BannerItem.TYPE.ERROR,
                    enableDismissClick: true
                })
            },
            {
                outputTable: new Table({
                    columns: [
                        {
                            display: "Line:Column",
                            key: "linecol"
                        },
                        {
                            display: "Severity",
                            key: "severity"
                        },
                        {
                            display: "Message",
                            key: "message",
                            sizeSpan: 4
                        },
                        {
                            display: "Rule Id",
                            key: "rule"
                        }
                    ],
                    subSections: []
                })
            },
            {
                spinner: new LoadingSpinner({
                    isLoading: true,
                    size: LoadingSpinner.SIZE.LARGE
                })
            },
            {
                reportBanner: new ReportBanner()
            },
            {
                runLintingButton: new Button({
                    type: Button.TYPE.SECONDARY,
                    display: "Run Linter",
                    clickEventName: PRIVATE_EVENTS.RUN_LINTER
                })
            },
            {
                autoFixCheckbox: new FormCheckbox({
                    display: "Fix Issues",
                    valueChangeEventName:
                        PRIVATE_EVENTS.AUTOFIX_SELECTION_CHANGE
                })
            }
        ];
    }

    propChangeHandlers() {
        return {
            isRunning: isRunning => {
                this.getChild("runLintingButton").setProp(
                    "disabled",
                    isRunning
                );
            }
        };
    }

    afterCreate() {
        this.onUpstream(EVENTS.STARTUP, () => {
            this.stopPropagation(EVENTS.STARTUP);

            checkConfigPath(this).then(path => {
                runLinter(this, {
                    lintPath: path,
                    autoFix: this.getProp("isFixIssuesSelected")
                });
            });
        });

        // Click handler for the last cell in the tables to link to relevant eslint rule pages
        this.on(CELL_ANCHOR_CLICK, (anchor, key) => clickCellLink(key));

        this.on(PRIVATE_EVENTS.RUN_LINTER, () => {
            checkConfigPath(this).then(path => {
                runLinter(this, {
                    lintPath: path,
                    autoFix: this.getProp("isFixIssuesSelected")
                });
            });
        });

        this.on(
            PRIVATE_EVENTS.AUTOFIX_SELECTION_CHANGE,
            (context, { value, isValid }) => {
                this.stopPropagation(PRIVATE_EVENTS.AUTOFIX_SELECTION_CHANGE);
                this.setProp("isFixIssuesSelected", value);
            }
        );
    }

    view(el, props, children, mappedChildren) {
        return el("div", { class: "linter-report-spacing" }, [
            props.showTable ? mappedChildren.reportBanner.render() : null,
            mappedChildren.spinner.render(),
            props.showError ? mappedChildren.alertBanner.render() : null,
            el("div", { class: "mpageui-u-flexgrid-row" }, [
                el("span", { class: "mpageui-u-pad-relative-tight" }, [
                    mappedChildren.autoFixCheckbox.render()
                ]),
                el("span", { class: "mpageui-u-pad-bottom-relative-base" }, [
                    mappedChildren.runLintingButton.render()
                ])
            ]),
            props.showTable &&
            mappedChildren.outputTable.getProp("subSections").length > 0
                ? mappedChildren.outputTable.render()
                : null
        ]);
    }
}

export default {
    label: "MPages Linter",
    control: Linter,
    showHelp: true
};
