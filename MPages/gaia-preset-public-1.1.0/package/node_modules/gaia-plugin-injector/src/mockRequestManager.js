const path = require("path");
const fs = require("fs");
const chalk = require("chalk");
const { RECORD_STATES } = require("./constants");

/**
 * handleMocks is used to initialize the mockCollection class and return the entire mock collection object.
 * @param {object} config - Configuration of the current route (located in gaia.json).
 * @param {object} args - The plugin arguments
 * @param {object} url - The URL for the current request
 * @returns {object} - The mocked up JSON object that matches the provided request.
 */
const getMatchingMockRequest = (config, args, url, recordingState) => {
    try {
        if (recordingState !== RECORD_STATES.REPLAY) {
            return undefined;
        }
        const cwd = args && args.cwd;
        const requestName = getReportNameFromUrl(url);
        const mockFileLocation = config && config.mockResponses && config.mockResponses.mockResponseLocation;
        const mockCollectionName = config && config.mockResponses && config.mockResponses.mockCollectionName;
        const testCollectionJSON = parseMockResponseCollection(cwd, mockFileLocation);
        const mockResponseCollection = testCollectionJSON &&
            searchMocksCollection(testCollectionJSON[Object.keys(testCollectionJSON)[0]], "collectionName", mockCollectionName);
        return mockResponseCollection
            ? searchMocksCollection(mockResponseCollection.responseCollection, "scriptName", requestName)
            : undefined;
    }
    catch (error) {
        console.log(` ${chalk.bgRed('*** Error in Injector:route:handleMocks: ')}  ${error.message}. `);
    }
};

/**
 * Returns the name of executed CCL report based on the current request
 * @param  {String} req URL or parameters for report being executed
 * @return {String}     CCL Report attempting to be executed
 */
const getReportNameFromUrl = (url) => {
    const reportString = "reports/";
    return url.substring(url.indexOf(reportString) + reportString.length);
};

/**
 * Returns a parsed mocked object based on a static JSON file.
 * Example Structure:
 * {
          "tests": [
            {
              "testType": "graybox",
              "collectionName": "scriptFailure",
              "responseCollection": [{
                "scriptName": "MP_RETRIEVE_DOCUMENTS_JSON_DP",
                "parameterarray": "^MINE^,1073923.0,1049884.0,3038002.0,0,value(4002293.0,4003743.0),0.0,1119.0,0,0,0,1",
                "response": {}
              }]
            }
          ]
      }
 * @returns {object} parsed JSON content of static file location
 */
const parseMockResponseCollection = (cwd = "", mockFileLocation = "") => {
    return fs.existsSync(path.resolve(cwd, mockFileLocation)) &&
        JSON.parse(fs.readFileSync(mockFileLocation, 'utf8'));
};

/**
 * Returns an array of mocked responses based on the collectionName property.
 * @param {array} sourceCollection - The array of objects to search.
 * @param {string} sourceCollectionKey - lookup key of a collection.
 * @param {string} targetCollectionName - target value of a collection.
 * @returns {object} targeted collection
 */
const searchMocksCollection = ((sourceCollection = [], sourceCollectionKey = "", targetCollectionName = "") =>
    sourceCollection.find((testCollection) => {
            return testCollection[sourceCollectionKey] === targetCollectionName
        }
    ));

/**
 * Generates JSON Array containing request/response details for the current workflow
 * @param  {String} collectionName   The name of the collection to save the requests/responses as
 * @param  {Array<Object>} capturedRequests Array of objects containing details for captured requests
 * @return {Object}                  Object containing details for the recorded test collection
 */
const generateTest = (collectionName, capturedRequests) => {
    const testJson = {
        collectionName: collectionName,
        responseCollection: [],
        testType: "recorded"
    };
    testJson.responseCollection = capturedRequests.map((captured) => {
        return createRequestJSON(captured);
    });
    return testJson;
};

/**
 * Generates the object containing mock data details for the captured request/response
 * @param  {Object} captured Object containing captured request/response details
 * @return {Object}          Object containing details for use in test collection to replay the request with mock data
 */
const createRequestJSON = (captured) => {
    const responseObject = {
        scriptName: captured.script,
        parameterarray: captured.params,
        response: captured.response,
        latency: 0
    }
    return responseObject;
};

/**
 * Handles saving the current request/reply collection to the file
 * @param {object} config - Configuration of the current route (located in gaia.json).
 * @param {object} args - The plugin arguments
 * @returns {object} - The mocked up JSON object that matches the provided request.
 */
const writeMockFileCollection = (config, args, capturedRequests) => {
    const cwd = args && args.cwd;
    const mockFileLocation = config && config.mockResponses && config.mockResponses.mockResponseLocation;
    const mockCollectionName = config && config.mockResponses && config.mockResponses.mockCollectionName;
    const collectionName = args.collectionName;
    const testCollectionJSON = fileExists(cwd, mockFileLocation) ? JSON.parse(fs.readFileSync(mockFileLocation)) : generateTestCollection(collectionName);
    const currentTestCollection = generateTest(collectionName, capturedRequests);
    testCollectionJSON.tests.push(currentTestCollection);
    fs.writeFileSync(mockFileLocation, JSON.stringify(testCollectionJSON, null, 4), "utf8");
    return testCollectionJSON;
};

/**
 * Creates the base structure for a test collection.  Utilized if test collection is not present in directory
 * @return {Object} Object representing test collection
 */
const generateTestCollection = () => {
    return {
        "tests": []
    }
};

/**
 * Verify that a  file exists.  This function will resolve the file path to support realative filepaths.
 * @param {string} cwd - current working directory.
 * @param {string} filePath - targeted filepath of the mocked JSON objects
 * @returns {boolean} true if the file exists.
 */
const fileExists = (cwd, filePath) => {
    return typeof filePath === "string"
        ? fs.existsSync(path.resolve(cwd, filePath))
        : false;
};

module.exports = {
    getMatchingMockRequest,
    getReportNameFromUrl,
    writeMockFileCollection
};