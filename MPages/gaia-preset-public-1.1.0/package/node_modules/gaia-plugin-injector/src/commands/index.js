const path = require("path");
const fs = require("fs");
const route = require("../route");
const { readConfig, saveConfig } = require("./config");
const { RECORD_STATES } = require("../constants");
const { writeMockFileCollection } = require("../mockRequestManager");

const readSettings = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) => config.settings
            ? Promise.resolve(config.settings)
            : Promise.resolve({})
    );

const saveSettings = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) =>
            saveConfig(
                gaia,
                args,
                Object.assign(config, {
                    settings: args.settings
                })
            )
    );

const readUrls = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) => config.urls
            ? Promise.resolve(config.urls)
            : Promise.resolve({})
    );

const saveUrls = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) =>
            saveConfig(
                gaia,
                args,
                Object.assign(config, {
                    urls: args.urls
                })
            )
    );


/**
 * Parses the file collection in the specified location to return corresponding JSON structure
 * @param {String}  cwd          Working directory where command is being executed from
 * @param  {String} fileLocation Path where the JSON file for test collection is located
 * @return {JSON}                JSON containing test collection
 */
const parseCollectionFromLocation = (cwd, fileLocation) =>
    fileLocation && fs.existsSync(path.resolve(cwd, fileLocation))
                ? JSON.parse(fs.readFileSync(path.resolve(cwd, fileLocation), 'utf8'))
                : null;

const readMockCollection = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) => {
            const fileLocation = config && config.mockResponses && config.mockResponses.mockResponseLocation;
            return parseCollectionFromLocation(args.cwd, fileLocation);
        }
    );


const readMockResponses = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) => {
            return config.mockResponses
            ? Promise.resolve(config.mockResponses)
            : Promise.resolve({})}
    );

/**
 * Reads the mock response collection file set in the injector settings and returns formatted array for select box.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Gaia arguments
 * @returns {array} Array of collection names.
 */
const retrieveMockResponseCollectionNames = (gaia, args) => (
    readMockCollection(gaia, args).then(
        (mockResponseCollection) => {
            return mockResponseCollection
                ? mockResponseCollection[Object.keys(mockResponseCollection)[0]].map((x, index) => ({
                display: x.collectionName,
                id: x.collectionName
            }))
                : [];
        })
);

/**
 * Reads the mock response collection file set in the injector settings and returns formatted array for select box.
 * @param {Object} gaia - Gaia context.
 * @param {string} args - Gaia arguments
 * @returns {array} Array of collection names.
 */
const readFullMockSettings = (gaia, args, state) =>
    readMockResponses(gaia, args)
        .then(mockResponseConfig => retrieveMockResponseCollectionNames(gaia, args)
            .then(collectionNames => Object.assign({}, mockResponseConfig, {"mockCollectionNames": collectionNames}, {"recordState": state.recordingState}))
        );

/**
 * Saves the mock responses
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Gaia arguments
 * @return {Promise}
 */
const saveMockResponses = (gaia, args) =>
    readConfig(gaia, args).then(
        (config) => {
            const mergedResponses = Object.assign({}, config.mockResponses, args);
            // If the saved current collection does not match one in the current file location, set to first test found in collection.  This is done so that the current collection matches current file.
            const currentCollection = parseCollectionFromLocation(args.cwd, mergedResponses.mockResponseLocation);
            const matchingTestCollection = currentCollection && currentCollection.tests.find(test => test.collectionName === mergedResponses.mockCollectionName);
            if (!matchingTestCollection && currentCollection && currentCollection.tests.length > 0) {
                mergedResponses.mockCollectionName = currentCollection.tests[0].collectionName;
            }
            return saveConfig(
                gaia,
                args,
                Object.assign(config, {
                    mockResponses: {
                        mockResponseLocation: mergedResponses.mockResponseLocation,
                        mockCollectionName: mergedResponses.mockCollectionName
                    }
                })
            )
        }
    );

const saveCollection = (gaia, args, state) =>
      readConfig(gaia, args, state).then(
          (config) => {
            // Save the captured requests to file and start new recording session
            writeMockFileCollection(config, args, state.recorder.getCapturedRequests());
            state.recorder.startRecording();
          }
      );

const changeRecordState = (gaia, args, state) =>
      readConfig(gaia, args).then(
          (config) => {
            const recordState = args.recordState;
            const recorder = state.recorder;
            state.recordingState = recordState;
            if (recordState === RECORD_STATES.RECORD) {
                recorder.startRecording();
            }
            else {
                recorder.stopRecording();
            }
          }
      );


module.exports = {
    readSettings,
    saveSettings,
    readUrls,
    saveUrls,
    readConfig,
    readMockCollection,
    readMockResponses,
    saveMockResponses,
    saveCollection,
    changeRecordState,
    retrieveMockResponseCollectionNames,
    readFullMockSettings
};
