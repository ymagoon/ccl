import * as Fusion from "MPageFusion";
import { runCommand, rootUrl } from "Gaia";
import StaticContentInput from "./driver-config/StaticContentInput";
import CCLProgramInput from "./driver-config/CCLProgramInput";
import ProgramParamsInput from "./driver-config/program-params/ProgramParamsInput";
import WebserviceURL from "./driver-config/WebserviceURL";
import SourceCodeLocationInput from "./artifact-config/SourceCodeLocationInput";
import CSSLocationInput from "./artifact-config/CSSLocationInput";
import I18nLocationInput from "./artifact-config/I18nLocationInput";
import BedrockMocks from "./mocks-config/BedrockMocks";
import SaveConfigButton from "./launch-pad/SaveConfigButton";
import LaunchButton from "./launch-pad/LaunchButton";
import WebpackSettings from "./artifact-config/WebpackSettings";
import AuthModal from "./mil-proxy/AuthModal";
import DataRetrievalSettings from "./mocks-config/DataRetrievalSettings";

import {
    CONFIG_SAVE_IN_PROGRESS,
    DISPATCH,
    PERFORM_LAUNCH,
    SAVE_CONFIG,
    MOCK_REFRESH_COLLECTION,
    MOCK_RESPONSE_COLLECTION_NAMES,
    REQUEST_LAUNCH,
    saveAllConfig,
    retrieveMockResponseCollectionNames
} from "./actions";
import { liveDevState } from "./state";
const ContentHeader = Fusion.atomic.header.ContentHeader;
import "../../styles/LiveDev.less";
import "../../styles/ParamParser.less";


/**
 * Small helper to render a header.
 * @param {String} title - The title of the header.
 * @returns {VDom} Rendered header.
 */
const header = (title) => (new ContentHeader({ title }).render());

/**
 * Small helper to wait a specified amount of time.
 * @param {Number} time - Amount of time (in ms) to wait.
 * @returns {Promise} Resolved after the time.
 */
const wait = (time) => new Promise((resolve, reject) => {
    setTimeout(resolve, time);
});

/**
 * Indicates a save is in progress.
 * @param {LiveDevPlugin} ctrl - The root plugin control.
 * @returns {Promise} Resolved after the event is emitted.
 */
const startSave = (ctrl) => new Promise((resolve, reject) => {
    ctrl.emit(DISPATCH, {
        type: CONFIG_SAVE_IN_PROGRESS,
        payload: { isSaveInProgress: true }
    });
    resolve();
});

/**
 * Indicates a save has ended.
 * @param {LiveDevPlugin} ctrl - The root plugin control.
 * @returns {Promise} Resolved after the event is emitted.
 */
const endSave = (ctrl) => new Promise((resolve, reject) => {
    ctrl.emit(DISPATCH, {
        type: CONFIG_SAVE_IN_PROGRESS,
        payload: { isSaveInProgress: false }
    });
    resolve();
});

/**
 * Attempts to start the millennium proxy, if it is not already running.
 * @returns {Promise} Resolved when the proxy is running.
 */
const attemptProxyStart = () =>
    runCommand("milproxy", "status")
        .then((res) => res.isRunning ? Promise.resolve() : runCommand("milproxy", "start"));

/**
 * Attempts to login to the millennium proxy.
 * @param {Object} auth - Current auth credentials.
 * @returns {Promise} Resolved after login attempt.
 */
const attemptProxyLogin = (auth) =>
    runCommand(
        "milproxy",
        "login",
        auth
    );

/**
 * Performs necessary steps to start the webpack development server for the currently selected webpack target.
 * If webpack is not enabled, simply resolve. Otherwise, check if a webpack dev server is already running
 * and if so, kill it. Afterwards, spin up the new webpack dev server for the selected webpack target.
 * @param {Boolean} isWebpackEnabled - Whether webpack is enabled or not.
 * @param {String} webpackTarget - The current webpack target id.
 * @returns {Promise} Resolved when webpack setup is complete.
 */
const attemptWebpackStart = ({ isWebpackEnabled, webpackTarget }) => {
    if (!isWebpackEnabled) {
        return Promise.resolve();
    }
    return runCommand(
        "webpack",
        "devServerStatus"
    ).then((res) => {
        return (res.isRunning ? runCommand("webpack", "stopDevServer") : Promise.resolve()).then(runCommand(
            "webpack",
            "startDevServer",
            { target: webpackTarget }
        ))
    });
};

/**
 * Helper that takes necessary steps prior to launching a development URL.
 * @param {Object} auth - The auth state (credentials).
 * @param {Boolean} isWebpackEnabled - If webpack is enabled or not.
 * @param {String} webpackTarget - The current webpack target.
 * @returns {Promise} Resolved when the preparations have been made.
 */
const prepareLaunch =
    ({
         auth,
         isWebpackEnabled,
         webpackTarget,
         webServiceUrl
     }) =>
        attemptProxyStart()
            .then(() => attemptWebpackStart({ isWebpackEnabled, webpackTarget }))
            .then(() => !webServiceUrl ? attemptProxyLogin(auth) : Promise.resolve());


/**
 * Launches the URL
 * @param {LiveDevPlugin} control the livedev control
 * @returns {Promise} promise that is resolved once it has been launched
 */
const performLaunch = (control) =>
    startSave(control)
        .then(() => saveAllConfig(control._state))
        .then(() => wait(500))
        .then(() => endSave(control))
        .then(() => prepareLaunch({
            auth: control._state.auth,
            isWebpackEnabled: control._state.artifactConfig.isWebpackEnabled,
            webpackTarget: control._state.artifactConfig.webpackTarget,
            webServiceUrl: control._state.webServiceUrl
        }))
        .then(() => {
            control.setState({ isRequestingLaunch: false }).update();

            window.open(buildUrl({
                cclProgram: control._state.cclProgram,
                programParams: control._state.programParams
            }));
        });

/**
 * Helper to build the URL that is launched.
 * @param {String} cclProgram - The CCL program.
 * @param {String} programParams - The program params.
 * @returns {String} The url to be launched.
 */
const buildUrl =
    ({ cclProgram, programParams }) =>
      `${rootUrl()}/api/routes/injector/inject/reports/${cclProgram}?parameters=${programParams}`
      .replace("$STATIC_CONTENT$", `${rootUrl()}/api/routes/contentserver/content/staticContent`);

/**
 * The top-level UI class for the livedev plugin. This plugin acts as the root
 * and manages the state for the various pieces of UI contained within the plugin.
 * @class LiveDevPlugin
 */
class LiveDevPlugin extends Fusion.UIComponent {
    /**
     * @inheritDoc
     */
    initialState() {
        return liveDevState(undefined, { type: "preload" });
    }

    /**
     * @inheritDoc
     */
    createChildren() {
        return [
            { staticContent: new StaticContentInput() },
            { cclProgram: new CCLProgramInput() },
            { programParams: new ProgramParamsInput() },
            { webServiceUrl: new WebserviceURL() },
            { cssLocation: new CSSLocationInput() },
            { i18nLocation: new I18nLocationInput() },
            { bedrockMocks: new BedrockMocks() },
            { sourceCode: new SourceCodeLocationInput() },
            { saveConfigButton: new SaveConfigButton({ disabled: false }) },
            { launchButton: new LaunchButton() },
            { webpackSettings: new WebpackSettings() },
            { authModal: new AuthModal() },
            { dataRetrievalSettings: new DataRetrievalSettings()}
        ];
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        /*
         * Retrieve initial state
         */
        runCommand(
            "livedev",
            "retrieveSettings"
        ).then((settings) => {
            this.setState({
                cclProgram: settings.cclProgram,
                cssLocation: settings.cssLocation,
                i18nLocation: settings.i18nLocation,
                bedrockMocksLocation: settings.bedrockMocksLocation,
                isBedrockEnabled: settings.isBedrockEnabled,
                programParams: settings.programParams,
                sourceCodeLocation: settings.sourceCodeLocation,
                staticContentLocation: settings.staticContentLocation,
                webServiceUrl: settings.webServiceUrl,
                artifactConfig: {
                    isWebpackEnabled: !!(settings.isWebpackEnabled && Object.keys(settings.webpackTargets).length),
                    isWebpackAutoRefreshEnabled: settings.isWebpackAutoRefreshEnabled,
                    webpackTarget: Object.keys(settings.webpackTargets).length ? (Object.keys(settings.webpackTargets)[ 0 ]) : "",
                    webpackTargets: settings.webpackTargets
                },
                mockResponseLocation: settings.mockResponseLocation,
                mockResponseCollectionNames: settings.mockCollectionNames,
                mockResponseCollection: settings.mockResponseCollection,
                recordMode: settings.recordMode,
                auth: {
                    username: settings.username,
                    domain: settings.domain
                }
            });
            this.update();
        });

        this.on(DISPATCH, (payload) => {
            this.setState(liveDevState(this._state, payload)).update();

            // perform a launch directly if the web service url is set
            // this is needed because we don't need a login when using
            // the mpages web service
            if (payload.type == REQUEST_LAUNCH && this._state.webServiceUrl) {
                performLaunch(this);
            }
        });

        this.on(PERFORM_LAUNCH, performLaunch.bind(null, this));

        this.on(MOCK_REFRESH_COLLECTION, (payload) => {
            retrieveMockResponseCollectionNames(payload).then ((names) => {
                this.emit(DISPATCH, {
                    type: MOCK_RESPONSE_COLLECTION_NAMES,
                    payload: names
                });
            })
        });

        this.on(SAVE_CONFIG, () => {
            startSave(this)
                .then(() => saveAllConfig(this._state))
                .then(() => wait(500))
                .then(() => endSave(this));
        });
    }

    /**
     * @inheritDoc
     */
    beforeRender({ nextState }) {
        /*
         * State is owned by this top-level control, so begin
         * forwarding state down to the child controls.
         */
        this.getChild("staticContent").setProps({
            value: nextState.staticContentLocation
        });
        this.getChild("cclProgram").setProps({
            value: nextState.cclProgram
        });
        this.getChild("programParams").setProps({
            value: nextState.programParams
        });
        this.getChild("webServiceUrl").setProps({
            value: nextState.webServiceUrl
        });
        this.getChild("i18nLocation").setProps({
            value: nextState.i18nLocation
        });
        this.getChild("sourceCode").setProps({
            isDisabled: nextState.artifactConfig.isWebpackEnabled,
            value: nextState.sourceCodeLocation
        });
        this.getChild("cssLocation").setProps({
            isDisabled: nextState.artifactConfig.isWebpackEnabled,
            value: nextState.cssLocation
        });
        this.getChild("bedrockMocks").setProps({
            isBedrockEnabled: nextState.isBedrockEnabled,
            isLocationEnabled: nextState.isBedrockEnabled,
            value: nextState.bedrockMocksLocation
        });
        this.getChild("saveConfigButton").setProps({
            disabled: nextState.isSavingConfig,
            display: (nextState.isSavingConfig ? "Saving..." : "Save Configuration")
        });
        this.getChild("webpackSettings").setProps({
            isWebpackEnabled: nextState.artifactConfig.isWebpackEnabled,
            isWebpackAutoRefreshEnabled: nextState.artifactConfig.isWebpackAutoRefreshEnabled,
            webpackTargets: nextState.artifactConfig.webpackTargets,
            webpackTarget: nextState.artifactConfig.webpackTarget
        });
        this.getChild("authModal").setProps({
            isVisible: nextState.isRequestingLaunch && !nextState.webServiceUrl,
            username: nextState.auth.username,
            domain: nextState.auth.domain
        });
        this.getChild("dataRetrievalSettings").setProps({
            recordMode: nextState.recordMode,
            mockResponseLocation: nextState.mockResponseLocation,
            mockResponseCollectionNames: nextState.mockResponseCollectionNames,
            mockResponseCollection: nextState.mockResponseCollection
        });
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped, { state }) {
        return el(
            "div",
            {
                key: "livedev",
                class: "gaia-plugin-LiveDev gaia-root-section"
            },
            header("Driver Config"),
            el(
                "section",
                {
                    class: "gaia-plugin-LiveDev-section gaia-section"
                },
                [
                    mapped.staticContent.render(),
                    mapped.cclProgram.render(),
                    mapped.programParams.render(),
                    mapped.webServiceUrl.render()
                ]
            ),
            el("hr", {}),
            header("Artifact Config"),
            el(
                "section",
                {
                    class: "gaia-plugin-LiveDev-section gaia-section"
                },
                [
                    mapped.i18nLocation.render(),
                    mapped.webpackSettings.render(),
                    mapped.sourceCode.render(),
                    mapped.cssLocation.render()
                ]
            ),
            el("hr", {}),
            header("Data Retrieval Settings"),
            el(
                "section",
                {
                    class: "gaia-plugin-LiveDev-section gaia-section"
                },
                [
                    mapped.dataRetrievalSettings.render(),
                    mapped.bedrockMocks.render()
                ]
            ),
            el("hr", {}),
            header("Launch Pad"),
            el(
                "section",
                {
                    class: "gaia-plugin-LiveDev-section gaia-plugin-LiveDev-LaunchPad gaia-section"
                },
                [
                    el(
                        "details",
                        {},
                        el("summary", {}, "Launch URL"),
                        buildUrl({ cclProgram: state.cclProgram, programParams: state.programParams })
                    ),
                    mapped.saveConfigButton.render(),
                    mapped.launchButton.render(),
                    mapped.authModal.render()
                ]
            )
        );
    }
}

export default {
    label: "Live Dev",
    control: LiveDevPlugin,
    showHelp: true
};
