/**
 * MPAGES
 * @description This plugin is simply a skeleton plugin that allows us to trick ckeditor. This plugin will eventually be
 * a concatenation of ALL necessary ckeditor plugins. This way, we can simply download one plugin.js file and cut
 * down on the front-to-back time by limiting file requests.
 */
(function () {
	CKEDITOR.plugins.add('mpage-master-plugin', {
		lang: 'en,en-au,en-gb,de,fr,es,pt-br',
		init: function (editor) {
		}
	});
})();

/**
 * MPages
 * Overwrite the cerndyndocbasicstyles plugin (required by cerndyndocjustify) to do nothing. MPages does not need
 * this plugin
 */
CKEDITOR.plugins.add('cerndyndocbasicstyles', {
	init: function (editor) {
		logger.logWarning("MPages has overridden the cerndyndocbasicstyles plugin to do nothing.");
	}
});

/**
 * MPages
 * Overwrite the cerndyndocbasicstyles plugin (required by cerndyndocjustify) to do nothing. MPages does not need
 * this plugin
 */
CKEDITOR.plugins.add('cerndyndoccommon', {
	init: function (editor) {
		logger.logWarning("MPages has overridden the cerndyndoccommon plugin to do nothing.");
	}
});

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "sourcearea" plugin. It registers the "source" editing
 *		mode, which displays the raw data being edited in the editor.
 */

(function() {
	CKEDITOR.plugins.add( 'sourcearea', {
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		icons: 'source,source-rtl', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			// Source mode isn't available in inline mode yet.
			if ( editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE )
				return;

			var sourcearea = CKEDITOR.plugins.sourcearea;

			editor.addMode( 'source', function( callback ) {
				var contentsSpace = editor.ui.space( 'contents' ),
					textarea = contentsSpace.getDocument().createElement( 'textarea' );

				textarea.setStyles(
					CKEDITOR.tools.extend({
						// IE7 has overflow the <textarea> from wrapping table cell.
						width: CKEDITOR.env.ie7Compat ? '99%' : '100%',
						height: '100%',
						resize: 'none',
						outline: 'none',
						'text-align': 'left'
					},
					CKEDITOR.tools.cssVendorPrefix( 'tab-size', editor.config.sourceAreaTabSize || 4 ) ) );

				// Make sure that source code is always displayed LTR,
				// regardless of editor language (#10105).
				textarea.setAttribute( 'dir', 'ltr' );

				textarea.addClass( 'cke_source cke_reset cke_enable_context_menu' );

				editor.ui.space( 'contents' ).append( textarea );

				var editable = editor.editable( new sourceEditable( editor, textarea ) );

				// Fill the textarea with the current editor data.
				editable.setData( editor.getData( 1 ) );

				// Having to make <textarea> fixed sized to conquer the following bugs:
				// 1. The textarea height/width='100%' doesn't constraint to the 'td' in IE6/7.
				// 2. Unexpected vertical-scrolling behavior happens whenever focus is moving out of editor
				// if text content within it has overflowed. (#4762)
				if ( CKEDITOR.env.ie ) {
					editable.attachListener( editor, 'resize', onResize, editable );
					editable.attachListener( CKEDITOR.document.getWindow(), 'resize', onResize, editable );
					CKEDITOR.tools.setTimeout( onResize, 0, editable );
				}

				editor.fire( 'ariaWidget', this );

				callback();
			});

			editor.addCommand( 'source', sourcearea.commands.source );

			if ( editor.ui.addButton ) {
				editor.ui.addButton( 'Source', {
					label: editor.lang.sourcearea.toolbar,
					command: 'source',
					toolbar: 'mode,10'
				});
			}

			editor.on( 'mode', function() {
				editor.getCommand( 'source' ).setState( editor.mode == 'source' ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );
			});

			function onResize() {
				// Holder rectange size is stretched by textarea,
				// so hide it just for a moment.
				this.hide();
				this.setStyle( 'height', this.getParent().$.clientHeight + 'px' );
				this.setStyle( 'width', this.getParent().$.clientWidth + 'px' );
				// When we have proper holder size, show textarea again.
				this.show();
			}
		}
	});

	var sourceEditable = CKEDITOR.tools.createClass({
		base: CKEDITOR.editable,
		proto: {
			setData: function( data ) {
				this.setValue( data );
				this.editor.fire( 'dataReady' );
			},

			getData: function() {
				return this.getValue();
			},

			// Insertions are not supported in source editable.
			insertHtml: function() {},
			insertElement: function() {},
			insertText: function() {},

			// Read-only support for textarea.
			setReadOnly: function( isReadOnly ) {
				this[ ( isReadOnly ? 'set' : 'remove' ) + 'Attribute' ]( 'readOnly', 'readonly' );
			},

			detach: function() {
				sourceEditable.baseProto.detach.call( this );
				this.clearCustomData();
				this.remove();
			}
		}
	});
})();

CKEDITOR.plugins.sourcearea = {
	commands: {
		source: {
			modes: { wysiwyg:1,source:1 },
			editorFocus: false,
			readOnly: 1,
			exec: function( editor ) {
				if ( editor.mode == 'wysiwyg' )
					editor.fire( 'saveSnapshot' );
				editor.getCommand( 'source' ).setState( CKEDITOR.TRISTATE_DISABLED );
				editor.setMode( editor.mode == 'source' ? 'wysiwyg' : 'source' );
			},

			canUndo: false
		}
	}
};

/**
 * Controls CSS tab-size property of the sourcearea view.
 *
 * **Note:** Works only with {@link #dataIndentationChars}
 * set to `'\t'`. Please consider that not all browsers support CSS
 * `tab-size` property yet.
 *
 *		// Set tab-size to 20 characters.
 *		CKEDITOR.config.sourceAreaTabSize = 20;
 *
 * @cfg {Number} [sourceAreaTabSize=4]
 * @member CKEDITOR.config
 * @see CKEDITOR.config#dataIndentationChars
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "elementspath" plugin. It shows all elements in the DOM
 *		parent tree relative to the current selection in the editing area.
 */

(function() {
	var commands = {
		toolbarFocus: {
			editorFocus: false,
			readOnly: 1,
			exec: function( editor ) {
				var idBase = editor._.elementsPath.idBase;
				var element = CKEDITOR.document.getById( idBase + '0' );

				// Make the first button focus accessible for IE. (#3417)
				// Adobe AIR instead need while of delay.
				element && element.focus( CKEDITOR.env.ie || CKEDITOR.env.air );
			}
		}
	};

	var emptyHtml = '<span class="cke_path_empty">&nbsp;</span>';

	var extra = '';

	// Some browsers don't cancel key events in the keydown but in the
	// keypress.
	// TODO: Check if really needed for Gecko+Mac.
	if ( CKEDITOR.env.opera || ( CKEDITOR.env.gecko && CKEDITOR.env.mac ) )
		extra += ' onkeypress="return false;"';

	// With Firefox, we need to force the button to redraw, otherwise it
	// will remain in the focus state.
	if ( CKEDITOR.env.gecko )
		extra += ' onblur="this.style.cssText = this.style.cssText;"';

	var pathItemTpl = CKEDITOR.addTemplate( 'pathItem', '<a' +
		' id="{id}"' +
		' href="{jsTitle}"' +
		' tabindex="-1"' +
		' class="cke_path_item"' +
		' title="{label}"' +
		( ( CKEDITOR.env.gecko && CKEDITOR.env.version < 10900 ) ? ' onfocus="event.preventBubble();"' : '' ) +
		extra +
		' hidefocus="true" ' +
		' onkeydown="return CKEDITOR.tools.callFunction({keyDownFn},{index}, event );"' +
		' onclick="CKEDITOR.tools.callFunction({clickFn},{index}); return false;"' +
		' role="button" aria-label="{label}">' +
		'{text}' +
		'</a>' );

	CKEDITOR.plugins.add( 'elementspath', {
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			editor.on( 'uiSpace', function( event ) {
				if ( event.data.space == 'bottom' )
					initElementsPath( editor, event.data );
			} );
		}
	} );

	function initElementsPath( editor, bottomSpaceData ) {
		var spaceId = editor.ui.spaceId( 'path' );
		var spaceElement;
		var getSpaceElement = function() {
				if ( !spaceElement )
					spaceElement = CKEDITOR.document.getById( spaceId );
				return spaceElement;
			};

		var idBase = 'cke_elementspath_' + CKEDITOR.tools.getNextNumber() + '_';

		editor._.elementsPath = { idBase: idBase, filters: [] };

		bottomSpaceData.html += '<span id="' + spaceId + '_label" class="cke_voice_label">' + editor.lang.elementspath.eleLabel + '</span>' +
			'<span id="' + spaceId + '" class="cke_path" role="group" aria-labelledby="' + spaceId + '_label">' + emptyHtml + '</span>';

		// Register the ui element to the focus manager.
		editor.on( 'uiReady', function() {
			var element = editor.ui.space( 'path' );
			element && editor.focusManager.add( element, 1 );
		} );

		function onClick( elementIndex ) {
			var element = editor._.elementsPath.list[ elementIndex ];
			if ( element.equals( editor.editable() ) ) {
				var range = editor.createRange();
				range.selectNodeContents( element );
				range.select();
			} else
				editor.getSelection().selectElement( element );

			// It is important to focus() *after* the above selection
			// manipulation, otherwise Firefox will have troubles. #10119
			editor.focus();
		}

		var onClickHanlder = CKEDITOR.tools.addFunction( onClick );

		var onKeyDownHandler = CKEDITOR.tools.addFunction( function( elementIndex, ev ) {
			var idBase = editor._.elementsPath.idBase,
				element;

			ev = new CKEDITOR.dom.event( ev );

			var rtl = editor.lang.dir == 'rtl';
			switch ( ev.getKeystroke() ) {
				case rtl ? 39:
					37 : // LEFT-ARROW
				case 9: // TAB
					element = CKEDITOR.document.getById( idBase + ( elementIndex + 1 ) );
					if ( !element )
						element = CKEDITOR.document.getById( idBase + '0' );
					element.focus();
					return false;

				case rtl ? 37:
					39 : // RIGHT-ARROW
				case CKEDITOR.SHIFT + 9: // SHIFT + TAB
					element = CKEDITOR.document.getById( idBase + ( elementIndex - 1 ) );
					if ( !element )
						element = CKEDITOR.document.getById( idBase + ( editor._.elementsPath.list.length - 1 ) );
					element.focus();
					return false;

				case 27: // ESC
					editor.focus();
					return false;

				case 13: // ENTER	// Opera
				case 32: // SPACE
					onClick( elementIndex );
					return false;
			}
			return true;
		} );

		editor.on( 'selectionChange', function( ev ) {
			var env = CKEDITOR.env,
				editable = editor.editable(),
				selection = ev.data.selection,
				element = selection.getStartElement(),
				html = [],
				elementsList = editor._.elementsPath.list = [],
				filters = editor._.elementsPath.filters;

			while ( element ) {
				var ignore = 0,
					name;

				if ( element.data( 'cke-display-name' ) )
					name = element.data( 'cke-display-name' );
				else if ( element.data( 'cke-real-element-type' ) )
					name = element.data( 'cke-real-element-type' );
				else
					name = element.getName();

				for ( var i = 0; i < filters.length; i++ ) {
					var ret = filters[ i ]( element, name );
					if ( ret === false ) {
						ignore = 1;
						break;
					}
					name = ret || name;
				}

				if ( !ignore ) {
					var index = elementsList.push( element ) - 1,
						label = editor.lang.elementspath.eleTitle.replace( /%1/, name );

					/* --------------------------------------------------------------------------------------------
					/*** DYNAMIC DOCUMENTATION CHANGE ***
					// What Changed:  Added option to show class names in elements path
					//--------------------------------------------------------------------------------------------*/
					var text = name;
					if (editor.config.elementsPath_showClassNames) {
						var classList = element.$.className.split(/\s+/);
						for (var i = 0; i < classList.length; i++) {
							if (classList[i])
								text += '.' + classList[i];
						}
					}

					var item = pathItemTpl.output({
						id: idBase + index,
						label: label,
						text: text,
						jsTitle: 'javascript:void(\'' + name + '\')',
						index: index,
						keyDownFn: onKeyDownHandler,
						clickFn: onClickHanlder
					} );
					html.unshift( item );

				}

				if ( element.equals( editable ) )
					break;

				element = element.getParent();
			}

			var space = getSpaceElement();
			space.setHtml( html.join( '' ) + emptyHtml );
			editor.fire( 'elementsPathUpdate', { space: space } );
		} );

		function empty() {
			spaceElement && spaceElement.setHtml( emptyHtml );
			delete editor._.elementsPath.list;
		}

		editor.on( 'readOnly', empty );
		editor.on( 'contentDomUnload', empty );

		editor.addCommand( 'elementsPathFocus', commands.toolbarFocus );
		editor.setKeystroke( CKEDITOR.ALT + 122 /*F11*/, 'elementsPathFocus' );
	}
})();

/**
 * Fired when the contents of the elementsPath are changed.
 *
 * @event elementsPathUpdate
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param data
 * @param {CKEDITOR.dom.element} data.space The elementsPath container.
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.BOLD_WEIGHT = 700;

CKEDITOR.plugins.add( 'basicstyles', {
	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
	icons: 'bold,italic,underline,strike,subscript,superscript', // %REMOVE_LINE_CORE%
	init: function( editor ) {
		var order = 0;
		// All buttons use the same code to register. So, to avoid
		// duplications, let's use this tool function.
		var addButtonCommand = function( buttonName, buttonLabel, commandName, styleDefiniton ) {
				// Disable the command if no definition is configured.
				if ( !styleDefiniton )
					return;

				var style = new CKEDITOR.style( styleDefiniton ),
					forms = contentForms[ commandName ];

				// Put the style as the most important form.
				forms.unshift( style );

				// Listen to contextual style activation.
				editor.attachStyleStateChange( style, function( state ) {
					!editor.readOnly && editor.getCommand( commandName ).setState( state );
				});

				// Create the command that can be used to apply the style.
				editor.addCommand( commandName, new CKEDITOR.styleCommand( style, {
					contentForms: forms
				} ) );

				// Register the button, if the button plugin is loaded.
				if ( editor.ui.addButton ) {
					editor.ui.addButton( buttonName, {
						label: buttonLabel,
						command: commandName,
						toolbar: 'basicstyles,' + ( order += 10 )
					});
				}
			};

		var contentForms = {
				bold: [
					'strong',
					'b',
					[ 'span', function( el ) {
						var fw = el.styles[ 'font-weight' ];
						return fw == 'bold' || +fw >= CKEDITOR.BOLD_WEIGHT;
					} ]
				],

				italic: [
					'em',
					'i',
					[ 'span', function( el ) {
						return el.styles[ 'font-style' ] == 'italic';
					} ]
				],

				underline: [
					'u',
					[ 'span', function( el ) {
						return el.styles[ 'text-decoration' ] == 'underline';
					} ]
				],

				strike: [
					's',
					'strike',
					[ 'span', function( el ) {
						return el.styles[ 'text-decoration' ] == 'line-through';
					} ]
				],

				subscript: [
					'sub'
				],

				superscript: [
					'sup'
				]
			},
			config = editor.config,
			lang = editor.lang.basicstyles;

		addButtonCommand( 'Bold', lang.bold, 'bold', config.coreStyles_bold );
		addButtonCommand( 'Italic', lang.italic, 'italic', config.coreStyles_italic );
		addButtonCommand( 'Underline', lang.underline, 'underline', config.coreStyles_underline );
		addButtonCommand( 'Strike', lang.strike, 'strike', config.coreStyles_strike );
		addButtonCommand( 'Subscript', lang.subscript, 'subscript', config.coreStyles_subscript );
		addButtonCommand( 'Superscript', lang.superscript, 'superscript', config.coreStyles_superscript );

		editor.setKeystroke( [
			[ CKEDITOR.CTRL + 66 /*B*/, 'bold' ],
			[ CKEDITOR.CTRL + 73 /*I*/, 'italic' ],
			[ CKEDITOR.CTRL + 85 /*U*/, 'underline' ]
			] );
	}
});

// Basic Inline Styles.

/**
 * The style definition that applies the **bold** style to the text.
 *
 *		config.coreStyles_bold = { element: 'b', overrides: 'strong' };
 *
 *		config.coreStyles_bold = {
 *			element: 'span',
 *			attributes: { 'class': 'Bold' }
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_bold = { element: 'strong', overrides: 'b' };
// ------------------------------------------------------------------------------------
// ***DYNAMIC DOCUMENTATION CHANGE***
// What Changed: Change bold style to use CSS instead of <strong> so that the styles (toolbar buttons) respond to
// pasted text that contains CSS `font-weight: bold`
// Testing Considerations: Paste formatted text into the editor, and make sure that bold, italics, and underline
// formatting can be removed. Try this for CSS formatted text, <strong>, <b>, <em>, <i>, <u>.
// ------------------------------------------------------------------------------------
CKEDITOR.config.coreStyles_bold = {
	element: 'span',
	styles: { 'font-weight': 'bold' }, overrides: ['b', 'strong'],
	check: function (element) {
	if (parseInt(element.getStyle('font-weight'), 10) >= CKEDITOR.BOLD_WEIGHT)
		return true;
	}
};

/**
 * The style definition that applies the *italics* style to the text.
 *
 *		config.coreStyles_italic = { element: 'i', overrides: 'em' };
 *
 *		CKEDITOR.config.coreStyles_italic = {
 *			element: 'span',
 *			attributes: { 'class': 'Italic' }
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_italic = { element: 'em', overrides: 'i' };
// ------------------------------------------------------------------------------------
// ***DYNAMIC DOCUMENTATION CHANGE***
// What Changed: Change italic style to use CSS instead of <em>
// ------------------------------------------------------------------------------------
CKEDITOR.config.coreStyles_italic = { element: 'span', styles: { 'font-style': 'italic' }, overrides: 'i' };

/**
 * The style definition that applies the <u>underline</u> style to the text.
 *
 *		CKEDITOR.config.coreStyles_underline = {
 *			element: 'span',
 *			attributes: { 'class': 'Underline' }
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_underline = { element: 'u' };
// ------------------------------------------------------------------------------------
// ***DYNAMIC DOCUMENTATION CHANGE***
// What Changed: Change underline style to use CSS instead of <u>
// ------------------------------------------------------------------------------------
CKEDITOR.config.coreStyles_underline = {
	element: 'span', styles: { 'text-decoration': 'underline' },
	overrides: 'u',
	check: function (element) {
		if (element.getStyle('text-decoration').indexOf('underline') >= 0)
			return true;
	}
};

/**
 * The style definition that applies the <strike>strike-through</strike> style to the text.
 *
 *		CKEDITOR.config.coreStyles_strike = {
 *			element: 'span',
 *			attributes: { 'class': 'StrikeThrough' },
 *			overrides: 'strike'
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_strike = { element: 's', overrides: 'strike' };
// ------------------------------------------------------------------------------------
// ***DYNAMIC DOCUMENTATION CHANGE***
// What Changed: Change strike style to use CSS instead of <s>
// ------------------------------------------------------------------------------------
CKEDITOR.config.coreStyles_strike = {
	element: 'span',
	styles: { 'text-decoration': 'line-through' },
	overrides: ['s', 'strike', 'del'],
	check: function (element) {
		if (element.getStyle('text-decoration').indexOf('line-through') >= 0)
			return true;
	}
};

/**
 * The style definition that applies the subscript style to the text.
 *
 *		CKEDITOR.config.coreStyles_subscript = {
 *			element: 'span',
 *			attributes: { 'class': 'Subscript' },
 *			overrides: 'sub'
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_subscript = { element: 'sub' };

/**
 * The style definition that applies the superscript style to the text.
 *
 *		CKEDITOR.config.coreStyles_superscript = {
 *			element: 'span',
 *			attributes: { 'class': 'Superscript' },
 *			overrides: 'sup'
 *		};
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.coreStyles_superscript = { element: 'sup' };

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @ignore
 * File overview: Clipboard support.
 */

//
// EXECUTION FLOWS:
// -- CTRL+C
//		* browser's default behaviour
// -- CTRL+V
//		* listen onKey (onkeydown)
//		* simulate 'beforepaste' for non-IEs on editable
//		* simulate 'paste' for Fx2/Opera on editable
//		* listen 'onpaste' on editable ('onbeforepaste' for IE)
//		* fire 'beforePaste' on editor
//		* !canceled && getClipboardDataByPastebin
//		* fire 'paste' on editor
//		* !canceled && fire 'afterPaste' on editor
// -- CTRL+X
//		* listen onKey (onkeydown)
//		* fire 'saveSnapshot' on editor
//		* browser's default behaviour
//		* deferred second 'saveSnapshot' event
// -- Copy command
//		* tryToCutCopy
//			* execCommand
//		* !success && alert
// -- Cut command
//		* fixCut
//		* tryToCutCopy
//			* execCommand
//		* !success && alert
// -- Paste command
//		* fire 'paste' on editable ('beforepaste' for IE)
//		* !canceled && execCommand 'paste'
//		* !success && fire 'pasteDialog' on editor
// -- Paste from native context menu & menubar
//		(Fx & Webkits are handled in 'paste' default listner.
//		Opera cannot be handled at all because it doesn't fire any events
//		Special treatment is needed for IE, for which is this part of doc)
//		* listen 'onpaste'
//		* cancel native event
//		* fire 'beforePaste' on editor
//		* !canceled && getClipboardDataByPastebin
//		* execIECommand( 'paste' ) -> this fires another 'paste' event, so cancel it
//		* fire 'paste' on editor
//		* !canceled && fire 'afterPaste' on editor
//
//
// PASTE EVENT - PREPROCESSING:
// -- Possible dataValue types: auto, text, html.
// -- Possible dataValue contents:
//		* text (possible \n\r)
//		* htmlified text (text + br,div,p - no presentional markup & attrs - depends on browser)
//		* html
// -- Possible flags:
//		* htmlified - if true then content is a HTML even if no markup inside. This flag is set
//			for content from editable pastebins, because they 'htmlify' pasted content.
//
// -- Type: auto:
//		* content: htmlified text ->	filter, unify text markup (brs, ps, divs), set type: text
//		* content: html ->				filter, set type: html
// -- Type: text:
//		* content: htmlified text ->	filter, unify text markup
//		* content: html ->				filter, strip presentional markup, unify text markup
// -- Type: html:
//		* content: htmlified text ->	filter, unify text markup
//		* content: html ->				filter
//
// -- Phases:
//		* filtering (priorities 3-5) - e.g. pastefromword filters
//		* content type sniffing (priority 6)
//		* markup transformations for text (priority 6)
//

'use strict';

(function() {
	// Register the plugin.
	CKEDITOR.plugins.add( 'clipboard', {
		requires: 'dialog',
		lang: 'en,en-au,en-gb,de,fr,es,pt-br',
		icons: 'copy,copy-rtl,cut,cut-rtl,paste,paste-rtl', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			var textificationFilter;

			initClipboard( editor );

			CKEDITOR.dialog.add( 'paste', CKEDITOR.getUrl( this.path + 'dialogs/paste.js' ) );

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Provide our own clipboard HTML
			// ------------------------------------------------------------------------------------
			if ( CKEDITOR.ClipboardHelper ) {
				editor.on( 'paste', function( evt ) {
					var dataObj = evt.data;
					var html = dataObj.dataValue || getClipboardContent();
					if ( html ) {
						dataObj.dataValue = html;
						// This pasteType will be used by cernpasteoptions to determine whether to paste using destination or source formatting
						dataObj.pasteType = dataObj.type;
						dataObj.type = 'html';
					}
				}, null, null, 1 );
			}

			editor.on( 'paste', function( evt ) {
				var data = evt.data.dataValue,
					blockElements = CKEDITOR.dtd.$block;

				// Filter webkit garbage.
				if ( data.indexOf( 'Apple-' ) > -1 ) {
					// Replace special webkit's &nbsp; with simple space, because webkit
					// produces them even for normal spaces.
					data = data.replace( /<span class="Apple-converted-space">&nbsp;<\/span>/gi, ' ' );

					// Strip <span> around white-spaces when not in forced 'html' content type.
					// This spans are created only when pasting plain text into Webkit,
					// but for safety reasons remove them always.
					if ( evt.data.type != 'html' )
						data = data.replace( /<span class="Apple-tab-span"[^>]*>([^<]*)<\/span>/gi, function( all, spaces ) {
						// Replace tabs with 4 spaces like Fx does.
						return spaces.replace( /\t/g, '&nbsp;&nbsp; &nbsp;' );
					});

					// This br is produced only when copying & pasting HTML content.
					if ( data.indexOf( '<br class="Apple-interchange-newline">' ) > -1 ) {
						evt.data.startsWithEOL = 1;
						evt.data.preSniffing = 'html'; // Mark as not text.
						data = data.replace( /<br class="Apple-interchange-newline">/, '' );
					}

					// Remove all other classes.
					data = data.replace( /(<[^>]+) class="Apple-[^"]*"/gi, '$1' );
				}

				// Strip editable that was copied from inside. (#9534)
				if ( data.match( /^<[^<]+cke_(editable|contents)/i ) ) {
					var tmp,
						editable_wrapper,
						wrapper = new CKEDITOR.dom.element( 'div' );

					wrapper.setHtml( data );
					// Verify for sure and check for nested editor UI parts. (#9675)
					while ( wrapper.getChildCount() == 1 &&
							( tmp = wrapper.getFirst() ) &&
							tmp.type == CKEDITOR.NODE_ELEMENT &&	// Make sure first-child is element.
							( tmp.hasClass( 'cke_editable' ) || tmp.hasClass( 'cke_contents' ) ) ) {
						wrapper = editable_wrapper = tmp;
					}

					// If editable wrapper was found strip it and bogus <br> (added on FF).
					if ( editable_wrapper )
						data = editable_wrapper.getHtml().replace( /<br>$/i, '' );
				}

				if ( CKEDITOR.env.ie ) {
					// &nbsp; <p> -> <p> (br.cke-pasted-remove will be removed later)
					data = data.replace( /^&nbsp;(?: |\r\n)?<(\w+)/g, function( match, elementName ) {
						if ( elementName.toLowerCase() in blockElements ) {
							evt.data.preSniffing = 'html'; // Mark as not a text.
							return '<' + elementName;
						}
						return match;
					});
				} else if ( CKEDITOR.env.webkit ) {
					// </p><div><br></div> -> </p><br>
					// We don't mark br, because this situation can happen for htmlified text too.
					data = data.replace( /<\/(\w+)><div><br><\/div>$/, function( match, elementName ) {
						if ( elementName in blockElements ) {
							evt.data.endsWithEOL = 1;
							return '</' + elementName + '>';
						}
						return match;
					});
				} else if ( CKEDITOR.env.gecko ) {
					// Firefox adds bogus <br> when user pasted text followed by space(s).
					data = data.replace( /(\s)<br>$/, '$1' );
				}

				evt.data.dataValue = data;
			}, null, null, 3 );

			editor.on( 'paste', function( evt ) {
				var dataObj = evt.data,
					type = dataObj.type,
					data = dataObj.dataValue,
					trueType,
					// Default is 'html'.
					defaultType = editor.config.clipboard_defaultContentType || 'html';

				// If forced type is 'html' we don't need to know true data type.
				if ( type == 'html' || dataObj.preSniffing == 'html' )
					trueType = 'html';
				else
					trueType = recogniseContentType( data );

				// Unify text markup.
				if ( trueType == 'htmlifiedtext' )
					data = htmlifiedTextHtmlification( editor.config, data );
				// Strip presentional markup & unify text markup.
				else if ( type == 'text' && trueType == 'html' ) {
					// Init filter only if needed and cache it.
					data = htmlTextification( editor.config, data, textificationFilter || ( textificationFilter = getTextificationFilter( editor ) ) );
				}

				if ( dataObj.startsWithEOL )
					data = '<br data-cke-eol="1">' + data;
				if ( dataObj.endsWithEOL )
					data += '<br data-cke-eol="1">';

				if ( type == 'auto' )
					type = ( trueType == 'html' || defaultType == 'html' ) ? 'html' : 'text';

				dataObj.type = type;
				dataObj.dataValue = data;
				delete dataObj.preSniffing;
				delete dataObj.startsWithEOL;
				delete dataObj.endsWithEOL;
			}, null, null, 6 );

			// Inserts processed data into the editor at the end of the
			// events chain.
			editor.on( 'paste', function( evt ) {
				var data = evt.data;

				editor.insertHtml( data.dataValue, data.type );

				// Deferr 'afterPaste' so all other listeners for 'paste' will be fired first.
				setTimeout( function() {
					editor.fire( 'afterPaste' );
				}, 0 );
			}, null, null, 1000 );

			editor.on( 'pasteDialog', function( evt ) {
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:  Disable paste dialog
				// ------------------------------------------------------------------------------------
				// This should not be called; let's log the event
				DocHandleError( 'clipboard/plugin.js - pasteDialog fired', 'DynDocCKEditor' );
				return;

				// TODO it's possible that this setTimeout is not needed any more,
				// because of changes introduced in the same commit as this comment.
				// Editor.getClipboardData adds listner to the dialog's events which are
				// fired after a while (not like 'showDialog').
				setTimeout( function() {
					// Open default paste dialog.
					editor.openDialog( 'paste', evt.data );
				}, 0 );
			});
		}
	});
	// ------------------------------------------------------------------------------------
	// ***DYNAMIC DOCUMENTATION CHANGE***
	// What Changed:  Add preserveWhitespace callback function passed to ClipboardHelper.GetClipboard2
	// ------------------------------------------------------------------------------------
	/*
	// @detail Preserve spaces in the sHtmlFragment by converting the first and last space of text nodes to NBSP
	//          and sequences of spaces will be converted to alternating NBSP + spaces.
	// @param sHtmlFragment - Html fragment preserve spaces
	*/
	function preserveWhitespace(sHtmlFragment) {
		var $fragment = $("<div>").html(sHtmlFragment);

		var getTextNodes = function (element) {
			var nodes = [];
			DDCOMMON.domDfs(element, 1, function (node) {
				if (node.nodeType === Node.TEXT_NODE)
					nodes.push(node);
			});
			return nodes;
		};

		var textNodes = getTextNodes($fragment[0]);
		for (var node in textNodes) {
			var text = textNodes[node].nodeValue;
			// replace first space with nbsp.
			if (text.charAt(0) == ' ')
				text = text.replace(' ', '\u00a0');

			// replace last space with nbsp.
			if (text.length > 1 && text.charAt(text.length - 1) == ' ')
				text = text.substring(0, text.length - 1).concat('\u00a0');

			// replace sequences of 2 or more spaces with alternating nbsp and spaces
			textNodes[node].nodeValue = text.replace(/([ ]{2,})/g, function (match) {
				var spaces = "";
				for (var i = 0; i < match.length; i++) {
					if (i % 2 == 0)
						spaces += "\u00a0";
					else
						spaces += " ";
				}
				return spaces;
			});
		}

		return $fragment.html();
	}
	// ------------------------------------------------------------------------------------
	// ***DYNAMIC DOCUMENTATION CHANGE***
	// What Changed:  add GetClipboardContent function
	// ------------------------------------------------------------------------------------
	/*
	// @detail  GetClipboard2 will be used with the preserveWhitespace callback function for IE 9 only.
	//           Otherwise use the GetClipboard call.
	*/

	function getClipboardContent() {
		return (CKEDITOR.env.ie && DDCOMMON.getIeVersionMajor() == '9') ? CKEDITOR.ClipboardHelper.GetClipboard2(preserveWhitespace) : CKEDITOR.ClipboardHelper.GetClipboard();
	}

	function initClipboard( editor ) {
		// ------------------------------------------------------------------------------------
		// ***DYNAMIC DOCUMENTATION CHANGE***
		// What Changed:  Add variable to save editor selection before opening context menu.
		//                See companion changes in contextMenu listener and in paste cmd exec.
		// ------------------------------------------------------------------------------------
		var bookmarksBeforeContextMenu = null;

		// ------------------------------------------------------------------------------------
		// ***DYNAMIC DOCUMENTATION CHANGE***
		// What Changed:  Update toolbar buttons for certain events
		// ------------------------------------------------------------------------------------
		editor.on( 'instanceReady', function() {
			var insertFreeTextCmd = editor.getCommand( DDCMD_INSERTFREETEXT );
			if ( insertFreeTextCmd ) {
				insertFreeTextCmd.on( 'afterddinsertfreetext', setToolbarStates );
			}

			var removeSectionCmd = editor.getCommand( DDCMD_REMOVEELEMENT );
			if ( removeSectionCmd ) {
				removeSectionCmd.on( 'afterddremovesection', setToolbarStates );
			}
		} );

		var preventBeforePasteEvent = 0,
			preventPasteEvent = 0,
			inReadOnly = 0,
			// Safari doesn't like 'beforepaste' event - it sometimes doesn't
			// properly handles ctrl+c. Probably some race-condition between events.
			// Chrome and Firefox works well with both events, so better to use 'paste'
			// which will handle pasting from e.g. browsers' menu bars.
			// IE7/8 doesn't like 'paste' event for which it's throwing random errors.
			mainPasteEvent = CKEDITOR.env.ie ? 'beforepaste' : 'paste';

		addListeners();
		addButtonsCommands();

		/**
		 * Gets clipboard data by directly accessing the clipboard (IE only) or opening paste dialog.
		 *
		 *		editor.getClipboardData( { title: 'Get my data' }, function( data ) {
		 *			if ( data )
		 *				alert( data.type + ' ' + data.dataValue );
		 *		} );
		 *
		 * @member CKEDITOR.editor
		 * @param {Object} options
		 * @param {String} [options.title] Title of paste dialog.
		 * @param {Function} callback Function that will be executed with `data.type` and `data.dataValue`
		 * or `null` if none of the capturing method succeeded.
		 */
		editor.getClipboardData = function( options, callback ) {
			var beforePasteNotCanceled = false,
				dataType = 'auto',
				dialogCommited = false;

			// Options are optional - args shift.
			if ( !callback ) {
				callback = options;
				options = null;
			}

			// Listen with maximum priority to handle content before everyone else.
			// This callback will handle paste event that will be fired if direct
			// access to the clipboard succeed in IE.
			editor.on( 'paste', onPaste, null, null, 0 );

			// Listen at the end of listeners chain to see if event wasn't canceled
			// and to retrieve modified data.type.
			editor.on( 'beforePaste', onBeforePaste, null, null, 1000 );

			// getClipboardDataDirectly() will fire 'beforePaste' synchronously, so we can
			// check if it was canceled and if any listener modified data.type.

			// If command didn't succeed (only IE allows to access clipboard and only if
			// user agrees) open and handle paste dialog.
			if ( getClipboardDataDirectly() === false ) {
				// Direct access to the clipboard wasn't successful so remove listener.
				editor.removeListener( 'paste', onPaste );

				// If beforePaste was canceled do not open dialog.
				// Add listeners only if dialog really opened. 'pasteDialog' can be canceled.
				if ( beforePasteNotCanceled && editor.fire( 'pasteDialog', onDialogOpen ) ) {
					editor.on( 'pasteDialogCommit', onDialogCommit );

					// 'dialogHide' will be fired after 'pasteDialogCommit'.
					editor.on( 'dialogHide', function( evt ) {
						evt.removeListener();
						evt.data.removeListener( 'pasteDialogCommit', onDialogCommit );

						// Because Opera has to wait a while in pasteDialog we have to wait here.
						setTimeout( function() {
							// Notify even if user canceled dialog (clicked 'cancel', ESC, etc).
							if ( !dialogCommited )
								callback( null );
						}, 10 );
					});
				} else
					callback( null );
			}

			function onPaste( evt ) {
				evt.removeListener();
				evt.cancel();
				callback( evt.data );
			}

			function onBeforePaste( evt ) {
				evt.removeListener();
				beforePasteNotCanceled = true;
				dataType = evt.data.type;
			}

			function onDialogCommit( evt ) {
				evt.removeListener();
				// Cancel pasteDialogCommit so paste dialog won't automatically fire
				// 'paste' evt by itself.
				evt.cancel();
				dialogCommited = true;
				callback( { type: dataType, dataValue: evt.data } );
			}

			function onDialogOpen() {
				this.customTitle = ( options && options.title );
			}
		};

		function addButtonsCommands() {
			addButtonCommand( 'Cut', 'cut', createCutCopyCmd( 'cut' ), 10, 1 );
			addButtonCommand( 'Copy', 'copy', createCutCopyCmd( 'copy' ), 20, 4 );
			addButtonCommand( 'Paste', 'paste', createPasteCmd(), 30, 8 );

			function addButtonCommand( buttonName, commandName, command, toolbarOrder, ctxMenuOrder ) {
				var lang = editor.lang.clipboard[ commandName ];

				editor.addCommand( commandName, command );
				editor.ui.addButton && editor.ui.addButton( buttonName, {
					label: lang,
					command: commandName,
					toolbar: 'clipboard,' + toolbarOrder
				});

				// If the "menu" plugin is loaded, register the menu item.
				if ( editor.addMenuItems ) {
					editor.addMenuItem( commandName, {
						label: lang,
						command: commandName,
						group: 'clipboard',
						order: ctxMenuOrder
					});
				}
			}
		}

		function addListeners() {
			editor.on( 'key', onKey );
			editor.on( 'contentDom', addListenersToEditable );

			// For improved performance, we're checking the readOnly state on selectionChange instead of hooking a key event for that.
			editor.on( 'selectionChange', function( evt ) {
				inReadOnly = evt.data.selection.getRanges()[ 0 ].checkReadOnly();
				setToolbarStates();
			});

			// If the "contextmenu" plugin is loaded, register the listeners.
			if ( editor.contextMenu ) {
				editor.contextMenu.addListener( function( element, selection ) {
					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Save editor selection before opening the context menu.  See companion
					//                change in paste cmd exec.
					// ------------------------------------------------------------------------------------
					bookmarksBeforeContextMenu = selection.createBookmarks2();

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Check for no ranges in selection
					// Test case:
					//  1. Without highlighting any text, right-click read-only text.
					// Result:  Javascript exception is thrown when trying to access checkReadOnly of null
					// ------------------------------------------------------------------------------------
					var ranges = selection.getRanges();
					inReadOnly = ranges.length ? selection.getRanges()[ 0 ].checkReadOnly() : false;

					var states = {
						cut: stateFromNamedCommand( 'Cut' ),
						copy: stateFromNamedCommand( 'Copy' ),
						paste: stateFromNamedCommand( 'Paste' )
					};
					if (editor.getCommand('pastetext')) {
						states.pastetext = stateFromNamedCommand( 'PasteText' );
					}
					return states;
				});

				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:  Select the bookmarks that were saved when opening the context menu.
				// ------------------------------------------------------------------------------------
				// Use override in case someone else defined onHide
				//Enabling the hide event handler,because editor selection restore is required
				//otherwise paste from context menu will not work properly
				//Work-flow:
				//  1. Select(highlight) a text in editor.
				//  2. Right click and perform paste (paste from context menu)
				// Previously highlighted text is not replaced with clipboard content,because selection is not restored.
				editor.contextMenu.onHide = CKEDITOR.tools.override( editor.contextMenu.onHide || (function() {}), function( fnOrig ) {
					return function() {
						var selection = editor.getSelection();
						selection && bookmarksBeforeContextMenu && selection.selectBookmarks( bookmarksBeforeContextMenu );
						bookmarksBeforeContextMenu = null;

						// Call original function
						if ( fnOrig && fnOrig.apply )
							fnOrig.apply( this, arguments );
					}
				} );
			}
		}

		// Add events listeners to editable.
		function addListenersToEditable() {
			var editable = editor.editable();

			// We'll be catching all pasted content in one line, regardless of whether
			// it's introduced by a document command execution (e.g. toolbar buttons) or
			// user paste behaviors (e.g. CTRL+V).
			editable.on( mainPasteEvent, function( evt ) {
				if ( CKEDITOR.env.ie && preventBeforePasteEvent )
					return;

				// If you've just asked yourself why preventPasteEventNow() is not here, but
				// in listener for CTRL+V and exec method of 'paste' command
				// you've asked the same question we did.
				//
				// THE ANSWER:
				//
				// First thing to notice - this answer makes sense only for IE,
				// because other browsers don't listen for 'paste' event.
				//
				// What would happen if we move preventPasteEventNow() here?
				// For:
				// * CTRL+V - IE fires 'beforepaste', so we prevent 'paste' and pasteDataFromClipboard(). OK.
				// * editor.execCommand( 'paste' ) - we fire 'beforepaste', so we prevent
				//		'paste' and pasteDataFromClipboard() and doc.execCommand( 'Paste' ). OK.
				// * native context menu - IE fires 'beforepaste', so we prevent 'paste', but unfortunately
				//		on IE we fail with pasteDataFromClipboard() here, because of... we don't know why, but
				//		we just fail, so... we paste nothing. FAIL.
				// * native menu bar - the same as for native context menu.
				//
				// But don't you know any way to distinguish first two cases from last two?
				// Only one - special flag set in CTRL+V handler and exec method of 'paste'
				// command. And that's what we did using preventPasteEventNow().

				pasteDataFromClipboard( evt );
			});

			// It's not possible to clearly handle all four paste methods (ctrl+v, native menu bar
			// native context menu, editor's command) in one 'paste/beforepaste' event in IE.
			//
			// For ctrl+v & editor's command it's easy to handle pasting in 'beforepaste' listener,
			// so we do this. For another two methods it's better to use 'paste' event.
			//
			// 'paste' is always being fired after 'beforepaste' (except of weird one on opening native
			// context menu), so for two methods handled in 'beforepaste' we're canceling 'paste'
			// using preventPasteEvent state.
			//
			// 'paste' event in IE is being fired before getClipboardDataByPastebin executes its callback.
			//
			// QUESTION: Why didn't you handle all 4 paste methods in handler for 'paste'?
			//		Wouldn't this just be simpler?
			// ANSWER: Then we would have to evt.data.preventDefault() only for native
			//		context menu and menu bar pastes. The same with execIECommand().
			//		That would force us to mark CTRL+V and editor's paste command with
			//		special flag, other than preventPasteEvent. But we still would have to
			//		have preventPasteEvent for the second event fired by execIECommand.
			//		Code would be longer and not cleaner.
			CKEDITOR.env.ie && editable.on( 'paste', function( evt ) {
				if ( preventPasteEvent )
					return;
				// Cancel next 'paste' event fired by execIECommand( 'paste' )
				// at the end of this callback.
				preventPasteEventNow();

				// Prevent native paste.
				evt.data.preventDefault();

				pasteDataFromClipboard( evt );

				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:  Don't execIECommand and don't open paste dialog
				// ------------------------------------------------------------------------------------
				// Force IE to paste content into pastebin so pasteDataFromClipboard will work.
				if ( false && !execIECommand( 'paste' ) )
					editor.openDialog( 'paste' );
			});

			// [IE] Dismiss the (wrong) 'beforepaste' event fired on context/toolbar menu open. (#7953)
			if ( CKEDITOR.env.ie ) {
				editable.on( 'contextmenu', preventBeforePasteEventNow, null, null, 0 );

				editable.on( 'beforepaste', function( evt ) {
					if ( evt.data && !evt.data.$.ctrlKey )
						preventBeforePasteEventNow();
				}, null, null, 0 );

			}

			editable.on( 'beforecut', function() {
				!preventBeforePasteEvent && fixCut( editor );
			});

			var mouseupTimeout;

			// Use editor.document instead of editable in non-IEs for observing mouseup
			// since editable won't fire the event if selection process started within
			// iframe and ended out of the editor (#9851).
			editable.attachListener( CKEDITOR.env.ie ? editable : editor.document.getDocumentElement(), 'mouseup', function() {
				mouseupTimeout = setTimeout( function() {
					setToolbarStates();
				}, 0 );
			});

			// Make sure that deferred mouseup callback isn't executed after editor instance
			// had been destroyed. This may happen when editor.destroy() is called in parallel
			// with mouseup event (i.e. a button with onclick callback) (#10219).
			editor.on( 'destroy', function() {
				clearTimeout( mouseupTimeout );
			});

			editable.on( 'keyup', setToolbarStates );
		}

		// Create object representing Cut or Copy commands.
		function createCutCopyCmd( type ) {
			return {
				type: type,
				canUndo: type == 'cut', // We can't undo copy to clipboard.
				startDisabled: true,
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:  Don't focus the editor
				// Focusing the editor will steal the selection if selecting read only text
				// Instead, we save a bookmark when opening the context menu and restore it in the command exec function.
				// ------------------------------------------------------------------------------------
				editorFocus: false,
				exec: function( data ) {
					// Attempts to execute the Cut and Copy operations.
					function tryToCutCopy( type ) {
						if ( CKEDITOR.env.ie )
							return execIECommand( type );

						// non-IEs part
						try {
							// Other browsers throw an error if the command is disabled.
							return editor.document.$.execCommand( type, false, null );
						} catch ( e ) {
							return false;
						}
					}

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Restore the selection prior to copying or pasting
					// Instead of focusing the read only selection, restore our saved selection from
					// prior to the context menu open.
					// ------------------------------------------------------------------------------------
					if ( bookmarksBeforeContextMenu ) {
						var selection = editor.getSelection( true );
						selection && selection.selectBookmarks( bookmarksBeforeContextMenu );
						bookmarksBeforeContextMenu = null;
					}

					this.type == 'cut' && fixCut();

					var success = tryToCutCopy( this.type );

					if ( !success )
						alert( editor.lang.clipboard[ this.type + 'Error' ] ); // Show cutError or copyError.

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Update toolbar buttons when cutting
					// NOTE:  This is a CKEditor defect.  This might not be needed after upgrading CKEditor.
					// Test case:
					//  1. Highlight some free text.
					//  2. Press the cut toolbar item
					// Result:  Cut and copy buttons should become disabled, but are not.
					// ------------------------------------------------------------------------------------
					if ( type === 'cut' )
						setToolbarStates();

					return success;
				}
			};
		}

		function createPasteCmd() {
			return {
				// Snapshots are done manually by editable.insertXXX methods.
				canUndo: false,
				async: true,

				exec: function( editor, data ) {
					var fire = function( data, withBeforePaste ) {
							data && firePasteEvents( data.type, data.dataValue, !!withBeforePaste );

							editor.fire( 'afterCommandExec', {
								name: 'paste',
								command: cmd,
								returnValue: !!data
							});
						},
						cmd = this;

					// Check data precisely - don't open dialog on empty string.
					if ( typeof data == 'string' )
						fire( { type: 'auto', dataValue: data }, 1 );
					else
						editor.getClipboardData( fire );
				}
			};
		}

		function preventPasteEventNow() {
			preventPasteEvent = 1;
			// For safety reason we should wait longer than 0/1ms.
			// We don't know how long execution of quite complex getClipboardData will take
			// and in for example 'paste' listner execCommand() (which fires 'paste') is called
			// after getClipboardData finishes.
			// Luckily, it's impossible to immediately fire another 'paste' event we want to handle,
			// because we only handle there native context menu and menu bar.
			setTimeout( function() {
				preventPasteEvent = 0;
			}, 100 );
		}

		function preventBeforePasteEventNow() {
			preventBeforePasteEvent = 1;
			setTimeout( function() {
				preventBeforePasteEvent = 0;
			}, 10 );
		}

		// Tries to execute any of the paste, cut or copy commands in IE. Returns a
		// boolean indicating that the operation succeeded.
		// @param {String} command *LOWER CASED* name of command ('paste', 'cut', 'copy').
		function execIECommand( command ) {
			var doc = editor.document,
				body = doc.getBody(),
				enabled = false,
				onExec = function() {
					enabled = true;
				};

			// The following seems to be the only reliable way to detect that
			// clipboard commands are enabled in IE. It will fire the
			// onpaste/oncut/oncopy events only if the security settings allowed
			// the command to execute.
			body.on( command, onExec );

			// IE6/7: document.execCommand has problem to paste into positioned element.
			( CKEDITOR.env.version > 7 ? doc.$ : doc.$.selection.createRange() )[ 'execCommand' ]( command );

			body.removeListener( command, onExec );

			return enabled;
		}

		function firePasteEvents( type, data, withBeforePaste ) {
			var eventData = { type: type };

			if ( withBeforePaste ) {
				// Fire 'beforePaste' event so clipboard flavor get customized
				// by other plugins.
				if ( !editor.fire( 'beforePaste', eventData ) )
					return false; // Event canceled
			}

			// The very last guard to make sure the paste has successfully happened.
			// This check should be done after firing 'beforePaste' because for native paste
			// 'beforePaste' is by default fired even for empty clipboard.
			if ( !data )
				return false;

			// Reuse eventData.type because the default one could be changed by beforePaste listeners.
			eventData.dataValue = data;

			return editor.fire( 'paste', eventData );
		}

		// Cutting off control type element in IE standards breaks the selection entirely. (#4881)
		function fixCut() {
			if ( !CKEDITOR.env.ie || CKEDITOR.env.quirks )
				return;

			var sel = editor.getSelection(),
				control, range, dummy;

			if ( ( sel.getType() == CKEDITOR.SELECTION_ELEMENT ) && ( control = sel.getSelectedElement() ) ) {
				range = sel.getRanges()[ 0 ];
				dummy = editor.document.createText( '' );
				dummy.insertBefore( control );
				range.setStartBefore( dummy );
				range.setEndAfter( control );
				sel.selectRanges( [ range ] );

				// Clear up the fix if the paste wasn't succeeded.
				setTimeout( function() {
					// Element still online?
					if ( control.getParent() ) {
						dummy.remove();
						sel.selectElement( control );
					}
				}, 0 );
			}

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// DynDoc Fix of Issue: IE 7&8 defect: When selection contains the end of free text area, the end
			//        container of selection will be the parent subsection/section node, instead of the last
			//        child node of free text element. As the section/subsection node is not content editable,
			//        it will cause cut/paste fail.
			// Solution: Insert a dummy text node with empty string, and insert the dummy node right after the
			//        end boundary node of the selection. Update the selection to let the end boundary node be the
			//        selection's end container.
			// Note: We do NOT delete the dummy node when we are done.  Cleaning up the dummy node causes a
			//        race condition with the spellcheck plugin or any other place that is using the context menu.
			//        Leaving the dummy node causes the child count of the parent freetext section to increase once
			//        every time this method is executed (provided they make it into the inner IF statement), but
			//        since the extra nodes do not change the HTML, they are all removed when you ensure the note.
			// ------------------------------------------------------------------------------------
			var ranges = sel.getRanges();
			if ( null == ranges || 0 === ranges.length )
				return;

			var boundaryNodes = ranges[0].getBoundaryNodes();

			if ( ranges[0].endContainer.type === CKEDITOR.NODE_ELEMENT ) {
				var endContClassName = ranges[0].endContainer.$.className;
				// NOTE: This is fine to keep in the generic plugin, it will just never find anything and thus won't execute...
				if ( DDCOMMON.hasClassName( endContClassName, g_sCLASS_SECTION ) || DDCOMMON.hasClassName( endContClassName, g_sCLASS_SUBSECTION ) ) {
					var range = ranges[0];
					var dummy = editor.document.createText( '' );
					dummy.insertAfter( boundaryNodes.endNode );
					range.setEndBefore( dummy );
					sel.selectRanges( [ range ] );
				}
			}
			// End of DynDoc fix
		}

		// Allow to peek clipboard content by redirecting the
		// pasting content into a temporary bin and grab the content of it.
		function getClipboardDataByPastebin( evt, callback ) {
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Only use pastebin when CKEDITOR.ClipboardHelper is not available,
			//                except to prevent double-paste
			// ------------------------------------------------------------------------------------
			var doc = editor.document,
				editable = editor.editable(),
				cancel = function( evt ) {
					evt.cancel();
				},
				ff3x = CKEDITOR.env.gecko && CKEDITOR.env.version <= 10902;

			var usePastebin = !CKEDITOR.ClipboardHelper;

			// Avoid recursions on 'paste' event or consequent paste too fast. (#5730)
			if ( doc.getById( 'cke_pastebin' ) )
				return;

			var sel = editor.getSelection();
			var bms = sel.createBookmarks();

			// Create container to paste into.
			// For rich content we prefer to use "body" since it holds
			// the least possibility to be splitted by pasted content, while this may
			// breaks the text selection on a frame-less editable, "div" would be
			// the best one in that case.
			// In another case on old IEs moving the selection into a "body" paste bin causes error panic.
			// Body can't be also used for Opera which fills it with <br>
			// what is indistinguishable from pasted <br> (copying <br> in Opera isn't possible,
			// but it can be copied from other browser).
			var pastebin = new CKEDITOR.dom.element(
				editable.is( 'body' ) && !( CKEDITOR.env.ie || CKEDITOR.env.opera ) ? 'body' : 'div', doc );

			pastebin.setAttribute( 'id', 'cke_pastebin' );

			if ( usePastebin ) {
				// Append bogus to prevent Opera from doing this. (#9522)
				if ( CKEDITOR.env.opera )
					pastebin.appendBogus();
			}

			var containerOffset = 0,
				win = doc.getWindow();

			// Seems to be the only way to avoid page scroll in Fx 3.x.
			if ( ff3x ) {
				pastebin.insertAfter( bms[ 0 ].startNode );
				pastebin.setStyle( 'display', 'inline' );
			} else {
				if ( CKEDITOR.env.webkit ) {
					// It's better to paste close to the real paste destination, so inherited styles
					// (which Webkits will try to compensate by styling span) differs less from the destination's one.
					editable.append( pastebin );
					// Style pastebin like .cke_editable, to minimize differences between origin and destination. (#9754)
					pastebin.addClass( 'cke_editable' );
					// Compensate position of offsetParent.
					containerOffset = ( editable.is( 'body' ) ? editable : CKEDITOR.dom.element.get( pastebin.$.offsetParent ) ).getDocumentPosition().y;
				} else {
					// Opera and IE doesn't allow to append to html element.
					editable.getAscendant( CKEDITOR.env.ie || CKEDITOR.env.opera ? 'body' : 'html', 1 ).append( pastebin );
				}

				pastebin.setStyles({
					position: 'absolute',
					// Position the bin at the top (+10 for safety) of viewport to avoid any subsequent document scroll.
					top: ( win.getScrollPosition().y - containerOffset + 10 ) + 'px',
					width: '1px',
					// Caret has to fit in that height, otherwise browsers like Chrome & Opera will scroll window to show it.
					// Set height equal to viewport's height - 20px (safety gaps), minimum 1px.
					height: Math.max( 1, win.getViewPaneSize().height - 20 ) + 'px',
					overflow: 'hidden',
					// Reset styles that can mess up pastebin position.
					margin: 0,
					padding: 0
				});
			}

			// Check if the paste bin now establishes new editing host.
			var isEditingHost = pastebin.getParent().isReadOnly();

			if ( isEditingHost ) {
				// Hide the paste bin.
				pastebin.setOpacity( 0 );
				// And make it editable.
				pastebin.setAttribute( 'contenteditable', true );
			}
			// Transparency is not enough since positioned non-editing host always shows
			// resize handler, pull it off the screen instead.
			else
				pastebin.setStyle( editor.config.contentsLangDirection == 'ltr' ? 'left' : 'right', '-1000px' );

			editor.on( 'selectionChange', cancel, null, null, 0 );

			// Temporarily move selection to the pastebin.
			isEditingHost && pastebin.focus();
			var range = new CKEDITOR.dom.range( pastebin );
			range.selectNodeContents( pastebin );
			var selPastebin = range.select();

			if ( usePastebin ) {
				// If non-native paste is executed, IE will open security alert and blur editable.
				// Editable will then lock selection inside itself and after accepting security alert
				// this selection will be restored. We overwrite stored selection, so it's restored
				// in pastebin. (#9552)
				if ( CKEDITOR.env.ie ) {
					var blurListener = editable.once( 'blur', function( evt ) {
						editor.lockSelection( selPastebin );
					} );
				}
			}

			var scrollTop = CKEDITOR.document.getWindow().getScrollPosition().y;

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Temporarily disable spellcheck
			// The setTimeout relies on a selection that is obtained prior to the setTimeout (shame
			// on them).  When spellcheck is invoked (via blur handler), it invalidates the
			// selection, causing JS null access errors to appear.
			// Test case:
			//  1. Open a new note; freetext is focused
			//  2. Type a misspelled word, do not trigger spellcheck (do not press spacebar, enter, etc).
			//  3. Select all of the text using the keyboard - Ctrl+A or Shift+Home
			//  4. Immediately, before spellcheck is invoked, press Ctrl+C, then Ctrl+V
			// Result:  The text is pasted over itself.  About a second later, this code, and
			//          spellcheck, is invoked, causing the error to appear.
			// ------------------------------------------------------------------------------------
			// Check is spellcheck is already enabled; if not, don't re-enable it afterwards.
			var bSpellCheckWasEnabled = editor.isSpellCheckEnabled && editor.isSpellCheckEnabled();
			if ( editor.disableSpellCheck )
				editor.disableSpellCheck();

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Lock snapshot during paste so that CKE undo bookmarks aren't saved on
			//                the cke_pastebin
			// Test case:  Hold ctrl+V to paste, then quickly switch to ctrl+Z to undo
			//     Result:  Previously, the focus would be lost.
			// ------------------------------------------------------------------------------------
			editor.fire('lockSnapshot');

			// Wait a while and grab the pasted contents.
			setTimeout( function() {
				try {
					// Restore main window's scroll position which could have been changed
					// by browser in cases described in #9771.
					if ( CKEDITOR.env.webkit || CKEDITOR.env.opera )
						CKEDITOR.document[ CKEDITOR.env.webkit ? 'getBody' : 'getDocumentElement' ]().$.scrollTop = scrollTop;

					// Blur will be fired only on non-native paste. In other case manually remove listener.
					blurListener && blurListener.removeListener();

					// Restore properly the document focus. (#8849)
					if ( CKEDITOR.env.ie )
						editable.focus();

					// IE7: selection must go before removing pastebin. (#8691)
					sel.selectBookmarks( bms );
					pastebin.remove();

					if ( usePastebin ) {
						// Grab the HTML contents.
						// We need to look for a apple style wrapper on webkit it also adds
						// a div wrapper if you copy/paste the body of the editor.
						// Remove hidden div and restore selection.
						var bogusSpan;
						if ( CKEDITOR.env.webkit && ( bogusSpan = pastebin.getFirst() ) && ( bogusSpan.is && bogusSpan.hasClass( 'Apple-style-span' ) ) )
							pastebin = bogusSpan;
					}

					editor.removeListener( 'selectionChange', cancel );
					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Call callback with our ClipboardHelper clipboard
					// ------------------------------------------------------------------------------------
					if ( usePastebin ) {
						callback( pastebin.getHtml() );
					}
					else {
						try {
							var sText = getClipboardContent();
							callback( sText );
						}
						catch ( e ) { // log failure. Error should have been displayed in GetClipboard()
							DocHandleError( 'clipboard/plugin.js, GetClipboard failed:  ' + (e.message || e), 'DynDocCKEditor' );
						}
					}
				}
				finally {
					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Unlock snapshot.  See corresponding change above
					// ------------------------------------------------------------------------------------
					editor.fire('unlockSnapshot');

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Re-enable spellcheck
					// See above dyndoc change.
					// ------------------------------------------------------------------------------------
					if ( bSpellCheckWasEnabled && editor.enableSpellCheck )
						editor.enableSpellCheck( true );
				}
			}, 0 );
		}

		// Try to get content directly from clipboard, without native event
		// being fired before. In other words - synthetically get clipboard data
		// if it's possible.
		// mainPasteEvent will be fired, so if forced native paste:
		// * worked, getClipboardDataByPastebin will grab it,
		// * didn't work, pastebin will be empty and editor#paste won't be fired.
		function getClipboardDataDirectly() {
			if ( CKEDITOR.env.ie ) {
				// Prevent IE from pasting at the begining of the document.
				editor.focus();

				// Command will be handled by 'beforepaste', but as
				// execIECommand( 'paste' ) will fire also 'paste' event
				// we're canceling it.
				preventPasteEventNow();

				// #9247: Lock focus to prevent IE from hiding toolbar for inline editor.
				var focusManager = editor.focusManager;
				focusManager.lock();

				if ( editor.editable().fire( mainPasteEvent ) && !execIECommand( 'paste' ) ) {
					focusManager.unlock();
					return false;
				}
				focusManager.unlock();
			} else {
				try {
					if ( editor.editable().fire( mainPasteEvent ) && !editor.document.$.execCommand( 'Paste', false, null ) ) {
						throw 0;
					}
				} catch ( e ) {
					return false;
				}
			}

			return true;
		}

		// Listens for some clipboard related keystrokes, so they get customized.
		// Needs to be bind to keydown event.
		function onKey( event ) {
			if ( editor.mode != 'wysiwyg' )
				return;

			switch ( event.data.keyCode ) {
				// Paste
				case CKEDITOR.CTRL + 86: // CTRL+V
				case CKEDITOR.SHIFT + 45: // SHIFT+INS
					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed: Paste using destination font face and size when hot keys are pressed.
					// ------------------------------------------------------------------------------------
					editor.fire('hotKeyPaste');
					var editable = editor.editable();

					// Cancel 'paste' event because ctrl+v is for IE handled
					// by 'beforepaste'.
					preventPasteEventNow();

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Override browser paste on Shift+Insert since the clipboard plugin does not.
					// ------------------------------------------------------------------------------------
					if ( event.data.keyCode === CKEDITOR.SHIFT + 45 ) {
						var html = getClipboardContent();
						if ( html ) {
							var cancel = function( evt ) { evt.data.preventDefault() };
							editor.editable().on( 'paste', cancel, null, null, 0 );
							setTimeout( function() {
								editor.editable().removeListener( 'paste', cancel );
							}, 0 );
							firePasteEvents( 'html', html );
						}
					}

					// Simulate 'beforepaste' event for all none-IEs.
					!CKEDITOR.env.ie && editable.fire( 'beforepaste' );

					// Simulate 'paste' event for Opera/Firefox2.
					if ( CKEDITOR.env.opera || CKEDITOR.env.gecko && CKEDITOR.env.version < 10900 )
						editable.fire( 'paste' );
					return;

				// Cut
				case CKEDITOR.CTRL + 88: // CTRL+X
				case CKEDITOR.SHIFT + 46: // SHIFT+DEL
					// Save Undo snapshot.
					editor.fire( 'saveSnapshot' ); // Save before cut
					setTimeout( function() {
						editor.fire( 'saveSnapshot' ); // Save after cut
					}, 0 );
			}
		}

		function pasteDataFromClipboard( evt ) {
			// Default type is 'auto', but can be changed by beforePaste listeners.
			var eventData = { type: 'auto' };
			// Fire 'beforePaste' event so clipboard flavor get customized by other plugins.
			// If 'beforePaste' is canceled continue executing getClipboardDataByPastebin and then do nothing
			// (do not fire 'paste', 'afterPaste' events). This way we can grab all - synthetically
			// and natively pasted content and prevent its insertion into editor
			// after canceling 'beforePaste' event.
			var beforePasteNotCanceled = editor.fire( 'beforePaste', eventData );

			getClipboardDataByPastebin( evt, function( data ) {
				// Clean up.
				data = data.replace( /<span[^>]+data-cke-bookmark[^<]*?<\/span>/ig, '' );

				// Fire remaining events (without beforePaste)
				beforePasteNotCanceled && firePasteEvents( eventData.type, data, 0, 1 );
			});
		}

		function setToolbarStates() {
			if ( editor.mode != 'wysiwyg' )
				return;

			var pasteState = stateFromNamedCommand( 'Paste' );

			editor.getCommand( 'cut' ).setState( stateFromNamedCommand( 'Cut' ) );
			editor.getCommand( 'copy' ).setState( stateFromNamedCommand( 'Copy' ) );
			editor.getCommand( 'paste' ).setState( pasteState );
			editor.fire( 'pasteState', pasteState );
		}

		// ------------------------------------------------------------------------------------
		// ***DYNAMIC DOCUMENTATION CHANGE***
		// What Changed:  Added PasteText menu button and contextmenu option to paste
		//                without source font family and size
		// ------------------------------------------------------------------------------------
		function stateFromNamedCommand( command ) {
			var retval;

			if ( inReadOnly && command in { Paste:1,Cut:1,PasteText:1 } )
				return CKEDITOR.TRISTATE_DISABLED;

			if ( command == 'Paste' || command == 'PasteText' ) {
				// IE Bug: queryCommandEnabled('paste') fires also 'beforepaste(copy/cut)',
				// guard to distinguish from the ordinary sources (either
				// keyboard paste or execCommand) (#4874).
				CKEDITOR.env.ie && ( preventBeforePasteEvent = 1 );
				try {
					// Always return true for Webkit (which always returns false)
					retval = editor.document.$.queryCommandEnabled( 'paste' ) || CKEDITOR.env.webkit;
				} catch ( er ) {}
				preventBeforePasteEvent = 0;
			}
			// Cut, Copy - check if the selection is not empty
			else {
				var sel = editor.getSelection(),
					ranges = sel.getRanges();
				retval = sel.getType() != CKEDITOR.SELECTION_NONE && !( ranges.length == 1 && ranges[ 0 ].collapsed );
			}

			return retval ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
		}
	}

	// Returns:
	// * 'htmlifiedtext' if content looks like transformed by browser from plain text.
	//		See clipboard/paste.html TCs for more info.
	// * 'html' if it is not 'htmlifiedtext'.
	function recogniseContentType( data ) {
		if ( CKEDITOR.env.webkit ) {
			// Plain text or ( <div><br></div> and text inside <div> ).
			if ( !data.match( /^[^<]*$/g ) && !data.match( /^(<div><br( ?\/)?><\/div>|<div>[^<]*<\/div>)*$/gi ) )
				return 'html';
		} else if ( CKEDITOR.env.ie ) {
			// Text and <br> or ( text and <br> in <p> - paragraphs can be separated by new \r\n ).
			if ( !data.match( /^([^<]|<br( ?\/)?>)*$/gi ) && !data.match( /^(<p>([^<]|<br( ?\/)?>)*<\/p>|(\r\n))*$/gi ) )
				return 'html';
		} else if ( CKEDITOR.env.gecko || CKEDITOR.env.opera ) {
			// Text or <br>.
			if ( !data.match( /^([^<]|<br( ?\/)?>)*$/gi ) )
				return 'html';
		} else
			return 'html';

		return 'htmlifiedtext';
	}

	// This function transforms what browsers produce when
	// pasting plain text into editable element (see clipboard/paste.html TCs
	// for more info) into correct HTML (similar to that produced by text2Html).
	function htmlifiedTextHtmlification( config, data ) {
		function repeatParagraphs( repeats ) {
			// Repeat blocks floor((n+1)/2) times.
			// Even number of repeats - add <br> at the beginning of last <p>.
			return CKEDITOR.tools.repeat( '</p><p>', ~~ ( repeats / 2 ) ) + ( repeats % 2 == 1 ? '<br>' : '' );
		}

			// Replace adjacent white-spaces (EOLs too - Fx sometimes keeps them) with one space.
		data = data.replace( /\s+/g, ' ' )
			// Remove spaces from between tags.
			.replace( /> +</g, '><' )
			// Normalize XHTML syntax and upper cased <br> tags.
			.replace( /<br ?\/>/gi, '<br>' );

		// IE - lower cased tags.
		data = data.replace( /<\/?[A-Z]+>/g, function( match ) {
			return match.toLowerCase();
		});

		// Don't touch single lines (no <br|p|div>) - nothing to do here.
		if ( data.match( /^[^<]$/ ) )
			return data;

		// Webkit.
		if ( CKEDITOR.env.webkit && data.indexOf( '<div>' ) > -1 ) {
				// One line break at the beginning - insert <br>
			data = data.replace( /^(<div>(<br>|)<\/div>)(?!$|(<div>(<br>|)<\/div>))/g, '<br>' )
				// Two or more - reduce number of new lines by one.
				.replace( /^(<div>(<br>|)<\/div>){2}(?!$)/g, '<div></div>' );

			// Two line breaks create one paragraph in Webkit.
			if ( data.match( /<div>(<br>|)<\/div>/ ) ) {
				data = '<p>' + data.replace( /(<div>(<br>|)<\/div>)+/g, function( match ) {
					return repeatParagraphs( match.split( '</div><div>' ).length + 1 );
				}) + '</p>';
			}

			// One line break create br.
			data = data.replace( /<\/div><div>/g, '<br>' );

			// Remove remaining divs.
			data = data.replace( /<\/?div>/g, '' );
		}

		// Opera and Firefox and enterMode != BR.
		if ( ( CKEDITOR.env.gecko || CKEDITOR.env.opera ) && config.enterMode != CKEDITOR.ENTER_BR ) {
			// Remove bogus <br> - Fx generates two <brs> for one line break.
			// For two line breaks it still produces two <brs>, but it's better to ignore this case than the first one.
			if ( CKEDITOR.env.gecko )
				data = data.replace( /^<br><br>$/, '<br>' );

			// This line satisfy edge case when for Opera we have two line breaks
			//data = data.replace( /)

			if ( data.indexOf( '<br><br>' ) > -1 ) {
				// Two line breaks create one paragraph, three - 2, four - 3, etc.
				data = '<p>' + data.replace( /(<br>){2,}/g, function( match ) {
					return repeatParagraphs( match.length / 4 );
				}) + '</p>';
			}
		}

		return switchEnterMode( config, data );
	}

	// Filter can be editor dependent.
	function getTextificationFilter( editor ) {
		var filter = new CKEDITOR.htmlParser.filter();

		// Elements which creates vertical breaks (have vert margins) - took from HTML5 spec.
		// http://dev.w3.org/html5/markup/Overview.html#toc
		var replaceWithParaIf = { blockquote:1,dl:1,fieldset:1,h1:1,h2:1,h3:1,h4:1,h5:1,h6:1,ol:1,p:1,table:1,ul:1 },

			// All names except of <br>.
			stripInlineIf = CKEDITOR.tools.extend({ br: 0 }, CKEDITOR.dtd.$inline ),

			// What's finally allowed (cke:br will be removed later).
			allowedIf = { p:1,br:1,'cke:br':1 },

			knownIf = CKEDITOR.dtd,

			// All names that will be removed (with content).
			removeIf = CKEDITOR.tools.extend( { area:1,basefont:1,embed:1,iframe:1,map:1,object:1,param:1 }, CKEDITOR.dtd.$nonBodyContent, CKEDITOR.dtd.$cdata );

		var flattenTableCell = function( element ) {
				delete element.name;
				element.add( new CKEDITOR.htmlParser.text( ' ' ) );
			},
			// Squash adjacent headers into one. <h1>A</h1><h2>B</h2> -> <h1>A<br>B</h1><h2></h2>
			// Empty ones will be removed later.
			squashHeader = function( element ) {
				var next = element,
					br, el;

				while ( ( next = next.next ) && next.name && next.name.match( /^h\d$/ ) ) {
					// TODO shitty code - waitin' for htmlParse.element fix.
					br = new CKEDITOR.htmlParser.element( 'cke:br' );
					br.isEmpty = true;
					element.add( br );
					while ( ( el = next.children.shift() ) )
						element.add( el );
				}
			};

		filter.addRules({
			elements: {
				h1: squashHeader,
				h2: squashHeader,
				h3: squashHeader,
				h4: squashHeader,
				h5: squashHeader,
				h6: squashHeader,

				img: function( element ) {
					var alt = CKEDITOR.tools.trim( element.attributes.alt || '' ),
						txt = ' ';

					// Replace image with its alt if it doesn't look like an url or is empty.
					if ( alt && !alt.match( /(^http|\.(jpe?g|gif|png))/i ) )
						txt = ' [' + alt + '] ';

					return new CKEDITOR.htmlParser.text( txt );
				},

				td: flattenTableCell,
				th: flattenTableCell,

				$: function( element ) {
					var initialName = element.name,
						br;

					// Remove entirely.
					if ( removeIf[ initialName ] )
						return false;

					// Remove all attributes.
					delete element.attributes;

					// Pass brs.
					if ( initialName == 'br' )
						return element;

					// Elements that we want to replace with paragraphs.
					if ( replaceWithParaIf[ initialName ] )
						element.name = 'p';

					// Elements that we want to strip (tags only, without the content).
					else if ( stripInlineIf[ initialName ] )
						delete element.name;

					// Surround other known element with <brs> and strip tags.
					else if ( knownIf[ initialName ] ) {
						// TODO shitty code - waitin' for htmlParse.element fix.
						br = new CKEDITOR.htmlParser.element( 'cke:br' );
						br.isEmpty = true;

						// Replace hrs (maybe sth else too?) with only one br.
						if ( CKEDITOR.dtd.$empty[ initialName ] )
							return br;

						element.add( br, 0 );
						br = br.clone();
						br.isEmpty = true;
						element.add( br );
						delete element.name;
					}

					// Final cleanup - if we can still find some not allowed elements then strip their names.
					if ( !allowedIf[ element.name ] )
						delete element.name;

					return element;
				}
			}
		});

		return filter;
	}

	function htmlTextification( config, data, filter ) {
		var fragment = new CKEDITOR.htmlParser.fragment.fromHtml( data ),
			writer = new CKEDITOR.htmlParser.basicWriter();

		fragment.writeHtml( writer, filter );
		data = writer.getHtml();

		// Cleanup cke:brs.
		data = data.replace( /\s*(<\/?[a-z:]+ ?\/?>)\s*/g, '$1' )	// Remove spaces around tags.
			.replace( /(<cke:br \/>){2,}/g, '<cke:br />' )			// Join multiple adjacent cke:brs
			.replace( /(<cke:br \/>)(<\/?p>|<br \/>)/g, '$2' )		// Strip cke:brs adjacent to original brs or ps.
			.replace( /(<\/?p>|<br \/>)(<cke:br \/>)/g, '$1' )
			.replace( /<(cke:)?br( \/)?>/g, '<br>' )				// Finally - rename cke:brs to brs and fix <br /> to <br>.
			.replace( /<p><\/p>/g, '' );							// Remove empty paragraphs.

		// Fix nested ps. E.g.:
		// <p>A<p>B<p>C</p>D<p>E</p>F</p>G
		// <p>A</p><p>B</p><p>C</p><p>D</p><p>E</p><p>F</p>G
		var nested = 0;
		data = data.replace( /<\/?p>/g, function( match ) {
			if ( match == '<p>' ) {
				if ( ++nested > 1 )
					return '</p><p>';
			} else {
				if ( --nested > 0 )
					return '</p><p>';
			}

			return match;
		}).replace( /<p><\/p>/g, '' ); // Step before: </p></p> -> </p><p></p><p>. Fix this here.

		return switchEnterMode( config, data );
	}

	function switchEnterMode( config, data ) {
		if ( config.enterMode == CKEDITOR.ENTER_BR ) {
			data = data.replace( /(<\/p><p>)+/g, function( match ) {
				return CKEDITOR.tools.repeat( '<br>', match.length / 7 * 2 );
			}).replace( /<\/?p>/g, '' );
		} else if ( config.enterMode == CKEDITOR.ENTER_DIV ) {
			data = data.replace( /<(\/)?p>/g, '<$1div>' );
		}

		return data;
	}
})();

/**
 * The default content type is used when pasted data cannot be clearly recognized as HTML or text.
 *
 * For example: `'foo'` may come from a plain text editor or a website. It isn't possible to recognize content
 * type in this case, so default will be used. However, it's clear that `'<b>example</b> text'` is an HTML
 * and its origin is webpage, email or other rich text editor.
 *
 * **Note:** If content type is text, then styles of context of paste are preserved.
 *
 *		CKEDITOR.config.clipboard_defaultContentType = 'text';
 *
 * @since 4.0
 * @cfg {'html'/'text'} [clipboard_defaultContentType='html']
 * @member CKEDITOR.config
 */

/**
 * Fired when a clipboard operation is about to be taken into the editor.
 * Listeners can manipulate the data to be pasted before having it effectively
 * inserted into the document.
 *
 * @since 3.1
 * @event paste
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param data
 * @param {String} data.type Type of data in `data.dataValue`. Usually `html` or `text`, but for listeners
 * with priority less than 6 it may be also `auto`, what means that content type hasn't been recognised yet
 * (this will be done by content type sniffer that listens with priority 6).
 * @param {String} data.dataValue HTML to be pasted.
 */

/**
 * Internal event to open the Paste dialog.
 *
 * @private
 * @event pasteDialog
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param {Function} [data] Callback that will be passed to {@link CKEDITOR.editor#openDialog}.
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "dialogui" plugin.
 */

CKEDITOR.plugins.add( 'dialogui', {
	onLoad: function() {

		var initPrivateObject = function( elementDefinition ) {
				this._ || ( this._ = {} );
				this._[ 'default' ] = this._.initValue = elementDefinition[ 'default' ] || '';
				this._.required = elementDefinition[ 'required' ] || false;
				var args = [ this._ ];
				for ( var i = 1; i < arguments.length; i++ )
					args.push( arguments[ i ] );
				args.push( true );
				CKEDITOR.tools.extend.apply( CKEDITOR.tools, args );
				return this._;
			},
			textBuilder = {
				build: function( dialog, elementDefinition, output ) {
					return new CKEDITOR.ui.dialog.textInput( dialog, elementDefinition, output );
				}
			},
			commonBuilder = {
				build: function( dialog, elementDefinition, output ) {
					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, elementDefinition, output );
				}
			},
			containerBuilder = {
				build: function( dialog, elementDefinition, output ) {
					var children = elementDefinition.children,
						child,
						childHtmlList = [],
						childObjList = [];
					for ( var i = 0;
					( i < children.length && ( child = children[ i ] ) ); i++ ) {
						var childHtml = [];
						childHtmlList.push( childHtml );
						childObjList.push( CKEDITOR.dialog._.uiElementBuilders[ child.type ].build( dialog, child, childHtml ) );
					}
					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, childObjList, childHtmlList, output, elementDefinition );
				}
			},
			commonPrototype = {
				isChanged: function() {
					return this.getValue() != this.getInitValue();
				},

				reset: function( noChangeEvent ) {
					this.setValue( this.getInitValue(), noChangeEvent );
				},

				setInitValue: function() {
					this._.initValue = this.getValue();
				},

				resetInitValue: function() {
					this._.initValue = this._[ 'default' ];
				},

				getInitValue: function() {
					return this._.initValue;
				}
			},
			commonEventProcessors = CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {
				onChange: function( dialog, func ) {
					if ( !this._.domOnChangeRegistered ) {
						dialog.on( 'load', function() {
							this.getInputElement().on( 'change', function() {
								// Make sure 'onchange' doesn't get fired after dialog closed. (#5719)
								if ( !dialog.parts.dialog.isVisible() )
									return;

								this.fire( 'change', { value: this.getValue() } );
							}, this );
						}, this );
						this._.domOnChangeRegistered = true;
					}

					this.on( 'change', func );
				}
			}, true ),
			eventRegex = /^on([A-Z]\w+)/,
			cleanInnerDefinition = function( def ) {
				// An inner UI element should not have the parent's type, title or events.
				for ( var i in def ) {
					if ( eventRegex.test( i ) || i == 'title' || i == 'type' )
						delete def[ i ];
				}
				return def;
			};

		CKEDITOR.tools.extend( CKEDITOR.ui.dialog, {
			/**
			 * Base class for all dialog elements with a textual label on the left.
			 *
			 * @class CKEDITOR.ui.dialog.labeledElement
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a labeledElement class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Required) The label string.
			 * * `labelLayout` (Optional) Put 'horizontal' here if the
			 *     label element is to be layed out horizontally. Otherwise a vertical
			 *     layout will be used.
			 * * `widths` (Optional) This applies only for horizontal
			 *     layouts - an 2-element array of lengths to specify the widths of the
			 *     label and the content element.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 * @param {Function} contentHtml
			 * A function returning the HTML code string to be added inside the content
			 * cell.
			 */
			labeledElement: function( dialog, elementDefinition, htmlList, contentHtml ) {
				if ( arguments.length < 4 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition );
				_.labelId = CKEDITOR.tools.getNextId() + '_label';
				var children = this._.children = [];

				var innerHTML = function() {
						var html = [],
							requiredClass = elementDefinition.required ? ' cke_required' : '';
						if ( elementDefinition.labelLayout != 'horizontal' )
						html.push( '<label class="cke_dialog_ui_labeled_label' + requiredClass + '" ', ' id="' + _.labelId + '"', ( _.inputId ? ' for="' + _.inputId + '"' : '' ), ( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>', elementDefinition.label, '</label>', '<div class="cke_dialog_ui_labeled_content"' + ( elementDefinition.controlStyle ? ' style="' + elementDefinition.controlStyle + '"' : '' ) + ' role="presentation">', contentHtml.call( this, dialog, elementDefinition ), '</div>' );
						else {
							var hboxDefinition = {
								type: 'hbox',
								widths: elementDefinition.widths,
								padding: 0,
								children: [
									{
									type: 'html',
									html: '<label class="cke_dialog_ui_labeled_label' + requiredClass + '"' +
										' id="' + _.labelId + '"' +
										' for="' + _.inputId + '"' +
										( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>' +
											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +
										'</span>'
								},
									{
									type: 'html',
									html: '<span class="cke_dialog_ui_labeled_content"' + ( elementDefinition.controlStyle ? ' style="' + elementDefinition.controlStyle + '"' : '' ) + '>' +
										contentHtml.call( this, dialog, elementDefinition ) +
										'</span>'
								}
								]
							};
							CKEDITOR.dialog._.uiElementBuilders.hbox.build( dialog, hboxDefinition, html );
						}
						return html.join( '' );
					};
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'div', null, { role: 'presentation' }, innerHTML );
			},

			/**
			 * A text input with a label. This UI element class represents both the
			 * single-line text inputs and password inputs in dialog boxes.
			 *
			 * @class CKEDITOR.ui.dialog.textInput
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a textInput class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Optional) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `maxLength` (Optional) The maximum length of text box contents.
			 * * `size` (Optional) The size of the text box. This is
			 *     usually overridden by the size defined by the skin, however.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			textInput: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				initPrivateObject.call( this, elementDefinition );
				var domId = this._.inputId = CKEDITOR.tools.getNextId() + '_textInput',
					attributes = { 'class': 'cke_dialog_ui_input_' + elementDefinition.type, id: domId, type: elementDefinition.type },
					i;

				// Set the validator, if any.
				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				// Set the max length and size.
				if ( elementDefinition.maxLength )
					attributes.maxlength = elementDefinition.maxLength;
				if ( elementDefinition.size )
					attributes.size = elementDefinition.size;

				if ( elementDefinition.inputStyle )
					attributes.style = elementDefinition.inputStyle;

				// If user presses Enter in a text box, it implies clicking OK for the dialog.
				var me = this,
					keyPressedOnMe = false;
				dialog.on( 'load', function() {
					me.getInputElement().on( 'keydown', function( evt ) {
						if ( evt.data.getKeystroke() == 13 )
							keyPressedOnMe = true;
					});

					// Lower the priority this 'keyup' since 'ok' will close the dialog.(#3749)
					me.getInputElement().on( 'keyup', function( evt ) {
						if ( evt.data.getKeystroke() == 13 && keyPressedOnMe ) {
							dialog.getButton( 'ok' ) && setTimeout( function() {
								dialog.getButton( 'ok' ).click();
							}, 0 );
							keyPressedOnMe = false;
						}
					}, null, null, 1000 );
				});

				var innerHTML = function() {
						// IE BUG: Text input fields in IE at 100% would exceed a <td> or inline
						// container's width, so need to wrap it inside a <div>.
						var html = [ '<div class="cke_dialog_ui_input_', elementDefinition.type, '" role="presentation"' ];

						if ( elementDefinition.width )
							html.push( 'style="width:' + elementDefinition.width + '" ' );

						html.push( '><input ' );

						attributes[ 'aria-labelledby' ] = this._.labelId;
						this._.required && ( attributes[ 'aria-required' ] = this._.required );
						for ( var i in attributes )
							html.push( i + '="' + attributes[ i ] + '" ' );
						html.push( ' /></div>' );
						return html.join( '' );
					};
				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

			/**
			 * A text area with a label on the top or left.
			 *
			 * @class CKEDITOR.ui.dialog.textarea
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a textarea class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 *
			 * The element definition. Accepted fields:
			 *
			 * * `rows` (Optional) The number of rows displayed.
			 *     Defaults to 5 if not defined.
			 * * `cols` (Optional) The number of cols displayed.
			 *     Defaults to 20 if not defined. Usually overridden by skins.
			 * * `default` (Optional) The default value.
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			textarea: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				initPrivateObject.call( this, elementDefinition );
				var me = this,
					domId = this._.inputId = CKEDITOR.tools.getNextId() + '_textarea',
					attributes = {};

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				// Generates the essential attributes for the textarea tag.
				attributes.rows = elementDefinition.rows || 5;
				attributes.cols = elementDefinition.cols || 20;

				attributes[ 'class' ] = 'cke_dialog_ui_input_textarea ' + ( elementDefinition[ 'class' ] || '' );

				if ( typeof elementDefinition.inputStyle != 'undefined' )
					attributes.style = elementDefinition.inputStyle;

				if ( elementDefinition.dir )
					attributes.dir = elementDefinition.dir;

				var innerHTML = function() {
						attributes[ 'aria-labelledby' ] = this._.labelId;
						this._.required && ( attributes[ 'aria-required' ] = this._.required );
						var html = [ '<div class="cke_dialog_ui_input_textarea" role="presentation"><textarea id="', domId, '" ' ];
						for ( var i in attributes )
							html.push( i + '="' + CKEDITOR.tools.htmlEncode( attributes[ i ] ) + '" ' );
						html.push( '>', CKEDITOR.tools.htmlEncode( me._[ 'default' ] ), '</textarea></div>' );
						return html.join( '' );
					};
				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

			/**
			 * A single checkbox with a label on the right.
			 *
			 * @class CKEDITOR.ui.dialog.checkbox
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a checkbox class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `checked` (Optional) Whether the checkbox is checked
			 *     on instantiation. Defaults to false.
			 * * `validate` (Optional) The validation function.
			 * * `label` (Optional) The checkbox label.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			checkbox: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition, { 'default': !!elementDefinition[ 'default' ] } );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				var innerHTML = function() {
						var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {
							id: elementDefinition.id ? elementDefinition.id + '_checkbox' : CKEDITOR.tools.getNextId() + '_checkbox'
						}, true ),
							html = [];

						var labelId = CKEDITOR.tools.getNextId() + '_label';
						var attributes = { 'class': 'cke_dialog_ui_checkbox_input', type: 'checkbox', 'aria-labelledby': labelId };
						cleanInnerDefinition( myDefinition );
						if ( elementDefinition[ 'default' ] )
							attributes.checked = 'checked';

						if ( typeof myDefinition.inputStyle != 'undefined' )
							myDefinition.style = myDefinition.inputStyle;

						_.checkbox = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, 'input', null, attributes );
						html.push( ' <label id="', labelId, '" for="', attributes.id, '"' + ( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>', CKEDITOR.tools.htmlEncode( elementDefinition.label ), '</label>' );
						return html.join( '' );
					};

				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'span', null, null, innerHTML );
			},

			/**
			 * A group of radio buttons.
			 *
			 * @class CKEDITOR.ui.dialog.radio
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a radio class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Required) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `items` (Required) An array of options. Each option
			 *     is a 1- or 2-item array of format `[ 'Description', 'Value' ]`. If `'Value'`
			 *     is missing, then the value would be assumed to be the same as the description.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			radio: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				initPrivateObject.call( this, elementDefinition );
				if ( !this._[ 'default' ] )
					this._[ 'default' ] = this._.initValue = elementDefinition.items[ 0 ][ 1 ];
				if ( elementDefinition.validate )
					this.validate = elementDefinition.valdiate;
				var children = [],
					me = this;

				var innerHTML = function() {
						var inputHtmlList = [],
							html = [],
							commonAttributes = { 'class': 'cke_dialog_ui_radio_item', 'aria-labelledby': this._.labelId },
							commonName = elementDefinition.id ? elementDefinition.id + '_radio' : CKEDITOR.tools.getNextId() + '_radio';
						for ( var i = 0; i < elementDefinition.items.length; i++ ) {
							var item = elementDefinition.items[ i ],
								title = item[ 2 ] !== undefined ? item[ 2 ] : item[ 0 ],
								value = item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ],
								inputId = CKEDITOR.tools.getNextId() + '_radio_input',
								labelId = inputId + '_label',
								inputDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {
									id: inputId,
									title: null,
									type: null
								}, true ),
								labelDefinition = CKEDITOR.tools.extend( {}, inputDefinition, {
									title: title
								}, true ),
								inputAttributes = {
									type: 'radio',
									'class': 'cke_dialog_ui_radio_input',
									name: commonName,
									value: value,
									'aria-labelledby': labelId
								},
								inputHtml = [];
							if ( me._[ 'default' ] == value )
								inputAttributes.checked = 'checked';
							cleanInnerDefinition( inputDefinition );
							cleanInnerDefinition( labelDefinition );

							if ( typeof inputDefinition.inputStyle != 'undefined' )
								inputDefinition.style = inputDefinition.inputStyle;

							children.push( new CKEDITOR.ui.dialog.uiElement( dialog, inputDefinition, inputHtml, 'input', null, inputAttributes ) );
							inputHtml.push( ' ' );
							new CKEDITOR.ui.dialog.uiElement( dialog, labelDefinition, inputHtml, 'label', null, { id: labelId, 'for': inputAttributes.id }, item[ 0 ] );
							inputHtmlList.push( inputHtml.join( '' ) );
						}
						new CKEDITOR.ui.dialog.hbox( dialog, children, inputHtmlList, html );
						return html.join( '' );
					};

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
				this._.children = children;
			},

			/**
			 * A button with a label inside.
			 *
			 * @class CKEDITOR.ui.dialog.button
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a button class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Required) The button label.
			 * * `disabled` (Optional) Set to true if you want the
			 *     button to appear in disabled state.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			button: function( dialog, elementDefinition, htmlList ) {
				if ( !arguments.length )
					return;

				if ( typeof elementDefinition == 'function' )
					elementDefinition = elementDefinition( dialog.getParentEditor() );

				initPrivateObject.call( this, elementDefinition, { disabled: elementDefinition.disabled || false } );

				// Add OnClick event to this input.
				CKEDITOR.event.implementOn( this );

				var me = this;

				// Register an event handler for processing button clicks.
				dialog.on( 'load', function( eventInfo ) {
					var element = this.getElement();

					(function() {
						element.on( 'click', me.click, me );

						element.on( 'keydown', function( evt ) {
							if ( evt.data.getKeystroke() in { 32:1 } ) {
								me.click();
								evt.data.preventDefault();
							}
						});
					})();

					element.unselectable();
				}, this );

				var outerDefinition = CKEDITOR.tools.extend( {}, elementDefinition );
				delete outerDefinition.style;

				var labelId = CKEDITOR.tools.getNextId() + '_label';
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, outerDefinition, htmlList, 'a', null, {
					style: elementDefinition.style,
					href: 'javascript:void(0)',
					title: elementDefinition.label,
					hidefocus: 'true',
					'class': elementDefinition[ 'class' ],
					role: 'button',
					'aria-labelledby': labelId
				}, '<span id="' + labelId + '" class="cke_dialog_ui_button">' +
											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +
										'</span>' );
			},

			/**
			 * A select box.
			 *
			 * @class CKEDITOR.ui.dialog.select
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a button class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Required) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `items` (Required) An array of options. Each option
			 *     is a 1- or 2-item array of format `[ 'Description', 'Value' ]`. If `'Value'`
			 *     is missing, then the value would be assumed to be the same as the
			 *     description.
			 * * `multiple` (Optional) Set this to true if you'd like
			 *     to have a multiple-choice select box.
			 * * `size` (Optional) The number of items to display in
			 *     the select box.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			select: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				_.inputId = CKEDITOR.tools.getNextId() + '_select';

				var innerHTML = function() {
						var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {
							id: elementDefinition.id ? elementDefinition.id + '_select' : CKEDITOR.tools.getNextId() + '_select'
						}, true ),
							html = [],
							innerHTML = [],
							attributes = { 'id': _.inputId, 'class': 'cke_dialog_ui_input_select', 'aria-labelledby': this._.labelId };

						html.push( '<div class="cke_dialog_ui_input_', elementDefinition.type, '" role="presentation"' );
						if ( elementDefinition.width )
							html.push( 'style="width:' + elementDefinition.width + '" ' );
						html.push( '>' );

						// Add multiple and size attributes from element definition.
						if ( elementDefinition.size != undefined )
							attributes.size = elementDefinition.size;
						if ( elementDefinition.multiple != undefined )
							attributes.multiple = elementDefinition.multiple;

						cleanInnerDefinition( myDefinition );
						for ( var i = 0, item; i < elementDefinition.items.length && ( item = elementDefinition.items[ i ] ); i++ ) {
							innerHTML.push( '<option value="', CKEDITOR.tools.htmlEncode( item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ] ).replace( /"/g, '&quot;' ), '" /> ', CKEDITOR.tools.htmlEncode( item[ 0 ] ) );
						}

						if ( typeof myDefinition.inputStyle != 'undefined' )
							myDefinition.style = myDefinition.inputStyle;

						_.select = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, 'select', null, attributes, innerHTML.join( '' ) );

						html.push( '</div>' );

						return html.join( '' );
					};

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

			/**
			 * A file upload input.
			 *
			 * @class CKEDITOR.ui.dialog.file
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a file class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			file: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				if ( elementDefinition[ 'default' ] === undefined )
					elementDefinition[ 'default' ] = '';

				var _ = CKEDITOR.tools.extend( initPrivateObject.call( this, elementDefinition ), { definition: elementDefinition, buttons: [] } );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				/** @ignore */
				var innerHTML = function() {
						_.frameId = CKEDITOR.tools.getNextId() + '_fileInput';

						// Support for custom document.domain in IE.
						var isCustomDomain = CKEDITOR.env.isCustomDomain();

						var html = [
							'<iframe' +
								' frameborder="0"' +
								' allowtransparency="0"' +
								' class="cke_dialog_ui_input_file"' +
								' role="presentation"' +
								' id="', _.frameId, '"' +
								' title="', elementDefinition.label, '"' +
								' src="javascript:void(' ];

						html.push( isCustomDomain ? '(function(){' +
							'document.open();' +
							'document.domain=\'' + document.domain + '\';' +
							'document.close();' +
							'})()'
							:
							'0' );

						html.push( ')">' +
							'</iframe>' );

						return html.join( '' );
					};

				// IE BUG: Parent container does not resize to contain the iframe automatically.
				dialog.on( 'load', function() {
					var iframe = CKEDITOR.document.getById( _.frameId ),
						contentDiv = iframe.getParent();
					contentDiv.addClass( 'cke_dialog_ui_input_file' );
				});

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

			/**
			 * A button for submitting the file in a file upload input.
			 *
			 * @class CKEDITOR.ui.dialog.fileButton
			 * @extends CKEDITOR.ui.dialog.button
			 * @constructor Creates a fileButton class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `for` (Required) The file input's page and element Id
			 *     to associate to, in a 2-item array format: `[ 'page_id', 'element_id' ]`.
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			fileButton: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length < 3 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition ),
					me = this;

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition );
				var onClick = myDefinition.onClick;
				myDefinition.className = ( myDefinition.className ? myDefinition.className + ' ' : '' ) + 'cke_dialog_ui_button';
				myDefinition.onClick = function( evt ) {
					var target = elementDefinition[ 'for' ]; // [ pageId, elementId ]
					if ( !onClick || onClick.call( this, evt ) !== false ) {
						dialog.getContentElement( target[ 0 ], target[ 1 ] ).submit();
						this.disable();
					}
				};

				dialog.on( 'load', function() {
					dialog.getContentElement( elementDefinition[ 'for' ][ 0 ], elementDefinition[ 'for' ][ 1 ] )._.buttons.push( me );
				});

				CKEDITOR.ui.dialog.button.call( this, dialog, myDefinition, htmlList );
			},

			html: (function() {
				var myHtmlRe = /^\s*<[\w:]+\s+([^>]*)?>/,
					theirHtmlRe = /^(\s*<[\w:]+(?:\s+[^>]*)?)((?:.|\r|\n)+)$/,
					emptyTagRe = /\/$/;
				/**
				 * A dialog element made from raw HTML code.
				 *
				 * @class CKEDITOR.ui.dialog.html
				 * @extends CKEDITOR.ui.dialog.uiElement
				 * @constructor Creates a html class instance.
				 * @param {CKEDITOR.dialog} dialog Parent dialog object.
				 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition Element definition.
				 * Accepted fields:
				 *
				 * * `html` (Required) HTML code of this element.
				 *
				 * @param {Array} htmlList List of HTML code to be added to the dialog's content area.
				 */
				return function( dialog, elementDefinition, htmlList ) {
					if ( arguments.length < 3 )
						return;

					var myHtmlList = [],
						myHtml,
						theirHtml = elementDefinition.html,
						myMatch, theirMatch;

					// If the HTML input doesn't contain any tags at the beginning, add a <span> tag around it.
					if ( theirHtml.charAt( 0 ) != '<' )
						theirHtml = '<span>' + theirHtml + '</span>';

					// Look for focus function in definition.
					var focus = elementDefinition.focus;
					if ( focus ) {
						var oldFocus = this.focus;
						this.focus = function() {
							( typeof focus == 'function' ? focus : oldFocus ).call( this );
							this.fire( 'focus' );
						};
						if ( elementDefinition.isFocusable ) {
							var oldIsFocusable = this.isFocusable;
							this.isFocusable = oldIsFocusable;
						}
						this.keyboardFocusable = true;
					}

					CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, myHtmlList, 'span', null, null, '' );

					// Append the attributes created by the uiElement call to the real HTML.
					myHtml = myHtmlList.join( '' );
					myMatch = myHtml.match( myHtmlRe );
					theirMatch = theirHtml.match( theirHtmlRe ) || [ '', '', '' ];

					if ( emptyTagRe.test( theirMatch[ 1 ] ) ) {
						theirMatch[ 1 ] = theirMatch[ 1 ].slice( 0, -1 );
						theirMatch[ 2 ] = '/' + theirMatch[ 2 ];
					}

					htmlList.push( [ theirMatch[ 1 ], ' ', myMatch[ 1 ] || '', theirMatch[ 2 ] ].join( '' ) );
				};
			})(),

			/**
			 * Form fieldset for grouping dialog UI elements.
			 *
			 * @class CKEDITOR.ui.dialog.fieldset
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a fieldset class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {Array} childObjList
			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.
			 * @param {Array} childHtmlList Array of HTML code that correspond to the HTML output of all the
			 * objects in childObjList.
			 * @param {Array} htmlList Array of HTML code that this element will output to.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Optional) The legend of the this fieldset.
			 * * `children` (Required) An array of dialog field definitions which will be grouped inside this fieldset.
			 *
			 */
			fieldset: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {
				var legendLabel = elementDefinition.label;
				/** @ignore */
				var innerHTML = function() {
						var html = [];
						legendLabel && html.push( '<legend' +
							( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) +
							'>' + legendLabel + '</legend>' );
						for ( var i = 0; i < childHtmlList.length; i++ )
							html.push( childHtmlList[ i ] );
						return html.join( '' );
					};

				this._ = { children: childObjList };
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'fieldset', null, null, innerHTML );
			}

		}, true );

		CKEDITOR.ui.dialog.html.prototype = new CKEDITOR.ui.dialog.uiElement;

		/** @class CKEDITOR.ui.dialog.labeledElement */
		CKEDITOR.ui.dialog.labeledElement.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {
			/**
			 * Sets the label text of the element.
			 *
			 * @param {String} label The new label text.
			 * @returns {CKEDITOR.ui.dialog.labeledElement} The current labeled element.
			 */
			setLabel: function( label ) {
				var node = CKEDITOR.document.getById( this._.labelId );
				if ( node.getChildCount() < 1 )
				( new CKEDITOR.dom.text( label, CKEDITOR.document ) ).appendTo( node );
				else
					node.getChild( 0 ).$.nodeValue = label;
				return this;
			},

			/**
			 * Retrieves the current label text of the elment.
			 *
			 * @returns {String} The current label text.
			 */
			getLabel: function() {
				var node = CKEDITOR.document.getById( this._.labelId );
				if ( !node || node.getChildCount() < 1 )
					return '';
				else
					return node.getChild( 0 ).getText();
			},

			/**
			 * Defines the onChange event for UI element definitions.
			 * @property {Object}
			 */
			eventProcessors: commonEventProcessors
		}, true );

		/** @class CKEDITOR.ui.dialog.button */
		CKEDITOR.ui.dialog.button.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {
			/**
			 * Simulates a click to the button.
			 *
			 * @returns {Object} Return value of the `click` event.
			 */
			click: function() {
				if ( !this._.disabled )
					return this.fire( 'click', { dialog: this._.dialog } );
				return false;
			},

			/**
			 * Enables the button.
			 */
			enable: function() {
				this._.disabled = false;
				var element = this.getElement();
				element && element.removeClass( 'cke_disabled' );
			},

			/**
			 * Disables the button.
			 */
			disable: function() {
				this._.disabled = true;
				this.getElement().addClass( 'cke_disabled' );
			},

			/**
			 * @todo
			 */
			isVisible: function() {
				return this.getElement().getFirst().isVisible();
			},

			/**
			 * @todo
			 */
			isEnabled: function() {
				return !this._.disabled;
			},

			/**
			 * Defines the onChange event and onClick for button element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {
				onClick: function( dialog, func ) {
					this.on( 'click', function() {
						func.apply( this, arguments );
					});
				}
			}, true ),

			/**
			 * Handler for the element's access key up event. Simulates a click to
			 * the button.
			 */
			accessKeyUp: function() {
				this.click();
			},

			/**
			 * Handler for the element's access key down event. Simulates a mouse
			 * down to the button.
			 */
			accessKeyDown: function() {
				this.focus();
			},

			keyboardFocusable: true
		}, true );

		/** @class CKEDITOR.ui.dialog.textInput */
		CKEDITOR.ui.dialog.textInput.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, {
			/**
			 * Gets the text input DOM element under this UI object.
			 *
			 * @returns {CKEDITOR.dom.element} The DOM element of the text input.
			 */
			getInputElement: function() {
				return CKEDITOR.document.getById( this._.inputId );
			},

			/**
			 * Puts focus into the text input.
			 */
			focus: function() {
				var me = this.selectParentTab();

				// GECKO BUG: setTimeout() is needed to workaround invisible selections.
				setTimeout( function() {
					var element = me.getInputElement();
					element && element.$.focus();
				}, 0 );
			},

			/**
			 * Selects all the text in the text input.
			 */
			select: function() {
				var me = this.selectParentTab();

				// GECKO BUG: setTimeout() is needed to workaround invisible selections.
				setTimeout( function() {
					var e = me.getInputElement();
					if ( e ) {
						e.$.focus();
						e.$.select();
					}
				}, 0 );
			},

			/**
			 * Handler for the text input's access key up event. Makes a `select()`
			 * call to the text input.
			 */
			accessKeyUp: function() {
				this.select();
			},

			/**
			 * Sets the value of this text input object.
			 *
			 *		uiElement.setValue( 'Blamo' );
			 *
			 * @param {Object} value The new value.
			 * @returns {CKEDITOR.ui.dialog.textInput} The current UI element.
			 */
			setValue: function( value ) {
				!value && ( value = '' );
				return CKEDITOR.ui.dialog.uiElement.prototype.setValue.apply( this, arguments );
			},

			keyboardFocusable: true
		}, commonPrototype, true );

		CKEDITOR.ui.dialog.textarea.prototype = new CKEDITOR.ui.dialog.textInput();

		/** @class CKEDITOR.ui.dialog.select */
		CKEDITOR.ui.dialog.select.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, {
			/**
			 * Gets the DOM element of the select box.
			 *
			 * @returns {CKEDITOR.dom.element} The `<select>` element of this UI element.
			 */
			getInputElement: function() {
				return this._.select.getElement();
			},

			/**
			 * Adds an option to the select box.
			 *
			 * @param {String} label Option label.
			 * @param {String} value (Optional) Option value, if not defined it'll be
			 * assumed to be the same as the label.
			 * @param {Number} index (Optional) Position of the option to be inserted
			 * to. If not defined the new option will be inserted to the end of list.
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			add: function( label, value, index ) {
				var option = new CKEDITOR.dom.element( 'option', this.getDialog().getParentEditor().document ),
					selectElement = this.getInputElement().$;
				option.$.text = label;
				option.$.value = ( value === undefined || value === null ) ? label : value;
				if ( index === undefined || index === null ) {
					if ( CKEDITOR.env.ie )
						selectElement.add( option.$ );
					else
						selectElement.add( option.$, null );
				} else
					selectElement.add( option.$, index );
				return this;
			},

			/**
			 * Removes an option from the selection list.
			 *
			 * @param {Number} index Index of the option to be removed.
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			remove: function( index ) {
				var selectElement = this.getInputElement().$;
				selectElement.remove( index );
				return this;
			},

			/**
			 * Clears all options out of the selection list.
			 *
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			clear: function() {
				var selectElement = this.getInputElement().$;
				while ( selectElement.length > 0 )
					selectElement.remove( 0 );
				return this;
			},

			keyboardFocusable: true
		}, commonPrototype, true );

		/** @class CKEDITOR.ui.dialog.checkbox */
		CKEDITOR.ui.dialog.checkbox.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {
			/**
			 * Gets the checkbox DOM element.
			 *
			 * @returns {CKEDITOR.dom.element} The DOM element of the checkbox.
			 */
			getInputElement: function() {
				return this._.checkbox.getElement();
			},

			/**
			 * Sets the state of the checkbox.
			 *
			 * @param {Boolean} `true` to tick the checkbox, `false` to untick it.
			 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.
			 */
			setValue: function( checked, noChangeEvent ) {
				this.getInputElement().$.checked = checked;
				!noChangeEvent && this.fire( 'change', { value: checked } );
			},

			/**
			 * Gets the state of the checkbox.
			 *
			 * @returns {Boolean} true means the checkbox is ticked, false means it's not ticked.
			 */
			getValue: function() {
				return this.getInputElement().$.checked;
			},

			/**
			 * Handler for the access key up event. Toggles the checkbox.
			 */
			accessKeyUp: function() {
				this.setValue( !this.getValue() );
			},

			/**
			 * Defines the onChange event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					if ( !CKEDITOR.env.ie || ( CKEDITOR.env.version > 8 ) )
						return commonEventProcessors.onChange.apply( this, arguments );
					else {
						dialog.on( 'load', function() {
							var element = this._.checkbox.getElement();
							element.on( 'propertychange', function( evt ) {
								evt = evt.data.$;
								if ( evt.propertyName == 'checked' )
									this.fire( 'change', { value: element.$.checked } );
							}, this );
						}, this );
						this.on( 'change', func );
					}
					return null;
				}
			},

			keyboardFocusable: true
		}, commonPrototype, true );

		/** @class CKEDITOR.ui.dialog.radio */
		CKEDITOR.ui.dialog.radio.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {
			/**
			 * Checks one of the radio buttons in this button group.
			 *
			 * @param {String} value The value of the button to be chcked.
			 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.
			 */
			setValue: function( value, noChangeEvent ) {
				var children = this._.children,
					item;
				for ( var i = 0;
				( i < children.length ) && ( item = children[ i ] ); i++ )
					item.getElement().$.checked = ( item.getValue() == value );
				!noChangeEvent && this.fire( 'change', { value: value } );
			},

			/**
			 * Gets the value of the currently checked radio button.
			 *
			 * @returns {String} The currently checked button's value.
			 */
			getValue: function() {
				var children = this._.children;
				for ( var i = 0; i < children.length; i++ ) {
					if ( children[ i ].getElement().$.checked )
						return children[ i ].getValue();
				}
				return null;
			},

			/**
			 * Handler for the access key up event. Focuses the currently
			 * selected radio button, or the first radio button if none is selected.
			 */
			accessKeyUp: function() {
				var children = this._.children,
					i;
				for ( i = 0; i < children.length; i++ ) {
					if ( children[ i ].getElement().$.checked ) {
						children[ i ].getElement().focus();
						return;
					}
				}
				children[ 0 ].getElement().focus();
			},

			/**
			 * Defines the onChange event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					if ( !CKEDITOR.env.ie )
						return commonEventProcessors.onChange.apply( this, arguments );
					else {
						dialog.on( 'load', function() {
							var children = this._.children,
								me = this;
							for ( var i = 0; i < children.length; i++ ) {
								var element = children[ i ].getElement();
								element.on( 'propertychange', function( evt ) {
									evt = evt.data.$;
									if ( evt.propertyName == 'checked' && this.$.checked )
										me.fire( 'change', { value: this.getAttribute( 'value' ) } );
								});
							}
						}, this );
						this.on( 'change', func );
					}
					return null;
				}
			},

			keyboardFocusable: true
		}, commonPrototype, true );

		/** @class CKEDITOR.ui.dialog.file */
		CKEDITOR.ui.dialog.file.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, commonPrototype, {
			/**
			 * Gets the `<input>` element of this file input.
			 *
			 * @returns {CKEDITOR.dom.element} The file input element.
			 */
			getInputElement: function() {
				var frameDocument = CKEDITOR.document.getById( this._.frameId ).getFrameDocument();
				return frameDocument.$.forms.length > 0 ? new CKEDITOR.dom.element( frameDocument.$.forms[ 0 ].elements[ 0 ] ) : this.getElement();
			},

			/**
			 * Uploads the file in the file input.
			 *
			 * @returns {CKEDITOR.ui.dialog.file} This object.
			 */
			submit: function() {
				this.getInputElement().getParent().$.submit();
				return this;
			},

			/**
			 * Get the action assigned to the form.
			 *
			 * @returns {String} The value of the action.
			 */
			getAction: function() {
				return this.getInputElement().getParent().$.action;
			},

			/**
			 * The events must be applied on the inner input element, and
			 * that must be done when the iframe & form has been loaded.
			 */
			registerEvents: function( definition ) {
				var regex = /^on([A-Z]\w+)/,
					match;

				var registerDomEvent = function( uiElement, dialog, eventName, func ) {
						uiElement.on( 'formLoaded', function() {
							uiElement.getInputElement().on( eventName, func, uiElement );
						});
					};

				for ( var i in definition ) {
					if ( !( match = i.match( regex ) ) )
						continue;

					if ( this.eventProcessors[ i ] )
						this.eventProcessors[ i ].call( this, this._.dialog, definition[ i ] );
					else
						registerDomEvent( this, this._.dialog, match[ 1 ].toLowerCase(), definition[ i ] );
				}

				return this;
			},

			/**
			 * Redraws the file input and resets the file path in the file input.
			 * The redraw logic is necessary because non-IE browsers tend to clear
			 * the `<iframe>` containing the file input after closing the dialog.
			 */
			reset: function() {
				var _ = this._,
					frameElement = CKEDITOR.document.getById( _.frameId ),
					frameDocument = frameElement.getFrameDocument(),
					elementDefinition = _.definition,
					buttons = _.buttons,
					callNumber = this.formLoadedNumber,
					unloadNumber = this.formUnloadNumber,
					langDir = _.dialog._.editor.lang.dir,
					langCode = _.dialog._.editor.langCode;

				// The callback function for the iframe, but we must call tools.addFunction only once
				// so we store the function number in this.formLoadedNumber
				if ( !callNumber ) {
					callNumber = this.formLoadedNumber = CKEDITOR.tools.addFunction( function() {
						// Now we can apply the events to the input type=file
						this.fire( 'formLoaded' );
					}, this );

					// Remove listeners attached to the content of the iframe (the file input)
					unloadNumber = this.formUnloadNumber = CKEDITOR.tools.addFunction( function() {
						this.getInputElement().clearCustomData();
					}, this );

					this.getDialog()._.editor.on( 'destroy', function() {
						CKEDITOR.tools.removeFunction( callNumber );
						CKEDITOR.tools.removeFunction( unloadNumber );
					});
				}

				function generateFormField() {
					frameDocument.$.open();

					// Support for custom document.domain in IE.
					if ( CKEDITOR.env.isCustomDomain() )
						frameDocument.$.domain = document.domain;

					var size = '';
					if ( elementDefinition.size )
						size = elementDefinition.size - ( CKEDITOR.env.ie ? 7 : 0 ); // "Browse" button is bigger in IE.

				var inputId = _.frameId + '_input';

					frameDocument.$.write( [ '<html dir="' + langDir + '" lang="' + langCode + '"><head><title></title></head><body style="margin: 0; overflow: hidden; background: transparent;">',
														'<form enctype="multipart/form-data" method="POST" dir="' + langDir + '" lang="' + langCode + '" action="',
														CKEDITOR.tools.htmlEncode( elementDefinition.action ),
														'">',
													// Replicate the field label inside of iframe.
																	'<label id="', _.labelId, '" for="', inputId, '" style="display:none">',
													CKEDITOR.tools.htmlEncode( elementDefinition.label ),
													'</label>',
													'<input id="', inputId, '" aria-labelledby="', _.labelId, '" type="file" name="',
														CKEDITOR.tools.htmlEncode( elementDefinition.id || 'cke_upload' ),
														'" size="',
														CKEDITOR.tools.htmlEncode( size > 0 ? size : "" ),
														'" />',
														'</form>',
														'</body></html>',
														'<script>window.parent.CKEDITOR.tools.callFunction(' + callNumber + ');',
														'window.onbeforeunload = function() {window.parent.CKEDITOR.tools.callFunction(' + unloadNumber + ')}</script>' ].join( '' ) );

					frameDocument.$.close();

					for ( var i = 0; i < buttons.length; i++ )
						buttons[ i ].enable();
				}

				// #3465: Wait for the browser to finish rendering the dialog first.
				if ( CKEDITOR.env.gecko )
					setTimeout( generateFormField, 500 );
				else
					generateFormField();
			},

			getValue: function() {
				return this.getInputElement().$.value || '';
			},

			/***
			 * The default value of input `type="file"` is an empty string, but during initialization
			 * of this UI element, the iframe still isn't ready so it can't be read from that object
			 * Setting it manually prevents later issues about the current value (`''`) being different
			 * of the initial value (undefined as it asked for `.value` of a div).
			 */
			setInitValue: function() {
				this._.initValue = '';
			},

			/**
			 * Defines the onChange event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					// If this method is called several times (I'm not sure about how this can happen but the default
					// onChange processor includes this protection)
					// In order to reapply to the new element, the property is deleted at the beggining of the registerEvents method
					if ( !this._.domOnChangeRegistered ) {
						// By listening for the formLoaded event, this handler will get reapplied when a new
						// form is created
						this.on( 'formLoaded', function() {
							this.getInputElement().on( 'change', function() {
								this.fire( 'change', { value: this.getValue() } );
							}, this );
						}, this );
						this._.domOnChangeRegistered = true;
					}

					this.on( 'change', func );
				}
			},

			keyboardFocusable: true
		}, true );

		CKEDITOR.ui.dialog.fileButton.prototype = new CKEDITOR.ui.dialog.button;

		CKEDITOR.ui.dialog.fieldset.prototype = CKEDITOR.tools.clone( CKEDITOR.ui.dialog.hbox.prototype );

		CKEDITOR.dialog.addUIElement( 'text', textBuilder );
		CKEDITOR.dialog.addUIElement( 'password', textBuilder );
		CKEDITOR.dialog.addUIElement( 'textarea', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'checkbox', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'radio', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'button', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'select', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'file', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'fileButton', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'html', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'fieldset', containerBuilder );
	}
});

/**
 * Fired when the value of the uiElement is changed.
 *
 * @event change
 * @member CKEDITOR.ui.dialog.uiElement
 */

/**
 * Fired when the inner frame created by the element is ready.
 * Each time the button is used or the dialog is loaded a new
 * form might be created.
 *
 * @event formLoaded
 * @member CKEDITOR.ui.dialog.fileButton
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The floating dialog plugin.
 */

/**
 * No resize for this dialog.
 *
 * @readonly
 * @property {Number} [=0]
 * @member CKEDITOR
 */
CKEDITOR.DIALOG_RESIZE_NONE = 0;

/**
 * Only allow horizontal resizing for this dialog, disable vertical resizing.
 *
 * @readonly
 * @property {Number} [=1]
 * @member CKEDITOR
 */
CKEDITOR.DIALOG_RESIZE_WIDTH = 1;

/**
 * Only allow vertical resizing for this dialog, disable horizontal resizing.
 *
 * @readonly
 * @property {Number} [=2]
 * @member CKEDITOR
 */
CKEDITOR.DIALOG_RESIZE_HEIGHT = 2;

/**
 * Allow the dialog to be resized in both directions.
 *
 * @readonly
 * @property {Number} [=3]
 * @member CKEDITOR
 */
CKEDITOR.DIALOG_RESIZE_BOTH = 3;

(function() {
	var cssLength = CKEDITOR.tools.cssLength;

	function isTabVisible( tabId ) {
		return !!this._.tabs[ tabId ][ 0 ].$.offsetHeight;
	}

	function getPreviousVisibleTab() {
		var tabId = this._.currentTabId,
			length = this._.tabIdList.length,
			tabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, tabId ) + length;

		for ( var i = tabIndex - 1; i > tabIndex - length; i-- ) {
			if ( isTabVisible.call( this, this._.tabIdList[ i % length ] ) )
				return this._.tabIdList[ i % length ];
		}

		return null;
	}

	function getNextVisibleTab() {
		var tabId = this._.currentTabId,
			length = this._.tabIdList.length,
			tabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, tabId );

		for ( var i = tabIndex + 1; i < tabIndex + length; i++ ) {
			if ( isTabVisible.call( this, this._.tabIdList[ i % length ] ) )
				return this._.tabIdList[ i % length ];
		}

		return null;
	}


	function clearOrRecoverTextInputValue( container, isRecover ) {
		var inputs = container.$.getElementsByTagName( 'input' );
		for ( var i = 0, length = inputs.length; i < length; i++ ) {
			var item = new CKEDITOR.dom.element( inputs[ i ] );

			if ( item.getAttribute( 'type' ).toLowerCase() == 'text' ) {
				if ( isRecover ) {
					item.setAttribute( 'value', item.getCustomData( 'fake_value' ) || '' );
					item.removeCustomData( 'fake_value' );
				} else {
					item.setCustomData( 'fake_value', item.getAttribute( 'value' ) );
					item.setAttribute( 'value', '' );
				}
			}
		}
	}

	// Handle dialog element validation state UI changes.
	function handleFieldValidated( isValid, msg ) {
		var input = this.getInputElement();
		if ( input ) {
			isValid ? input.removeAttribute( 'aria-invalid' ) : input.setAttribute( 'aria-invalid', true );
		}

		if ( !isValid ) {
			if ( this.select )
				this.select();
			else
				this.focus();
		}

		msg && alert( msg );

		this.fire( 'validated', { valid: isValid, msg: msg } );
	}

	function resetField() {
		var input = this.getInputElement();
		input && input.removeAttribute( 'aria-invalid' );
	}

	var templateSource = '<div class="cke cke_reset_all {editorId} {editorDialogClass}' +
		'" dir="{langDir}"' +
		' lang="{langCode}"' +
		' role="application"' +
		'>' +
		'<table class="cke_dialog ' + CKEDITOR.env.cssClass + ' cke_{langDir}"' +
			' aria-labelledby="cke_dialog_title_{id}"' +
			' style="position:absolute" role="dialog">' +
			'<tr><td role="presentation">' +
			'<div class="cke_dialog_body" role="presentation">' +
				'<div id="cke_dialog_title_{id}" class="cke_dialog_title" role="presentation"></div>' +
				'<a id="cke_dialog_close_button_{id}" class="cke_dialog_close_button" href="javascript:void(0)" title="{closeTitle}" role="button"><span class="cke_label">X</span></a>' +
				'<div id="cke_dialog_tabs_{id}" class="cke_dialog_tabs" role="tablist"></div>' +
				'<table class="cke_dialog_contents" role="presentation">' +
				'<tr>' +
					'<td id="cke_dialog_contents_{id}" class="cke_dialog_contents_body" role="presentation"></td>' +
				'</tr>' +
				'<tr>' +
					'<td id="cke_dialog_footer_{id}" class="cke_dialog_footer" role="presentation"></td>' +
				'</tr>' +
				'</table>' +
			'</div>' +
			'</td></tr>' +
		'</table>' +
		'</div>';

	function buildDialog( editor ) {
		var element = CKEDITOR.dom.element.createFromHtml( CKEDITOR.addTemplate( 'dialog', templateSource ).output({
			id: CKEDITOR.tools.getNextNumber(),
			editorId: editor.id,
			langDir: editor.lang.dir,
			langCode: editor.langCode,
			editorDialogClass: 'cke_editor_' + editor.name.replace( /\./g, '\\.' ) + '_dialog',
			closeTitle: editor.lang.common.close
		}));

		// TODO: Change this to getById(), so it'll support custom templates.
		var body = element.getChild( [ 0, 0, 0, 0, 0 ] ),
			title = body.getChild( 0 ),
			close = body.getChild( 1 );

		// IFrame shim for dialog that masks activeX in IE. (#7619)
		if ( CKEDITOR.env.ie && !CKEDITOR.env.ie6Compat ) {
			var isCustomDomain = CKEDITOR.env.isCustomDomain(),
				src = 'javascript:void(function(){' + encodeURIComponent( 'document.open();' + ( isCustomDomain ? ( 'document.domain="' + document.domain + '";' ) : '' ) + 'document.close();' ) + '}())',
				iframe = CKEDITOR.dom.element.createFromHtml( '<iframe' +
					' frameBorder="0"' +
					' class="cke_iframe_shim"' +
					' src="' + src + '"' +
					' tabIndex="-1"' +
					'></iframe>' );
			iframe.appendTo( body.getParent() );
		}

		// Make the Title and Close Button unselectable.
		title.unselectable();
		close.unselectable();

		return {
			element: element,
			parts: {
				dialog: element.getChild( 0 ),
				title: title,
				close: close,
				tabs: body.getChild( 2 ),
				contents: body.getChild( [ 3, 0, 0, 0 ] ),
				footer: body.getChild( [ 3, 0, 1, 0 ] )
			}
		};
	}

	/**
	 * This is the base class for runtime dialog objects. An instance of this
	 * class represents a single named dialog for a single editor instance.
	 *
	 *		var dialogObj = new CKEDITOR.dialog( editor, 'smiley' );
	 *
	 * @class
	 * @constructor Creates a dialog class instance.
	 * @param {Object} editor The editor which created the dialog.
	 * @param {String} dialogName The dialog's registered name.
	 */
	CKEDITOR.dialog = function( editor, dialogName ) {
		// Load the dialog definition.
		var definition = CKEDITOR.dialog._.dialogDefinitions[ dialogName ],
			defaultDefinition = CKEDITOR.tools.clone( defaultDialogDefinition ),
			buttonsOrder = editor.config.dialog_buttonsOrder || 'OS',
			dir = editor.lang.dir,
			tabsToRemove = {},
			i, processed, stopPropagation;

		if ( ( buttonsOrder == 'OS' && CKEDITOR.env.mac ) || // The buttons in MacOS Apps are in reverse order (#4750)
		( buttonsOrder == 'rtl' && dir == 'ltr' ) || ( buttonsOrder == 'ltr' && dir == 'rtl' ) )
			defaultDefinition.buttons.reverse();


		// Completes the definition with the default values.
		definition = CKEDITOR.tools.extend( definition( editor ), defaultDefinition );

		// Clone a functionally independent copy for this dialog.
		definition = CKEDITOR.tools.clone( definition );

		// Create a complex definition object, extending it with the API
		// functions.
		definition = new definitionObject( this, definition );

		var doc = CKEDITOR.document;

		var themeBuilt = buildDialog( editor );

		// Initialize some basic parameters.
		this._ = {
			editor: editor,
			element: themeBuilt.element,
			name: dialogName,
			contentSize: { width: 0, height: 0 },
			size: { width: 0, height: 0 },
			contents: {},
			buttons: {},
			accessKeyMap: {},

			// Initialize the tab and page map.
			tabs: {},
			tabIdList: [],
			currentTabId: null,
			currentTabIndex: null,
			pageCount: 0,
			lastTab: null,
			tabBarMode: false,

			// Initialize the tab order array for input widgets.
			focusList: [],
			currentFocusIndex: 0,
			hasFocus: false
		};

		this.parts = themeBuilt.parts;

		CKEDITOR.tools.setTimeout( function() {
			editor.fire( 'ariaWidget', this.parts.contents );
		}, 0, this );

		// Set the startup styles for the dialog, avoiding it enlarging the
		// page size on the dialog creation.
		var startStyles = {
			position: CKEDITOR.env.ie6Compat ? 'absolute' : 'fixed',
			top: 0,
			visibility: 'hidden'
		};

		startStyles[ dir == 'rtl' ? 'right' : 'left' ] = 0;
		this.parts.dialog.setStyles( startStyles );


		// Call the CKEDITOR.event constructor to initialize this instance.
		CKEDITOR.event.call( this );

		// Fire the "dialogDefinition" event, making it possible to customize
		// the dialog definition.
		this.definition = definition = CKEDITOR.fire( 'dialogDefinition', {
			name: dialogName,
			definition: definition
		}, editor ).definition;

		// Cache tabs that should be removed.
		if ( !( 'removeDialogTabs' in editor._ ) && editor.config.removeDialogTabs ) {
			var removeContents = editor.config.removeDialogTabs.split( ';' );

			for ( i = 0; i < removeContents.length; i++ ) {
				var parts = removeContents[ i ].split( ':' );
				if ( parts.length == 2 ) {
					var removeDialogName = parts[ 0 ];
					if ( !tabsToRemove[ removeDialogName ] )
						tabsToRemove[ removeDialogName ] = [];
					tabsToRemove[ removeDialogName ].push( parts[ 1 ] );
				}
			}
			editor._.removeDialogTabs = tabsToRemove;
		}

		// Remove tabs of this dialog.
		if ( editor._.removeDialogTabs && ( tabsToRemove = editor._.removeDialogTabs[ dialogName ] ) ) {
			for ( i = 0; i < tabsToRemove.length; i++ )
				definition.removeContents( tabsToRemove[ i ] );
		}

		// Initialize load, show, hide, ok and cancel events.
		if ( definition.onLoad )
			this.on( 'load', definition.onLoad );

		if ( definition.onShow )
			this.on( 'show', definition.onShow );

		if ( definition.onHide )
			this.on( 'hide', definition.onHide );

		if ( definition.onOk ) {
			this.on( 'ok', function( evt ) {
				// Dialog confirm might probably introduce content changes (#5415).
				editor.fire( 'saveSnapshot' );
				setTimeout( function() {
					editor.fire( 'saveSnapshot' );
				}, 0 );
				if ( definition.onOk.call( this, evt ) === false )
					evt.data.hide = false;
			});
		}

		if ( definition.onCancel ) {
			this.on( 'cancel', function( evt ) {
				if ( definition.onCancel.call( this, evt ) === false )
					evt.data.hide = false;
			});
		}

		var me = this;

		// Iterates over all items inside all content in the dialog, calling a
		// function for each of them.
		var iterContents = function( func ) {
				var contents = me._.contents,
					stop = false;

				for ( var i in contents ) {
					for ( var j in contents[ i ] ) {
						stop = func.call( this, contents[ i ][ j ] );
						if ( stop )
							return;
					}
				}
			};

		this.on( 'ok', function( evt ) {
			iterContents( function( item ) {
				if ( item.validate ) {
					var retval = item.validate( this ),
						invalid = typeof( retval ) == 'string' || retval === false;

					if ( invalid ) {
						evt.data.hide = false;
						evt.stop();
					}

					handleFieldValidated.call( item, !invalid, typeof retval == 'string' ? retval : undefined );
					return invalid;
				}
			});
		}, this, null, 0 );

		this.on( 'cancel', function( evt ) {
			iterContents( function( item ) {
				if ( item.isChanged() ) {
					if ( !confirm( editor.lang.common.confirmCancel ) )
						evt.data.hide = false;
					return true;
				}
			});
		}, this, null, 0 );

		this.parts.close.on( 'click', function( evt ) {
			if ( this.fire( 'cancel', { hide: true } ).hide !== false )
				this.hide();
			evt.data.preventDefault();
		}, this );

		// Sort focus list according to tab order definitions.
		function setupFocus() {
			var focusList = me._.focusList;
			focusList.sort( function( a, b ) {
				// Mimics browser tab order logics;
				if ( a.tabIndex != b.tabIndex )
					return b.tabIndex - a.tabIndex;
				//  Sort is not stable in some browsers,
				// fall-back the comparator to 'focusIndex';
				else
					return a.focusIndex - b.focusIndex;
			});

			var size = focusList.length;
			for ( var i = 0; i < size; i++ )
				focusList[ i ].focusIndex = i;
		}

		function changeFocus( offset ) {
			var focusList = me._.focusList;
			offset = offset || 0;

			if ( focusList.length < 1 )
				return;

			var current = me._.currentFocusIndex;

			// Trigger the 'blur' event of  any input element before anything,
			// since certain UI updates may depend on it.
			try {
				focusList[ current ].getInputElement().$.blur();
			} catch ( e ) {}

			var startIndex = ( current + offset + focusList.length ) % focusList.length,
				currentIndex = startIndex;
			while ( offset && !focusList[ currentIndex ].isFocusable() ) {
				currentIndex = ( currentIndex + offset + focusList.length ) % focusList.length;
				if ( currentIndex == startIndex )
					break;
			}

			focusList[ currentIndex ].focus();

			// Select whole field content.
			if ( focusList[ currentIndex ].type == 'text' )
				focusList[ currentIndex ].select();
		}

		this.changeFocus = changeFocus;


		function keydownHandler( evt ) {
			// If I'm not the top dialog, ignore.
			if ( me != CKEDITOR.dialog._.currentTop )
				return;

			var keystroke = evt.data.getKeystroke(),
				rtl = editor.lang.dir == 'rtl',
				button;

			processed = stopPropagation = 0;

			if ( keystroke == 9 || keystroke == CKEDITOR.SHIFT + 9 ) {
				var shiftPressed = ( keystroke == CKEDITOR.SHIFT + 9 );

				// Handling Tab and Shift-Tab.
				if ( me._.tabBarMode ) {
					// Change tabs.
					var nextId = shiftPressed ? getPreviousVisibleTab.call( me ) : getNextVisibleTab.call( me );
					me.selectPage( nextId );
					me._.tabs[ nextId ][ 0 ].focus();
				} else {
					// Change the focus of inputs.
					changeFocus( shiftPressed ? -1 : 1 );
				}

				processed = 1;
			} else if ( keystroke == CKEDITOR.ALT + 121 && !me._.tabBarMode && me.getPageCount() > 1 ) {
				// Alt-F10 puts focus into the current tab item in the tab bar.
				me._.tabBarMode = true;
				me._.tabs[ me._.currentTabId ][ 0 ].focus();
				processed = 1;
			} else if ( ( keystroke == 37 || keystroke == 39 ) && me._.tabBarMode ) {
				// Arrow keys - used for changing tabs.
				nextId = ( keystroke == ( rtl ? 39 : 37 ) ? getPreviousVisibleTab.call( me ) : getNextVisibleTab.call( me ) );
				me.selectPage( nextId );
				me._.tabs[ nextId ][ 0 ].focus();
				processed = 1;
			} else if ( ( keystroke == 13 || keystroke == 32 ) && me._.tabBarMode ) {
				this.selectPage( this._.currentTabId );
				this._.tabBarMode = false;
				this._.currentFocusIndex = -1;
				changeFocus( 1 );
				processed = 1;
			}
			// If user presses enter key in a text box, it implies clicking OK for the dialog.
			else if ( keystroke == 13 /*ENTER*/ ) {
				// Don't do that for a target that handles ENTER.
				var target = evt.data.getTarget();
				if ( !target.is( 'a', 'button', 'select', 'textarea' ) && ( !target.is( 'input' ) || target.$.type != 'button' ) ) {
					button = this.getButton( 'ok' );
					button && CKEDITOR.tools.setTimeout( button.click, 0, button );
					processed = 1;
				}
				stopPropagation = 1; // Always block the propagation (#4269)
			} else if ( keystroke == 27 /*ESC*/ ) {
				button = this.getButton( 'cancel' );

				// If there's a Cancel button, click it, else just fire the cancel event and hide the dialog.
				if ( button )
					CKEDITOR.tools.setTimeout( button.click, 0, button );
				else {
					if ( this.fire( 'cancel', { hide: true } ).hide !== false )
						this.hide();
				}
				stopPropagation = 1; // Always block the propagation (#4269)
			} else
				return;

			keypressHandler( evt );
		}

		function keypressHandler( evt ) {
			if ( processed )
				evt.data.preventDefault( 1 );
			else if ( stopPropagation )
				evt.data.stopPropagation();
		}

		var dialogElement = this._.element;

		editor.focusManager.add( dialogElement, 1 );

		// Add the dialog keyboard handlers.
		this.on( 'show', function() {
			dialogElement.on( 'keydown', keydownHandler, this );

			// Some browsers instead, don't cancel key events in the keydown, but in the
			// keypress. So we must do a longer trip in those cases. (#4531,#8985)
			if ( CKEDITOR.env.opera || CKEDITOR.env.gecko )
				dialogElement.on( 'keypress', keypressHandler, this );

		});
		this.on( 'hide', function() {
			dialogElement.removeListener( 'keydown', keydownHandler );
			if ( CKEDITOR.env.opera || CKEDITOR.env.gecko )
				dialogElement.removeListener( 'keypress', keypressHandler );

			// Reset fields state when closing dialog.
			iterContents( function( item ) {
				resetField.apply( item );
			});
		});
		this.on( 'iframeAdded', function( evt ) {
			var doc = new CKEDITOR.dom.document( evt.data.iframe.$.contentWindow.document );
			doc.on( 'keydown', keydownHandler, this, null, 0 );
		});

		// Auto-focus logic in dialog.
		this.on( 'show', function() {
			// Setup tabIndex on showing the dialog instead of on loading
			// to allow dynamic tab order happen in dialog definition.
			setupFocus();

			if ( editor.config.dialog_startupFocusTab && me._.pageCount > 1 ) {
				me._.tabBarMode = true;
				me._.tabs[ me._.currentTabId ][ 0 ].focus();
			} else if ( !this._.hasFocus ) {
				this._.currentFocusIndex = -1;

				// Decide where to put the initial focus.
				if ( definition.onFocus ) {
					var initialFocus = definition.onFocus.call( this );
					// Focus the field that the user specified.
					initialFocus && initialFocus.focus();
				}
				// Focus the first field in layout order.
				else
					changeFocus( 1 );
			}
		}, this, null, 0xffffffff );

		// IE6 BUG: Text fields and text areas are only half-rendered the first time the dialog appears in IE6 (#2661).
		// This is still needed after [2708] and [2709] because text fields in hidden TR tags are still broken.
		if ( CKEDITOR.env.ie6Compat ) {
			this.on( 'load', function( evt ) {
				var outer = this.getElement(),
					inner = outer.getFirst();
				inner.remove();
				inner.appendTo( outer );
			}, this );
		}

		initDragAndDrop( this );
		initResizeHandles( this );

		// Insert the title.
		( new CKEDITOR.dom.text( definition.title, CKEDITOR.document ) ).appendTo( this.parts.title );

		// Insert the tabs and contents.
		for ( i = 0; i < definition.contents.length; i++ ) {
			var page = definition.contents[ i ];
			page && this.addPage( page );
		}

		this.parts[ 'tabs' ].on( 'click', function( evt ) {
			var target = evt.data.getTarget();
			// If we aren't inside a tab, bail out.
			if ( target.hasClass( 'cke_dialog_tab' ) ) {
				// Get the ID of the tab, without the 'cke_' prefix and the unique number suffix.
				var id = target.$.id;
				this.selectPage( id.substring( 4, id.lastIndexOf( '_' ) ) );

				if ( this._.tabBarMode ) {
					this._.tabBarMode = false;
					this._.currentFocusIndex = -1;
					changeFocus( 1 );
				}
				evt.data.preventDefault();
			}
		}, this );

		// Insert buttons.
		var buttonsHtml = [],
			buttons = CKEDITOR.dialog._.uiElementBuilders.hbox.build( this, {
				type: 'hbox',
				className: 'cke_dialog_footer_buttons',
				widths: [],
				children: definition.buttons
			}, buttonsHtml ).getChild();
		this.parts.footer.setHtml( buttonsHtml.join( '' ) );

		for ( i = 0; i < buttons.length; i++ )
			this._.buttons[ buttons[ i ].id ] = buttons[ i ];
	};

	// Focusable interface. Use it via dialog.addFocusable.
	function Focusable( dialog, element, index ) {
		this.element = element;
		this.focusIndex = index;
		// TODO: support tabIndex for focusables.
		this.tabIndex = 0;
		this.isFocusable = function() {
			return !element.getAttribute( 'disabled' ) && element.isVisible();
		};
		this.focus = function() {
			dialog._.currentFocusIndex = this.focusIndex;
			this.element.focus();
		};
		// Bind events
		element.on( 'keydown', function( e ) {
			if ( e.data.getKeystroke() in { 32:1,13:1 } )
				this.fire( 'click' );
		});
		element.on( 'focus', function() {
			this.fire( 'mouseover' );
		});
		element.on( 'blur', function() {
			this.fire( 'mouseout' );
		});
	}

	// Re-layout the dialog on window resize.
	function resizeWithWindow( dialog ) {
		var win = CKEDITOR.document.getWindow();
		function resizeHandler() { dialog.layout(); }
		win.on( 'resize', resizeHandler );
		dialog.on( 'hide', function() { win.removeListener( 'resize', resizeHandler ); } );
	}

	CKEDITOR.dialog.prototype = {
		destroy: function() {
			this.hide();
			this._.element.remove();
		},

		/**
		 * Resizes the dialog.
		 *
		 *		dialogObj.resize( 800, 640 );
		 *
		 * @method
		 * @param {Number} width The width of the dialog in pixels.
		 * @param {Number} height The height of the dialog in pixels.
		 */
		resize: (function() {
			return function( width, height ) {
				if ( this._.contentSize && this._.contentSize.width == width && this._.contentSize.height == height )
					return;

				CKEDITOR.dialog.fire( 'resize', {
					dialog: this,
					width: width,
					height: height
				}, this._.editor );

				this.fire( 'resize', {
					width: width,
					height: height
				}, this._.editor );

				var contents = this.parts.contents;
				contents.setStyles({
					width: width + 'px',
					height: height + 'px'
				});

				// Update dialog position when dimension get changed in RTL.
				if ( this._.editor.lang.dir == 'rtl' && this._.position )
					this._.position.x = CKEDITOR.document.getWindow().getViewPaneSize().width - this._.contentSize.width - parseInt( this._.element.getFirst().getStyle( 'right' ), 10 );

				this._.contentSize = { width: width, height: height };
			};
		})(),

		/**
		 * Gets the current size of the dialog in pixels.
		 *
		 * var width = dialogObj.getSize().width;
		 *
		 * @returns {Object}
		 * @returns {Number} return.width
		 * @returns {Number} return.height
		 */
		getSize: function() {
			var element = this._.element.getFirst();
			return { width: element.$.offsetWidth || 0, height: element.$.offsetHeight || 0 };
		},

		/**
		 * Moves the dialog to an `(x, y)` coordinate relative to the window.
		 *
		 * dialogObj.move( 10, 40 );
		 *
		 * @method
		 * @param {Number} x The target x-coordinate.
		 * @param {Number} y The target y-coordinate.
		 * @param {Boolean} save Flag indicate whether the dialog position should be remembered on next open up.
		 */
		move: function( x, y, save ) {

			// The dialog may be fixed positioned or absolute positioned. Ask the
			// browser what is the current situation first.
			var element = this._.element.getFirst(), rtl = this._.editor.lang.dir == 'rtl';
			var isFixed = element.getComputedStyle( 'position' ) == 'fixed';

			// (#8888) In some cases of a very small viewport, dialog is incorrectly
			// positioned in IE7. It also happens that it remains sticky and user cannot
			// scroll down/up to reveal dialog's content below/above the viewport; this is
			// cumbersome.
			// The only way to fix this is to move mouse out of the browser and
			// go back to see that dialog position is automagically fixed. No events,
			// no style change - pure magic. This is a IE7 rendering issue, which can be
			// fixed with dummy style redraw on each move.
			if ( CKEDITOR.env.ie )
				element.setStyle( 'zoom', '100%' );

			if ( isFixed && this._.position && this._.position.x == x && this._.position.y == y )
				return;

			// Save the current position.
			this._.position = { x: x, y: y };

			// If not fixed positioned, add scroll position to the coordinates.
			if ( !isFixed ) {
				var scrollPosition = CKEDITOR.document.getWindow().getScrollPosition();
				x += scrollPosition.x;
				y += scrollPosition.y;
			}

			// Translate coordinate for RTL.
			if ( rtl ) {
				var dialogSize = this.getSize(), viewPaneSize = CKEDITOR.document.getWindow().getViewPaneSize();
				x = viewPaneSize.width - dialogSize.width - x;
			}

			var styles = { 'top': ( y > 0 ? y : 0 ) + 'px' };
			styles[ rtl ? 'right' : 'left' ] = ( x > 0 ? x : 0 ) + 'px';

			element.setStyles( styles );

			save && ( this._.moved = 1 );
		},

		/**
		 * Gets the dialog's position in the window.
		 *
		 *		var dialogX = dialogObj.getPosition().x;
		 *
		 * @returns {Object}
		 * @returns {Number} return.x
		 * @returns {Number} return.y
		 */
		getPosition: function() {
			return CKEDITOR.tools.extend( {}, this._.position );
		},

		/**
		 * Shows the dialog box.
		 *
		 *		dialogObj.show();
		 */
		show: function() {
			// Insert the dialog's element to the root document.
			var element = this._.element;
			var definition = this.definition;
			if ( !( element.getParent() && element.getParent().equals( CKEDITOR.document.getBody() ) ) )
				element.appendTo( CKEDITOR.document.getBody() );
			else
				element.setStyle( 'display', 'block' );

			// FIREFOX BUG: Fix vanishing caret for Firefox 2 or Gecko 1.8.
			if ( CKEDITOR.env.gecko && CKEDITOR.env.version < 10900 ) {
				var dialogElement = this.parts.dialog;
				dialogElement.setStyle( 'position', 'absolute' );
				setTimeout( function() {
					dialogElement.setStyle( 'position', 'fixed' );
				}, 0 );
			}


			// First, set the dialog to an appropriate size.
			this.resize( this._.contentSize && this._.contentSize.width || definition.width || definition.minWidth, this._.contentSize && this._.contentSize.height || definition.height || definition.minHeight );

			// Reset all inputs back to their default value.
			this.reset();

			// Select the first tab by default.
			this.selectPage( this.definition.contents[ 0 ].id );

			// Set z-index.
			if ( CKEDITOR.dialog._.currentZIndex === null )
				CKEDITOR.dialog._.currentZIndex = this._.editor.config.baseFloatZIndex;
			this._.element.getFirst().setStyle( 'z-index', CKEDITOR.dialog._.currentZIndex += 10 );

			// Maintain the dialog ordering and dialog cover.
			if ( CKEDITOR.dialog._.currentTop === null ) {
				CKEDITOR.dialog._.currentTop = this;
				this._.parentDialog = null;
				showCover( this._.editor );

			} else {
				this._.parentDialog = CKEDITOR.dialog._.currentTop;
				var parentElement = this._.parentDialog.getElement().getFirst();
				parentElement.$.style.zIndex -= Math.floor( this._.editor.config.baseFloatZIndex / 2 );
				CKEDITOR.dialog._.currentTop = this;
			}

			element.on( 'keydown', accessKeyDownHandler );
			element.on( CKEDITOR.env.opera ? 'keypress' : 'keyup', accessKeyUpHandler );

			// Reset the hasFocus state.
			this._.hasFocus = false;

			CKEDITOR.tools.setTimeout( function() {
				this.layout();
				resizeWithWindow( this );

				this.parts.dialog.setStyle( 'visibility', '' );

				// Execute onLoad for the first show.
				this.fireOnce( 'load', {} );
				CKEDITOR.ui.fire( 'ready', this );

				this.fire( 'show', {} );
				this._.editor.fire( 'dialogShow', this );

				if ( !this._.parentDialog )
					this._.editor.focusManager.lock();

				// Save the initial values of the dialog.
				this.foreach( function( contentObj ) {
					contentObj.setInitValue && contentObj.setInitValue();
				});

			}, 100, this );
		},

		/**
		 * Rearrange the dialog to its previous position or the middle of the window.
		 *
		 * @since 3.5
		 */
		layout: function() {
			var el = this.parts.dialog;
			var dialogSize = this.getSize();
			var win = CKEDITOR.document.getWindow(),
					viewSize = win.getViewPaneSize();

			var posX = ( viewSize.width - dialogSize.width ) / 2,
				posY = ( viewSize.height - dialogSize.height ) / 2;

			// Switch to absolute position when viewport is smaller than dialog size.
			if ( !CKEDITOR.env.ie6Compat ) {
				if ( dialogSize.height + ( posY > 0 ? posY : 0 ) > viewSize.height ||
						 dialogSize.width + ( posX > 0 ? posX : 0 ) > viewSize.width )
					el.setStyle( 'position', 'absolute' );
				else
					el.setStyle( 'position', 'fixed' );
			}

			this.move( this._.moved ? this._.position.x : posX,
					this._.moved ? this._.position.y : posY );
		},

		/**
		 * Executes a function for each UI element.
		 *
		 * @param {Function} fn Function to execute for each UI element.
		 * @returns {CKEDITOR.dialog} The current dialog object.
		 */
		foreach: function( fn ) {
			for ( var i in this._.contents ) {
				for ( var j in this._.contents[ i ] )
					fn.call( this, this._.contents[ i ][ j ] );
			}
			return this;
		},

		/**
		 * Resets all input values in the dialog.
		 *
		 *		dialogObj.reset();
		 *
		 * @method
		 * @chainable
		 */
		reset: (function() {
			var fn = function( widget ) {
					if ( widget.reset )
						widget.reset( 1 );
				};
			return function() {
				this.foreach( fn );
				return this;
			};
		})(),


		/**
		 * Calls the {@link CKEDITOR.dialog.definition.uiElement#setup} method of each
		 * of the UI elements, with the arguments passed through it.
		 * It is usually being called when the dialog is opened, to put the initial value inside the field.
		 *
		 *		dialogObj.setupContent();
		 *
		 *		var timestamp = ( new Date() ).valueOf();
		 *		dialogObj.setupContent( timestamp );
		 */
		setupContent: function() {
			var args = arguments;
			this.foreach( function( widget ) {
				if ( widget.setup )
					widget.setup.apply( widget, args );
			});
		},

		/**
		 * Calls the {@link CKEDITOR.dialog.definition.uiElement#commit} method of each
		 * of the UI elements, with the arguments passed through it.
		 * It is usually being called when the user confirms the dialog, to process the values.
		 *
		 *		dialogObj.commitContent();
		 *
		 *		var timestamp = ( new Date() ).valueOf();
		 *		dialogObj.commitContent( timestamp );
		 */
		commitContent: function() {
			var args = arguments;
			this.foreach( function( widget ) {
				// Make sure IE triggers "change" event on last focused input before closing the dialog. (#7915)
				if ( CKEDITOR.env.ie && this._.currentFocusIndex == widget.focusIndex )
					widget.getInputElement().$.blur();

				if ( widget.commit )
					widget.commit.apply( widget, args );
			});
		},

		/**
		 * Hides the dialog box.
		 *
		 *		dialogObj.hide();
		 */
		hide: function() {
			if ( !this.parts.dialog.isVisible() )
				return;

			this.fire( 'hide', {} );
			this._.editor.fire( 'dialogHide', this );
			// Reset the tab page.
			this.selectPage( this._.tabIdList[ 0 ] );
			var element = this._.element;
			element.setStyle( 'display', 'none' );
			this.parts.dialog.setStyle( 'visibility', 'hidden' );
			// Unregister all access keys associated with this dialog.
			unregisterAccessKey( this );

			// Close any child(top) dialogs first.
			while ( CKEDITOR.dialog._.currentTop != this )
				CKEDITOR.dialog._.currentTop.hide();

			// Maintain dialog ordering and remove cover if needed.
			if ( !this._.parentDialog )
				hideCover( this._.editor );
			else {
				var parentElement = this._.parentDialog.getElement().getFirst();
				parentElement.setStyle( 'z-index', parseInt( parentElement.$.style.zIndex, 10 ) + Math.floor( this._.editor.config.baseFloatZIndex / 2 ) );
			}
			CKEDITOR.dialog._.currentTop = this._.parentDialog;

			// Deduct or clear the z-index.
			if ( !this._.parentDialog ) {
				CKEDITOR.dialog._.currentZIndex = null;

				// Remove access key handlers.
				element.removeListener( 'keydown', accessKeyDownHandler );
				element.removeListener( CKEDITOR.env.opera ? 'keypress' : 'keyup', accessKeyUpHandler );

				var editor = this._.editor;
				editor.focus();

				// Give a while before unlock, waiting for focus to return to the editable. (#172)
				setTimeout( function() { editor.focusManager.unlock(); }, 0 );

			} else
				CKEDITOR.dialog._.currentZIndex -= 10;

			delete this._.parentDialog;
			// Reset the initial values of the dialog.
			this.foreach( function( contentObj ) {
				contentObj.resetInitValue && contentObj.resetInitValue();
			});
		},

		/**
		 * Adds a tabbed page into the dialog.
		 *
		 * @param {Object} contents Content definition.
		 */
		addPage: function( contents ) {
			if ( contents.requiredContent && !this._.editor.filter.check( contents.requiredContent ) )
				return;

			var pageHtml = [],
				titleHtml = contents.label ? ' title="' + CKEDITOR.tools.htmlEncode( contents.label ) + '"' : '',
				elements = contents.elements,
				vbox = CKEDITOR.dialog._.uiElementBuilders.vbox.build( this, {
					type: 'vbox',
					className: 'cke_dialog_page_contents',
					children: contents.elements,
					expand: !!contents.expand,
					padding: contents.padding,
					style: contents.style || 'width: 100%;'
				}, pageHtml );

			var contentMap = this._.contents[ contents.id ] = {},
				cursor,
				children = vbox.getChild(),
				enabledFields = 0;

			while ( ( cursor = children.shift() ) ) {
				// Count all allowed fields.
				if ( !cursor.notAllowed && cursor.type != 'hbox' && cursor.type != 'vbox' )
					enabledFields++;

				contentMap[ cursor.id ] = cursor;
				if ( typeof( cursor.getChild ) == 'function' )
					children.push.apply( children, cursor.getChild() );
			}

			// If all fields are disabled (because they are not allowed) hide this tab.
			if ( !enabledFields )
				contents.hidden = true;

			// Create the HTML for the tab and the content block.
			var page = CKEDITOR.dom.element.createFromHtml( pageHtml.join( '' ) );
			page.setAttribute( 'role', 'tabpanel' );

			var env = CKEDITOR.env;
			var tabId = 'cke_' + contents.id + '_' + CKEDITOR.tools.getNextNumber(),
				tab = CKEDITOR.dom.element.createFromHtml( [
					'<a class="cke_dialog_tab"',
						( this._.pageCount > 0 ? ' cke_last' : 'cke_first' ),
						titleHtml,
						( !!contents.hidden ? ' style="display:none"' : '' ),
						' id="', tabId, '"',
						env.gecko && env.version >= 10900 && !env.hc ? '' : ' href="javascript:void(0)"',
						' tabIndex="-1"',
						' hidefocus="true"',
						' role="tab">',
							contents.label,
					'</a>'
					].join( '' ) );

			page.setAttribute( 'aria-labelledby', tabId );

			// Take records for the tabs and elements created.
			this._.tabs[ contents.id ] = [ tab, page ];
			this._.tabIdList.push( contents.id );
			!contents.hidden && this._.pageCount++;
			this._.lastTab = tab;
			this.updateStyle();

			// Attach the DOM nodes.

			page.setAttribute( 'name', contents.id );
			page.appendTo( this.parts.contents );

			tab.unselectable();
			this.parts.tabs.append( tab );

			// Add access key handlers if access key is defined.
			if ( contents.accessKey ) {
				registerAccessKey( this, this, 'CTRL+' + contents.accessKey, tabAccessKeyDown, tabAccessKeyUp );
				this._.accessKeyMap[ 'CTRL+' + contents.accessKey ] = contents.id;
			}
		},

		/**
		 * Activates a tab page in the dialog by its id.
		 *
		 *		dialogObj.selectPage( 'tab_1' );
		 *
		 * @param {String} id The id of the dialog tab to be activated.
		 */
		selectPage: function( id ) {
			if ( this._.currentTabId == id )
				return;

			// Returning true means that the event has been canceled
			if ( this.fire( 'selectPage', { page: id, currentPage: this._.currentTabId } ) === true )
				return;

			// Hide the non-selected tabs and pages.
			for ( var i in this._.tabs ) {
				var tab = this._.tabs[ i ][ 0 ],
					page = this._.tabs[ i ][ 1 ];
				if ( i != id ) {
					tab.removeClass( 'cke_dialog_tab_selected' );
					page.hide();
				}
				page.setAttribute( 'aria-hidden', i != id );
			}

			var selected = this._.tabs[ id ];
			selected[ 0 ].addClass( 'cke_dialog_tab_selected' );

			// [IE] an invisible input[type='text'] will enlarge it's width
			// if it's value is long when it shows, so we clear it's value
			// before it shows and then recover it (#5649)
			if ( CKEDITOR.env.ie6Compat || CKEDITOR.env.ie7Compat ) {
				clearOrRecoverTextInputValue( selected[ 1 ] );
				selected[ 1 ].show();
				setTimeout( function() {
					clearOrRecoverTextInputValue( selected[ 1 ], 1 );
				}, 0 );
			} else
				selected[ 1 ].show();

			this._.currentTabId = id;
			this._.currentTabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, id );
		},

		/**
		 * Dialog state-specific style updates.
		 */
		updateStyle: function() {
			// If only a single page shown, a different style is used in the central pane.
			this.parts.dialog[ ( this._.pageCount === 1 ? 'add' : 'remove' ) + 'Class' ]( 'cke_single_page' );
		},

		/**
		 * Hides a page's tab away from the dialog.
		 *
		 *		dialog.hidePage( 'tab_3' );
		 *
		 * @param {String} id The page's Id.
		 */
		hidePage: function( id ) {
			var tab = this._.tabs[ id ] && this._.tabs[ id ][ 0 ];
			if ( !tab || this._.pageCount == 1 || !tab.isVisible() )
				return;
			// Switch to other tab first when we're hiding the active tab.
			else if ( id == this._.currentTabId )
				this.selectPage( getPreviousVisibleTab.call( this ) );

			tab.hide();
			this._.pageCount--;
			this.updateStyle();
		},

		/**
		 * Unhides a page's tab.
		 *
		 *		dialog.showPage( 'tab_2' );
		 *
		 * @param {String} id The page's Id.
		 */
		showPage: function( id ) {
			var tab = this._.tabs[ id ] && this._.tabs[ id ][ 0 ];
			if ( !tab )
				return;
			tab.show();
			this._.pageCount++;
			this.updateStyle();
		},

		/**
		 * Gets the root DOM element of the dialog.
		 *
		 *		var dialogElement = dialogObj.getElement().getFirst();
		 *		dialogElement.setStyle( 'padding', '5px' );
		 *
		 * @returns {CKEDITOR.dom.element} The `<span>` element containing this dialog.
		 */
		getElement: function() {
			return this._.element;
		},

		/**
		 * Gets the name of the dialog.
		 *
		 *		var dialogName = dialogObj.getName();
		 *
		 * @returns {String} The name of this dialog.
		 */
		getName: function() {
			return this._.name;
		},

		/**
		 * Gets a dialog UI element object from a dialog page.
		 *
		 *		dialogObj.getContentElement( 'tabId', 'elementId' ).setValue( 'Example' );
		 *
		 * @param {String} pageId id of dialog page.
		 * @param {String} elementId id of UI element.
		 * @returns {CKEDITOR.ui.dialog.uiElement} The dialog UI element.
		 */
		getContentElement: function( pageId, elementId ) {
			var page = this._.contents[ pageId ];
			return page && page[ elementId ];
		},

		/**
		 * Gets the value of a dialog UI element.
		 *
		 *		alert( dialogObj.getValueOf( 'tabId', 'elementId' ) );
		 *
		 * @param {String} pageId id of dialog page.
		 * @param {String} elementId id of UI element.
		 * @returns {Object} The value of the UI element.
		 */
		getValueOf: function( pageId, elementId ) {
			return this.getContentElement( pageId, elementId ).getValue();
		},

		/**
		 * Sets the value of a dialog UI element.
		 *
		 *		dialogObj.setValueOf( 'tabId', 'elementId', 'Example' );
		 *
		 * @param {String} pageId id of the dialog page.
		 * @param {String} elementId id of the UI element.
		 * @param {Object} value The new value of the UI element.
		 */
		setValueOf: function( pageId, elementId, value ) {
			return this.getContentElement( pageId, elementId ).setValue( value );
		},

		/**
		 * Gets the UI element of a button in the dialog's button row.
		 *
		 *		@returns {CKEDITOR.ui.dialog.button} The button object.
		 *
		 * @param {String} id The id of the button.
		 */
		getButton: function( id ) {
			return this._.buttons[ id ];
		},

		/**
		 * Simulates a click to a dialog button in the dialog's button row.
		 *
		 * @returns The return value of the dialog's `click` event.
		 *
		 * @param {String} id The id of the button.
		 */
		click: function( id ) {
			return this._.buttons[ id ].click();
		},

		/**
		 * Disables a dialog button.
		 *
		 * @param {String} id The id of the button.
		 */
		disableButton: function( id ) {
			return this._.buttons[ id ].disable();
		},

		/**
		 * Enables a dialog button.
		 *
		 * @param {String} id The id of the button.
		 */
		enableButton: function( id ) {
			return this._.buttons[ id ].enable();
		},

		/**
		 * Gets the number of pages in the dialog.
		 *
		 * @returns {Number} Page count.
		 */
		getPageCount: function() {
			return this._.pageCount;
		},

		/**
		 * Gets the editor instance which opened this dialog.
		 *
		 * @returns {CKEDITOR.editor} Parent editor instances.
		 */
		getParentEditor: function() {
			return this._.editor;
		},

		/**
		 * Gets the element that was selected when opening the dialog, if any.
		 *
		 * @returns {CKEDITOR.dom.element} The element that was selected, or `null`.
		 */
		getSelectedElement: function() {
			return this.getParentEditor().getSelection().getSelectedElement();
		},

		/**
		 * Adds element to dialog's focusable list.
		 *
		 * @param {CKEDITOR.dom.element} element
		 * @param {Number} [index]
		 */
		addFocusable: function( element, index ) {
			if ( typeof index == 'undefined' ) {
				index = this._.focusList.length;
				this._.focusList.push( new Focusable( this, element, index ) );
			} else {
				this._.focusList.splice( index, 0, new Focusable( this, element, index ) );
				for ( var i = index + 1; i < this._.focusList.length; i++ )
					this._.focusList[ i ].focusIndex++;
			}
		}
	};

	CKEDITOR.tools.extend( CKEDITOR.dialog, {
		/**
		 * Registers a dialog.
		 *
		 *		// Full sample plugin, which does not only register a dialog window but also adds an item to the context menu.
		 *		// To open the dialog window, choose "Open dialog" in the context menu.
		 *		CKEDITOR.plugins.add( 'myplugin', {
		 *			init: function( editor ) {
		 *				editor.addCommand( 'mydialog',new CKEDITOR.dialogCommand( 'mydialog' ) );
		 *
		 *				if ( editor.contextMenu ) {
		 *					editor.addMenuGroup( 'mygroup', 10 );
		 *					editor.addMenuItem( 'My Dialog', {
		 *						label: 'Open dialog',
		 *						command: 'mydialog',
		 *						group: 'mygroup'
		 *					} );
		 *					editor.contextMenu.addListener( function( element ) {
		 *						return { 'My Dialog': CKEDITOR.TRISTATE_OFF };
		 *					} );
		 *				}
		 *
		 *				CKEDITOR.dialog.add( 'mydialog', function( api ) {
		 *					// CKEDITOR.dialog.definition
		 *					var dialogDefinition = {
		 *						title: 'Sample dialog',
		 *						minWidth: 390,
		 *						minHeight: 130,
		 *						contents: [
		 *							{
		 *								id: 'tab1',
		 *								label: 'Label',
		 *								title: 'Title',
		 *								expand: true,
		 *								padding: 0,
		 *								elements: [
		 *									{
		 *										type: 'html',
		 *										html: '<p>This is some sample HTML content.</p>'
		 *									},
		 *									{
		 *										type: 'textarea',
		 *										id: 'textareaId',
		 *										rows: 4,
		 *										cols: 40
		 *									}
		 *								]
		 *							}
		 *						],
		 *						buttons: [ CKEDITOR.dialog.okButton, CKEDITOR.dialog.cancelButton ],
		 *						onOk: function() {
		 *							// "this" is now a CKEDITOR.dialog object.
		 *							// Accessing dialog elements:
		 *							var textareaObj = this.getContentElement( 'tab1', 'textareaId' );
		 *							alert( "You have entered: " + textareaObj.getValue() );
		 *						}
		 *					};
		 *
		 *					return dialogDefinition;
		 *				} );
		 *			}
		 *		} );
		 *
		 *		CKEDITOR.replace( 'editor1', { extraPlugins: 'myplugin' } );
		 *
		 * @static
		 * @param {String} name The dialog's name.
		 * @param {Function/String} dialogDefinition
		 * A function returning the dialog's definition, or the URL to the `.js` file holding the function.
		 * The function should accept an argument `editor` which is the current editor instance, and
		 * return an object conforming to {@link CKEDITOR.dialog.definition}.
		 * @see CKEDITOR.dialog.definition
		 */
		add: function( name, dialogDefinition ) {
			// Avoid path registration from multiple instances override definition.
			if ( !this._.dialogDefinitions[ name ] || typeof dialogDefinition == 'function' )
				this._.dialogDefinitions[ name ] = dialogDefinition;
		},

		/**
		 * @static
		 * @todo
		 */
		exists: function( name ) {
			return !!this._.dialogDefinitions[ name ];
		},

		/**
		 * @static
		 * @todo
		 */
		getCurrent: function() {
			return CKEDITOR.dialog._.currentTop;
		},

		/**
		 * Check whether tab wasn't removed by {@link CKEDITOR.config#removeDialogTabs}.
		 *
		 * @since 4.1
		 * @static
		 * @param {CKEDITOR.editor} editor
		 * @param {String} dialogName
		 * @param {String} tabName
		 * @returns {Boolean}
		 */
		isTabEnabled: function( editor, dialogName, tabName ) {
			var cfg = editor.config.removeDialogTabs;

			return !( cfg && cfg.match( new RegExp( '(?:^|;)' + dialogName + ':' + tabName + '(?:$|;)', 'i' ) ) );
		},

		/**
		 * The default OK button for dialogs. Fires the `ok` event and closes the dialog if the event succeeds.
		 *
		 * @static
		 * @method
		 */
		okButton: (function() {
			var retval = function( editor, override ) {
					override = override || {};
					return CKEDITOR.tools.extend({
						id: 'ok',
						type: 'button',
						label: editor.lang.common.ok,
						'class': 'cke_dialog_ui_button_ok',
						onClick: function( evt ) {
							var dialog = evt.data.dialog;
							if ( dialog.fire( 'ok', { hide: true } ).hide !== false )
								dialog.hide();
						}
					}, override, true );
				};
			retval.type = 'button';
			retval.override = function( override ) {
				return CKEDITOR.tools.extend( function( editor ) {
					return retval( editor, override );
				}, { type: 'button' }, true );
			};
			return retval;
		})(),

		/**
		 * The default cancel button for dialogs. Fires the `cancel` event and
		 * closes the dialog if no UI element value changed.
		 *
		 * @static
		 * @method
		 */
		cancelButton: (function() {
			var retval = function( editor, override ) {
					override = override || {};
					return CKEDITOR.tools.extend({
						id: 'cancel',
						type: 'button',
						label: editor.lang.common.cancel,
						'class': 'cke_dialog_ui_button_cancel',
						onClick: function( evt ) {
							var dialog = evt.data.dialog;
							if ( dialog.fire( 'cancel', { hide: true } ).hide !== false )
								dialog.hide();
						}
					}, override, true );
				};
			retval.type = 'button';
			retval.override = function( override ) {
				return CKEDITOR.tools.extend( function( editor ) {
					return retval( editor, override );
				}, { type: 'button' }, true );
			};
			return retval;
		})(),

		/**
		 * Registers a dialog UI element.
		 *
		 * @static
		 * @param {String} typeName The name of the UI element.
		 * @param {Function} builder The function to build the UI element.
		 */
		addUIElement: function( typeName, builder ) {
			this._.uiElementBuilders[ typeName ] = builder;
		}
	});

	CKEDITOR.dialog._ = {
		uiElementBuilders: {},

		dialogDefinitions: {},

		currentTop: null,

		currentZIndex: null
	};

	// "Inherit" (copy actually) from CKEDITOR.event.
	CKEDITOR.event.implementOn( CKEDITOR.dialog );
	CKEDITOR.event.implementOn( CKEDITOR.dialog.prototype );

	var defaultDialogDefinition = {
		resizable: CKEDITOR.DIALOG_RESIZE_BOTH,
		minWidth: 600,
		minHeight: 400,
		buttons: [ CKEDITOR.dialog.okButton, CKEDITOR.dialog.cancelButton ]
	};

	// Tool function used to return an item from an array based on its id
	// property.
	var getById = function( array, id, recurse ) {
			for ( var i = 0, item;
			( item = array[ i ] ); i++ ) {
				if ( item.id == id )
					return item;
				if ( recurse && item[ recurse ] ) {
					var retval = getById( item[ recurse ], id, recurse );
					if ( retval )
						return retval;
				}
			}
			return null;
		};

	// Tool function used to add an item into an array.
	var addById = function( array, newItem, nextSiblingId, recurse, nullIfNotFound ) {
			if ( nextSiblingId ) {
				for ( var i = 0, item;
				( item = array[ i ] ); i++ ) {
					if ( item.id == nextSiblingId ) {
						array.splice( i, 0, newItem );
						return newItem;
					}

					if ( recurse && item[ recurse ] ) {
						var retval = addById( item[ recurse ], newItem, nextSiblingId, recurse, true );
						if ( retval )
							return retval;
					}
				}

				if ( nullIfNotFound )
					return null;
			}

			array.push( newItem );
			return newItem;
		};

	// Tool function used to remove an item from an array based on its id.
	var removeById = function( array, id, recurse ) {
			for ( var i = 0, item;
			( item = array[ i ] ); i++ ) {
				if ( item.id == id )
					return array.splice( i, 1 );
				if ( recurse && item[ recurse ] ) {
					var retval = removeById( item[ recurse ], id, recurse );
					if ( retval )
						return retval;
				}
			}
			return null;
		};

	/**
	 * This class is not really part of the API. It is the `definition` property value
	 * passed to `dialogDefinition` event handlers.
	 *
	 *		CKEDITOR.on( 'dialogDefinition', function( evt ) {
	 *			var definition = evt.data.definition;
	 *			var content = definition.getContents( 'page1' );
	 * 			// ...
	 *		} );
	 *
	 * @private
	 * @class CKEDITOR.dialog.definitionObject
	 * @extends CKEDITOR.dialog.definition
	 * @constructor Creates a definitionObject class instance.
	 */
	var definitionObject = function( dialog, dialogDefinition ) {
			// TODO : Check if needed.
			this.dialog = dialog;

			// Transform the contents entries in contentObjects.
			var contents = dialogDefinition.contents;
			for ( var i = 0, content;
			( content = contents[ i ] ); i++ )
				contents[ i ] = content && new contentObject( dialog, content );

			CKEDITOR.tools.extend( this, dialogDefinition );
		};

	definitionObject.prototype = {
		/**
		 * Gets a content definition.
		 *
		 * @param {String} id The id of the content definition.
		 * @returns {CKEDITOR.dialog.definition.content} The content definition matching id.
		 */
		getContents: function( id ) {
			return getById( this.contents, id );
		},

		/**
		 * Gets a button definition.
		 *
		 * @param {String} id The id of the button definition.
		 * @returns {CKEDITOR.dialog.definition.button} The button definition matching id.
		 */
		getButton: function( id ) {
			return getById( this.buttons, id );
		},

		/**
		 * Adds a content definition object under this dialog definition.
		 *
		 * @param {CKEDITOR.dialog.definition.content} contentDefinition The
		 * content definition.
		 * @param {String} [nextSiblingId] The id of an existing content
		 * definition which the new content definition will be inserted
		 * before. Omit if the new content definition is to be inserted as
		 * the last item.
		 * @returns {CKEDITOR.dialog.definition.content} The inserted content definition.
		 */
		addContents: function( contentDefinition, nextSiblingId ) {
			return addById( this.contents, contentDefinition, nextSiblingId );
		},

		/**
		 * Adds a button definition object under this dialog definition.
		 *
		 * @param {CKEDITOR.dialog.definition.button} buttonDefinition The
		 * button definition.
		 * @param {String} [nextSiblingId] The id of an existing button
		 * definition which the new button definition will be inserted
		 * before. Omit if the new button definition is to be inserted as
		 * the last item.
		 * @returns {CKEDITOR.dialog.definition.button} The inserted button definition.
		 */
		addButton: function( buttonDefinition, nextSiblingId ) {
			return addById( this.buttons, buttonDefinition, nextSiblingId );
		},

		/**
		 * Removes a content definition from this dialog definition.
		 *
		 * @param {String} id The id of the content definition to be removed.
		 * @returns {CKEDITOR.dialog.definition.content} The removed content definition.
		 */
		removeContents: function( id ) {
			removeById( this.contents, id );
		},

		/**
		 * Removes a button definition from the dialog definition.
		 *
		 * @param {String} id The id of the button definition to be removed.
		 * @returns {CKEDITOR.dialog.definition.button} The removed button definition.
		 */
		removeButton: function( id ) {
			removeById( this.buttons, id );
		}
	};

	/**
	 * This class is not really part of the API. It is the template of the
	 * objects representing content pages inside the
	 * CKEDITOR.dialog.definitionObject.
	 *
	 *		CKEDITOR.on( 'dialogDefinition', function( evt ) {
	 *			var definition = evt.data.definition;
	 *			var content = definition.getContents( 'page1' );
	 *			content.remove( 'textInput1' );
	 *			// ...
	 *		} );
	 *
	 * @private
	 * @class CKEDITOR.dialog.definition.contentObject
	 * @constructor Creates a contentObject class instance.
	 */
	function contentObject( dialog, contentDefinition ) {
		this._ = {
			dialog: dialog
		};

		CKEDITOR.tools.extend( this, contentDefinition );
	}

	contentObject.prototype = {
		/**
		 * Gets a UI element definition under the content definition.
		 *
		 * @param {String} id The id of the UI element definition.
		 * @returns {CKEDITOR.dialog.definition.uiElement}
		 */
		get: function( id ) {
			return getById( this.elements, id, 'children' );
		},

		/**
		 * Adds a UI element definition to the content definition.
		 *
		 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition The
		 * UI elemnet definition to be added.
		 * @param {String} nextSiblingId The id of an existing UI element
		 * definition which the new UI element definition will be inserted
		 * before. Omit if the new button definition is to be inserted as
		 * the last item.
		 * @returns {CKEDITOR.dialog.definition.uiElement} The element definition inserted.
		 */
		add: function( elementDefinition, nextSiblingId ) {
			return addById( this.elements, elementDefinition, nextSiblingId, 'children' );
		},

		/**
		 * Removes a UI element definition from the content definition.
		 *
		 * @param {String} id The id of the UI element definition to be removed.
		 * @returns {CKEDITOR.dialog.definition.uiElement} The element definition removed.
		 */
		remove: function( id ) {
			removeById( this.elements, id, 'children' );
		}
	};

	function initDragAndDrop( dialog ) {
		var lastCoords = null,
			abstractDialogCoords = null,
			element = dialog.getElement().getFirst(),
			editor = dialog.getParentEditor(),
			magnetDistance = editor.config.dialog_magnetDistance,
			margins = CKEDITOR.skin.margins || [ 0, 0, 0, 0 ];

		if ( typeof magnetDistance == 'undefined' )
			magnetDistance = 20;

		function mouseMoveHandler( evt ) {
			var dialogSize = dialog.getSize(),
				viewPaneSize = CKEDITOR.document.getWindow().getViewPaneSize(),
				x = evt.data.$.screenX,
				y = evt.data.$.screenY,
				dx = x - lastCoords.x,
				dy = y - lastCoords.y,
				realX, realY;

			lastCoords = { x: x, y: y };
			abstractDialogCoords.x += dx;
			abstractDialogCoords.y += dy;

			if ( abstractDialogCoords.x + margins[ 3 ] < magnetDistance )
				realX = -margins[ 3 ];
			else if ( abstractDialogCoords.x - margins[ 1 ] > viewPaneSize.width - dialogSize.width - magnetDistance )
				realX = viewPaneSize.width - dialogSize.width + ( editor.lang.dir == 'rtl' ? 0 : margins[ 1 ] );
			else
				realX = abstractDialogCoords.x;

			if ( abstractDialogCoords.y + margins[ 0 ] < magnetDistance )
				realY = -margins[ 0 ];
			else if ( abstractDialogCoords.y - margins[ 2 ] > viewPaneSize.height - dialogSize.height - magnetDistance )
				realY = viewPaneSize.height - dialogSize.height + margins[ 2 ];
			else
				realY = abstractDialogCoords.y;

			dialog.move( realX, realY, 1 );

			evt.data.preventDefault();
		}

		function mouseUpHandler( evt ) {
			CKEDITOR.document.removeListener( 'mousemove', mouseMoveHandler );
			CKEDITOR.document.removeListener( 'mouseup', mouseUpHandler );

			if ( CKEDITOR.env.ie6Compat ) {
				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();
				coverDoc.removeListener( 'mousemove', mouseMoveHandler );
				coverDoc.removeListener( 'mouseup', mouseUpHandler );
			}
		}

		dialog.parts.title.on( 'mousedown', function( evt ) {
			lastCoords = { x: evt.data.$.screenX, y: evt.data.$.screenY };

			CKEDITOR.document.on( 'mousemove', mouseMoveHandler );
			CKEDITOR.document.on( 'mouseup', mouseUpHandler );
			abstractDialogCoords = dialog.getPosition();

			if ( CKEDITOR.env.ie6Compat ) {
				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();
				coverDoc.on( 'mousemove', mouseMoveHandler );
				coverDoc.on( 'mouseup', mouseUpHandler );
			}

			evt.data.preventDefault();
		}, dialog );
	}

	function initResizeHandles( dialog ) {
		var def = dialog.definition,
			resizable = def.resizable;

		if ( resizable == CKEDITOR.DIALOG_RESIZE_NONE )
			return;

		var editor = dialog.getParentEditor();
		var wrapperWidth, wrapperHeight, viewSize, origin, startSize, dialogCover;

		var mouseDownFn = CKEDITOR.tools.addFunction( function( $event ) {
			startSize = dialog.getSize();

			var content = dialog.parts.contents,
				iframeDialog = content.$.getElementsByTagName( 'iframe' ).length;

			// Shim to help capturing "mousemove" over iframe.
			if ( iframeDialog ) {
				dialogCover = CKEDITOR.dom.element.createFromHtml( '<div class="cke_dialog_resize_cover" style="height: 100%; position: absolute; width: 100%;"></div>' );
				content.append( dialogCover );
			}

			// Calculate the offset between content and chrome size.
			wrapperHeight = startSize.height - dialog.parts.contents.getSize( 'height', !( CKEDITOR.env.gecko || CKEDITOR.env.opera || CKEDITOR.env.ie && CKEDITOR.env.quirks ) );
			wrapperWidth = startSize.width - dialog.parts.contents.getSize( 'width', 1 );

			origin = { x: $event.screenX, y: $event.screenY };

			viewSize = CKEDITOR.document.getWindow().getViewPaneSize();

			CKEDITOR.document.on( 'mousemove', mouseMoveHandler );
			CKEDITOR.document.on( 'mouseup', mouseUpHandler );

			if ( CKEDITOR.env.ie6Compat ) {
				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();
				coverDoc.on( 'mousemove', mouseMoveHandler );
				coverDoc.on( 'mouseup', mouseUpHandler );
			}

			$event.preventDefault && $event.preventDefault();
		});

		// Prepend the grip to the dialog.
		dialog.on( 'load', function() {
			var direction = '';
			if ( resizable == CKEDITOR.DIALOG_RESIZE_WIDTH )
				direction = ' cke_resizer_horizontal';
			else if ( resizable == CKEDITOR.DIALOG_RESIZE_HEIGHT )
				direction = ' cke_resizer_vertical';
			var resizer = CKEDITOR.dom.element.createFromHtml(
				'<div' +
				' class="cke_resizer' + direction + ' cke_resizer_' + editor.lang.dir + '"' +
				' title="' + CKEDITOR.tools.htmlEncode( editor.lang.common.resize ) + '"' +
				' onmousedown="CKEDITOR.tools.callFunction(' + mouseDownFn + ', event )">' +
				// BLACK LOWER RIGHT TRIANGLE (ltr)
				// BLACK LOWER LEFT TRIANGLE (rtl)
				( editor.lang.dir == 'ltr' ? '\u25E2' : '\u25E3' ) +
				'</div>' );
			dialog.parts.footer.append( resizer, 1 );
		});
		editor.on( 'destroy', function() {
			CKEDITOR.tools.removeFunction( mouseDownFn );
		});

		function mouseMoveHandler( evt ) {
			var rtl = editor.lang.dir == 'rtl',
				dx = ( evt.data.$.screenX - origin.x ) * ( rtl ? -1 : 1 ),
				dy = evt.data.$.screenY - origin.y,
				width = startSize.width,
				height = startSize.height,
				internalWidth = width + dx * ( dialog._.moved ? 1 : 2 ),
				internalHeight = height + dy * ( dialog._.moved ? 1 : 2 ),
				element = dialog._.element.getFirst(),
				right = rtl && element.getComputedStyle( 'right' ),
				position = dialog.getPosition();

			if ( position.y + internalHeight > viewSize.height )
				internalHeight = viewSize.height - position.y;

			if ( ( rtl ? right : position.x ) + internalWidth > viewSize.width )
				internalWidth = viewSize.width - ( rtl ? right : position.x );

			// Make sure the dialog will not be resized to the wrong side when it's in the leftmost position for RTL.
			if ( ( resizable == CKEDITOR.DIALOG_RESIZE_WIDTH || resizable == CKEDITOR.DIALOG_RESIZE_BOTH ) )
				width = Math.max( def.minWidth || 0, internalWidth - wrapperWidth );

			if ( resizable == CKEDITOR.DIALOG_RESIZE_HEIGHT || resizable == CKEDITOR.DIALOG_RESIZE_BOTH )
				height = Math.max( def.minHeight || 0, internalHeight - wrapperHeight );

			dialog.resize( width, height );

			if ( !dialog._.moved )
				dialog.layout();

			evt.data.preventDefault();
		}

		function mouseUpHandler() {
			CKEDITOR.document.removeListener( 'mouseup', mouseUpHandler );
			CKEDITOR.document.removeListener( 'mousemove', mouseMoveHandler );

			if ( dialogCover ) {
				dialogCover.remove();
				dialogCover = null;
			}

			if ( CKEDITOR.env.ie6Compat ) {
				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();
				coverDoc.removeListener( 'mouseup', mouseUpHandler );
				coverDoc.removeListener( 'mousemove', mouseMoveHandler );
			}
		}
	}

	var resizeCover;
	// Caching resuable covers and allowing only one cover
	// on screen.
	var covers = {},
		currentCover;

	function cancelEvent( ev ) {
		ev.data.preventDefault( 1 );
	}

	function showCover( editor ) {
		var win = CKEDITOR.document.getWindow();
		var config = editor.config,
			backgroundColorStyle = config.dialog_backgroundCoverColor || 'white',
			backgroundCoverOpacity = config.dialog_backgroundCoverOpacity,
			baseFloatZIndex = config.baseFloatZIndex,
			coverKey = CKEDITOR.tools.genKey( backgroundColorStyle, backgroundCoverOpacity, baseFloatZIndex ),
			coverElement = covers[ coverKey ];

		if ( !coverElement ) {
			var html = [
				'<div tabIndex="-1" style="position: ', ( CKEDITOR.env.ie6Compat ? 'absolute' : 'fixed' ),
				'; z-index: ', baseFloatZIndex,
				'; top: 0px; left: 0px; ',
				( !CKEDITOR.env.ie6Compat ? 'background-color: ' + backgroundColorStyle : '' ),
				'" class="cke_dialog_background_cover">'
				];

			if ( CKEDITOR.env.ie6Compat ) {
				// Support for custom document.domain in IE.
				var isCustomDomain = CKEDITOR.env.isCustomDomain(),
					iframeHtml = '<html><body style=\\\'background-color:' + backgroundColorStyle + ';\\\'></body></html>';

				html.push( '<iframe' +
					' hidefocus="true"' +
					' frameborder="0"' +
					' id="cke_dialog_background_iframe"' +
					' src="javascript:' );

				html.push( 'void((function(){' +
					'document.open();' +
					( isCustomDomain ? 'document.domain=\'' + document.domain + '\';' : '' ) +
					'document.write( \'' + iframeHtml + '\' );' +
					'document.close();' +
					'})())' );

				html.push( '"' +
					' style="' +
						'position:absolute;' +
						'left:0;' +
						'top:0;' +
						'width:100%;' +
						'height: 100%;' +
	// DynDoc fix -- Filter style cause multiple instance of direct X dxtrans.dll spawn off when using MS IE8 or older
						/*'filter: progid:DXImageTransform.Microsoft.Alpha(opacity=0)">' +*/
					'</iframe>' );
			}

			html.push( '</div>' );

			coverElement = CKEDITOR.dom.element.createFromHtml( html.join( '' ) );
			coverElement.setOpacity( backgroundCoverOpacity != undefined ? backgroundCoverOpacity : 0.5 );

			coverElement.on( 'keydown', cancelEvent );
			coverElement.on( 'keypress', cancelEvent );
			coverElement.on( 'keyup', cancelEvent );

			coverElement.appendTo( CKEDITOR.document.getBody() );
			covers[ coverKey ] = coverElement;
		} else
			coverElement.show();

		// Makes the dialog cover a focus holder as well.
		editor.focusManager.add( coverElement );

		currentCover = coverElement;
		var resizeFunc = function() {
				var size = win.getViewPaneSize();
				coverElement.setStyles({
					width: size.width + 'px',
					height: size.height + 'px'
				});
			};

		var scrollFunc = function() {
				var pos = win.getScrollPosition(),
					cursor = CKEDITOR.dialog._.currentTop;
				coverElement.setStyles({
					left: pos.x + 'px',
					top: pos.y + 'px'
				});

				if ( cursor ) {
					do {
						var dialogPos = cursor.getPosition();
						cursor.move( dialogPos.x, dialogPos.y );
					} while ( ( cursor = cursor._.parentDialog ) );
				}
			};

		resizeCover = resizeFunc;
		win.on( 'resize', resizeFunc );
		resizeFunc();
		// Using Safari/Mac, focus must be kept where it is (#7027)
		if ( !( CKEDITOR.env.mac && CKEDITOR.env.webkit ) )
			coverElement.focus();

		if ( CKEDITOR.env.ie6Compat ) {
			// IE BUG: win.$.onscroll assignment doesn't work.. it must be window.onscroll.
			// So we need to invent a really funny way to make it work.
			var myScrollHandler = function() {
					scrollFunc();
					arguments.callee.prevScrollHandler.apply( this, arguments );
				};
			win.$.setTimeout( function() {
				myScrollHandler.prevScrollHandler = window.onscroll ||
				function() {};
				window.onscroll = myScrollHandler;
			}, 0 );
			scrollFunc();
		}
	}

	function hideCover( editor ) {
		if ( !currentCover )
			return;

		editor.focusManager.remove( currentCover );
		var win = CKEDITOR.document.getWindow();
		currentCover.hide();
		win.removeListener( 'resize', resizeCover );

		if ( CKEDITOR.env.ie6Compat ) {
			win.$.setTimeout( function() {
				var prevScrollHandler = window.onscroll && window.onscroll.prevScrollHandler;
				window.onscroll = prevScrollHandler || null;
			}, 0 );
		}
		resizeCover = null;
	}

	function removeCovers() {
		for ( var coverId in covers )
			covers[ coverId ].remove();
		covers = {};
	}

	var accessKeyProcessors = {};

	var accessKeyDownHandler = function( evt ) {
			var ctrl = evt.data.$.ctrlKey || evt.data.$.metaKey,
				alt = evt.data.$.altKey,
				shift = evt.data.$.shiftKey,
				key = String.fromCharCode( evt.data.$.keyCode ),
				keyProcessor = accessKeyProcessors[ ( ctrl ? 'CTRL+' : '' ) + ( alt ? 'ALT+' : '' ) + ( shift ? 'SHIFT+' : '' ) + key ];

			if ( !keyProcessor || !keyProcessor.length )
				return;

			keyProcessor = keyProcessor[ keyProcessor.length - 1 ];
			keyProcessor.keydown && keyProcessor.keydown.call( keyProcessor.uiElement, keyProcessor.dialog, keyProcessor.key );
			evt.data.preventDefault();
		};

	var accessKeyUpHandler = function( evt ) {
			var ctrl = evt.data.$.ctrlKey || evt.data.$.metaKey,
				alt = evt.data.$.altKey,
				shift = evt.data.$.shiftKey,
				key = String.fromCharCode( evt.data.$.keyCode ),
				keyProcessor = accessKeyProcessors[ ( ctrl ? 'CTRL+' : '' ) + ( alt ? 'ALT+' : '' ) + ( shift ? 'SHIFT+' : '' ) + key ];

			if ( !keyProcessor || !keyProcessor.length )
				return;

			keyProcessor = keyProcessor[ keyProcessor.length - 1 ];
			if ( keyProcessor.keyup ) {
				keyProcessor.keyup.call( keyProcessor.uiElement, keyProcessor.dialog, keyProcessor.key );
				evt.data.preventDefault();
			}
		};

	var registerAccessKey = function( uiElement, dialog, key, downFunc, upFunc ) {
			var procList = accessKeyProcessors[ key ] || ( accessKeyProcessors[ key ] = [] );
			procList.push({
				uiElement: uiElement,
				dialog: dialog,
				key: key,
				keyup: upFunc || uiElement.accessKeyUp,
				keydown: downFunc || uiElement.accessKeyDown
			});
		};

	var unregisterAccessKey = function( obj ) {
			for ( var i in accessKeyProcessors ) {
				var list = accessKeyProcessors[ i ];
				for ( var j = list.length - 1; j >= 0; j-- ) {
					if ( list[ j ].dialog == obj || list[ j ].uiElement == obj )
						list.splice( j, 1 );
				}
				if ( list.length === 0 )
					delete accessKeyProcessors[ i ];
			}
		};

	var tabAccessKeyUp = function( dialog, key ) {
			if ( dialog._.accessKeyMap[ key ] )
				dialog.selectPage( dialog._.accessKeyMap[ key ] );
		};

	var tabAccessKeyDown = function( dialog, key ) {};

	(function() {
		CKEDITOR.ui.dialog = {
			/**
			 * The base class of all dialog UI elements.
			 *
			 * @class CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a uiElement class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition Element
			 * definition.
			 *
			 * Accepted fields:
			 *
			 * * `id` (Required) The id of the UI element. See {@link CKEDITOR.dialog#getContentElement}.
			 * * `type` (Required) The type of the UI element. The
			 *     value to this field specifies which UI element class will be used to
			 *     generate the final widget.
			 * * `title` (Optional) The popup tooltip for the UI
			 *     element.
			 * * `hidden` (Optional) A flag that tells if the element
			 *     should be initially visible.
			 * * `className` (Optional) Additional CSS class names
			 *     to add to the UI element. Separated by space.
			 * * `style` (Optional) Additional CSS inline styles
			 *     to add to the UI element. A semicolon (;) is required after the last
			 *     style declaration.
			 * * `accessKey` (Optional) The alphanumeric access key
			 *     for this element. Access keys are automatically prefixed by CTRL.
			 * * `on*` (Optional) Any UI element definition field that
			 *     starts with `on` followed immediately by a capital letter and
			 *     probably more letters is an event handler. Event handlers may be further
			 *     divided into registered event handlers and DOM event handlers. Please
			 *     refer to {@link CKEDITOR.ui.dialog.uiElement#registerEvents} and
			 *     {@link CKEDITOR.ui.dialog.uiElement#eventProcessors} for more information.
			 *
			 * @param {Array} htmlList
			 * List of HTML code to be added to the dialog's content area.
			 * @param {Function/String} [nodeNameArg='div']
			 * A function returning a string, or a simple string for the node name for
			 * the root DOM node.
			 * @param {Function/Object} [stylesArg={}]
			 * A function returning an object, or a simple object for CSS styles applied
			 * to the DOM node.
			 * @param {Function/Object} [attributesArg={}]
			 * A fucntion returning an object, or a simple object for attributes applied
			 * to the DOM node.
			 * @param {Function/String} [contentsArg='']
			 * A function returning a string, or a simple string for the HTML code inside
			 * the root DOM node. Default is empty string.
			 */
			uiElement: function( dialog, elementDefinition, htmlList, nodeNameArg, stylesArg, attributesArg, contentsArg ) {
				if ( arguments.length < 4 )
					return;

				var nodeName = ( nodeNameArg.call ? nodeNameArg( elementDefinition ) : nodeNameArg ) || 'div',
					html = [ '<', nodeName, ' ' ],
					styles = ( stylesArg && stylesArg.call ? stylesArg( elementDefinition ) : stylesArg ) || {},
					attributes = ( attributesArg && attributesArg.call ? attributesArg( elementDefinition ) : attributesArg ) || {},
					innerHTML = ( contentsArg && contentsArg.call ? contentsArg.call( this, dialog, elementDefinition ) : contentsArg ) || '',
					domId = this.domId = attributes.id || CKEDITOR.tools.getNextId() + '_uiElement',
					id = this.id = elementDefinition.id,
					i;

				if ( elementDefinition.requiredContent && !dialog.getParentEditor().filter.check( elementDefinition.requiredContent ) ) {
					styles.display = 'none';
					this.notAllowed = true;
				}

				// Set the id, a unique id is required for getElement() to work.
				attributes.id = domId;

				// Set the type and definition CSS class names.
				var classes = {};
				if ( elementDefinition.type )
					classes[ 'cke_dialog_ui_' + elementDefinition.type ] = 1;
				if ( elementDefinition.className )
					classes[ elementDefinition.className ] = 1;
				if ( elementDefinition.disabled )
					classes[ 'cke_disabled' ] = 1;

				var attributeClasses = ( attributes[ 'class' ] && attributes[ 'class' ].split ) ? attributes[ 'class' ].split( ' ' ) : [];
				for ( i = 0; i < attributeClasses.length; i++ ) {
					if ( attributeClasses[ i ] )
						classes[ attributeClasses[ i ] ] = 1;
				}
				var finalClasses = [];
				for ( i in classes )
					finalClasses.push( i );
				attributes[ 'class' ] = finalClasses.join( ' ' );

				// Set the popup tooltop.
				if ( elementDefinition.title )
					attributes.title = elementDefinition.title;

				// Write the inline CSS styles.
				var styleStr = ( elementDefinition.style || '' ).split( ';' );

				// Element alignment support.
				if ( elementDefinition.align ) {
					var align = elementDefinition.align;
					styles[ 'margin-left' ] = align == 'left' ? 0 : 'auto';
					styles[ 'margin-right' ] = align == 'right' ? 0 : 'auto';
				}

				for ( i in styles )
					styleStr.push( i + ':' + styles[ i ] );
				if ( elementDefinition.hidden )
					styleStr.push( 'display:none' );
				for ( i = styleStr.length - 1; i >= 0; i-- ) {
					if ( styleStr[ i ] === '' )
						styleStr.splice( i, 1 );
				}
				if ( styleStr.length > 0 )
					attributes.style = ( attributes.style ? ( attributes.style + '; ' ) : '' ) + styleStr.join( '; ' );

				// Write the attributes.
				for ( i in attributes )
					html.push( i + '="' + CKEDITOR.tools.htmlEncode( attributes[ i ] ) + '" ' );

				// Write the content HTML.
				html.push( '>', innerHTML, '</', nodeName, '>' );

				// Add contents to the parent HTML array.
				htmlList.push( html.join( '' ) );

				( this._ || ( this._ = {} ) ).dialog = dialog;

				// Override isChanged if it is defined in element definition.
				if ( typeof( elementDefinition.isChanged ) == 'boolean' )
					this.isChanged = function() {
					return elementDefinition.isChanged;
				};
				if ( typeof( elementDefinition.isChanged ) == 'function' )
					this.isChanged = elementDefinition.isChanged;

				// Overload 'get(set)Value' on definition.
				if ( typeof( elementDefinition.setValue ) == 'function' ) {
					this.setValue = CKEDITOR.tools.override( this.setValue, function( org ) {
						return function( val ) {
							org.call( this, elementDefinition.setValue.call( this, val ) );
						};
					});
				}

				if ( typeof( elementDefinition.getValue ) == 'function' ) {
					this.getValue = CKEDITOR.tools.override( this.getValue, function( org ) {
						return function() {
							return elementDefinition.getValue.call( this, org.call( this ) );
						};
					});
				}

				// Add events.
				CKEDITOR.event.implementOn( this );

				this.registerEvents( elementDefinition );
				if ( this.accessKeyUp && this.accessKeyDown && elementDefinition.accessKey )
					registerAccessKey( this, dialog, 'CTRL+' + elementDefinition.accessKey );

				var me = this;
				dialog.on( 'load', function() {
					var input = me.getInputElement();
					if ( input ) {
						var focusClass = me.type in { 'checkbox':1,'ratio':1 } && CKEDITOR.env.ie && CKEDITOR.env.version < 8 ? 'cke_dialog_ui_focused' : '';
						input.on( 'focus', function() {
							dialog._.tabBarMode = false;
							dialog._.hasFocus = true;
							me.fire( 'focus' );
							focusClass && this.addClass( focusClass );

						});

						input.on( 'blur', function() {
							me.fire( 'blur' );
							focusClass && this.removeClass( focusClass );
						});
					}
				});

				// Register the object as a tab focus if it can be included.
				if ( this.keyboardFocusable ) {
					this.tabIndex = elementDefinition.tabIndex || 0;

					this.focusIndex = dialog._.focusList.push( this ) - 1;
					this.on( 'focus', function() {
						dialog._.currentFocusIndex = me.focusIndex;
					});
				}

				// Completes this object with everything we have in the
				// definition.
				CKEDITOR.tools.extend( this, elementDefinition );
			},

			/**
			 * Horizontal layout box for dialog UI elements, auto-expends to available width of container.
			 *
			 * @class CKEDITOR.ui.dialog.hbox
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a hbox class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {Array} childObjList
			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.
			 * @param {Array} childHtmlList
			 * Array of HTML code that correspond to the HTML output of all the
			 * objects in childObjList.
			 * @param {Array} htmlList
			 * Array of HTML code that this element will output to.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `widths` (Optional) The widths of child cells.
			 * * `height` (Optional) The height of the layout.
			 * * `padding` (Optional) The padding width inside child cells.
			 * * `align` (Optional) The alignment of the whole layout.
			 */
			hbox: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {
				if ( arguments.length < 4 )
					return;

				this._ || ( this._ = {} );

				var children = this._.children = childObjList,
					widths = elementDefinition && elementDefinition.widths || null,
					height = elementDefinition && elementDefinition.height || null,
					styles = {},
					i;
				/** @ignore */
				var innerHTML = function() {
						var html = [ '<tbody><tr class="cke_dialog_ui_hbox">' ];
						for ( i = 0; i < childHtmlList.length; i++ ) {
							var className = 'cke_dialog_ui_hbox_child',
								styles = [];
							if ( i === 0 )
								className = 'cke_dialog_ui_hbox_first';
							if ( i == childHtmlList.length - 1 )
								className = 'cke_dialog_ui_hbox_last';
							html.push( '<td class="', className, '" role="presentation" ' );
							if ( widths ) {
								if ( widths[ i ] )
									styles.push( 'width:' + cssLength( widths[ i ] ) );
							} else
								styles.push( 'width:' + Math.floor( 100 / childHtmlList.length ) + '%' );
							if ( height )
								styles.push( 'height:' + cssLength( height ) );
							if ( elementDefinition && elementDefinition.padding != undefined )
								styles.push( 'padding:' + cssLength( elementDefinition.padding ) );
							// In IE Quirks alignment has to be done on table cells. (#7324)
							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && children[ i ].align )
								styles.push( 'text-align:' + children[ i ].align );
							if ( styles.length > 0 )
								html.push( 'style="' + styles.join( '; ' ) + '" ' );
							html.push( '>', childHtmlList[ i ], '</td>' );
						}
						html.push( '</tr></tbody>' );
						return html.join( '' );
					};

				var attribs = { role: 'presentation' };
				elementDefinition && elementDefinition.align && ( attribs.align = elementDefinition.align );

				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition || { type: 'hbox' }, htmlList, 'table', styles, attribs, innerHTML );
			},

			/**
			 * Vertical layout box for dialog UI elements.
			 *
			 * @class CKEDITOR.ui.dialog.vbox
			 * @extends CKEDITOR.ui.dialog.hbox
			 * @constructor Creates a vbox class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog object.
			 * @param {Array} childObjList
			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.
			 * @param {Array} childHtmlList
			 * Array of HTML code that correspond to the HTML output of all the
			 * objects in childObjList.
			 * @param {Array} htmlList Array of HTML code that this element will output to.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `width` (Optional) The width of the layout.
			 * * `heights` (Optional) The heights of individual cells.
			 * * `align` (Optional) The alignment of the layout.
			 * * `padding` (Optional) The padding width inside child cells.
			 * * `expand` (Optional) Whether the layout should expand
			 *     vertically to fill its container.
			 */
			vbox: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {
				if ( arguments.length < 3 )
					return;

				this._ || ( this._ = {} );

				var children = this._.children = childObjList,
					width = elementDefinition && elementDefinition.width || null,
					heights = elementDefinition && elementDefinition.heights || null;
				/** @ignore */
				var innerHTML = function() {
						var html = [ '<table role="presentation" cellspacing="0" border="0" ' ];
						html.push( 'style="' );
						if ( elementDefinition && elementDefinition.expand )
							html.push( 'height:100%;' );
						html.push( 'width:' + cssLength( width || '100%' ), ';' );

						// (#10123) Temp fix for dialog broken layout in latest webkit.
						if ( CKEDITOR.env.webkit )
							html.push( 'float:none;' );

						html.push( '"' );
						html.push( 'align="', CKEDITOR.tools.htmlEncode(
						( elementDefinition && elementDefinition.align ) || ( dialog.getParentEditor().lang.dir == 'ltr' ? 'left' : 'right' ) ), '" ' );

						html.push( '><tbody>' );
						for ( var i = 0; i < childHtmlList.length; i++ ) {
							var styles = [];
							html.push( '<tr><td role="presentation" ' );
							if ( width )
								styles.push( 'width:' + cssLength( width || '100%' ) );
							if ( heights )
								styles.push( 'height:' + cssLength( heights[ i ] ) );
							else if ( elementDefinition && elementDefinition.expand )
								styles.push( 'height:' + Math.floor( 100 / childHtmlList.length ) + '%' );
							if ( elementDefinition && elementDefinition.padding != undefined )
								styles.push( 'padding:' + cssLength( elementDefinition.padding ) );
							// In IE Quirks alignment has to be done on table cells. (#7324)
							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && children[ i ].align )
								styles.push( 'text-align:' + children[ i ].align );
							if ( styles.length > 0 )
								html.push( 'style="', styles.join( '; ' ), '" ' );
							html.push( ' class="cke_dialog_ui_vbox_child">', childHtmlList[ i ], '</td></tr>' );
						}
						html.push( '</tbody></table>' );
						return html.join( '' );
					};
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition || { type: 'vbox' }, htmlList, 'div', null, { role: 'presentation' }, innerHTML );
			}
		};
	})();

	/** @class CKEDITOR.ui.dialog.uiElement */
	CKEDITOR.ui.dialog.uiElement.prototype = {
		/**
		 * Gets the root DOM element of this dialog UI object.
		 *
		 *		uiElement.getElement().hide();
		 *
		 * @returns {CKEDITOR.dom.element} Root DOM element of UI object.
		 */
		getElement: function() {
			return CKEDITOR.document.getById( this.domId );
		},

		/**
		 * Gets the DOM element that the user inputs values.
		 *
		 * This function is used by {@link #setValue}, {@link #getValue} and {@link #focus}. It should
		 * be overrided in child classes where the input element isn't the root
		 * element.
		 *
		 *		var rawValue = textInput.getInputElement().$.value;
		 *
		 * @returns {CKEDITOR.dom.element} The element where the user input values.
		 */
		getInputElement: function() {
			return this.getElement();
		},

		/**
		 * Gets the parent dialog object containing this UI element.
		 *
		 *		var dialog = uiElement.getDialog();
		 *
		 * @returns {CKEDITOR.dialog} Parent dialog object.
		 */
		getDialog: function() {
			return this._.dialog;
		},

		/**
		 * Sets the value of this dialog UI object.
		 *
		 *		uiElement.setValue( 'Dingo' );
		 *
		 * @chainable
		 * @param {Object} value The new value.
		 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.
		 */
		setValue: function( value, noChangeEvent ) {
			this.getInputElement().setValue( value );
			!noChangeEvent && this.fire( 'change', { value: value } );
			return this;
		},

		/**
		 * Gets the current value of this dialog UI object.
		 *
		 *		var myValue = uiElement.getValue();
		 *
		 * @returns {Object} The current value.
		 */
		getValue: function() {
			return this.getInputElement().getValue();
		},

		/**
		 * Tells whether the UI object's value has changed.
		 *
		 *		if ( uiElement.isChanged() )
		 *			confirm( 'Value changed! Continue?' );
		 *
		 * @returns {Boolean} `true` if changed, `false` if not changed.
		 */
		isChanged: function() {
			// Override in input classes.
			return false;
		},

		/**
		 * Selects the parent tab of this element. Usually called by focus() or overridden focus() methods.
		 *
		 *		focus : function() {
		 *			this.selectParentTab();
		 *			// do something else.
		 *		}
		 *
		 * @chainable
		 */
		selectParentTab: function() {
			var element = this.getInputElement(),
				cursor = element,
				tabId;
			while ( ( cursor = cursor.getParent() ) && cursor.$.className.search( 'cke_dialog_page_contents' ) == -1 ) {
				/*jsl:pass*/
			}

			// Some widgets don't have parent tabs (e.g. OK and Cancel buttons).
			if ( !cursor )
				return this;

			tabId = cursor.getAttribute( 'name' );
			// Avoid duplicate select.
			if ( this._.dialog._.currentTabId != tabId )
				this._.dialog.selectPage( tabId );
			return this;
		},

		/**
		 * Puts the focus to the UI object. Switches tabs if the UI object isn't in the active tab page.
		 *
		 *		uiElement.focus();
		 *
		 * @chainable
		 */
		focus: function() {
			this.selectParentTab().getInputElement().focus();
			return this;
		},

		/**
		 * Registers the `on*` event handlers defined in the element definition.
		 *
		 * The default behavior of this function is:
		 *
		 * 1. If the on* event is defined in the class's eventProcesors list,
		 *     then the registration is delegated to the corresponding function
		 *     in the eventProcessors list.
		 * 2. If the on* event is not defined in the eventProcessors list, then
		 *     register the event handler under the corresponding DOM event of
		 *     the UI element's input DOM element (as defined by the return value
		 *     of {@link #getInputElement}).
		 *
		 * This function is only called at UI element instantiation, but can
		 * be overridded in child classes if they require more flexibility.
		 *
		 * @chainable
		 * @param {CKEDITOR.dialog.definition.uiElement} definition The UI element
		 * definition.
		 */
		registerEvents: function( definition ) {
			var regex = /^on([A-Z]\w+)/,
				match;

			var registerDomEvent = function( uiElement, dialog, eventName, func ) {
					dialog.on( 'load', function() {
						uiElement.getInputElement().on( eventName, func, uiElement );
					});
				};

			for ( var i in definition ) {
				if ( !( match = i.match( regex ) ) )
					continue;
				if ( this.eventProcessors[ i ] )
					this.eventProcessors[ i ].call( this, this._.dialog, definition[ i ] );
				else
					registerDomEvent( this, this._.dialog, match[ 1 ].toLowerCase(), definition[ i ] );
			}

			return this;
		},

		/**
		 * The event processor list used by
		 * {@link CKEDITOR.ui.dialog.uiElement#getInputElement} at UI element
		 * instantiation. The default list defines three `on*` events:
		 *
		 * 1. `onLoad` - Called when the element's parent dialog opens for the
		 *     first time.
		 * 2. `onShow` - Called whenever the element's parent dialog opens.
		 * 3. `onHide` - Called whenever the element's parent dialog closes.
		 *
		 *		// This connects the 'click' event in CKEDITOR.ui.dialog.button to onClick
		 *		// handlers in the UI element's definitions.
		 *		CKEDITOR.ui.dialog.button.eventProcessors = CKEDITOR.tools.extend( {},
		 *			CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors,
		 *			{ onClick : function( dialog, func ) { this.on( 'click', func ); } },
		 *			true
		 *		);
		 *
		 * @property {Object}
		 */
		eventProcessors: {
			onLoad: function( dialog, func ) {
				dialog.on( 'load', func, this );
			},

			onShow: function( dialog, func ) {
				dialog.on( 'show', func, this );
			},

			onHide: function( dialog, func ) {
				dialog.on( 'hide', func, this );
			}
		},

		/**
		 * The default handler for a UI element's access key down event, which
		 * tries to put focus to the UI element.
		 *
		 * Can be overridded in child classes for more sophisticaed behavior.
		 *
		 * @param {CKEDITOR.dialog} dialog The parent dialog object.
		 * @param {String} key The key combination pressed. Since access keys
		 * are defined to always include the `CTRL` key, its value should always
		 * include a `'CTRL+'` prefix.
		 */
		accessKeyDown: function( dialog, key ) {
			this.focus();
		},

		/**
		 * The default handler for a UI element's access key up event, which
		 * does nothing.
		 *
		 * Can be overridded in child classes for more sophisticated behavior.
		 *
		 * @param {CKEDITOR.dialog} dialog The parent dialog object.
		 * @param {String} key The key combination pressed. Since access keys
		 * are defined to always include the `CTRL` key, its value should always
		 * include a `'CTRL+'` prefix.
		 */
		accessKeyUp: function( dialog, key ) {},

		/**
		 * Disables a UI element.
		 */
		disable: function() {
			var element = this.getElement(),
				input = this.getInputElement();
			input.setAttribute( 'disabled', 'true' );
			element.addClass( 'cke_disabled' );
		},

		/**
		 * Enables a UI element.
		 */
		enable: function() {
			var element = this.getElement(),
				input = this.getInputElement();
			input.removeAttribute( 'disabled' );
			element.removeClass( 'cke_disabled' );
		},

		/**
		 * Determines whether an UI element is enabled or not.
		 *
		 * @returns {Boolean} Whether the UI element is enabled.
		 */
		isEnabled: function() {
			return !this.getElement().hasClass( 'cke_disabled' );
		},

		/**
		 * Determines whether an UI element is visible or not.
		 *
		 * @returns {Boolean} Whether the UI element is visible.
		 */
		isVisible: function() {
			return this.getInputElement().isVisible();
		},

		/**
		 * Determines whether an UI element is focus-able or not.
		 * Focus-able is defined as being both visible and enabled.
		 *
		 * @returns {Boolean} Whether the UI element can be focused.
		 */
		isFocusable: function() {
			if ( !this.isEnabled() || !this.isVisible() )
				return false;
			return true;
		}
	};

	/** @class CKEDITOR.ui.dialog.hbox */
	CKEDITOR.ui.dialog.hbox.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {
		/**
		 * Gets a child UI element inside this container.
		 *
		 *		var checkbox = hbox.getChild( [0,1] );
		 *		checkbox.setValue( true );
		 *
		 * @param {Array/Number} indices An array or a single number to indicate the child's
		 * position in the container's descendant tree. Omit to get all the children in an array.
		 * @returns {Array/CKEDITOR.ui.dialog.uiElement} Array of all UI elements in the container
		 * if no argument given, or the specified UI element if indices is given.
		 */
		getChild: function( indices ) {
			// If no arguments, return a clone of the children array.
			if ( arguments.length < 1 )
				return this._.children.concat();

			// If indices isn't array, make it one.
			if ( !indices.splice )
				indices = [ indices ];

			// Retrieve the child element according to tree position.
			if ( indices.length < 2 )
				return this._.children[ indices[ 0 ] ];
			else
				return ( this._.children[ indices[ 0 ] ] && this._.children[ indices[ 0 ] ].getChild ) ? this._.children[ indices[ 0 ] ].getChild( indices.slice( 1, indices.length ) ) : null;
		}
	}, true );

	CKEDITOR.ui.dialog.vbox.prototype = new CKEDITOR.ui.dialog.hbox();

	(function() {
		var commonBuilder = {
			build: function( dialog, elementDefinition, output ) {
				var children = elementDefinition.children,
					child,
					childHtmlList = [],
					childObjList = [];
				for ( var i = 0;
				( i < children.length && ( child = children[ i ] ) ); i++ ) {
					var childHtml = [];
					childHtmlList.push( childHtml );
					childObjList.push( CKEDITOR.dialog._.uiElementBuilders[ child.type ].build( dialog, child, childHtml ) );
				}
				return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, childObjList, childHtmlList, output, elementDefinition );
			}
		};

		CKEDITOR.dialog.addUIElement( 'hbox', commonBuilder );
		CKEDITOR.dialog.addUIElement( 'vbox', commonBuilder );
	})();

	/**
	 * Generic dialog command. It opens a specific dialog when executed.
	 *
	 *		// Register the "link" command, which opens the "link" dialog.
	 *		editor.addCommand( 'link', new CKEDITOR.dialogCommand( 'link' ) );
	 *
	 * @class
	 * @constructor Creates a dialogCommand class instance.
	 * @extends CKEDITOR.commandDefinition
	 * @param {String} dialogName The name of the dialog to open when executing
	 * this command.
	 * @param {Object} [ext] Additional command definition's properties.
	 */
	CKEDITOR.dialogCommand = function( dialogName, ext ) {
		this.dialogName = dialogName;
		CKEDITOR.tools.extend( this, ext, true );
	};

	CKEDITOR.dialogCommand.prototype = {
		exec: function( editor ) {
			// Special treatment for Opera. (#8031)
			CKEDITOR.env.opera ? CKEDITOR.tools.setTimeout( function() {
				editor.openDialog( this.dialogName );
			}, 0, this ) : editor.openDialog( this.dialogName );
		},

		// Dialog commands just open a dialog ui, thus require no undo logic,
		// undo support should dedicate to specific dialog implementation.
		canUndo: false,

		editorFocus: 1
	};

	(function() {
		var notEmptyRegex = /^([a]|[^a])+$/,
			integerRegex = /^\d*$/,
			numberRegex = /^\d*(?:\.\d+)?$/,
			htmlLengthRegex = /^(((\d*(\.\d+))|(\d*))(px|\%)?)?$/,
			cssLengthRegex = /^(((\d*(\.\d+))|(\d*))(px|em|ex|in|cm|mm|pt|pc|\%)?)?$/i,
			inlineStyleRegex = /^(\s*[\w-]+\s*:\s*[^:;]+(?:;|$))*$/;

		CKEDITOR.VALIDATE_OR = 1;
		CKEDITOR.VALIDATE_AND = 2;

		CKEDITOR.dialog.validate = {
			functions: function() {
				var args = arguments;
				return function() {
					/**
					 * It's important for validate functions to be able to accept the value
					 * as argument in addition to this.getValue(), so that it is possible to
					 * combine validate functions together to make more sophisticated
					 * validators.
					 */
					var value = this && this.getValue ? this.getValue() : args[ 0 ];

					var msg = undefined,
						relation = CKEDITOR.VALIDATE_AND,
						functions = [],
						i;

					for ( i = 0; i < args.length; i++ ) {
						if ( typeof( args[ i ] ) == 'function' )
							functions.push( args[ i ] );
						else
							break;
					}

					if ( i < args.length && typeof( args[ i ] ) == 'string' ) {
						msg = args[ i ];
						i++;
					}

					if ( i < args.length && typeof( args[ i ] ) == 'number' )
						relation = args[ i ];

					var passed = ( relation == CKEDITOR.VALIDATE_AND ? true : false );
					for ( i = 0; i < functions.length; i++ ) {
						if ( relation == CKEDITOR.VALIDATE_AND )
							passed = passed && functions[ i ]( value );
						else
							passed = passed || functions[ i ]( value );
					}

					return !passed ? msg : true;
				};
			},

			regex: function( regex, msg ) {
				/*
				 * Can be greatly shortened by deriving from functions validator if code size
				 * turns out to be more important than performance.
				 */
				return function() {
					var value = this && this.getValue ? this.getValue() : arguments[ 0 ];
					return !regex.test( value ) ? msg : true;
				};
			},

			notEmpty: function( msg ) {
				return this.regex( notEmptyRegex, msg );
			},

			integer: function( msg ) {
				return this.regex( integerRegex, msg );
			},

			'number': function( msg ) {
				return this.regex( numberRegex, msg );
			},

			'cssLength': function( msg ) {
				return this.functions( function( val ) {
					return cssLengthRegex.test( CKEDITOR.tools.trim( val ) );
				}, msg );
			},

			'htmlLength': function( msg ) {
				return this.functions( function( val ) {
					return htmlLengthRegex.test( CKEDITOR.tools.trim( val ) );
				}, msg );
			},

			'inlineStyle': function( msg ) {
				return this.functions( function( val ) {
					return inlineStyleRegex.test( CKEDITOR.tools.trim( val ) );
				}, msg );
			},

			equals: function( value, msg ) {
				return this.functions( function( val ) {
					return val == value;
				}, msg );
			},

			notEqual: function( value, msg ) {
				return this.functions( function( val ) {
					return val != value;
				}, msg );
			}
		};

		CKEDITOR.on( 'instanceDestroyed', function( evt ) {
			// Remove dialog cover on last instance destroy.
			if ( CKEDITOR.tools.isEmpty( CKEDITOR.instances ) ) {
				var currentTopDialog;
				while ( ( currentTopDialog = CKEDITOR.dialog._.currentTop ) )
					currentTopDialog.hide();
				removeCovers();
			}

			var dialogs = evt.editor._.storedDialogs;
			for ( var name in dialogs )
				dialogs[ name ].destroy();

		});

	})();

	// Extend the CKEDITOR.editor class with dialog specific functions.
	CKEDITOR.tools.extend( CKEDITOR.editor.prototype, {
		/**
		 * Loads and opens a registered dialog.
		 *
		 *		CKEDITOR.instances.editor1.openDialog( 'smiley' );
		 *
		 * @member CKEDITOR.editor
		 * @param {String} dialogName The registered name of the dialog.
		 * @param {Function} callback The function to be invoked after dialog instance created.
		 * @returns {CKEDITOR.dialog} The dialog object corresponding to the dialog displayed.
		 * `null` if the dialog name is not registered.
		 * @see CKEDITOR.dialog#add
		 */
		openDialog: function( dialogName, callback ) {
			var dialog = null, dialogDefinitions = CKEDITOR.dialog._.dialogDefinitions[ dialogName ];

			if ( CKEDITOR.dialog._.currentTop === null )
				showCover( this );

			// If the dialogDefinition is already loaded, open it immediately.
			if ( typeof dialogDefinitions == 'function' ) {
				var storedDialogs = this._.storedDialogs || ( this._.storedDialogs = {} );

				dialog = storedDialogs[ dialogName ] || ( storedDialogs[ dialogName ] = new CKEDITOR.dialog( this, dialogName ) );

				callback && callback.call( dialog, dialog );
				dialog.show();

			} else if ( dialogDefinitions == 'failed' ) {
				hideCover( this );
				throw new Error( '[CKEDITOR.dialog.openDialog] Dialog "' + dialogName + '" failed when loading definition.' );
			} else if ( typeof dialogDefinitions == 'string' ) {

				CKEDITOR.scriptLoader.load( CKEDITOR.getUrl( dialogDefinitions ),
					function() {
						var dialogDefinition = CKEDITOR.dialog._.dialogDefinitions[ dialogName ];
						// In case of plugin error, mark it as loading failed.
						if ( typeof dialogDefinition != 'function' )
							CKEDITOR.dialog._.dialogDefinitions[ dialogName ] = 'failed';

						this.openDialog( dialogName, callback );
					}, this, 0, 1 );
			}

			CKEDITOR.skin.loadPart( 'dialog' );

			return dialog;
		}
	});
})();

CKEDITOR.plugins.add( 'dialog', {
	requires: 'dialogui',
	init: function( editor ) {
		editor.on( 'contentDom', function() {
			var editable = editor.editable();
			// Open dialog on double-clicks.
			editable.attachListener( editable, 'dblclick', function( evt ) {
				if ( editor.readOnly )
					return false;

				var data = { element: evt.data.getTarget() };
				editor.fire( 'doubleclick', data );
				data.dialog && editor.openDialog( data.dialog );

				return 1;
			});
		});
	}
});

// Dialog related configurations.

/**
 * The color of the dialog background cover. It should be a valid CSS color string.
 *
 *		config.dialog_backgroundCoverColor = 'rgb(255, 254, 253)';
 *
 * @cfg {String} [dialog_backgroundCoverColor='white']
 * @member CKEDITOR.config
 */

/**
 * The opacity of the dialog background cover. It should be a number within the
 * range `[0.0, 1.0]`.
 *
 *		config.dialog_backgroundCoverOpacity = 0.7;
 *
 * @cfg {Number} [dialog_backgroundCoverOpacity=0.5]
 * @member CKEDITOR.config
 */

/**
 * If the dialog has more than one tab, put focus into the first tab as soon as dialog is opened.
 *
 *		config.dialog_startupFocusTab = true;
 *
 * @cfg {Boolean} [dialog_startupFocusTab=false]
 * @member CKEDITOR.config
 */

/**
 * The distance of magnetic borders used in moving and resizing dialogs,
 * measured in pixels.
 *
 *		config.dialog_magnetDistance = 30;
 *
 * @cfg {Number} [dialog_magnetDistance=20]
 * @member CKEDITOR.config
 */

/**
 * The guideline to follow when generating the dialog buttons. There are 3 possible options:
 *
 * * `'OS'` - the buttons will be displayed in the default order of the user's OS;
 * * `'ltr'` - for Left-To-Right order;
 * * `'rtl'` - for Right-To-Left order.
 *
 * Example:
 *
 *		config.dialog_buttonsOrder = 'rtl';
 *
 * @since 3.5
 * @cfg {String} [dialog_buttonsOrder='OS']
 * @member CKEDITOR.config
 */

/**
 * The dialog contents to removed. It's a string composed by dialog name and tab name with a colon between them.
 *
 * Separate each pair with semicolon (see example).
 *
 * **Note:** All names are case-sensitive.
 *
 * **Note:** Be cautious when specifying dialog tabs that are mandatory,
 * like `'info'`, dialog functionality might be broken because of this!
 *
 *		config.removeDialogTabs = 'flash:advanced;image:Link';
 *
 * @since 3.5
 * @cfg {String} [removeDialogTabs='']
 * @member CKEDITOR.config
 */

/**
 * Fired when a dialog definition is about to be used to create a dialog into
 * an editor instance. This event makes it possible to customize the definition
 * before creating it.
 *
 * Note that this event is called only the first time a specific dialog is
 * opened. Successive openings will use the cached dialog, and this event will
 * not get fired.
 *
 * @event dialogDefinition
 * @member CKEDITOR
 * @param {CKEDITOR.dialog.definition} data The dialog defination that
 * is being loaded.
 * @param {CKEDITOR.editor} editor The editor instance that will use the dialog.
 */

/**
 * Fired when a tab is going to be selected in a dialog.
 *
 * @event selectPage
 * @member CKEDITOR.dialog
 * @param data
 * @param {String} data.page The id of the page that it's gonna be selected.
 * @param {String} data.currentPage The id of the current page.
 */

/**
 * Fired when the user tries to dismiss a dialog.
 *
 * @event cancel
 * @member CKEDITOR.dialog
 * @param data
 * @param {Boolean} data.hide Whether the event should proceed or not.
 */

/**
 * Fired when the user tries to confirm a dialog.
 *
 * @event ok
 * @member CKEDITOR.dialog
 * @param data
 * @param {Boolean} data.hide Whether the event should proceed or not.
 */

/**
 * Fired when a dialog is shown.
 *
 * @event show
 * @member CKEDITOR.dialog
 */

/**
 * Fired when a dialog is shown.
 *
 * @event dialogShow
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 */

/**
 * Fired when a dialog is hidden.
 *
 * @event hide
 * @member CKEDITOR.dialog
 */

/**
 * Fired when a dialog is hidden.
 *
 * @event dialogHide
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 */

/**
 * Fired when a dialog is being resized. The event is fired on
 * both the {@link CKEDITOR.dialog} object and the dialog instance
 * since 3.5.3, previously it's available only in the global object.
 *
 * @static
 * @event resize
 * @member CKEDITOR.dialog
 * @param data
 * @param {CKEDITOR.dialog} data.dialog The dialog being resized (if
 * it's fired on the dialog itself, this parameter isn't sent).
 * @param {String} data.skin The skin name.
 * @param {Number} data.width The new width.
 * @param {Number} data.height The new height.
 */

/**
 * Fired when a dialog is being resized. The event is fired on
 * both the {@link CKEDITOR.dialog} object and the dialog instance
 * since 3.5.3, previously it's available only in the global object.
 *
 * @since 3.5
 * @event resize
 * @member CKEDITOR.dialog
 * @param data
 * @param {Number} data.width The new width.
 * @param {Number} data.height The new height.
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

(function() {
	var template = '<a id="{id}"' +
		' class="cke_button cke_button__{name} cke_button_{state} {cls}"' +
		( CKEDITOR.env.gecko && CKEDITOR.env.version >= 10900 && !CKEDITOR.env.hc ? '' : '" href="javascript:void(\'{titleJs}\')"' ) +
		' title="{title}"' +
		' tabindex="-1"' +
		' hidefocus="true"' +
		' role="button"' +
		' aria-labelledby="{id}_label"' +
		' aria-haspopup="{hasArrow}"';

	// Some browsers don't cancel key events in the keydown but in the
	// keypress.
	// TODO: Check if really needed for Gecko+Mac.
	if ( CKEDITOR.env.opera || ( CKEDITOR.env.gecko && CKEDITOR.env.mac ) )
		template += ' onkeypress="return false;"';

	// With Firefox, we need to force the button to redraw, otherwise it
	// will remain in the focus state.
	if ( CKEDITOR.env.gecko )
		template += ' onblur="this.style.cssText = this.style.cssText;"';

	template += ' onkeydown="return CKEDITOR.tools.callFunction({keydownFn},event);"' +
		' onfocus="return CKEDITOR.tools.callFunction({focusFn},event);" ' +
		' onmousedown="return CKEDITOR.tools.callFunction({mousedownFn},event);" ' +
		( CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick' ) + // #188
			'="CKEDITOR.tools.callFunction({clickFn},this);return false;">' +
		'<span class="cke_button_icon cke_button__{iconName}_icon" style="{style}"';


	template += '>&nbsp;</span>' +
		'<span id="{id}_label" class="cke_button_label cke_button__{name}_label">{label}</span>' +
		'{arrowHtml}' +
		'</a>';

	var templateArrow = '<span class="cke_button_arrow">' +
		// BLACK DOWN-POINTING TRIANGLE
	( CKEDITOR.env.hc ? '&#9660;' : '' ) +
		'</span>';

	var btnArrowTpl = CKEDITOR.addTemplate( 'buttonArrow', templateArrow ),
		btnTpl = CKEDITOR.addTemplate( 'button', template );

	CKEDITOR.plugins.add( 'button', {
		beforeInit: function( editor ) {
			editor.ui.addHandler( CKEDITOR.UI_BUTTON, CKEDITOR.ui.button.handler );
		}
	});

	/**
	 * Button UI element.
	 *
	 * @readonly
	 * @property {String} [='button']
	 * @member CKEDITOR
	 */
	CKEDITOR.UI_BUTTON = 'button';

	/**
	 * Represents a button UI element. This class should not be called directly. To
	 * create new buttons use {@link CKEDITOR.ui#addButton} instead.
	 *
	 * @class
	 * @constructor Creates a button class instance.
	 * @param {Object} definition The button definition.
	 */
	CKEDITOR.ui.button = function( definition ) {
		CKEDITOR.tools.extend( this, definition,
		// Set defaults.
		{
			title: definition.label,
			click: definition.click ||
			function( editor ) {
				editor.execCommand( definition.command );
			}
		});

		this._ = {};
	};

	/**
	 * Represents button handler object.
	 *
	 * @class
	 * @singleton
	 * @extends CKEDITOR.ui.handlerDefinition
	 */
	CKEDITOR.ui.button.handler = {
		/**
		 * Transforms a button definition in a {@link CKEDITOR.ui.button} instance.
		 *
		 * @member CKEDITOR.ui.button.handler
		 * @param {Object} definition
		 * @returns {CKEDITOR.ui.button}
		 */
		create: function( definition ) {
			return new CKEDITOR.ui.button( definition );
		}
	};

	/** @class CKEDITOR.ui.button */
	CKEDITOR.ui.button.prototype = {
		/**
		 * Renders the button.
		 *
		 * @param {CKEDITOR.editor} editor The editor instance which this button is
		 * to be used by.
		 * @param {Array} output The output array to which append the HTML relative
		 * to this button.
		 */
		render: function( editor, output ) {
			var env = CKEDITOR.env,
				id = this._.id = CKEDITOR.tools.getNextId(),
				stateName = '',
				command = this.command,
				// Get the command name.
				clickFn;

			this._.editor = editor;

			var instance = {
				id: id,
				button: this,
				editor: editor,
				focus: function() {
					var element = CKEDITOR.document.getById( id );
					element.focus();
				},
				execute: function() {
					this.button.click( editor );
				},
				attach: function( editor ) {
					this.button.attach( editor );
				}
			};

			var keydownFn = CKEDITOR.tools.addFunction( function( ev ) {
				if ( instance.onkey ) {
					ev = new CKEDITOR.dom.event( ev );
					return ( instance.onkey( instance, ev.getKeystroke() ) !== false );
				}
			});

			var focusFn = CKEDITOR.tools.addFunction( function( ev ) {
				var retVal;

				if ( instance.onfocus )
					retVal = ( instance.onfocus( instance, new CKEDITOR.dom.event( ev ) ) !== false );

				// FF2: prevent focus event been bubbled up to editor container, which caused unexpected editor focus.
				if ( CKEDITOR.env.gecko && CKEDITOR.env.version < 10900 )
					ev.preventBubble();
				return retVal;
			});

			var selLocked = 0;

			var mousedownFn = CKEDITOR.tools.addFunction( function() {
				// Opera: lock to prevent loosing editable text selection when clicking on button.
				if ( CKEDITOR.env.opera ) {
					var edt = editor.editable();
					if ( edt.isInline() && edt.hasFocus ) {
						editor.lockSelection();
						selLocked = 1;
					}
				}
			});

			instance.clickFn = clickFn = CKEDITOR.tools.addFunction( function() {

				// Restore locked selection in Opera.
				if ( selLocked ) {
					editor.unlockSelection( 1 );
					selLocked = 0;
				}

				instance.execute();
			});


			// Indicate a mode sensitive button.
			if ( this.modes ) {
				var modeStates = {};

				function updateState() {
					// "this" is a CKEDITOR.ui.button instance.

					var mode = editor.mode;

					if ( mode ) {
						// Restore saved button state.
						var state = this.modes[ mode ] ? modeStates[ mode ] != undefined ? modeStates[ mode ] : CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;

						this.setState( editor.readOnly && !this.readOnly ? CKEDITOR.TRISTATE_DISABLED : state );
					}
				}

				editor.on( 'beforeModeUnload', function() {
					if ( editor.mode && this._.state != CKEDITOR.TRISTATE_DISABLED )
						modeStates[ editor.mode ] = this._.state;
				}, this );

				editor.on( 'mode', updateState, this );

				// If this button is sensitive to readOnly state, update it accordingly.
				!this.readOnly && editor.on( 'readOnly', updateState, this );
			} else if ( command ) {
				// Get the command instance.
				command = editor.getCommand( command );

				if ( command ) {
					command.on( 'state', function() {
						this.setState( command.state );
					}, this );

					stateName += ( command.state == CKEDITOR.TRISTATE_ON ? 'on' : command.state == CKEDITOR.TRISTATE_DISABLED ? 'disabled' : 'off' );
				}
			}

			// For button that has text-direction awareness on selection path.
			if ( this.directional ) {
				editor.on( 'contentDirChanged', function( evt ) {
					var el = CKEDITOR.document.getById( this._.id ),
						icon = el.getFirst();

					var pathDir = evt.data;

					// Make a minor direction change to become style-able for the skin icon.
					if ( pathDir !=  editor.lang.dir )
						el.addClass( 'cke_' + pathDir );
					else
						el.removeClass( 'cke_ltr' ).removeClass( 'cke_rtl' );

					// Inline style update for the plugin icon.
					icon.setAttribute( 'style', CKEDITOR.skin.getIconStyle( iconName, pathDir == 'rtl', this.icon, this.iconOffset ) );
				}, this );
			}

			if ( !command )
				stateName += 'off';

			var name = this.name || this.command,
				iconName = name;

			// Check if we're pointing to an icon defined by another command. (#9555)
			if ( this.icon && !( /\./ ).test( this.icon ) ) {
				iconName = this.icon;
				this.icon = null;
			}

			var params = {
				id: id,
				name: name,
				iconName: iconName,
				label: this.label,
				cls: this.className || '',
				state: stateName,
				title: this.title,
				titleJs: env.gecko && env.version >= 10900 && !env.hc ? '' : ( this.title || '' ).replace( "'", '' ),
				hasArrow: this.hasArrow ? 'true' : 'false',
				keydownFn: keydownFn,
				mousedownFn: mousedownFn,
				focusFn: focusFn,
				clickFn: clickFn,
				style: CKEDITOR.skin.getIconStyle( iconName, ( editor.lang.dir == 'rtl' ), this.icon, this.iconOffset ),
				arrowHtml: this.hasArrow ? btnArrowTpl.output() : ''
			};

			btnTpl.output( params, output );

			if ( this.onRender )
				this.onRender();

			return instance;
		},

		/**
		 * @todo
		 */
		setState: function( state ) {
			if ( this._.state == state )
				return false;

			this._.state = state;

			var element = CKEDITOR.document.getById( this._.id );

			if ( element ) {
				element.setState( state, 'cke_button' );

				state == CKEDITOR.TRISTATE_DISABLED ?
					element.setAttribute( 'aria-disabled', true ) :
					element.removeAttribute( 'aria-disabled' );

				state == CKEDITOR.TRISTATE_ON ?
					element.setAttribute( 'aria-pressed', true ) :
					element.removeAttribute( 'aria-pressed' );

				return true;
			} else
				return false;
		},

		/**
		 * Returns this button's {@link CKEDITOR.feature} instance.
		 *
		 * It may be this button instance if it has at least one of
		 * `allowedContent` and `requiredContent` properties. Otherwise,
		 * if command is bound to this button by `command` property, then
		 * that command will be returned.
		 *
		 * This method implements {@link CKEDITOR.feature#toFeature} interface method.
		 *
		 * @since 4.1
		 * @param {CKEDITOR.editor} Editor instance.
		 * @returns {CKEDITOR.feature} The feature.
		 */
		toFeature: function( editor ) {
			if ( this._.feature )
				return this._.feature;

			var feature = this;

			// If button isn't a feature, return command if is bound.
			if ( !this.allowedContent && !this.requiredContent && this.command )
				feature = editor.getCommand( this.command ) || feature;

			return this._.feature = feature;
		}
	};

	/**
	 * Adds a button definition to the UI elements list.
	 *
	 *		editorInstance.ui.addButton( 'MyBold', {
	 *			label: 'My Bold',
	 *			command: 'bold',
	 *			toolbar: 'basicstyles,1'
	 *		} );
	 *
	 * @member CKEDITOR.ui
	 * @param {String} name The button name.
	 * @param {Object} definition The button definition.
	 */
	CKEDITOR.ui.prototype.addButton = function( name, definition ) {
		this.add( name, CKEDITOR.UI_BUTTON, definition );
	};

})();

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'panelbutton', {
	requires: 'button',
	onLoad: function() {
		function clickFn( editor ) {
			var _ = this._;

			if ( _.state == CKEDITOR.TRISTATE_DISABLED )
				return;

			this.createPanel( editor );

			if ( _.on ) {
				_.panel.hide();
				return;
			}

			_.panel.showBlock( this._.id, this.document.getById( this._.id ), 4 );
		}

		/**
		 * @class
		 * @extends CKEDITOR.ui.button
		 * @todo class and methods
		 */
		CKEDITOR.ui.panelButton = CKEDITOR.tools.createClass({
			base: CKEDITOR.ui.button,

			/**
			 * Creates a panelButton class instance.
			 *
			 * @constructor
			 */
			$: function( definition ) {
				// We don't want the panel definition in this object.
				var panelDefinition = definition.panel || {};
				delete definition.panel;

				this.base( definition );

				this.document = ( panelDefinition.parent && panelDefinition.parent.getDocument() ) || CKEDITOR.document;

				panelDefinition.block = {
					attributes: panelDefinition.attributes
				};
				panelDefinition.toolbarRelated = true;

				this.hasArrow = true;

				this.click = clickFn;

				this._ = {
					panelDefinition: panelDefinition
				};
			},

			statics: {
				handler: {
					create: function( definition ) {
						return new CKEDITOR.ui.panelButton( definition );
					}
				}
			},

			proto: {
				createPanel: function( editor ) {
					var _ = this._;

					if ( _.panel )
						return;

					var panelDefinition = this._.panelDefinition,
						panelBlockDefinition = this._.panelDefinition.block,
						panelParentElement = panelDefinition.parent || CKEDITOR.document.getBody(),
						panel = this._.panel = new CKEDITOR.ui.floatPanel( editor, panelParentElement, panelDefinition ),
						block = panel.addBlock( _.id, panelBlockDefinition ),
						me = this;

					panel.onShow = function() {
						if ( me.className )
							this.element.addClass( me.className + '_panel' );

						me.setState( CKEDITOR.TRISTATE_ON );

						_.on = 1;

						me.editorFocus && editor.focus();

						if ( me.onOpen )
							me.onOpen();
					};

					panel.onHide = function( preventOnClose ) {
						if ( me.className )
							this.element.getFirst().removeClass( me.className + '_panel' );

						me.setState( me.modes && me.modes[ editor.mode ] ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );

						_.on = 0;

						if ( !preventOnClose && me.onClose )
							me.onClose();
					};

					panel.onEscape = function() {
						panel.hide( 1 );
						me.document.getById( _.id ).focus();
					};

					if ( this.onBlock )
						this.onBlock( panel, block );

					block.onHide = function() {
						_.on = 0;
						me.setState( CKEDITOR.TRISTATE_OFF );
					};
				}
			}
		});

	},
	beforeInit: function( editor ) {
		editor.ui.addHandler( CKEDITOR.UI_PANELBUTTON, CKEDITOR.ui.panelButton.handler );
	}
});

/**
 * Button UI element.
 *
 * @readonly
 * @property {String} [='panelbutton']
 * @member CKEDITOR
 */
CKEDITOR.UI_PANELBUTTON = 'panelbutton';

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

(function() {
	CKEDITOR.plugins.add( 'panel', {
		beforeInit: function( editor ) {
			editor.ui.addHandler( CKEDITOR.UI_PANEL, CKEDITOR.ui.panel.handler );
		}
	});

	/**
	 * Panel UI element.
	 *
	 * @readonly
	 * @property {String} [='panel']
	 * @member CKEDITOR
	 */
	CKEDITOR.UI_PANEL = 'panel';

	/**
	 * @class
	 * @constructor Creates a panel class instance.
	 * @param {CKEDITOR.dom.document} document
	 * @param {Object} definition
	 */
	CKEDITOR.ui.panel = function( document, definition ) {
		// Copy all definition properties to this object.
		if ( definition )
			CKEDITOR.tools.extend( this, definition );

		// Set defaults.
		CKEDITOR.tools.extend( this, {
			className: '',
			css: []
		});

		this.id = CKEDITOR.tools.getNextId();
		this.document = document;
		this.isFramed = this.forceIFrame || this.css.length;

		this._ = {
			blocks: {}
		};
	};

	/**
	 * Represents panel handler object.
	 *
	 * @class
	 * @singleton
	 * @extends CKEDITOR.ui.handlerDefinition
	 */
	CKEDITOR.ui.panel.handler = {
		/**
		 * Transforms a panel definition in a {@link CKEDITOR.ui.panel} instance.
		 *
		 * @param {Object} definition
		 * @returns {CKEDITOR.ui.panel}
		 */
		create: function( definition ) {
			return new CKEDITOR.ui.panel( definition );
		}
	};

	var panelTpl = CKEDITOR.addTemplate( 'panel', '<div lang="{langCode}" id="{id}" dir={dir}' +
		' class="cke cke_reset_all {editorId} cke_panel cke_panel {cls} cke_{dir}"' +
		' style="z-index:{z-index}" role="presentation">' +
		'{frame}' +
		'</div>' );

	var frameTpl = CKEDITOR.addTemplate( 'panel-frame', '<iframe id="{id}" class="cke_panel_frame" role="application" frameborder="0" src="{src}"></iframe>' );

	// -------------------------------------------------------------------------
	// ***DYNAMIC DOCUMENTATION CHANGE***
	// What Changed:  Use the editor's document mode in the panel iframe.
	// See below change
	// -------------------------------------------------------------------------
	var frameDocTpl = CKEDITOR.addTemplate( 'panel-frame-inner', '<!DOCTYPE html>' +
		'<html class="cke_panel_container {env}" dir="{dir}" lang="{langCode}">' +
			'<head>{docmode}{css}</head>' +
			'<body class="cke_{dir}"' +
				' style="margin:0;padding:0" onload="{onload}"></body>' +
		'<\/html>' );

	/** @class CKEDITOR.ui.panel */
	CKEDITOR.ui.panel.prototype = {
		/**
		 * Renders the combo.
		 *
		 * @param {CKEDITOR.editor} editor The editor instance which this button is
		 * to be used by.
		 * @param {Array} [output] The output array to which append the HTML relative
		 * to this button.
		 */
		render: function( editor, output ) {
			this.getHolderElement = function() {
				var holder = this._.holder;

				if ( !holder ) {
					if ( this.isFramed ) {
						var iframe = this.document.getById( this.id + '_frame' ),
							parentDiv = iframe.getParent(),
							doc = iframe.getFrameDocument();

						// Make it scrollable on iOS. (#8308)
						CKEDITOR.env.iOS && parentDiv.setStyles({
							'overflow': 'scroll',
							'-webkit-overflow-scrolling': 'touch'
						});

						var onLoad = CKEDITOR.tools.addFunction( CKEDITOR.tools.bind( function( ev ) {
							this.isLoaded = true;
							if ( this.onLoad )
								this.onLoad();
						}, this ) );

						// -------------------------------------------------------------------------
						// ***DYNAMIC DOCUMENTATION CHANGE***
						// What Changed:  Use the editor's document mode in the panel iframe.
						//
						// This is important because the skin will select a stylesheet based on the
						// documentMode of the editor.  If we let the iframe use the default document
						// mode it will default to IE7 document mode, but will be using the
						// stylesheet of a newer version.  This causes rendering issues.
						//
						// Testing Considerations:  Right-click inside the editor and verify context
						//                          menus align properly
						// -------------------------------------------------------------------------
						var docMode = '';
						if ( CKEDITOR.env.ie )
							docMode = '<meta http-equiv="X-UA-Compatible" content="IE=' + editor.document.$.documentMode + '" />';

						doc.write( frameDocTpl.output( CKEDITOR.tools.extend({
							docmode: docMode,
							css: CKEDITOR.tools.buildStyleHtml( this.css ),
							onload: 'window.parent.CKEDITOR.tools.callFunction(' + onLoad + ');'
						}, data ) ) );

						var win = doc.getWindow();

						// Register the CKEDITOR global.
						win.$.CKEDITOR = CKEDITOR;

						// Arrow keys for scrolling is only preventable with 'keypress' event in Opera (#4534).
						doc.on( 'key' + ( CKEDITOR.env.opera ? 'press' : 'down' ), function( evt ) {
							var keystroke = evt.data.getKeystroke(),
								dir = this.document.getById( this.id ).getAttribute( 'dir' );

							// Delegate key processing to block.
							if ( this._.onKeyDown && this._.onKeyDown( keystroke ) === false ) {
								evt.data.preventDefault();
								return;
							}

							// ESC/ARROW-LEFT(ltr) OR ARROW-RIGHT(rtl)
							if ( keystroke == 27 || keystroke == ( dir == 'rtl' ? 39 : 37 ) ) {
								if ( this.onEscape && this.onEscape( keystroke ) === false )
									evt.data.preventDefault();
							}
						}, this );

						holder = doc.getBody();
						holder.unselectable();
						CKEDITOR.env.air && CKEDITOR.tools.callFunction( onLoad );
					} else
						holder = this.document.getById( this.id );

					this._.holder = holder;
				}

				return holder;
			};

			var data = {
				editorId: editor.id,
				id: this.id,
				langCode: editor.langCode,
				dir: editor.lang.dir,
				cls: this.className,
				frame: '',
				env: CKEDITOR.env.cssClass,
				'z-index': editor.config.baseFloatZIndex + 1
			};

			if ( this.isFramed ) {
				data.frame = frameTpl.output({
					id: this.id + '_frame',
					src: 'javascript:void(document.open(),' + ( CKEDITOR.env.isCustomDomain() ? 'document.domain=\'' + document.domain + '\',' : '' )
						+ 'document.close())">'
				});
			}

			var html = panelTpl.output( data );

			if ( output )
				output.push( html );

			return html;
		},

		/**
		 * @todo
		 */
		addBlock: function( name, block ) {
			block = this._.blocks[ name ] = block instanceof CKEDITOR.ui.panel.block ? block : new CKEDITOR.ui.panel.block( this.getHolderElement(), block );

			if ( !this._.currentBlock )
				this.showBlock( name );

			return block;
		},

		/**
		 * @todo
		 */
		getBlock: function( name ) {
			return this._.blocks[ name ];
		},

		/**
		 * @todo
		 */
		showBlock: function( name ) {
			var blocks = this._.blocks,
				block = blocks[ name ],
				current = this._.currentBlock;

			// ARIA role works better in IE on the body element, while on the iframe
			// for FF. (#8864)
			var holder = !this.forceIFrame || CKEDITOR.env.ie ? this._.holder : this.document.getById( this.id + '_frame' );

			if ( current ) {
				// Clean up the current block's effects on holder.
				holder.removeAttributes( current.attributes );
				current.hide();
			}

			this._.currentBlock = block;

			holder.setAttributes( block.attributes );
			CKEDITOR.fire( 'ariaWidget', holder );

			// Reset the focus index, so it will always go into the first one.
			block._.focusIndex = -1;

			this._.onKeyDown = block.onKeyDown && CKEDITOR.tools.bind( block.onKeyDown, block );

			block.show();

			return block;
		},

		/**
		 * @todo
		 */
		destroy: function() {
			this.element && this.element.remove();
		}
	};

	/**
	 * @class
	 *
	 * @todo class and all methods
	 */
	CKEDITOR.ui.panel.block = CKEDITOR.tools.createClass({
		/**
		 * Creates a block class instances.
		 *
		 * @constructor
		 * @todo
		 */
		$: function( blockHolder, blockDefinition ) {
			this.element = blockHolder.append( blockHolder.getDocument().createElement( 'div', {
				attributes: {
					'tabIndex': -1,
					'class': 'cke_panel_block',
					'role': 'presentation'
				},
				styles: {
					display: 'none'
				}
			}));

			// Copy all definition properties to this object.
			if ( blockDefinition )
				CKEDITOR.tools.extend( this, blockDefinition );

			if ( !this.attributes.title )
				this.attributes.title = this.attributes[ 'aria-label' ];

			this.keys = {};

			this._.focusIndex = -1;

			// Disable context menu for panels.
			this.element.disableContextMenu();
		},

		_: {

			/**
			 * Mark the item specified by the index as current activated.
			 */
			markItem: function( index ) {
				if ( index == -1 )
					return;
				var links = this.element.getElementsByTag( 'a' );
				var item = links.getItem( this._.focusIndex = index );

				// Safari need focus on the iframe window first(#3389), but we need
				// lock the blur to avoid hiding the panel.
				if ( CKEDITOR.env.webkit || CKEDITOR.env.opera )
					item.getDocument().getWindow().focus();
				item.focus();

				this.onMark && this.onMark( item );
			}
		},

		proto: {
			show: function() {
				this.element.setStyle( 'display', '' );
			},

			hide: function() {
				if ( !this.onHide || this.onHide.call( this ) !== true )
					this.element.setStyle( 'display', 'none' );
			},

			onKeyDown: function( keystroke ) {
				var keyAction = this.keys[ keystroke ];
				switch ( keyAction ) {
					// Move forward.
					case 'next':
						var index = this._.focusIndex,
							links = this.element.getElementsByTag( 'a' ),
							link;

						while ( ( link = links.getItem( ++index ) ) ) {
							// Move the focus only if the element is marked with
							// the _cke_focus and it it's visible (check if it has
							// width).
							if ( link.getAttribute( '_cke_focus' ) && link.$.offsetWidth ) {
								this._.focusIndex = index;
								link.focus();
								break;
							}
						}
						return false;

						// Move backward.
					case 'prev':
						index = this._.focusIndex;
						links = this.element.getElementsByTag( 'a' );

						while ( index > 0 && ( link = links.getItem( --index ) ) ) {
							// Move the focus only if the element is marked with
							// the _cke_focus and it it's visible (check if it has
							// width).
							if ( link.getAttribute( '_cke_focus' ) && link.$.offsetWidth ) {
								this._.focusIndex = index;
								link.focus();
								break;
							}
						}
						return false;

					case 'click':
					case 'mouseup':
						index = this._.focusIndex;
						link = index >= 0 && this.element.getElementsByTag( 'a' ).getItem( index );

						if ( link )
							link.$[ keyAction ] ? link.$[ keyAction ]() : link.$[ 'on' + keyAction ]();

						return false;
				}

				return true;
			}
		}
	});

})();

/**
 * Fired when a panel is added to the document.
 *
 * @event ariaWidget
 * @member CKEDITOR
 * @param {Object} data The element wrapping the panel.
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'floatpanel', {
	requires: 'panel'
} );

( function() {
	var panels = {};

	function getPanel( editor, doc, parentElement, definition, level ) {
		// Generates the panel key: docId-eleId-skinName-langDir[-uiColor][-CSSs][-level]
		var key = CKEDITOR.tools.genKey( doc.getUniqueId(), parentElement.getUniqueId(), editor.lang.dir, editor.uiColor || '', definition.css || '', level || '' ),
			panel = panels[ key ];

		if ( !panel ) {
			panel = panels[ key ] = new CKEDITOR.ui.panel( doc, definition );
			panel.element = parentElement.append( CKEDITOR.dom.element.createFromHtml( panel.render( editor ), doc ) );

			panel.element.setStyles( {
				display: 'none',
				position: 'absolute'
			} );
		}

		return panel;
	}

	/**
	 * Represents a floating panel UI element.
	 *
	 * It is reused by rich combos, color combos, menus, etc.
	 * and it renders its content using {@link CKEDITOR.ui.panel}.
	 *
	 * @class
	 * @todo
	 */
	CKEDITOR.ui.floatPanel = CKEDITOR.tools.createClass( {
		/**
		 * Creates a floatPanel class instance.
		 *
		 * @constructor
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.dom.element} parentElement
		 * @param {Object} definition Definition of the panel that will be floating.
		 * @param {Number} level
		 */
		$: function( editor, parentElement, definition, level ) {
			definition.forceIFrame = 1;

			// In case of editor with floating toolbar append panels that should float
			// to the main UI element.
			if ( definition.toolbarRelated && editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE )
				parentElement = CKEDITOR.document.getById( 'cke_' + editor.name );

			var doc = parentElement.getDocument(),
				panel = getPanel( editor, doc, parentElement, definition, level || 0 ),
				element = panel.element,
				iframe = element.getFirst(),
				that = this;

			// Disable native browser menu. (#4825)
			element.disableContextMenu();

			this.element = element;

			this._ = {
				editor: editor,
				// The panel that will be floating.
				panel: panel,
				parentElement: parentElement,
				definition: definition,
				document: doc,
				iframe: iframe,
				children: [],
				dir: editor.lang.dir,
				showBlockParams: null
			};

			editor.on( 'mode', hide );
			editor.on( 'resize', hide );

			// When resize of the window is triggered floatpanel should be repositioned according to new dimensions.
			// #11724. Fixes issue with undesired panel hiding on Android and iOS.
			doc.getWindow().on( 'resize', function() {
				this.reposition();
			}, this );

			// We need a wrapper because events implementation doesn't allow to attach
			// one listener more than once for the same event on the same object.
			// Remember that floatPanel#hide is shared between all instances.
			function hide() {
				that.hide();
			}
		},

		proto: {
			/**
			 * @todo
			 */
			addBlock: function( name, block ) {
				return this._.panel.addBlock( name, block );
			},

			/**
			 * @todo
			 */
			addListBlock: function( name, multiSelect ) {
				return this._.panel.addListBlock( name, multiSelect );
			},

			/**
			 * @todo
			 */
			getBlock: function( name ) {
				return this._.panel.getBlock( name );
			},

			/**
			 * Shows the panel block.
			 *
			 * @param {String} name
			 * @param {CKEDITOR.dom.element} offsetParent Positioned parent.
			 * @param {Number} corner
			 *
			 * * For LTR (left to right) oriented editor:
			 *      * `1` = top-left
			 *      * `2` = top-right
			 *      * `3` = bottom-right
			 *      * `4` = bottom-left
			 * * For RTL (right to left):
			 *      * `1` = top-right
			 *      * `2` = top-left
			 *      * `3` = bottom-left
			 *      * `4` = bottom-right
			 *
			 * @param {Number} [offsetX=0]
			 * @param {Number} [offsetY=0]
			 * @param {Function} [callback] A callback function executed when block positioning is done.
			 * @todo what do exactly these params mean (especially corner)?
			 */
			showBlock: function( name, offsetParent, corner, offsetX, offsetY, callback ) {
				var panel = this._.panel,
					block = panel.showBlock( name );

				this._.showBlockParams = [].slice.call( arguments );
				this.allowBlur( false );

				// Record from where the focus is when open panel.
				var editable = this._.editor.editable();
				this._.returnFocus = editable.hasFocus ? editable : new CKEDITOR.dom.element( CKEDITOR.document.$.activeElement );
				this._.hideTimeout = 0;

				var element = this.element,
					iframe = this._.iframe,
					// Edge prefers iframe's window to the iframe, just like the rest of the browsers (#13143).
					focused = CKEDITOR.env.ie && !CKEDITOR.env.edge ? iframe : new CKEDITOR.dom.window( iframe.$.contentWindow ),
					doc = element.getDocument(),
					positionedAncestor = this._.parentElement.getPositionedAncestor(),
					position = offsetParent.getDocumentPosition( doc ),
					positionedAncestorPosition = positionedAncestor ? positionedAncestor.getDocumentPosition( doc ) : { x: 0, y: 0 },
					rtl = this._.dir == 'rtl',
					left = position.x + ( offsetX || 0 ) - positionedAncestorPosition.x,
					top = position.y + ( offsetY || 0 ) - positionedAncestorPosition.y;

				// Floating panels are off by (-1px, 0px) in RTL mode. (#3438)
				if ( rtl && ( corner == 1 || corner == 4 ) )
					left += offsetParent.$.offsetWidth;
				else if ( !rtl && ( corner == 2 || corner == 3 ) )
					left += offsetParent.$.offsetWidth - 1;

				if ( corner == 3 || corner == 4 )
					top += offsetParent.$.offsetHeight - 1;

				// Memorize offsetParent by it's ID.
				this._.panel._.offsetParentId = offsetParent.getId();

				element.setStyles( {
					top: top + 'px',
					left: 0,
					display: ''
				} );

				// Don't use display or visibility style because we need to
				// calculate the rendering layout later and focus the element.
				element.setOpacity( 0 );

				// To allow the context menu to decrease back their width
				element.getFirst().removeStyle( 'width' );

				// Report to focus manager.
				this._.editor.focusManager.add( focused );

				// Configure the IFrame blur event. Do that only once.
				if ( !this._.blurSet ) {

					// With addEventListener compatible browsers, we must
					// useCapture when registering the focus/blur events to
					// guarantee they will be firing in all situations. (#3068, #3222 )
					CKEDITOR.event.useCapture = true;

					focused.on( 'blur', function( ev ) {
						// As we are using capture to register the listener,
						// the blur event may get fired even when focusing
						// inside the window itself, so we must ensure the
						// target is out of it.
						if ( !this.allowBlur() || ev.data.getPhase() != CKEDITOR.EVENT_PHASE_AT_TARGET )
							return;

						if ( this.visible && !this._.activeChild ) {
							// [iOS] Allow hide to be prevented if touch is bound
							// to any parent of the iframe blur happens before touch (#10714).
							if ( CKEDITOR.env.iOS ) {
								if ( !this._.hideTimeout )
									this._.hideTimeout = CKEDITOR.tools.setTimeout( doHide, 0, this );
							} else {
								doHide.call( this );
							}
						}

						function doHide() {
							// Panel close is caused by user's navigating away the focus, e.g. click outside the panel.
							// DO NOT restore focus in this case.
							delete this._.returnFocus;
							this.hide();
						}
					}, this );

					focused.on( 'focus', function() {
						this._.focused = true;
						this.hideChild();
						this.allowBlur( true );
					}, this );

					// [iOS] if touch is bound to any parent of the iframe blur
					// happens twice before touchstart and before touchend (#10714).
					if ( CKEDITOR.env.iOS ) {
						// Prevent false hiding on blur.
						// We don't need to return focus here because touchend will fire anyway.
						// If user scrolls and pointer gets out of the panel area touchend will also fire.
						focused.on( 'touchstart', function() {
							clearTimeout( this._.hideTimeout );
						}, this );

						// Set focus back to handle blur and hide panel when needed.
						focused.on( 'touchend', function() {
							this._.hideTimeout = 0;
							this.focus();
						}, this );
					}

					CKEDITOR.event.useCapture = false;

					this._.blurSet = 1;
				}

				panel.onEscape = CKEDITOR.tools.bind( function( keystroke ) {
					if ( this.onEscape && this.onEscape( keystroke ) === false )
						return false;
				}, this );

				CKEDITOR.tools.setTimeout( function() {
					var panelLoad = CKEDITOR.tools.bind( function() {
						var target = element;

						// Reset panel width as the new content can be narrower
						// than the old one. (#9355)
						target.removeStyle( 'width' );

						if ( block.autoSize ) {
							var panelDoc = block.element.getDocument(),
								width = ( ( CKEDITOR.env.webkit || CKEDITOR.env.edge ) ? block.element : panelDoc.getBody() ).$.scrollWidth;

							// Account for extra height needed due to IE quirks box model bug:
							// http://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug
							// (#3426)
							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && width > 0 )
								width += ( target.$.offsetWidth || 0 ) - ( target.$.clientWidth || 0 ) + 3;

							// Add some extra pixels to improve the appearance.
							width += 10;

							target.setStyle( 'width', width + 'px' );

							var height = block.element.$.scrollHeight;

							// Account for extra height needed due to IE quirks box model bug:
							// http://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug
							// (#3426)
							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && height > 0 )
								height += ( target.$.offsetHeight || 0 ) - ( target.$.clientHeight || 0 ) + 3;

							target.setStyle( 'height', height + 'px' );

							// Fix IE < 8 visibility.
							panel._.currentBlock.element.setStyle( 'display', 'none' ).removeStyle( 'display' );
						} else {
							target.removeStyle( 'height' );
						}

						// Flip panel layout horizontally in RTL with known width.
						if ( rtl )
							left -= element.$.offsetWidth;

						// Pop the style now for measurement.
						element.setStyle( 'left', left + 'px' );

						/* panel layout smartly fit the viewport size. */
						var panelElement = panel.element,
							panelWindow = panelElement.getWindow(),
							rect = element.$.getBoundingClientRect(),
							viewportSize = panelWindow.getViewPaneSize();

						// Compensation for browsers that dont support "width" and "height".
						var rectWidth = rect.width || rect.right - rect.left,
							rectHeight = rect.height || rect.bottom - rect.top;

						// Check if default horizontal layout is impossible.
						var spaceAfter = rtl ? rect.right : viewportSize.width - rect.left,
							spaceBefore = rtl ? viewportSize.width - rect.right : rect.left;

						if ( rtl ) {
							if ( spaceAfter < rectWidth ) {
								// Flip to show on right.
								if ( spaceBefore > rectWidth )
									left += rectWidth;
								// Align to window left.
								else if ( viewportSize.width > rectWidth )
									left = left - rect.left;
								// Align to window right, never cutting the panel at right.
								else
									left = left - rect.right + viewportSize.width;
							}
						} else if ( spaceAfter < rectWidth ) {
							// Flip to show on left.
							if ( spaceBefore > rectWidth )
								left -= rectWidth;
							// Align to window right.
							else if ( viewportSize.width > rectWidth )
								left = left - rect.right + viewportSize.width;
							// Align to window left, never cutting the panel at left.
							else
								left = left - rect.left;
						}


						// Check if the default vertical layout is possible.
						var spaceBelow = viewportSize.height - rect.top,
							spaceAbove = rect.top;

						if ( spaceBelow < rectHeight ) {
							// Flip to show above.
							if ( spaceAbove > rectHeight )
								top -= rectHeight;
							// Align to window bottom.
							else if ( viewportSize.height > rectHeight )
								top = top - rect.bottom + viewportSize.height;
							// Align to top, never cutting the panel at top.
							else
								top = top - rect.top;
						}

						// If IE is in RTL, we have troubles with absolute
						// position and horizontal scrolls. Here we have a
						// series of hacks to workaround it. (#6146)
						if ( CKEDITOR.env.ie ) {
							var offsetParent = new CKEDITOR.dom.element( element.$.offsetParent ),
								scrollParent = offsetParent;

							// Quirks returns <body>, but standards returns <html>.
							if ( scrollParent.getName() == 'html' )
								scrollParent = scrollParent.getDocument().getBody();

							if ( scrollParent.getComputedStyle( 'direction' ) == 'rtl' ) {
								// For IE8, there is not much logic on this, but it works.
								if ( CKEDITOR.env.ie8Compat )
									left -= element.getDocument().getDocumentElement().$.scrollLeft * 2;
								else
									left -= ( offsetParent.$.scrollWidth - offsetParent.$.clientWidth );
							}
						}

						// Trigger the onHide event of the previously active panel to prevent
						// incorrect styles from being applied (#6170)
						var innerElement = element.getFirst(),
							activePanel;
						if ( ( activePanel = innerElement.getCustomData( 'activePanel' ) ) )
							activePanel.onHide && activePanel.onHide.call( this, 1 );
						innerElement.setCustomData( 'activePanel', this );

						element.setStyles( {
							top: top + 'px',
							left: left + 'px'
						} );
						element.setOpacity( 1 );

						callback && callback();
					}, this );

					panel.isLoaded ? panelLoad() : panel.onLoad = panelLoad;

					CKEDITOR.tools.setTimeout( function() {
						var scrollTop = CKEDITOR.env.webkit && CKEDITOR.document.getWindow().getScrollPosition().y;

						// Focus the panel frame first, so blur gets fired.
						this.focus();

						// Focus the block now.
						block.element.focus();

						// #10623, #10951 - restore the viewport's scroll position after focusing list element.
						if ( CKEDITOR.env.webkit )
							CKEDITOR.document.getBody().$.scrollTop = scrollTop;

						// We need this get fired manually because of unfired focus() function.
						this.allowBlur( true );
						this._.editor.fire( 'panelShow', this );
					}, 0, this );
				}, CKEDITOR.env.air ? 200 : 0, this );
				this.visible = 1;

				if ( this.onShow )
					this.onShow.call( this );
			},

			/**
			 * Repositions the panel with the same parameters that were used in the last {@link #showBlock} call.
			 *
			 * @since 4.5.4
			 */
			reposition: function() {
				var blockParams = this._.showBlockParams;

				if ( this.visible && this._.showBlockParams ) {
					this.hide();
					this.showBlock.apply( this, blockParams );
				}
			},

			/**
			 * Restores the last focused element or simply focuses the panel window.
			 */
			focus: function() {
				// Webkit requires to blur any previous focused page element, in
				// order to properly fire the "focus" event.
				if ( CKEDITOR.env.webkit ) {
					var active = CKEDITOR.document.getActive();
					active && !active.equals( this._.iframe ) && active.$.blur();
				}

				// Restore last focused element or simply focus panel window.
				var focus = this._.lastFocused || this._.iframe.getFrameDocument().getWindow();
				focus.focus();
			},

			/**
			 * @todo
			 */
			blur: function() {
				var doc = this._.iframe.getFrameDocument(),
					active = doc.getActive();

				active && active.is( 'a' ) && ( this._.lastFocused = active );
			},

			/**
			 * Hides the panel.
			 *
			 * @todo
			 */
			hide: function( returnFocus ) {
				if ( this.visible && ( !this.onHide || this.onHide.call( this ) !== true ) ) {
					this.hideChild();
					// Blur previously focused element. (#6671)
					CKEDITOR.env.gecko && this._.iframe.getFrameDocument().$.activeElement.blur();
					this.element.setStyle( 'display', 'none' );
					this.visible = 0;
					this.element.getFirst().removeCustomData( 'activePanel' );

					// Return focus properly. (#6247)
					var focusReturn = returnFocus && this._.returnFocus;
					if ( focusReturn ) {
						// Webkit requires focus moved out panel iframe first.
						if ( CKEDITOR.env.webkit && focusReturn.type )
							focusReturn.getWindow().$.focus();

						focusReturn.focus();
					}

					delete this._.lastFocused;
					this._.showBlockParams = null;

					this._.editor.fire( 'panelHide', this );
				}
			},

			/**
			 * @todo
			 */
			allowBlur: function( allow ) {
				// Prevent editor from hiding the panel. (#3222)
				var panel = this._.panel;
				if ( allow !== undefined )
					panel.allowBlur = allow;

				return panel.allowBlur;
			},

			/**
			 * Shows the specified panel as a child of one block of this one.
			 *
			 * @param {CKEDITOR.ui.floatPanel} panel
			 * @param {String} blockName
			 * @param {CKEDITOR.dom.element} offsetParent Positioned parent.
			 * @param {Number} corner
			 *
			 * * For LTR (left to right) oriented editor:
			 *      * `1` = top-left
			 *      * `2` = top-right
			 *      * `3` = bottom-right
			 *      * `4` = bottom-left
			 * * For RTL (right to left):
			 *      * `1` = top-right
			 *      * `2` = top-left
			 *      * `3` = bottom-left
			 *      * `4` = bottom-right
			 *
			 * @param {Number} [offsetX=0]
			 * @param {Number} [offsetY=0]
			 * @todo
			 */
			showAsChild: function( panel, blockName, offsetParent, corner, offsetX, offsetY ) {
				// Skip reshowing of child which is already visible.
				if ( this._.activeChild == panel && panel._.panel._.offsetParentId == offsetParent.getId() )
					return;

				this.hideChild();

				panel.onHide = CKEDITOR.tools.bind( function() {
					// Use a timeout, so we give time for this menu to get
					// potentially focused.
					CKEDITOR.tools.setTimeout( function() {
						if ( !this._.focused )
							this.hide();
					}, 0, this );
				}, this );

				this._.activeChild = panel;
				this._.focused = false;

				panel.showBlock( blockName, offsetParent, corner, offsetX, offsetY );
				this.blur();

				/* #3767 IE: Second level menu may not have borders */
				if ( CKEDITOR.env.ie7Compat || CKEDITOR.env.ie6Compat ) {
					setTimeout( function() {
						panel.element.getChild( 0 ).$.style.cssText += '';
					}, 100 );
				}
			},

			/**
			 * @todo
			 */
			hideChild: function( restoreFocus ) {
				var activeChild = this._.activeChild;

				if ( activeChild ) {
					delete activeChild.onHide;
					delete this._.activeChild;
					activeChild.hide();

					// At this point focus should be moved back to parent panel.
					restoreFocus && this.focus();
				}
			}
		}
	} );

	CKEDITOR.on( 'instanceDestroyed', function() {
		var isLastInstance = CKEDITOR.tools.isEmpty( CKEDITOR.instances );

		for ( var i in panels ) {
			var panel = panels[ i ];
			// Safe to destroy it since there're no more instances.(#4241)
			if ( isLastInstance )
				panel.destroy();
			// Panel might be used by other instances, just hide them.(#4552)
			else
				panel.element.hide();
		}
		// Remove the registration.
		isLastInstance && ( panels = {} );

	} );
} )();

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "colorbutton" plugin that makes it possible to assign
 *               text and background colors to editor contents.
 *
 */
CKEDITOR.plugins.add( 'colorbutton', {
	requires: 'panelbutton,floatpanel',
	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
	icons: 'bgcolor,textcolor', // %REMOVE_LINE_CORE%
	init: function( editor ) {
		var config = editor.config,
			lang = editor.lang.colorbutton;

		var clickFn;

		if ( !CKEDITOR.env.hc ) {
			addButton( 'TextColor', 'fore', lang.textColorTitle, 10 );
			addButton( 'BGColor', 'back', lang.bgColorTitle, 20 );
		}

		function addButton( name, type, title, order ) {
			var style = new CKEDITOR.style( config[ 'colorButton_' + type + 'Style' ] ),
				colorBoxId = CKEDITOR.tools.getNextId() + '_colorBox';

			editor.ui.add( name, CKEDITOR.UI_PANELBUTTON, {
				label: title,
				title: title,
				modes: { wysiwyg:1 },
				editorFocus: 1,
				toolbar: 'colors,' + order,
				allowedContent: style,
				requiredContent: style,

				panel: {
					css: CKEDITOR.skin.getPath( 'editor' ),
					attributes: { role: 'listbox', 'aria-label': lang.panelTitle }
				},

				onBlock: function( panel, block ) {
					block.autoSize = true;
					block.element.addClass( 'cke_colorblock' );
					block.element.setHtml( renderColors( panel, type, colorBoxId ) );
					// The block should not have scrollbars (#5933, #6056)
					block.element.getDocument().getBody().setStyle( 'overflow', 'hidden' );

					CKEDITOR.ui.fire( 'ready', this );

					var keys = block.keys;
					var rtl = editor.lang.dir == 'rtl';
					keys[ rtl ? 37 : 39 ] = 'next'; // ARROW-RIGHT
					keys[ 40 ] = 'next'; // ARROW-DOWN
					keys[ 9 ] = 'next'; // TAB
					keys[ rtl ? 39 : 37 ] = 'prev'; // ARROW-LEFT
					keys[ 38 ] = 'prev'; // ARROW-UP
					keys[ CKEDITOR.SHIFT + 9 ] = 'prev'; // SHIFT + TAB
					keys[ 32 ] = 'click'; // SPACE
				},

				// The automatic colorbox should represent the real color (#6010)
				onOpen: function() {

					var selection = editor.getSelection(),
						block = selection && selection.getStartElement(),
						path = editor.elementPath( block ),
						color;

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed: Check for null.
					// If selection is collapsed in read-only area, `block` and `path` might be null.
					// Testing Consideration:
					// 1. Click into read-only area in DynDocCKEditor to create a collapsed selection.
					// 2. Click the font color button
					// JavaScript error appears because `path` is null.
					// Also, when this occurs, verify that no error occurs when selecting a color from the popup.
					// ------------------------------------------------------------------------------------
					if (!path)
						return;

					// Find the closest block element.
					block = path.block || path.blockLimit || editor.document.getBody();

					// The background color might be transparent. In that case, look up the color in the DOM tree.
					do {
						color = block && block.getComputedStyle( type == 'back' ? 'background-color' : 'color' ) || 'transparent';
					}
					while ( type == 'back' && color == 'transparent' && block && ( block = block.getParent() ) );

					// The box should never be transparent.
					if ( !color || color == 'transparent' )
						color = '#ffffff';

					this._.panel._.iframe.getFrameDocument().getById( colorBoxId ).setStyle( 'background-color', color );

					this._.bms = selection.createBookmarks2();

					return color;
				},

				onClose:  function() {
					if ( this._.bms ) {
						editor.getSelection().selectBookmarks( this._.bms );
						delete this._.bms;
					}
				}
			});
		}


		function renderColors( panel, type, colorBoxId ) {
			var output = [],
				colors = config.colorButton_colors.split( ',' );

			var clickFn = CKEDITOR.tools.addFunction( function( color, type ) {
				if ( color == '?' ) {
					var applyColorStyle = arguments.callee;

					function onColorDialogClose( evt ) {
						this.removeListener( 'ok', onColorDialogClose );
						this.removeListener( 'cancel', onColorDialogClose );

						evt.name == 'ok' && applyColorStyle( this.getContentElement( 'picker', 'selectedColor' ).getValue(), type );
					}

					editor.openDialog( 'colordialog', function() {
						this.on( 'ok', onColorDialogClose );
						this.on( 'cancel', onColorDialogClose );
					});

					return;
				}

				editor.focus();

				panel.hide();

				editor.fire( 'saveSnapshot' );

				// Clean up any conflicting style within the range.
				editor.removeStyle( new CKEDITOR.style( config[ 'colorButton_' + type + 'Style' ], { color: 'inherit' } ) );

				if ( color ) {
					var colorStyle = config[ 'colorButton_' + type + 'Style' ];

					colorStyle.childRule = type == 'back' ?
					function( element ) {
						// It's better to apply background color as the innermost style. (#3599)
						// Except for "unstylable elements". (#6103)
						return isUnstylable( element );
					} : function( element ) {
						// Fore color style must be applied inside links instead of around it. (#4772,#6908)
						return !( element.is( 'a' ) || element.getElementsByTag( 'a' ).count() ) || isUnstylable( element );
					};

					editor.applyStyle( new CKEDITOR.style( colorStyle, { color: color } ) );
				}

				editor.fire( 'saveSnapshot' );
			});

			// Render the "Automatic" button.
			output.push( '<a class="cke_colorauto" _cke_focus=1 hidefocus=true' +
				' title="', lang.auto, '"' +
				' onclick="CKEDITOR.tools.callFunction(', clickFn, ',null,\'', type, '\');return false;"' +
				' href="javascript:void(\'', lang.auto, '\')"' +
				' role="option">' +
				'<table role="presentation" cellspacing=0 cellpadding=0 width="100%">' +
					'<tr>' +
						'<td>' +
							'<span class="cke_colorbox" id="', colorBoxId, '"></span>' +
						'</td>' +
						'<td colspan=7 align=center>', lang.auto, '</td>' +
					'</tr>' +
				'</table>' +
				'</a>' +
				'<table role="presentation" cellspacing=0 cellpadding=0 width="100%">' );

			// Render the color boxes.
			for ( var i = 0; i < colors.length; i++ ) {
				if ( ( i % 8 ) === 0 )
					output.push( '</tr><tr>' );

				var parts = colors[ i ].split( '/' ),
					colorName = parts[ 0 ],
					colorCode = parts[ 1 ] || colorName;

				// The data can be only a color code (without #) or colorName + color code
				// If only a color code is provided, then the colorName is the color with the hash
				// Convert the color from RGB to RRGGBB for better compatibility with IE and <font>. See #5676
				if ( !parts[ 1 ] )
					colorName = '#' + colorName.replace( /^(.)(.)(.)$/, '$1$1$2$2$3$3' );

				var colorLabel = editor.lang.colorbutton.colors[ colorCode ] || colorCode;
				output.push( '<td>' +
					'<a class="cke_colorbox" _cke_focus=1 hidefocus=true' +
						' title="', colorLabel, '"' +
						' onclick="CKEDITOR.tools.callFunction(', clickFn, ',\'', colorName, '\',\'', type, '\'); return false;"' +
						' href="javascript:void(\'', colorLabel, '\')"' +
						' role="option">' +
						'<span class="cke_colorbox" style="background-color:#', colorCode, '"></span>' +
					'</a>' +
					'</td>' );
			}

			// Render the "More Colors" button.
			if ( editor.plugins.colordialog && config.colorButton_enableMore === undefined || config.colorButton_enableMore ) {
				output.push( '</tr>' +
					'<tr>' +
						'<td colspan=8 align=center>' +
							'<a class="cke_colormore" _cke_focus=1 hidefocus=true' +
								' title="', lang.more, '"' +
								' onclick="CKEDITOR.tools.callFunction(', clickFn, ',\'?\',\'', type, '\');return false;"' +
								' href="javascript:void(\'', lang.more, '\')"', ' role="option">', lang.more, '</a>' +
						'</td>' ); // tr is later in the code.
			}

			output.push( '</tr></table>' );

			return output.join( '' );
		}

		function isUnstylable( ele ) {
			return ( ele.getAttribute( 'contentEditable' ) == 'false' ) || ele.getAttribute( 'data-nostyle' );
		}
	}
});

/**
 * Whether to enable the **More Colors*** button in the color selectors.
 *
 *		config.colorButton_enableMore = false;
 *
 * @cfg {Boolean} [colorButton_enableMore=true]
 * @member CKEDITOR.config
 */

/**
 * Defines the colors to be displayed in the color selectors. This is a string
 * containing hexadecimal notation for HTML colors, without the `'#'` prefix.
 *
 * **Since 3.3:** A color name may optionally be defined by prefixing the entries with
 * a name and the slash character. For example, `'FontColor1/FF9900'` will be
 * displayed as the color `#FF9900` in the selector, but will be output as `'FontColor1'`.
 *
 *		// Brazil colors only.
 *		config.colorButton_colors = '00923E,F8C100,28166F';
 *
 *		config.colorButton_colors = 'FontColor1/FF9900,FontColor2/0066CC,FontColor3/F00';
 *
 * @cfg {String} [colorButton_colors=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.colorButton_colors = '000,800000,8B4513,2F4F4F,008080,000080,4B0082,696969,' +
	'B22222,A52A2A,DAA520,006400,40E0D0,0000CD,800080,808080,' +
	'F00,FF8C00,FFD700,008000,0FF,00F,EE82EE,A9A9A9,' +
	'FFA07A,FFA500,FFFF00,00FF00,AFEEEE,ADD8E6,DDA0DD,D3D3D3,' +
	'FFF0F5,FAEBD7,FFFFE0,F0FFF0,F0FFFF,F0F8FF,E6E6FA,FFF';

/**
 * Stores the style definition that applies the text foreground color.
 *
 *		// This is actually the default value.
 *		config.colorButton_foreStyle = {
 *			element: 'span',
 *			styles: { color: '#(color)' }
 *		};
 *
 * @cfg [colorButton_foreStyle=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.colorButton_foreStyle = {
	element: 'span',
	styles: { 'color': '#(color)' },
	overrides: [ {
		element: 'font', attributes: { 'color': null }
	}]
};

/**
 * Stores the style definition that applies the text background color.
 *
 *		// This is actually the default value.
 *		config.colorButton_backStyle = {
 *			element: 'span',
 *			styles: { 'background-color': '#(color)' }
 *		};
 *
 * @cfg [colorButton_backStyle=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.colorButton_backStyle = {
	element: 'span',
	styles: { 'background-color': '#(color)' }
};

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.colordialog = {
	requires: 'dialog',
	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
	init: function( editor ) {
		editor.addCommand( 'colordialog', new CKEDITOR.dialogCommand( 'colordialog' ) );
		CKEDITOR.dialog.add( 'colordialog', this.path + 'dialogs/colordialog.js' );

		/**
		 * Open up color dialog and to receive the selected color.
		 *
		 * @param {Function} callback The callback when color dialog is closed
		 * @param {String} callback.color The color value received if selected on the dialog.
		 * @param [scope] The scope in which the callback will be bound.
		 * @member CKEDITOR.editor
		 */
		editor.getColorFromDialog = function( callback, scope ) {
			var onClose = function( evt ) {
				releaseHandlers( this );
				var color = evt.name == 'ok' ? this.getValueOf( 'picker', 'selectedColor' ) : null;
				callback.call( scope, color );
			};
			var releaseHandlers = function( dialog ) {
				dialog.removeListener( 'ok', onClose );
				dialog.removeListener( 'cancel', onClose );
			};
			var bindToDialog = function( dialog ) {
				dialog.on( 'ok', onClose );
				dialog.on( 'cancel', onClose );
			};

			editor.execCommand( 'colordialog' );

			if ( editor._.storedDialogs && editor._.storedDialogs.colordialog )
				bindToDialog( editor._.storedDialogs.colordialog );
			else {
				CKEDITOR.on( 'dialogDefinition', function( e ) {
					if ( e.data.name != 'colordialog' )
						return;

					var definition = e.data.definition;

					e.removeListener();
					definition.onLoad = CKEDITOR.tools.override( definition.onLoad,
						function( orginal ) {
							return function() {
								bindToDialog( this );
								definition.onLoad = orginal;
								if ( typeof orginal == 'function' )
									orginal.call( this );
							};
						} );
				} );
			}
		};


	}
};

CKEDITOR.plugins.add( 'colordialog', CKEDITOR.plugins.colordialog );

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'menu', {
	requires: 'floatpanel',

	beforeInit: function( editor ) {
		var groups = editor.config.menu_groups.split( ',' ),
			groupsOrder = editor._.menuGroups = {},
			menuItems = editor._.menuItems = {};

		for ( var i = 0; i < groups.length; i++ )
			groupsOrder[ groups[ i ] ] = i + 1;

		/**
		 * Registers an item group to the editor context menu in order to make it
		 * possible to associate it with menu items later.
		 *
		 * @param {String} name Specify a group name.
		 * @param {Number} [order=100] Define the display sequence of this group
		 * inside the menu. A smaller value gets displayed first.
		 * @member CKEDITOR.editor
		 */
		editor.addMenuGroup = function( name, order ) {
			groupsOrder[ name ] = order || 100;
		};

		/**
		 * Adds an item from the specified definition to the editor context menu.
		 *
		 * @method
		 * @param {String} name The menu item name.
		 * @param {Object} definition The menu item definition.
		 * @member CKEDITOR.editor
		 */
		editor.addMenuItem = function( name, definition ) {
			if ( groupsOrder[ definition.group ] )
				menuItems[ name ] = new CKEDITOR.menuItem( this, name, definition );
		};

		/**
		 * Adds one or more items from the specified definition array to the editor context menu.
		 *
		 * @method
		 * @param {Array} definitions List of definitions for each menu item as if {@link #addMenuItem} is called.
		 * @member CKEDITOR.editor
		 */
		editor.addMenuItems = function( definitions ) {
			for ( var itemName in definitions ) {
				this.addMenuItem( itemName, definitions[ itemName ] );
			}
		};

		/**
		 * Retrieves a particular menu item definition from the editor context menu.
		 *
		 * @method
		 * @param {String} name The name of the desired menu item.
		 * @returns {Object}
		 * @member CKEDITOR.editor
		 */
		editor.getMenuItem = function( name ) {
			return menuItems[ name ];
		};

		/**
		 * Removes a particular menu item added before from the editor context menu.
		 *
		 * @since 3.6.1
		 * @method
		 * @param {String} name The name of the desired menu item.
		 * @member CKEDITOR.editor
		 */
		editor.removeMenuItem = function( name ) {
			delete menuItems[ name ];
		};
	}
});

(function() {
	var menuItemSource = '<span class="cke_menuitem">' +
		'<a id="{id}"' +
		' class="cke_menubutton cke_menubutton__{name} cke_menubutton_{state} {cls}" href="{href}"' +
		' title="{title}"' +
		' tabindex="-1"' +
		'_cke_focus=1' +
		' hidefocus="true"' +
		' role="menuitem"' +
		' aria-haspopup="{hasPopup}"' +
		' aria-disabled="{disabled}"';

	// Some browsers don't cancel key events in the keydown but in the
	// keypress.
	// TODO: Check if really needed for Gecko+Mac.
	if ( CKEDITOR.env.opera || ( CKEDITOR.env.gecko && CKEDITOR.env.mac ) )
		menuItemSource += ' onkeypress="return false;"';

	// With Firefox, we need to force the button to redraw, otherwise it
	// will remain in the focus state.
	if ( CKEDITOR.env.gecko )
		menuItemSource += ' onblur="this.style.cssText = this.style.cssText;"';

	// #188
	menuItemSource += ' onmouseover="CKEDITOR.tools.callFunction({hoverFn},{index});"' +
			' onmouseout="CKEDITOR.tools.callFunction({moveOutFn},{index});" ' +
			( CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick' ) +
				'="CKEDITOR.tools.callFunction({clickFn},{index}); return false;"' +
			'>';

	menuItemSource +=
				'<span class="cke_menubutton_inner">' +
					'<span class="cke_menubutton_icon">' +
						'<span class="cke_button_icon cke_button__{iconName}_icon" style="{iconStyle}"></span>' +
					'</span>' +
					'<span class="cke_menubutton_label">' +
						'{label}' +
					'</span>' +
					'{arrowHtml}' +
				'</span>' +
			'</a></span>';

	var menuArrowSource = '<span class="cke_menuarrow">' +
				'<span>{label}</span>' +
			'</span>';

	var menuItemTpl = CKEDITOR.addTemplate( 'menuItem', menuItemSource ),
		menuArrowTpl = CKEDITOR.addTemplate( 'menuArrow', menuArrowSource );

	/**
	 * @class
	 * @todo
	 */
	CKEDITOR.menu = CKEDITOR.tools.createClass({
		$: function( editor, definition ) {
			definition = this._.definition = definition || {};
			this.id = CKEDITOR.tools.getNextId();

			this.editor = editor;
			this.items = [];
			this._.listeners = [];

			this._.level = definition.level || 1;

			var panelDefinition = CKEDITOR.tools.extend( {}, definition.panel, {
				css: [ CKEDITOR.skin.getPath( 'editor' ) ],
				level: this._.level - 1,
				block: {}
			});

			var attrs = panelDefinition.block.attributes = ( panelDefinition.attributes || {} );
			// Provide default role of 'menu'.
			!attrs.role && ( attrs.role = 'menu' );
			this._.panelDefinition = panelDefinition;
		},

		_: {
			onShow: function() {
				var selection = this.editor.getSelection(),
					start = selection && selection.getStartElement(),
					path = this.editor.elementPath(),
					listeners = this._.listeners;

				this.removeAll();
				// Call all listeners, filling the list of items to be displayed.
				for ( var i = 0; i < listeners.length; i++ ) {
					var listenerItems = listeners[ i ]( start, selection, path );

					if ( listenerItems ) {
						for ( var itemName in listenerItems ) {
							var item = this.editor.getMenuItem( itemName );

							if ( item && ( !item.command || this.editor.getCommand( item.command ).state ) ) {
								item.state = listenerItems[ itemName ];
								this.add( item );
							}
						}
					}
				}
			},

			onClick: function( item ) {
				this.hide();

				if ( item.onClick )
					item.onClick();
				else if ( item.command )
					this.editor.execCommand( item.command );
			},

			onEscape: function( keystroke ) {
				var parent = this.parent;
				// 1. If it's sub-menu, close it, with focus restored on this.
				// 2. In case of a top-menu, close it, with focus returned to page.
				if ( parent )
					parent._.panel.hideChild( 1 );
				else if ( keystroke == 27 )
					this.hide( 1 );

				return false;
			},

			onHide: function() {
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:  Delete saved bookmark
				//
				// Put this in a setTimeout so that the itemClickFn gets a chance to use them first.
				//
				// See companion changes in menu/plugin.js
				// ------------------------------------------------------------------------------------
				this.onHide && this.onHide();
				CKEDITOR.tools.setTimeout( function() { delete this.editor._.bookmarksBeforeMenu; delete this.editor._.scrollTopBeforeMenu; }, 0, this );
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Added call to removeAll in onHide
				// Testing Considerations: Clear references to items so that memory doesn't leak 
				// ------------------------------------------------------------------------------------
				this.removeAll();
			},

			showSubMenu: function( index ) {
				var menu = this._.subMenu,
					item = this.items[ index ];

				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Validate item and menu prior to usage
				// Testing Considerations:
				//  * Open context menu and scroll-up/down and right-click to launch context menu.
				//  * Quickly right-click repeatedly to bring up the context menu (have something on
				//    the system clipboard).
				// ------------------------------------------------------------------------------------
				if ( !item || !menu )
					return;
				var subItemDefs = item.getItems && item.getItems();

				// If this item has no subitems, we just hide the submenu, if
				// available, and return back.
				if ( !subItemDefs ) {
					// Hide sub menu with focus returned.
					this._.panel.hideChild( 1 );
					return;
				}

				// Create the submenu, if not available, or clean the existing
				// one.
				if ( menu )
					menu.removeAll();
				else {
					menu = this._.subMenu = new CKEDITOR.menu( this.editor, CKEDITOR.tools.extend( {}, this._.definition, { level: this._.level + 1 }, true ) );
					menu.parent = this;
					menu._.onClick = CKEDITOR.tools.bind( this._.onClick, this );
				}

				// Add all submenu items to the menu.
				for ( var subItemName in subItemDefs ) {
					var subItem = this.editor.getMenuItem( subItemName );
					if ( subItem ) {
						subItem.state = subItemDefs[ subItemName ];
						menu.add( subItem );
					}
				}

				// Get the element representing the current item.
				var element = this._.panel.getBlock( this.id ).element.getDocument().getById( this.id + String( index ) );

				// Show the submenu.
				// This timeout is needed to give time for the sub-menu get
				// focus when JAWS is running. (#9844)
				setTimeout( function() {
					menu.show( element, 2 );
				},0);
			}
		},

		proto: {
			add: function( item ) {
				// Later we may sort the items, but Array#sort is not stable in
				// some browsers, here we're forcing the original sequence with
				// 'order' attribute if it hasn't been assigned. (#3868)
				if ( !item.order )
					item.order = this.items.length;

				this.items.push( item );
			},

			removeAll: function() {
				this.items = [];
			},

			show: function( offsetParent, corner, offsetX, offsetY ) {
				// Not for sub menu.
				if ( !this.parent ) {
					this._.onShow();
					// Don't menu with zero items.
					if ( !this.items.length )
						return;
				}

				corner = corner || ( this.editor.lang.dir == 'rtl' ? 2 : 1 );

				var items = this.items,
					editor = this.editor,
					panel = this._.panel,
					element = this._.element;

				// Create the floating panel for this menu.
				if ( !panel ) {
					panel = this._.panel = new CKEDITOR.ui.floatPanel( this.editor, CKEDITOR.document.getBody(), this._.panelDefinition, this._.level );

					panel.onEscape = CKEDITOR.tools.bind( function( keystroke ) {
						if ( this._.onEscape( keystroke ) === false )
							return false;
					}, this );

					panel.onShow = function() {
						// Menu need CSS resets, compensate class name.
						var holder = panel._.panel.getHolderElement();
						holder.getParent().addClass( 'cke cke_reset_all' );
					};

					panel.onHide = CKEDITOR.tools.bind( function() {
						this._.onHide && this._.onHide();
					}, this );

					// Create an autosize block inside the panel.
					var block = panel.addBlock( this.id, this._.panelDefinition.block );
					block.autoSize = true;

					var keys = block.keys;
					keys[ 40 ] = 'next'; // ARROW-DOWN
					keys[ 9 ] = 'next'; // TAB
					keys[ 38 ] = 'prev'; // ARROW-UP
					keys[ CKEDITOR.SHIFT + 9 ] = 'prev'; // SHIFT + TAB
					keys[ ( editor.lang.dir == 'rtl' ? 37 : 39 ) ] = CKEDITOR.env.ie ? 'mouseup' : 'click'; // ARROW-RIGHT/ARROW-LEFT(rtl)
					keys[ 32 ] = CKEDITOR.env.ie ? 'mouseup' : 'click'; // SPACE
					CKEDITOR.env.ie && ( keys[ 13 ] = 'mouseup' ); // Manage ENTER, since onclick is blocked in IE (#8041).

					element = this._.element = block.element;

					var elementDoc = element.getDocument();
					elementDoc.getBody().setStyle( 'overflow', 'hidden' );
					elementDoc.getElementsByTag( 'html' ).getItem( 0 ).setStyle( 'overflow', 'hidden' );

					this._.itemOverFn = CKEDITOR.tools.addFunction( function( index ) {
						clearTimeout( this._.showSubTimeout );
						this._.showSubTimeout = CKEDITOR.tools.setTimeout( this._.showSubMenu, editor.config.menu_subMenuDelay || 400, this, [ index ] );
					}, this );

					this._.itemOutFn = CKEDITOR.tools.addFunction( function( index ) {
						clearTimeout( this._.showSubTimeout );
					}, this );

					this._.itemClickFn = CKEDITOR.tools.addFunction( function( index ) {
						var item = this.items[ index ];
						// ------------------------------------------------------------------------------------
						// ***DYNAMIC DOCUMENTATION CHANGE***
						// What Changed: Validate item and menu prior to usage
						// Testing Considerations:
						//  * Quickly right-click repeatedly to bring up the context menu (have something on
						//    the system clipboard).
						// ------------------------------------------------------------------------------------
						if ( !item )
							return;

						if ( item.state == CKEDITOR.TRISTATE_DISABLED ) {
							this.hide( 1 );

							// ------------------------------------------------------------------------------------
							// ***DYNAMIC DOCUMENTATION CHANGE***
							// What Changed: Select the saved bookmarks
							//
							// See companion changes in menu/plugin.js
							//
							// Testing Considerations:
							//  * Repeatedly right-click a misspelled to show the context menu and click (No
							//    Suggestions).  The page should not scroll and the editable element should still
							//    have focus.
							//  * Verify that other menus still work, like the font family and font size menus.
							//  * Verify that selecting spelling suggestions works.
							//  * Verify that context menu copy, cut, & paste work.
							//  * Verify that these things work in the popup editor.
							//  * Verify that these things work in the Formatted Text Entry dialog HTML editor.
							// ------------------------------------------------------------------------------------
							if ( this.editor._.bookmarksBeforeMenu ) {
								var selection = this.editor.getSelection();
								selection && selection.selectBookmarks( this.editor._.bookmarksBeforeMenu );
								this.editor.editable().$.scrollTop = this.editor._.scrollTopBeforeMenu;
								delete this.editor._.bookmarksBeforeMenu;
								delete this.editor._.scrollTopBeforeMenu;
							}
							return;
						}

						if ( item.getItems )
							this._.showSubMenu( index );
						else
							this._.onClick( item );
					}, this );
				}

				// Put the items in the right order.
				sortItems( items );

				// Apply the editor mixed direction status to menu.
				var path = editor.elementPath(),
					mixedDirCls = ( path && path.direction() != editor.lang.dir ) ? ' cke_mixed_dir_content' : '';

				// Build the HTML that composes the menu and its items.
				var output = [ '<div class="cke_menu' + mixedDirCls + '" role="presentation">' ];

				var length = items.length,
					lastGroup = length && items[ 0 ].group;

				for ( var i = 0; i < length; i++ ) {
					var item = items[ i ];
					if ( lastGroup != item.group ) {
						output.push( '<div class="cke_menuseparator" role="separator"></div>' );
						lastGroup = item.group;
					}

					item.render( this, i, output );
				}

				output.push( '</div>' );

				// Inject the HTML inside the panel.
				element.setHtml( output.join( '' ) );

				CKEDITOR.ui.fire( 'ready', this );

				// Show the panel.
				if ( this.parent )
					this.parent._.panel.showAsChild( panel, this.id, offsetParent, corner, offsetX, offsetY );
				else
					panel.showBlock( this.id, offsetParent, corner, offsetX, offsetY );

				editor.fire( 'menuShow', [ panel ] );
			},

			addListener: function( listenerFn ) {
				this._.listeners.push( listenerFn );
			},

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: Added removeListeners function
			// Testing Considerations: Clear references to listeners so that memory doesn't leak 
			// ------------------------------------------------------------------------------------
			removeListeners: function () {
				this._.listeners = [];
			},

			hide: function( returnFocus ) {
				this._.onHide && this._.onHide();
				this._.panel && this._.panel.hide( returnFocus );
			},

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: Added public isVisible function to CKEDITOR.menu
			// Javascript error appears.  startNode is null in CKEDITOR.dom.range.setStart
			// Testing Considerations:
			// 1. Type a word into a free text area.  Do not enter a space after the word.
			// 2. Right-click the word to bring up the context menu.
			// 3. Click outside of the menu to close it.
			//    JavaScript error appears
			// ------------------------------------------------------------------------------------
			isVisible: function () {
				return this._.panel && this._.panel.isVisible && this._.panel.isVisible();
			}
		}
	});

	function sortItems( items ) {
		items.sort( function( itemA, itemB ) {
			if ( itemA.group < itemB.group )
				return -1;
			else if ( itemA.group > itemB.group )
				return 1;

			return itemA.order < itemB.order ? -1 : itemA.order > itemB.order ? 1 : 0;
		});
	}

	/**
	 * @class
	 * @todo
	 */
	CKEDITOR.menuItem = CKEDITOR.tools.createClass({
		$: function( editor, name, definition ) {
			CKEDITOR.tools.extend( this, definition,
			// Defaults
			{
				order: 0,
				className: 'cke_menubutton__' + name
			});

			// Transform the group name into its order number.
			this.group = editor._.menuGroups[ this.group ];

			this.editor = editor;
			this.name = name;
		},

		proto: {
			render: function( menu, index, output ) {
				var id = menu.id + String( index ),
					state = ( typeof this.state == 'undefined' ) ? CKEDITOR.TRISTATE_OFF : this.state;

				var stateName = state == CKEDITOR.TRISTATE_ON ? 'on' : state == CKEDITOR.TRISTATE_DISABLED ? 'disabled' : 'off';

				var hasSubMenu = this.getItems;
				// ltr: BLACK LEFT-POINTING POINTER
				// rtl: BLACK RIGHT-POINTING POINTER
				var arrowLabel = '&#' + ( this.editor.lang.dir == 'rtl' ? '9668' : '9658' ) + ';';

				var iconName = this.name;
				if ( this.icon && !( /\./ ).test( this.icon ) )
					iconName = this.icon;

				var params = {
					id: id,
					name: this.name,
					iconName: iconName,
					label: this.label,
					cls: this.className || '',
					state: stateName,
					hasPopup: hasSubMenu ? 'true' : 'false',
					disabled: state == CKEDITOR.TRISTATE_DISABLED,
					title: this.label,
					href: 'javascript:void(\'' + ( this.label || '' ).replace( "'" + '' ) + '\')',
					hoverFn: menu._.itemOverFn,
					moveOutFn: menu._.itemOutFn,
					clickFn: menu._.itemClickFn,
					index: index,
					iconStyle: CKEDITOR.skin.getIconStyle( iconName, ( this.editor.lang.dir == 'rtl' ), iconName == this.icon ? null : this.icon, this.iconOffset ),
					arrowHtml: hasSubMenu ? menuArrowTpl.output({ label: arrowLabel } ) : ''
				};

				menuItemTpl.output( params, output );
			}
		}
	});

})();


/**
 * The amount of time, in milliseconds, the editor waits before displaying submenu
 * options when moving the mouse over options that contain submenus, like the
 * "Cell Properties" entry for tables.
 *
 *		// Remove the submenu delay.
 *		config.menu_subMenuDelay = 0;
 *
 * @cfg {Number} [menu_subMenuDelay=400]
 * @member CKEDITOR.config
 */

/**
 * Fired when a menu is shown.
 *
 * @event menuShow
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param {CKEDITOR.ui.panel[]} data
 */

/**
 * A comma separated list of items group names to be displayed in the context
 * menu. The order of items will reflect the order specified in this list if
 * no priority was defined in the groups.
 *
 *		config.menu_groups = 'clipboard,table,anchor,link,image';
 *
 * @cfg {String} [menu_groups=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.menu_groups = 'clipboard,' +
	'form,' +
	'tablecell,tablecellproperties,tablerow,tablecolumn,table,' +
	'anchor,link,image,flash,' +
	'checkbox,radio,textfield,hiddenfield,imagebutton,button,select,textarea,div';

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'contextmenu', {
	requires: 'menu',
	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%

	// Make sure the base class (CKEDITOR.menu) is loaded before it (#3318).
	onLoad: function() {
		CKEDITOR.plugins.contextMenu = CKEDITOR.tools.createClass({
			base: CKEDITOR.menu,

			$: function( editor ) {
				this.base.call( this, editor, {
					panel: {
						className: 'cke_menu_panel',
						attributes: {
							'aria-label': editor.lang.contextmenu.options
						}
					}
				});
			},

			proto: {
				addTarget: function( element, nativeContextMenuOnCtrl ) {
					// Opera doesn't support 'contextmenu' event, we have duo approaches employed here:
					// 1. Inherit the 'button override' hack we introduced in v2 (#4530), while this require the Opera browser
					//  option 'Allow script to detect context menu/right click events' to be always turned on.
					// 2. Considering the fact that ctrl/meta key is not been occupied
					//  for multiple range selecting (like Gecko), we use this key
					//  combination as a fallback for triggering context-menu. (#4530)
					if ( CKEDITOR.env.opera && !( 'oncontextmenu' in document.body ) ) {
						var contextMenuOverrideButton;
						element.on( 'mousedown', function( evt ) {
							evt = evt.data;
							if ( evt.$.button != 2 ) {
								if ( evt.getKeystroke() == CKEDITOR.CTRL + 1 )
									element.fire( 'contextmenu', evt );
								return;
							}

							if ( nativeContextMenuOnCtrl && ( CKEDITOR.env.mac ? evt.$.metaKey : evt.$.ctrlKey ) )
								return;

							var target = evt.getTarget();

							if ( !contextMenuOverrideButton ) {
								var ownerDoc = target.getDocument();
								contextMenuOverrideButton = ownerDoc.createElement( 'input' );
								contextMenuOverrideButton.$.type = 'button';
								ownerDoc.getBody().append( contextMenuOverrideButton );
							}

							contextMenuOverrideButton.setAttribute( 'style', 'position:absolute;top:' + ( evt.$.clientY - 2 ) +
								'px;left:' + ( evt.$.clientX - 2 ) +
								'px;width:5px;height:5px;opacity:0.01' );

						});

						element.on( 'mouseup', function( evt ) {
							if ( contextMenuOverrideButton ) {
								contextMenuOverrideButton.remove();
								contextMenuOverrideButton = undefined;
								// Simulate 'contextmenu' event.
								element.fire( 'contextmenu', evt.data );
							}
						});
					}

					element.on( 'contextmenu', function( event ) {
						var domEvent = event.data;

						if ( nativeContextMenuOnCtrl &&
						// Safari on Windows always show 'ctrlKey' as true in 'contextmenu' event,
						// which make this property unreliable. (#4826)
						( CKEDITOR.env.webkit ? holdCtrlKey : ( CKEDITOR.env.mac ? domEvent.$.metaKey : domEvent.$.ctrlKey ) ) )
							return;


						// Cancel the browser context menu.
						domEvent.preventDefault();

						var doc = domEvent.getTarget().getDocument(),
							offsetParent = domEvent.getTarget().getDocument().getDocumentElement(),
							fromFrame = !doc.equals( CKEDITOR.document ),
							scroll = doc.getWindow().getScrollPosition(),
							offsetX = fromFrame ? domEvent.$.clientX : domEvent.$.pageX || scroll.x + domEvent.$.clientX,
							offsetY = fromFrame ? domEvent.$.clientY : domEvent.$.pageY || scroll.y + domEvent.$.clientY;

						CKEDITOR.tools.setTimeout( function() {
							this.open( offsetParent, null, offsetX, offsetY );

							// IE needs a short while to allow selection change before opening menu. (#7908)
						}, CKEDITOR.env.ie ? 200 : 0, this );
					}, this );

					if ( CKEDITOR.env.opera ) {
						// 'contextmenu' event triggered by Windows menu key is unpreventable,
						// cancel the key event itself. (#6534)
						element.on( 'keypress', function( evt ) {
							var domEvent = evt.data;

							if ( domEvent.$.keyCode === 0 )
								domEvent.preventDefault();
						});
					}

					if ( CKEDITOR.env.webkit ) {
						var holdCtrlKey,
							onKeyDown = function( event ) {
								holdCtrlKey = CKEDITOR.env.mac ? event.data.$.metaKey : event.data.$.ctrlKey;
							},
							resetOnKeyUp = function() {
								holdCtrlKey = 0;
							};

						element.on( 'keydown', onKeyDown );
						element.on( 'keyup', resetOnKeyUp );
						element.on( 'contextmenu', resetOnKeyUp );
					}
				},

				open: function( offsetParent, corner, offsetX, offsetY ) {
					this.editor.focus();
					offsetParent = offsetParent || CKEDITOR.document.getDocumentElement();

					// #9362: Force selection check to update commands' states in the new context.
					this.editor.selectionChange( 1 );

					this.show( offsetParent, corner, offsetX, offsetY );

					// ------------------------------------------------------------------------------------
					// ***DYNAMIC DOCUMENTATION CHANGE***
					// What Changed:  Save bookmarks at the current selection so that we can restore the
					//                current selection later
					//
					// See companion changes in menu/plugin.js
					// ------------------------------------------------------------------------------------
					var selection = this.editor.getSelection();
					if ( selection ) {
						this.editor._.bookmarksBeforeMenu = selection.createBookmarks2();
						this.editor._.scrollTopBeforeMenu = this.editor.editable().$.scrollTop;
					}
				}
			}
		});
	},

	beforeInit: function( editor ) {
		var contextMenu = editor.contextMenu = new CKEDITOR.plugins.contextMenu( editor );

		editor.on( 'contentDom', function() {
			contextMenu.addTarget( editor.editable(), editor.config.browserContextMenuOnCtrl !== false );
		});

		editor.addCommand( 'contextMenu', {
			exec: function() {
				editor.contextMenu.open( editor.document.getBody() );
			}
		});

		editor.setKeystroke( CKEDITOR.SHIFT + 121 /*F10*/, 'contextMenu' );
		editor.setKeystroke( CKEDITOR.CTRL + CKEDITOR.SHIFT + 121 /*F10*/, 'contextMenu' );
	}
});

/**
 * Whether to show the browser native context menu when the *Ctrl* or
 * *Meta* (Mac) key is pressed on opening the context menu with the
 * right mouse button click or the *Menu* key.
 *
 *		config.browserContextMenuOnCtrl = false;
 *
 * @since 3.0.2
 * @cfg {Boolean} [browserContextMenuOnCtrl=true]
 * @member CKEDITOR.config
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "toolbar" plugin. Renders the default toolbar interface in
 * the editor.
 */

(function() {
	var toolbox = function() {
			this.toolbars = [];
			this.focusCommandExecuted = false;
		};

	toolbox.prototype.focus = function() {
		for ( var t = 0, toolbar; toolbar = this.toolbars[ t++ ]; ) {
			for ( var i = 0, item; item = toolbar.items[ i++ ]; ) {
				if ( item.focus ) {
					item.focus();
					return;
				}
			}
		}
	};

	var commands = {
		toolbarFocus: {
			modes: { wysiwyg:1,source:1 },
			readOnly: 1,

			exec: function( editor ) {
				if ( editor.toolbox ) {
					editor.toolbox.focusCommandExecuted = true;

					// Make the first button focus accessible for IE. (#3417)
					// Adobe AIR instead need while of delay.
					if ( CKEDITOR.env.ie || CKEDITOR.env.air )
						setTimeout( function() {
						editor.toolbox.focus();
					}, 100 );
					else
						editor.toolbox.focus();
				}
			}
		}
	};

	CKEDITOR.plugins.add( 'toolbar', {
		requires: 'button',
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%

		init: function( editor ) {
			var endFlag;

			var itemKeystroke = function( item, keystroke ) {
					var next, toolbar;
					var rtl = editor.lang.dir == 'rtl',
						toolbarGroupCycling = editor.config.toolbarGroupCycling;

					toolbarGroupCycling = toolbarGroupCycling === undefined || toolbarGroupCycling;

					switch ( keystroke ) {
						case 9: // TAB
						case CKEDITOR.SHIFT + 9: // SHIFT + TAB
							// Cycle through the toolbars, starting from the one
							// closest to the current item.
							while ( !toolbar || !toolbar.items.length ) {
								toolbar = keystroke == 9 ? ( ( toolbar ? toolbar.next : item.toolbar.next ) || editor.toolbox.toolbars[ 0 ] ) : ( ( toolbar ? toolbar.previous : item.toolbar.previous ) || editor.toolbox.toolbars[ editor.toolbox.toolbars.length - 1 ] );

								// Look for the first item that accepts focus.
								if ( toolbar.items.length ) {
									item = toolbar.items[ endFlag ? ( toolbar.items.length - 1 ) : 0 ];
									while ( item && !item.focus ) {
										item = endFlag ? item.previous : item.next;

										if ( !item )
											toolbar = 0;
									}
								}
							}

							if ( item )
								item.focus();

							return false;

						case rtl ? 37:
							39 : // RIGHT-ARROW
						case 40: // DOWN-ARROW
							next = item;
							do {
								// Look for the next item in the toolbar.
								next = next.next;

								// If it's the last item, cycle to the first one.
								if ( !next && toolbarGroupCycling ) next = item.toolbar.items[ 0 ];
							}
							while ( next && !next.focus )

							// If available, just focus it, otherwise focus the
							// first one.
							if ( next )
								next.focus();
							else
								// Send a TAB.
								itemKeystroke( item, 9 );

							return false;

						case rtl ? 39:
							37 : // LEFT-ARROW
						case 38: // UP-ARROW
							next = item;
							do {
								// Look for the previous item in the toolbar.
								next = next.previous;

								// If it's the first item, cycle to the last one.
								if ( !next && toolbarGroupCycling ) next = item.toolbar.items[ item.toolbar.items.length - 1 ];
							}
							while ( next && !next.focus )

							// If available, just focus it, otherwise focus the
							// last one.
							if ( next )
								next.focus();
							else {
								endFlag = 1;
								// Send a SHIFT + TAB.
								itemKeystroke( item, CKEDITOR.SHIFT + 9 );
								endFlag = 0;
							}

							return false;

						case 27: // ESC
							editor.focus();
							return false;

						case 13: // ENTER
						case 32: // SPACE
							item.execute();
							return false;
					}
					return true;
				};

			editor.on( 'uiSpace', function( event ) {
				if ( event.data.space != editor.config.toolbarLocation )
					return;

				// Create toolbar only once.
				event.removeListener();

				editor.toolbox = new toolbox();

				var labelId = CKEDITOR.tools.getNextId();

				var output = [
					'<span id="', labelId, '" class="cke_voice_label">', editor.lang.toolbar.toolbars, '</span>',
					'<span id="' + editor.ui.spaceId( 'toolbox' ) + '" class="cke_toolbox" role="group" aria-labelledby="', labelId, '" onmousedown="return false;">' ];

				var expanded = editor.config.toolbarStartupExpanded !== false,
					groupStarted, pendingSeparator;

				// If the toolbar collapser will be available, we'll have
				// an additional container for all toolbars.
				if ( editor.config.toolbarCanCollapse && editor.elementMode != CKEDITOR.ELEMENT_MODE_INLINE )
					output.push( '<span class="cke_toolbox_main"' + ( expanded ? '>' : ' style="display:none">' ) );

				var toolbars = editor.toolbox.toolbars,
					toolbar = getToolbarConfig( editor );

				for ( var r = 0; r < toolbar.length; r++ ) {
					var toolbarId,
						toolbarObj = 0,
						toolbarName,
						row = toolbar[ r ],
						items;

					// It's better to check if the row object is really
					// available because it's a common mistake to leave
					// an extra comma in the toolbar definition
					// settings, which leads on the editor not loading
					// at all in IE. (#3983)
					if ( !row )
						continue;

					if ( groupStarted ) {
						output.push( '</span>' );
						groupStarted = 0;
						pendingSeparator = 0;
					}

					if ( row === '/' ) {
						output.push( '<span class="cke_toolbar_break"></span>' );
						continue;
					}

					items = row.items || row;

					// Create all items defined for this toolbar.
					for ( var i = 0; i < items.length; i++ ) {
						var item = items[ i ],
							canGroup;

						if ( item ) {
							if ( item.type == CKEDITOR.UI_SEPARATOR ) {
								// Do not add the separator immediately. Just save
								// it be included if we already have something in
								// the toolbar and if a new item is to be added (later).
								pendingSeparator = groupStarted && item;
								continue;
							}

							canGroup = item.canGroup !== false;

							// Initialize the toolbar first, if needed.
							if ( !toolbarObj ) {
								// Create the basic toolbar object.
								toolbarId = CKEDITOR.tools.getNextId();
								toolbarObj = { id: toolbarId, items: [] };
								toolbarName = row.name && ( editor.lang.toolbar.toolbarGroups[ row.name ] || row.name );

								// Output the toolbar opener.
								output.push( '<span id="', toolbarId, '" class="cke_toolbar"', ( toolbarName ? ' aria-labelledby="' + toolbarId + '_label"' : '' ), ' role="toolbar">' );

								// If a toolbar name is available, send the voice label.
								toolbarName && output.push( '<span id="', toolbarId, '_label" class="cke_voice_label">', toolbarName, '</span>' );

								output.push( '<span class="cke_toolbar_start"></span>' );

								// Add the toolbar to the "editor.toolbox.toolbars"
								// array.
								var index = toolbars.push( toolbarObj ) - 1;

								// Create the next/previous reference.
								if ( index > 0 ) {
									toolbarObj.previous = toolbars[ index - 1 ];
									toolbarObj.previous.next = toolbarObj;
								}
							}

							if ( canGroup ) {
								if ( !groupStarted ) {
									output.push( '<span class="cke_toolgroup" role="presentation">' );
									groupStarted = 1;
								}
							} else if ( groupStarted ) {
								output.push( '</span>' );
								groupStarted = 0;
							}

							function addItem( item ) {
								var itemObj = item.render( editor, output );
								index = toolbarObj.items.push( itemObj ) - 1;

								if ( index > 0 ) {
									itemObj.previous = toolbarObj.items[ index - 1 ];
									itemObj.previous.next = itemObj;
								}

								itemObj.toolbar = toolbarObj;
								itemObj.onkey = itemKeystroke;

								// Fix for #3052:
								// Prevent JAWS from focusing the toolbar after document load.
								itemObj.onfocus = function() {
									if ( !editor.toolbox.focusCommandExecuted )
										editor.focus();
								};
							}

							if ( pendingSeparator ) {
								addItem( pendingSeparator );
								pendingSeparator = 0;
							}

							addItem( item );
						}
					}

					if ( groupStarted ) {
						output.push( '</span>' );
						groupStarted = 0;
						pendingSeparator = 0;
					}

					if ( toolbarObj )
						output.push( '<span class="cke_toolbar_end"></span></span>' );
				}

				if ( editor.config.toolbarCanCollapse )
					output.push( '</span>' );

				// Not toolbar collapser for inline mode.
				if ( editor.config.toolbarCanCollapse && editor.elementMode != CKEDITOR.ELEMENT_MODE_INLINE ) {
					var collapserFn = CKEDITOR.tools.addFunction( function() {
						editor.execCommand( 'toolbarCollapse' );
					});

					editor.on( 'destroy', function() {
						CKEDITOR.tools.removeFunction( collapserFn );
					});

					editor.addCommand( 'toolbarCollapse', {
						readOnly: 1,
						exec: function( editor ) {
							var collapser = editor.ui.space( 'toolbar_collapser' ),
								toolbox = collapser.getPrevious(),
								contents = editor.ui.space( 'contents' ),
								toolboxContainer = toolbox.getParent(),
								contentHeight = parseInt( contents.$.style.height, 10 ),
								previousHeight = toolboxContainer.$.offsetHeight,
								minClass = 'cke_toolbox_collapser_min',
								collapsed = collapser.hasClass( minClass );

							if ( !collapsed ) {
								toolbox.hide();
								collapser.addClass( minClass );
								collapser.setAttribute( 'title', editor.lang.toolbar.toolbarExpand );
							} else {
								toolbox.show();
								collapser.removeClass( minClass );
								collapser.setAttribute( 'title', editor.lang.toolbar.toolbarCollapse );
							}

							// Update collapser symbol.
							collapser.getFirst().setText( collapsed ? '\u25B2' : // BLACK UP-POINTING TRIANGLE
							'\u25C0' ); // BLACK LEFT-POINTING TRIANGLE

							var dy = toolboxContainer.$.offsetHeight - previousHeight;
							contents.setStyle( 'height', ( contentHeight - dy ) + 'px' );

							editor.fire( 'resize' );
						},

						modes: { wysiwyg:1,source:1 }
					});

					editor.setKeystroke( CKEDITOR.ALT + ( CKEDITOR.env.ie || CKEDITOR.env.webkit ? 189 : 109 ) /*-*/, 'toolbarCollapse' );

					output.push( '<a title="' + ( expanded ? editor.lang.toolbar.toolbarCollapse : editor.lang.toolbar.toolbarExpand )
						+ '" id="' + editor.ui.spaceId( 'toolbar_collapser' )
						+ '" tabIndex="-1" class="cke_toolbox_collapser' );

					if ( !expanded )
						output.push( ' cke_toolbox_collapser_min' );

					output.push( '" onclick="CKEDITOR.tools.callFunction(' + collapserFn + ')">', '<span class="cke_arrow">&#9650;</span>', // BLACK UP-POINTING TRIANGLE
						'</a>' );
				}

				output.push( '</span>' );
				event.data.html += output.join( '' );
			});

			editor.on( 'destroy', function() {

				if ( this.toolbox )
				{
					var toolbars,
						index = 0,
						i, items, instance;
					toolbars = this.toolbox.toolbars;
					for ( ; index < toolbars.length; index++ ) {
						items = toolbars[ index ].items;
						for ( i = 0; i < items.length; i++ ) {
							instance = items[ i ];
							if ( instance.clickFn )
								CKEDITOR.tools.removeFunction( instance.clickFn );
							if ( instance.keyDownFn )
								CKEDITOR.tools.removeFunction( instance.keyDownFn );
						}
					}
				}
			});

			// Manage editor focus  when navigating the toolbar.
			editor.on( 'uiReady', function() {
				var toolbox = editor.ui.space( 'toolbox' );
				toolbox && editor.focusManager.add( toolbox, 1 );
			});

			editor.addCommand( 'toolbarFocus', commands.toolbarFocus );
			editor.setKeystroke( CKEDITOR.ALT + 121 /*F10*/, 'toolbarFocus' );

			editor.ui.add( '-', CKEDITOR.UI_SEPARATOR, {} );
			editor.ui.addHandler( CKEDITOR.UI_SEPARATOR, {
				create: function() {
					return {
						render: function( editor, output ) {
							output.push( '<span class="cke_toolbar_separator" role="separator"></span>' );
							return {};
						}
					};
				}
			});
		}
	});

	function getToolbarConfig( editor ) {
		var removeButtons = editor.config.removeButtons;

		removeButtons = removeButtons && removeButtons.split( ',' );

		function buildToolbarConfig() {

			// Object containing all toolbar groups used by ui items.
			var lookup = getItemDefinedGroups();

			// Take the base for the new toolbar, which is basically a toolbar
			// definition without items.
			var toolbar = CKEDITOR.tools.clone( editor.config.toolbarGroups ) || getPrivateToolbarGroups( editor );

			// Fill the toolbar groups with the available ui items.
			for ( var i = 0; i < toolbar.length; i++ ) {
				var toolbarGroup = toolbar[ i ];

				// Skip toolbar break.
				if ( toolbarGroup == '/' )
					continue;
				// Handle simply group name item.
				else if ( typeof toolbarGroup == 'string' )
					toolbarGroup = toolbar[ i ] = { name: toolbarGroup };

				var items, subGroups = toolbarGroup.groups;

				// Look for items that match sub groups.
				if ( subGroups ) {
					for ( var j = 0, sub; j < subGroups.length; j++ ) {
						sub = subGroups[ j ];

						// If any ui item is registered for this subgroup.
						items = lookup[ sub ];
						items && fillGroup( toolbarGroup, items );
					}
				}

				// Add the main group items as well.
				items = lookup[ toolbarGroup.name ];
				items && fillGroup( toolbarGroup, items );
			}

			return toolbar;
		}

		// Returns an object containing all toolbar groups used by ui items.
		function getItemDefinedGroups() {
			var groups = {},
				itemName, item, itemToolbar, group, order;

			for ( itemName in editor.ui.items ) {
				item = editor.ui.items[ itemName ];
				itemToolbar = item.toolbar || 'others';
				if ( itemToolbar ) {
					// Break the toolbar property into its parts: "group_name[,order]".
					itemToolbar = itemToolbar.split( ',' );
					group = itemToolbar[ 0 ];
					order = parseInt( itemToolbar[ 1 ] || -1, 10 );

					// Initialize the group, if necessary.
					groups[ group ] || ( groups[ group ] = [] );

					// Push the data used to build the toolbar later.
					groups[ group ].push( { name: itemName, order: order} );
				}
			}

			// Put the items in the right order.
			for ( group in groups ) {
				groups[ group ] = groups[ group ].sort( function( a, b ) {
					return a.order == b.order ? 0 :
						b.order < 0 ? -1 :
						a.order < 0 ? 1 :
						a.order < b.order ? -1 :
						1;
				});
			}

			return groups;
		}

		function fillGroup( toolbarGroup, uiItems ) {
			if ( uiItems.length ) {
				if ( toolbarGroup.items )
					toolbarGroup.items.push( editor.ui.create( '-' ) );
				else
					toolbarGroup.items = [];

				var item, name;
				while ( ( item = uiItems.shift() ) ) {
					name = typeof item == 'string' ? item : item.name;

					// Ignore items that are configured to be removed.
					if ( !removeButtons || CKEDITOR.tools.indexOf( removeButtons, name ) == -1 ) {
						item = editor.ui.create( name );

						if ( !item )
							continue;

						if ( !editor.addFeature( item ) )
							continue;

						toolbarGroup.items.push( item );
					}
				}
			}
		}

		function populateToolbarConfig( config ) {
			var toolbar = [],
				i, group, newGroup;

			for ( i = 0; i < config.length; ++i ) {
				group = config[ i ];
				newGroup = {};

				if ( group == '/' )
					toolbar.push( group );
				else if ( CKEDITOR.tools.isArray( group) ) {
					fillGroup( newGroup, CKEDITOR.tools.clone( group ) );
					toolbar.push( newGroup );
				}
				else if ( group.items ) {
					fillGroup( newGroup, CKEDITOR.tools.clone( group.items ) );
					newGroup.name = group.name;
					toolbar.push( newGroup);
				}
			}

			return toolbar;
		}

		var toolbar = editor.config.toolbar;

		// If it is a string, return the relative "toolbar_name" config.
		if ( typeof toolbar == 'string' )
			toolbar = editor.config[ 'toolbar_' + toolbar ];

		return ( editor.toolbar = toolbar ? populateToolbarConfig( toolbar ) : buildToolbarConfig() );
	}

	/**
	 * Add toolbar group. See {@link CKEDITOR.config#toolbarGroups} for more details.
	 *
	 * **Note:** This method won't modify toolbar groups set explicitly by
	 * {@link CKEDITOR.config#toolbarGroups}. It will extend only default setting.
	 *
	 * @param {String} name Group name.
	 * @param {Number/String} previous Name of group after which this one
	 * should be added or `0` if this group should be the first one.
	 * @param {String} [subgroupOf] Name of parent group.
	 * @member CKEDITOR.ui
	 */
	CKEDITOR.ui.prototype.addToolbarGroup = function( name, previous, subgroupOf ) {
		// The toolbarGroups from the privates is the one we gonna use for automatic toolbar creation.
		var toolbarGroups = getPrivateToolbarGroups( this.editor ),
			atStart = previous === 0,
			newGroup = { name: name };

		if ( subgroupOf ) {
			// Transform the subgroupOf name in the real subgroup object.
			subgroupOf = CKEDITOR.tools.search( toolbarGroups, function( group ) {
				return group.name == subgroupOf;
			});

			if ( subgroupOf ) {
				!subgroupOf.groups && ( subgroupOf.groups = [] ) ;

				if ( previous ) {
					// Search the "previous" item and add the new one after it.
					previous = CKEDITOR.tools.indexOf( subgroupOf.groups, previous );
					if ( previous >= 0 ) {
						subgroupOf.groups.splice( previous + 1, 0, name );
						return;
					}
				}

				// If no previous found.

				if ( atStart )
					subgroupOf.groups.splice( 0, 0, name );
				else
					subgroupOf.groups.push(  name );
				return;
			} else {
				// Ignore "previous" if subgroupOf has not been found.
				previous = null;
			}
		}

		if ( previous ) {
			// Transform the "previous" name into its index.
			previous = CKEDITOR.tools.indexOf( toolbarGroups, function( group ) {
				return group.name == previous;
			});
		}

		if ( atStart )
			toolbarGroups.splice( 0, 0, name );
		else if ( typeof previous == 'number' )
			toolbarGroups.splice( previous + 1, 0, newGroup );
		else
			toolbarGroups.push( name );
	};

	function getPrivateToolbarGroups( editor ) {
		return editor._.toolbarGroups || ( editor._.toolbarGroups = [
			{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },
			{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },
			{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },
			{ name: 'forms' },
			'/',
			{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },
			{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align' ] },
			{ name: 'links' },
			{ name: 'insert' },
			'/',
			{ name: 'styles' },
			{ name: 'colors' },
			{ name: 'tools' },
			{ name: 'others' },
			{ name: 'about' }
		]);
	}
})();

/**
 * Separator UI element.
 *
 * @readonly
 * @property {String} [='separator']
 * @member CKEDITOR
 */
CKEDITOR.UI_SEPARATOR = 'separator';

/**
 * The "UI space" to which rendering the toolbar. For the default editor implementation,
 * the recommended options are `'top'` and `'bottom'`.
 *
 *		config.toolbarLocation = 'bottom';
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.toolbarLocation = 'top';

/**
 * The toolbox (alias toolbar) definition. It is a toolbar name or an array of
 * toolbars (strips), each one being also an array, containing a list of UI items.
 *
 * If set to `null`, generate toolbar automatically using all available buttons
 * and {@link #toolbarGroups} as a toolbar groups layout.
 *
 *		// Defines a toolbar with only one strip containing the "Source" button, a
 *		// separator and the "Bold" and "Italic" buttons.
 *		config.toolbar = [
 *			[ 'Source', '-', 'Bold', 'Italic' ]
 *		];
 *
 *		// Similar to example the above, defines a "Basic" toolbar with only one strip containing three buttons.
 *		// Note that this setting is composed by "toolbar_" added by the toolbar name, which in this case is called "Basic".
 *		// This second part of the setting name can be anything. You must use this name in the CKEDITOR.config.toolbar setting,
 *		// so you instruct the editor which toolbar_(name) setting to use.
 *		config.toolbar_Basic = [
 *			[ 'Source', '-', 'Bold', 'Italic' ]
 *		];
 *		// Load toolbar_Name where Name = Basic.
 *		config.toolbar = 'Basic';
 *
 * @cfg {Array/String} [toolbar=null]
 * @member CKEDITOR.config
 */

/**
 * The toolbar groups definition.
 *
 * If toolbar layout isn't explicitly defined by {@link #toolbar} setting, then
 * this setting is used to group all defined buttons (see {@link CKEDITOR.ui#addButton}).
 * Buttons are associated with toolbar groups by `toolbar` property in their definition objects.
 *
 * New groups may be dynamically added during the editor and plugins initialization by
 * {@link CKEDITOR.ui#addToolbarGroup}. Although only if default setting was used.
 *
 *		// Default setting.
 *		config.toolbarGroups = [
 *			{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },
 *			{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },
 *			{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },
 *			{ name: 'forms' },
 *			'/',
 *			{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },
 *			{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align' ] },
 *			{ name: 'links' },
 *			{ name: 'insert' },
 *			'/',
 *			{ name: 'styles' },
 *			{ name: 'colors' },
 *			{ name: 'tools' },
 *			{ name: 'others' },
 *			{ name: 'about' }
 *		];
 *
 * @cfg {Array} [toolbarGroups=see example]
 * @member CKEDITOR.config
 */

/**
 * Whether the toolbar can be collapsed by the user. If disabled, the collapser
 * button will not be displayed.
 *
 *		config.toolbarCanCollapse = true;
 *
 * @cfg {Boolean} [toolbarCanCollapse=false]
 * @member CKEDITOR.config
 */

/**
 * Whether the toolbar must start expanded when the editor is loaded.
 *
 * Setting this option to `false` will affect toolbar only when
 * {@link #toolbarCanCollapse} is set to `true`:
 *
 *		config.toolbarCanCollapse = true;
 *		config.toolbarStartupExpanded = false;
 *
 * @cfg {Boolean} [toolbarStartupExpanded=true]
 * @member CKEDITOR.config
 */

/**
 * When enabled, makes the arrow keys navigation cycle within the current
 * toolbar group. Otherwise the arrows will move through all items available in
 * the toolbar. The *TAB* key will still be used to quickly jump among the
 * toolbar groups.
 *
 *		config.toolbarGroupCycling = false;
 *
 * @since 3.6
 * @cfg {Boolean} [toolbarGroupCycling=true]
 * @member CKEDITOR.config
 */

/**
 * List of toolbar button names that must not be rendered. This will work as
 * well for non-button toolbar items, like the Font combos.
 *
 *		config.removeButtons = 'Underline,JustifyCenter';
 *
 * This configuration should not be overused, having
 * {@link CKEDITOR.config#removePlugins} removing features from the editor. In
 * some cases though, a single plugin may define a set of toolbar buttons and
 * removeButtons may be useful when just a few of them are to be removed.
 *
 * @cfg {String} [removeButtons]
 * @member CKEDITOR.config
 */

/**
 * Toolbar definition used by the editor. It is crated from the
 * {@link CKEDITOR.config#toolbar} if it is set or automatically
 * based on {@link CKEDITOR.config#toolbarGroups}.
 *
 * @property {Object} toolbar
 * @member CKEDITOR.editor
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

(function() {
	CKEDITOR.plugins.add( 'enterkey', {
		// TODO: should not depend on a particular format plugin.
		requires: 'indent',

		init: function( editor ) {
			editor.addCommand( 'enter', { modes:{wysiwyg:1 },
				editorFocus: false,
				exec: function( editor ) {
					enter( editor );
				}
			});

			editor.addCommand( 'shiftEnter', { modes:{wysiwyg:1 },
				editorFocus: false,
				exec: function( editor ) {
					shiftEnter( editor );
				}
			});

			editor.setKeystroke( [
				[ 13, 'enter' ],
				[ CKEDITOR.SHIFT + 13, 'shiftEnter' ]
				] );
		}
	});

	var whitespaces = CKEDITOR.dom.walker.whitespaces(),
		bookmark = CKEDITOR.dom.walker.bookmark();

	CKEDITOR.plugins.enterkey = {
		enterBlock: function( editor, mode, range, forceMode ) {
			// Get the range for the current selection.
			range = range || getRange( editor );

			// We may not have valid ranges to work on, like when inside a
			// contenteditable=false element.
			if ( !range )
				return;

			var doc = range.document;

			var atBlockStart = range.checkStartOfBlock(),
				atBlockEnd = range.checkEndOfBlock(),
				path = editor.elementPath( range.startContainer ),
				block = path.block;

			// Exit the list when we're inside an empty list item block. (#5376)
			if ( atBlockStart && atBlockEnd ) {
				// Exit the list when we're inside an empty list item block. (#5376)
				if ( block && ( block.is( 'li' ) || block.getParent().is( 'li' ) ) ) {
					editor.execCommand( 'outdent' );
					return;
				}

				if ( block && block.getParent().is( 'blockquote' ) ) {
					block.breakParent( block.getParent() );

					// If we were at the start of <blockquote>, there will be an empty element before it now.
					if ( !block.getPrevious().getFirst( CKEDITOR.dom.walker.invisible( 1 ) ) )
						block.getPrevious().remove();

					// If we were at the end of <blockquote>, there will be an empty element after it now.
					if ( !block.getNext().getFirst( CKEDITOR.dom.walker.invisible( 1 ) ) )
						block.getNext().remove();

					range.moveToElementEditStart( block );
					range.select();
					return;
				}
			}
			// Don't split <pre> if we're in the middle of it, act as shift enter key.
			else if ( block && block.is( 'pre' ) ) {
				if ( !atBlockEnd ) {
					enterBr( editor, mode, range, forceMode );
					return;
				}
			}

			// Determine the block element to be used.
			var blockTag = ( mode == CKEDITOR.ENTER_DIV ? 'div' : 'p' );

			// Split the range.
			var splitInfo = range.splitBlock( blockTag );

			if ( !splitInfo )
				return;

			// Get the current blocks.
			var previousBlock = splitInfo.previousBlock,
				nextBlock = splitInfo.nextBlock;

			var isStartOfBlock = splitInfo.wasStartOfBlock,
				isEndOfBlock = splitInfo.wasEndOfBlock;

			var node;

			// If this is a block under a list item, split it as well. (#1647)
			if ( nextBlock ) {
				node = nextBlock.getParent();
				if ( node.is( 'li' ) ) {
					nextBlock.breakParent( node );
					nextBlock.move( nextBlock.getNext(), 1 );
				}
			} else if ( previousBlock && ( node = previousBlock.getParent() ) && node.is( 'li' ) ) {
				previousBlock.breakParent( node );
				node = previousBlock.getNext();
				range.moveToElementEditStart( node );
				previousBlock.move( previousBlock.getPrevious() );
			}

			// If we have both the previous and next blocks, it means that the
			// boundaries were on separated blocks, or none of them where on the
			// block limits (start/end).
			if ( !isStartOfBlock && !isEndOfBlock ) {
				// If the next block is an <li> with another list tree as the first
				// child, we'll need to append a filler (<br>/NBSP) or the list item
				// wouldn't be editable. (#1420)
				if ( nextBlock.is( 'li' ) ) {
					var walkerRange = range.clone();
					walkerRange.selectNodeContents( nextBlock );
					var walker = new CKEDITOR.dom.walker( walkerRange );
					walker.evaluator = function( node ) {
						return !( bookmark( node ) || whitespaces( node ) || node.type == CKEDITOR.NODE_ELEMENT && node.getName() in CKEDITOR.dtd.$inline && !( node.getName() in CKEDITOR.dtd.$empty ) );
					};

					node = walker.next();
					if ( node && node.type == CKEDITOR.NODE_ELEMENT && node.is( 'ul', 'ol' ) ) {
						( CKEDITOR.env.ie ? doc.createText( '\xa0' ) : doc.createElement( 'br' ) ).insertBefore( node );
					}
				}

				// Move the selection to the end block.
				if ( nextBlock )
					range.moveToElementEditStart( nextBlock );
			} else {
				var newBlock, newBlockDir;

				if ( previousBlock ) {
					// Do not enter this block if it's a header tag, or we are in
					// a Shift+Enter (#77). Create a new block element instead
					// (later in the code).
					if ( previousBlock.is( 'li' ) || !( headerTagRegex.test( previousBlock.getName() ) || previousBlock.is( 'pre' ) ) ) {
						// Otherwise, duplicate the previous block.
						newBlock = previousBlock.clone();
					}
				} else if ( nextBlock )
					newBlock = nextBlock.clone();

				if ( !newBlock ) {
					// We have already created a new list item. (#6849)
					if ( node && node.is( 'li' ) )
						newBlock = node;
					else {
						newBlock = doc.createElement( blockTag );
						if ( previousBlock && ( newBlockDir = previousBlock.getDirection() ) )
							newBlock.setAttribute( 'dir', newBlockDir );
					}
				}
				// Force the enter block unless we're talking of a list item.
				else if ( forceMode && !newBlock.is( 'li' ) )
					newBlock.renameNode( blockTag );

				// Recreate the inline elements tree, which was available
				// before hitting enter, so the same styles will be available in
				// the new block.
				var elementPath = splitInfo.elementPath;
				if ( elementPath ) {
					for ( var i = 0, len = elementPath.elements.length; i < len; i++ ) {
						var element = elementPath.elements[ i ];

						if ( element.equals( elementPath.block ) || element.equals( elementPath.blockLimit ) )
							break;

						if ( CKEDITOR.dtd.$removeEmpty[ element.getName() ] ) {
							element = element.clone();
							newBlock.moveChildren( element );
							newBlock.append( element );
						}
					}
				}

				if ( !CKEDITOR.env.ie )
					newBlock.appendBogus();

				if ( !newBlock.getParent() )
					range.insertNode( newBlock );

				// list item start number should not be duplicated (#7330), but we need
				// to remove the attribute after it's onto the DOM tree because of old IEs (#7581).
				newBlock.is( 'li' ) && newBlock.removeAttribute( 'value' );

				// This is tricky, but to make the new block visible correctly
				// we must select it.
				// The previousBlock check has been included because it may be
				// empty if we have fixed a block-less space (like ENTER into an
				// empty table cell).
				if ( CKEDITOR.env.ie && isStartOfBlock && ( !isEndOfBlock || !previousBlock.getChildCount() ) ) {
					// Move the selection to the new block.
					range.moveToElementEditStart( isEndOfBlock ? previousBlock : newBlock );
					range.select();
				}

				// Move the selection to the new block.
				range.moveToElementEditStart( isStartOfBlock && !isEndOfBlock ? nextBlock : newBlock );
			}

			range.select();
			range.scrollIntoView();
		},

		enterBr: function( editor, mode, range, forceMode ) {
			// Get the range for the current selection.
			range = range || getRange( editor );

			// We may not have valid ranges to work on, like when inside a
			// contenteditable=false element.
			if ( !range )
				return;

			var doc = range.document;

			// Determine the block element to be used.
			var blockTag = ( mode == CKEDITOR.ENTER_DIV ? 'div' : 'p' );

			var isEndOfBlock = range.checkEndOfBlock();

			var elementPath = new CKEDITOR.dom.elementPath( editor.getSelection().getStartElement() );

			var startBlock = elementPath.block,
				startBlockTag = startBlock && elementPath.block.getName();

			var isPre = false;

			if ( !forceMode && startBlockTag == 'li' ) {
				enterBlock( editor, mode, range, forceMode );
				return;
			}

			// If we are at the end of a header block.
			if ( !forceMode && isEndOfBlock && headerTagRegex.test( startBlockTag ) ) {
				var newBlock, newBlockDir;

				if ( ( newBlockDir = startBlock.getDirection() ) ) {
					newBlock = doc.createElement( 'div' );
					newBlock.setAttribute( 'dir', newBlockDir );
					newBlock.insertAfter( startBlock );
					range.setStart( newBlock, 0 );
				} else {
					// Insert a <br> after the current paragraph.
					doc.createElement( 'br' ).insertAfter( startBlock );

					// A text node is required by Gecko only to make the cursor blink.
					if ( CKEDITOR.env.gecko )
						doc.createText( '' ).insertAfter( startBlock );

					// IE has different behaviors regarding position.
					range.setStartAt( startBlock.getNext(), CKEDITOR.env.ie ? CKEDITOR.POSITION_BEFORE_START : CKEDITOR.POSITION_AFTER_START );
				}
			} else {
				var lineBreak;

				// IE<8 prefers text node as line-break inside of <pre> (#4711).
				if ( startBlockTag == 'pre' && CKEDITOR.env.ie && CKEDITOR.env.version < 8 )
					lineBreak = doc.createText( '\r' );
				else
					lineBreak = doc.createElement( 'br' );

				range.deleteContents();
				range.insertNode( lineBreak );

				// IE has different behavior regarding position.
				if ( CKEDITOR.env.ie )
					range.setStartAt( lineBreak, CKEDITOR.POSITION_AFTER_END );
				else {
					// A text node is required by Gecko only to make the cursor blink.
					// We need some text inside of it, so the bogus <br> is properly
					// created.
					doc.createText( '\ufeff' ).insertAfter( lineBreak );

					// If we are at the end of a block, we must be sure the bogus node is available in that block.
					if ( isEndOfBlock )
						lineBreak.getParent().appendBogus();

					// Now we can remove the text node contents, so the caret doesn't
					// stop on it.
					lineBreak.getNext().$.nodeValue = '';

					range.setStartAt( lineBreak.getNext(), CKEDITOR.POSITION_AFTER_START );

				}
			}

			// This collapse guarantees the cursor will be blinking.
			range.collapse( true );

			range.select();
			range.scrollIntoView();
		}
	};

	var plugin = CKEDITOR.plugins.enterkey,
		enterBr = plugin.enterBr,
		enterBlock = plugin.enterBlock,
		headerTagRegex = /^h[1-6]$/;

	function shiftEnter( editor ) {
		// Only effective within document.
		if ( editor.mode != 'wysiwyg' )
			return false;

		// On SHIFT+ENTER:
		// 1. We want to enforce the mode to be respected, instead
		// of cloning the current block. (#77)
		return enter( editor, editor.config.shiftEnterMode, 1 );
	}

	function enter( editor, mode, forceMode ) {
		forceMode = editor.config.forceEnterMode || forceMode;

		// Only effective within document.
		if ( editor.mode != 'wysiwyg' )
			return false;

		// TODO:  Use CKE functions
		/* --------------------------------------------------------------------
		/*** DYNAMIC DOCUMENTATION CHANGE ***
		// What Changed: Return early if selection parentElement is not contenteditable
		// Testing Considerations: Modify authenticated document.  Select
		//     read-only text, then press enter.
		//--------------------------------------------------------------------*/
		var ieselection = editor.document.$.selection.createRange();
		if (ieselection.moveStart && ieselection.parentElement().isContentEditable == false)
			return false;

		if ( !mode )
			mode = editor.config.enterMode;

		// Check path block specialities:
		// 1. Cannot be a un-splittable element, e.g. table caption;
		// 2. Must not be the editable element itself. (blockless)
		var path = editor.elementPath();
		if ( !path.isContextFor( 'p' ) ) {
			mode = CKEDITOR.ENTER_BR;
			forceMode = 1;
		}

		editor.fire( 'saveSnapshot' ); // Save undo step.

		if ( mode == CKEDITOR.ENTER_BR )
			enterBr( editor, mode, null, forceMode );
		else
			enterBlock( editor, mode, null, forceMode );

		editor.fire( 'saveSnapshot' );

		return true;
	}

	function getRange(editor) {
		// ------------------------------------------------------------------------------------
		// ***DYNAMIC DOCUMENTATION CHANGE***
		// What Changed: Check for null selection before calling getRanges
		// Test Considerations:
		// 1. Delete EMR content item
		// 2. Without clicking, press the enter key
		// Error appears at the `.getRanges` call because getSelection returns null
		// ---------------------------------------------------------------------
		// Get the selection ranges.
		var selection = editor.getSelection();
		if (!selection)
			return null;

		// Get the selection ranges.
		var ranges = selection.getRanges(true);

		// Delete the contents of all ranges except the first one.
		for ( var i = ranges.length - 1; i > 0; i-- ) {
			ranges[ i ].deleteContents();
		}

		// Return the first range.
		return ranges[ 0 ];
	}
})();

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'listblock', {
	requires: 'panel',

	onLoad: function() {
		var list = CKEDITOR.addTemplate( 'panel-list', '<ul role="presentation" class="cke_panel_list">{items}</ul>' ),
			listItem = CKEDITOR.addTemplate( 'panel-list-item', '<li id="{id}" class="cke_panel_listItem" role=presentation>' +
				'<a id="{id}_option" _cke_focus=1 hidefocus=true' +
					' title="{title}"' +
					' href="javascript:void(\'{val}\')" ' +
					' {onclick}="CKEDITOR.tools.callFunction({clickFn},\'{val}\'); return false;"' + // #188
						' role="option">' +
					'{text}' +
				'</a>' +
				'</li>' ),
			listGroup = CKEDITOR.addTemplate( 'panel-list-group', '<h1 id="{id}" class="cke_panel_grouptitle" role="presentation" >{label}</h1>' );

		CKEDITOR.ui.panel.prototype.addListBlock = function( name, definition ) {
			return this.addBlock( name, new CKEDITOR.ui.listBlock( this.getHolderElement(), definition ) );
		};

		CKEDITOR.ui.listBlock = CKEDITOR.tools.createClass({
			base: CKEDITOR.ui.panel.block,

			$: function( blockHolder, blockDefinition ) {
				blockDefinition = blockDefinition || {};

				var attribs = blockDefinition.attributes || ( blockDefinition.attributes = {} );
				( this.multiSelect = !!blockDefinition.multiSelect ) && ( attribs[ 'aria-multiselectable' ] = true );
				// Provide default role of 'listbox'.
				!attribs.role && ( attribs.role = 'listbox' );

				// Call the base contructor.
				this.base.apply( this, arguments );

				var keys = this.keys;
				keys[ 40 ] = 'next'; // ARROW-DOWN
				keys[ 9 ] = 'next'; // TAB
				keys[ 38 ] = 'prev'; // ARROW-UP
				keys[ CKEDITOR.SHIFT + 9 ] = 'prev'; // SHIFT + TAB
				keys[ 32 ] = CKEDITOR.env.ie ? 'mouseup' : 'click'; // SPACE
				CKEDITOR.env.ie && ( keys[ 13 ] = 'mouseup' ); // Manage ENTER, since onclick is blocked in IE (#8041).

				this._.pendingHtml = [];
				this._.pendingList = [];
				this._.items = {};
				this._.groups = {};
			},

			_: {
				close: function() {
					if ( this._.started ) {
						var output = list.output({ items: this._.pendingList.join( '' ) } );
						this._.pendingList = [];
						this._.pendingHtml.push( output );
						delete this._.started;
					}
				},

				getClick: function() {
					if ( !this._.click ) {
						this._.click = CKEDITOR.tools.addFunction( function( value ) {
							var marked = this.toggle( value );
							if ( this.onClick )
								this.onClick( value, marked );
						}, this );
					}
					return this._.click;
				}
			},

			proto: {
				add: function( value, html, title ) {
					var id = CKEDITOR.tools.getNextId();

					if ( !this._.started ) {
						this._.started = 1;
						this._.size = this._.size || 0;
					}

					this._.items[ value ] = id;

					var data = {
						id: id,
						val: value,
						onclick: CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick',
						clickFn: this._.getClick(),
						title: title || value,
						text: html || value
					};

					this._.pendingList.push( listItem.output( data ) );
				},

				startGroup: function( title ) {
					this._.close();

					var id = CKEDITOR.tools.getNextId();

					this._.groups[ title ] = id;

					this._.pendingHtml.push( listGroup.output({ id: id, label: title } ) );
				},

				commit: function() {
					this._.close();
					this.element.appendHtml( this._.pendingHtml.join( '' ) );
					delete this._.size;

					this._.pendingHtml = [];
				},

				toggle: function( value ) {
					var isMarked = this.isMarked( value );

					if ( isMarked )
						this.unmark( value );
					else
						this.mark( value );

					return !isMarked;
				},

				hideGroup: function( groupTitle ) {
					var group = this.element.getDocument().getById( this._.groups[ groupTitle ] ),
						list = group && group.getNext();

					if ( group ) {
						group.setStyle( 'display', 'none' );

						if ( list && list.getName() == 'ul' )
							list.setStyle( 'display', 'none' );
					}
				},

				hideItem: function( value ) {
					this.element.getDocument().getById( this._.items[ value ] ).setStyle( 'display', 'none' );
				},

				showAll: function() {
					var items = this._.items,
						groups = this._.groups,
						doc = this.element.getDocument();

					for ( var value in items ) {
						doc.getById( items[ value ] ).setStyle( 'display', '' );
					}

					for ( var title in groups ) {
						var group = doc.getById( groups[ title ] ),
							list = group.getNext();

						group.setStyle( 'display', '' );

						if ( list && list.getName() == 'ul' )
							list.setStyle( 'display', '' );
					}
				},

				mark: function( value ) {
					if ( !this.multiSelect )
						this.unmarkAll();

					var itemId = this._.items[ value ],
						item = this.element.getDocument().getById( itemId );
					item.addClass( 'cke_selected' );

					this.element.getDocument().getById( itemId + '_option' ).setAttribute( 'aria-selected', true );
					this.onMark && this.onMark( item );
				},

				unmark: function( value ) {
					var doc = this.element.getDocument(),
						itemId = this._.items[ value ],
						item = doc.getById( itemId );

					item.removeClass( 'cke_selected' );
					doc.getById( itemId + '_option' ).removeAttribute( 'aria-selected' );

					this.onUnmark && this.onUnmark( item );
				},

				unmarkAll: function() {
					var items = this._.items,
						doc = this.element.getDocument();

					for ( var value in items ) {
						var itemId = items[ value ];

						doc.getById( itemId ).removeClass( 'cke_selected' );
						doc.getById( itemId + '_option' ).removeAttribute( 'aria-selected' );
					}

					this.onUnmark && this.onUnmark();
				},

				isMarked: function( value ) {
					return this.element.getDocument().getById( this._.items[ value ] ).hasClass( 'cke_selected' );
				},

				focus: function( value ) {
					this._.focusIndex = -1;

					if ( value ) {
						var selected = this.element.getDocument().getById( this._.items[ value ] ).getFirst();

						var links = this.element.getElementsByTag( 'a' ),
							link,
							i = -1;

						while ( ( link = links.getItem( ++i ) ) ) {
							if ( link.equals( selected ) ) {
								this._.focusIndex = i;
								break;
							}
						}

						setTimeout( function() {
							selected.focus();
						}, 0 );
					}
				}
			}
		});
	}
});

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'richcombo', {
	requires: 'floatpanel,listblock,button',

	beforeInit: function( editor ) {
		editor.ui.addHandler( CKEDITOR.UI_RICHCOMBO, CKEDITOR.ui.richCombo.handler );
	}
});

(function() {
	var template = '<span id="{id}"' +
		' class="cke_combo cke_combo__{name} {cls}"' +
		' role="presentation">' +
			'<span id="{id}_label" class="cke_combo_label">{label}</span>' +
			'<a class="cke_combo_button" hidefocus=true title="{title}" tabindex="-1"' +
			( CKEDITOR.env.gecko && CKEDITOR.env.version >= 10900 && !CKEDITOR.env.hc ? '' : '" href="javascript:void(\'{titleJs}\')"' ) +
			' hidefocus="true"' +
			' role="button"' +
			' aria-labelledby="{id}_label"' +
			' aria-haspopup="true"';

	// Some browsers don't cancel key events in the keydown but in the
	// keypress.
	// TODO: Check if really needed for Gecko+Mac.
	if ( CKEDITOR.env.opera || ( CKEDITOR.env.gecko && CKEDITOR.env.mac ) )
		template += ' onkeypress="return false;"';

	// With Firefox, we need to force the button to redraw, otherwise it
	// will remain in the focus state.
	if ( CKEDITOR.env.gecko )
		template += ' onblur="this.style.cssText = this.style.cssText;"';

	template +=
		' onkeydown="return CKEDITOR.tools.callFunction({keydownFn},event,this);"' +
		' onmousedown="return CKEDITOR.tools.callFunction({mousedownFn},event);" ' +
		' onfocus="return CKEDITOR.tools.callFunction({focusFn},event);" ' +
			( CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick' ) + // #188
				'="CKEDITOR.tools.callFunction({clickFn},this);return false;">' +
			'<span id="{id}_text" class="cke_combo_text cke_combo_inlinelabel">{label}</span>' +
			'<span class="cke_combo_open">' +
				'<span class="cke_combo_arrow">' +
				// BLACK DOWN-POINTING TRIANGLE
	( CKEDITOR.env.hc ? '&#9660;' : CKEDITOR.env.air ? '&nbsp;' : '' ) +
				'</span>' +
			'</span>' +
		'</a>' +
		'</span>';

	var rcomboTpl = CKEDITOR.addTemplate( 'combo', template );

	/**
	 * Button UI element.
	 *
	 * @readonly
	 * @property {String} [='richcombo']
	 * @member CKEDITOR
	 */
	CKEDITOR.UI_RICHCOMBO = 'richcombo';

	/**
	 * @class
	 * @todo
	 */
	CKEDITOR.ui.richCombo = CKEDITOR.tools.createClass({
		$: function( definition ) {
			// Copy all definition properties to this object.
			CKEDITOR.tools.extend( this, definition,
			// Set defaults.
			{
				// The combo won't participate in toolbar grouping.
				canGroup: false,
				title: definition.label,
				modes: { wysiwyg:1 },
				editorFocus: 1
			});

			// We don't want the panel definition in this object.
			var panelDefinition = this.panel || {};
			delete this.panel;

			this.id = CKEDITOR.tools.getNextNumber();

			this.document = ( panelDefinition.parent && panelDefinition.parent.getDocument() ) || CKEDITOR.document;

			panelDefinition.className = 'cke_combopanel';
			panelDefinition.block = {
				multiSelect: panelDefinition.multiSelect,
				attributes: panelDefinition.attributes
			};
			panelDefinition.toolbarRelated = true;

			this._ = {
				panelDefinition: panelDefinition,
				items: {}
			};
		},

		proto: {
			renderHtml: function( editor ) {
				var output = [];
				this.render( editor, output );
				return output.join( '' );
			},

			/**
			 * Renders the combo.
			 *
			 * @param {CKEDITOR.editor} editor The editor instance which this button is
			 * to be used by.
			 * @param {Array} output The output array to which append the HTML relative
			 * to this button.
			 */
			render: function( editor, output ) {
				var env = CKEDITOR.env;

				var id = 'cke_' + this.id;
				var clickFn = CKEDITOR.tools.addFunction( function( el ) {

				// Restore locked selection in Opera.
				if ( selLocked ) {
					editor.unlockSelection( 1 );
					selLocked = 0;
				}

					instance.execute( el );
				}, this );

				var combo = this;
				var instance = {
					id: id,
					combo: this,
					focus: function() {
						var element = CKEDITOR.document.getById( id ).getChild( 1 );
						element.focus();
					},
					execute: function( el ) {
						var _ = combo._;

						if ( _.state == CKEDITOR.TRISTATE_DISABLED )
							return;

						combo.createPanel( editor );

						if ( _.on ) {
							_.panel.hide();
							return;
						}

						combo.commit();
						var value = combo.getValue();
						if ( value )
							_.list.mark( value );
						else
							_.list.unmarkAll();

						_.panel.showBlock( combo.id, new CKEDITOR.dom.element( el ), 4 );
					},
					clickFn: clickFn
				};

				function updateState() {
					var state = this.modes[ editor.mode ] ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
					this.setState( editor.readOnly && !this.readOnly ? CKEDITOR.TRISTATE_DISABLED : state );
					this.setValue( '' );
				}

				editor.on( 'mode', updateState, this );
				// If this combo is sensitive to readOnly state, update it accordingly.
				!this.readOnly && editor.on( 'readOnly', updateState, this );

				var keyDownFn = CKEDITOR.tools.addFunction( function( ev, element ) {
					ev = new CKEDITOR.dom.event( ev );

					var keystroke = ev.getKeystroke();
					switch ( keystroke ) {
						case 13: // ENTER
						case 32: // SPACE
						case 40: // ARROW-DOWN
							// Show panel
							CKEDITOR.tools.callFunction( clickFn, element );
							break;
						default:
							// Delegate the default behavior to toolbar button key handling.
							instance.onkey( instance, keystroke );
					}

					// Avoid subsequent focus grab on editor document.
					ev.preventDefault();
				});

				var focusFn = CKEDITOR.tools.addFunction( function() {
					instance.onfocus && instance.onfocus();
				});

				var selLocked = 0;
				var mouseDownFn = CKEDITOR.tools.addFunction( function() {
					// Opera: lock to prevent loosing editable text selection when clicking on button.
					if ( CKEDITOR.env.opera ) {
						var edt = editor.editable();
						if ( edt.isInline() && edt.hasFocus ) {
							editor.lockSelection();
							selLocked = 1;
						}
					}
				});

				// For clean up
				instance.keyDownFn = keyDownFn;

				var params = {
					id: id,
					name: this.name || this.command,
					label: this.label,
					title: this.title,
					cls: this.className || '',
					titleJs: env.gecko && env.version >= 10900 && !env.hc ? '' : ( this.title || '' ).replace( "'", '' ),
					keydownFn: keyDownFn,
					mousedownFn: mouseDownFn,
					focusFn: focusFn,
					clickFn: clickFn
				};

				rcomboTpl.output( params, output );

				if ( this.onRender )
					this.onRender();

				return instance;
			},

			createPanel: function( editor ) {
				if ( this._.panel )
					return;

				var panelDefinition = this._.panelDefinition,
					panelBlockDefinition = this._.panelDefinition.block,
					panelParentElement = panelDefinition.parent || CKEDITOR.document.getBody(),
					namedPanelCls = 'cke_combopanel__' + this.name,
					panel = new CKEDITOR.ui.floatPanel( editor, panelParentElement, panelDefinition ),
					list = panel.addListBlock( this.id, panelBlockDefinition ),
					me = this;

				panel.onShow = function() {
					
					// ------------------------------------------------------------------------------------
					//*** DYNAMIC DOCUMENTATION CHANGE ***
					// Fire 'beforerichcomboshow' event to move the range outside of the footnote reference 
					// number span if the range is at the boundary of the footnote span. The range is moved
					// so that the style is applied outside of the footnote span when we are at the boundary
					// ------------------------------------------------------------------------------------
				    editor.fire('beforerichcomboshow');
					
					this.element.addClass( namedPanelCls );

					me.setState( CKEDITOR.TRISTATE_ON );

					// ------------------------------------------------------------------------------------
					//*** DYNAMIC DOCUMENTATION CHANGE ***
					// Commented out list.focus so that the combo doesn't immediately disappear in generic editor
					// 1. Change the font size (or font family) of selected text using the combo box.
					// 2. Without changing selection, try to re-open the same combo box.
					// ------------------------------------------------------------------------------------
					//list.focus( !list.multiSelect && me.getValue() );
				    
					me._.on = 1;

					me.editorFocus && editor.focus();

					me._.bms = editor.getSelection().createBookmarks2();

					if ( me.onOpen )
						me.onOpen();
				};

				panel.onHide = function( preventOnClose ) {
					this.element.removeClass( namedPanelCls );

					me.setState( me.modes && me.modes[ editor.mode ] ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );

					me._.on = 0;

					if ( !preventOnClose && me.onClose )
						me.onClose();
				};

				panel.onEscape = function() {
					// Hide drop-down with focus returned.
					panel.hide( 1 );
				};

				list.onClick = function( value, marked ) {
					if ( me._.bms ) {
						editor.getSelection().selectBookmarks( me._.bms );
						delete me._.bms;
					}

					if ( me.onClick )
						me.onClick.call( me, value, marked );

					panel.hide();
				};

				this._.panel = panel;
				this._.list = list;

				panel.getBlock( this.id ).onHide = function() {
					me._.on = 0;
					me.setState( CKEDITOR.TRISTATE_OFF );
				};

				if ( this.init )
					this.init();
			},

			setValue: function( value, text ) {
				this._.value = value;

				var textElement = this.document.getById( 'cke_' + this.id + '_text' );
				if ( textElement ) {
					if ( !( value || text ) ) {
						text = this.label;
						textElement.addClass( 'cke_combo_inlinelabel' );
					} else
						textElement.removeClass( 'cke_combo_inlinelabel' );

					textElement.setText( typeof text != 'undefined' ? text : value );
				}
			},

			getValue: function() {
				return this._.value || '';
			},

			unmarkAll: function() {
				this._.list.unmarkAll();
			},

			mark: function( value ) {
				this._.list.mark( value );
			},

			hideItem: function( value ) {
				this._.list.hideItem( value );
			},

			hideGroup: function( groupTitle ) {
				this._.list.hideGroup( groupTitle );
			},

			showAll: function() {
				this._.list.showAll();
			},

			add: function( value, html, text ) {
				this._.items[ value ] = text || value;
				this._.list.add( value, html, text );
			},

			startGroup: function( title ) {
				this._.list.startGroup( title );
			},

			commit: function() {
				if ( !this._.committed ) {
					this._.list.commit();
					this._.committed = 1;
					CKEDITOR.ui.fire( 'ready', this );
				}
				this._.committed = 1;
			},

			setState: function( state ) {
				if ( this._.state == state )
					return;

				var el = this.document.getById( 'cke_' + this.id );
				el.setState( state, 'cke_combo' );

				state == CKEDITOR.TRISTATE_DISABLED ?
					el.setAttribute( 'aria-disabled', true ) :
					el.removeAttribute( 'aria-disabled' );

				this._.state = state;
			},

			enable: function() {
				if ( this._.state == CKEDITOR.TRISTATE_DISABLED )
					this.setState( this._.lastState );
			},

			disable: function() {
				if ( this._.state != CKEDITOR.TRISTATE_DISABLED ) {
					this._.lastState = this._.state;
					this.setState( CKEDITOR.TRISTATE_DISABLED );
				}
			}
		},

		/**
		 * Represents richCombo handler object.
		 *
		 * @class CKEDITOR.ui.richCombo.handler
		 * @singleton
		 * @extends CKEDITOR.ui.handlerDefinition
		 */
		statics: {
			handler: {
				/**
				 * Transforms a richCombo definition in a {@link CKEDITOR.ui.richCombo} instance.
				 *
				 * @param {Object} definition
				 * @returns {CKEDITOR.ui.richCombo}
				 */
				create: function( definition ) {
					return new CKEDITOR.ui.richCombo( definition );
				}
			}
		}
	});

	/**
	 * @member CKEDITOR.ui
	 * @param {String} name
	 * @param {Object} definition
	 * @todo
	 */
	CKEDITOR.ui.prototype.addRichCombo = function( name, definition ) {
		this.add( name, CKEDITOR.UI_RICHCOMBO, definition );
	};

})();

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

(function() {
	function addCombo( editor, comboName, styleType, lang, entries, defaultLabel, styleDefinition, order ) {
		var config = editor.config,
			style = new CKEDITOR.style( styleDefinition );

		// Gets the list of fonts from the settings.
		var names = entries.split( ';' ),
			values = [];

		// Create style objects for all fonts.
		var styles = {};
		for ( var i = 0; i < names.length; i++ ) {
			var parts = names[ i ];

			if ( parts ) {
				parts = parts.split( '/' );

				var vars = {},
					name = names[ i ] = parts[ 0 ];

				vars[ styleType ] = values[ i ] = parts[ 1 ] || name;

				styles[ name ] = new CKEDITOR.style( styleDefinition, vars );
				styles[ name ]._.definition.name = name;
			} else
				names.splice( i--, 1 );
		}

		editor.ui.addRichCombo( comboName, {
			label: lang.label,
			title: lang.panelTitle,
			toolbar: 'styles,' + order,
			allowedContent: style,
			requiredContent: style,

			panel: {
				css: [ CKEDITOR.skin.getPath( 'editor' ) ].concat( config.contentsCss ),
				multiSelect: false,
				attributes: { 'aria-label': lang.panelTitle }
			},

			init: function() {
				this.startGroup( lang.panelTitle );

				for ( var i = 0; i < names.length; i++ ) {
					var name = names[ i ];

					// Add the tag entry to the panel list.
					this.add( name, styles[ name ].buildPreview(), name );
				}
			},

			onClick: function( value ) {
				editor.focus();
				editor.fire( 'saveSnapshot' );

				var style = styles[ value ];

				// ------------------------------------------------------------------------------------
				//*** DYNAMIC DOCUMENTATION CHANGE ***
				// Disable the ability to toggle font styles using the toolbar button.
				// Example:
				//  1. Select some text and change the font size using the toolbar combo box.
				//  2. Without changing the selection, select the same font size from the combo box.
				// Without this change, the selection would toggle to its prior font size.
				// With this change, the font size remains what the user clicked in the combo box.
				// ------------------------------------------------------------------------------------
				editor[ /* this.getValue() == value ? 'removeStyle' : */ 'applyStyle' ]( style );
				editor.fire( 'saveSnapshot' );
			},

			onRender: function() {
				editor.on( 'selectionChange', function( ev ) {
					var currentValue = this.getValue();

					var elementPath = ev.data.path,
						elements = elementPath.elements;

					// For each element into the elements path.
					for ( var i = 0, element; i < elements.length; i++ ) {
						element = elements[ i ];

						// Check if the element is removable by any of
						// the styles.
						for ( var value in styles ) {
							if ( styles[ value ].checkElementMatch( element, true ) ) {
								if ( value != currentValue )
									this.setValue( value );
								return;
							}
						}
					}

					// If no styles match, just empty it.
					this.setValue( '', defaultLabel );
				}, this );
			}
		});
	}

	CKEDITOR.plugins.add( 'font', {
		requires: 'richcombo',
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			var config = editor.config;

			addCombo( editor, 'Font', 'family', editor.lang.font, config.font_names, config.font_defaultLabel, config.font_style, 30 );
			addCombo( editor, 'FontSize', 'size', editor.lang.font.fontSize, config.fontSize_sizes, config.fontSize_defaultLabel, config.fontSize_style, 40 );
		}
	});
})();

/**
 * The list of fonts names to be displayed in the Font combo in the toolbar.
 * Entries are separated by semi-colons (`';'`), while it's possible to have more
 * than one font for each entry, in the HTML way (separated by comma).
 *
 * A display name may be optionally defined by prefixing the entries with the
 * name and the slash character. For example, `'Arial/Arial, Helvetica, sans-serif'`
 * will be displayed as `'Arial'` in the list, but will be outputted as
 * `'Arial, Helvetica, sans-serif'`.
 *
 *		config.font_names =
 *			'Arial/Arial, Helvetica, sans-serif;' +
 *			'Times New Roman/Times New Roman, Times, serif;' +
 *			'Verdana';
 *
 *		config.font_names = 'Arial;Times New Roman;Verdana';
 *
 * @cfg {String} [font_names=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.font_names = 'Arial/Arial, Helvetica, sans-serif;' +
	'Comic Sans MS/Comic Sans MS, cursive;' +
	'Courier New/Courier New, Courier, monospace;' +
	'Georgia/Georgia, serif;' +
	'Lucida Sans Unicode/Lucida Sans Unicode, Lucida Grande, sans-serif;' +
	'Tahoma/Tahoma, Geneva, sans-serif;' +
	'Times New Roman/Times New Roman, Times, serif;' +
	'Trebuchet MS/Trebuchet MS, Helvetica, sans-serif;' +
	'Verdana/Verdana, Geneva, sans-serif';

/**
 * The text to be displayed in the Font combo is none of the available values
 * matches the current cursor position or text selection.
 *
 *		// If the default site font is Arial, we may making it more explicit to the end user.
 *		config.font_defaultLabel = 'Arial';
 *
 * @cfg {String} [font_defaultLabel='']
 * @member CKEDITOR.config
 */
CKEDITOR.config.font_defaultLabel = '';

/**
 * The style definition to be used to apply the font in the text.
 *
 *		// This is actually the default value for it.
 *		config.font_style = {
 *			element:		'span',
 *			styles:			{ 'font-family': '#(family)' },
 *			overrides:		[ { element: 'font', attributes: { 'face': null } } ]
 *     };
 *
 * @cfg {Object} [font_style=see example]
 * @member CKEDITOR.config
 */
CKEDITOR.config.font_style = {
	element: 'span',
	styles: { 'font-family': '#(family)' },
	overrides: [ {
		element: 'font', attributes: { 'face': null }
	}]
};

/**
 * The list of fonts size to be displayed in the Font Size combo in the
 * toolbar. Entries are separated by semi-colons (`';'`).
 *
 * Any kind of "CSS like" size can be used, like `'12px'`, `'2.3em'`, `'130%'`,
 * `'larger'` or `'x-small'`.
 *
 * A display name may be optionally defined by prefixing the entries with the
 * name and the slash character. For example, `'Bigger Font/14px'` will be
 * displayed as `'Bigger Font'` in the list, but will be outputted as `'14px'`.
 *
 *		config.fontSize_sizes = '16/16px;24/24px;48/48px;';
 *
 *		config.fontSize_sizes = '12px;2.3em;130%;larger;x-small';
 *
 *		config.fontSize_sizes = '12 Pixels/12px;Big/2.3em;30 Percent More/130%;Bigger/larger;Very Small/x-small';
 *
 * @cfg {String} [fontSize_sizes=see source]
 * @member CKEDITOR.config
 */
CKEDITOR.config.fontSize_sizes = '8/8px;9/9px;10/10px;11/11px;12/12px;14/14px;16/16px;18/18px;20/20px;22/22px;24/24px;26/26px;28/28px;36/36px;48/48px;72/72px';

/**
 * The text to be displayed in the Font Size combo is none of the available
 * values matches the current cursor position or text selection.
 *
 *		// If the default site font size is 12px, we may making it more explicit to the end user.
 *		config.fontSize_defaultLabel = '12px';
 *
 * @cfg {String} [fontSize_defaultLabel='']
 * @member CKEDITOR.config
 */
CKEDITOR.config.fontSize_defaultLabel = '';

/**
 * The style definition to be used to apply the font size in the text.
 *
 *		// This is actually the default value for it.
 *		config.fontSize_style = {
 *			element:		'span',
 *			styles:			{ 'font-size': '#(size)' },
 *			overrides:		[ { element :'font', attributes: { 'size': null } } ]
 *		};
 *
 * @cfg {Object} [fontSize_style=see example]
 * @member CKEDITOR.config
 */
CKEDITOR.config.fontSize_style = {
	element: 'span',
	styles: { 'font-size': '#(size)' },
	overrides: [ {
		element: 'font', attributes: { 'size': null }
	}]
};

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'format', {
	requires: 'richcombo',
	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
	init: function( editor ) {
		if ( editor.blockless )
			return;

		var config = editor.config,
			lang = editor.lang.format;

		// Gets the list of tags from the settings.
		var tags = config.format_tags.split( ';' );

		// Create style objects for all defined styles.
		var styles = {},
			stylesCount = 0,
			allowedContent = [];
		for ( var i = 0; i < tags.length; i++ ) {
			var tag = tags[ i ];
			var style = new CKEDITOR.style( config[ 'format_' + tag ] );
			if ( !editor.filter.customConfig || editor.filter.check( style ) ) {
				stylesCount++;
				styles[ tag ] = style;
				styles[ tag ]._.enterMode = editor.config.enterMode;
				allowedContent.push( style );
			}
		}

		// Hide entire combo when all formats are rejected.
		if ( stylesCount === 0 )
			return;

		editor.ui.addRichCombo( 'Format', {
			label: lang.label,
			title: lang.panelTitle,
			toolbar: 'styles,20',
			allowedContent: allowedContent,

			panel: {
				css: [ CKEDITOR.skin.getPath( 'editor' ) ].concat( config.contentsCss ),
				multiSelect: false,
				attributes: { 'aria-label': lang.panelTitle }
			},

			init: function() {
				this.startGroup( lang.panelTitle );

				for ( var tag in styles ) {
					var label = lang[ 'tag_' + tag ];

					// Add the tag entry to the panel list.
					this.add( tag, styles[ tag ].buildPreview( label ), label );
				}
			},

			onClick: function( value ) {
				editor.focus();
				editor.fire( 'saveSnapshot' );

				var style = styles[ value ],
					elementPath = editor.elementPath();

				editor[ style.checkActive( elementPath ) ? 'removeStyle' : 'applyStyle' ]( style );

				// Save the undo snapshot after all changes are affected. (#4899)
				setTimeout( function() {
					editor.fire( 'saveSnapshot' );
				}, 0 );
			},

			onRender: function() {
				editor.on( 'selectionChange', function( ev ) {

					var currentTag = this.getValue(),
						elementPath = ev.data.path,
						isEnabled = !editor.readOnly && elementPath.isContextFor( 'p' );

					// Disable the command when selection path is "blockless".
					this[ isEnabled ? 'enable' : 'disable' ]();

					if ( isEnabled ) {

						for ( var tag in styles ) {
							if ( styles[ tag ].checkActive( elementPath ) ) {
								if ( tag != currentTag )
									this.setValue( tag, editor.lang.format[ 'tag_' + tag ] );
								return;
							}
						}

						// If no styles match, just empty it.
						this.setValue( '' );
					}
				}, this );
			}
		});
	}
});

/**
 * A list of semi colon separated style names (by default tags) representing
 * the style definition for each entry to be displayed in the Format combo in
 * the toolbar. Each entry must have its relative definition configuration in a
 * setting named `'format_(tagName)'`. For example, the `'p'` entry has its
 * definition taken from `config.format_p`.
 *
 *		config.format_tags = 'p;h2;h3;pre';
 *
 * @cfg {String} [format_tags='p;h1;h2;h3;h4;h5;h6;pre;address;div']
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_tags = 'p;h1;h2;h3;h4;h5;h6;pre;address;div';

/**
 * The style definition to be used to apply the `'Normal'` format.
 *
 *		config.format_p = { element : 'p', attributes : { 'class' : 'normalPara' } };
 *
 * @cfg {Object} [format_p={ element: 'p' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_p = { element: 'p' };

/**
 * The style definition to be used to apply the `'Normal (DIV)'` format.
 *
 *		config.format_div = { element : 'div', attributes : { 'class' : 'normalDiv' } };
 *
 * @cfg {Object} [format_div={ element: 'div' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_div = { element: 'div' };

/**
 * The style definition to be used to apply the `'Formatted'` format.
 *
 *		config.format_pre = { element: 'pre', attributes: { 'class': 'code' } };
 *
 * @cfg {Object} [format_pre={ element: 'pre' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_pre = { element: 'pre' };

/**
 * The style definition to be used to apply the `'Address'` format.
 *
 * config.format_address = { element: 'address', attributes: { 'class': 'styledAddress' } };
 *
 * @cfg {Object} [format_address={ element: 'address' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_address = { element: 'address' };

/**
 * The style definition to be used to apply the ``'Heading 1'` format.
 *
 *		config.format_h1 = { element: 'h1', attributes: { 'class': 'contentTitle1' } };
 *
 * @cfg {Object} [format_h1={ element: 'h1' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h1 = { element: 'h1' };

/**
 * The style definition to be used to apply the `'Heading 1'` format.
 *
 *		config.format_h2 = { element: 'h2', attributes: { 'class': 'contentTitle2' } };
 *
 * @cfg {Object} [format_h2={ element: 'h2' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h2 = { element: 'h2' };

/**
 * The style definition to be used to apply the `'Heading 1'` format.
 *
 *		config.format_h3 = { element: 'h3', attributes: { 'class': 'contentTitle3' } };
 *
 * @cfg {Object} [format_h3={ element: 'h3' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h3 = { element: 'h3' };

/**
 * The style definition to be used to apply the `'Heading 1'` format.
 *
 *		config.format_h4 = { element: 'h4', attributes: { 'class': 'contentTitle4' } };
 *
 * @cfg {Object} [format_h4={ element: 'h4' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h4 = { element: 'h4' };

/**
 * The style definition to be used to apply the `'Heading 1'` format.
 *
 *		config.format_h5 = { element: 'h5', attributes: { 'class': 'contentTitle5' } };
 *
 * @cfg {Object} [format_h5={ element: 'h5' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h5 = { element: 'h5' };

/**
 * The style definition to be used to apply the `'Heading 1'` format.
 *
 *		config.format_h6 = { element: 'h6', attributes: { 'class': 'contentTitle6' } };
 *
 * @cfg {Object} [format_h6={ element: 'h6' }]
 * @member CKEDITOR.config
 */
CKEDITOR.config.format_h6 = { element: 'h6' };

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'htmlwriter', {
	init: function( editor ) {
		var writer = new CKEDITOR.htmlWriter();

		writer.forceSimpleAmpersand = editor.config.forceSimpleAmpersand;
		writer.indentationChars = editor.config.dataIndentationChars || '\t';

		// Overwrite default basicWriter initialized in hmtlDataProcessor constructor.
		editor.dataProcessor.writer = writer;
	}
});

/**
 * Class used to write HTML data.
 *
 *		var writer = new CKEDITOR.htmlWriter();
 *		writer.openTag( 'p' );
 *		writer.attribute( 'class', 'MyClass' );
 *		writer.openTagClose( 'p' );
 *		writer.text( 'Hello' );
 *		writer.closeTag( 'p' );
 *		alert( writer.getHtml() ); // '<p class="MyClass">Hello</p>'
 *
 * @class
 * @extends CKEDITOR.htmlParser.basicWriter
 */
CKEDITOR.htmlWriter = CKEDITOR.tools.createClass({
	base: CKEDITOR.htmlParser.basicWriter,

	/**
	 * Creates a htmlWriter class instance.
	 *
	 * @constructor
	 */
	$: function() {
		// Call the base contructor.
		this.base();

		/**
		 * The characters to be used for each identation step.
		 *
		 *		// Use tab for indentation.
		 *		editorInstance.dataProcessor.writer.indentationChars = '\t';
		 */
		this.indentationChars = '\t';

		/**
		 * The characters to be used to close "self-closing" elements, like `<br>` or `<img>`.
		 *
		 *		// Use HTML4 notation for self-closing elements.
		 *		editorInstance.dataProcessor.writer.selfClosingEnd = '>';
		 */
		this.selfClosingEnd = ' />';

		/**
		 * The characters to be used for line breaks.
		 *
		 *		// Use CRLF for line breaks.
		 *		editorInstance.dataProcessor.writer.lineBreakChars = '\r\n';
		 */
		this.lineBreakChars = '\n';

		this.sortAttributes = 1;

		this._.indent = 0;
		this._.indentation = '';
		// Indicate preformatted block context status. (#5789)
		this._.inPre = 0;
		this._.rules = {};

		var dtd = CKEDITOR.dtd;

		for ( var e in CKEDITOR.tools.extend( {}, dtd.$nonBodyContent, dtd.$block, dtd.$listItem, dtd.$tableContent ) ) {
			this.setRules( e, {
				indent: !dtd[ e ][ '#' ],
				breakBeforeOpen: 1,
				breakBeforeClose: !dtd[ e ][ '#' ],
				breakAfterClose: 1,
				needsSpace: ( e in dtd.$block ) && !( e in { li:1,dt:1,dd:1 } )
			});
		}

		this.setRules( 'br', { breakAfterOpen:1 } );

		this.setRules( 'title', {
			indent: 0,
			breakAfterOpen: 0
		});

		this.setRules( 'style', {
			indent: 0,
			breakBeforeClose: 1
		});

		this.setRules( 'pre', {
			breakAfterOpen: 1, // Keep line break after the opening tag
			indent: 0 // Disable indentation on <pre>.
		});
	},

	proto: {
		/**
		 * Writes the tag opening part for a opener tag.
		 *
		 *		// Writes '<p'.
		 *		writer.openTag( 'p', { class : 'MyClass', id : 'MyId' } );
		 *
		 * @param {String} tagName The element name for this tag.
		 * @param {Object} attributes The attributes defined for this tag. The
		 * attributes could be used to inspect the tag.
		 */
		openTag: function( tagName, attributes ) {
			var rules = this._.rules[ tagName ];

			if ( this._.afterCloser && rules && rules.needsSpace && this._.needsSpace )
				this._.output.push( '\n' );

			if ( this._.indent )
				this.indentation();
			// Do not break if indenting.
			else if ( rules && rules.breakBeforeOpen ) {
				this.lineBreak();
				this.indentation();
			}

			this._.output.push( '<', tagName );

			this._.afterCloser = 0;
		},

		/**
		 * Writes the tag closing part for a opener tag.
		 *
		 *		// Writes '>'.
		 *		writer.openTagClose( 'p', false );
		 *
		 *		// Writes ' />'.
		 *		writer.openTagClose( 'br', true );
		 *
		 * @param {String} tagName The element name for this tag.
		 * @param {Boolean} isSelfClose Indicates that this is a self-closing tag,
		 * like `<br>` or `<img>`.
		 */
		openTagClose: function( tagName, isSelfClose ) {
			var rules = this._.rules[ tagName ];

			if ( isSelfClose ) {
				this._.output.push( this.selfClosingEnd );

				if ( rules && rules.breakAfterClose )
					this._.needsSpace = rules.needsSpace;
			} else {
				this._.output.push( '>' );

				if ( rules && rules.indent )
					this._.indentation += this.indentationChars;
			}

			if ( rules && rules.breakAfterOpen )
				this.lineBreak();
			tagName == 'pre' && ( this._.inPre = 1 );
		},

		/**
		 * Writes an attribute. This function should be called after opening the
		 * tag with {@link #openTagClose}.
		 *
		 *		// Writes ' class="MyClass"'.
		 *		writer.attribute( 'class', 'MyClass' );
		 *
		 * @param {String} attName The attribute name.
		 * @param {String} attValue The attribute value.
		 */
		attribute: function( attName, attValue ) {

			if ( typeof attValue == 'string' ) {
				this.forceSimpleAmpersand && ( attValue = attValue.replace( /&amp;/g, '&' ) );
				// Browsers don't always escape special character in attribute values. (#4683, #4719).
				attValue = CKEDITOR.tools.htmlEncodeAttr( attValue );
			}

			this._.output.push( ' ', attName, '="', attValue, '"' );
		},

		/**
		 * Writes a closer tag.
		 *
		 *		// Writes '</p>'.
		 *		writer.closeTag( 'p' );
		 *
		 * @param {String} tagName The element name for this tag.
		 */
		closeTag: function( tagName ) {
			var rules = this._.rules[ tagName ];

			if ( rules && rules.indent )
				this._.indentation = this._.indentation.substr( this.indentationChars.length );

			if ( this._.indent )
				this.indentation();
			// Do not break if indenting.
			else if ( rules && rules.breakBeforeClose ) {
				this.lineBreak();
				this.indentation();
			}

			this._.output.push( '</', tagName, '>' );
			tagName == 'pre' && ( this._.inPre = 0 );

			if ( rules && rules.breakAfterClose ) {
				this.lineBreak();
				this._.needsSpace = rules.needsSpace;
			}

			this._.afterCloser = 1;
		},

		/**
		 * Writes text.
		 *
		 *		// Writes 'Hello Word'.
		 *		writer.text( 'Hello Word' );
		 *
		 * @param {String} text The text value
		 */
		text: function( text ) {
			if ( this._.indent ) {
				this.indentation();
				!this._.inPre && ( text = CKEDITOR.tools.ltrim( text ) );
			}

			this._.output.push( text );
		},

		/**
		 * Writes a comment.
		 *
		 *		// Writes "<!-- My comment -->".
		 *		writer.comment( ' My comment ' );
		 *
		 * @param {String} comment The comment text.
		 */
		comment: function( comment ) {
			if ( this._.indent )
				this.indentation();

			this._.output.push( '<!--', comment, '-->' );
		},

		/**
		 * Writes a line break. It uses the {@link #lineBreakChars} property for it.
		 *
		 *		// Writes '\n' (e.g.).
		 *		writer.lineBreak();
		 */
		lineBreak: function() {
			if ( !this._.inPre && this._.output.length > 0 )
				this._.output.push( this.lineBreakChars );
			this._.indent = 1;
		},

		/**
		 * Writes the current indentation chars. It uses the {@link #indentationChars}
		 * property, repeating it for the current indentation steps.
		 *
		 *		// Writes '\t' (e.g.).
		 *		writer.indentation();
		 */
		indentation: function() {
			if ( !this._.inPre && this._.indentation )
				this._.output.push( this._.indentation );
			this._.indent = 0;
		},

		/**
		 * Empties the current output buffer. It also brings back the default
		 * values of the writer flags.
		 *
		 *		writer.reset();
		 */
		reset: function() {
			this._.output = [];
			this._.indent = 0;
			this._.indentation = '';
			this._.afterCloser = 0;
			this._.inPre = 0;
		},

		/**
		 * Sets formatting rules for a give element. The possible rules are:
		 *
		 * * `indent`: indent the element contents.
		 * * `breakBeforeOpen`: break line before the opener tag for this element.
		 * * `breakAfterOpen`: break line after the opener tag for this element.
		 * * `breakBeforeClose`: break line before the closer tag for this element.
		 * * `breakAfterClose`: break line after the closer tag for this element.
		 *
		 * All rules default to `false`. Each call to the function overrides
		 * already present rules, leaving the undefined untouched.
		 *
		 * By default, all elements available in the {@link CKEDITOR.dtd#$block},
		 * {@link CKEDITOR.dtd#$listItem} and {@link CKEDITOR.dtd#$tableContent}
		 * lists have all the above rules set to `true`. Additionaly, the `<br>`
		 * element has the `breakAfterOpen` set to `true`.
		 *
		 *		// Break line before and after "img" tags.
		 *		writer.setRules( 'img', {
		 *			breakBeforeOpen: true
		 *			breakAfterOpen: true
		 *		} );
		 *
		 *		// Reset the rules for the "h1" tag.
		 *		writer.setRules( 'h1', {} );
		 *
		 * @param {String} tagName The element name to which set the rules.
		 * @param {Object} rules An object containing the element rules.
		 */
		setRules: function( tagName, rules ) {
			var currentRules = this._.rules[ tagName ];

			if ( currentRules )
				CKEDITOR.tools.extend( currentRules, rules, true );
			else
				this._.rules[ tagName ] = rules;
		}
	}
});

/**
 * Whether to force using `'&'` instead of `'&amp;'` in elements attributes
 * values, it's not recommended to change this setting for compliance with the
 * W3C XHTML 1.0 standards ([C.12, XHTML 1.0](http://www.w3.org/TR/xhtml1/#C_12)).
 *
 *		// Use `'&'` instead of `'&amp;'`
 *		CKEDITOR.config.forceSimpleAmpersand = true;
 *
 * @cfg {Boolean} [forceSimpleAmpersand=false]
 * @member CKEDITOR.config
 */

/**
 * The characters to be used for indenting the HTML produced by the editor.
 * Using characters different than `' '` (space) and `'\t'` (tab) is definitely
 * a bad idea as it'll mess the code.
 *
 *		// No indentation.
 *		CKEDITOR.config.dataIndentationChars = '';
 *
 *		// Use two spaces for indentation.
 *		CKEDITOR.config.dataIndentationChars = '  ';
 *
 * @cfg {String} [dataIndentationChars='\t']
 * @member CKEDITOR.config
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "wysiwygarea" plugin. It registers the "wysiwyg" editing
 *		mode, which handles the main editing area space.
 */

(function() {
	CKEDITOR.plugins.add( 'wysiwygarea', {
		init: function( editor ) {
			if ( editor.config.fullPage ) {
				editor.addFeature( {
					allowedContent: 'html head title; style [media,type]; body (*)[id]; meta link [*]',
					requiredContent: 'body'
				} );
			}

			editor.addMode( 'wysiwyg', function( callback ) {
				var iframe = CKEDITOR.document.createElement( 'iframe' );
				iframe.setStyles({ width: '100%', height: '100%' } );
				iframe.addClass( 'cke_wysiwyg_frame cke_reset' );

				var contentSpace = editor.ui.space( 'contents' );
				contentSpace.append( iframe );

				var src = 'document.open();' +
					// The document domain must be set any time we
				// call document.open().
				( isCustomDomain ? ( 'document.domain="' + document.domain + '";' ) : '' ) +
					'document.close();';

				// With IE, the custom domain has to be taken care at first,
				// for other browers, the 'src' attribute should be left empty to
				// trigger iframe's 'load' event.
				src = CKEDITOR.env.air ? 'javascript:void(0)' : CKEDITOR.env.ie ? 'javascript:void(function(){' + encodeURIComponent( src ) + '}())'
					:
					'';

				// Asynchronous iframe loading is only required in IE>8 and Gecko (other reasons probably).
				// Do not use it on WebKit as it'll break the browser-back navigation.
				var useOnloadEvent = CKEDITOR.env.ie || CKEDITOR.env.gecko;
				if ( useOnloadEvent )
					iframe.on( 'load', onLoad );

				var frameLabel = [ editor.lang.editor, editor.name ].join( ',' ),
					frameDesc = editor.lang.common.editorHelp;

				if ( CKEDITOR.env.ie )
					frameLabel += ', ' + frameDesc;

				var labelId = CKEDITOR.tools.getNextId(),
					desc = CKEDITOR.dom.element.createFromHtml( '<span id="' + labelId + '" class="cke_voice_label">' + frameDesc + '</span>' );

				contentSpace.append( desc, 1 );

				// Remove the ARIA description.
				editor.on( 'beforeModeUnload', function( evt ) {
					evt.removeListener();
					desc.remove();
				});

				iframe.setAttributes({
					frameBorder: 0,
					'aria-describedby' : labelId,
					title: frameLabel,
					src: src,
					tabIndex: editor.tabIndex,
					allowTransparency: 'true'
				});

				// Execute onLoad manually for all non IE||Gecko browsers.
				!useOnloadEvent && onLoad();

				if ( CKEDITOR.env.webkit ) {
					// Webkit: iframe size doesn't auto fit well. (#7360)
					var onResize = function() {
						// Hide the iframe to get real size of the holder. (#8941)
						contentSpace.setStyle( 'width', '100%' );

						iframe.hide();
						iframe.setSize( 'width', contentSpace.getSize( 'width' ) );
						contentSpace.removeStyle( 'width' );
						iframe.show();
					};

					iframe.setCustomData( 'onResize', onResize );

					CKEDITOR.document.getWindow().on( 'resize', onResize );
				}

				editor.fire( 'ariaWidget', iframe );

				function onLoad( evt ) {
					evt && evt.removeListener();
					editor.editable( new framedWysiwyg( editor, iframe.$.contentWindow.document.body ) );
					editor.setData( editor.getData( 1 ), callback );
				}
			});
		}
	});

	// Support for custom document.domain in IE.
	var isCustomDomain = CKEDITOR.env.isCustomDomain();

	function onDomReady( win ) {
		var editor = this.editor,
			doc = win.document,
			body = doc.body;

		// Remove helper scripts from the DOM.
		var script = doc.getElementById( 'cke_actscrpt' );
		script && script.parentNode.removeChild( script );
		script = doc.getElementById( 'cke_shimscrpt' );
		script && script.parentNode.removeChild( script );

		if ( CKEDITOR.env.gecko ) {
			// Force Gecko to change contentEditable from false to true on domReady
			// (because it's previously set to true on iframe's body creation).
			// Otherwise del/backspace and some other editable features will be broken in Fx <4
			// See: #107 and https://bugzilla.mozilla.org/show_bug.cgi?id=440916
			body.contentEditable = false;

			// Remove any leading <br> which is between the <body> and the comment.
			// This one fixes Firefox 3.6 bug: the browser inserts a leading <br>
			// on document.write if the body has contenteditable="true".
			if ( CKEDITOR.env.version < 20000 ) {
				body.innerHTML = body.innerHTML.replace( /^.*<!-- cke-content-start -->/, '' );

				// The above hack messes up the selection in FF36.
				// To clean this up, manually select collapsed range that
				// starts within the body.
				setTimeout( function() {
					var range = new CKEDITOR.dom.range( new CKEDITOR.dom.document( doc ) );
					range.setStart( new CKEDITOR.dom.node( body ), 0 );
					editor.getSelection().selectRanges( [ range ] );
				}, 0 );
			}
		}

		body.contentEditable = true;

		if ( CKEDITOR.env.ie ) {
			// Don't display the focus border.
			body.hideFocus = true;

			// Disable and re-enable the body to avoid IE from
			// taking the editing focus at startup. (#141 / #523)
			body.disabled = true;
			body.removeAttribute( 'disabled' );
		}

		delete this._.isLoadingData;

		// Play the magic to alter element reference to the reloaded one.
		this.$ = body;

		doc = new CKEDITOR.dom.document( doc );

		this.setup();

		if ( CKEDITOR.env.ie ) {
			doc.getDocumentElement().addClass( doc.$.compatMode );

			// Prevent IE from leaving new paragraph after deleting all contents in body. (#6966)
			editor.config.enterMode != CKEDITOR.ENTER_P && doc.on('selectionchange', function () {

				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Ensure the selection is valid, especially when selection contains non-editable
				// and editable areas and applying a font change
				// ------------------------------------------------------------------------------------
				if (null == editor.getSelection())
					return;

				var body = doc.getBody(),
					sel = editor.getSelection(),
					range = sel && sel.getRanges()[ 0 ];

				if ( range && body.getHtml().match( /^<p>&nbsp;<\/p>$/i ) && range.startContainer.equals( body ) ) {
					// Avoid the ambiguity from a real user cursor position.
					setTimeout( function() {
						range = editor.getSelection().getRanges()[ 0 ];
						if ( !range.startContainer.equals( 'body' ) ) {
							body.getFirst().remove( 1 );
							range.moveToElementEditEnd( body );
							range.select();
						}
					}, 0 );
				}
			});
		}

		// Gecko needs a key event to 'wake up' editing when the document is
		// empty. (#3864, #5781)
		CKEDITOR.env.gecko && CKEDITOR.tools.setTimeout( activateEditing, 0, this, editor );

		// ## START : disableNativeTableHandles and disableObjectResizing settings.

		// Enable dragging of position:absolute elements in IE.
		try {
			editor.document.$.execCommand( '2D-position', false, true );
		} catch ( e ) {}

		// IE, Opera and Safari may not support it and throw errors.
		try {
			editor.document.$.execCommand( 'enableInlineTableEditing', false, !editor.config.disableNativeTableHandles );
		} catch ( e ) {}

		if ( editor.config.disableObjectResizing ) {
			try {
				this.getDocument().$.execCommand( 'enableObjectResizing', false, false );
			} catch ( e ) {
				// For browsers in which the above method failed, we can cancel the resizing on the fly (#4208)
				this.attachListener( this, CKEDITOR.env.ie ? 'resizestart' : 'resize', function( evt ) {
					evt.data.preventDefault();
				});
			}
		}

		if ( CKEDITOR.env.gecko || CKEDITOR.env.ie && editor.document.$.compatMode == 'CSS1Compat' ) {
			this.attachListener( this, 'keydown', function( evt ) {
				var keyCode = evt.data.getKeystroke();

				// PageUp OR PageDown
				if ( keyCode == 33 || keyCode == 34 ) {
					// PageUp/PageDown scrolling is broken in document
					// with standard doctype, manually fix it. (#4736)
					if ( CKEDITOR.env.ie ) {
						setTimeout( function() {
							editor.getSelection().scrollIntoView();
						}, 0 );
					}
					// Page up/down cause editor selection to leak
					// outside of editable thus we try to intercept
					// the behavior, while it affects only happen
					// when editor contents are not overflowed. (#7955)
					else if ( editor.window.$.innerHeight > this.$.offsetHeight ) {
						var range = editor.createRange();
						range[ keyCode == 33 ? 'moveToElementEditStart' : 'moveToElementEditEnd' ]( this );
						range.select();
						evt.data.preventDefault();
					}
				}
			});
		}

		if ( CKEDITOR.env.ie ) {
			// [IE] Iframe will still keep the selection when blurred, if
			// focus is moved onto a non-editing host, e.g. link or button, but
			// it becomes a problem for the object type selection, since the resizer
			// handler attached on it will mark other part of the UI, especially
			// for the dialog. (#8157)
			// [IE<8 & Opera] Even worse For old IEs, the cursor will not vanish even if
			// the selection has been moved to another text input in some cases. (#4716)
			//
			// Now the range restore is disabled, so we simply force IE to clean
			// up the selection before blur.
			this.attachListener( doc, 'blur', function() {
				// Error proof when the editor is not visible. (#6375)
				try {
					doc.$.selection.empty();
				} catch ( er ) {}
			});
		}

		// ## END


		var title = editor.document.getElementsByTag( 'title' ).getItem( 0 );
		title.data( 'cke-title', editor.document.$.title );

		// [IE] JAWS will not recognize the aria label we used on the iframe
		// unless the frame window title string is used as the voice label,
		// backup the original one and restore it on output.
		if ( CKEDITOR.env.ie )
			editor.document.$.title = this._.docTitle;

		CKEDITOR.tools.setTimeout( function() {
			editor.fire( 'contentDom' );

			if ( this._.isPendingFocus ) {
				editor.focus();
				this._.isPendingFocus = false;
			}

			setTimeout( function() {
				editor.fire( 'dataReady' );
			}, 0 );

			// IE BUG: IE might have rendered the iframe with invisible contents.
			// (#3623). Push some inconsequential CSS style changes to force IE to
			// refresh it.
			//
			// Also, for some unknown reasons, short timeouts (e.g. 100ms) do not
			// fix the problem. :(
			if ( CKEDITOR.env.ie ) {
				setTimeout( function() {
					if ( editor.document ) {
						var $body = editor.document.$.body;
						$body.runtimeStyle.marginBottom = '0px';
						$body.runtimeStyle.marginBottom = '';
					}
				}, 1000 );
			}
		}, 0, this );
	}

	var framedWysiwyg = CKEDITOR.tools.createClass({
		$: function( editor ) {
			this.base.apply( this, arguments );

			this._.frameLoadedHandler = CKEDITOR.tools.addFunction( function( win ) {
				// Avoid opening design mode in a frame window thread,
				// which will cause host page scrolling.(#4397)
				CKEDITOR.tools.setTimeout( onDomReady, 0, this, win );
			}, this );

			this._.docTitle = this.getWindow().getFrame().getAttribute( 'title' );
		},

		base: CKEDITOR.editable,

		proto: {
			setData: function( data, isSnapshot ) {
				var editor = this.editor;

				if ( isSnapshot )
					this.setHtml( data );
				else {
					this._.isLoadingData = true;
					editor._.dataStore = { id:1 };

					var config = editor.config,
						fullPage = config.fullPage,
						docType = config.docType;

					// Build the additional stuff to be included into <head>.
					var headExtra = CKEDITOR.tools.buildStyleHtml( iframeCssFixes() )
						                .replace( /<style>/, '<style data-cke-temp="1">' );

					if ( !fullPage )
						headExtra += CKEDITOR.tools.buildStyleHtml( editor.config.contentsCss );

					var baseTag = config.baseHref ? '<base href="' + config.baseHref + '" data-cke-temp="1" />' : '';

					if ( fullPage ) {
						// Search and sweep out the doctype declaration.
						data = data.replace( /<!DOCTYPE[^>]*>/i, function( match ) {
							editor.docType = docType = match;
							return '';
						}).replace( /<\?xml\s[^\?]*\?>/i, function( match ) {
							editor.xmlDeclaration = match;
							return '';
						});
					}

					// Get the HTML version of the data.
					if ( editor.dataProcessor )
						data = editor.dataProcessor.toHtml( data );

					if ( fullPage ) {
						// Check if the <body> tag is available.
						if ( !( /<body[\s|>]/ ).test( data ) )
							data = '<body>' + data;

						// Check if the <html> tag is available.
						if ( !( /<html[\s|>]/ ).test( data ) )
							data = '<html>' + data + '</html>';

						// Check if the <head> tag is available.
						if ( !( /<head[\s|>]/ ).test( data ) )
							data = data.replace( /<html[^>]*>/, '$&<head><title></title></head>' );
						else if ( !( /<title[\s|>]/ ).test( data ) )
							data = data.replace( /<head[^>]*>/, '$&<title></title>' );

						// The base must be the first tag in the HEAD, e.g. to get relative
						// links on styles.
						baseTag && ( data = data.replace( /<head>/, '$&' + baseTag ) );

						// Inject the extra stuff into <head>.
						// Attention: do not change it before testing it well. (V2)
						// This is tricky... if the head ends with <meta ... content type>,
						// Firefox will break. But, it works if we place our extra stuff as
						// the last elements in the HEAD.
						data = data.replace( /<\/head\s*>/, headExtra + '$&' );

						// Add the DOCTYPE back to it.
						data = docType + data;
					} else {
						data = config.docType +
							'<html dir="' + config.contentsLangDirection + '"' +
								' lang="' + ( config.contentsLanguage || editor.langCode ) + '">' +
							'<head>' +
								'<title>' + this._.docTitle + '</title>' +
								baseTag +
								headExtra +
							'</head>' +
							'<body' + ( config.bodyId ? ' id="' + config.bodyId + '"' : '' ) +
								( config.bodyClass ? ' class="' + config.bodyClass + '"' : '' ) +
							'>' +
								data +
							'</body>' +
							'</html>';
					}

					if ( CKEDITOR.env.gecko ) {
						// Hack to make Fx put cursor at the start of doc on fresh focus.
						data = data.replace( /<body/, '<body contenteditable="true" ' );

						// Another hack which is used by onDomReady to remove a leading
						// <br> which is inserted by Firefox 3.6 when document.write is called.
						// This additional <br> is present because of contenteditable="true"
						if ( CKEDITOR.env.version < 20000 )
							data = data.replace( /<body[^>]*>/, '$&<!-- cke-content-start -->'  );
					}

					// The script that launches the bootstrap logic on 'domReady', so the document
					// is fully editable even before the editing iframe is fully loaded (#4455).
					var bootstrapCode =
						'<script id="cke_actscrpt" type="text/javascript"' + ( CKEDITOR.env.ie ? ' defer="defer" ' : '' ) + '>' +
							( isCustomDomain ? ( 'document.domain="' + document.domain + '";' ) : '' ) +
							'var wasLoaded=0;' +	// It must be always set to 0 as it remains as a window property.
							'function onload(){' +
								'if(!wasLoaded)' +	// FF3.6 calls onload twice when editor.setData. Stop that.
									'window.parent.CKEDITOR.tools.callFunction(' + this._.frameLoadedHandler + ',window);' +
								'wasLoaded=1;' +
							'}' +
							( CKEDITOR.env.ie ? 'onload();' : 'document.addEventListener("DOMContentLoaded", onload, false );' ) +
						'</script>';

					// For IE<9 add support for HTML5's elements.
					// Note: this code must not be deferred.
					if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 ) {
						bootstrapCode +=
							'<script id="cke_shimscrpt">' +
								'(function(){' +
									'var e="abbr,article,aside,audio,bdi,canvas,data,datalist,details,figcaption,figure,footer,header,hgroup,mark,meter,nav,output,progress,section,summary,time,video".split(","),i=e.length;' +
									'while(i--){document.createElement(e[i])}' +
								'})()' +
							'</script>';
					}

					data = data.replace( /(?=\s*<\/(:?head)>)/, bootstrapCode );

					// Current DOM will be deconstructed by document.write, cleanup required.
					this.clearCustomData();
					this.clearListeners();

					editor.fire( 'contentDomUnload' );

					var doc = this.getDocument();

					// Work around Firefox bug - error prune when called from XUL (#320),
					// defer it thanks to the async nature of this method.
					try { doc.write( data ); } catch ( e ) {
						setTimeout( function () { doc.write( data ); }, 0 );
					}
				}
			},

			getData: function( isSnapshot ) {
				if ( isSnapshot )
					return this.getHtml();
				else {
					var editor = this.editor,
						config = editor.config,
						fullPage = config.fullPage,
						docType = fullPage && editor.docType,
						xmlDeclaration = fullPage && editor.xmlDeclaration,
						doc = this.getDocument();

					var data = fullPage ? doc.getDocumentElement().getOuterHtml() : doc.getBody().getHtml();

					// BR at the end of document is bogus node for Mozilla. (#5293).
					if ( CKEDITOR.env.gecko )
						data = data.replace( /<br>(?=\s*(:?$|<\/body>))/, '' );

					if ( editor.dataProcessor )
						data = editor.dataProcessor.toDataFormat( data );

					if ( xmlDeclaration )
						data = xmlDeclaration + '\n' + data;
					if ( docType )
						data = docType + '\n' + data;

					return data;
				}
			},

			focus: function() {
				if ( this._.isLoadingData )
					this._.isPendingFocus = true;
				else
					framedWysiwyg.baseProto.focus.call( this );
			},

			detach: function() {
				var editor = this.editor,
					doc = editor.document,
					iframe = editor.window.getFrame();

				framedWysiwyg.baseProto.detach.call( this );

				// Memory leak proof.
				this.clearCustomData();
				doc.getDocumentElement().clearCustomData();
				iframe.clearCustomData();
				CKEDITOR.tools.removeFunction( this._.frameLoadedHandler );

				var onResize = iframe.removeCustomData( 'onResize' );
				onResize && onResize.removeListener();


				editor.fire( 'contentDomUnload' );

				// IE BUG: When destroying editor DOM with the selection remains inside
				// editing area would break IE7/8's selection system, we have to put the editing
				// iframe offline first. (#3812 and #5441)
				iframe.remove();
			}
		}
	});

	// DOM modification here should not bother dirty flag.(#4385)
	function restoreDirty( editor ) {
		if ( !editor.checkDirty() )
			setTimeout( function() {
			editor.resetDirty();
		}, 0 );
	}

	function activateEditing( editor ) {
		if ( editor.readOnly )
			return;

		var win = editor.window,
			doc = editor.document,
			body = doc.getBody(),
			bodyFirstChild = body.getFirst(),
			bodyChildsNum = body.getChildren().count();

		if ( !bodyChildsNum || bodyChildsNum == 1 && bodyFirstChild.type == CKEDITOR.NODE_ELEMENT && bodyFirstChild.hasAttribute( '_moz_editor_bogus_node' ) ) {
			restoreDirty( editor );

			// Memorize scroll position to restore it later (#4472).
			var hostDocument = CKEDITOR.document;
			var hostDocumentElement = hostDocument.getDocumentElement();
			var scrollTop = hostDocumentElement.$.scrollTop;
			var scrollLeft = hostDocumentElement.$.scrollLeft;

			// Simulating keyboard character input by dispatching a keydown of white-space text.
			var keyEventSimulate = doc.$.createEvent( "KeyEvents" );
			keyEventSimulate.initKeyEvent( 'keypress', true, true, win.$, false, false, false, false, 0, 32 );
			doc.$.dispatchEvent( keyEventSimulate );

			if ( scrollTop != hostDocumentElement.$.scrollTop || scrollLeft != hostDocumentElement.$.scrollLeft )
				hostDocument.getWindow().$.scrollTo( scrollLeft, scrollTop );

			// Restore the original document status by placing the cursor before a bogus br created (#5021).
			bodyChildsNum && body.getFirst().remove();
			doc.getBody().appendBogus();
			var nativeRange = editor.createRange();
			nativeRange.setStartAt( body, CKEDITOR.POSITION_AFTER_START );
			nativeRange.select();
		}
	}

	function iframeCssFixes() {
		var css = [];

		// IE>=8 stricts mode doesn't have 'contentEditable' in effect
		// on element unless it has layout. (#5562)
		if ( CKEDITOR.document.$.documentMode >= 8 ) {
			css.push( 'html.CSS1Compat [contenteditable=false]{min-height:0 !important}' );

			var selectors = [];

			for ( var tag in CKEDITOR.dtd.$removeEmpty )
				selectors.push( 'html.CSS1Compat ' + tag + '[contenteditable=false]' );

			css.push( selectors.join( ',' ) + '{display:inline-block}' );
		}
		// Set the HTML style to 100% to have the text cursor in affect (#6341)
		else if ( CKEDITOR.env.gecko ) {
			css.push( 'html{height:100% !important}' );
			css.push( 'img:-moz-broken{-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}' );
		}

		// #6341: The text cursor must be set on the editor area.
		// #6632: Avoid having "text" shape of cursor in IE7 scrollbars.
		css.push( 'html{cursor:text;*cursor:auto}' );

		// Use correct cursor for these elements
		css.push( 'img,input,textarea{cursor:default}' );

		return css.join('\n');
	}
})();

/**
 * Disables the ability of resize objects (image and tables) in the editing area.
 *
 *		config.disableObjectResizing = true;
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.disableObjectResizing = false;

/**
 * Disables the "table tools" offered natively by the browser (currently
 * Firefox only) to make quick table editing operations, like adding or
 * deleting rows and columns.
 *
 *		config.disableNativeTableHandles = false;
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.disableNativeTableHandles = true;

/**
 * Disables the built-in words spell checker if browser provides one.
 *
 * **Note:** Although word suggestions provided by browsers (natively) will
 * not appear in CKEditor's default context menu,
 * users can always reach the native context menu by holding the
 * *Ctrl* key when right-clicking if {@link #browserContextMenuOnCtrl}
 * is enabled or you're simply not using the context menu plugin.
 *
 *		config.disableNativeSpellChecker = false;
 *
 * @cfg
 * @member CKEDITOR.config
 */
CKEDITOR.config.disableNativeSpellChecker = true;

/**
 * The CSS file(s) to be used to apply style to the contents. It should
 * reflect the CSS used in the final pages where the contents are to be
 * used.
 *
 *		config.contentsCss = '/css/mysitestyles.css';
 *		config.contentsCss = ['/css/mysitestyles.css', '/css/anotherfile.css'];
 *
 * @cfg {String/Array} [contentsCss=CKEDITOR.basePath + 'contents.css']
 * @member CKEDITOR.config
 */
CKEDITOR.config.contentsCss = CKEDITOR.basePath + 'contents.css';

/**
 * Language code of  the writting language which is used to author the editor
 * contents.
 *
 *		config.contentsLanguage = 'fr';
 *
 * @cfg {String} [contentsLanguage=same value with editor's UI language]
 * @member CKEDITOR.config
 */

/**
 * The base href URL used to resolve relative and absolute URLs in the
 * editor content.
 *
 *		config.baseHref = 'http://www.example.com/path/';
 *
 * @cfg {String} [baseHref='']
 * @member CKEDITOR.config
 */

/**
 * Whether automatically create wrapping blocks around inline contents inside document body,
 * this helps to ensure the integrality of the block enter mode.
 *
 * **Note:** Changing the default value might introduce unpredictable usability issues.
 *
 *		config.autoParagraph = false;
 *
 * @since 3.6
 * @cfg {Boolean} [autoParagraph=true]
 * @member CKEDITOR.config
 */

/**
 * Fired when some elements are added to the document.
 *
 * @event ariaWidget
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @param {CKEDITOR.dom.element} data The element being added.
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview Justify commands.
 */

(function() {
	function getAlignment( element, useComputedState ) {
		useComputedState = useComputedState === undefined || useComputedState;

		var align;
		if ( useComputedState )
			align = element.getComputedStyle( 'text-align' );
		else {
			while ( !element.hasAttribute || !( element.hasAttribute( 'align' ) || element.getStyle( 'text-align' ) ) ) {
				var parent = element.getParent();
				if ( !parent )
					break;
				element = parent;
			}
			align = element.getStyle( 'text-align' ) || element.getAttribute( 'align' ) || '';
		}

		// Sometimes computed values doesn't tell.
		align && ( align = align.replace( /(?:-(?:moz|webkit)-)?(?:start|auto)/i, '' ) );

		!align && useComputedState && ( align = element.getComputedStyle( 'direction' ) == 'rtl' ? 'right' : 'left' );

		return align;
	}

	function justifyCommand( editor, name, value ) {
		this.editor = editor;
		this.name = name;
		this.value = value;
		this.context = 'p';

		var classes = editor.config.justifyClasses;
		if ( classes ) {
			switch ( value ) {
				case 'left':
					this.cssClassName = classes[ 0 ];
					break;
				case 'center':
					this.cssClassName = classes[ 1 ];
					break;
				case 'right':
					this.cssClassName = classes[ 2 ];
					break;
				case 'justify':
					this.cssClassName = classes[ 3 ];
					break;
			}

			this.cssClassRegex = new RegExp( '(?:^|\\s+)(?:' + classes.join( '|' ) + ')(?=$|\\s)' );
			this.requiredContent = 'p(' + this.cssClassName + ')';
		}
		else {
			this.requiredContent = 'p{text-align}';
		}

		this.allowedContent = {
			'caption div h1 h2 h3 h4 h5 h6 p pre td th li': {
				// Do not add elements, but only text-align style if element is validated by other rule.
				propertiesOnly: true,
				styles: this.cssClassName ? null : 'text-align',
				classes: this.cssClassName || null
			}
		};
	}

	function onDirChanged( e ) {
		var editor = e.editor;

		var range = editor.createRange();
		range.setStartBefore( e.data.node );
		range.setEndAfter( e.data.node );

		var walker = new CKEDITOR.dom.walker( range ),
			node;

		while ( ( node = walker.next() ) ) {
			if ( node.type == CKEDITOR.NODE_ELEMENT ) {
				// A child with the defined dir is to be ignored.
				if ( !node.equals( e.data.node ) && node.getDirection() ) {
					range.setStartAfter( node );
					walker = new CKEDITOR.dom.walker( range );
					continue;
				}

				// Switch the alignment.
				var classes = editor.config.justifyClasses;
				if ( classes ) {
					// The left align class.
					if ( node.hasClass( classes[ 0 ] ) ) {
						node.removeClass( classes[ 0 ] );
						node.addClass( classes[ 2 ] );
					}
					// The right align class.
					else if ( node.hasClass( classes[ 2 ] ) ) {
						node.removeClass( classes[ 2 ] );
						node.addClass( classes[ 0 ] );
					}
				}

				// Always switch CSS margins.
				var style = 'text-align';
				var align = node.getStyle( style );

				if ( align == 'left' )
					node.setStyle( style, 'right' );
				else if ( align == 'right' )
					node.setStyle( style, 'left' );
			}
		}
	}

	justifyCommand.prototype = {
		exec: function( editor ) {
			var selection = editor.getSelection(),
				enterMode = editor.config.enterMode;

			if ( !selection )
				return;

			var bookmarks = selection.createBookmarks(),
				ranges = selection.getRanges( true );

			var cssClassName = this.cssClassName,
				iterator, block;

			var useComputedState = editor.config.useComputedState;
			useComputedState = useComputedState === undefined || useComputedState;

			for ( var i = ranges.length - 1; i >= 0; i-- ) {
				iterator = ranges[ i ].createIterator();
				iterator.enlargeBr = enterMode != CKEDITOR.ENTER_BR;

				while ( ( block = iterator.getNextParagraph( enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' ) ) ) {
					block.removeAttribute( 'align' );
					block.removeStyle( 'text-align' );

					// Remove any of the alignment classes from the className.
					var className = cssClassName && ( block.$.className = CKEDITOR.tools.ltrim( block.$.className.replace( this.cssClassRegex, '' ) ) );

					var apply = ( this.state == CKEDITOR.TRISTATE_OFF ) && ( !useComputedState || ( getAlignment( block, true ) != this.value ) );

					if ( cssClassName ) {
						// Append the desired class name.
						if ( apply )
							block.addClass( cssClassName );
						else if ( !className )
							block.removeAttribute( 'class' );
					} else if ( apply )
						block.setStyle( 'text-align', this.value );
				}

			}

			editor.focus();
			editor.forceNextSelectionCheck();
			selection.selectBookmarks( bookmarks );
		},

		refresh: function( editor, path ) {
			var firstBlock = path.block || path.blockLimit;

			this.setState( firstBlock.getName() != 'body' && getAlignment( firstBlock, this.editor.config.useComputedState ) == this.value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );
		}
	};

	CKEDITOR.plugins.add( 'justify', {
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		icons: 'justifyblock,justifycenter,justifyleft,justifyright', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			if ( editor.blockless )
				return;

			var left = new justifyCommand( editor, 'justifyleft', 'left' ),
				center = new justifyCommand( editor, 'justifycenter', 'center' ),
				right = new justifyCommand( editor, 'justifyright', 'right' ),
				justify = new justifyCommand( editor, 'justifyblock', 'justify' );

			editor.addCommand( 'justifyleft', left );
			editor.addCommand( 'justifycenter', center );
			editor.addCommand( 'justifyright', right );
			editor.addCommand( 'justifyblock', justify );

			if ( editor.ui.addButton ) {
				editor.ui.addButton( 'JustifyLeft', {
					label: editor.lang.justify.left,
					command: 'justifyleft',
					toolbar: 'align,10'
				});
				editor.ui.addButton( 'JustifyCenter', {
					label: editor.lang.justify.center,
					command: 'justifycenter',
					toolbar: 'align,20'
				});
				editor.ui.addButton( 'JustifyRight', {
					label: editor.lang.justify.right,
					command: 'justifyright',
					toolbar: 'align,30'
				});
				editor.ui.addButton( 'JustifyBlock', {
					label: editor.lang.justify.block,
					command: 'justifyblock',
					toolbar: 'align,40'
				});
			}

			editor.on( 'dirChanged', onDirChanged );
		}
	});
})();

/**
 * List of classes to use for aligning the contents. If it's `null`, no classes will be used
 * and instead the corresponding CSS values will be used.
 *
 * The array should contain 4 members, in the following order: left, center, right, justify.
 *
 *		// Use the classes 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify'
 *		config.justifyClasses = [ 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify' ];
 *
 * @cfg {Array} [justifyClasses=null]
 * @member CKEDITOR.config
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview Undo/Redo system for saving shapshot for document modification
 *		and other recordable changes.
 */

(function() {
	CKEDITOR.plugins.add( 'undo', {
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		icons: 'redo,redo-rtl,undo,undo-rtl', // %REMOVE_LINE_CORE%
		init: function( editor ) {
			var undoManager = new UndoManager( editor );

			var undoCommand = editor.addCommand( 'undo', {
				exec: function() {
					if ( undoManager.undo() ) {
						editor.selectionChange();
						this.fire( 'afterUndo' );
					}
				},
				state: CKEDITOR.TRISTATE_DISABLED,
				canUndo: false,
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Set editorFocus to false as it causes jumpy scrolling after undo
				// Testing Considerations: Jumpy scrolling after undo/redo
				// ------------------------------------------------------------------------------------
				editorFocus: true
			});

			var redoCommand = editor.addCommand( 'redo', {
				exec: function() {
					if ( undoManager.redo() ) {
						editor.selectionChange();
						this.fire( 'afterRedo' );
					}
				},
				state: CKEDITOR.TRISTATE_DISABLED,
				canUndo: false,

				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Set editorFocus to false as it causes jumpy scrolling after undo
				// Testing Considerations: Jumpy scrolling after undo/redo
				// ------------------------------------------------------------------------------------
				editorFocus: true
			});

			editor.setKeystroke( [
				[ CKEDITOR.CTRL + 90 /*Z*/, 'undo' ],
				[ CKEDITOR.CTRL + 89 /*Y*/, 'redo' ],
				[ CKEDITOR.CTRL + CKEDITOR.SHIFT + 90 /*Z*/, 'redo' ]
				] );

			undoManager.onChange = function() {
				undoCommand.setState( undoManager.undoable() ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );
				redoCommand.setState( undoManager.redoable() ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );
			};

			function recordCommand( event ) {
				// If the command hasn't been marked to not support undo.
				if ( undoManager.enabled && event.data.command.canUndo !== false )
					undoManager.save();
			}

			// We'll save snapshots before and after executing a command.
			editor.on( 'beforeCommandExec', recordCommand );
			editor.on( 'afterCommandExec', recordCommand );

			// Save snapshots before doing custom changes.
			editor.on( 'saveSnapshot', function( evt ) {
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed:
				//   - Pass userData to `save` so that the consumer can attach data to the image
				//   - Pass freeze indicator to save so that the consumer can declare snapshot state to be 'frozen' and resistant to updates
				// (Used by tag clipboard)
				// ------------------------------------------------------------------------------------
				undoManager.save(evt.data && evt.data.contentOnly, undefined, undefined, evt.data && evt.data.userData, evt.data && evt.data.freeze);
			});

			// Registering keydown on every document recreation.(#3844)
			editor.on( 'contentDom', function() {
				editor.editable().on( 'keydown', function( event ) {
					// Do not capture CTRL hotkeys.
					if ( !event.data.$.ctrlKey && !event.data.$.metaKey )
						undoManager.type( event );
				});
			});

			// Always save an undo snapshot - the previous mode might have
			// changed editor contents.
			editor.on( 'beforeModeUnload', function() {
				editor.mode == 'wysiwyg' && undoManager.save( true );
			});

			// Make the undo manager available only in wysiwyg mode.
			editor.on( 'mode', function() {
				undoManager.enabled = editor.readOnly ? false : editor.mode == 'wysiwyg';
				undoManager.onChange();
			});

			if ( editor.ui.addButton ) {
				editor.ui.addButton( 'Undo', {
					label: editor.lang.undo.undo,
					command: 'undo',
					toolbar: 'undo,10'
				});

				editor.ui.addButton( 'Redo', {
					label: editor.lang.undo.redo,
					command: 'redo',
					toolbar: 'undo,20'
				});
			}

			/**
			 * Reset undo stack.
			 *
			 * @member CKEDITOR.editor
			 */
			editor.resetUndo = function() {
				// Reset the undo stack.
				undoManager.reset();

				// Create the first image.
				editor.fire( 'saveSnapshot', { freeze: true } );
			};

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Added isOnBaseSnapshot, iterateSnapshots, isOnFrozenSnapshot, getSnapshotText functions
			// ------------------------------------------------------------------------------------
			/**
			 * @member CKEDITOR.editor
			 * @returns {boolean} true if the current undo snapshot is the first snapshot
			 */
			editor.isOnBaseSnapshot = function() {
				return undoManager.index === 0;
			}

			/**
			 * Iterate through the snapshot stack calling snapshotCallback on each snapshot until the first
			 * @member CKEDITOR.editor
			 * @param snapshotCallback called for every snapshot in the stack until it returns true or no more snapshots
			 * @returns void
			 */
			editor.iterateSnapshots = function(snapshotCallback) {
				for(var i = undoManager.snapshots.length - 1; i >= 0; i--){
					if(snapshotCallback(undoManager.snapshots[i])){
						return;
					}
				}
			}

			/**
			 * @member CKEDITOR.editor
			 * @returns {boolean} true if the current undo snapshot is frozen
			 */
			editor.isOnFrozenSnapshot = function () {
			    return undoManager.currentImage && undoManager.currentImage.frozen;
			}

			/**
			 * @member CKEDITOR.editor
			 * @returns {string[]} Text value of current image if the current image is frozen
			 */
			editor.getSnapshotText = function () {
			    return undoManager.currentImage ? undoManager.currentImage.text : undefined;
			}

			/**
			 * Amend the top of undo stack (last undo image) with the current DOM changes.
			 *
			 *		function() {
			 *			editor.fire( 'saveSnapshot' );
			 *			editor.document.body.append(...);
			 *			// Make new changes following the last undo snapshot part of it.
			 *			editor.fire( 'updateSnapshot' );
			 *			..
			 *		}
			 *
			 * @event updateSnapshot
			 * @member CKEDITOR.editor
			 * @param {CKEDITOR.editor} editor This editor instance.
			 */
			editor.on( 'updateSnapshot', function( evt ) {
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Pass userData to `update` so that the consumer can merge attached
				// data to the image (Used by tag clipboard)
				// ------------------------------------------------------------------------------------
				if ( undoManager.currentImage )
					undoManager.update( evt.data && evt.data.userData, evt.data && evt.data.userDataMergeCallback );
			});

			/**
			 * Lock manager to prevent any save/update operations.
			 *
			 * It's convenient to lock manager before doing DOM operations
			 * that shouldn't be recored (e.g. auto paragraphing).
			 *
			 * See {@link CKEDITOR.plugins.undo.UndoManager#lock} for more details.
			 *
			 * @since 4.0
			 * @event lockSnapshot
			 * @member CKEDITOR.editor
			 * @param {CKEDITOR.editor} editor This editor instance.
			 */
			editor.on( 'lockSnapshot', undoManager.lock, undoManager );

			/**
			 * Unlock manager and update latest snapshot.
			 *
			 * @since 4.0
			 * @event unlockSnapshot
			 * @member CKEDITOR.editor
			 * @param {CKEDITOR.editor} editor This editor instance.
			 */
			editor.on( 'unlockSnapshot', undoManager.unlock, undoManager );
		}
	});

	CKEDITOR.plugins.undo = {};

	/**
	 * Undo snapshot which represents the current document status.
	 *
	 * @private
	 * @class CKEDITOR.plugins.undo.Image
	 * @constructor Creates an Image class instance.
	 * @param {CKEDITOR.editor} editor The editor instance on which the image is created.
	 */
	var Image = CKEDITOR.plugins.undo.Image = function( editor ) {
			this.editor = editor;

			editor.fire( 'beforeUndoImage' );

			var contents = editor.getSnapshot(),
				selection = contents && editor.getSelection();

			// In IE, we need to remove the expando attributes.
			CKEDITOR.env.ie && contents && ( contents = contents.replace( /\s+data-cke-expando=".*?"/g, '' ) );

			this.contents = contents;
			this.bookmarks = selection && selection.createBookmarks2( true );

			editor.fire( 'afterUndoImage' );
		};

	// Attributes that browser may changing them when setting via innerHTML.
	var protectedAttrs = /\b(?:href|src|name)="[^"]*?"/gi;

	Image.prototype = {
		equals: function( otherImage, contentOnly ) {

			var thisContents = this.contents,
				otherContents = otherImage.contents;

			// For IE6/7 : Comparing only the protected attribute values but not the original ones.(#4522)
			if ( CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.ie6Compat ) ) {
				thisContents = thisContents.replace( protectedAttrs, '' );
				otherContents = otherContents.replace( protectedAttrs, '' );
			}

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: User data makes an image unique, aside from its contents.
			// ------------------------------------------------------------------------------------
			if ( this !== otherImage && (this.userData || otherImage.userData) )
				if ( this.userData !== otherImage.userData )
					return false;

			if ( thisContents != otherContents )
				return false;

			if ( contentOnly )
				return true;

			var bookmarksA = this.bookmarks,
				bookmarksB = otherImage.bookmarks;

			if ( bookmarksA || bookmarksB ) {
				if ( !bookmarksA || !bookmarksB || bookmarksA.length != bookmarksB.length )
					return false;

				for ( var i = 0; i < bookmarksA.length; i++ ) {
					var bookmarkA = bookmarksA[ i ],
						bookmarkB = bookmarksB[ i ];

					if ( bookmarkA.startOffset != bookmarkB.startOffset || bookmarkA.endOffset != bookmarkB.endOffset || !CKEDITOR.tools.arrayCompare( bookmarkA.start, bookmarkB.start ) || !CKEDITOR.tools.arrayCompare( bookmarkA.end, bookmarkB.end ) ) {
						return false;
					}
				}
			}

			return true;
		}
	};

	/**
	 * Main logic for Redo/Undo feature.
	 *
	 * **Note:** This class isn't accessible from the global scope.
	 *
	 * @private
	 * @class CKEDITOR.plugins.undo.UndoManager
	 * @constructor Creates an UndoManager class instance.
	 * @param {CKEDITOR.editor} editor
	 */
	function UndoManager( editor ) {
		this.editor = editor;

		// Reset the undo stack.
		this.reset();

		var manager = this;
		this.editor.setUndoUpdateHandler = function( func ) {
			manager.updateHandler = func;
		};
	}

    // ------------------------------------------------------------------------------------
    // ***DYNAMIC DOCUMENTATION CHANGE***
    // What Changed:
    //   - Added Page Up, Page Down ,End ,Home key codes in navigation keycodes set
    // ------------------------------------------------------------------------------------
    var editingKeyCodes = { /*Backspace*/8: 1,/*Delete*/46: 1 },
        modifierKeyCodes = { /*Shift*/16: 1,/*Ctrl*/17: 1,/*Alt*/18: 1 },
	    navigationKeyCodes = { /*Page Up*/33: 1, /*Page Down*/34: 1,/*End*/35: 1,/*Home*/36: 1, 37: 1, 38: 1, 39: 1, 40: 1 }; // Arrows: L, T, R, B

	UndoManager.prototype = {
		/**
		 * When `locked` property is not `null` manager is locked, so
		 * operations like `save` or `update` are forbidden.
		 *
		 * Manager can be locked/unlocked by {@link #lock} and {@link #unlock} methods.
		 *
		 * @private
		 * @property {Object} [locked=null]
		 */

		/**
		 * Process undo system regard keystrikes.
		 * @param {CKEDITOR.dom.event} event
		 */
		type: function( event ) {
			var keystroke = event && event.data.getKey(),
				isModifierKey = keystroke in modifierKeyCodes,
				isEditingKey = keystroke in editingKeyCodes,
				wasEditingKey = this.lastKeystroke in editingKeyCodes,
				sameAsLastEditingKey = isEditingKey && keystroke == this.lastKeystroke,
				// Keystrokes which navigation through contents.
				isReset = keystroke in navigationKeyCodes,
				wasReset = this.lastKeystroke in navigationKeyCodes,

				// Keystrokes which just introduce new contents.
				isContent = ( !isEditingKey && !isReset ),

				// Create undo snap for every different modifier key.
				modifierSnapshot = ( isEditingKey && !sameAsLastEditingKey ),
				// Create undo snap on the following cases:
				// 1. Just start to type .
				// 2. Typing some content after a modifier.
				// 3. Typing some content after make a visible selection.
				startedTyping = !( isModifierKey || this.typing ) || ( isContent && ( wasEditingKey || wasReset ) );
	        
            // ----------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			//Issue:Navigation keys are causing issue and undo snapshot is lost
			//1.Remove section which is having cursor.
			//2.Remove couple of more section and click undo
			//3. Use any of the navigational keys End or down arrow
			// ----------------------------------------------------------
		    if ((keystroke===9 && !this.editor.config.tabSpaces) || isReset)
		        startedTyping = false;
			
			if ( startedTyping || modifierSnapshot ) {
				var beforeTypeImage = new Image( this.editor ),
					beforeTypeCount = this.snapshots.length;

				// Use setTimeout, so we give the necessary time to the
				// browser to insert the character into the DOM.
				CKEDITOR.tools.setTimeout( function() {
					var currentSnapshot = this.editor.getSnapshot();

					// In IE, we need to remove the expando attributes.
					if ( CKEDITOR.env.ie )
						currentSnapshot = currentSnapshot.replace( /\s+data-cke-expando=".*?"/g, '' );

					// If changes have taken place, while not been captured yet (#8459),
					// compensate the snapshot.
					if ( beforeTypeImage.contents != currentSnapshot && beforeTypeCount == this.snapshots.length ) {
						// It's safe to now indicate typing state.
						this.typing = true;

						// This's a special save, with specified snapshot
						// and without auto 'fireChange'.
						if ( !this.save( false, beforeTypeImage, false ) ) {
							// Drop future snapshots.
							var droppedSnapshots = this.snapshots.splice( this.index + 1, this.snapshots.length - this.index - 1 );
							if ( droppedSnapshots.length ) {
								this.editor.fire( 'snapshotsDropped', {
									droppedSnapshots: droppedSnapshots
								} );
							}
						}

						this.hasUndo = true;
						this.hasRedo = false;

						this.typesCount = 1;
						this.modifiersCount = 1;

						this.onChange();
					}
				}, 0, this );
			}

			this.lastKeystroke = keystroke;

			// Create undo snap after typed too much (over 25 times).
			if ( isEditingKey ) {
				this.typesCount = 0;
				this.modifiersCount++;

				if ( this.modifiersCount > 25 ) {
					this.save( false, null, false );
					this.modifiersCount = 1;
				}
			} else if ( !isReset ) {
				this.modifiersCount = 0;
				this.typesCount++;

				if ( this.typesCount > 25 ) {
					this.save( false, null, false );
					this.typesCount = 1;
				}
			}
		},

		/**
		 * Reset the undo stack.
		 */
		reset: function() {
			// Remember last pressed key.
			this.lastKeystroke = 0;

			// Stack for all the undo and redo snapshots, they're always created/removed
			// in consistency.
			this.snapshots = [];

			// Current snapshot history index.
			this.index = -1;

			this.limit = this.editor.config.undoStackSize || 20;

			this.currentImage = null;

			this.hasUndo = false;
			this.hasRedo = false;
			this.locked = null;

			this.resetType();
		},

		/**
		 * Reset all states about typing.
		 *
		 * @see #type
		 */
		resetType: function() {
			this.typing = false;
			delete this.lastKeystroke;
			this.typesCount = 0;
			this.modifiersCount = 0;
		},

		fireChange: function() {
			this.hasUndo = !!this.getNextImage( true );
			this.hasRedo = !!this.getNextImage( false );
			// Reset typing
			this.resetType();
			this.onChange();
		},

		// ------------------------------------------------------------------------------------
		// ***DYNAMIC DOCUMENTATION CHANGE***
		// What Changed:
		//   - Added userData parameter to `save` method
		//   - Added freeze parameter to save method
		// This allows us to save consumer-specified data (to support tag and clipboard).
		// ------------------------------------------------------------------------------------
		/**
		 * Save a snapshot of document image for later retrieve.
		 */
		save: function( onContentOnly, image, autoFireChange, userData, freeze) {
			// Do not change snapshots stack when locked.
			if ( this.locked )
				return false;

			var disallowDuplicates = !userData;

			var snapshots = this.snapshots;

			// Get a content image.
			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: Added try-catch.
			// CKEDITOR.dom.text.getLength in core/dom/text.js will throw an
			// exception from nodeValue being invalid.
			// Testing Considerations:
			// 1. Type words into a free text area
			// 2. Change the middle word to become misspelled, therefore underlined.
			// 3. Put the cursor to the end of the word.
			// 4. Type a  space after the word
			// 5. Type another letter.
			// 6. Backspace
			// ------------------------------------------------------------------------------------
			try {
				if ( !image )
					image = new Image( this.editor );
			}
			catch ( e ) {
				// Exception is thrown from new Image if the saved CKEditor DOM has a bad node.
				// Do not pass go, do not save snapshot.
				return false;
			}

			// Do nothing if it was not possible to retrieve an image.
			if ( image.contents === false )
				return false;

			// Check if this is a duplicate. In such case, do nothing.
			if ( disallowDuplicates && this.currentImage ) {
				// ------------------------------------------------------------------------------------
				// ***DYNAMIC DOCUMENTATION CHANGE***
				// What Changed: Don't use "id" and "class" attributes while comparing snapshots. We don't include ids
				// because every time an EMR content is refreshed, their ids are reset even if the contents are same, creates an
				// unnecessary snapshot on the undo stack in such case. We don't use "class" because we don't want 'ddinfocus' to create
				// unnecessary snapshots on the undo stack (we don't update snapshots with ddinfocus in toggleCSS)
				// Testing Considerations: Extra unnecessary snapshots with undo/redo
				//  1. Remove a section with content that is still loading.
				//  2. The background thread completes.
				//  3. Undo.
				// The section comes back in, instead of showing the loading image it shows the content returned by the background thread.
				// ------------------------------------------------------------------------------------
				var truncatedImage = image.contents.replace(/\s*id\s*=_?[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/g, '');
				truncatedImage = truncatedImage.replace(/\s*class\s*="[^"]*"/g, '');
				truncatedImage = truncatedImage.replace(/\s*class\s*=[^\s>]*/g, '');

				// ***DYNAMIC DOCUMENTATION CHANGE***
				// Don't use "id" and "class" attributes while comparing snapshots.
				var truncatedCurImage = this.currentImage.contents.replace(/\s*id\s*=_?[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}/g, '');
				truncatedCurImage = truncatedCurImage.replace(/\s*class\s*="[^"]*"/g, '');
				truncatedCurImage = truncatedCurImage.replace(/\s*class\s*=[^\s>]*/g, '');

				if (truncatedImage == truncatedCurImage) {
					if (freeze === true) {
						this.currentImage.frozen = true;
					}
					return false;
				}
			}

			image.userData = userData;

			// ----------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: keep track of dropped snapshots and
			// when we've reached the max limit for undo snapshots
			// ----------------------------------------------------------

			// Drop future snapshots.
			var droppedSnapshots = snapshots.splice(this.index + 1, snapshots.length - this.index - 1);
			if (droppedSnapshots.length) {
				this.editor.fire('snapshotsDropped', {
					droppedSnapshots: droppedSnapshots
				});
			}

			// If we have reached the limit, remove the oldest one.
			if (snapshots.length == this.limit) {
				var droppedSnapshot = snapshots.shift();

				this.editor.fire('snapshotsDropped', {
					droppedSnapshots: [droppedSnapshot]
				});
			}

			// Add the new image, updating the current index.
			this.index = snapshots.push( image ) - 1;

			this.currentImage = image;

			// ***DYNAMIC DOCUMENTATION CHANGE***
			image.frozen = freeze;
			if (image.frozen) {
				image.text = {};
				if (this.updateHandler) {
					this.updateHandler(this.editor);
				}
			}

			if ( autoFireChange !== false )
				this.fireChange();
			return true;
		},

		restoreImage: function( image ) {
			// Bring editor focused to restore selection.
			var editor = this.editor,
				sel;

			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed:  Fire event before and after loading a snapshot into the editor
			//                (and after selecting bookmarks in the snapshot image).
			// ------------------------------------------------------------------------------------

			var direction = this.editor.redoing ? 1 : -1;
			editor.fire('beforeRestoreImage', {
				beforeImage: this.currentImage,
				afterImage:  image,
				direction:   direction
			});

			if ( image.bookmarks ) {
				editor.focus();
				// Retrieve the selection beforehand. (#8324)
				sel = editor.getSelection();
			}

			// Start transaction - do not allow any mutations to the
			// snapshots stack done when selecting bookmarks (much probably
			// by selectionChange listener).
			this.locked = 1;

			this.editor.loadSnapshot( image.contents );

			if (image.bookmarks) {
			    sel.selectBookmarks(image.bookmarks);
			    // ------------------------------------------------------------------------------------
			    // ***DYNAMIC DOCUMENTATION CHANGE***
			    // What Changed: Scroll to the cursor position after undo/redo
			    // Testing Considerations: Jumpy scrolling after undo/redo
			    // ------------------------------------------------------------------------------------
			    sel.scrollIntoView();
			    editor.focus();
			}
			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: Remove "else if" logic to avoid jumpy scrolling after undo
			// Testing Considerations: Jumpy scrolling after undo/redo
			// ------------------------------------------------------------------------------------
			//else if (CKEDITOR.env.ie) {
			// IE BUG: If I don't set the selection to *somewhere* after setting
			// document contents, then IE would create an empty paragraph at the bottom
			// the next time the document is modified.
			//	var $range = this.editor.document.getBody().$.createTextRange();
			//	$range.collapse(true);
			//	$range.select();
			//}

			this.locked = 0;

			this.index = image.index;

			// Update current image with the actual editor
			// content, since actualy content may differ from
			// the original snapshot due to dom change. (#4622)
			this.update();
			this.fireChange();

			this.editor.fire('afterRestoreImage', {
				afterImage: image,
				direction:  direction
			});
		},

		// Get the closest available image.
		getNextImage: function( isUndo ) {
			var snapshots = this.snapshots,
				currentImage = this.currentImage,
				image, i;

			if ( currentImage ) {
				if ( isUndo ) {
					for ( i = this.index - 1; i >= 0; i-- ) {
						image = snapshots[ i ];
						if ( !currentImage.equals( image, true ) ) {
							image.index = i;
							return image;
						}
					}
				} else {
					for ( i = this.index + 1; i < snapshots.length; i++ ) {
						image = snapshots[ i ];
						if ( !currentImage.equals( image, true ) ) {
							image.index = i;
							return image;
						}
					}
				}
			}

			return null;
		},

		/**
		 * Check the current redo state.
		 *
		 * @returns {Boolean} Whether the document has previous state to retrieve.
		 */
		redoable: function() {
			return this.enabled && this.hasRedo;
		},

		/**
		 * Check the current undo state.
		 *
		 * @returns {Boolean} Whether the document has future state to restore.
		 */
		undoable: function() {
			return this.enabled && this.hasUndo;
		},

		/**
		 * Perform undo on current index.
		 */
		undo: function() {
			if ( this.undoable() ) {
				this.editor.undoing = true;
				this.editor.redoing = false;

				try {
					this.save( true );

					var image = this.getNextImage( true );
					if ( image )
						return this.restoreImage( image ), true;
				}
				finally {
					this.editor.undoing = false;
				}
			}

			return false;
		},

		/**
		 * Perform redo on current index.
		 */
		redo: function() {
			if ( this.redoable() ) {
				this.editor.redoing = true;
				this.editor.undoing = false;

				try {
					// Try to save. If no changes have been made, the redo stack
					// will not change, so it will still be redoable.
					this.save( true );

					// If instead we had changes, we can't redo anymore.
					if ( this.redoable() ) {
						var image = this.getNextImage( false );
						if ( image )
							return this.restoreImage( image ), true;
					}
				}
				finally {
					this.editor.redoing = false;
				}
			}

			return false;
		},

		/**
		 * Update the last snapshot of the undo stack with the current editor content.
		 */
		update: function( userData, userDataMergeCallback ) {
			// ------------------------------------------------------------------------------------
			// ***DYNAMIC DOCUMENTATION CHANGE***
			// What Changed: When image is re-created, attach the old image's userData to the new
			//               image, or merge new userData with old userData
			//
			// Testing Considerations:
			//  1. Drag multiple items from the tag clipboard to the editor.
			//  2. Undo multiple times.
			// ------------------------------------------------------------------------------------
			// Do not change snapshots stack is locked.
			if ( !this.locked ) {
				this.currentImage = new Image( this.editor );
				var oldImage = this.snapshots[this.index];

				var updatedUserData = undefined;
				if ( userData && oldImage && oldImage.userData ) {
					// Two images have userData, merge them together using the provided callback
					if ( userDataMergeCallback && userDataMergeCallback.apply )
						updatedUserData = userDataMergeCallback( oldImage.userData, userData );
					else
						updatedUserData = userData;
				}
				else if ( userData )  // Use new image userData
					updatedUserData = userData;
				else if ( oldImage && oldImage.userData ) // Use old image userData
					updatedUserData = oldImage.userData;
				this.currentImage.userData = updatedUserData;

				this.currentImage.frozen = oldImage.frozen;
				this.currentImage.text = oldImage.text;

				this.snapshots.splice( this.index, 1, this.currentImage );
			}
		},

		/**
		 * Lock the snapshot stack to prevent any save/update operations, and additionally
		 * update the tip snapshot with the DOM changes during the locked period when necessary,
		 * after the {@link #unlock} method is called.
		 *
		 * It's mainly used for ensure any DOM operations that shouldn't be recorded (e.g. auto paragraphing).
		 *
		 * @since 4.0
		 */
		lock: function() {
			if ( !this.locked ) {
				var snapBefore = this.editor.getSnapshot();

				// If current editor content matches the tip of snapshot stack,
				// the stack tip must be updated by unlock, to include any changes made
				// during this period.
				var matchedTip = this.currentImage && snapBefore == this.currentImage.contents;

				this.locked = { update: matchedTip ? snapBefore : null };
			}
		},

		/**
		 * Unlock the snapshot stack and check to amend the last snapshot.
		 *
		 * See {@link #lock} for more details.
		 *
		 * @since 4.0
		 */
		unlock: function() {
			if ( this.locked ) {
				var update = this.locked.update,
					snap = this.editor.getSnapshot();

				this.locked = null;

				if ( typeof update == 'string' && snap != update )
					this.update();
			}
		}
	};
})();

/**
 * The number of undo steps to be saved. The higher this setting value the more
 * memory is used for it.
 *
 *		config.undoStackSize = 50;
 *
 * @cfg {Number} [undoStackSize=20]
 * @member CKEDITOR.config
 */

/**
 * Fired when the editor is about to save an undo snapshot. This event can be
 * fired by plugins and customizations to make the editor saving undo snapshots.
 *
 * @event saveSnapshot
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 */

/**
 * Fired before an undo image is to be taken. An undo image represents the
 * editor state at some point. It's saved into an undo store, so the editor is
 * able to recover the editor state on undo and redo operations.
 *
 * @since 3.5.3
 * @event beforeUndoImage
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @see CKEDITOR.editor#afterUndoImage
 */

/**
 * Fired after an undo image is taken. An undo image represents the
 * editor state at some point. It's saved into an undo store, so the editor is
 * able to recover the editor state on undo and redo operations.
 *
 * @since 3.5.3
 * @event afterUndoImage
 * @member CKEDITOR.editor
 * @param {CKEDITOR.editor} editor This editor instance.
 * @see CKEDITOR.editor#beforeUndoImage
 */

CKEDITOR.plugins.add('cernundo', {
    init:  function(editor) {
        if (editor.setUndoUpdateHandler) {
            editor.setUndoUpdateHandler(this.updateFreeText.bind(this));
        }

        // Assign missing IDs before saving any snapshot
        editor.on('saveSnapshot', function (event) {
            if (typeof CKEDITOR.DocUtilsHelper !== 'undefined') {
                $(editor.editable().$).find('.ddfreetext').each(function () {
                    if (!$(this).attr('id')) {
                        $(this).attr('id', CKEDITOR.DocUtilsHelper.GenerateGUID());
                    }
                });
            }
        }, undefined, undefined, -1); // Execute listener first
    },

    handleBaseSnapshot:  function(editor) {
        if (!editor.getCommand('redo'))
            return;

        var plugin = this;

        this.updateFreeText(editor);

        // Save initial freetext that are loaded during the base snapshot
        var emrListener = editor.on(DDCMD_CONTENTHTMLLOADED, function(event) {
            var $emr = $('#' + event.data.activityId);
            plugin.updateFreeText(editor);
        }, undefined, undefined, /* Highest priority: */ -1);
        // When the refresh state becomes stable, we've saved all the initial freetext content
        var refreshStateListener = editor.on('refreshStateChange', function() {
            if (editor.refreshState === 'stable') {
                emrListener.removeListener();
                refreshStateListener.removeListener();
            }
        });

        function areFreetextSameAsFrozen() {
            var bSame = true;
            $(editor.editable().$).find('.ddfreetext').each(function (_, ddfreetext) {
                var id = $(ddfreetext).attr('id');
                if (editor.getSnapshotText().hasOwnProperty(id)) {
                    if (ddfreetext.innerText !== editor.getSnapshotText()[id]) {
                        bSame = false;
                        return false;  // break
                    }
                }
                else {
                    if (ddfreetext.innerText.length) {
                        bSame = false;
                        return false;  // break
                    }
                }
            });
            return bSame;
        }

        // data to live on each frozen snapshot
        editor.on('updateSnapshot', function (event) {

            var isSnapshotFrozen = editor.isOnFrozenSnapshot && editor.isOnFrozenSnapshot();

            // Don't convert forced updates
            if (event.data && event.data.overrideFrozen) {
                if (isSnapshotFrozen)
                    plugin.updateFreeText(event.editor);
                return;
            }

            // Let special snapshots pass through as an update
            if (event.data && event.data.userData)
                return;

            // Convert an update to a save iff we are currently on the base snapshot
            // Don't convert update type if changes are transient
            if (isSnapshotFrozen && !areFreetextSameAsFrozen()) {

                // Convert updateSnapshot to saveSnapshot
                event.cancel();
                editor.fire('saveSnapshot', event.data);
            }
        }, undefined, undefined, /* Highest priority: */ -1);
    },

    updateFreeText: function (editor) {
        if (!editor.getSnapshotText())
            return;

        $(editor.editable().$).find('.ddfreetext').each(function (_, ddfreetext) {
            var id = $(ddfreetext).attr('id');
            if (id) {
                editor.getSnapshotText()[id] = ddfreetext.innerText;
            }
        });
    }
});

/*
 * @file change event plugin for CKEditor
 * Copyright (C) 2011 Alfonso Martnez de Lizarrondo
 *
 * == BEGIN LICENSE ==
 *
 * Licensed under the terms of any of the following licenses at your
 * choice:
 *
 *  - GNU General Public License Version 2 or later (the "GPL")
 *    http://www.gnu.org/licenses/gpl.html
 *
 *  - GNU Lesser General Public License Version 2.1 or later (the "LGPL")
 *    http://www.gnu.org/licenses/lgpl.html
 *
 *  - Mozilla Public License Version 1.1 or later (the "MPL")
 *    http://www.mozilla.org/MPL/MPL-1.1.html
 *
 * == END LICENSE ==
 *
 */

 // Keeps track of changes to the content and fires a "change" event
CKEDITOR.plugins.add( 'onchange',
{
	init : function( editor )
	{
//		// Test:
//		editor.on( 'change', function(e) { console.log( e ) });

		var timer,
			theMutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
			observer;
// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#mutation-observers
// http://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/

		// Avoid firing the event too often
		function somethingChanged()
		{
			// don't fire events if the editor is readOnly as they are false detections
			if (editor.readOnly)
				return;

			if (timer)
				return;

			timer = setTimeout( function() {
				timer = 0;
				editor.fire( 'change' );
			}, editor.config.minimumChangeMilliseconds || 100);
		}
		// Kill the timer on editor destroy
		editor.on( 'destroy', function() { if ( timer ) clearTimeout( timer ); timer = null; });

		// in theory this block should be enabled only for browsers that don't support MutationObservers,
		// but it doesn't seem to fire correctly in all the situations. Maybe in the future...
		{
			// Set several listeners to watch for changes to the content
			editor.on( 'saveSnapshot', function( evt )
			{
				if ( !evt.data || !evt.data.contentOnly )
					somethingChanged();
			});

			var undoCmd = editor.getCommand('undo');
			undoCmd && undoCmd.on( 'afterUndo', somethingChanged);
			var redoCmd = editor.getCommand('redo');
			redoCmd && redoCmd.on( 'afterRedo', somethingChanged);

			editor.on( 'afterCommandExec', function( event )
			{
				if ( event.data.name == 'source' )
					return;

				if ( event.data.command.canUndo !== false )
					somethingChanged();
			} );
		}

		if ( theMutationObserver )
		{
			observer = new theMutationObserver( function( mutations ) {
				somethingChanged();
			} );

			// To check that we are using a cool browser.
			if (window.console && window.console.log)
				console.log("Detecting changes using MutationObservers");
		}

		// Changes in WYSIWYG mode
		editor.on( 'contentDom', function()
			{
				if ( observer )
				{
					// A notification is fired right now, but we don't want it so soon
					setTimeout( function() {
						observer.observe( editor.document.getBody().$, {
							attributes: true,
							childList: true,
							characterData: true
						  });
					}, 100);
				}

				editor.document.on( 'keydown', function( event )
					{
						// Do not capture CTRL hotkeys.
						if ( event.data.$.ctrlKey ||event.data.$.metaKey )
							return;

						var keyCode = event.data.$.keyCode;
						// Filter movement keys and related
						if (keyCode==8 || keyCode == 13 || keyCode == 32 || ( keyCode >= 46 && keyCode <= 90) || ( keyCode >= 96 && keyCode <= 111) || ( keyCode >= 186 && keyCode <= 222) || keyCode == 229)
							somethingChanged();
					});

					// Firefox OK
				editor.document.on( 'drop', somethingChanged);
					// IE OK
				editor.document.getBody().on( 'drop', somethingChanged);
			});

		// Detect changes in source mode
		editor.on( 'mode', function( e )
			{
				if ( editor.mode != 'source' )
					return;

				var textarea = (editor.textarea || editor._.editable);
				textarea.on( 'keydown', function( event )
					{
						// Do not capture CTRL hotkeys.
						if ( !event.data.$.ctrlKey && !event.data.$.metaKey )
							somethingChanged();
					});

				textarea.on( 'drop', somethingChanged);
				textarea.on( 'input', somethingChanged);
				if (CKEDITOR.env.ie)
				{
					textarea.on( 'cut', somethingChanged);
					textarea.on( 'paste', somethingChanged);
				}
			});

	} //Init
} );

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview The "divarea" plugin. It registers the "wysiwyg" editing
 *		mode using a DIV element.
 */

CKEDITOR.plugins.add( 'divarea', {
	afterInit: function( editor ) {
		// Add the "wysiwyg" mode.
		// Do that in the afterInit function, so it'll eventually overwrite
		// the mode defined by the wysiwygarea plugin.
		editor.addMode( 'wysiwyg', function( callback ) {
			var editingBlock = CKEDITOR.dom.element.createFromHtml( '<div class="cke_wysiwyg_div cke_reset" hidefocus="true"></div>' );

			var contentSpace = editor.ui.space( 'contents' );
			contentSpace.append( editingBlock );

			editingBlock = editor.editable( editingBlock );

			editingBlock.detach = CKEDITOR.tools.override( editingBlock.detach,
				function( org ) {
					return function() {
						org.apply( this, arguments );
						this.remove();
					};
				});

			editor.setData( editor.getData( 1 ), callback );
			editor.fire( 'contentDom' );
		});
	}
});

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview Defines the {@link CKEDITOR.xml} class, which represents a
 *		loaded XML document.
 */

(function() {
	CKEDITOR.plugins.add( 'xml', {} );

	/**
	 * Represents a loaded XML document.
	 *
	 *		var xml = new CKEDITOR.xml( '<books><book title="My Book" /></books>' );
	 *
	 * @class
	 * @constructor Creates xml class instance.
	 * @param {Object/String} xmlObjectOrData A native XML (DOM document) object or
	 * a string containing the XML definition to be loaded.
	 */
	CKEDITOR.xml = function( xmlObjectOrData ) {
		var baseXml = null;

		if ( typeof xmlObjectOrData == 'object' )
			baseXml = xmlObjectOrData;
		else {
			var data = ( xmlObjectOrData || '' ).replace( /&nbsp;/g, '\xA0' );
			if ( window.DOMParser )
				baseXml = ( new DOMParser() ).parseFromString( data, 'text/xml' );
			else if ( window.ActiveXObject ) {
				try {
					baseXml = new ActiveXObject( 'MSXML2.DOMDocument' );
				} catch ( e ) {
					try {
						baseXml = new ActiveXObject( 'Microsoft.XmlDom' );
					} catch ( e ) {}
				}

				if ( baseXml ) {
					baseXml.async = false;
					baseXml.resolveExternals = false;
					baseXml.validateOnParse = false;
					baseXml.loadXML( data );
				}
			}
		}

		/**
		 * The native XML (DOM document) used by the class instance.
		 */
		this.baseXml = baseXml;
	};

	CKEDITOR.xml.prototype = {
		/**
		 * Get a single node from the XML document, based on a XPath query.
		 *
		 *		// Create the XML instance.
		 *		var xml = new CKEDITOR.xml( '<list><item id="test1" /><item id="test2" /></list>' );
		 *		// Get the first <item> node.
		 *		var itemNode = <b>xml.selectSingleNode( 'list/item' )</b>;
		 *		// Alert "item".
		 *		alert( itemNode.nodeName );
		 *
		 * @param {String} xpath The XPath query to execute.
		 * @param {Object} [contextNode] The XML DOM node to be used as the context
		 * for the XPath query. The document root is used by default.
		 * @returns {Object} A XML node element or null if the query has no results.
		 */
		selectSingleNode: function( xpath, contextNode ) {
			var baseXml = this.baseXml;

			if ( contextNode || ( contextNode = baseXml ) ) {
				if ( CKEDITOR.env.ie || contextNode.selectSingleNode ) // IE
				return contextNode.selectSingleNode( xpath );
				else if ( baseXml.evaluate ) // Others
				{
					var result = baseXml.evaluate( xpath, contextNode, null, 9, null );
					return ( result && result.singleNodeValue ) || null;
				}
			}

			return null;
		},

		/**
		 * Gets a list node from the XML document, based on a XPath query.
		 *
		 *		// Create the XML instance.
		 *		var xml = new CKEDITOR.xml( '<list><item id="test1" /><item id="test2" /></list>' );
		 *		// Get the first <item> node.
		 *		var itemNodes = xml.selectSingleNode( 'list/item' );
		 *		// Alert "item" twice, one for each <item>.
		 *		for ( var i = 0 ; i < itemNodes.length ; i++ )
		 *			alert( itemNodes[i].nodeName );
		 *
		 * @param {String} xpath The XPath query to execute.
		 * @param {Object} [contextNode] The XML DOM node to be used as the context
		 * for the XPath query. The document root is used by default.
		 * @returns {Array} An array containing all matched nodes. The array will
		 * be empty if the query has no results.
		 */
		selectNodes: function( xpath, contextNode ) {
			var baseXml = this.baseXml,
				nodes = [];

			if ( contextNode || ( contextNode = baseXml ) ) {
				if ( CKEDITOR.env.ie || contextNode.selectNodes ) // IE
				return contextNode.selectNodes( xpath );
				else if ( baseXml.evaluate ) // Others
				{
					var result = baseXml.evaluate( xpath, contextNode, null, 5, null );

					if ( result ) {
						var node;
						while ( ( node = result.iterateNext() ) )
							nodes.push( node );
					}
				}
			}

			return nodes;
		},

		/**
		 * Gets the string representation of hte inner contents of a XML node,
		 * based on a XPath query.
		 *
		 *		// Create the XML instance.
		 *		var xml = new CKEDITOR.xml( '<list><item id="test1" /><item id="test2" /></list>' );
		 *		// Alert "<item id="test1" /><item id="test2" />".
		 *		alert( xml.getInnerXml( 'list' ) );
		 *
		 * @param {String} xpath The XPath query to execute.
		 * @param {Object} [contextNode] The XML DOM node to be used as the context
		 * for the XPath query. The document root is used by default.
		 * @returns {String} The textual representation of the inner contents of
		 * the node or null if the query has no results.
		 */
		getInnerXml: function( xpath, contextNode ) {
			var node = this.selectSingleNode( xpath, contextNode ),
				xml = [];
			if ( node ) {
				node = node.firstChild;
				while ( node ) {
					if ( node.xml ) // IE
					xml.push( node.xml );
					else if ( window.XMLSerializer ) // Others
					xml.push( ( new XMLSerializer() ).serializeToString( node ) );

					node = node.nextSibling;
				}
			}

			return xml.length ? xml.join( '' ) : null;
		}
	};
})();

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'menubutton', {
	requires: 'button,menu',
	onLoad: function() {
		var clickFn = function( editor ) {
				var _ = this._;

				// Do nothing if this button is disabled.
				if ( _.state === CKEDITOR.TRISTATE_DISABLED )
					return;

				_.previousState = _.state;

				// Check if we already have a menu for it, otherwise just create it.
				var menu = _.menu;
				if ( !menu ) {
					menu = _.menu = new CKEDITOR.menu( editor, {
						panel: {
							className: 'cke_menu_panel',
							attributes: { 'aria-label': editor.lang.common.options }
						}
					});

					menu.onHide = CKEDITOR.tools.bind( function() {
						this.setState( this.modes && this.modes[ editor.mode ] ? _.previousState : CKEDITOR.TRISTATE_DISABLED );
					}, this );

					// Initialize the menu items at this point.
					if ( this.onMenu )
						menu.addListener( this.onMenu );
				}

				if ( _.on ) {
					menu.hide();
					return;
				}

				this.setState( CKEDITOR.TRISTATE_ON );

				// This timeout is needed to give time for the panel get focus
				// when JAWS is running. (#9842)
				setTimeout( function() {
					menu.show( CKEDITOR.document.getById( _.id ), 4 );
				},0);
			};

		/**
		 * @class
		 * @extends CKEDITOR.ui.button
		 * @todo
		 */
		CKEDITOR.ui.menuButton = CKEDITOR.tools.createClass({
			base: CKEDITOR.ui.button,

			/**
			 * Creates a menuButton class instance.
			 *
			 * @constructor
			 * @param Object definition
			 * @todo
			 */
			$: function( definition ) {
				// We don't want the panel definition in this object.
				var panelDefinition = definition.panel;
				delete definition.panel;

				this.base( definition );

				this.hasArrow = true;

				this.click = clickFn;
			},

			statics: {
				handler: {
					create: function( definition ) {
						return new CKEDITOR.ui.menuButton( definition );
					}
				}
			}
		});
	},
	beforeInit: function( editor ) {
		editor.ui.addHandler( CKEDITOR.UI_MENUBUTTON, CKEDITOR.ui.menuButton.handler );
	}
});

/**
 * Button UI element.
 *
 * @readonly
 * @property {String} [='menubutton']
 * @member CKEDITOR
 */
CKEDITOR.UI_MENUBUTTON = 'menubutton';

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'uicolor', {
	requires: 'dialog',
	lang: 'bg,cs,cy,da,de,el,en,eo,et,fa,fi,fr,he,hr,it,ku,mk,nb,nl,no,pl,tr,ug,uk,vi,zh-cn', // %REMOVE_LINE_CORE%
	icons: 'uicolor', // %REMOVE_LINE_CORE%
	init: function( editor ) {
		if ( CKEDITOR.env.ie6Compat )
			return;

		editor.addCommand( 'uicolor', new CKEDITOR.dialogCommand( 'uicolor' ) );
		editor.ui.addButton && editor.ui.addButton( 'UIColor', {
			label: editor.lang.uicolor.title,
			command: 'uicolor',
			toolbar: 'tools,1'
		});
		CKEDITOR.dialog.add( 'uicolor', this.path + 'dialogs/uicolor.js' );

		/*
		 * DYNAMIC DOCUMENTATION CHANGE
		 * Check to see whether the YAHOO namespace already exists. If so, no need to load the yui.js or yui.css files
		 * as it is assumed to already be included.
		 */
		if (typeof YAHOO === 'undefined') {
			// Load YUI js files.
			CKEDITOR.scriptLoader.load(CKEDITOR.getUrl('plugins/uicolor/yui/yui.js'));

			// Load YUI css files.
			CKEDITOR.document.appendStyleSheet(CKEDITOR.getUrl('plugins/uicolor/yui/assets/yui.css'));
		}
	}
});

/*jsl:ignoreall*/
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
if ( typeof YAHOO == "undefined" || !YAHOO ) {
	var YAHOO = {};
}
YAHOO.namespace = function() {
	var A = arguments,
		E = null,
		C, B, D;
	for ( C = 0; C < A.length; C = C + 1 ) {
		D = ( "" + A[ C ] ).split( "." );
		E = YAHOO;
		for ( B = ( D[ 0 ] == "YAHOO" ) ? 1 : 0; B < D.length; B = B + 1 ) {
			E[ D[ B ] ] = E[ D[ B ] ] || {};
			E = E[ D[ B ] ];
		}
	}
	return E;
};
YAHOO.log = function( D, A, C ) {
	var B = YAHOO.widget.Logger;
	if ( B && B.log ) {
		return B.log( D, A, C );
	} else {
		return false;
	}
};
YAHOO.register = function( A, E, D ) {
	var I = YAHOO.env.modules,
		B, H, G, F, C;
	if ( !I[ A ] ) {
		I[ A ] = { versions: [], builds: [] };
	}
	B = I[ A ];
	H = D.version;
	G = D.build;
	F = YAHOO.env.listeners;
	B.name = A;
	B.version = H;
	B.build = G;
	B.versions.push( H );
	B.builds.push( G );
	B.mainClass = E;
	for ( C = 0; C < F.length; C = C + 1 ) {
		F[ C ]( B );
	}
	if ( E ) {
		E.VERSION = H;
		E.BUILD = G;
	} else {
		YAHOO.log( "mainClass is undefined for module " + A, "warn" );
	}
};
YAHOO.env = YAHOO.env || { modules: [], listeners: [] }; YAHOO.env.getVersion = function( A ) {
	return YAHOO.env.modules[ A ] || null;
};
YAHOO.env.ua = function() {
	var C = { ie: 0, opera: 0, gecko: 0, webkit: 0, mobile: null, air: 0, caja: 0 },
		B = navigator.userAgent,
		A; if ( ( /KHTML/ ).test( B ) ) {
		C.webkit = 1;
	}
	A = B.match( /AppleWebKit\/([^\s]*)/ );
	if ( A && A[ 1 ] ) {
		C.webkit = parseFloat( A[ 1 ] );
		if ( / Mobile\//.test( B ) ) {
			C.mobile = "Apple";
		} else {
			A = B.match( /NokiaN[^\/]*/ );
			if ( A ) {
				C.mobile = A[ 0 ];
			}
		}
		A = B.match( /AdobeAIR\/([^\s]*)/ );
		if ( A ) {
			C.air = A[ 0 ];
		}
	}
	if ( !C.webkit ) {
		A = B.match( /Opera[\s\/]([^\s]*)/ );
		if ( A && A[ 1 ] ) {
			C.opera = parseFloat( A[ 1 ] );
			A = B.match( /Opera Mini[^;]*/ );
			if ( A ) {
				C.mobile = A[ 0 ];
			}
		} else {
			A = B.match( /MSIE\s([^;]*)/ );
			if ( A && A[ 1 ] ) {
				C.ie = parseFloat( A[ 1 ] );
			} else {
				A = B.match( /Gecko\/([^\s]*)/ );
				if ( A ) {
					C.gecko = 1;
					A = B.match( /rv:([^\s\)]*)/ );
					if ( A && A[ 1 ] ) {
						C.gecko = parseFloat( A[ 1 ] );
					}
				}
			}
		}
	}
	A = B.match( /Caja\/([^\s]*)/ );
	if ( A && A[ 1 ] ) {
		C.caja = parseFloat( A[ 1 ] );
	}
	return C;
}();
(function() {
	YAHOO.namespace( "util", "widget", "example" );
	if ( "undefined" !== typeof YAHOO_config ) {
		var B = YAHOO_config.listener,
			A = YAHOO.env.listeners,
			D = true,
			C;
		if ( B ) {
			for ( C = 0; C < A.length; C = C + 1 ) {
				if ( A[ C ] == B ) {
					D = false;
					break;
				}
			}
			if ( D ) {
				A.push( B );
			}
		}
	}
})();
YAHOO.lang = YAHOO.lang || {};
(function() {
	var B = YAHOO.lang,
		F = "[object Array]",
		C = "[object Function]",
		A = Object.prototype,
		E = [ "toString", "valueOf" ],
		D = {
			isArray: function( G ) {
				return A.toString.apply( G ) === F;
			},
			isBoolean: function( G ) {
				return typeof G === "boolean";
			},
			isFunction: function( G ) {
				return A.toString.apply( G ) === C;
			},
			isNull: function( G ) {
				return G === null;
			},
			isNumber: function( G ) {
				return typeof G === "number" && isFinite( G );
			},
			isObject: function( G ) {
				return ( G && ( typeof G === "object" || B.isFunction( G ) ) ) || false;
			},
			isString: function( G ) {
				return typeof G === "string";
			},
			isUndefined: function( G ) {
				return typeof G === "undefined";
			},
			_IEEnumFix: ( YAHOO.env.ua.ie ) ?
			function( I, H ) {
				var G, K, J; for ( G = 0; G < E.length; G = G + 1 ) {
					K = E[ G ];
					J = H[ K ];
					if ( B.isFunction( J ) && J != A[ K ] ) {
						I[ K ] = J;
					}
				}
			} : function() {},
			extend: function( J, K, I ) {
				if ( !K || !J ) {
					throw new Error( "extend failed, please check that " + "all dependencies are included." );
				}
				var H = function() {},
					G;
				H.prototype = K.prototype;
				J.prototype = new H();
				J.prototype.constructor = J;
				J.superclass = K.prototype;
				if ( K.prototype.constructor == A.constructor ) {
					K.prototype.constructor = K;
				}
				if ( I ) {
					for ( G in I ) {
						if ( B.hasOwnProperty( I, G ) ) {
							J.prototype[ G ] = I[ G ];
						}
					}
					B._IEEnumFix( J.prototype, I );
				}
			},
			augmentObject: function( K, J ) {
				if ( !J || !K ) {
					throw new Error( "Absorb failed, verify dependencies." );
				}
				var G = arguments,
					I, L,
					H = G[ 2 ];
				if ( H && H !== true ) {
					for ( I = 2; I < G.length; I = I + 1 ) {
						K[ G[ I ] ] = J[ G[ I ] ];
					}
				} else {
					for ( L in J ) {
						if ( H || !( L in K ) ) {
							K[ L ] = J[ L ];
						}
					}
					B._IEEnumFix( K, J );
				}
			},
			augmentProto: function( J, I ) {
				if ( !I || !J ) {
					throw new Error( "Augment failed, verify dependencies." );
				}
				var G = [ J.prototype, I.prototype ],
					H;
				for ( H = 2; H < arguments.length; H = H + 1 ) {
					G.push( arguments[ H ] );
				}
				B.augmentObject.apply( this, G );
			},
			dump: function( G, L ) {
				var I, K,
					N = [],
					O = "{...}",
					H = "f(){...}",
					M = ", ",
					J = " => ";
				if ( !B.isObject( G ) ) {
					return G + "";
				} else {
					if ( G instanceof Date || ( "nodeType" in G && "tagName" in G ) ) {
						return G;
					} else {
						if ( B.isFunction( G ) ) {
							return H;
						}
					}
				}
				L = ( B.isNumber( L ) ) ? L : 3;
				if ( B.isArray( G ) ) {
					N.push( "[" );
					for ( I = 0, K = G.length; I < K; I = I + 1 ) {
						if ( B.isObject( G[ I ] ) ) {
							N.push( ( L > 0 ) ? B.dump( G[ I ], L - 1 ) : O );
						} else {
							N.push( G[ I ] );
						}
						N.push( M );
					}
					if ( N.length > 1 ) {
						N.pop();
					}
					N.push( "]" );
				} else {
					N.push( "{" );
					for ( I in G ) {
						if ( B.hasOwnProperty( G, I ) ) {
							N.push( I + J );
							if ( B.isObject( G[ I ] ) ) {
								N.push( ( L > 0 ) ? B.dump( G[ I ], L - 1 ) : O );
							} else {
								N.push( G[ I ] );
							}
							N.push( M );
						}
					}
					if ( N.length > 1 ) {
						N.pop();
					}
					N.push( "}" );
				}
				return N.join( "" );
			},
			substitute: function( V, H, O ) {
				var L, K, J, R, S, U,
					Q = [],
					I,
					M = "dump",
					P = " ",
					G = "{",
					T = "}",
					N;
				for ( ;; ) {
					L = V.lastIndexOf( G );
					if ( L < 0 ) {
						break;
					}
					K = V.indexOf( T, L );
					if ( L + 1 >= K ) {
						break;
					}
					I = V.substring( L + 1, K );
					R = I;
					U = null;
					J = R.indexOf( P );
					if ( J > -1 ) {
						U = R.substring( J + 1 );
						R = R.substring( 0, J );
					}
					S = H[ R ];
					if ( O ) {
						S = O( R, S, U );
					}
					if ( B.isObject( S ) ) {
						if ( B.isArray( S ) ) {
							S = B.dump( S, parseInt( U, 10 ) );
						} else {
							U = U || "";
							N = U.indexOf( M );
							if ( N > -1 ) {
								U = U.substring( 4 );
							}
							if ( S.toString === A.toString || N > -1 ) {
								S = B.dump( S, parseInt( U, 10 ) );
							} else {
								S = S.toString();
							}
						}
					} else {
						if ( !B.isString( S ) && !B.isNumber( S ) ) {
							S = "~-" + Q.length + "-~";
							Q[ Q.length ] = I;
						}
					}
					V = V.substring( 0, L ) + S + V.substring( K + 1 );
				}
				for ( L = Q.length - 1; L >= 0; L = L - 1 ) {
					V = V.replace( new RegExp( "~-" + L + "-~" ), "{" + Q[ L ] + "}", "g" );
				}
				return V;
			},
			trim: function( G ) {
				try {
					return G.replace( /^\s+|\s+$/g, "" );
				} catch ( H ) {
					return G;
				}
			},
			merge: function() {
				var J = {},
					H = arguments,
					G = H.length,
					I;
				for ( I = 0; I < G; I = I + 1 ) {
					B.augmentObject( J, H[ I ], true );
				}
				return J;
			},
			later: function( N, H, O, J, K ) {
				N = N || 0; H = H || {};
				var I = O,
					M = J,
					L, G;
				if ( B.isString( O ) ) {
					I = H[ O ];
				}
				if ( !I ) {
					throw new TypeError( "method undefined" );
				}
				if ( !B.isArray( M ) ) {
					M = [ J ];
				}
				L = function() {
					I.apply( H, M );
				};
				G = ( K ) ? setInterval( L, N ) : setTimeout( L, N );
				return {
					interval: K, cancel: function() {
						if ( this.interval ) {
							clearInterval( G );
						} else {
							clearTimeout( G );
						}
					} };
			},
			isValue: function( G ) {
				return ( B.isObject( G ) || B.isString( G ) || B.isNumber( G ) || B.isBoolean( G ) );
			} }; B.hasOwnProperty = ( A.hasOwnProperty ) ?
	function( G, H ) {
		return G && G.hasOwnProperty( H );
	} : function( G, H ) {
		return !B.isUndefined( G[ H ] ) && G.constructor.prototype[ H ] !== G[ H ];
	};
	D.augmentObject( B, D, true );
	YAHOO.util.Lang = B;
	B.augment = B.augmentProto;
	YAHOO.augment = B.augmentProto;
	YAHOO.extend = B.extend;
})();
YAHOO.register( "yahoo", YAHOO, { version: "2.7.0", build: "1796" } );
(function() {
	YAHOO.env._id_counter = YAHOO.env._id_counter || 0;
	var E = YAHOO.util,
		L = YAHOO.lang,
		m = YAHOO.env.ua,
		A = YAHOO.lang.trim,
		d = {},
		h = {},
		N = /^t(?:able|d|h)$/i,
		X = /color$/i,
		K = window.document,
		W = K.documentElement,
		e = "ownerDocument",
		n = "defaultView",
		v = "documentElement",
		t = "compatMode",
		b = "offsetLeft",
		P = "offsetTop",
		u = "offsetParent",
		Z = "parentNode",
		l = "nodeType",
		C = "tagName",
		O = "scrollLeft",
		i = "scrollTop",
		Q = "getBoundingClientRect",
		w = "getComputedStyle",
		a = "currentStyle",
		M = "CSS1Compat",
		c = "BackCompat",
		g = "class",
		F = "className",
		J = "",
		B = " ",
		s = "(?:^|\\s)",
		k = "(?= |$)",
		U = "g",
		p = "position",
		f = "fixed",
		V = "relative",
		j = "left",
		o = "top",
		r = "medium",
		q = "borderLeftWidth",
		R = "borderTopWidth",
		D = m.opera,
		I = m.webkit,
		H = m.gecko,
		T = m.ie;
	E.Dom = {
		CUSTOM_ATTRIBUTES: ( !W.hasAttribute ) ? { "for": "htmlFor", "class": F } : { "htmlFor": "for", "className": g },
		get: function( y ) {
			var AA, Y, z, x, G; if ( y ) {
				if ( y[ l ] || y.item ) {
					return y;
				}
				if ( typeof y === "string" ) {
					AA = y;
					y = K.getElementById( y );
					if ( y && y.id === AA ) {
						return y;
					} else {
						if ( y && K.all ) {
							y = null;
							Y = K.all[ AA ];
							for ( x = 0, G = Y.length; x < G; ++x ) {
								if ( Y[ x ].id === AA ) {
									return Y[ x ];
								}
							}
						}
					}
					return y;
				}
				if ( y.DOM_EVENTS ) {
					y = y.get( "element" );
				}
				if ( "length" in y ) {
					z = [];
					for ( x = 0, G = y.length; x < G; ++x ) {
						z[ z.length ] = E.Dom.get( y[ x ] );
					}
					return z;
				}
				return y;
			}
			return null;
		},
		getComputedStyle: function( G, Y ) {
			if ( window[ w ] ) {
				return G[ e ][ n ][ w ]( G, null )[ Y ];
			} else {
				if ( G[ a ] ) {
					return E.Dom.IE_ComputedStyle.get( G, Y );
				}
			}
		},
		getStyle: function( G, Y ) {
			return E.Dom.batch( G, E.Dom._getStyle, Y );
		},
		_getStyle: function() {
			if ( window[ w ] ) {
				return function( G, y ) {
					y = ( y === "float" ) ? y = "cssFloat" : E.Dom._toCamel( y );
					var x = G.style[ y ],
						Y;
					if ( !x ) {
						Y = G[ e ][ n ][ w ]( G, null );
						if ( Y ) {
							x = Y[ y ];
						}
					}
					return x;
				};
			} else {
				if ( W[ a ] ) {
					return function( G, y ) {
						var x;
						switch ( y ) {
/* DynDoc update: don't use filter style
							case "opacity":
								x = 100;
								try {
									x = G.filters[ "DXImageTransform.Microsoft.Alpha" ].opacity;
								} catch ( z ) {
									try {
										x = G.filters( "alpha" ).opacity;
									} catch ( Y ) {}
								}
								return x / 100;*/case "float":
								y = "styleFloat";default:
								y = E.Dom._toCamel( y );
								x = G[ a ] ? G[ a ][ y ] : null;
								return ( G.style[ y ] || x );
						}
					};
				}
			}
		}(), setStyle: function( G, Y, x ) {
			E.Dom.batch( G, E.Dom._setStyle, { prop: Y, val: x } );
		},
		_setStyle: function() {
			if ( T ) {
				return function( Y, G ) {
					var x = E.Dom._toCamel( G.prop ),
						y = G.val;
					if ( Y ) {
						switch ( x ) {
/* DynDoc update: don't use filter style
							case "opacity":
								if ( L.isString( Y.style.filter ) ) {
									Y.style.filter = "alpha(opacity=" + y * 100 + ")";
									if ( !Y[ a ] || !Y[ a ].hasLayout ) {
										Y.style.zoom = 1;
									}
								}
								break;*/case "float":
								x = "styleFloat";default:
								Y.style[ x ] = y;
						}
					} else {}
				};
			} else {
				return function( Y, G ) {
					var x = E.Dom._toCamel( G.prop ),
						y = G.val;
					if ( Y ) {
						if ( x == "float" ) {
							x = "cssFloat";
						}
						Y.style[ x ] = y;
					} else {}
				};
			}
		}(), getXY: function( G ) {
			return E.Dom.batch( G, E.Dom._getXY );
		},
		_canPosition: function( G ) {
			return ( E.Dom._getStyle( G, "display" ) !== "none" && E.Dom._inDoc( G ) );
		},
		_getXY: function() {
			if ( K[ v ][ Q ] ) {
				return function( y ) {
					var z, Y, AA, AF, AE, AD, AC, G, x,
						AB = Math.floor,
						AG = false;
					if ( E.Dom._canPosition( y ) ) {
						AA = y[ Q ]();
						AF = y[ e ];
						z = E.Dom.getDocumentScrollLeft( AF );
						Y = E.Dom.getDocumentScrollTop( AF );
						AG = [ AB( AA[ j ] ), AB( AA[ o ] ) ];
						if ( T && m.ie < 8 ) {
							AE = 2;
							AD = 2;
							AC = AF[ t ];
							G = S( AF[ v ], q );
							x = S( AF[ v ], R );
							if ( m.ie === 6 ) {
								if ( AC !== c ) {
									AE = 0;
									AD = 0;
								}
							}
							if ( ( AC == c ) ) {
								if ( G !== r ) {
									AE = parseInt( G, 10 );
								}
								if ( x !== r ) {
									AD = parseInt( x, 10 );
								}
							}
							AG[ 0 ] -= AE;
							AG[ 1 ] -= AD;
						}
						if ( ( Y || z ) ) {
							AG[ 0 ] += z;
							AG[ 1 ] += Y;
						}
						AG[ 0 ] = AB( AG[ 0 ] );
						AG[ 1 ] = AB( AG[ 1 ] );
					} else {}
					return AG;
				};
			} else {
				return function( y ) {
					var x, Y, AA, AB, AC,
						z = false,
						G = y;
					if ( E.Dom._canPosition( y ) ) {
						z = [ y[ b ], y[ P ] ];
						x = E.Dom.getDocumentScrollLeft( y[ e ] );
						Y = E.Dom.getDocumentScrollTop( y[ e ] );
						AC = ( ( H || m.webkit > 519 ) ? true : false );
						while ( ( G = G[ u ] ) ) {
							z[ 0 ] += G[ b ];
							z[ 1 ] += G[ P ];
							if ( AC ) {
								z = E.Dom._calcBorders( G, z );
							}
						}
						if ( E.Dom._getStyle( y, p ) !== f ) {
							G = y;
							while ( ( G = G[ Z ] ) && G[ C ] ) {
								AA = G[ i ];
								AB = G[ O ];
								if ( H && ( E.Dom._getStyle( G, "overflow" ) !== "visible" ) ) {
									z = E.Dom._calcBorders( G, z );
								}
								if ( AA || AB ) {
									z[ 0 ] -= AB;
									z[ 1 ] -= AA;
								}
							}
							z[ 0 ] += x;
							z[ 1 ] += Y;
						} else {
							if ( D ) {
								z[ 0 ] -= x;
								z[ 1 ] -= Y;
							} else {
								if ( I || H ) {
									z[ 0 ] += x;
									z[ 1 ] += Y;
								}
							}
						}
						z[ 0 ] = Math.floor( z[ 0 ] );
						z[ 1 ] = Math.floor( z[ 1 ] );
					} else {}
					return z;
				};
			}
		}(), getX: function( G ) {
			var Y = function( x ) {
					return E.Dom.getXY( x )[ 0 ];
				};
			return E.Dom.batch( G, Y, E.Dom, true );
		},
		getY: function( G ) {
			var Y = function( x ) {
					return E.Dom.getXY( x )[ 1 ];
				};
			return E.Dom.batch( G, Y, E.Dom, true );
		},
		setXY: function( G, x, Y ) {
			E.Dom.batch( G, E.Dom._setXY, { pos: x, noRetry: Y } );
		},
		_setXY: function( G, z ) {
			var AA = E.Dom._getStyle( G, p ),
				y = E.Dom.setStyle,
				AD = z.pos,
				Y = z.noRetry,
				AB = [ parseInt( E.Dom.getComputedStyle( G, j ), 10 ), parseInt( E.Dom.getComputedStyle( G, o ), 10 ) ],
				AC, x;
			if ( AA == "static" ) {
				AA = V;
				y( G, p, AA );
			}
			AC = E.Dom._getXY( G );
			if ( !AD || AC === false ) {
				return false;
			}
			if ( isNaN( AB[ 0 ] ) ) {
				AB[ 0 ] = ( AA == V ) ? 0 : G[ b ];
			}
			if ( isNaN( AB[ 1 ] ) ) {
				AB[ 1 ] = ( AA == V ) ? 0 : G[ P ];
			}
			if ( AD[ 0 ] !== null ) {
				y( G, j, AD[ 0 ] - AC[ 0 ] + AB[ 0 ] + "px" );
			}
			if ( AD[ 1 ] !== null ) {
				y( G, o, AD[ 1 ] - AC[ 1 ] + AB[ 1 ] + "px" );
			}
			if ( !Y ) {
				x = E.Dom._getXY( G );
				if ( ( AD[ 0 ] !== null && x[ 0 ] != AD[ 0 ] ) || ( AD[ 1 ] !== null && x[ 1 ] != AD[ 1 ] ) ) {
					E.Dom._setXY( G, { pos: AD, noRetry: true } );
				}
			}
		},
		setX: function( Y, G ) {
			E.Dom.setXY( Y, [ G, null ] );
		},
		setY: function( G, Y ) {
			E.Dom.setXY( G, [ null, Y ] );
		},
		getRegion: function( G ) {
			var Y = function( x ) {
					var y = false;
					if ( E.Dom._canPosition( x ) ) {
						y = E.Region.getRegion( x );
					} else {}
					return y;
				};
			return E.Dom.batch( G, Y, E.Dom, true );
		},
		getClientWidth: function() {
			return E.Dom.getViewportWidth();
		},
		getClientHeight: function() {
			return E.Dom.getViewportHeight();
		},
		getElementsByClassName: function( AB, AF, AC, AE, x, AD ) {
			AB = L.trim( AB );
			AF = AF || "*";
			AC = ( AC ) ? E.Dom.get( AC ) : null || K;
			if ( !AC ) {
				return [];
			}
			var Y = [],
				G = AC.getElementsByTagName( AF ),
				z = E.Dom.hasClass;
			for ( var y = 0, AA = G.length; y < AA; ++y ) {
				if ( z( G[ y ], AB ) ) {
					Y[ Y.length ] = G[ y ];
				}
			}
			if ( AE ) {
				E.Dom.batch( Y, AE, x, AD );
			}
			return Y;
		},
		hasClass: function( Y, G ) {
			return E.Dom.batch( Y, E.Dom._hasClass, G );
		},
		_hasClass: function( x, Y ) {
			var G = false,
				y; if ( x && Y ) {
				y = E.Dom.getAttribute( x, F ) || J;
				if ( Y.exec ) {
					G = Y.test( y );
				} else {
					G = Y && ( B + y + B ).indexOf( B + Y + B ) > -1;
				}
			} else {}
			return G;
		},
		addClass: function( Y, G ) {
			return E.Dom.batch( Y, E.Dom._addClass, G );
		},
		_addClass: function( x, Y ) {
			var G = false,
				y; if ( x && Y ) {
				y = E.Dom.getAttribute( x, F ) || J;
				if ( !E.Dom._hasClass( x, Y ) ) {
					E.Dom.setAttribute( x, F, A( y + B + Y ) );
					G = true;
				}
			} else {}
			return G;
		},
		removeClass: function( Y, G ) {
			return E.Dom.batch( Y, E.Dom._removeClass, G );
		},
		_removeClass: function( y, x ) {
			var Y = false,
				AA, z, G; if ( y && x ) {
				AA = E.Dom.getAttribute( y, F ) || J;
				E.Dom.setAttribute( y, F, AA.replace( E.Dom._getClassRegex( x ), J ) );
				z = E.Dom.getAttribute( y, F );
				if ( AA !== z ) {
					E.Dom.setAttribute( y, F, A( z ) );
					Y = true;
					if ( E.Dom.getAttribute( y, F ) === "" ) {
						G = ( y.hasAttribute && y.hasAttribute( g ) ) ? g : F;
						y.removeAttribute( G );
					}
				}
			} else {}
			return Y;
		},
		replaceClass: function( x, Y, G ) {
			return E.Dom.batch( x, E.Dom._replaceClass, { from: Y, to: G } );
		},
		_replaceClass: function( y, x ) {
			var Y, AB, AA,
				G = false,
				z; if ( y && x ) {
				AB = x.from;
				AA = x.to;
				if ( !AA ) {
					G = false;
				} else {
					if ( !AB ) {
						G = E.Dom._addClass( y, x.to );
					} else {
						if ( AB !== AA ) {
							z = E.Dom.getAttribute( y, F ) || J;
							Y = ( B + z.replace( E.Dom._getClassRegex( AB ), B + AA ) ).split( E.Dom._getClassRegex( AA ) );
							Y.splice( 1, 0, B + AA );
							E.Dom.setAttribute( y, F, A( Y.join( J ) ) );
							G = true;
						}
					}
				}
			} else {}
			return G;
		},
		generateId: function( G, x ) {
			x = x || "yui-gen"; var Y = function( y ) {
					if ( y && y.id ) {
						return y.id;
					}
					var z = x + YAHOO.env._id_counter++;
					if ( y ) {
						if ( y[ e ].getElementById( z ) ) {
							return E.Dom.generateId( y, z + x );
						}
						y.id = z;
					}
					return z;
				};
			return E.Dom.batch( G, Y, E.Dom, true ) || Y.apply( E.Dom, arguments );
		},
		isAncestor: function( Y, x ) {
			Y = E.Dom.get( Y );
			x = E.Dom.get( x );
			var G = false;
			if ( ( Y && x ) && ( Y[ l ] && x[ l ] ) ) {
				if ( Y.contains && Y !== x ) {
					G = Y.contains( x );
				} else {
					if ( Y.compareDocumentPosition ) {
						G = !!( Y.compareDocumentPosition( x ) & 16 );
					}
				}
			} else {}
			return G;
		},
		inDocument: function( G, Y ) {
			return E.Dom._inDoc( E.Dom.get( G ), Y );
		},
		_inDoc: function( Y, x ) {
			var G = false; if ( Y && Y[ C ] ) {
				x = x || Y[ e ];
				G = E.Dom.isAncestor( x[ v ], Y );
			} else {}
			return G;
		},
		getElementsBy: function( Y, AF, AB, AD, y, AC, AE ) {
			AF = AF || "*"; AB = ( AB ) ? E.Dom.get( AB ) : null || K;
			if ( !AB ) {
				return [];
			}
			var x = [],
				G = AB.getElementsByTagName( AF );
			for ( var z = 0, AA = G.length; z < AA; ++z ) {
				if ( Y( G[ z ] ) ) {
					if ( AE ) {
						x = G[ z ];
						break;
					} else {
						x[ x.length ] = G[ z ];
					}
				}
			}
			if ( AD ) {
				E.Dom.batch( x, AD, y, AC );
			}
			return x;
		},
		getElementBy: function( x, G, Y ) {
			return E.Dom.getElementsBy( x, G, Y, null, null, null, true );
		},
		batch: function( x, AB, AA, z ) {
			var y = [],
				Y = ( z ) ? AA : window;
			x = ( x && ( x[ C ] || x.item ) ) ? x : E.Dom.get( x );
			if ( x && AB ) {
				if ( x[ C ] || x.length === undefined ) {
					return AB.call( Y, x, AA );
				}
				for ( var G = 0; G < x.length; ++G ) {
					y[ y.length ] = AB.call( Y, x[ G ], AA );
				}
			} else {
				return false;
			}
			return y;
		},
		getDocumentHeight: function() {
			var Y = ( K[ t ] != M || I ) ? K.body.scrollHeight : W.scrollHeight,
				G = Math.max( Y, E.Dom.getViewportHeight() );
			return G;
		},
		getDocumentWidth: function() {
			var Y = ( K[ t ] != M || I ) ? K.body.scrollWidth : W.scrollWidth,
				G = Math.max( Y, E.Dom.getViewportWidth() );
			return G;
		},
		getViewportHeight: function() {
			var G = self.innerHeight,
				Y = K[ t ];
			if ( ( Y || T ) && !D ) {
				G = ( Y == M ) ? W.clientHeight : K.body.clientHeight;
			}
			return G;
		},
		getViewportWidth: function() {
			var G = self.innerWidth,
				Y = K[ t ];
			if ( Y || T ) {
				G = ( Y == M ) ? W.clientWidth : K.body.clientWidth;
			}
			return G;
		},
		getAncestorBy: function( G, Y ) {
			while ( ( G = G[ Z ] ) ) {
				if ( E.Dom._testElement( G, Y ) ) {
					return G;
				}
			}
			return null;
		},
		getAncestorByClassName: function( Y, G ) {
			Y = E.Dom.get( Y );
			if ( !Y ) {
				return null;
			}
			var x = function( y ) {
					return E.Dom.hasClass( y, G );
				};
			return E.Dom.getAncestorBy( Y, x );
		},
		getAncestorByTagName: function( Y, G ) {
			Y = E.Dom.get( Y );
			if ( !Y ) {
				return null;
			}
			var x = function( y ) {
					return y[ C ] && y[ C ].toUpperCase() == G.toUpperCase();
				};
			return E.Dom.getAncestorBy( Y, x );
		},
		getPreviousSiblingBy: function( G, Y ) {
			while ( G ) {
				G = G.previousSibling;
				if ( E.Dom._testElement( G, Y ) ) {
					return G;
				}
			}
			return null;
		},
		getPreviousSibling: function( G ) {
			G = E.Dom.get( G );
			if ( !G ) {
				return null;
			}
			return E.Dom.getPreviousSiblingBy( G );
		},
		getNextSiblingBy: function( G, Y ) {
			while ( G ) {
				G = G.nextSibling;
				if ( E.Dom._testElement( G, Y ) ) {
					return G;
				}
			}
			return null;
		},
		getNextSibling: function( G ) {
			G = E.Dom.get( G );
			if ( !G ) {
				return null;
			}
			return E.Dom.getNextSiblingBy( G );
		},
		getFirstChildBy: function( G, x ) {
			var Y = ( E.Dom._testElement( G.firstChild, x ) ) ? G.firstChild : null;
			return Y || E.Dom.getNextSiblingBy( G.firstChild, x );
		},
		getFirstChild: function( G, Y ) {
			G = E.Dom.get( G );
			if ( !G ) {
				return null;
			}
			return E.Dom.getFirstChildBy( G );
		},
		getLastChildBy: function( G, x ) {
			if ( !G ) {
				return null;
			}
			var Y = ( E.Dom._testElement( G.lastChild, x ) ) ? G.lastChild : null;
			return Y || E.Dom.getPreviousSiblingBy( G.lastChild, x );
		},
		getLastChild: function( G ) {
			G = E.Dom.get( G );
			return E.Dom.getLastChildBy( G );
		},
		getChildrenBy: function( Y, y ) {
			var x = E.Dom.getFirstChildBy( Y, y ),
				G = x ? [ x ] : [];
			E.Dom.getNextSiblingBy( x, function( z ) {
				if ( !y || y( z ) ) {
					G[ G.length ] = z;
				}
				return false;
			});
			return G;
		},
		getChildren: function( G ) {
			G = E.Dom.get( G );
			if ( !G ) {}
			return E.Dom.getChildrenBy( G );
		},
		getDocumentScrollLeft: function( G ) {
			G = G || K; return Math.max( G[ v ].scrollLeft, G.body.scrollLeft );
		},
		getDocumentScrollTop: function( G ) {
			G = G || K; return Math.max( G[ v ].scrollTop, G.body.scrollTop );
		},
		insertBefore: function( Y, G ) {
			Y = E.Dom.get( Y );
			G = E.Dom.get( G );
			if ( !Y || !G || !G[ Z ] ) {
				return null;
			}
			return G[ Z ].insertBefore( Y, G );
		},
		insertAfter: function( Y, G ) {
			Y = E.Dom.get( Y );
			G = E.Dom.get( G );
			if ( !Y || !G || !G[ Z ] ) {
				return null;
			}
			if ( G.nextSibling ) {
				return G[ Z ].insertBefore( Y, G.nextSibling );
			} else {
				return G[ Z ].appendChild( Y );
			}
		},
		getClientRegion: function() {
			var x = E.Dom.getDocumentScrollTop(),
				Y = E.Dom.getDocumentScrollLeft(),
				y = E.Dom.getViewportWidth() + Y,
				G = E.Dom.getViewportHeight() + x;
			return new E.Region( x, y, G, Y );
		},
		setAttribute: function( Y, G, x ) {
			G = E.Dom.CUSTOM_ATTRIBUTES[ G ] || G;
			Y.setAttribute( G, x );
		},
		getAttribute: function( Y, G ) {
			G = E.Dom.CUSTOM_ATTRIBUTES[ G ] || G;
			return Y.getAttribute( G );
		},
		_toCamel: function( Y ) {
			var x = d;

			function G( y, z ) {
				return z.toUpperCase();
			}
			return x[ Y ] || ( x[ Y ] = Y.indexOf( "-" ) === -1 ? Y : Y.replace( /-([a-z])/gi, G ) );
		},
		_getClassRegex: function( Y ) {
			var G; if ( Y !== undefined ) {
				if ( Y.exec ) {
					G = Y;
				} else {
					G = h[ Y ];
					if ( !G ) {
						Y = Y.replace( E.Dom._patterns.CLASS_RE_TOKENS, "\\$1" );
						G = h[ Y ] = new RegExp( s + Y + k, U );
					}
				}
			}
			return G;
		},
		_patterns: { ROOT_TAG: /^body|html$/i, CLASS_RE_TOKENS: /([\.\(\)\^\$\*\+\?\|\[\]\{\}])/g },
		_testElement: function( G, Y ) {
			return G && G[ l ] == 1 && ( !Y || Y( G ) );
		},
		_calcBorders: function( x, y ) {
			var Y = parseInt( E.Dom[ w ]( x, R ), 10 ) || 0,
				G = parseInt( E.Dom[ w ]( x, q ), 10 ) || 0;
			if ( H ) {
				if ( N.test( x[ C ] ) ) {
					Y = 0;
					G = 0;
				}
			}
			y[ 0 ] += G;
			y[ 1 ] += Y;
			return y;
		} }; var S = E.Dom[ w ];
	if ( m.opera ) {
		E.Dom[ w ] = function( Y, G ) {
			var x = S( Y, G );
			if ( X.test( G ) ) {
				x = E.Dom.Color.toRGB( x );
			}
			return x;
		};
	}
	if ( m.webkit ) {
		E.Dom[ w ] = function( Y, G ) {
			var x = S( Y, G );
			if ( x === "rgba(0, 0, 0, 0)" ) {
				x = "transparent";
			}
			return x;
		};
	}
})();
YAHOO.util.Region = function( C, D, A, B ) {
	this.top = C;
	this.y = C;
	this[ 1 ] = C;
	this.right = D;
	this.bottom = A;
	this.left = B;
	this.x = B;
	this[ 0 ] = B;
	this.width = this.right - this.left;
	this.height = this.bottom - this.top;
};
YAHOO.util.Region.prototype.contains = function( A ) {
	return ( A.left >= this.left && A.right <= this.right && A.top >= this.top && A.bottom <= this.bottom );
};
YAHOO.util.Region.prototype.getArea = function() {
	return ( ( this.bottom - this.top ) * ( this.right - this.left ) );
};
YAHOO.util.Region.prototype.intersect = function( E ) {
	var C = Math.max( this.top, E.top ),
		D = Math.min( this.right, E.right ),
		A = Math.min( this.bottom, E.bottom ),
		B = Math.max( this.left, E.left );
	if ( A >= C && D >= B ) {
		return new YAHOO.util.Region( C, D, A, B );
	} else {
		return null;
	}
};
YAHOO.util.Region.prototype.union = function( E ) {
	var C = Math.min( this.top, E.top ),
		D = Math.max( this.right, E.right ),
		A = Math.max( this.bottom, E.bottom ),
		B = Math.min( this.left, E.left );
	return new YAHOO.util.Region( C, D, A, B );
};
YAHOO.util.Region.prototype.toString = function() {
	return ( "Region {" + "top: " + this.top + ", right: " + this.right + ", bottom: " + this.bottom + ", left: " + this.left + ", height: " + this.height + ", width: " + this.width + "}" );
};
YAHOO.util.Region.getRegion = function( D ) {
	var F = YAHOO.util.Dom.getXY( D ),
		C = F[ 1 ],
		E = F[ 0 ] + D.offsetWidth,
		A = F[ 1 ] + D.offsetHeight,
		B = F[ 0 ];
	return new YAHOO.util.Region( C, E, A, B );
};
YAHOO.util.Point = function( A, B ) {
	if ( YAHOO.lang.isArray( A ) ) {
		B = A[ 1 ];
		A = A[ 0 ];
	}
	YAHOO.util.Point.superclass.constructor.call( this, B, A, B, A );
};
YAHOO.extend( YAHOO.util.Point, YAHOO.util.Region );
(function() {
	var B = YAHOO.util,
		A = "clientTop",
		F = "clientLeft",
		J = "parentNode",
		K = "right",
		W = "hasLayout",
		I = "px",
		U = "opacity",
		L = "auto",
		D = "borderLeftWidth",
		G = "borderTopWidth",
		P = "borderRightWidth",
		V = "borderBottomWidth",
		S = "visible",
		Q = "transparent",
		N = "height",
		E = "width",
		H = "style",
		T = "currentStyle",
		R = /^width|height$/,
		O = /^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,
		M = {
			get: function( X, Z ) {
				var Y = "",
					a = X[ T ][ Z ];
				if ( Z === U ) {
					Y = B.Dom.getStyle( X, U );
				} else {
					if ( !a || ( a.indexOf && a.indexOf( I ) > -1 ) ) {
						Y = a;
					} else {
						if ( B.Dom.IE_COMPUTED[ Z ] ) {
							Y = B.Dom.IE_COMPUTED[ Z ]( X, Z );
						} else {
							if ( O.test( a ) ) {
								Y = B.Dom.IE.ComputedStyle.getPixel( X, Z );
							} else {
								Y = a;
							}
						}
					}
				}
				return Y;
			},
			getOffset: function( Z, e ) {
				var b = Z[ T ][ e ],
					X = e.charAt( 0 ).toUpperCase() + e.substr( 1 ),
					c = "offset" + X,
					Y = "pixel" + X,
					a = "",
					d;
				if ( b == L ) {
					d = Z[ c ];
					if ( d === undefined ) {
						a = 0;
					}
					a = d;
					if ( R.test( e ) ) {
						Z[ H ][ e ] = d;
						if ( Z[ c ] > d ) {
							a = d - ( Z[ c ] - d );
						}
						Z[ H ][ e ] = L;
					}
				} else {
					if ( !Z[ H ][ Y ] && !Z[ H ][ e ] ) {
						Z[ H ][ e ] = b;
					}
					a = Z[ H ][ Y ];
				}
				return a + I;
			},
			getBorderWidth: function( X, Z ) {
				var Y = null; if ( !X[ T ][ W ] ) {
					X[ H ].zoom = 1;
				}
				switch ( Z ) {
					case G:
						Y = X[ A ];
						break;case V:
						Y = X.offsetHeight - X.clientHeight - X[ A ];
						break;case D:
						Y = X[ F ];
						break;case P:
						Y = X.offsetWidth - X.clientWidth - X[ F ];
						break;
				}
				return Y + I;
			},
			getPixel: function( Y, X ) {
				var a = null,
					b = Y[ T ][ K ],
					Z = Y[ T ][ X ];
				Y[ H ][ K ] = Z;
				a = Y[ H ].pixelRight;
				Y[ H ][ K ] = b;
				return a + I;
			},
			getMargin: function( Y, X ) {
				var Z; if ( Y[ T ][ X ] == L ) {
					Z = 0 + I;
				} else {
					Z = B.Dom.IE.ComputedStyle.getPixel( Y, X );
				}
				return Z;
			},
			getVisibility: function( Y, X ) {
				var Z; while ( ( Z = Y[ T ] ) && Z[ X ] == "inherit" ) {
					Y = Y[ J ];
				}
				return ( Z ) ? Z[ X ] : S;
			},
			getColor: function( Y, X ) {
				return B.Dom.Color.toRGB( Y[ T ][ X ] ) || Q;
			},
			getBorderColor: function( Y, X ) {
				var Z = Y[ T ],
					a = Z[ X ] || Z.color;
				return B.Dom.Color.toRGB( B.Dom.Color.toHex( a ) );
			} },
		C = {};
	C.top = C.right = C.bottom = C.left = C[ E ] = C[ N ] = M.getOffset;
	C.color = M.getColor;
	C[ G ] = C[ P ] = C[ V ] = C[ D ] = M.getBorderWidth;
	C.marginTop = C.marginRight = C.marginBottom = C.marginLeft = M.getMargin;
	C.visibility = M.getVisibility;
	C.borderColor = C.borderTopColor = C.borderRightColor = C.borderBottomColor = C.borderLeftColor = M.getBorderColor;
	B.Dom.IE_COMPUTED = C;
	B.Dom.IE_ComputedStyle = M;
})();
(function() {
	var C = "toString",
		A = parseInt,
		B = RegExp,
		D = YAHOO.util;
	D.Dom.Color = {
		KEYWORDS: { black: "000", silver: "c0c0c0", gray: "808080", white: "fff", maroon: "800000", red: "f00", purple: "800080", fuchsia: "f0f", green: "008000", lime: "0f0", olive: "808000", yellow: "ff0", navy: "000080", blue: "00f", teal: "008080", aqua: "0ff" },
		re_RGB: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i, re_hex: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i, re_hex3: /([0-9A-F])/gi, toRGB: function( E ) {
			if ( !D.Dom.Color.re_RGB.test( E ) ) {
				E = D.Dom.Color.toHex( E );
			}
			if ( D.Dom.Color.re_hex.exec( E ) ) {
				E = "rgb(" + [ A( B.$1, 16 ), A( B.$2, 16 ), A( B.$3, 16 ) ].join( ", " ) + ")";
			}
			return E;
		},
		toHex: function( H ) {
			H = D.Dom.Color.KEYWORDS[ H ] || H;
			if ( D.Dom.Color.re_RGB.exec( H ) ) {
				var G = ( B.$1.length === 1 ) ? "0" + B.$1 : Number( B.$1 ),
					F = ( B.$2.length === 1 ) ? "0" + B.$2 : Number( B.$2 ),
					E = ( B.$3.length === 1 ) ? "0" + B.$3 : Number( B.$3 );
				H = [ G[ C ]( 16 ), F[ C ]( 16 ), E[ C ]( 16 ) ].join( "" );
			}
			if ( H.length < 6 ) {
				H = H.replace( D.Dom.Color.re_hex3, "$1$1" );
			}
			if ( H !== "transparent" && H.indexOf( "#" ) < 0 ) {
				H = "#" + H;
			}
			return H.toLowerCase();
		} };
}() );
YAHOO.register( "dom", YAHOO.util.Dom, { version: "2.7.0", build: "1796" } );
YAHOO.util.CustomEvent = function( D, C, B, A ) {
	this.type = D;
	this.scope = C || window;
	this.silent = B;
	this.signature = A || YAHOO.util.CustomEvent.LIST;
	this.subscribers = [];
	if ( !this.silent ) {}
	var E = "_YUICEOnSubscribe";
	if ( D !== E ) {
		this.subscribeEvent = new YAHOO.util.CustomEvent( E, this, true );
	}
	this.lastError = null;
};
YAHOO.util.CustomEvent.LIST = 0;
YAHOO.util.CustomEvent.FLAT = 1;
YAHOO.util.CustomEvent.prototype = {
	subscribe: function( A, B, C ) {
		if ( !A ) {
			throw new Error( "Invalid callback for subscriber to '" + this.type + "'" );
		}
		if ( this.subscribeEvent ) {
			this.subscribeEvent.fire( A, B, C );
		}
		this.subscribers.push( new YAHOO.util.Subscriber( A, B, C ) );
	},
	unsubscribe: function( D, F ) {
		if ( !D ) {
			return this.unsubscribeAll();
		}
		var E = false;
		for ( var B = 0, A = this.subscribers.length; B < A; ++B ) {
			var C = this.subscribers[ B ];
			if ( C && C.contains( D, F ) ) {
				this._delete( B );
				E = true;
			}
		}
		return E;
	},
	fire: function() {
		this.lastError = null; var K = [],
			E = this.subscribers.length;
		if ( !E && this.silent ) {
			return true;
		}
		var I = [].slice.call( arguments, 0 ),
			G = true,
			D,
			J = false;
		if ( !this.silent ) {}
		var C = this.subscribers.slice(),
			A = YAHOO.util.Event.throwErrors;
		for ( D = 0; D < E; ++D ) {
			var M = C[ D ];
			if ( !M ) {
				J = true;
			} else {
				if ( !this.silent ) {}
				var L = M.getScope( this.scope );
				if ( this.signature == YAHOO.util.CustomEvent.FLAT ) {
					var B = null;
					if ( I.length > 0 ) {
						B = I[ 0 ];
					}
					try {
						G = M.fn.call( L, B, M.obj );
					} catch ( F ) {
						this.lastError = F;
						if ( A ) {
							throw F;
						}
					}
				} else {
					try {
						G = M.fn.call( L, this.type, I, M.obj );
					} catch ( H ) {
						this.lastError = H;
						if ( A ) {
							throw H;
						}
					}
				}
				if ( false === G ) {
					if ( !this.silent ) {}
					break;
				}
			}
		}
		return ( G !== false );
	},
	unsubscribeAll: function() {
		var A = this.subscribers.length,
			B; for ( B = A - 1; B > -1; B-- ) {
			this._delete( B );
		}
		this.subscribers = [];
		return A;
	},
	_delete: function( A ) {
		var B = this.subscribers[ A ];
		if ( B ) {
			delete B.fn;
			delete B.obj;
		}
		this.subscribers.splice( A, 1 );
	},
	toString: function() {
		return "CustomEvent: " + "'" + this.type + "', " + "context: " + this.scope;
	} }; YAHOO.util.Subscriber = function( A, B, C ) {
	this.fn = A;
	this.obj = YAHOO.lang.isUndefined( B ) ? null : B;
	this.overrideContext = C;
};
YAHOO.util.Subscriber.prototype.getScope = function( A ) {
	if ( this.overrideContext ) {
		if ( this.overrideContext === true ) {
			return this.obj;
		} else {
			return this.overrideContext;
		}
	}
	return A;
};
YAHOO.util.Subscriber.prototype.contains = function( A, B ) {
	if ( B ) {
		return ( this.fn == A && this.obj == B );
	} else {
		return ( this.fn == A );
	}
};
YAHOO.util.Subscriber.prototype.toString = function() {
	return "Subscriber { obj: " + this.obj + ", overrideContext: " + ( this.overrideContext || "no" ) + " }";
};
if ( !YAHOO.util.Event ) {
	YAHOO.util.Event = function() {
		var H = false;
		var I = [];
		var J = [];
		var G = [];
		var E = [];
		var C = 0;
		var F = [];
		var B = [];
		var A = 0;
		var D = { 63232: 38, 63233: 40, 63234: 37, 63235: 39, 63276: 33, 63277: 34, 25: 9 }; var K = YAHOO.env.ua.ie ? "focusin" : "focus"; var L = YAHOO.env.ua.ie ? "focusout" : "blur"; return {
			POLL_RETRYS: 2000, POLL_INTERVAL: 20, EL: 0, TYPE: 1, FN: 2, WFN: 3, UNLOAD_OBJ: 3, ADJ_SCOPE: 4, OBJ: 5, OVERRIDE: 6, lastError: null, isSafari: YAHOO.env.ua.webkit, webkit: YAHOO.env.ua.webkit, isIE: YAHOO.env.ua.ie, _interval: null, _dri: null, DOMReady: false, throwErrors: false, startInterval: function() {
				if ( !this._interval ) {
					var M = this;
					var N = function() {
							M._tryPreloadAttach();
						};
					this._interval = setInterval( N, this.POLL_INTERVAL );
				}
			},
			onAvailable: function( S, O, Q, R, P ) {
				var M = ( YAHOO.lang.isString( S ) ) ? [ S ] : S;
				for ( var N = 0; N < M.length; N = N + 1 ) {
					F.push({ id: M[ N ], fn: O, obj: Q, overrideContext: R, checkReady: P } );
				}
				C = this.POLL_RETRYS;
				this.startInterval();
			},
			onContentReady: function( P, M, N, O ) {
				this.onAvailable( P, M, N, O, true );
			},
			onDOMReady: function( M, N, O ) {
				if ( this.DOMReady ) {
					setTimeout( function() {
						var P = window;
						if ( O ) {
							if ( O === true ) {
								P = N;
							} else {
								P = O;
							}
						}
						M.call( P, "DOMReady", [], N );
					}, 0 );
				} else {
					this.DOMReadyEvent.subscribe( M, N, O );
				}
			},
			_addListener: function( O, M, Y, S, W, b ) {
				if ( !Y || !Y.call ) {
					return false;
				}
				if ( this._isValidCollection( O ) ) {
					var Z = true;
					for ( var T = 0, V = O.length; T < V; ++T ) {
						Z = this.on( O[ T ], M, Y, S, W ) && Z;
					}
					return Z;
				} else {
					if ( YAHOO.lang.isString( O ) ) {
						var R = this.getEl( O );
						if ( R ) {
							O = R;
						} else {
							this.onAvailable( O, function() {
								YAHOO.util.Event.on( O, M, Y, S, W );
							});
							return true;
						}
					}
				}
				if ( !O ) {
					return false;
				}
				if ( "unload" == M && S !== this ) {
					J[ J.length ] = [ O, M, Y, S, W ];
					return true;
				}
				var N = O;
				if ( W ) {
					if ( W === true ) {
						N = S;
					} else {
						N = W;
					}
				}
				var P = function( c ) {
						return Y.call( N, YAHOO.util.Event.getEvent( c, O ), S );
					};
				var a = [ O, M, Y, P, N, S, W ];
				var U = I.length;
				I[ U ] = a;
				if ( this.useLegacyEvent( O, M ) ) {
					var Q = this.getLegacyIndex( O, M );
					if ( Q == -1 || O != G[ Q ][ 0 ] ) {
						Q = G.length;
						B[ O.id + M ] = Q;
						G[ Q ] = [ O, M, O[ "on" + M ] ];
						E[ Q ] = [];
						O[ "on" + M ] = function( c ) {
							YAHOO.util.Event.fireLegacyEvent( YAHOO.util.Event.getEvent( c ), Q );
						};
					}
					E[ Q ].push( a );
				} else {
					try {
						this._simpleAdd( O, M, P, b );
					} catch ( X ) {
						this.lastError = X;
						this.removeListener( O, M, Y );
						return false;
					}
				}
				return true;
			},
			addListener: function( N, Q, M, O, P ) {
				return this._addListener( N, Q, M, O, P, false );
			},
			addFocusListener: function( N, M, O, P ) {
				return this._addListener( N, K, M, O, P, true );
			},
			removeFocusListener: function( N, M ) {
				return this.removeListener( N, K, M );
			},
			addBlurListener: function( N, M, O, P ) {
				return this._addListener( N, L, M, O, P, true );
			},
			removeBlurListener: function( N, M ) {
				return this.removeListener( N, L, M );
			},
			fireLegacyEvent: function( R, P ) {
				var T = true,
					M, V, U, N, S; V = E[ P ].slice();
				for ( var O = 0, Q = V.length; O < Q; ++O ) {
					U = V[ O ];
					if ( U && U[ this.WFN ] ) {
						N = U[ this.ADJ_SCOPE ];
						S = U[ this.WFN ].call( N, R );
						T = ( T && S );
					}
				}
				M = G[ P ];
				if ( M && M[ 2 ] ) {
					M[ 2 ]( R );
				}
				return T;
			},
			getLegacyIndex: function( N, O ) {
				var M = this.generateId( N ) + O;
				if ( typeof B[ M ] == "undefined" ) {
					return -1;
				} else {
					return B[ M ];
				}
			},
			useLegacyEvent: function( M, N ) {
				return ( this.webkit && this.webkit < 419 && ( "click" == N || "dblclick" == N ) );
			},
			removeListener: function( N, M, V ) {
				var Q, T, X; if ( typeof N == "string" ) {
					N = this.getEl( N );
				} else {
					if ( this._isValidCollection( N ) ) {
						var W = true;
						for ( Q = N.length - 1; Q > -1; Q-- ) {
							W = ( this.removeListener( N[ Q ], M, V ) && W );
						}
						return W;
					}
				}
				if ( !V || !V.call ) {
					return this.purgeElement( N, false, M );
				}
				if ( "unload" == M ) {
					for ( Q = J.length - 1; Q > -1; Q-- ) {
						X = J[ Q ];
						if ( X && X[ 0 ] == N && X[ 1 ] == M && X[ 2 ] == V ) {
							J.splice( Q, 1 );
							return true;
						}
					}
					return false;
				}
				var R = null;
				var S = arguments[ 3 ];
				if ( "undefined" === typeof S ) {
					S = this._getCacheIndex( N, M, V );
				}
				if ( S >= 0 ) {
					R = I[ S ];
				}
				if ( !N || !R ) {
					return false;
				}
				if ( this.useLegacyEvent( N, M ) ) {
					var P = this.getLegacyIndex( N, M );
					var O = E[ P ];
					if ( O ) {
						for ( Q = 0, T = O.length; Q < T; ++Q ) {
							X = O[ Q ];
							if ( X && X[ this.EL ] == N && X[ this.TYPE ] == M && X[ this.FN ] == V ) {
								O.splice( Q, 1 );
								break;
							}
						}
					}
				} else {
					try {
						this._simpleRemove( N, M, R[ this.WFN ], false );
					} catch ( U ) {
						this.lastError = U;
						return false;
					}
				}
				delete I[ S ][ this.WFN ];
				delete I[ S ][ this.FN ];
				I.splice( S, 1 );
				return true;
			},
			getTarget: function( O, N ) {
				var M = O.target || O.srcElement; return this.resolveTextNode( M );
			},
			resolveTextNode: function( N ) {
				try {
					if ( N && 3 == N.nodeType ) {
						return N.parentNode;
					}
				} catch ( M ) {}
				return N;
			},
			getPageX: function( N ) {
				var M = N.pageX; if ( !M && 0 !== M ) {
					M = N.clientX || 0;
					if ( this.isIE ) {
						M += this._getScrollLeft();
					}
				}
				return M;
			},
			getPageY: function( M ) {
				var N = M.pageY; if ( !N && 0 !== N ) {
					N = M.clientY || 0;
					if ( this.isIE ) {
						N += this._getScrollTop();
					}
				}
				return N;
			},
			getXY: function( M ) {
				return [ this.getPageX( M ), this.getPageY( M ) ];
			},
			getRelatedTarget: function( N ) {
				var M = N.relatedTarget; if ( !M ) {
					if ( N.type == "mouseout" ) {
						M = N.toElement;
					} else {
						if ( N.type == "mouseover" ) {
							M = N.fromElement;
						}
					}
				}
				return this.resolveTextNode( M );
			},
			getTime: function( O ) {
				if ( !O.time ) {
					var N = new Date().getTime();
					try {
						O.time = N;
					} catch ( M ) {
						this.lastError = M;
						return N;
					}
				}
				return O.time;
			},
			stopEvent: function( M ) {
				this.stopPropagation( M );
				this.preventDefault( M );
			},
			stopPropagation: function( M ) {
				if ( M.stopPropagation ) {
					M.stopPropagation();
				} else {
					M.cancelBubble = true;
				}
			},
			preventDefault: function( M ) {
				if ( M.preventDefault ) {
					M.preventDefault();
				} else {
					M.returnValue = false;
				}
			},
			getEvent: function( O, M ) {
				var N = O || window.event; if ( !N ) {
					var P = this.getEvent.caller;
					while ( P ) {
						N = P.arguments[ 0 ];
						if ( N && Event == N.constructor ) {
							break;
						}
						P = P.caller;
					}
				}
				return N;
			},
			getCharCode: function( N ) {
				var M = N.keyCode || N.charCode || 0; if ( YAHOO.env.ua.webkit && ( M in D ) ) {
					M = D[ M ];
				}
				return M;
			},
			_getCacheIndex: function( Q, R, P ) {
				for ( var O = 0, N = I.length; O < N; O = O + 1 ) {
					var M = I[ O ];
					if ( M && M[ this.FN ] == P && M[ this.EL ] == Q && M[ this.TYPE ] == R ) {
						return O;
					}
				}
				return -1;
			},
			generateId: function( M ) {
				var N = M.id; if ( !N ) {
					N = "yuievtautoid-" + A;
					++A;
					M.id = N;
				}
				return N;
			},
			_isValidCollection: function( N ) {
				try {
					return ( N && typeof N !== "string" && N.length && !N.tagName && !N.alert && typeof N[ 0 ] !== "undefined" );
				} catch ( M ) {
					return false;
				}
			},
			elCache: {},
			getEl: function( M ) {
				return ( typeof M === "string" ) ? document.getElementById( M ) : M;
			},
			clearCache: function() {},
			DOMReadyEvent: new YAHOO.util.CustomEvent( "DOMReady", this ), _load: function( N ) {
				if ( !H ) {
					H = true;
					var M = YAHOO.util.Event;
					M._ready();
					M._tryPreloadAttach();
				}
			},
			_ready: function( N ) {
				var M = YAHOO.util.Event; if ( !M.DOMReady ) {
					M.DOMReady = true;
					M.DOMReadyEvent.fire();
					M._simpleRemove( document, "DOMContentLoaded", M._ready );
				}
			},
			_tryPreloadAttach: function() {
				if ( F.length === 0 ) {
					C = 0;
					if ( this._interval ) {
						clearInterval( this._interval );
						this._interval = null;
					}
					return;
				}
				if ( this.locked ) {
					return;
				}
				if ( this.isIE ) {
					if ( !this.DOMReady ) {
						this.startInterval();
						return;
					}
				}
				this.locked = true;
				var S = !H;
				if ( !S ) {
					S = ( C > 0 && F.length > 0 );
				}
				var R = [];
				var T = function( V, W ) {
						var U = V;
						if ( W.overrideContext ) {
							if ( W.overrideContext === true ) {
								U = W.obj;
							} else {
								U = W.overrideContext;
							}
						}
						W.fn.call( U, W.obj );
					};
				var N, M, Q, P,
					O = [];
				for ( N = 0, M = F.length; N < M; N = N + 1 ) {
					Q = F[ N ];
					if ( Q ) {
						P = this.getEl( Q.id );
						if ( P ) {
							if ( Q.checkReady ) {
								if ( H || P.nextSibling || !S ) {
									O.push( Q );
									F[ N ] = null;
								}
							} else {
								T( P, Q );
								F[ N ] = null;
							}
						} else {
							R.push( Q );
						}
					}
				}
				for ( N = 0, M = O.length; N < M; N = N + 1 ) {
					Q = O[ N ];
					T( this.getEl( Q.id ), Q );
				}
				C--;
				if ( S ) {
					for ( N = F.length - 1; N > -1; N-- ) {
						Q = F[ N ];
						if ( !Q || !Q.id ) {
							F.splice( N, 1 );
						}
					}
					this.startInterval();
				} else {
					if ( this._interval ) {
						clearInterval( this._interval );
						this._interval = null;
					}
				}
				this.locked = false;
			},
			purgeElement: function( Q, R, T ) {
				var O = ( YAHOO.lang.isString( Q ) ) ? this.getEl( Q ) : Q;
				var S = this.getListeners( O, T ),
					P, M;
				if ( S ) {
					for ( P = S.length - 1; P > -1; P-- ) {
						var N = S[ P ];
						this.removeListener( O, N.type, N.fn );
					}
				}
				if ( R && O && O.childNodes ) {
					for ( P = 0, M = O.childNodes.length; P < M; ++P ) {
						this.purgeElement( O.childNodes[ P ], R, T );
					}
				}
			},
			getListeners: function( O, M ) {
				var R = [],
					N;
				if ( !M ) {
					N = [ I, J ];
				} else {
					if ( M === "unload" ) {
						N = [ J ];
					} else {
						N = [ I ];
					}
				}
				var T = ( YAHOO.lang.isString( O ) ) ? this.getEl( O ) : O;
				for ( var Q = 0; Q < N.length; Q = Q + 1 ) {
					var V = N[ Q ];
					if ( V ) {
						for ( var S = 0, U = V.length; S < U; ++S ) {
							var P = V[ S ];
							if ( P && P[ this.EL ] === T && ( !M || M === P[ this.TYPE ] ) ) {
								R.push({ type: P[ this.TYPE ], fn: P[ this.FN ], obj: P[ this.OBJ ], adjust: P[ this.OVERRIDE ], scope: P[ this.ADJ_SCOPE ], index: S } );
							}
						}
					}
				}
				return ( R.length ) ? R : null;
			},
			_unload: function( T ) {
				var N = YAHOO.util.Event,
					Q, P, O, S, R,
					U = J.slice(),
					M;
				for ( Q = 0, S = J.length; Q < S; ++Q ) {
					O = U[ Q ];
					if ( O ) {
						M = window;
						if ( O[ N.ADJ_SCOPE ] ) {
							if ( O[ N.ADJ_SCOPE ] === true ) {
								M = O[ N.UNLOAD_OBJ ];
							} else {
								M = O[ N.ADJ_SCOPE ];
							}
						}
						O[ N.FN ].call( M, N.getEvent( T, O[ N.EL ] ), O[ N.UNLOAD_OBJ ] );
						U[ Q ] = null;
					}
				}
				O = null;
				M = null;
				J = null;
				if ( I ) {
					for ( P = I.length - 1; P > -1; P-- ) {
						O = I[ P ];
						if ( O ) {
							N.removeListener( O[ N.EL ], O[ N.TYPE ], O[ N.FN ], P );
						}
					}
					O = null;
				}
				G = null;
				N._simpleRemove( window, "unload", N._unload );
			},
			_getScrollLeft: function() {
				return this._getScroll()[ 1 ];
			},
			_getScrollTop: function() {
				return this._getScroll()[ 0 ];
			},
			_getScroll: function() {
				var M = document.documentElement,
					N = document.body; if ( M && ( M.scrollTop || M.scrollLeft ) ) {
					return [ M.scrollTop, M.scrollLeft ];
				} else {
					if ( N ) {
						return [ N.scrollTop, N.scrollLeft ];
					} else {
						return [ 0, 0 ];
					}
				}
			},
			regCE: function() {},
			_simpleAdd: function() {
				if ( window.addEventListener ) {
					return function( O, P, N, M ) {
						O.addEventListener( P, N, ( M ) );
					};
				} else {
					if ( window.attachEvent ) {
						return function( O, P, N, M ) {
							O.attachEvent( "on" + P, N );
						};
					} else {
						return function() {};
					}
				}
			}(), _simpleRemove: function() {
				if ( window.removeEventListener ) {
					return function( O, P, N, M ) {
						O.removeEventListener( P, N, ( M ) );
					};
				} else {
					if ( window.detachEvent ) {
						return function( N, O, M ) {
							N.detachEvent( "on" + O, M );
						};
					} else {
						return function() {};
					}
				}
			}() };
	}();
	(function() {
		var EU = YAHOO.util.Event;
		EU.on = EU.addListener;
		EU.onFocus = EU.addFocusListener;
		EU.onBlur = EU.addBlurListener;
		/* DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller */
		if ( EU.isIE ) {
			YAHOO.util.Event.onDOMReady( YAHOO.util.Event._tryPreloadAttach, YAHOO.util.Event, true );
			var n = document.createElement( "p" );
			EU._dri = setInterval( function() {
				try {
					n.doScroll( "left" );
					clearInterval( EU._dri );
					EU._dri = null;
					EU._ready();
					n = null;
				} catch ( ex ) {}
			}, EU.POLL_INTERVAL );
		} else {
			if ( EU.webkit && EU.webkit < 525 ) {
				EU._dri = setInterval( function() {
					var rs = document.readyState;
					if ( "loaded" == rs || "complete" == rs ) {
						clearInterval( EU._dri );
						EU._dri = null;
						EU._ready();
					}
				}, EU.POLL_INTERVAL );
			} else {
				EU._simpleAdd( document, "DOMContentLoaded", EU._ready );
			}
		}
		EU._simpleAdd( window, "load", EU._load );
		EU._simpleAdd( window, "unload", EU._unload );
		EU._tryPreloadAttach();
	})();
}
YAHOO.util.EventProvider = function() {};
YAHOO.util.EventProvider.prototype = {
	__yui_events: null, __yui_subscribers: null, subscribe: function( A, C, F, E ) {
		this.__yui_events = this.__yui_events || {};
		var D = this.__yui_events[ A ];
		if ( D ) {
			D.subscribe( C, F, E );
		} else {
			this.__yui_subscribers = this.__yui_subscribers || {};
			var B = this.__yui_subscribers;
			if ( !B[ A ] ) {
				B[ A ] = [];
			}
			B[ A ].push({ fn: C, obj: F, overrideContext: E } );
		}
	},
	unsubscribe: function( C, E, G ) {
		this.__yui_events = this.__yui_events || {};
		var A = this.__yui_events;
		if ( C ) {
			var F = A[ C ];
			if ( F ) {
				return F.unsubscribe( E, G );
			}
		} else {
			var B = true;
			for ( var D in A ) {
				if ( YAHOO.lang.hasOwnProperty( A, D ) ) {
					B = B && A[ D ].unsubscribe( E, G );
				}
			}
			return B;
		}
		return false;
	},
	unsubscribeAll: function( A ) {
		return this.unsubscribe( A );
	},
	createEvent: function( G, D ) {
		this.__yui_events = this.__yui_events || {};
		var A = D || {};
		var I = this.__yui_events;
		if ( I[ G ] ) {} else {
			var H = A.scope || this;
			var E = ( A.silent );
			var B = new YAHOO.util.CustomEvent( G, H, E, YAHOO.util.CustomEvent.FLAT );
			I[ G ] = B;
			if ( A.onSubscribeCallback ) {
				B.subscribeEvent.subscribe( A.onSubscribeCallback );
			}
			this.__yui_subscribers = this.__yui_subscribers || {};
			var F = this.__yui_subscribers[ G ];
			if ( F ) {
				for ( var C = 0; C < F.length; ++C ) {
					B.subscribe( F[ C ].fn, F[ C ].obj, F[ C ].overrideContext );
				}
			}
		}
		return I[ G ];
	},
	fireEvent: function( E, D, A, C ) {
		this.__yui_events = this.__yui_events || {};
		var G = this.__yui_events[ E ];
		if ( !G ) {
			return null;
		}
		var B = [];
		for ( var F = 1; F < arguments.length; ++F ) {
			B.push( arguments[ F ] );
		}
		return G.fire.apply( G, B );
	},
	hasEvent: function( A ) {
		if ( this.__yui_events ) {
			if ( this.__yui_events[ A ] ) {
				return true;
			}
		}
		return false;
	} };
(function() {
	var A = YAHOO.util.Event,
		C = YAHOO.lang;
	YAHOO.util.KeyListener = function( D, I, E, F ) {
		if ( !D ) {} else {
			if ( !I ) {} else {
				if ( !E ) {}
			}
		}
		if ( !F ) {
			F = YAHOO.util.KeyListener.KEYDOWN;
		}
		var G = new YAHOO.util.CustomEvent( "keyPressed" );
		this.enabledEvent = new YAHOO.util.CustomEvent( "enabled" );
		this.disabledEvent = new YAHOO.util.CustomEvent( "disabled" );
		if ( C.isString( D ) ) {
			D = document.getElementById( D );
		}
		if ( C.isFunction( E ) ) {
			G.subscribe( E );
		} else {
			G.subscribe( E.fn, E.scope, E.correctScope );
		}
		function H( O, N ) {
			if ( !I.shift ) {
				I.shift = false;
			}
			if ( !I.alt ) {
				I.alt = false;
			}
			if ( !I.ctrl ) {
				I.ctrl = false;
			}
			if ( O.shiftKey == I.shift && O.altKey == I.alt && O.ctrlKey == I.ctrl ) {
				var J,
					M = I.keys,
					L;
				if ( YAHOO.lang.isArray( M ) ) {
					for ( var K = 0; K < M.length; K++ ) {
						J = M[ K ];
						L = A.getCharCode( O );
						if ( J == L ) {
							G.fire( L, O );
							break;
						}
					}
				} else {
					L = A.getCharCode( O );
					if ( M == L ) {
						G.fire( L, O );
					}
				}
			}
		}
		this.enable = function() {
			if ( !this.enabled ) {
				A.on( D, F, H );
				this.enabledEvent.fire( I );
			}
			this.enabled = true;
		};
		this.disable = function() {
			if ( this.enabled ) {
				A.removeListener( D, F, H );
				this.disabledEvent.fire( I );
			}
			this.enabled = false;
		};
		this.toString = function() {
			return "KeyListener [" + I.keys + "] " + D.tagName + ( D.id ? "[" + D.id + "]" : "" );
		};
	};
	var B = YAHOO.util.KeyListener;
	B.KEYDOWN = "keydown";
	B.KEYUP = "keyup";
	B.KEY = { ALT: 18, BACK_SPACE: 8, CAPS_LOCK: 20, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, META: 224, NUM_LOCK: 144, PAGE_DOWN: 34, PAGE_UP: 33, PAUSE: 19, PRINTSCREEN: 44, RIGHT: 39, SCROLL_LOCK: 145, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38 };
})();
YAHOO.register( "event", YAHOO.util.Event, { version: "2.7.0", build: "1796" } );
YAHOO.register( "yahoo-dom-event", YAHOO, { version: "2.7.0", build: "1796" } );
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
if ( !YAHOO.util.DragDropMgr ) {
	YAHOO.util.DragDropMgr = function() {
		var A = YAHOO.util.Event,
			B = YAHOO.util.Dom;
		return {
			useShim: false, _shimActive: false, _shimState: false, _debugShim: false, _createShim: function() {
				var C = document.createElement( "div" );
				C.id = "yui-ddm-shim";
				if ( document.body.firstChild ) {
					document.body.insertBefore( C, document.body.firstChild );
				} else {
					document.body.appendChild( C );
				}
				C.style.display = "none";
				C.style.backgroundColor = "red";
				C.style.position = "absolute";
				C.style.zIndex = "99999";
				B.setStyle( C, "opacity", "0" );
				this._shim = C;
				A.on( C, "mouseup", this.handleMouseUp, this, true );
				A.on( C, "mousemove", this.handleMouseMove, this, true );
				A.on( window, "scroll", this._sizeShim, this, true );
			},
			_sizeShim: function() {
				if ( this._shimActive ) {
					var C = this._shim;
					C.style.height = B.getDocumentHeight() + "px";
					C.style.width = B.getDocumentWidth() + "px";
					C.style.top = "0";
					C.style.left = "0";
				}
			},
			_activateShim: function() {
				if ( this.useShim ) {
					if ( !this._shim ) {
						this._createShim();
					}
					this._shimActive = true;
					var C = this._shim,
						D = "0";
					if ( this._debugShim ) {
						D = ".5";
					}
					B.setStyle( C, "opacity", D );
					this._sizeShim();
					C.style.display = "block";
				}
			},
			_deactivateShim: function() {
				this._shim.style.display = "none"; this._shimActive = false;
			},
			_shim: null, ids: {},
			handleIds: {},
			dragCurrent: null, dragOvers: {},
			deltaX: 0, deltaY: 0, preventDefault: true, stopPropagation: true, initialized: false, locked: false, interactionInfo: null, init: function() {
				this.initialized = true;
			},
			POINT: 0, INTERSECT: 1, STRICT_INTERSECT: 2, mode: 0, _execOnAll: function( E, D ) {
				for ( var F in this.ids ) {
					for ( var C in this.ids[ F ] ) {
						var G = this.ids[ F ][ C ];
						if ( !this.isTypeOfDD( G ) ) {
							continue;
						}
						G[ E ].apply( G, D );
					}
				}
			},
			_onLoad: function() {
				this.init();
				A.on( document, "mouseup", this.handleMouseUp, this, true );
				A.on( document, "mousemove", this.handleMouseMove, this, true );
				A.on( window, "unload", this._onUnload, this, true );
				A.on( window, "resize", this._onResize, this, true );
			},
			_onResize: function( C ) {
				this._execOnAll( "resetConstraints", [] );
			},
			lock: function() {
				this.locked = true;
			},
			unlock: function() {
				this.locked = false;
			},
			isLocked: function() {
				return this.locked;
			},
			locationCache: {},
			useCache: true, clickPixelThresh: 3, clickTimeThresh: 1000, dragThreshMet: false, clickTimeout: null, startX: 0, startY: 0, fromTimeout: false, regDragDrop: function( D, C ) {
				if ( !this.initialized ) {
					this.init();
				}
				if ( !this.ids[ C ] ) {
					this.ids[ C ] = {};
				}
				this.ids[ C ][ D.id ] = D;
			},
			removeDDFromGroup: function( E, C ) {
				if ( !this.ids[ C ] ) {
					this.ids[ C ] = {};
				}
				var D = this.ids[ C ];
				if ( D && D[ E.id ] ) {
					delete D[ E.id ];
				}
			},
			_remove: function( E ) {
				for ( var D in E.groups ) {
					if ( D ) {
						var C = this.ids[ D ];
						if ( C && C[ E.id ] ) {
							delete C[ E.id ];
						}
					}
				}
				delete this.handleIds[ E.id ];
			},
			regHandle: function( D, C ) {
				if ( !this.handleIds[ D ] ) {
					this.handleIds[ D ] = {};
				}
				this.handleIds[ D ][ C ] = C;
			},
			isDragDrop: function( C ) {
				return ( this.getDDById( C ) ) ? true : false;
			},
			getRelated: function( H, D ) {
				var G = [];
				for ( var F in H.groups ) {
					for ( var E in this.ids[ F ] ) {
						var C = this.ids[ F ][ E ];
						if ( !this.isTypeOfDD( C ) ) {
							continue;
						}
						if ( !D || C.isTarget ) {
							G[ G.length ] = C;
						}
					}
				}
				return G;
			},
			isLegalTarget: function( G, F ) {
				var D = this.getRelated( G, true );
				for ( var E = 0, C = D.length; E < C; ++E ) {
					if ( D[ E ].id == F.id ) {
						return true;
					}
				}
				return false;
			},
			isTypeOfDD: function( C ) {
				return ( C && C.__ygDragDrop );
			},
			isHandle: function( D, C ) {
				return ( this.handleIds[ D ] && this.handleIds[ D ][ C ] );
			},
			getDDById: function( D ) {
				for ( var C in this.ids ) {
					if ( this.ids[ C ][ D ] ) {
						return this.ids[ C ][ D ];
					}
				}
				return null;
			},
			handleMouseDown: function( E, D ) {
				this.currentTarget = YAHOO.util.Event.getTarget( E );
				this.dragCurrent = D;
				var C = D.getEl();
				this.startX = YAHOO.util.Event.getPageX( E );
				this.startY = YAHOO.util.Event.getPageY( E );
				this.deltaX = this.startX - C.offsetLeft;
				this.deltaY = this.startY - C.offsetTop;
				this.dragThreshMet = false;
				this.clickTimeout = setTimeout( function() {
					var F = YAHOO.util.DDM;
					F.startDrag( F.startX, F.startY );
					F.fromTimeout = true;
				}, this.clickTimeThresh );
			},
			startDrag: function( C, E ) {
				if ( this.dragCurrent && this.dragCurrent.useShim ) {
					this._shimState = this.useShim;
					this.useShim = true;
				}
				this._activateShim();
				clearTimeout( this.clickTimeout );
				var D = this.dragCurrent;
				if ( D && D.events.b4StartDrag ) {
					D.b4StartDrag( C, E );
					D.fireEvent( "b4StartDragEvent", { x: C, y: E } );
				}
				if ( D && D.events.startDrag ) {
					D.startDrag( C, E );
					D.fireEvent( "startDragEvent", { x: C, y: E } );
				}
				this.dragThreshMet = true;
			},
			handleMouseUp: function( C ) {
				if ( this.dragCurrent ) {
					clearTimeout( this.clickTimeout );
					if ( this.dragThreshMet ) {
						if ( this.fromTimeout ) {
							this.fromTimeout = false;
							this.handleMouseMove( C );
						}
						this.fromTimeout = false;
						this.fireEvents( C, true );
					} else {}
					this.stopDrag( C );
					this.stopEvent( C );
				}
			},
			stopEvent: function( C ) {
				if ( this.stopPropagation ) {
					YAHOO.util.Event.stopPropagation( C );
				}
				if ( this.preventDefault ) {
					YAHOO.util.Event.preventDefault( C );
				}
			},
			stopDrag: function( E, D ) {
				var C = this.dragCurrent; if ( C && !D ) {
					if ( this.dragThreshMet ) {
						if ( C.events.b4EndDrag ) {
							C.b4EndDrag( E );
							C.fireEvent( "b4EndDragEvent", { e: E } );
						}
						if ( C.events.endDrag ) {
							C.endDrag( E );
							C.fireEvent( "endDragEvent", { e: E } );
						}
					}
					if ( C.events.mouseUp ) {
						C.onMouseUp( E );
						C.fireEvent( "mouseUpEvent", { e: E } );
					}
				}
				if ( this._shimActive ) {
					this._deactivateShim();
					if ( this.dragCurrent && this.dragCurrent.useShim ) {
						this.useShim = this._shimState;
						this._shimState = false;
					}
				}
				this.dragCurrent = null;
				this.dragOvers = {};
			},
			handleMouseMove: function( F ) {
				var C = this.dragCurrent; if ( C ) {
					if ( YAHOO.util.Event.isIE && !F.button ) {
						this.stopEvent( F );
						return this.handleMouseUp( F );
					} else {
						if ( F.clientX < 0 || F.clientY < 0 ) {}
					}
					if ( !this.dragThreshMet ) {
						var E = Math.abs( this.startX - YAHOO.util.Event.getPageX( F ) );
						var D = Math.abs( this.startY - YAHOO.util.Event.getPageY( F ) );
						if ( E > this.clickPixelThresh || D > this.clickPixelThresh ) {
							this.startDrag( this.startX, this.startY );
						}
					}
					if ( this.dragThreshMet ) {
						if ( C && C.events.b4Drag ) {
							C.b4Drag( F );
							C.fireEvent( "b4DragEvent", { e: F } );
						}
						if ( C && C.events.drag ) {
							C.onDrag( F );
							C.fireEvent( "dragEvent", { e: F } );
						}
						if ( C ) {
							this.fireEvents( F, false );
						}
					}
					this.stopEvent( F );
				}
			},
			fireEvents: function( V, L ) {
				var a = this.dragCurrent; if ( !a || a.isLocked() || a.dragOnly ) {
					return;
				}
				var N = YAHOO.util.Event.getPageX( V ),
					M = YAHOO.util.Event.getPageY( V ),
					P = new YAHOO.util.Point( N, M ),
					K = a.getTargetCoord( P.x, P.y ),
					F = a.getDragEl(),
					E = [ "out", "over", "drop", "enter" ],
					U = new YAHOO.util.Region( K.y, K.x + F.offsetWidth, K.y + F.offsetHeight, K.x ),
					I = [],
					D = {},
					Q = [],
					c = { outEvts: [], overEvts: [], dropEvts: [], enterEvts: [] }; for ( var S in this.dragOvers ) {
					var d = this.dragOvers[ S ];
					if ( !this.isTypeOfDD( d ) ) {
						continue;
					}
					if ( !this.isOverTarget( P, d, this.mode, U ) ) {
						c.outEvts.push( d );
					}
					I[ S ] = true;
					delete this.dragOvers[ S ];
				}
				for ( var R in a.groups ) {
					if ( "string" != typeof R ) {
						continue;
					}
					for ( S in this.ids[ R ] ) {
						var G = this.ids[ R ][ S ];
						if ( !this.isTypeOfDD( G ) ) {
							continue;
						}
						if ( G.isTarget && !G.isLocked() && G != a ) {
							if ( this.isOverTarget( P, G, this.mode, U ) ) {
								D[ R ] = true;
								if ( L ) {
									c.dropEvts.push( G );
								} else {
									if ( !I[ G.id ] ) {
										c.enterEvts.push( G );
									} else {
										c.overEvts.push( G );
									}
									this.dragOvers[ G.id ] = G;
								}
							}
						}
					}
				}
				this.interactionInfo = { out: c.outEvts, enter: c.enterEvts, over: c.overEvts, drop: c.dropEvts, point: P, draggedRegion: U, sourceRegion: this.locationCache[ a.id ], validDrop: L }; for ( var C in D ) {
					Q.push( C );
				}
				if ( L && !c.dropEvts.length ) {
					this.interactionInfo.validDrop = false;
					if ( a.events.invalidDrop ) {
						a.onInvalidDrop( V );
						a.fireEvent( "invalidDropEvent", { e: V } );
					}
				}
				for ( S = 0; S < E.length; S++ ) {
					var Y = null;
					if ( c[ E[ S ] + "Evts" ] ) {
						Y = c[ E[ S ] + "Evts" ];
					}
					if ( Y && Y.length ) {
						var H = E[ S ].charAt( 0 ).toUpperCase() + E[ S ].substr( 1 ),
							X = "onDrag" + H,
							J = "b4Drag" + H,
							O = "drag" + H + "Event",
							W = "drag" + H;
						if ( this.mode ) {
							if ( a.events[ J ] ) {
								a[ J ]( V, Y, Q );
								a.fireEvent( J + "Event", { event: V, info: Y, group: Q } );
							}
							if ( a.events[ W ] ) {
								a[ X ]( V, Y, Q );
								a.fireEvent( O, { event: V, info: Y, group: Q } );
							}
						} else {
							for ( var Z = 0, T = Y.length; Z < T; ++Z ) {
								if ( a.events[ J ] ) {
									a[ J ]( V, Y[ Z ].id, Q[ 0 ] );
									a.fireEvent( J + "Event", { event: V, info: Y[ Z ].id, group: Q[ 0 ] } );
								}
								if ( a.events[ W ] ) {
									a[ X ]( V, Y[ Z ].id, Q[ 0 ] );
									a.fireEvent( O, { event: V, info: Y[ Z ].id, group: Q[ 0 ] } );
								}
							}
						}
					}
				}
			},
			getBestMatch: function( E ) {
				var G = null; var D = E.length; if ( D == 1 ) {
					G = E[ 0 ];
				} else {
					for ( var F = 0; F < D; ++F ) {
						var C = E[ F ];
						if ( this.mode == this.INTERSECT && C.cursorIsOver ) {
							G = C;
							break;
						} else {
							if ( !G || !G.overlap || ( C.overlap && G.overlap.getArea() < C.overlap.getArea() ) ) {
								G = C;
							}
						}
					}
				}
				return G;
			},
			refreshCache: function( D ) {
				var F = D || this.ids; for ( var C in F ) {
					if ( "string" != typeof C ) {
						continue;
					}
					for ( var E in this.ids[ C ] ) {
						var G = this.ids[ C ][ E ];
						if ( this.isTypeOfDD( G ) ) {
							var H = this.getLocation( G );
							if ( H ) {
								this.locationCache[ G.id ] = H;
							} else {
								delete this.locationCache[ G.id ];
							}
						}
					}
				}
			},
			verifyEl: function( D ) {
				try {
					if ( D ) {
						var C = D.offsetParent;
						if ( C ) {
							return true;
						}
					}
				} catch ( E ) {}
				return false;
			},
			getLocation: function( H ) {
				if ( !this.isTypeOfDD( H ) ) {
					return null;
				}
				var F = H.getEl(),
					K, E, D, M, L, N, C, J, G;
				try {
					K = YAHOO.util.Dom.getXY( F );
				} catch ( I ) {}
				if ( !K ) {
					return null;
				}
				E = K[ 0 ];
				D = E + F.offsetWidth;
				M = K[ 1 ];
				L = M + F.offsetHeight;
				N = M - H.padding[ 0 ];
				C = D + H.padding[ 1 ];
				J = L + H.padding[ 2 ];
				G = E - H.padding[ 3 ];
				return new YAHOO.util.Region( N, C, J, G );
			},
			isOverTarget: function( K, C, E, F ) {
				var G = this.locationCache[ C.id ];
				if ( !G || !this.useCache ) {
					G = this.getLocation( C );
					this.locationCache[ C.id ] = G;
				}
				if ( !G ) {
					return false;
				}
				C.cursorIsOver = G.contains( K );
				var J = this.dragCurrent;
				if ( !J || ( !E && !J.constrainX && !J.constrainY ) ) {
					return C.cursorIsOver;
				}
				C.overlap = null;
				if ( !F ) {
					var H = J.getTargetCoord( K.x, K.y );
					var D = J.getDragEl();
					F = new YAHOO.util.Region( H.y, H.x + D.offsetWidth, H.y + D.offsetHeight, H.x );
				}
				var I = F.intersect( G );
				if ( I ) {
					C.overlap = I;
					return ( E ) ? true : C.cursorIsOver;
				} else {
					return false;
				}
			},
			_onUnload: function( D, C ) {
				this.unregAll();
			},
			unregAll: function() {
				if ( this.dragCurrent ) {
					this.stopDrag();
					this.dragCurrent = null;
				}
				this._execOnAll( "unreg", [] );
				this.ids = {};
			},
			elementCache: {},
			getElWrapper: function( D ) {
				var C = this.elementCache[ D ];
				if ( !C || !C.el ) {
					C = this.elementCache[ D ] = new this.ElementWrapper( YAHOO.util.Dom.get( D ) );
				}
				return C;
			},
			getElement: function( C ) {
				return YAHOO.util.Dom.get( C );
			},
			getCss: function( D ) {
				var C = YAHOO.util.Dom.get( D );
				return ( C ) ? C.style : null;
			},
			ElementWrapper: function( C ) {
				this.el = C || null; this.id = this.el && C.id; this.css = this.el && C.style;
			},
			getPosX: function( C ) {
				return YAHOO.util.Dom.getX( C );
			},
			getPosY: function( C ) {
				return YAHOO.util.Dom.getY( C );
			},
			swapNode: function( E, C ) {
				if ( E.swapNode ) {
					E.swapNode( C );
				} else {
					var F = C.parentNode;
					var D = C.nextSibling;
					if ( D == E ) {
						F.insertBefore( E, C );
					} else {
						if ( C == E.nextSibling ) {
							F.insertBefore( C, E );
						} else {
							E.parentNode.replaceChild( C, E );
							F.insertBefore( E, D );
						}
					}
				}
			},
			getScroll: function() {
				var E, C,
					F = document.documentElement,
					D = document.body; if ( F && ( F.scrollTop || F.scrollLeft ) ) {
					E = F.scrollTop;
					C = F.scrollLeft;
				} else {
					if ( D ) {
						E = D.scrollTop;
						C = D.scrollLeft;
					} else {}
				}
				return { top: E, left: C };
			},
			getStyle: function( D, C ) {
				return YAHOO.util.Dom.getStyle( D, C );
			},
			getScrollTop: function() {
				return this.getScroll().top;
			},
			getScrollLeft: function() {
				return this.getScroll().left;
			},
			moveToEl: function( C, E ) {
				var D = YAHOO.util.Dom.getXY( E );
				YAHOO.util.Dom.setXY( C, D );
			},
			getClientHeight: function() {
				return YAHOO.util.Dom.getViewportHeight();
			},
			getClientWidth: function() {
				return YAHOO.util.Dom.getViewportWidth();
			},
			numericSort: function( D, C ) {
				return ( D - C );
			},
			_timeoutCount: 0, _addListeners: function() {
				var C = YAHOO.util.DDM; if ( YAHOO.util.Event && document ) {
					C._onLoad();
				} else {
					if ( C._timeoutCount > 2000 ) {} else {
						setTimeout( C._addListeners, 10 );
						if ( document && document.body ) {
							C._timeoutCount += 1;
						}
					}
				}
			},
			handleWasClicked: function( C, E ) {
				if ( this.isHandle( E, C.id ) ) {
					return true;
				} else {
					var D = C.parentNode;
					while ( D ) {
						if ( this.isHandle( E, D.id ) ) {
							return true;
						} else {
							D = D.parentNode;
						}
					}
				}
				return false;
			} };
	}();
	YAHOO.util.DDM = YAHOO.util.DragDropMgr;
	YAHOO.util.DDM._addListeners();
}( function() {
	var A = YAHOO.util.Event;
	var B = YAHOO.util.Dom;
	YAHOO.util.DragDrop = function( E, C, D ) {
		if ( E ) {
			this.init( E, C, D );
		}
	};
	YAHOO.util.DragDrop.prototype = {
		events: null, on: function() {
			this.subscribe.apply( this, arguments );
		},
		id: null, config: null, dragElId: null, handleElId: null, invalidHandleTypes: null, invalidHandleIds: null, invalidHandleClasses: null, startPageX: 0, startPageY: 0, groups: null, locked: false, lock: function() {
			this.locked = true;
		},
		unlock: function() {
			this.locked = false;
		},
		isTarget: true, padding: null, dragOnly: false, useShim: false, _domRef: null, __ygDragDrop: true, constrainX: false, constrainY: false, minX: 0, maxX: 0, minY: 0, maxY: 0, deltaX: 0, deltaY: 0, maintainOffset: false, xTicks: null, yTicks: null, primaryButtonOnly: true, available: false, hasOuterHandles: false, cursorIsOver: false, overlap: null, b4StartDrag: function( C, D ) {},
		startDrag: function( C, D ) {},
		b4Drag: function( C ) {},
		onDrag: function( C ) {},
		onDragEnter: function( C, D ) {},
		b4DragOver: function( C ) {},
		onDragOver: function( C, D ) {},
		b4DragOut: function( C ) {},
		onDragOut: function( C, D ) {},
		b4DragDrop: function( C ) {},
		onDragDrop: function( C, D ) {},
		onInvalidDrop: function( C ) {},
		b4EndDrag: function( C ) {},
		endDrag: function( C ) {},
		b4MouseDown: function( C ) {},
		onMouseDown: function( C ) {},
		onMouseUp: function( C ) {},
		onAvailable: function() {},
		getEl: function() {
			if ( !this._domRef ) {
				this._domRef = B.get( this.id );
			}
			return this._domRef;
		},
		getDragEl: function() {
			return B.get( this.dragElId );
		},
		init: function( F, C, D ) {
			this.initTarget( F, C, D );
			A.on( this._domRef || this.id, "mousedown", this.handleMouseDown, this, true );
			for ( var E in this.events ) {
				this.createEvent( E + "Event" );
			}
		},
		initTarget: function( E, C, D ) {
			this.config = D || {};
			this.events = {};
			this.DDM = YAHOO.util.DDM;
			this.groups = {};
			if ( typeof E !== "string" ) {
				this._domRef = E;
				E = B.generateId( E );
			}
			this.id = E;
			this.addToGroup( ( C ) ? C : "default" );
			this.handleElId = E;
			A.onAvailable( E, this.handleOnAvailable, this, true );
			this.setDragElId( E );
			this.invalidHandleTypes = { A: "A" }; this.invalidHandleIds = {};
			this.invalidHandleClasses = [];
			this.applyConfig();
		},
		applyConfig: function() {
			this.events = { mouseDown: true, b4MouseDown: true, mouseUp: true, b4StartDrag: true, startDrag: true, b4EndDrag: true, endDrag: true, drag: true, b4Drag: true, invalidDrop: true, b4DragOut: true, dragOut: true, dragEnter: true, b4DragOver: true, dragOver: true, b4DragDrop: true, dragDrop: true }; if ( this.config.events ) {
				for ( var C in this.config.events ) {
					if ( this.config.events[ C ] === false ) {
						this.events[ C ] = false;
					}
				}
			}
			this.padding = this.config.padding || [ 0, 0, 0, 0 ];
			this.isTarget = ( this.config.isTarget !== false );
			this.maintainOffset = ( this.config.maintainOffset );
			this.primaryButtonOnly = ( this.config.primaryButtonOnly !== false );
			this.dragOnly = ( ( this.config.dragOnly === true ) ? true : false );
			this.useShim = ( ( this.config.useShim === true ) ? true : false );
		},
		handleOnAvailable: function() {
			this.available = true; this.resetConstraints();
			this.onAvailable();
		},
		setPadding: function( E, C, F, D ) {
			if ( !C && 0 !== C ) {
				this.padding = [ E, E, E, E ];
			} else {
				if ( !F && 0 !== F ) {
					this.padding = [ E, C, E, C ];
				} else {
					this.padding = [ E, C, F, D ];
				}
			}
		},
		setInitPosition: function( F, E ) {
			var G = this.getEl();
			if ( !this.DDM.verifyEl( G ) ) {
				if ( G && G.style && ( G.style.display == "none" ) ) {} else {}
				return;
			}
			var D = F || 0;
			var C = E || 0;
			var H = B.getXY( G );
			this.initPageX = H[ 0 ] - D;
			this.initPageY = H[ 1 ] - C;
			this.lastPageX = H[ 0 ];
			this.lastPageY = H[ 1 ];
			this.setStartPosition( H );
		},
		setStartPosition: function( D ) {
			var C = D || B.getXY( this.getEl() );
			this.deltaSetXY = null;
			this.startPageX = C[ 0 ];
			this.startPageY = C[ 1 ];
		},
		addToGroup: function( C ) {
			this.groups[ C ] = true;
			this.DDM.regDragDrop( this, C );
		},
		removeFromGroup: function( C ) {
			if ( this.groups[ C ] ) {
				delete this.groups[ C ];
			}
			this.DDM.removeDDFromGroup( this, C );
		},
		setDragElId: function( C ) {
			this.dragElId = C;
		},
		setHandleElId: function( C ) {
			if ( typeof C !== "string" ) {
				C = B.generateId( C );
			}
			this.handleElId = C;
			this.DDM.regHandle( this.id, C );
		},
		setOuterHandleElId: function( C ) {
			if ( typeof C !== "string" ) {
				C = B.generateId( C );
			}
			A.on( C, "mousedown", this.handleMouseDown, this, true );
			this.setHandleElId( C );
			this.hasOuterHandles = true;
		},
		unreg: function() {
			A.removeListener( this.id, "mousedown", this.handleMouseDown );
			this._domRef = null;
			this.DDM._remove( this );
		},
		isLocked: function() {
			return ( this.DDM.isLocked() || this.locked );
		},
		handleMouseDown: function( J, I ) {
			var D = J.which || J.button; if ( this.primaryButtonOnly && D > 1 ) {
				return;
			}
			if ( this.isLocked() ) {
				return;
			}
			var C = this.b4MouseDown( J ),
				F = true;
			if ( this.events.b4MouseDown ) {
				F = this.fireEvent( "b4MouseDownEvent", J );
			}
			var E = this.onMouseDown( J ),
				H = true;
			if ( this.events.mouseDown ) {
				H = this.fireEvent( "mouseDownEvent", J );
			}
			if ( ( C === false ) || ( E === false ) || ( F === false ) || ( H === false ) ) {
				return;
			}
			this.DDM.refreshCache( this.groups );
			var G = new YAHOO.util.Point( A.getPageX( J ), A.getPageY( J ) );
			if ( !this.hasOuterHandles && !this.DDM.isOverTarget( G, this ) ) {} else {
				if ( this.clickValidator( J ) ) {
					this.setStartPosition();
					this.DDM.handleMouseDown( J, this );
					this.DDM.stopEvent( J );
				} else {}
			}
		},
		clickValidator: function( D ) {
			var C = YAHOO.util.Event.getTarget( D );
			return ( this.isValidHandleChild( C ) && ( this.id == this.handleElId || this.DDM.handleWasClicked( C, this.id ) ) );
		},
		getTargetCoord: function( E, D ) {
			var C = E - this.deltaX; var F = D - this.deltaY; if ( this.constrainX ) {
				if ( C < this.minX ) {
					C = this.minX;
				}
				if ( C > this.maxX ) {
					C = this.maxX;
				}
			}
			if ( this.constrainY ) {
				if ( F < this.minY ) {
					F = this.minY;
				}
				if ( F > this.maxY ) {
					F = this.maxY;
				}
			}
			C = this.getTick( C, this.xTicks );
			F = this.getTick( F, this.yTicks );
			return { x: C, y: F };
		},
		addInvalidHandleType: function( C ) {
			var D = C.toUpperCase();
			this.invalidHandleTypes[ D ] = D;
		},
		addInvalidHandleId: function( C ) {
			if ( typeof C !== "string" ) {
				C = B.generateId( C );
			}
			this.invalidHandleIds[ C ] = C;
		},
		addInvalidHandleClass: function( C ) {
			this.invalidHandleClasses.push( C );
		},
		removeInvalidHandleType: function( C ) {
			var D = C.toUpperCase();
			delete this.invalidHandleTypes[ D ];
		},
		removeInvalidHandleId: function( C ) {
			if ( typeof C !== "string" ) {
				C = B.generateId( C );
			}
			delete this.invalidHandleIds[ C ];
		},
		removeInvalidHandleClass: function( D ) {
			for ( var E = 0, C = this.invalidHandleClasses.length; E < C; ++E ) {
				if ( this.invalidHandleClasses[ E ] == D ) {
					delete this.invalidHandleClasses[ E ];
				}
			}
		},
		isValidHandleChild: function( F ) {
			var E = true; var H; try {
				H = F.nodeName.toUpperCase();
			} catch ( G ) {
				H = F.nodeName;
			}
			E = E && !this.invalidHandleTypes[ H ];
			E = E && !this.invalidHandleIds[ F.id ];
			for ( var D = 0, C = this.invalidHandleClasses.length; E && D < C; ++D ) {
				E = !B.hasClass( F, this.invalidHandleClasses[ D ] );
			}
			return E;
		},
		setXTicks: function( F, C ) {
			this.xTicks = [];
			this.xTickSize = C;
			var E = {};
			for ( var D = this.initPageX; D >= this.minX; D = D - C ) {
				if ( !E[ D ] ) {
					this.xTicks[ this.xTicks.length ] = D;
					E[ D ] = true;
				}
			}
			for ( D = this.initPageX; D <= this.maxX; D = D + C ) {
				if ( !E[ D ] ) {
					this.xTicks[ this.xTicks.length ] = D;
					E[ D ] = true;
				}
			}
			this.xTicks.sort( this.DDM.numericSort );
		},
		setYTicks: function( F, C ) {
			this.yTicks = [];
			this.yTickSize = C;
			var E = {};
			for ( var D = this.initPageY; D >= this.minY; D = D - C ) {
				if ( !E[ D ] ) {
					this.yTicks[ this.yTicks.length ] = D;
					E[ D ] = true;
				}
			}
			for ( D = this.initPageY; D <= this.maxY; D = D + C ) {
				if ( !E[ D ] ) {
					this.yTicks[ this.yTicks.length ] = D;
					E[ D ] = true;
				}
			}
			this.yTicks.sort( this.DDM.numericSort );
		},
		setXConstraint: function( E, D, C ) {
			this.leftConstraint = parseInt( E, 10 );
			this.rightConstraint = parseInt( D, 10 );
			this.minX = this.initPageX - this.leftConstraint;
			this.maxX = this.initPageX + this.rightConstraint;
			if ( C ) {
				this.setXTicks( this.initPageX, C );
			}
			this.constrainX = true;
		},
		clearConstraints: function() {
			this.constrainX = false; this.constrainY = false; this.clearTicks();
		},
		clearTicks: function() {
			this.xTicks = null; this.yTicks = null; this.xTickSize = 0; this.yTickSize = 0;
		},
		setYConstraint: function( C, E, D ) {
			this.topConstraint = parseInt( C, 10 );
			this.bottomConstraint = parseInt( E, 10 );
			this.minY = this.initPageY - this.topConstraint;
			this.maxY = this.initPageY + this.bottomConstraint;
			if ( D ) {
				this.setYTicks( this.initPageY, D );
			}
			this.constrainY = true;
		},
		resetConstraints: function() {
			if ( this.initPageX || this.initPageX === 0 ) {
				var D = ( this.maintainOffset ) ? this.lastPageX - this.initPageX : 0;
				var C = ( this.maintainOffset ) ? this.lastPageY - this.initPageY : 0;
				this.setInitPosition( D, C );
			} else {
				this.setInitPosition();
			}
			if ( this.constrainX ) {
				this.setXConstraint( this.leftConstraint, this.rightConstraint, this.xTickSize );
			}
			if ( this.constrainY ) {
				this.setYConstraint( this.topConstraint, this.bottomConstraint, this.yTickSize );
			}
		},
		getTick: function( I, F ) {
			if ( !F ) {
				return I;
			} else {
				if ( F[ 0 ] >= I ) {
					return F[ 0 ];
				} else {
					for ( var D = 0, C = F.length; D < C; ++D ) {
						var E = D + 1;
						if ( F[ E ] && F[ E ] >= I ) {
							var H = I - F[ D ];
							var G = F[ E ] - I;
							return ( G > H ) ? F[ D ] : F[ E ];
						}
					}
					return F[ F.length - 1 ];
				}
			}
		},
		toString: function() {
			return ( "DragDrop " + this.id );
		} }; YAHOO.augment( YAHOO.util.DragDrop, YAHOO.util.EventProvider );
})();
YAHOO.util.DD = function( C, A, B ) {
	if ( C ) {
		this.init( C, A, B );
	}
};
YAHOO.extend( YAHOO.util.DD, YAHOO.util.DragDrop, {
	scroll: true, autoOffset: function( C, B ) {
		var A = C - this.startPageX; var D = B - this.startPageY; this.setDelta( A, D );
	},
	setDelta: function( B, A ) {
		this.deltaX = B; this.deltaY = A;
	},
	setDragElPos: function( C, B ) {
		var A = this.getDragEl();
		this.alignElWithMouse( A, C, B );
	},
	alignElWithMouse: function( C, G, F ) {
		var E = this.getTargetCoord( G, F );
		if ( !this.deltaSetXY ) {
			var H = [ E.x, E.y ];
			YAHOO.util.Dom.setXY( C, H );
			var D = parseInt( YAHOO.util.Dom.getStyle( C, "left" ), 10 );
			var B = parseInt( YAHOO.util.Dom.getStyle( C, "top" ), 10 );
			this.deltaSetXY = [ D - E.x, B - E.y ];
		} else {
			YAHOO.util.Dom.setStyle( C, "left", ( E.x + this.deltaSetXY[ 0 ] ) + "px" );
			YAHOO.util.Dom.setStyle( C, "top", ( E.y + this.deltaSetXY[ 1 ] ) + "px" );
		}
		this.cachePosition( E.x, E.y );
		var A = this;
		setTimeout( function() {
			A.autoScroll.call( A, E.x, E.y, C.offsetHeight, C.offsetWidth );
		}, 0 );
	},
	cachePosition: function( B, A ) {
		if ( B ) {
			this.lastPageX = B;
			this.lastPageY = A;
		} else {
			var C = YAHOO.util.Dom.getXY( this.getEl() );
			this.lastPageX = C[ 0 ];
			this.lastPageY = C[ 1 ];
		}
	},
	autoScroll: function( J, I, E, K ) {
		if ( this.scroll ) {
			var L = this.DDM.getClientHeight();
			var B = this.DDM.getClientWidth();
			var N = this.DDM.getScrollTop();
			var D = this.DDM.getScrollLeft();
			var H = E + I;
			var M = K + J;
			var G = ( L + N - I - this.deltaY );
			var F = ( B + D - J - this.deltaX );
			var C = 40;
			var A = ( document.all ) ? 80 : 30;
			if ( H > L && G < C ) {
				window.scrollTo( D, N + A );
			}
			if ( I < N && N > 0 && I - N < C ) {
				window.scrollTo( D, N - A );
			}
			if ( M > B && F < C ) {
				window.scrollTo( D + A, N );
			}
			if ( J < D && D > 0 && J - D < C ) {
				window.scrollTo( D - A, N );
			}
		}
	},
	applyConfig: function() {
		YAHOO.util.DD.superclass.applyConfig.call( this );
		this.scroll = ( this.config.scroll !== false );
	},
	b4MouseDown: function( A ) {
		this.setStartPosition();
		this.autoOffset( YAHOO.util.Event.getPageX( A ), YAHOO.util.Event.getPageY( A ) );
	},
	b4Drag: function( A ) {
		this.setDragElPos( YAHOO.util.Event.getPageX( A ), YAHOO.util.Event.getPageY( A ) );
	},
	toString: function() {
		return ( "DD " + this.id );
	} } );
YAHOO.util.DDProxy = function( C, A, B ) {
	if ( C ) {
		this.init( C, A, B );
		this.initFrame();
	}
};
YAHOO.util.DDProxy.dragElId = "ygddfdiv";
YAHOO.extend( YAHOO.util.DDProxy, YAHOO.util.DD, {
	resizeFrame: true, centerFrame: false, createFrame: function() {
		var B = this,
			A = document.body; if ( !A || !A.firstChild ) {
			setTimeout( function() {
				B.createFrame();
			}, 50 );
			return;
		}
		var F = this.getDragEl(),
			E = YAHOO.util.Dom;
		if ( !F ) {
			F = document.createElement( "div" );
			F.id = this.dragElId;
			var D = F.style;
			D.position = "absolute";
			D.visibility = "hidden";
			D.cursor = "move";
			D.border = "2px solid #aaa";
			D.zIndex = 999;
			D.height = "25px";
			D.width = "25px";
			var C = document.createElement( "div" );
			E.setStyle( C, "height", "100%" );
			E.setStyle( C, "width", "100%" );
			E.setStyle( C, "background-color", "#ccc" );
			E.setStyle( C, "opacity", "0" );
			F.appendChild( C );
			A.insertBefore( F, A.firstChild );
		}
	},
	initFrame: function() {
		this.createFrame();
	},
	applyConfig: function() {
		YAHOO.util.DDProxy.superclass.applyConfig.call( this );
		this.resizeFrame = ( this.config.resizeFrame !== false );
		this.centerFrame = ( this.config.centerFrame );
		this.setDragElId( this.config.dragElId || YAHOO.util.DDProxy.dragElId );
	},
	showFrame: function( E, D ) {
		var C = this.getEl();
		var A = this.getDragEl();
		var B = A.style;
		this._resizeProxy();
		if ( this.centerFrame ) {
			this.setDelta( Math.round( parseInt( B.width, 10 ) / 2 ), Math.round( parseInt( B.height, 10 ) / 2 ) );
		}
		this.setDragElPos( E, D );
		YAHOO.util.Dom.setStyle( A, "visibility", "visible" );
	},
	_resizeProxy: function() {
		if ( this.resizeFrame ) {
			var H = YAHOO.util.Dom;
			var B = this.getEl();
			var C = this.getDragEl();
			var G = parseInt( H.getStyle( C, "borderTopWidth" ), 10 );
			var I = parseInt( H.getStyle( C, "borderRightWidth" ), 10 );
			var F = parseInt( H.getStyle( C, "borderBottomWidth" ), 10 );
			var D = parseInt( H.getStyle( C, "borderLeftWidth" ), 10 );
			if ( isNaN( G ) ) {
				G = 0;
			}
			if ( isNaN( I ) ) {
				I = 0;
			}
			if ( isNaN( F ) ) {
				F = 0;
			}
			if ( isNaN( D ) ) {
				D = 0;
			}
			var E = Math.max( 0, B.offsetWidth - I - D );
			var A = Math.max( 0, B.offsetHeight - G - F );
			H.setStyle( C, "width", E + "px" );
			H.setStyle( C, "height", A + "px" );
		}
	},
	b4MouseDown: function( B ) {
		this.setStartPosition();
		var A = YAHOO.util.Event.getPageX( B );
		var C = YAHOO.util.Event.getPageY( B );
		this.autoOffset( A, C );
	},
	b4StartDrag: function( A, B ) {
		this.showFrame( A, B );
	},
	b4EndDrag: function( A ) {
		YAHOO.util.Dom.setStyle( this.getDragEl(), "visibility", "hidden" );
	},
	endDrag: function( D ) {
		var C = YAHOO.util.Dom; var B = this.getEl();
		var A = this.getDragEl();
		C.setStyle( A, "visibility", "" );
		C.setStyle( B, "visibility", "hidden" );
		YAHOO.util.DDM.moveToEl( B, A );
		C.setStyle( A, "visibility", "hidden" );
		C.setStyle( B, "visibility", "" );
	},
	toString: function() {
		return ( "DDProxy " + this.id );
	} } );
YAHOO.util.DDTarget = function( C, A, B ) {
	if ( C ) {
		this.initTarget( C, A, B );
	}
};
YAHOO.extend( YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
	toString: function() {
		return ( "DDTarget " + this.id );
	} } );
YAHOO.register( "dragdrop", YAHOO.util.DragDropMgr, { version: "2.7.0", build: "1796" } );
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/ ( function() {
	var B = YAHOO.util.Dom.getXY,
		A = YAHOO.util.Event,
		D = Array.prototype.slice;

	function C( G, E, F, H ) {
		C.ANIM_AVAIL = ( !YAHOO.lang.isUndefined( YAHOO.util.Anim ) );
		if ( G ) {
			this.init( G, E, true );
			this.initSlider( H );
			this.initThumb( F );
		}
	}
	YAHOO.lang.augmentObject( C, {
		getHorizSlider: function( F, G, I, H, E ) {
			return new C( F, F, new YAHOO.widget.SliderThumb( G, F, I, H, 0, 0, E ), "horiz" );
		},
		getVertSlider: function( G, H, E, I, F ) {
			return new C( G, G, new YAHOO.widget.SliderThumb( H, G, 0, 0, E, I, F ), "vert" );
		},
		getSliderRegion: function( G, H, J, I, E, K, F ) {
			return new C( G, G, new YAHOO.widget.SliderThumb( H, G, J, I, E, K, F ), "region" );
		},
		SOURCE_UI_EVENT: 1, SOURCE_SET_VALUE: 2, SOURCE_KEY_EVENT: 3, ANIM_AVAIL: false }, true );
	YAHOO.extend( C, YAHOO.util.DragDrop, {
		_mouseDown: false, dragOnly: true, initSlider: function( E ) {
			this.type = E; this.createEvent( "change", this );
			this.createEvent( "slideStart", this );
			this.createEvent( "slideEnd", this );
			this.isTarget = false;
			this.animate = C.ANIM_AVAIL;
			this.backgroundEnabled = true;
			this.tickPause = 40;
			this.enableKeys = true;
			this.keyIncrement = 20;
			this.moveComplete = true;
			this.animationDuration = 0.2;
			this.SOURCE_UI_EVENT = 1;
			this.SOURCE_SET_VALUE = 2;
			this.valueChangeSource = 0;
			this._silent = false;
			this.lastOffset = [ 0, 0 ];
		},
		initThumb: function( F ) {
			var E = this; this.thumb = F; F.cacheBetweenDrags = true; if ( F._isHoriz && F.xTicks && F.xTicks.length ) {
				this.tickPause = Math.round( 360 / F.xTicks.length );
			} else {
				if ( F.yTicks && F.yTicks.length ) {
					this.tickPause = Math.round( 360 / F.yTicks.length );
				}
			}
			F.onAvailable = function() {
				return E.setStartSliderState();
			};
			F.onMouseDown = function() {
				E._mouseDown = true;
				return E.focus();
			};
			F.startDrag = function() {
				E._slideStart();
			};
			F.onDrag = function() {
				E.fireEvents( true );
			};
			F.onMouseUp = function() {
				E.thumbMouseUp();
			};
		},
		onAvailable: function() {
			this._bindKeyEvents();
		},
		_bindKeyEvents: function() {
			A.on( this.id, "keydown", this.handleKeyDown, this, true );
			A.on( this.id, "keypress", this.handleKeyPress, this, true );
		},
		handleKeyPress: function( F ) {
			if ( this.enableKeys ) {
				var E = A.getCharCode( F );
				switch ( E ) {
					case 37:
					case 38:
					case 39:
					case 40:
					case 36:
					case 35:
						A.preventDefault( F );
						break;default:
				}
			}
		},
		handleKeyDown: function( J ) {
			if ( this.enableKeys ) {
				var G = A.getCharCode( J ),
					F = this.thumb,
					H = this.getXValue(),
					E = this.getYValue(),
					I = true;
				switch ( G ) {
					case 37:
						H -= this.keyIncrement;
						break;case 38:
						E -= this.keyIncrement;
						break;case 39:
						H += this.keyIncrement;
						break;case 40:
						E += this.keyIncrement;
						break;case 36:
						H = F.leftConstraint;
						E = F.topConstraint;
						break;case 35:
						H = F.rightConstraint;
						E = F.bottomConstraint;
						break;default:
						I = false;
				}
				if ( I ) {
					if ( F._isRegion ) {
						this._setRegionValue( C.SOURCE_KEY_EVENT, H, E, true );
					} else {
						this._setValue( C.SOURCE_KEY_EVENT, ( F._isHoriz ? H : E ), true );
					}
					A.stopEvent( J );
				}
			}
		},
		setStartSliderState: function() {
			this.setThumbCenterPoint();
			this.baselinePos = B( this.getEl() );
			this.thumb.startOffset = this.thumb.getOffsetFromParent( this.baselinePos );
			if ( this.thumb._isRegion ) {
				if ( this.deferredSetRegionValue ) {
					this._setRegionValue.apply( this, this.deferredSetRegionValue );
					this.deferredSetRegionValue = null;
				} else {
					this.setRegionValue( 0, 0, true, true, true );
				}
			} else {
				if ( this.deferredSetValue ) {
					this._setValue.apply( this, this.deferredSetValue );
					this.deferredSetValue = null;
				} else {
					this.setValue( 0, true, true, true );
				}
			}
		},
		setThumbCenterPoint: function() {
			var E = this.thumb.getEl();
			if ( E ) {
				this.thumbCenterPoint = { x: parseInt( E.offsetWidth / 2, 10 ), y: parseInt( E.offsetHeight / 2, 10 ) };
			}
		},
		lock: function() {
			this.thumb.lock();
			this.locked = true;
		},
		unlock: function() {
			this.thumb.unlock();
			this.locked = false;
		},
		thumbMouseUp: function() {
			this._mouseDown = false; if ( !this.isLocked() && !this.moveComplete ) {
				this.endMove();
			}
		},
		onMouseUp: function() {
			this._mouseDown = false; if ( this.backgroundEnabled && !this.isLocked() && !this.moveComplete ) {
				this.endMove();
			}
		},
		getThumb: function() {
			return this.thumb;
		},
		focus: function() {
			this.valueChangeSource = C.SOURCE_UI_EVENT; var E = this.getEl();
			if ( E.focus ) {
				try {
					E.focus();
				} catch ( F ) {}
			}
			this.verifyOffset();
			return !this.isLocked();
		},
		onChange: function( E, F ) {},
		onSlideStart: function() {},
		onSlideEnd: function() {},
		getValue: function() {
			return this.thumb.getValue();
		},
		getXValue: function() {
			return this.thumb.getXValue();
		},
		getYValue: function() {
			return this.thumb.getYValue();
		},
		setValue: function() {
			var E = D.call( arguments );
			E.unshift( C.SOURCE_SET_VALUE );
			return this._setValue.apply( this, E );
		},
		_setValue: function( I, L, G, H, E ) {
			var F = this.thumb,
				K, J; if ( !F.available ) {
				this.deferredSetValue = arguments;
				return false;
			}
			if ( this.isLocked() && !H ) {
				return false;
			}
			if ( isNaN( L ) ) {
				return false;
			}
			if ( F._isRegion ) {
				return false;
			}
			this._silent = E;
			this.valueChangeSource = I || C.SOURCE_SET_VALUE;
			F.lastOffset = [ L, L ];
			this.verifyOffset( true );
			this._slideStart();
			if ( F._isHoriz ) {
				K = F.initPageX + L + this.thumbCenterPoint.x;
				this.moveThumb( K, F.initPageY, G );
			} else {
				J = F.initPageY + L + this.thumbCenterPoint.y;
				this.moveThumb( F.initPageX, J, G );
			}
			return true;
		},
		setRegionValue: function() {
			var E = D.call( arguments );
			E.unshift( C.SOURCE_SET_VALUE );
			return this._setRegionValue.apply( this, E );
		},
		_setRegionValue: function( F, J, H, I, G, K ) {
			var L = this.thumb,
				E, M; if ( !L.available ) {
				this.deferredSetRegionValue = arguments;
				return false;
			}
			if ( this.isLocked() && !G ) {
				return false;
			}
			if ( isNaN( J ) ) {
				return false;
			}
			if ( !L._isRegion ) {
				return false;
			}
			this._silent = K;
			this.valueChangeSource = F || C.SOURCE_SET_VALUE;
			L.lastOffset = [ J, H ];
			this.verifyOffset( true );
			this._slideStart();
			E = L.initPageX + J + this.thumbCenterPoint.x;
			M = L.initPageY + H + this.thumbCenterPoint.y;
			this.moveThumb( E, M, I );
			return true;
		},
		verifyOffset: function( F ) {
			var G = B( this.getEl() ),
				E = this.thumb;
			if ( !this.thumbCenterPoint || !this.thumbCenterPoint.x ) {
				this.setThumbCenterPoint();
			}
			if ( G ) {
				if ( G[ 0 ] != this.baselinePos[ 0 ] || G[ 1 ] != this.baselinePos[ 1 ] ) {
					this.setInitPosition();
					this.baselinePos = G;
					E.initPageX = this.initPageX + E.startOffset[ 0 ];
					E.initPageY = this.initPageY + E.startOffset[ 1 ];
					E.deltaSetXY = null;
					this.resetThumbConstraints();
					return false;
				}
			}
			return true;
		},
		moveThumb: function( K, J, I, G ) {
			var L = this.thumb,
				M = this,
				F, E, H; if ( !L.available ) {
				return;
			}
			L.setDelta( this.thumbCenterPoint.x, this.thumbCenterPoint.y );
			E = L.getTargetCoord( K, J );
			F = [ Math.round( E.x ), Math.round( E.y ) ];
			if ( this.animate && L._graduated && !I ) {
				this.lock();
				this.curCoord = B( this.thumb.getEl() );
				this.curCoord = [ Math.round( this.curCoord[ 0 ] ), Math.round( this.curCoord[ 1 ] ) ];
				setTimeout( function() {
					M.moveOneTick( F );
				}, this.tickPause );
			} else {
				if ( this.animate && C.ANIM_AVAIL && !I ) {
					this.lock();
					H = new YAHOO.util.Motion( L.id, {
						points: { to: F } }, this.animationDuration, YAHOO.util.Easing.easeOut );
					H.onComplete.subscribe( function() {
						M.unlock();
						if ( !M._mouseDown ) {
							M.endMove();
						}
					});
					H.animate();
				} else {
					L.setDragElPos( K, J );
					if ( !G && !this._mouseDown ) {
						this.endMove();
					}
				}
			}
		},
		_slideStart: function() {
			if ( !this._sliding ) {
				if ( !this._silent ) {
					this.onSlideStart();
					this.fireEvent( "slideStart" );
				}
				this._sliding = true;
			}
		},
		_slideEnd: function() {
			if ( this._sliding && this.moveComplete ) {
				var E = this._silent;
				this._sliding = false;
				this._silent = false;
				this.moveComplete = false;
				if ( !E ) {
					this.onSlideEnd();
					this.fireEvent( "slideEnd" );
				}
			}
		},
		moveOneTick: function( F ) {
			var H = this.thumb,
				G = this,
				I = null,
				E, J; if ( H._isRegion ) {
				I = this._getNextX( this.curCoord, F );
				E = ( I !== null ) ? I[ 0 ] : this.curCoord[ 0 ];
				I = this._getNextY( this.curCoord, F );
				J = ( I !== null ) ? I[ 1 ] : this.curCoord[ 1 ];
				I = E !== this.curCoord[ 0 ] || J !== this.curCoord[ 1 ] ? [ E, J ] : null;
			} else {
				if ( H._isHoriz ) {
					I = this._getNextX( this.curCoord, F );
				} else {
					I = this._getNextY( this.curCoord, F );
				}
			}
			if ( I ) {
				this.curCoord = I;
				this.thumb.alignElWithMouse( H.getEl(), I[ 0 ] + this.thumbCenterPoint.x, I[ 1 ] + this.thumbCenterPoint.y );
				if ( !( I[ 0 ] == F[ 0 ] && I[ 1 ] == F[ 1 ] ) ) {
					setTimeout( function() {
						G.moveOneTick( F );
					}, this.tickPause );
				} else {
					this.unlock();
					if ( !this._mouseDown ) {
						this.endMove();
					}
				}
			} else {
				this.unlock();
				if ( !this._mouseDown ) {
					this.endMove();
				}
			}
		},
		_getNextX: function( E, F ) {
			var H = this.thumb,
				J,
				G = [],
				I = null;
			if ( E[ 0 ] > F[ 0 ] ) {
				J = H.tickSize - this.thumbCenterPoint.x;
				G = H.getTargetCoord( E[ 0 ] - J, E[ 1 ] );
				I = [ G.x, G.y ];
			} else {
				if ( E[ 0 ] < F[ 0 ] ) {
					J = H.tickSize + this.thumbCenterPoint.x;
					G = H.getTargetCoord( E[ 0 ] + J, E[ 1 ] );
					I = [ G.x, G.y ];
				} else {}
			}
			return I;
		},
		_getNextY: function( E, F ) {
			var H = this.thumb,
				J,
				G = [],
				I = null;
			if ( E[ 1 ] > F[ 1 ] ) {
				J = H.tickSize - this.thumbCenterPoint.y;
				G = H.getTargetCoord( E[ 0 ], E[ 1 ] - J );
				I = [ G.x, G.y ];
			} else {
				if ( E[ 1 ] < F[ 1 ] ) {
					J = H.tickSize + this.thumbCenterPoint.y;
					G = H.getTargetCoord( E[ 0 ], E[ 1 ] + J );
					I = [ G.x, G.y ];
				} else {}
			}
			return I;
		},
		b4MouseDown: function( E ) {
			if ( !this.backgroundEnabled ) {
				return false;
			}
			this.thumb.autoOffset();
			this.resetThumbConstraints();
		},
		onMouseDown: function( F ) {
			if ( !this.backgroundEnabled || this.isLocked() ) {
				return false;
			}
			this._mouseDown = true;
			var E = A.getPageX( F ),
				G = A.getPageY( F );
			this.focus();
			this._slideStart();
			this.moveThumb( E, G );
		},
		onDrag: function( F ) {
			if ( this.backgroundEnabled && !this.isLocked() ) {
				var E = A.getPageX( F ),
					G = A.getPageY( F );
				this.moveThumb( E, G, true, true );
				this.fireEvents();
			}
		},
		endMove: function() {
			this.unlock();
			this.fireEvents();
			this.moveComplete = true;
			this._slideEnd();
		},
		resetThumbConstraints: function() {
			var E = this.thumb; E.setXConstraint( E.leftConstraint, E.rightConstraint, E.xTickSize );
			E.setYConstraint( E.topConstraint, E.bottomConstraint, E.xTickSize );
		},
		fireEvents: function( G ) {
			var F = this.thumb,
				I, H, E; if ( !G ) {
				F.cachePosition();
			}
			if ( !this.isLocked() ) {
				if ( F._isRegion ) {
					I = F.getXValue();
					H = F.getYValue();
					if ( I != this.previousX || H != this.previousY ) {
						if ( !this._silent ) {
							this.onChange( I, H );
							this.fireEvent( "change", { x: I, y: H } );
						}
					}
					this.previousX = I;
					this.previousY = H;
				} else {
					E = F.getValue();
					if ( E != this.previousVal ) {
						if ( !this._silent ) {
							this.onChange( E );
							this.fireEvent( "change", E );
						}
					}
					this.previousVal = E;
				}
			}
		},
		toString: function() {
			return ( "Slider (" + this.type + ") " + this.id );
		} } );
	YAHOO.lang.augmentProto( C, YAHOO.util.EventProvider );
	YAHOO.widget.Slider = C;
})();
YAHOO.widget.SliderThumb = function( G, B, E, D, A, F, C ) {
	if ( G ) {
		YAHOO.widget.SliderThumb.superclass.constructor.call( this, G, B );
		this.parentElId = B;
	}
	this.isTarget = false;
	this.tickSize = C;
	this.maintainOffset = true;
	this.initSlider( E, D, A, F, C );
	this.scroll = false;
};
YAHOO.extend( YAHOO.widget.SliderThumb, YAHOO.util.DD, {
	startOffset: null, dragOnly: true, _isHoriz: false, _prevVal: 0, _graduated: false, getOffsetFromParent0: function( C ) {
		var A = YAHOO.util.Dom.getXY( this.getEl() ),
			B = C || YAHOO.util.Dom.getXY( this.parentElId );
		return [ ( A[ 0 ] - B[ 0 ] ), ( A[ 1 ] - B[ 1 ] ) ];
	},
	getOffsetFromParent: function( H ) {
		var A = this.getEl(),
			E, I, F, B, K, D, C, J, G;
		if ( !this.deltaOffset ) {
			I = YAHOO.util.Dom.getXY( A );
			F = H || YAHOO.util.Dom.getXY( this.parentElId );
			E = [ ( I[ 0 ] - F[ 0 ] ), ( I[ 1 ] - F[ 1 ] ) ];
			B = parseInt( YAHOO.util.Dom.getStyle( A, "left" ), 10 );
			K = parseInt( YAHOO.util.Dom.getStyle( A, "top" ), 10 );
			D = B - E[ 0 ];
			C = K - E[ 1 ];
			if ( isNaN( D ) || isNaN( C ) ) {} else {
				this.deltaOffset = [ D, C ];
			}
		} else {
			J = parseInt( YAHOO.util.Dom.getStyle( A, "left" ), 10 );
			G = parseInt( YAHOO.util.Dom.getStyle( A, "top" ), 10 );
			E = [ J + this.deltaOffset[ 0 ], G + this.deltaOffset[ 1 ] ];
		}
		return E;
	},
	initSlider: function( D, C, A, E, B ) {
		this.initLeft = D; this.initRight = C; this.initUp = A; this.initDown = E; this.setXConstraint( D, C, B );
		this.setYConstraint( A, E, B );
		if ( B && B > 1 ) {
			this._graduated = true;
		}
		this._isHoriz = ( D || C );
		this._isVert = ( A || E );
		this._isRegion = ( this._isHoriz && this._isVert );
	},
	clearTicks: function() {
		YAHOO.widget.SliderThumb.superclass.clearTicks.call( this );
		this.tickSize = 0;
		this._graduated = false;
	},
	getValue: function() {
		return ( this._isHoriz ) ? this.getXValue() : this.getYValue();
	},
	getXValue: function() {
		if ( !this.available ) {
			return 0;
		}
		var A = this.getOffsetFromParent();
		if ( YAHOO.lang.isNumber( A[ 0 ] ) ) {
			this.lastOffset = A;
			return ( A[ 0 ] - this.startOffset[ 0 ] );
		} else {
			return ( this.lastOffset[ 0 ] - this.startOffset[ 0 ] );
		}
	},
	getYValue: function() {
		if ( !this.available ) {
			return 0;
		}
		var A = this.getOffsetFromParent();
		if ( YAHOO.lang.isNumber( A[ 1 ] ) ) {
			this.lastOffset = A;
			return ( A[ 1 ] - this.startOffset[ 1 ] );
		} else {
			return ( this.lastOffset[ 1 ] - this.startOffset[ 1 ] );
		}
	},
	toString: function() {
		return "SliderThumb " + this.id;
	},
	onChange: function( A, B ) {} } );
(function() {
	var A = YAHOO.util.Event,
		B = YAHOO.widget;

	function C( I, F, H, D ) {
		var G = this,
			J = { min: false, max: false },
			E, K; this.minSlider = I; this.maxSlider = F; this.activeSlider = I; this.isHoriz = I.thumb._isHoriz; E = this.minSlider.thumb.onMouseDown; K = this.maxSlider.thumb.onMouseDown; this.minSlider.thumb.onMouseDown = function() {
			G.activeSlider = G.minSlider;
			E.apply( this, arguments );
		};
		this.maxSlider.thumb.onMouseDown = function() {
			G.activeSlider = G.maxSlider;
			K.apply( this, arguments );
		};
		this.minSlider.thumb.onAvailable = function() {
			I.setStartSliderState();
			J.min = true;
			if ( J.max ) {
				G.fireEvent( "ready", G );
			}
		};
		this.maxSlider.thumb.onAvailable = function() {
			F.setStartSliderState();
			J.max = true;
			if ( J.min ) {
				G.fireEvent( "ready", G );
			}
		};
		I.onMouseDown = F.onMouseDown = function( L ) {
			return this.backgroundEnabled && G._handleMouseDown( L );
		};
		I.onDrag = F.onDrag = function( L ) {
			G._handleDrag( L );
		};
		I.onMouseUp = F.onMouseUp = function( L ) {
			G._handleMouseUp( L );
		};
		I._bindKeyEvents = function() {
			G._bindKeyEvents( this );
		};
		F._bindKeyEvents = function() {};
		I.subscribe( "change", this._handleMinChange, I, this );
		I.subscribe( "slideStart", this._handleSlideStart, I, this );
		I.subscribe( "slideEnd", this._handleSlideEnd, I, this );
		F.subscribe( "change", this._handleMaxChange, F, this );
		F.subscribe( "slideStart", this._handleSlideStart, F, this );
		F.subscribe( "slideEnd", this._handleSlideEnd, F, this );
		this.createEvent( "ready", this );
		this.createEvent( "change", this );
		this.createEvent( "slideStart", this );
		this.createEvent( "slideEnd", this );
		D = YAHOO.lang.isArray( D ) ? D : [ 0, H ];
		D[ 0 ] = Math.min( Math.max( parseInt( D[ 0 ], 10 ) | 0, 0 ), H );
		D[ 1 ] = Math.max( Math.min( parseInt( D[ 1 ], 10 ) | 0, H ), 0 );
		if ( D[ 0 ] > D[ 1 ] ) {
			D.splice( 0, 2, D[ 1 ], D[ 0 ] );
		}
		this.minVal = D[ 0 ];
		this.maxVal = D[ 1 ];
		this.minSlider.setValue( this.minVal, true, true, true );
		this.maxSlider.setValue( this.maxVal, true, true, true );
	}
	C.prototype = {
		minVal: -1, maxVal: -1, minRange: 0, _handleSlideStart: function( E, D ) {
			this.fireEvent( "slideStart", D );
		},
		_handleSlideEnd: function( E, D ) {
			this.fireEvent( "slideEnd", D );
		},
		_handleDrag: function( D ) {
			B.Slider.prototype.onDrag.call( this.activeSlider, D );
		},
		_handleMinChange: function() {
			this.activeSlider = this.minSlider; this.updateValue();
		},
		_handleMaxChange: function() {
			this.activeSlider = this.maxSlider; this.updateValue();
		},
		_bindKeyEvents: function( D ) {
			A.on( D.id, "keydown", this._handleKeyDown, this, true );
			A.on( D.id, "keypress", this._handleKeyPress, this, true );
		},
		_handleKeyDown: function( D ) {
			this.activeSlider.handleKeyDown.apply( this.activeSlider, arguments );
		},
		_handleKeyPress: function( D ) {
			this.activeSlider.handleKeyPress.apply( this.activeSlider, arguments );
		},
		setValues: function( H, K, I, E, J ) {
			var F = this.minSlider,
				M = this.maxSlider,
				D = F.thumb,
				L = M.thumb,
				N = this,
				G = { min: false, max: false }; if ( D._isHoriz ) {
				D.setXConstraint( D.leftConstraint, L.rightConstraint, D.tickSize );
				L.setXConstraint( D.leftConstraint, L.rightConstraint, L.tickSize );
			} else {
				D.setYConstraint( D.topConstraint, L.bottomConstraint, D.tickSize );
				L.setYConstraint( D.topConstraint, L.bottomConstraint, L.tickSize );
			}
			this._oneTimeCallback( F, "slideEnd", function() {
				G.min = true;
				if ( G.max ) {
					N.updateValue( J );
					setTimeout( function() {
						N._cleanEvent( F, "slideEnd" );
						N._cleanEvent( M, "slideEnd" );
					}, 0 );
				}
			});
			this._oneTimeCallback( M, "slideEnd", function() {
				G.max = true;
				if ( G.min ) {
					N.updateValue( J );
					setTimeout( function() {
						N._cleanEvent( F, "slideEnd" );
						N._cleanEvent( M, "slideEnd" );
					}, 0 );
				}
			});
			F.setValue( H, I, E, false );
			M.setValue( K, I, E, false );
		},
		setMinValue: function( F, H, I, E ) {
			var G = this.minSlider,
				D = this; this.activeSlider = G; D = this; this._oneTimeCallback( G, "slideEnd", function() {
				D.updateValue( E );
				setTimeout( function() {
					D._cleanEvent( G, "slideEnd" );
				}, 0 );
			});
			G.setValue( F, H, I );
		},
		setMaxValue: function( D, H, I, F ) {
			var G = this.maxSlider,
				E = this; this.activeSlider = G; this._oneTimeCallback( G, "slideEnd", function() {
				E.updateValue( F );
				setTimeout( function() {
					E._cleanEvent( G, "slideEnd" );
				}, 0 );
			});
			G.setValue( D, H, I );
		},
		updateValue: function( J ) {
			var E = this.minSlider.getValue(),
				K = this.maxSlider.getValue(),
				F = false,
				D, M, H, I, L, G;
			if ( E != this.minVal || K != this.maxVal ) {
				F = true;
				D = this.minSlider.thumb;
				M = this.maxSlider.thumb;
				H = this.isHoriz ? "x" : "y";
				G = this.minSlider.thumbCenterPoint[ H ] + this.maxSlider.thumbCenterPoint[ H ];
				I = Math.max( K - G - this.minRange, 0 );
				L = Math.min( -E - G - this.minRange, 0 );
				if ( this.isHoriz ) {
					I = Math.min( I, M.rightConstraint );
					D.setXConstraint( D.leftConstraint, I, D.tickSize );
					M.setXConstraint( L, M.rightConstraint, M.tickSize );
				} else {
					I = Math.min( I, M.bottomConstraint );
					D.setYConstraint( D.leftConstraint, I, D.tickSize );
					M.setYConstraint( L, M.bottomConstraint, M.tickSize );
				}
			}
			this.minVal = E;
			this.maxVal = K;
			if ( F && !J ) {
				this.fireEvent( "change", this );
			}
		},
		selectActiveSlider: function( H ) {
			var E = this.minSlider,
				D = this.maxSlider,
				J = E.isLocked() || !E.backgroundEnabled,
				G = D.isLocked() || !E.backgroundEnabled,
				F = YAHOO.util.Event,
				I;
			if ( J || G ) {
				this.activeSlider = J ? D : E;
			} else {
				if ( this.isHoriz ) {
					I = F.getPageX( H ) - E.thumb.initPageX - E.thumbCenterPoint.x;
				} else {
					I = F.getPageY( H ) - E.thumb.initPageY - E.thumbCenterPoint.y;
				}
				this.activeSlider = I * 2 > D.getValue() + E.getValue() ? D : E;
			}
		},
		_handleMouseDown: function( D ) {
			if ( !D._handled ) {
				D._handled = true;
				this.selectActiveSlider( D );
				return B.Slider.prototype.onMouseDown.call( this.activeSlider, D );
			} else {
				return false;
			}
		},
		_handleMouseUp: function( D ) {
			B.Slider.prototype.onMouseUp.apply( this.activeSlider, arguments );
		},
		_oneTimeCallback: function( F, D, E ) {
			F.subscribe( D, function() {
				F.unsubscribe( D, arguments.callee );
				E.apply( {}, [].slice.apply( arguments ) );
			});
		},
		_cleanEvent: function( K, E ) {
			var J, I, D, G, H, F; if ( K.__yui_events && K.events[ E ] ) {
				for ( I = K.__yui_events.length; I >= 0; --I ) {
					if ( K.__yui_events[ I ].type === E ) {
						J = K.__yui_events[ I ];
						break;
					}
				}
				if ( J ) {
					H = J.subscribers;
					F = [];
					G = 0;
					for ( I = 0, D = H.length; I < D; ++I ) {
						if ( H[ I ] ) {
							F[ G++ ] = H[ I ];
						}
					}
					J.subscribers = F;
				}
			}
		} }; YAHOO.lang.augmentProto( C, YAHOO.util.EventProvider );
	B.Slider.getHorizDualSlider = function( H, J, K, G, F, D ) {
		var I = new B.SliderThumb( J, H, 0, G, 0, 0, F ),
			E = new B.SliderThumb( K, H, 0, G, 0, 0, F );
		return new C( new B.Slider( H, H, I, "horiz" ), new B.Slider( H, H, E, "horiz" ), G, D );
	};
	B.Slider.getVertDualSlider = function( H, J, K, G, F, D ) {
		var I = new B.SliderThumb( J, H, 0, 0, 0, G, F ),
			E = new B.SliderThumb( K, H, 0, 0, 0, G, F );
		return new B.DualSlider( new B.Slider( H, H, I, "vert" ), new B.Slider( H, H, E, "vert" ), G, D );
	};
	YAHOO.widget.DualSlider = C;
})();
YAHOO.register( "slider", YAHOO.widget.Slider, { version: "2.7.0", build: "1796" } );
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
YAHOO.util.Attribute = function( B, A ) {
	if ( A ) {
		this.owner = A;
		this.configure( B, true );
	}
};
YAHOO.util.Attribute.prototype = {
	name: undefined, value: null, owner: null, readOnly: false, writeOnce: false, _initialConfig: null, _written: false, method: null, setter: null, getter: null, validator: null, getValue: function() {
		var A = this.value; if ( this.getter ) {
			A = this.getter.call( this.owner, this.name );
		}
		return A;
	},
	setValue: function( F, B ) {
		var E,
			A = this.owner,
			C = this.name; var D = { type: C, prevValue: this.getValue(), newValue: F }; if ( this.readOnly || ( this.writeOnce && this._written ) ) {
			return false;
		}
		if ( this.validator && !this.validator.call( A, F ) ) {
			return false;
		}
		if ( !B ) {
			E = A.fireBeforeChangeEvent( D );
			if ( E === false ) {
				return false;
			}
		}
		if ( this.setter ) {
			F = this.setter.call( A, F, this.name );
			if ( F === undefined ) {}
		}
		if ( this.method ) {
			this.method.call( A, F, this.name );
		}
		this.value = F;
		this._written = true;
		D.type = C;
		if ( !B ) {
			this.owner.fireChangeEvent( D );
		}
		return true;
	},
	configure: function( B, C ) {
		B = B || {};
		if ( C ) {
			this._written = false;
		}
		this._initialConfig = this._initialConfig || {};
		for ( var A in B ) {
			if ( B.hasOwnProperty( A ) ) {
				this[ A ] = B[ A ];
				if ( C ) {
					this._initialConfig[ A ] = B[ A ];
				}
			}
		}
	},
	resetValue: function() {
		return this.setValue( this._initialConfig.value );
	},
	resetConfig: function() {
		this.configure( this._initialConfig, true );
	},
	refresh: function( A ) {
		this.setValue( this.value, A );
	} };
(function() {
	var A = YAHOO.util.Lang;
	YAHOO.util.AttributeProvider = function() {};
	YAHOO.util.AttributeProvider.prototype = {
		_configs: null, get: function( C ) {
			this._configs = this._configs || {};
			var B = this._configs[ C ];
			if ( !B || !this._configs.hasOwnProperty( C ) ) {
				return null;
			}
			return B.getValue();
		},
		set: function( D, E, B ) {
			this._configs = this._configs || {};
			var C = this._configs[ D ];
			if ( !C ) {
				return false;
			}
			return C.setValue( E, B );
		},
		getAttributeKeys: function() {
			this._configs = this._configs; var C = [],
				B;
			for ( B in this._configs ) {
				if ( A.hasOwnProperty( this._configs, B ) && !A.isUndefined( this._configs[ B ] ) ) {
					C[ C.length ] = B;
				}
			}
			return C;
		},
		setAttributes: function( D, B ) {
			for ( var C in D ) {
				if ( A.hasOwnProperty( D, C ) ) {
					this.set( C, D[ C ], B );
				}
			}
		},
		resetValue: function( C, B ) {
			this._configs = this._configs || {};
			if ( this._configs[ C ] ) {
				this.set( C, this._configs[ C ]._initialConfig.value, B );
				return true;
			}
			return false;
		},
		refresh: function( E, C ) {
			this._configs = this._configs || {};
			var F = this._configs;
			E = ( ( A.isString( E ) ) ? [ E ] : E ) || this.getAttributeKeys();
			for ( var D = 0, B = E.length; D < B; ++D ) {
				if ( F.hasOwnProperty( E[ D ] ) ) {
					this._configs[ E[ D ] ].refresh( C );
				}
			}
		},
		register: function( B, C ) {
			this.setAttributeConfig( B, C );
		},
		getAttributeConfig: function( C ) {
			this._configs = this._configs || {};
			var B = this._configs[ C ] || {};
			var D = {};
			for ( C in B ) {
				if ( A.hasOwnProperty( B, C ) ) {
					D[ C ] = B[ C ];
				}
			}
			return D;
		},
		setAttributeConfig: function( B, C, D ) {
			this._configs = this._configs || {};
			C = C || {};
			if ( !this._configs[ B ] ) {
				C.name = B;
				this._configs[ B ] = this.createAttribute( C );
			} else {
				this._configs[ B ].configure( C, D );
			}
		},
		configureAttribute: function( B, C, D ) {
			this.setAttributeConfig( B, C, D );
		},
		resetAttributeConfig: function( B ) {
			this._configs = this._configs || {};
			this._configs[ B ].resetConfig();
		},
		subscribe: function( B, C ) {
			this._events = this._events || {};
			if ( !( B in this._events ) ) {
				this._events[ B ] = this.createEvent( B );
			}
			YAHOO.util.EventProvider.prototype.subscribe.apply( this, arguments );
		},
		on: function() {
			this.subscribe.apply( this, arguments );
		},
		addListener: function() {
			this.subscribe.apply( this, arguments );
		},
		fireBeforeChangeEvent: function( C ) {
			var B = "before"; B += C.type.charAt( 0 ).toUpperCase() + C.type.substr( 1 ) + "Change";
			C.type = B;
			return this.fireEvent( C.type, C );
		},
		fireChangeEvent: function( B ) {
			B.type += "Change"; return this.fireEvent( B.type, B );
		},
		createAttribute: function( B ) {
			return new YAHOO.util.Attribute( B, this );
		} }; YAHOO.augment( YAHOO.util.AttributeProvider, YAHOO.util.EventProvider );
})();
(function() {
	var B = YAHOO.util.Dom,
		C = YAHOO.util.AttributeProvider;
	var A = function( D, E ) {
			this.init.apply( this, arguments );
		};
	A.DOM_EVENTS = { "click": true, "dblclick": true, "keydown": true, "keypress": true, "keyup": true, "mousedown": true, "mousemove": true, "mouseout": true, "mouseover": true, "mouseup": true, "focus": true, "blur": true, "submit": true, "change": true }; A.prototype = {
		DOM_EVENTS: null, DEFAULT_HTML_SETTER: function( F, D ) {
			var E = this.get( "element" );
			if ( E ) {
				E[ D ] = F;
			}
		},
		DEFAULT_HTML_GETTER: function( D ) {
			var E = this.get( "element" ),
				F;
			if ( E ) {
				F = E[ D ];
			}
			return F;
		},
		appendChild: function( D ) {
			D = D.get ? D.get( "element" ) : D;
			return this.get( "element" ).appendChild( D );
		},
		getElementsByTagName: function( D ) {
			return this.get( "element" ).getElementsByTagName( D );
		},
		hasChildNodes: function() {
			return this.get( "element" ).hasChildNodes();
		},
		insertBefore: function( D, E ) {
			D = D.get ? D.get( "element" ) : D;
			E = ( E && E.get ) ? E.get( "element" ) : E;
			return this.get( "element" ).insertBefore( D, E );
		},
		removeChild: function( D ) {
			D = D.get ? D.get( "element" ) : D;
			return this.get( "element" ).removeChild( D );
		},
		replaceChild: function( D, E ) {
			D = D.get ? D.get( "element" ) : D;
			E = E.get ? E.get( "element" ) : E;
			return this.get( "element" ).replaceChild( D, E );
		},
		initAttributes: function( D ) {},
		addListener: function( H, G, I, F ) {
			var E = this.get( "element" ) || this.get( "id" );
			F = F || this;
			var D = this;
			if ( !this._events[ H ] ) {
				if ( E && this.DOM_EVENTS[ H ] ) {
					YAHOO.util.Event.addListener( E, H, function( J ) {
						if ( J.srcElement && !J.target ) {
							J.target = J.srcElement;
						}
						D.fireEvent( H, J );
					}, I, F );
				}
				this.createEvent( H, this );
			}
			return YAHOO.util.EventProvider.prototype.subscribe.apply( this, arguments );
		},
		on: function() {
			return this.addListener.apply( this, arguments );
		},
		subscribe: function() {
			return this.addListener.apply( this, arguments );
		},
		removeListener: function( E, D ) {
			return this.unsubscribe.apply( this, arguments );
		},
		addClass: function( D ) {
			B.addClass( this.get( "element" ), D );
		},
		getElementsByClassName: function( E, D ) {
			return B.getElementsByClassName( E, D, this.get( "element" ) );
		},
		hasClass: function( D ) {
			return B.hasClass( this.get( "element" ), D );
		},
		removeClass: function( D ) {
			return B.removeClass( this.get( "element" ), D );
		},
		replaceClass: function( E, D ) {
			return B.replaceClass( this.get( "element" ), E, D );
		},
		setStyle: function( E, D ) {
			return B.setStyle( this.get( "element" ), E, D );
		},
		getStyle: function( D ) {
			return B.getStyle( this.get( "element" ), D );
		},
		fireQueue: function() {
			var E = this._queue; for ( var F = 0, D = E.length; F < D; ++F ) {
				this[ E[ F ][ 0 ] ].apply( this, E[ F ][ 1 ] );
			}
		},
		appendTo: function( E, F ) {
			E = ( E.get ) ? E.get( "element" ) : B.get( E );
			this.fireEvent( "beforeAppendTo", { type: "beforeAppendTo", target: E } );
			F = ( F && F.get ) ? F.get( "element" ) : B.get( F );
			var D = this.get( "element" );
			if ( !D ) {
				return false;
			}
			if ( !E ) {
				return false;
			}
			if ( D.parent != E ) {
				if ( F ) {
					E.insertBefore( D, F );
				} else {
					E.appendChild( D );
				}
			}
			this.fireEvent( "appendTo", { type: "appendTo", target: E } );
			return D;
		},
		get: function( D ) {
			var F = this._configs || {},
				E = F.element;
			if ( E && !F[ D ] && !YAHOO.lang.isUndefined( E.value[ D ] ) ) {
				this._setHTMLAttrConfig( D );
			}
			return C.prototype.get.call( this, D );
		},
		setAttributes: function( J, G ) {
			var E = {},
				H = this._configOrder;
			for ( var I = 0, D = H.length; I < D; ++I ) {
				if ( J[ H[ I ] ] !== undefined ) {
					E[ H[ I ] ] = true;
					this.set( H[ I ], J[ H[ I ] ], G );
				}
			}
			for ( var F in J ) {
				if ( J.hasOwnProperty( F ) && !E[ F ] ) {
					this.set( F, J[ F ], G );
				}
			}
		},
		set: function( E, G, D ) {
			var F = this.get( "element" );
			if ( !F ) {
				this._queue[ this._queue.length ] = [ "set", arguments ];
				if ( this._configs[ E ] ) {
					this._configs[ E ].value = G;
				}
				return;
			}
			if ( !this._configs[ E ] && !YAHOO.lang.isUndefined( F[ E ] ) ) {
				this._setHTMLAttrConfig( E );
			}
			return C.prototype.set.apply( this, arguments );
		},
		setAttributeConfig: function( D, E, F ) {
			this._configOrder.push( D );
			C.prototype.setAttributeConfig.apply( this, arguments );
		},
		createEvent: function( E, D ) {
			this._events[ E ] = true;
			return C.prototype.createEvent.apply( this, arguments );
		},
		init: function( E, D ) {
			this._initElement( E, D );
		},
		destroy: function() {
			var D = this.get( "element" );
			YAHOO.util.Event.purgeElement( D, true );
			this.unsubscribeAll();
			if ( D && D.parentNode ) {
				D.parentNode.removeChild( D );
			}
			this._queue = [];
			this._events = {};
			this._configs = {};
			this._configOrder = [];
		},
		_initElement: function( F, E ) {
			this._queue = this._queue || [];
			this._events = this._events || {};
			this._configs = this._configs || {};
			this._configOrder = [];
			E = E || {};
			E.element = E.element || F || null;
			var H = false;
			var D = A.DOM_EVENTS;
			this.DOM_EVENTS = this.DOM_EVENTS || {};
			for ( var G in D ) {
				if ( D.hasOwnProperty( G ) ) {
					this.DOM_EVENTS[ G ] = D[ G ];
				}
			}
			if ( typeof E.element === "string" ) {
				this._setHTMLAttrConfig( "id", { value: E.element } );
			}
			if ( B.get( E.element ) ) {
				H = true;
				this._initHTMLElement( E );
				this._initContent( E );
			}
			YAHOO.util.Event.onAvailable( E.element, function() {
				if ( !H ) {
					this._initHTMLElement( E );
				}
				this.fireEvent( "available", { type: "available", target: B.get( E.element ) } );
			}, this, true );
			YAHOO.util.Event.onContentReady( E.element, function() {
				if ( !H ) {
					this._initContent( E );
				}
				this.fireEvent( "contentReady", { type: "contentReady", target: B.get( E.element ) } );
			}, this, true );
		},
		_initHTMLElement: function( D ) {
			this.setAttributeConfig( "element", { value: B.get( D.element ), readOnly: true } );
		},
		_initContent: function( D ) {
			this.initAttributes( D );
			this.setAttributes( D, true );
			this.fireQueue();
		},
		_setHTMLAttrConfig: function( D, F ) {
			var E = this.get( "element" );
			F = F || {};
			F.name = D;
			F.setter = F.setter || this.DEFAULT_HTML_SETTER;
			F.getter = F.getter || this.DEFAULT_HTML_GETTER;
			F.value = F.value || E[ D ];
			this._configs[ D ] = new YAHOO.util.Attribute( F, this );
		} }; YAHOO.augment( A, C );
	YAHOO.util.Element = A;
})();
YAHOO.register( "element", YAHOO.util.Element, { version: "2.7.0", build: "1796" } );
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
YAHOO.util.Color = function() {
	var A = "0",
		B = YAHOO.lang.isArray,
		C = YAHOO.lang.isNumber;
	return {
		real2dec: function( D ) {
			return Math.min( 255, Math.round( D * 256 ) );
		},
		hsv2rgb: function( H, O, M ) {
			if ( B( H ) ) {
				return this.hsv2rgb.call( this, H[ 0 ], H[ 1 ], H[ 2 ] );
			}
			var D, I, L,
				G = Math.floor( ( H / 60 ) % 6 ),
				J = ( H / 60 ) - G,
				F = M * ( 1 - O ),
				E = M * ( 1 - J * O ),
				N = M * ( 1 - ( 1 - J ) * O ),
				K;
			switch ( G ) {
				case 0:
					D = M;
					I = N;
					L = F;
					break;case 1:
					D = E;
					I = M;
					L = F;
					break;case 2:
					D = F;
					I = M;
					L = N;
					break;case 3:
					D = F;
					I = E;
					L = M;
					break;case 4:
					D = N;
					I = F;
					L = M;
					break;case 5:
					D = M;
					I = F;
					L = E;
					break;
			}
			K = this.real2dec;
			return [ K( D ), K( I ), K( L ) ];
		},
		rgb2hsv: function( D, H, I ) {
			if ( B( D ) ) {
				return this.rgb2hsv.apply( this, D );
			}
			D /= 255;
			H /= 255;
			I /= 255;
			var G, L,
				E = Math.min( Math.min( D, H ), I ),
				J = Math.max( Math.max( D, H ), I ),
				K = J - E,
				F;
			switch ( J ) {
				case E:
					G = 0;
					break;case D:
					G = 60 * ( H - I ) / K;
					if ( H < I ) {
						G += 360;
					}
					break;case H:
					G = ( 60 * ( I - D ) / K ) + 120;
					break;case I:
					G = ( 60 * ( D - H ) / K ) + 240;
					break;
			}
			L = ( J === 0 ) ? 0 : 1 - ( E / J );
			F = [ Math.round( G ), L, J ];
			return F;
		},
		rgb2hex: function( F, E, D ) {
			if ( B( F ) ) {
				return this.rgb2hex.apply( this, F );
			}
			var G = this.dec2hex;
			return G( F ) + G( E ) + G( D );
		},
		dec2hex: function( D ) {
			D = parseInt( D, 10 ) | 0;
			D = ( D > 255 || D < 0 ) ? 0 : D;
			return ( A + D.toString( 16 ) ).slice( -2 ).toUpperCase();
		},
		hex2dec: function( D ) {
			return parseInt( D, 16 );
		},
		hex2rgb: function( D ) {
			var E = this.hex2dec; return [ E( D.slice( 0, 2 ) ), E( D.slice( 2, 4 ) ), E( D.slice( 4, 6 ) ) ];
		},
		websafe: function( F, E, D ) {
			if ( B( F ) ) {
				return this.websafe.apply( this, F );
			}
			var G = function( H ) {
					if ( C( H ) ) {
						H = Math.min( Math.max( 0, H ), 255 );
						var I, J;
						for ( I = 0; I < 256; I = I + 51 ) {
							J = I + 51;
							if ( H >= I && H <= J ) {
								return ( H - I > 25 ) ? J : I;
							}
						}
					}
					return H;
				};
			return [ G( F ), G( E ), G( D ) ];
		} };
}();
(function() {
	var J = 0,
		F = YAHOO.util,
		C = YAHOO.lang,
		D = YAHOO.widget.Slider,
		B = F.Color,
		E = F.Dom,
		I = F.Event,
		A = C.substitute,
		H = "yui-picker";

	function G( L, K ) {
		J = J + 1;
		K = K || {};
		if ( arguments.length === 1 && !YAHOO.lang.isString( L ) && !L.nodeName ) {
			K = L;
			L = K.element || null;
		}
		if ( !L && !K.element ) {
			L = this._createHostElement( K );
		}
		G.superclass.constructor.call( this, L, K );
		this.initPicker();
	}
	YAHOO.extend( G, YAHOO.util.Element, {
		ID: { R: H + "-r", R_HEX: H + "-rhex", G: H + "-g", G_HEX: H + "-ghex", B: H + "-b", B_HEX: H + "-bhex", H: H + "-h", S: H + "-s", V: H + "-v", PICKER_BG: H + "-bg", PICKER_THUMB: H + "-thumb", HUE_BG: H + "-hue-bg", HUE_THUMB: H + "-hue-thumb", HEX: H + "-hex", SWATCH: H + "-swatch", WEBSAFE_SWATCH: H + "-websafe-swatch", CONTROLS: H + "-controls", RGB_CONTROLS: H + "-rgb-controls", HSV_CONTROLS: H + "-hsv-controls", HEX_CONTROLS: H + "-hex-controls", HEX_SUMMARY: H + "-hex-summary", CONTROLS_LABEL: H + "-controls-label" },
		TXT: { ILLEGAL_HEX: "Illegal hex value entered", SHOW_CONTROLS: "Show color details", HIDE_CONTROLS: "Hide color details", CURRENT_COLOR: "Currently selected color: {rgb}", CLOSEST_WEBSAFE: "Closest websafe color: {rgb}. Click to select.", R: "R", G: "G", B: "B", H: "H", S: "S", V: "V", HEX: "#", DEG: "\u00B0", PERCENT: "%" },
		IMAGE: { PICKER_THUMB: "../../build/colorpicker/assets/picker_thumb.png", HUE_THUMB: "../../build/colorpicker/assets/hue_thumb.png" },
		DEFAULT: { PICKER_SIZE: 180 },
		OPT: { HUE: "hue", SATURATION: "saturation", VALUE: "value", RED: "red", GREEN: "green", BLUE: "blue", HSV: "hsv", RGB: "rgb", WEBSAFE: "websafe", HEX: "hex", PICKER_SIZE: "pickersize", SHOW_CONTROLS: "showcontrols", SHOW_RGB_CONTROLS: "showrgbcontrols", SHOW_HSV_CONTROLS: "showhsvcontrols", SHOW_HEX_CONTROLS: "showhexcontrols", SHOW_HEX_SUMMARY: "showhexsummary", SHOW_WEBSAFE: "showwebsafe", CONTAINER: "container", IDS: "ids", ELEMENTS: "elements", TXT: "txt", IMAGES: "images", ANIMATE: "animate" },
		skipAnim: true, _createHostElement: function() {
			var K = document.createElement( "div" );
			if ( this.CSS.BASE ) {
				K.className = this.CSS.BASE;
			}
			return K;
		},
		_updateHueSlider: function() {
			var K = this.get( this.OPT.PICKER_SIZE ),
				L = this.get( this.OPT.HUE );
			L = K - Math.round( L / 360 * K );
			if ( L === K ) {
				L = 0;
			}
			this.hueSlider.setValue( L, this.skipAnim );
		},
		_updatePickerSlider: function() {
			var L = this.get( this.OPT.PICKER_SIZE ),
				M = this.get( this.OPT.SATURATION ),
				K = this.get( this.OPT.VALUE );
			M = Math.round( M * L / 100 );
			K = Math.round( L - ( K * L / 100 ) );
			this.pickerSlider.setRegionValue( M, K, this.skipAnim );
		},
		_updateSliders: function() {
			this._updateHueSlider();
			this._updatePickerSlider();
		},
		setValue: function( L, K ) {
			K = ( K ) || false;
			this.set( this.OPT.RGB, L, K );
			this._updateSliders();
		},
		hueSlider: null, pickerSlider: null, _getH: function() {
			var K = this.get( this.OPT.PICKER_SIZE ),
				L = ( K - this.hueSlider.getValue() ) / K;
			L = Math.round( L * 360 );
			return ( L === 360 ) ? 0 : L;
		},
		_getS: function() {
			return this.pickerSlider.getXValue() / this.get( this.OPT.PICKER_SIZE );
		},
		_getV: function() {
			var K = this.get( this.OPT.PICKER_SIZE );
			return ( K - this.pickerSlider.getYValue() ) / K;
		},
		_updateSwatch: function() {
			var M = this.get( this.OPT.RGB ),
				O = this.get( this.OPT.WEBSAFE ),
				N = this.getElement( this.ID.SWATCH ),
				L = M.join( "," ),
				K = this.get( this.OPT.TXT );
			E.setStyle( N, "background-color", "rgb(" + L + ")" );
			N.title = A( K.CURRENT_COLOR, { "rgb": "#" + this.get( this.OPT.HEX ) } );
			N = this.getElement( this.ID.WEBSAFE_SWATCH );
			L = O.join( "," );
			E.setStyle( N, "background-color", "rgb(" + L + ")" );
			N.title = A( K.CLOSEST_WEBSAFE, { "rgb": "#" + B.rgb2hex( O ) } );
		},
		_getValuesFromSliders: function() {
			this.set( this.OPT.RGB, B.hsv2rgb( this._getH(), this._getS(), this._getV() ) );
		},
		_updateFormFields: function() {
			this.getElement( this.ID.H ).value = this.get( this.OPT.HUE );
			this.getElement( this.ID.S ).value = this.get( this.OPT.SATURATION );
			this.getElement( this.ID.V ).value = this.get( this.OPT.VALUE );
			this.getElement( this.ID.R ).value = this.get( this.OPT.RED );
			this.getElement( this.ID.R_HEX ).innerHTML = B.dec2hex( this.get( this.OPT.RED ) );
			this.getElement( this.ID.G ).value = this.get( this.OPT.GREEN );
			this.getElement( this.ID.G_HEX ).innerHTML = B.dec2hex( this.get( this.OPT.GREEN ) );
			this.getElement( this.ID.B ).value = this.get( this.OPT.BLUE );
			this.getElement( this.ID.B_HEX ).innerHTML = B.dec2hex( this.get( this.OPT.BLUE ) );
			this.getElement( this.ID.HEX ).value = this.get( this.OPT.HEX );
		},
		_onHueSliderChange: function( N ) {
			var L = this._getH(),
				K = B.hsv2rgb( L, 1, 1 ),
				M = "rgb(" + K.join( "," ) + ")";
			this.set( this.OPT.HUE, L, true );
			E.setStyle( this.getElement( this.ID.PICKER_BG ), "background-color", M );
			if ( this.hueSlider.valueChangeSource !== D.SOURCE_SET_VALUE ) {
				this._getValuesFromSliders();
			}
			this._updateFormFields();
			this._updateSwatch();
		},
		_onPickerSliderChange: function( M ) {
			var L = this._getS(),
				K = this._getV();
			this.set( this.OPT.SATURATION, Math.round( L * 100 ), true );
			this.set( this.OPT.VALUE, Math.round( K * 100 ), true );
			if ( this.pickerSlider.valueChangeSource !== D.SOURCE_SET_VALUE ) {
				this._getValuesFromSliders();
			}
			this._updateFormFields();
			this._updateSwatch();
		},
		_getCommand: function( K ) {
			var L = I.getCharCode( K );
			if ( L === 38 ) {
				return 3;
			} else {
				if ( L === 13 ) {
					return 6;
				} else {
					if ( L === 40 ) {
						return 4;
					} else {
						if ( L >= 48 && L <= 57 ) {
							return 1;
						} else {
							if ( L >= 97 && L <= 102 ) {
								return 2;
							} else {
								if ( L >= 65 && L <= 70 ) {
									return 2;
								} else {
									if ( "8, 9, 13, 27, 37, 39".indexOf( L ) > -1 || K.ctrlKey || K.metaKey ) {
										return 5;
									} else {
										return 0;
									}
								}
							}
						}
					}
				}
			}
		},
		_useFieldValue: function( L, K, N ) {
			var M = K.value; if ( N !== this.OPT.HEX ) {
				M = parseInt( M, 10 );
			}
			if ( M !== this.get( N ) ) {
				this.set( N, M );
			}
		},
		_rgbFieldKeypress: function( M, K, O ) {
			var N = this._getCommand( M ),
				L = ( M.shiftKey ) ? 10 : 1;
			switch ( N ) {
				case 6:
					this._useFieldValue.apply( this, arguments );
					break;case 3:
					this.set( O, Math.min( this.get( O ) + L, 255 ) );
					this._updateFormFields();
					break;case 4:
					this.set( O, Math.max( this.get( O ) - L, 0 ) );
					this._updateFormFields();
					break;default:
			}
		},
		_hexFieldKeypress: function( L, K, N ) {
			var M = this._getCommand( L );
			if ( M === 6 ) {
				this._useFieldValue.apply( this, arguments );
			}
		},
		_hexOnly: function( L, K ) {
			var M = this._getCommand( L );
			switch ( M ) {
				case 6:
				case 5:
				case 1:
					break;case 2:
					if ( K !== true ) {
						break;
					}default:
					I.stopEvent( L );
					return false;
			}
		},
		_numbersOnly: function( K ) {
			return this._hexOnly( K, true );
		},
		getElement: function( K ) {
			return this.get( this.OPT.ELEMENTS )[ this.get( this.OPT.IDS )[ K ] ];
		},
		_createElements: function() {
			var N, M, P, O, L,
				K = this.get( this.OPT.IDS ),
				Q = this.get( this.OPT.TXT ),
				S = this.get( this.OPT.IMAGES ),
				R = function( U, V ) {
					var W = document.createElement( U );
					if ( V ) {
						C.augmentObject( W, V, true );
					}
					return W;
				},
				T = function( U, V ) {
					var W = C.merge({ autocomplete: "off", value: "0", size: 3, maxlength: 3 }, V );
					W.name = W.id;
					return new R( U, W );
				};
			L = this.get( "element" );
			N = new R( "div", { id: K[ this.ID.PICKER_BG ], className: "yui-picker-bg", tabIndex: -1, hideFocus: true } );
			M = new R( "div", { id: K[ this.ID.PICKER_THUMB ], className: "yui-picker-thumb" } );
			P = new R( "img", { src: S.PICKER_THUMB } );
			M.appendChild( P );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "div", { id: K[ this.ID.HUE_BG ], className: "yui-picker-hue-bg", tabIndex: -1, hideFocus: true } );
			M = new R( "div", { id: K[ this.ID.HUE_THUMB ], className: "yui-picker-hue-thumb" } );
			P = new R( "img", { src: S.HUE_THUMB } );
			M.appendChild( P );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "div", { id: K[ this.ID.CONTROLS ], className: "yui-picker-controls" } );
			L.appendChild( N );
			L = N;
			N = new R( "div", { className: "hd" } );
			M = new R( "a", { id: K[ this.ID.CONTROLS_LABEL ], href: "#" } );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "div", { className: "bd" } );
			L.appendChild( N );
			L = N;
			N = new R( "ul", { id: K[ this.ID.RGB_CONTROLS ], className: "yui-picker-rgb-controls" } );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.R + " " ) );
			O = new T( "input", { id: K[ this.ID.R ], className: "yui-picker-r" } );
			M.appendChild( O );
			N.appendChild( M );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.G + " " ) );
			O = new T( "input", { id: K[ this.ID.G ], className: "yui-picker-g" } );
			M.appendChild( O );
			N.appendChild( M );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.B + " " ) );
			O = new T( "input", { id: K[ this.ID.B ], className: "yui-picker-b" } );
			M.appendChild( O );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "ul", { id: K[ this.ID.HSV_CONTROLS ], className: "yui-picker-hsv-controls" } );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.H + " " ) );
			O = new T( "input", { id: K[ this.ID.H ], className: "yui-picker-h" } );
			M.appendChild( O );
			M.appendChild( document.createTextNode( " " + Q.DEG ) );
			N.appendChild( M );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.S + " " ) );
			O = new T( "input", { id: K[ this.ID.S ], className: "yui-picker-s" } );
			M.appendChild( O );
			M.appendChild( document.createTextNode( " " + Q.PERCENT ) );
			N.appendChild( M );
			M = new R( "li" );
			M.appendChild( document.createTextNode( Q.V + " " ) );
			O = new T( "input", { id: K[ this.ID.V ], className: "yui-picker-v" } );
			M.appendChild( O );
			M.appendChild( document.createTextNode( " " + Q.PERCENT ) );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "ul", { id: K[ this.ID.HEX_SUMMARY ], className: "yui-picker-hex_summary" } );
			M = new R( "li", { id: K[ this.ID.R_HEX ] } );
			N.appendChild( M );
			M = new R( "li", { id: K[ this.ID.G_HEX ] } );
			N.appendChild( M );
			M = new R( "li", { id: K[ this.ID.B_HEX ] } );
			N.appendChild( M );
			L.appendChild( N );
			N = new R( "div", { id: K[ this.ID.HEX_CONTROLS ], className: "yui-picker-hex-controls" } );
			N.appendChild( document.createTextNode( Q.HEX + " " ) );
			M = new T( "input", { id: K[ this.ID.HEX ], className: "yui-picker-hex", size: 6, maxlength: 6 } );
			N.appendChild( M );
			L.appendChild( N );
			L = this.get( "element" );
			N = new R( "div", { id: K[ this.ID.SWATCH ], className: "yui-picker-swatch" } );
			L.appendChild( N );
			N = new R( "div", { id: K[ this.ID.WEBSAFE_SWATCH ], className: "yui-picker-websafe-swatch" } );
			L.appendChild( N );
		},
		_attachRGBHSV: function( L, K ) {
			I.on( this.getElement( L ), "keydown", function( N, M ) {
				M._rgbFieldKeypress( N, this, K );
			}, this );
			I.on( this.getElement( L ), "keypress", this._numbersOnly, this, true );
			I.on( this.getElement( L ), "blur", function( N, M ) {
				M._useFieldValue( N, this, K );
			}, this );
		},
		_updateRGB: function() {
			var K = [ this.get( this.OPT.RED ), this.get( this.OPT.GREEN ), this.get( this.OPT.BLUE ) ];
			this.set( this.OPT.RGB, K );
			this._updateSliders();
		},
		_initElements: function() {
			var O = this.OPT,
				N = this.get( O.IDS ),
				L = this.get( O.ELEMENTS ),
				K, M, P;
			for ( K in this.ID ) {
				if ( C.hasOwnProperty( this.ID, K ) ) {
					N[ this.ID[ K ] ] = N[ K ];
				}
			}
			M = E.get( N[ this.ID.PICKER_BG ] );
			if ( !M ) {
				this._createElements();
			} else {}
			for ( K in N ) {
				if ( C.hasOwnProperty( N, K ) ) {
					M = E.get( N[ K ] );
					P = E.generateId( M );
					N[ K ] = P;
					N[ N[ K ] ] = P;
					L[ P ] = M;
				}
			}
		},
		initPicker: function() {
			this._initSliders();
			this._bindUI();
			this.syncUI( true );
		},
		_initSliders: function() {
			var K = this.ID,
				L = this.get( this.OPT.PICKER_SIZE );
			this.hueSlider = D.getVertSlider( this.getElement( K.HUE_BG ), this.getElement( K.HUE_THUMB ), 0, L );
			this.pickerSlider = D.getSliderRegion( this.getElement( K.PICKER_BG ), this.getElement( K.PICKER_THUMB ), 0, L, 0, L );
			this.set( this.OPT.ANIMATE, this.get( this.OPT.ANIMATE ) );
		},
		_bindUI: function() {
			var K = this.ID,
				L = this.OPT; this.hueSlider.subscribe( "change", this._onHueSliderChange, this, true );
			this.pickerSlider.subscribe( "change", this._onPickerSliderChange, this, true );
			I.on( this.getElement( K.WEBSAFE_SWATCH ), "click", function( M ) {
				this.setValue( this.get( L.WEBSAFE ) );
			}, this, true );
			I.on( this.getElement( K.CONTROLS_LABEL ), "click", function( M ) {
				this.set( L.SHOW_CONTROLS, !this.get( L.SHOW_CONTROLS ) );
				I.preventDefault( M );
			}, this, true );
			this._attachRGBHSV( K.R, L.RED );
			this._attachRGBHSV( K.G, L.GREEN );
			this._attachRGBHSV( K.B, L.BLUE );
			this._attachRGBHSV( K.H, L.HUE );
			this._attachRGBHSV( K.S, L.SATURATION );
			this._attachRGBHSV( K.V, L.VALUE );
			I.on( this.getElement( K.HEX ), "keydown", function( N, M ) {
				M._hexFieldKeypress( N, this, L.HEX );
			}, this );
			I.on( this.getElement( this.ID.HEX ), "keypress", this._hexOnly, this, true );
			I.on( this.getElement( this.ID.HEX ), "blur", function( N, M ) {
				M._useFieldValue( N, this, L.HEX );
			}, this );
		},
		syncUI: function( K ) {
			this.skipAnim = K; this._updateRGB();
			this.skipAnim = false;
		},
		_updateRGBFromHSV: function() {
			var L = [ this.get( this.OPT.HUE ), this.get( this.OPT.SATURATION ) / 100, this.get( this.OPT.VALUE ) / 100 ],
				K = B.hsv2rgb( L );
			this.set( this.OPT.RGB, K );
			this._updateSliders();
		},
		_updateHex: function() {
			var N = this.get( this.OPT.HEX ),
				K = N.length,
				O, M, L;
			if ( K === 3 ) {
				O = N.split( "" );
				for ( M = 0; M < K; M = M + 1 ) {
					O[ M ] = O[ M ] + O[ M ];
				}
				N = O.join( "" );
			}
			if ( N.length !== 6 ) {
				return false;
			}
			L = B.hex2rgb( N );
			this.setValue( L );
		},
		_hideShowEl: function( M, K ) {
			var L = ( C.isString( M ) ? this.getElement( M ) : M );
			E.setStyle( L, "display", ( K ) ? "" : "none" );
		},
		initAttributes: function( K ) {
			K = K || {};
			G.superclass.initAttributes.call( this, K );
			this.setAttributeConfig( this.OPT.PICKER_SIZE, { value: K.size || this.DEFAULT.PICKER_SIZE } );
			this.setAttributeConfig( this.OPT.HUE, { value: K.hue || 0, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.SATURATION, { value: K.saturation || 0, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.VALUE, { value: C.isNumber( K.value ) ? K.value : 100, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.RED, { value: C.isNumber( K.red ) ? K.red : 255, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.GREEN, { value: C.isNumber( K.green ) ? K.green : 255, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.BLUE, { value: C.isNumber( K.blue ) ? K.blue : 255, validator: C.isNumber } );
			this.setAttributeConfig( this.OPT.HEX, { value: K.hex || "FFFFFF", validator: C.isString } );
			this.setAttributeConfig( this.OPT.RGB, {
				value: K.rgb || [ 255, 255, 255 ], method: function( O ) {
					this.set( this.OPT.RED, O[ 0 ], true );
					this.set( this.OPT.GREEN, O[ 1 ], true );
					this.set( this.OPT.BLUE, O[ 2 ], true );
					var Q = B.websafe( O ),
						P = B.rgb2hex( O ),
						N = B.rgb2hsv( O );
					this.set( this.OPT.WEBSAFE, Q, true );
					this.set( this.OPT.HEX, P, true );
					if ( N[ 1 ] ) {
						this.set( this.OPT.HUE, N[ 0 ], true );
					}
					this.set( this.OPT.SATURATION, Math.round( N[ 1 ] * 100 ), true );
					this.set( this.OPT.VALUE, Math.round( N[ 2 ] * 100 ), true );
				},
				readonly: true } );
			this.setAttributeConfig( this.OPT.CONTAINER, {
				value: null, method: function( N ) {
					if ( N ) {
						N.showEvent.subscribe( function() {
							this.pickerSlider.focus();
						}, this, true );
					}
				} } );
			this.setAttributeConfig( this.OPT.WEBSAFE, { value: K.websafe || [ 255, 255, 255 ] } );
			var M = K.ids || C.merge( {}, this.ID ),
				L;
			if ( !K.ids && J > 1 ) {
				for ( L in M ) {
					if ( C.hasOwnProperty( M, L ) ) {
						M[ L ] = M[ L ] + J;
					}
				}
			}
			this.setAttributeConfig( this.OPT.IDS, { value: M, writeonce: true } );
			this.setAttributeConfig( this.OPT.TXT, { value: K.txt || this.TXT, writeonce: true } );
			this.setAttributeConfig( this.OPT.IMAGES, { value: K.images || this.IMAGE, writeonce: true } );
			this.setAttributeConfig( this.OPT.ELEMENTS, {
				value: {},
				readonly: true } );
			this.setAttributeConfig( this.OPT.SHOW_CONTROLS, {
				value: C.isBoolean( K.showcontrols ) ? K.showcontrols : true, method: function( N ) {
					var O = E.getElementsByClassName( "bd", "div", this.getElement( this.ID.CONTROLS ) )[ 0 ];
					this._hideShowEl( O, N );
					this.getElement( this.ID.CONTROLS_LABEL ).innerHTML = ( N ) ? this.get( this.OPT.TXT ).HIDE_CONTROLS : this.get( this.OPT.TXT ).SHOW_CONTROLS;
				} } );
			this.setAttributeConfig( this.OPT.SHOW_RGB_CONTROLS, {
				value: C.isBoolean( K.showrgbcontrols ) ? K.showrgbcontrols : true, method: function( N ) {
					this._hideShowEl( this.ID.RGB_CONTROLS, N );
				} } );
			this.setAttributeConfig( this.OPT.SHOW_HSV_CONTROLS, {
				value: C.isBoolean( K.showhsvcontrols ) ? K.showhsvcontrols : false, method: function( N ) {
					this._hideShowEl( this.ID.HSV_CONTROLS, N );
					if ( N && this.get( this.OPT.SHOW_HEX_SUMMARY ) ) {
						this.set( this.OPT.SHOW_HEX_SUMMARY, false );
					}
				} } );
			this.setAttributeConfig( this.OPT.SHOW_HEX_CONTROLS, {
				value: C.isBoolean( K.showhexcontrols ) ? K.showhexcontrols : false, method: function( N ) {
					this._hideShowEl( this.ID.HEX_CONTROLS, N );
				} } );
			this.setAttributeConfig( this.OPT.SHOW_WEBSAFE, {
				value: C.isBoolean( K.showwebsafe ) ? K.showwebsafe : true, method: function( N ) {
					this._hideShowEl( this.ID.WEBSAFE_SWATCH, N );
				} } );
			this.setAttributeConfig( this.OPT.SHOW_HEX_SUMMARY, {
				value: C.isBoolean( K.showhexsummary ) ? K.showhexsummary : true, method: function( N ) {
					this._hideShowEl( this.ID.HEX_SUMMARY, N );
					if ( N && this.get( this.OPT.SHOW_HSV_CONTROLS ) ) {
						this.set( this.OPT.SHOW_HSV_CONTROLS, false );
					}
				} } );
			this.setAttributeConfig( this.OPT.ANIMATE, {
				value: C.isBoolean( K.animate ) ? K.animate : true, method: function( N ) {
					if ( this.pickerSlider ) {
						this.pickerSlider.animate = N;
						this.hueSlider.animate = N;
					}
				} } );
			this.on( this.OPT.HUE + "Change", this._updateRGBFromHSV, this, true );
			this.on( this.OPT.SATURATION + "Change", this._updateRGBFromHSV, this, true );
			this.on( this.OPT.VALUE + "Change", this._updateRGBFromHSV, this, true );
			this.on( this.OPT.RED + "Change", this._updateRGB, this, true );
			this.on( this.OPT.GREEN + "Change", this._updateRGB, this, true );
			this.on( this.OPT.BLUE + "Change", this._updateRGB, this, true );
			this.on( this.OPT.HEX + "Change", this._updateHex, this, true );
			this._initElements();
		} } );
	YAHOO.widget.ColorPicker = G;
})();
YAHOO.register( "colorpicker", YAHOO.widget.ColorPicker, { version: "2.7.0", build: "1796" } );

/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/ ( function() {
	var B = YAHOO.util;
	var A = function( D, C, E, F ) {
			if ( !D ) {}
			this.init( D, C, E, F );
		};
	A.NAME = "Anim";
	A.prototype = {
		toString: function() {
			var C = this.getEl() || {};
			var D = C.id || C.tagName;
			return ( this.constructor.NAME + ": " + D );
		},
		patterns: { noNegatives: /width|height|opacity|padding/i, offsetAttribute: /^((width|height)|(top|left))$/, defaultUnit: /width|height|top$|bottom$|left$|right$/i, offsetUnit: /\d+(em|%|en|ex|pt|in|cm|mm|pc)$/i },
		doMethod: function( C, E, D ) {
			return this.method( this.currentFrame, E, D - E, this.totalFrames );
		},
		setAttribute: function( C, F, E ) {
			var D = this.getEl();
			if ( this.patterns.noNegatives.test( C ) ) {
				F = ( F > 0 ) ? F : 0;
			}
			if ( "style" in D ) {
				B.Dom.setStyle( D, C, F + E );
			} else {
				if ( C in D ) {
					D[ C ] = F;
				}
			}
		},
		getAttribute: function( C ) {
			var E = this.getEl();
			var G = B.Dom.getStyle( E, C );
			if ( G !== "auto" && !this.patterns.offsetUnit.test( G ) ) {
				return parseFloat( G );
			}
			var D = this.patterns.offsetAttribute.exec( C ) || [];
			var H = !!( D[ 3 ] );
			var F = !!( D[ 2 ] );
			if ( "style" in E ) {
				if ( F || ( B.Dom.getStyle( E, "position" ) == "absolute" && H ) ) {
					G = E[ "offset" + D[ 0 ].charAt( 0 ).toUpperCase() + D[ 0 ].substr( 1 ) ];
				} else {
					G = 0;
				}
			} else {
				if ( C in E ) {
					G = E[ C ];
				}
			}
			return G;
		},
		getDefaultUnit: function( C ) {
			if ( this.patterns.defaultUnit.test( C ) ) {
				return "px";
			}
			return "";
		},
		setRuntimeAttribute: function( D ) {
			var I; var E; var F = this.attributes; this.runtimeAttributes[ D ] = {};
			var H = function( J ) {
					return ( typeof J !== "undefined" );
				};
			if ( !H( F[ D ][ "to" ] ) && !H( F[ D ][ "by" ] ) ) {
				return false;
			}
			I = ( H( F[ D ][ "from" ] ) ) ? F[ D ][ "from" ] : this.getAttribute( D );
			if ( H( F[ D ][ "to" ] ) ) {
				E = F[ D ][ "to" ];
			} else {
				if ( H( F[ D ][ "by" ] ) ) {
					if ( I.constructor == Array ) {
						E = [];
						for ( var G = 0, C = I.length; G < C; ++G ) {
							E[ G ] = I[ G ] + F[ D ][ "by" ][ G ] * 1;
						}
					} else {
						E = I + F[ D ][ "by" ] * 1;
					}
				}
			}
			this.runtimeAttributes[ D ].start = I;
			this.runtimeAttributes[ D ].end = E;
			this.runtimeAttributes[ D ].unit = ( H( F[ D ].unit ) ) ? F[ D ][ "unit" ] : this.getDefaultUnit( D );
			return true;
		},
		init: function( E, J, I, C ) {
			var D = false; var F = null; var H = 0; E = B.Dom.get( E );
			this.attributes = J || {};
			this.duration = !YAHOO.lang.isUndefined( I ) ? I : 1;
			this.method = C || B.Easing.easeNone;
			this.useSeconds = true;
			this.currentFrame = 0;
			this.totalFrames = B.AnimMgr.fps;
			this.setEl = function( M ) {
				E = B.Dom.get( M );
			};
			this.getEl = function() {
				return E;
			};
			this.isAnimated = function() {
				return D;
			};
			this.getStartTime = function() {
				return F;
			};
			this.runtimeAttributes = {};
			this.animate = function() {
				if ( this.isAnimated() ) {
					return false;
				}
				this.currentFrame = 0;
				this.totalFrames = ( this.useSeconds ) ? Math.ceil( B.AnimMgr.fps * this.duration ) : this.duration;
				if ( this.duration === 0 && this.useSeconds ) {
					this.totalFrames = 1;
				}
				B.AnimMgr.registerElement( this );
				return true;
			};
			this.stop = function( M ) {
				if ( !this.isAnimated() ) {
					return false;
				}
				if ( M ) {
					this.currentFrame = this.totalFrames;
					this._onTween.fire();
				}
				B.AnimMgr.stop( this );
			};
			var L = function() {
					this.onStart.fire();
					this.runtimeAttributes = {};
					for ( var M in this.attributes ) {
						this.setRuntimeAttribute( M );
					}
					D = true;
					H = 0;
					F = new Date();
				};
			var K = function() {
					var O = { duration: new Date() - this.getStartTime(), currentFrame: this.currentFrame }; O.toString = function() {
						return ( "duration: " + O.duration + ", currentFrame: " + O.currentFrame );
					};
					this.onTween.fire( O );
					var N = this.runtimeAttributes;
					for ( var M in N ) {
						this.setAttribute( M, this.doMethod( M, N[ M ].start, N[ M ].end ), N[ M ].unit );
					}
					H += 1;
				};
			var G = function() {
					var M = ( new Date() - F ) / 1000;
					var N = { duration: M, frames: H, fps: H / M }; N.toString = function() {
						return ( "duration: " + N.duration + ", frames: " + N.frames + ", fps: " + N.fps );
					};
					D = false;
					H = 0;
					this.onComplete.fire( N );
				};
			this._onStart = new B.CustomEvent( "_start", this, true );
			this.onStart = new B.CustomEvent( "start", this );
			this.onTween = new B.CustomEvent( "tween", this );
			this._onTween = new B.CustomEvent( "_tween", this, true );
			this.onComplete = new B.CustomEvent( "complete", this );
			this._onComplete = new B.CustomEvent( "_complete", this, true );
			this._onStart.subscribe( L );
			this._onTween.subscribe( K );
			this._onComplete.subscribe( G );
		} }; B.Anim = A;
})();
YAHOO.util.AnimMgr = new function() {
	var C = null;
	var B = [];
	var A = 0;
	this.fps = 1000;
	this.delay = 1;
	this.registerElement = function( F ) {
		B[ B.length ] = F;
		A += 1;
		F._onStart.fire();
		this.start();
	};
	this.unRegister = function( G, F ) {
		F = F || E( G );
		if ( !G.isAnimated() || F == -1 ) {
			return false;
		}
		G._onComplete.fire();
		B.splice( F, 1 );
		A -= 1;
		if ( A <= 0 ) {
			this.stop();
		}
		return true;
	};
	this.start = function() {
		if ( C === null ) {
			C = setInterval( this.run, this.delay );
		}
	};
	this.stop = function( H ) {
		if ( !H ) {
			clearInterval( C );
			for ( var G = 0, F = B.length; G < F; ++G ) {
				this.unRegister( B[ 0 ], 0 );
			}
			B = [];
			C = null;
			A = 0;
		} else {
			this.unRegister( H );
		}
	};
	this.run = function() {
		for ( var H = 0, F = B.length; H < F; ++H ) {
			var G = B[ H ];
			if ( !G || !G.isAnimated() ) {
				continue;
			}
			if ( G.currentFrame < G.totalFrames || G.totalFrames === null ) {
				G.currentFrame += 1;
				if ( G.useSeconds ) {
					D( G );
				}
				G._onTween.fire();
			} else {
				YAHOO.util.AnimMgr.stop( G, H );
			}
		}
	};
	var E = function( H ) {
			for ( var G = 0, F = B.length; G < F; ++G ) {
				if ( B[ G ] == H ) {
					return G;
				}
			}
			return -1;
		};
	var D = function( G ) {
			var J = G.totalFrames;
			var I = G.currentFrame;
			var H = ( G.currentFrame * G.duration * 1000 / G.totalFrames );
			var F = ( new Date() - G.getStartTime() );
			var K = 0;
			if ( F < G.duration * 1000 ) {
				K = Math.round( ( F / H - 1 ) * G.currentFrame );
			} else {
				K = J - ( I + 1 );
			}
			if ( K > 0 && isFinite( K ) ) {
				if ( G.currentFrame + K >= J ) {
					K = J - ( I + 1 );
				}
				G.currentFrame += K;
			}
		};
};
YAHOO.util.Bezier = new function() {
	this.getPosition = function( E, D ) {
		var F = E.length;
		var C = [];
		for ( var B = 0; B < F; ++B ) {
			C[ B ] = [ E[ B ][ 0 ], E[ B ][ 1 ] ];
		}
		for ( var A = 1; A < F; ++A ) {
			for ( B = 0; B < F - A; ++B ) {
				C[ B ][ 0 ] = ( 1 - D ) * C[ B ][ 0 ] + D * C[ parseInt( B + 1, 10 ) ][ 0 ];
				C[ B ][ 1 ] = ( 1 - D ) * C[ B ][ 1 ] + D * C[ parseInt( B + 1, 10 ) ][ 1 ];
			}
		}
		return [ C[ 0 ][ 0 ], C[ 0 ][ 1 ] ];
	};
};
(function() {
	var A = function( F, E, G, H ) {
			A.superclass.constructor.call( this, F, E, G, H );
		};
	A.NAME = "ColorAnim";
	A.DEFAULT_BGCOLOR = "#fff";
	var C = YAHOO.util;
	YAHOO.extend( A, C.Anim );
	var D = A.superclass;
	var B = A.prototype;
	B.patterns.color = /color$/i;
	B.patterns.rgb = /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i;
	B.patterns.hex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i;
	B.patterns.hex3 = /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;
	B.patterns.transparent = /^transparent|rgba\(0, 0, 0, 0\)$/;
	B.parseColor = function( E ) {
		if ( E.length == 3 ) {
			return E;
		}
		var F = this.patterns.hex.exec( E );
		if ( F && F.length == 4 ) {
			return [ parseInt( F[ 1 ], 16 ), parseInt( F[ 2 ], 16 ), parseInt( F[ 3 ], 16 ) ];
		}
		F = this.patterns.rgb.exec( E );
		if ( F && F.length == 4 ) {
			return [ parseInt( F[ 1 ], 10 ), parseInt( F[ 2 ], 10 ), parseInt( F[ 3 ], 10 ) ];
		}
		F = this.patterns.hex3.exec( E );
		if ( F && F.length == 4 ) {
			return [ parseInt( F[ 1 ] + F[ 1 ], 16 ), parseInt( F[ 2 ] + F[ 2 ], 16 ), parseInt( F[ 3 ] + F[ 3 ], 16 ) ];
		}
		return null;
	};
	B.getAttribute = function( E ) {
		var G = this.getEl();
		if ( this.patterns.color.test( E ) ) {
			var I = YAHOO.util.Dom.getStyle( G, E );
			var H = this;
			if ( this.patterns.transparent.test( I ) ) {
				var F = YAHOO.util.Dom.getAncestorBy( G, function( J ) {
					return !H.patterns.transparent.test( I );
				});
				if ( F ) {
					I = C.Dom.getStyle( F, E );
				} else {
					I = A.DEFAULT_BGCOLOR;
				}
			}
		} else {
			I = D.getAttribute.call( this, E );
		}
		return I;
	};
	B.doMethod = function( F, J, G ) {
		var I;
		if ( this.patterns.color.test( F ) ) {
			I = [];
			for ( var H = 0, E = J.length; H < E; ++H ) {
				I[ H ] = D.doMethod.call( this, F, J[ H ], G[ H ] );
			}
			I = "rgb(" + Math.floor( I[ 0 ] ) + "," + Math.floor( I[ 1 ] ) + "," + Math.floor( I[ 2 ] ) + ")";
		} else {
			I = D.doMethod.call( this, F, J, G );
		}
		return I;
	};
	B.setRuntimeAttribute = function( F ) {
		D.setRuntimeAttribute.call( this, F );
		if ( this.patterns.color.test( F ) ) {
			var H = this.attributes;
			var J = this.parseColor( this.runtimeAttributes[ F ].start );
			var G = this.parseColor( this.runtimeAttributes[ F ].end );
			if ( typeof H[ F ][ "to" ] === "undefined" && typeof H[ F ][ "by" ] !== "undefined" ) {
				G = this.parseColor( H[ F ].by );
				for ( var I = 0, E = J.length; I < E; ++I ) {
					G[ I ] = J[ I ] + G[ I ];
				}
			}
			this.runtimeAttributes[ F ].start = J;
			this.runtimeAttributes[ F ].end = G;
		}
	};
	C.ColorAnim = A;
})();
/*
TERMS OF USE - EASING EQUATIONS
Open source under the BSD License.
Copyright 2001 Robert Penner All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
YAHOO.util.Easing = {
	easeNone: function( B, A, D, C ) {
		return D * B / C + A;
	},
	easeIn: function( B, A, D, C ) {
		return D * ( B /= C ) * B + A;
	},
	easeOut: function( B, A, D, C ) {
		return -D * ( B /= C ) * ( B - 2 ) + A;
	},
	easeBoth: function( B, A, D, C ) {
		if ( ( B /= C / 2 ) < 1 ) {
			return D / 2 * B * B + A;
		}
		return -D / 2 * ( ( --B ) * ( B - 2 ) - 1 ) + A;
	},
	easeInStrong: function( B, A, D, C ) {
		return D * ( B /= C ) * B * B * B + A;
	},
	easeOutStrong: function( B, A, D, C ) {
		return -D * ( ( B = B / C - 1 ) * B * B * B - 1 ) + A;
	},
	easeBothStrong: function( B, A, D, C ) {
		if ( ( B /= C / 2 ) < 1 ) {
			return D / 2 * B * B * B * B + A;
		}
		return -D / 2 * ( ( B -= 2 ) * B * B * B - 2 ) + A;
	},
	elasticIn: function( C, A, G, F, B, E ) {
		if ( C == 0 ) {
			return A;
		}
		if ( ( C /= F ) == 1 ) {
			return A + G;
		}
		if ( !E ) {
			E = F * 0.3;
		}
		if ( !B || B < Math.abs( G ) ) {
			B = G;
			var D = E / 4;
		} else {
			var D = E / ( 2 * Math.PI ) * Math.asin( G / B );
		}
		return -( B * Math.pow( 2, 10 * ( C -= 1 ) ) * Math.sin( ( C * F - D ) * ( 2 * Math.PI ) / E ) ) + A;
	},
	elasticOut: function( C, A, G, F, B, E ) {
		if ( C == 0 ) {
			return A;
		}
		if ( ( C /= F ) == 1 ) {
			return A + G;
		}
		if ( !E ) {
			E = F * 0.3;
		}
		if ( !B || B < Math.abs( G ) ) {
			B = G;
			var D = E / 4;
		} else {
			var D = E / ( 2 * Math.PI ) * Math.asin( G / B );
		}
		return B * Math.pow( 2, -10 * C ) * Math.sin( ( C * F - D ) * ( 2 * Math.PI ) / E ) + G + A;
	},
	elasticBoth: function( C, A, G, F, B, E ) {
		if ( C == 0 ) {
			return A;
		}
		if ( ( C /= F / 2 ) == 2 ) {
			return A + G;
		}
		if ( !E ) {
			E = F * ( 0.3 * 1.5 );
		}
		if ( !B || B < Math.abs( G ) ) {
			B = G;
			var D = E / 4;
		} else {
			var D = E / ( 2 * Math.PI ) * Math.asin( G / B );
		}
		if ( C < 1 ) {
			return -0.5 * ( B * Math.pow( 2, 10 * ( C -= 1 ) ) * Math.sin( ( C * F - D ) * ( 2 * Math.PI ) / E ) ) + A;
		}
		return B * Math.pow( 2, -10 * ( C -= 1 ) ) * Math.sin( ( C * F - D ) * ( 2 * Math.PI ) / E ) * 0.5 + G + A;
	},
	backIn: function( B, A, E, D, C ) {
		if ( typeof C == "undefined" ) {
			C = 1.70158;
		}
		return E * ( B /= D ) * B * ( ( C + 1 ) * B - C ) + A;
	},
	backOut: function( B, A, E, D, C ) {
		if ( typeof C == "undefined" ) {
			C = 1.70158;
		}
		return E * ( ( B = B / D - 1 ) * B * ( ( C + 1 ) * B + C ) + 1 ) + A;
	},
	backBoth: function( B, A, E, D, C ) {
		if ( typeof C == "undefined" ) {
			C = 1.70158;
		}
		if ( ( B /= D / 2 ) < 1 ) {
			return E / 2 * ( B * B * ( ( ( C *= ( 1.525 ) ) + 1 ) * B - C ) ) + A;
		}
		return E / 2 * ( ( B -= 2 ) * B * ( ( ( C *= ( 1.525 ) ) + 1 ) * B + C ) + 2 ) + A;
	},
	bounceIn: function( B, A, D, C ) {
		return D - YAHOO.util.Easing.bounceOut( C - B, 0, D, C ) + A;
	},
	bounceOut: function( B, A, D, C ) {
		if ( ( B /= C ) < ( 1 / 2.75 ) ) {
			return D * ( 7.5625 * B * B ) + A;
		} else {
			if ( B < ( 2 / 2.75 ) ) {
				return D * ( 7.5625 * ( B -= ( 1.5 / 2.75 ) ) * B + 0.75 ) + A;
			} else {
				if ( B < ( 2.5 / 2.75 ) ) {
					return D * ( 7.5625 * ( B -= ( 2.25 / 2.75 ) ) * B + 0.9375 ) + A;
				}
			}
		}
		return D * ( 7.5625 * ( B -= ( 2.625 / 2.75 ) ) * B + 0.984375 ) + A;
	},
	bounceBoth: function( B, A, D, C ) {
		if ( B < C / 2 ) {
			return YAHOO.util.Easing.bounceIn( B * 2, 0, D, C ) * 0.5 + A;
		}
		return YAHOO.util.Easing.bounceOut( B * 2 - C, 0, D, C ) * 0.5 + D * 0.5 + A;
	} };
(function() {
	var A = function( H, G, I, J ) {
			if ( H ) {
				A.superclass.constructor.call( this, H, G, I, J );
			}
		};
	A.NAME = "Motion";
	var E = YAHOO.util;
	YAHOO.extend( A, E.ColorAnim );
	var F = A.superclass;
	var C = A.prototype;
	C.patterns.points = /^points$/i;
	C.setAttribute = function( G, I, H ) {
		if ( this.patterns.points.test( G ) ) {
			H = H || "px";
			F.setAttribute.call( this, "left", I[ 0 ], H );
			F.setAttribute.call( this, "top", I[ 1 ], H );
		} else {
			F.setAttribute.call( this, G, I, H );
		}
	};
	C.getAttribute = function( G ) {
		if ( this.patterns.points.test( G ) ) {
			var H = [ F.getAttribute.call( this, "left" ), F.getAttribute.call( this, "top" ) ];
		} else {
			H = F.getAttribute.call( this, G );
		}
		return H;
	};
	C.doMethod = function( G, K, H ) {
		var J = null;
		if ( this.patterns.points.test( G ) ) {
			var I = this.method( this.currentFrame, 0, 100, this.totalFrames ) / 100;
			J = E.Bezier.getPosition( this.runtimeAttributes[ G ], I );
		} else {
			J = F.doMethod.call( this, G, K, H );
		}
		return J;
	};
	C.setRuntimeAttribute = function( P ) {
		if ( this.patterns.points.test( P ) ) {
			var H = this.getEl();
			var J = this.attributes;
			var G;
			var L = J[ "points" ][ "control" ] || [];
			var I;
			var M, O;
			if ( L.length > 0 && !( L[ 0 ] instanceof Array ) ) {
				L = [ L ];
			} else {
				var K = [];
				for ( M = 0, O = L.length; M < O; ++M ) {
					K[ M ] = L[ M ];
				}
				L = K;
			}
			if ( E.Dom.getStyle( H, "position" ) == "static" ) {
				E.Dom.setStyle( H, "position", "relative" );
			}
			if ( D( J[ "points" ][ "from" ] ) ) {
				E.Dom.setXY( H, J[ "points" ][ "from" ] );
			} else {
				E.Dom.setXY( H, E.Dom.getXY( H ) );
			}
			G = this.getAttribute( "points" );
			if ( D( J[ "points" ][ "to" ] ) ) {
				I = B.call( this, J[ "points" ][ "to" ], G );
				var N = E.Dom.getXY( this.getEl() );
				for ( M = 0, O = L.length; M < O; ++M ) {
					L[ M ] = B.call( this, L[ M ], G );
				}
			} else {
				if ( D( J[ "points" ][ "by" ] ) ) {
					I = [ G[ 0 ] + J[ "points" ][ "by" ][ 0 ], G[ 1 ] + J[ "points" ][ "by" ][ 1 ] ];
					for ( M = 0, O = L.length; M < O; ++M ) {
						L[ M ] = [ G[ 0 ] + L[ M ][ 0 ], G[ 1 ] + L[ M ][ 1 ] ];
					}
				}
			}
			this.runtimeAttributes[ P ] = [ G ];
			if ( L.length > 0 ) {
				this.runtimeAttributes[ P ] = this.runtimeAttributes[ P ].concat( L );
			}
			this.runtimeAttributes[ P ][ this.runtimeAttributes[ P ].length ] = I;
		} else {
			F.setRuntimeAttribute.call( this, P );
		}
	};
	var B = function( G, I ) {
			var H = E.Dom.getXY( this.getEl() );
			G = [ G[ 0 ] - H[ 0 ] + I[ 0 ], G[ 1 ] - H[ 1 ] + I[ 1 ] ];
			return G;
		};
	var D = function( G ) {
			return ( typeof G !== "undefined" );
		};
	E.Motion = A;
})();
(function() {
	var D = function( F, E, G, H ) {
			if ( F ) {
				D.superclass.constructor.call( this, F, E, G, H );
			}
		};
	D.NAME = "Scroll";
	var B = YAHOO.util;
	YAHOO.extend( D, B.ColorAnim );
	var C = D.superclass;
	var A = D.prototype;
	A.doMethod = function( E, H, F ) {
		var G = null;
		if ( E == "scroll" ) {
			G = [ this.method( this.currentFrame, H[ 0 ], F[ 0 ] - H[ 0 ], this.totalFrames ), this.method( this.currentFrame, H[ 1 ], F[ 1 ] - H[ 1 ], this.totalFrames ) ];
		} else {
			G = C.doMethod.call( this, E, H, F );
		}
		return G;
	};
	A.getAttribute = function( E ) {
		var G = null;
		var F = this.getEl();
		if ( E == "scroll" ) {
			G = [ F.scrollLeft, F.scrollTop ];
		} else {
			G = C.getAttribute.call( this, E );
		}
		return G;
	};
	A.setAttribute = function( E, H, G ) {
		var F = this.getEl();
		if ( E == "scroll" ) {
			F.scrollLeft = H[ 0 ];
			F.scrollTop = H[ 1 ];
		} else {
			C.setAttribute.call( this, E, H, G );
		}
	};
	B.Scroll = D;
})();
YAHOO.register( "animation", YAHOO.util.Anim, { version: "2.7.0", build: "1799" } );

(function() {

    /*
     * Allows the editor to accept dropped text and generates corresponding attribution
     */
    CKEDITOR.plugins.add('cernacceptdrops', {
        init: function(editor) {
            var initTagging = function() {
                DDClipDragDrop.handleEditorDrop(editor);
                if (editor.config.isStandaloneSection) {
                    this.initWorkflowTagging(editor);
                }
            };
            editor.droppedHtml = undefined;
            editor.droppedEntityId = undefined;

            // maps the entity Id of a consumed tag to content type
            // used to keep track of consumed tags in workflow components
            editor.consumedTags = {};

            // register the editor
            DDClipDragDrop.registerEditor(editor);

            // unregister when the editor will be destroyed
            editor.on('destroy', function() {
                DDClipDragDrop.unregisterEditor(editor);
            });

            // make loaded clipboard contents draggable
            if (!editor.droppableInit && editor.config.isStandaloneSection) {
                // Initialize droppables that are inserted into the editor after note is loaded
                editor.on(DDCMD_CONTENTHTMLLOADED, function() {
                    DDClipDragDrop.destroyDroppables(editor);
                    DDClipDragDrop.handleEditorDrop(editor);
                });
            }

            if (!editor.droppableInit)
                editor.on('afterRestoreImage', DDClipDragDrop.handleEditorDrop.bind(undefined, editor));

            editor.on('contentDom', initTagging, this);
            if (editor.config.isStandaloneSection) {
                CERN_EventListener.addListener(document.body, 'preview-drag-event', function(e, eventData) {
                    editor.droppedHtml = eventData.previewHtml;
                    editor.droppedEntityId = eventData.entityId;
                    editor.droppedPromise = eventData.promiseHtml;
                    editor.contentType = eventData.contentType;
                }, this);

                CERN_EventListener.addListener(document.body, 'cancel-preview-drag', function() {
                    editor.droppedHtml = undefined;
                    editor.droppedEntityId = undefined;
                    editor.droppedPromise = undefined;
                    editor.contentType = undefined;
                }, this);

                DDClipDragDrop.handleTaggingEditorUndoRedo(editor);
                DDClipDragDrop.handleTagFootnotes(editor);

                // enable drop behavior for the editor
                editor.once('contentDom', DDClipDragDrop.initDropBehavior.bind(DDClipDragDrop, editor));

                editor.droppableInit = 1;
            }
        },

        generateAndAppendTag: function(targetElement, editor, droppedDetails) {
            DDClipDragDrop.dropTag(editor, droppedDetails.droppedEntityId, $("<span>").html(droppedDetails.droppedHtml), droppedDetails.droppedPromise,
                null, droppedDetails.contentType, function($ddtagged) {
                $ddtagged.attr('dd:entityid', droppedDetails.droppedEntityId);
                return DDClipDragDrop.FreetextDropCallbacks.insertIntoFreetext($ddtagged, editor, $(targetElement));
            });
        },

        initWorkflowTagging: function(editor) {
            var editable = editor.editable();
            var plugin = this;

            // check for already consumed tags and populate them into the consumedTags
            // assoc. array
            var tagList = $(editable.$).find('.ddtagged').each(function() {
                editor.consumedTags[$(this).attr('dd:entityid')] = $(this).attr('dd:contenttype');
            });

            $('.ddfreetext').on('mouseover', function() {
                $(document.body).css('cursor', 'copy, auto');
            });
            editable.attachListener(editable, 'drop', function(event) {
                event.data.$.preventDefault();
                if (editor.droppedHtml && editor.droppedEntityId) {
                    plugin.generateAndAppendTag($(event.data.$.target).closest('[contenteditable=true]')[0], editor, { droppedHtml:editor.droppedHtml, droppedEntityId:editor.droppedEntityId, droppedPromise:editor.droppedPromise,
                        droppedContentEntityId: $(this).attr('dd:entityid'), droppedContentType: $(this).attr('dd:contenttype')} );
                    // clear drag data
                    editor.droppedHtml = undefined;
                    editor.droppedEntityId = undefined;
                    editor.droppedPromise = undefined;
                    editor.contentType = undefined;
                    if(editor.config.isStandaloneSection){
                        // on mpages, signal that we have natively dropped text
                        CERN_EventListener.fireEvent(event, document.body, 'nativeDrop', null);
                    }
                }
            });
        }
    });

})();

/***************************************************************************
/ Description:   when tagged text is removed from a note, the tagged text are /
/                reordered, so that they are in numerical order from the top  /
/                of the note to the bottom.  Or in the case of the two-column /
/                view, from the top of the left column to the bottom of the   /
/                right column. Also corresponding reference numbers created   /
/                for the dropped text within the note are also reordered      /
/                accordingly.                                                 /
--------------   --------------------------------------------------------------
Mod Date         Engineer              Comment
--- --------     --------------------  ----------------------------------------
000 08/04        SR029785              Initial Release
******************************************************************************/

CKEDITOR.plugins.add('cerndyndoctag', {
    requires: 'onchange',

    removeModifiedAttribution: false,
    tagRefreshEvent : { refreshEvent: false },

    init: function (editor) {
        var noteLoaded = function () {
            if (typeof DDClipDragDrop !== 'undefined' && !DDClipDragDrop.checkForLegacyTags(editor)) {
                editor.on('change', _.debounce(this.checkDeletedTags.bind(this), 500), null, { removeModifiedAttribution: this.removeModifiedAttribution });
                editor.removeListener('contentDom', noteLoaded);
            }
        };
        editor.on('contentDom', noteLoaded, this);

        var moveSelectionOutside = function(editor, lastElement) {
            var sel = editor.getSelection();

            if (sel && !sel.isLocked && sel.getRanges().length > 0) {
                var range = sel.getRanges()[0];
                var start = range.startContainer.type === CKEDITOR.NODE_TEXT ? range.startContainer.getParent().$ : range.startContainer.$;
                var selectedElement = $(start).closest(".taggedtextnumber, .ddtagged");
                // Verify range is inside the span for footnote number
                if (start != null && typeof start != 'undefined' && range.collapsed == true && selectedElement.length > 0) {
                    // If we are at the boundary of a tag or tag text number, move the selection outside. Recurse as long as the selection keeps moving, this will avoid
                    // moving from the boundary of one element we are not accidentally leaving the selection on the boundary of another tag or attribution number.
                    if (DDCOMMON.moveRangeWhenAtBoundary(selectedElement[0], editor) && (!lastElement || lastElement.length === 0 || selectedElement[0] !== lastElement[0]))
                        moveSelectionOutside(editor, selectedElement);
                }
            }
        }

        /*
         * When we drop a tagged text onto a note and start entering text immediately
         * after footnote number, font size from footnote number is taken since the
         * text gets added to the footnote span. In order to avoid this, we move the
         * range outside of the ddtagged element in case range falls within footnote
         * number. For this purpose we handle the click and mouseup events and move the
         * range outside footnote number span.
         */

        editor.on('instanceReady', function (evt) {
            $(editor.editable().$).on('click', function () {
                moveSelectionOutside(editor);
            });

            $(editor.editable().$).on('keydown', function (event) {
                var keyCode = event.keyCode;
                if (keyCode === $.ui.keyCode.BACKSPACE || keyCode === $.ui.keyCode.DELETE || keyCode === $.ui.keyCode.RIGHT || keyCode === $.ui.keyCode.LEFT) {
                    return;
                }

                moveSelectionOutside(editor);
            });

            editor.on('beforerichcomboshow', function () {
                moveSelectionOutside(editor);
            });

            var restoreFootnoteSection = function (editor, refreshState) {
                if (refreshState === 'stable') {
                    var $editable = $(editor.editable().$);
                    $editable.find('.ddfootnotesection').show();
                    var $refreshingTag = $editable.find('.refreshingTags').remove();
                    $refreshingTag.remove();
                }
            }

            var hideFootnoteSection = function (editor, refreshState) {
                if (refreshState === 'refreshing') {
                    var $editable = $(editor.editable().$);
                    if ($editable.find('.refreshingTags').length > 0) {
                        return;
                    }

                    var $img = $('<img>').attr({
                        unselectable: 'on',
                        src: CKEDITOR.getUrl('images/loading.gif')
                    });
                    var $refreshFootnote = $('<div>')
                        .addClass('refreshingTags')
                        .append($img);

                    var $footnoteSection = DDClipDragDrop.createFootnoteSection(editor);
                    $footnoteSection.hide();
                    $refreshFootnote.insertAfter($footnoteSection);
                }
            }

            // Restore editor after refresh. Priority is set higher than default so that this is called later than other handlers,
            // obscuring the tags for as long as possible in order to avoid displaying footnote reordering
            editor.on('refreshStateChange', function (event) {
                restoreFootnoteSection(event.editor, event.editor.refreshState);
                hideFootnoteSection(event.editor, event.editor.refreshState);
            }, null, null, 500);

            // Restore a hidden footnote section after undo/redo
            editor.on('afterRestoreImage', function (event) {
                DDClipDragDrop.reorderFootnotes(editor);
                restoreFootnoteSection(event.editor, event.editor.refreshState);
            });

        });
        var DocUtilsHelper = window.DocUtilsHelper || CKEDITOR.DocUtilsHelper;

        if (typeof DocUtilsHelper.ShouldRemoveAlteredTag !== 'undefined') {
            this.removeModifiedAttribution = DocUtilsHelper.ShouldRemoveAlteredTag();
        }
        else if (typeof DynDocHelper !== 'undefined' && typeof DynDocHelper.ShouldRemoveAlteredTag !== 'undefined') {
            this.removeModifiedAttribution = DynDocHelper.ShouldRemoveAlteredTag();
        }
        else if (typeof DynDocDlgReusableConsumerCallBack !== 'undefined' && typeof DynDocDlgReusableConsumerCallBack.ShouldRemoveAlteredTag !== 'undefined') {
            this.removeModifiedAttribution = DynDocDlgReusableConsumerCallBack.ShouldRemoveAlteredTag();
        }
    },

    checkDeletedTags: function (event) {
        var editor = event.editor;
        DDCOMMON.waitForRefreshStable(editor, this.tagRefreshEvent, function () {

            // filter the dropped tagtext such that hasContent will remove any tagtext which has no content
            var hasContent = function () { return $.trim(this.innerText) !== '' };
            var $ddtagged = $(editor.editable().$).find('.ddtagged:not(.ddfootnotesection .ddtagged)').filter(hasContent);

            // Remove class '.ddtagged' from empty content
            var hasNoContent = function () { return $.trim(this.innerText) == '' };
            $(editor.editable().$).find('.ddtagged:not(.ddfootnotesection .ddtagged)').filter(hasNoContent).removeClass('ddtagged');

            // Map tags by their footnote IDs
            var taggedHash = {};
            $ddtagged.each(function () {

                var footnoteId = $(this).attr('dd:footnoteid');
                if (footnoteId) {
                    taggedHash[footnoteId] = this;
                }
            });

            // Removing the footnotes for the corresponding deleted dropped tagtext
            var $footnotes = $(editor.editable().$).find('.ddfootnoteitem');
            var footnoteRemovedCnt = 0;
            var footnoteHash = {};
            $footnotes.each(function () {
                var footnoteId = $(this).find('.ddemrcontent').attr('id');

                // If this footnote cannot be matched back to a tag, remove it
                if (!footnoteId || !taggedHash[footnoteId]) {
                    $(this).remove();
                    footnoteRemovedCnt++;
                    return;
                }

                footnoteHash[footnoteId] = this;
            });

            $ddtagged.each(function () {
                // Don't attempt to delete the annotations of signed tags
                if ($(this).closest('.ddcontribution').attr('ddactive') === 'false')
                    return;

                // If tag exists but text has been changed, untag and remove footnote
                if (event.listenerData.removeModifiedAttribution && $(this).attr('orig-text') !== DDClipDragDrop.extractTextValue(DDClipDragDrop.retrieveUnstruckText(this))) {

                    var footnoteId = $(this).attr('dd:footnoteid');

                    $ddtagged.filter('[dd\\:footnoteid=' + footnoteId + ']').each(function () {
                        $(this).find('.taggedtextnumber').remove();
                        $(this).removeClass('ddtagged');
                        $(this).removeAttr('dd:footnotetext');
                        $(this).removeAttr('orig-text');
                        $(this).removeAttr('dd:footnoteid');

                        if (footnoteHash[footnoteId]) {
                            $(footnoteHash[footnoteId]).remove();
                        }
                        footnoteRemovedCnt++;
                    });
                }
            });

            // Updating the snapshot and reordering the tagtext and footnotes iff footnote is removed
            if (footnoteRemovedCnt > 0) {
                editor.fire('updateSnapshot');
                DDClipDragDrop.reorderFootnotes(editor);
            }
        }, 50);
    }
});    // End plugin.add

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

(function() {
	// Base HTML entities.
	var htmlbase = 'nbsp,gt,lt,amp';

	var entities =
	// Latin-1 Entities
	'quot,iexcl,cent,pound,curren,yen,brvbar,sect,uml,copy,ordf,laquo,' +
		'not,shy,reg,macr,deg,plusmn,sup2,sup3,acute,micro,para,middot,' +
		'cedil,sup1,ordm,raquo,frac14,frac12,frac34,iquest,times,divide,' +

		// Symbols
		'fnof,bull,hellip,prime,Prime,oline,frasl,weierp,image,real,trade,' +
		'alefsym,larr,uarr,rarr,darr,harr,crarr,lArr,uArr,rArr,dArr,hArr,' +
		'forall,part,exist,empty,nabla,isin,notin,ni,prod,sum,minus,lowast,' +
		'radic,prop,infin,ang,and,or,cap,cup,int,there4,sim,cong,asymp,ne,' +
		'equiv,le,ge,sub,sup,nsub,sube,supe,oplus,otimes,perp,sdot,lceil,' +
		'rceil,lfloor,rfloor,lang,rang,loz,spades,clubs,hearts,diams,' +

		// Other Special Characters
		'circ,tilde,ensp,emsp,thinsp,zwnj,zwj,lrm,rlm,ndash,mdash,lsquo,' +
		'rsquo,sbquo,ldquo,rdquo,bdquo,dagger,Dagger,permil,lsaquo,rsaquo,' +
		'euro';

	// Latin Letters Entities
	var latin = 'Agrave,Aacute,Acirc,Atilde,Auml,Aring,AElig,Ccedil,Egrave,Eacute,' +
		'Ecirc,Euml,Igrave,Iacute,Icirc,Iuml,ETH,Ntilde,Ograve,Oacute,Ocirc,' +
		'Otilde,Ouml,Oslash,Ugrave,Uacute,Ucirc,Uuml,Yacute,THORN,szlig,' +
		'agrave,aacute,acirc,atilde,auml,aring,aelig,ccedil,egrave,eacute,' +
		'ecirc,euml,igrave,iacute,icirc,iuml,eth,ntilde,ograve,oacute,ocirc,' +
		'otilde,ouml,oslash,ugrave,uacute,ucirc,uuml,yacute,thorn,yuml,' +
		'OElig,oelig,Scaron,scaron,Yuml';

	// Greek Letters Entities.
	var greek = 'Alpha,Beta,Gamma,Delta,Epsilon,Zeta,Eta,Theta,Iota,Kappa,Lambda,Mu,' +
		'Nu,Xi,Omicron,Pi,Rho,Sigma,Tau,Upsilon,Phi,Chi,Psi,Omega,alpha,' +
		'beta,gamma,delta,epsilon,zeta,eta,theta,iota,kappa,lambda,mu,nu,xi,' +
		'omicron,pi,rho,sigmaf,sigma,tau,upsilon,phi,chi,psi,omega,thetasym,' +
		'upsih,piv';

	// Create a mapping table between one character and its entity form from a list of entity names.
	// @param reverse {Boolean} Whether to create a reverse map from the entity string form to an actual character.
	function buildTable( entities, reverse ) {
		var table = {},
			regex = [];

		// Entities that the browsers DOM don't transform to the final char
		// automatically.
		var specialTable = {
			nbsp: '\u00A0', // IE | FF
			shy: '\u00AD', // IE
			gt: '\u003E', // IE | FF |   --   | Opera
			lt: '\u003C', // IE | FF | Safari | Opera
			amp: '\u0026', // ALL
			apos: '\u0027', // IE
			quot: '\u0022' // IE
		};

		entities = entities.replace( /\b(nbsp|shy|gt|lt|amp|apos|quot)(?:,|$)/g, function( match, entity ) {
			var org = reverse ? '&' + entity + ';' : specialTable[ entity ],
				result = reverse ? specialTable[ entity ] : '&' + entity + ';';

			table[ org ] = result;
			regex.push( org );
			return '';
		});

		if ( !reverse && entities ) {
			// Transforms the entities string into an array.
			entities = entities.split( ',' );

			// Put all entities inside a DOM element, transforming them to their
			// final chars.
			var div = document.createElement( 'div' ),
				chars;
			div.innerHTML = '&' + entities.join( ';&' ) + ';';
			chars = div.innerHTML;
			div = null;

			// Add all chars to the table.
			for ( var i = 0; i < chars.length; i++ ) {
				var charAt = chars.charAt( i );
				table[ charAt ] = '&' + entities[ i ] + ';';
				regex.push( charAt );
			}
		}

		table.regex = regex.join( reverse ? '|' : '' );

		return table;
	}

	CKEDITOR.plugins.add( 'entities', {
		afterInit: function( editor ) {
			var config = editor.config;

			var dataProcessor = editor.dataProcessor,
				htmlFilter = dataProcessor && dataProcessor.htmlFilter;

			if ( htmlFilter ) {
				// Mandatory HTML base entities.
				var selectedEntities = [];

				if ( config.basicEntities !== false )
					selectedEntities.push( htmlbase );

				if ( config.entities ) {
					if ( selectedEntities.length )
						selectedEntities.push( entities );

					if ( config.entities_latin )
						selectedEntities.push( latin );

					if ( config.entities_greek )
						selectedEntities.push( greek );

					if ( config.entities_additional )
						selectedEntities.push( config.entities_additional );
				}

				var entitiesTable = buildTable( selectedEntities.join( ',' ) );

				// Create the Regex used to find entities in the text, leave it matches nothing if entities are empty.
				var entitiesRegex = entitiesTable.regex ? '[' + entitiesTable.regex + ']' : 'a^';
				delete entitiesTable.regex;

				if ( config.entities && config.entities_processNumerical )
					entitiesRegex = '[^ -~]|' + entitiesRegex;

				entitiesRegex = new RegExp( entitiesRegex, 'g' );

				function getEntity( character ) {
					return config.entities_processNumerical == 'force' || !entitiesTable[ character ] ? '&#' + character.charCodeAt( 0 ) + ';'
						: entitiesTable[ character ];
				}

				// Decode entities that the browsers has transformed
				// at first place.
				var baseEntitiesTable = buildTable( [ htmlbase, 'shy' ].join( ',' ), true ),
					baseEntitiesRegex = new RegExp( baseEntitiesTable.regex, 'g' );

				function getChar( character ) {
					return baseEntitiesTable[ character ];
				}

				htmlFilter.addRules({
					text: function( text ) {
						return text.replace( baseEntitiesRegex, getChar ).replace( entitiesRegex, getEntity );
					}
				});
			}
		}
	});
})();

/**
 * Whether to escape basic HTML entities in the document, including:
 *
 * * `nbsp`
 * * `gt`
 * * `lt`
 * * `amp`
 *
 * **Note:** It should not be subject to change unless when outputting a non-HTML data format like BBCode.
 *
 *		config.basicEntities = false;
 *
 * @cfg {Boolean} [basicEntities=true]
 * @member CKEDITOR.config
 */
CKEDITOR.config.basicEntities = true;

/**
 * Whether to use HTML entities in the output.
 *
 *		config.entities = false;
 *
 * @cfg {Boolean} [entities=true]
 * @member CKEDITOR.config
 */
CKEDITOR.config.entities = true;

/**
 * Whether to convert some Latin characters (Latin alphabet No. 1, ISO 8859-1)
 * to HTML entities. The list of entities can be found in the
 * [W3C HTML 4.01 Specification, section 24.2.1](http://www.w3.org/TR/html4/sgml/entities.html#h-24.2.1).
 *
 *		config.entities_latin = false;
 *
 * @cfg {Boolean} [entities_latin=true]
 * @member CKEDITOR.config
 */
CKEDITOR.config.entities_latin = true;

/**
 * Whether to convert some symbols, mathematical symbols, and Greek letters to
 * HTML entities. This may be more relevant for users typing text written in Greek.
 * The list of entities can be found in the
 * [W3C HTML 4.01 Specification, section 24.3.1(http://www.w3.org/TR/html4/sgml/entities.html#h-24.3.1).
 *
 *		config.entities_greek = false;
 *
 * @cfg {Boolean} [entities_greek=true]
 * @member CKEDITOR.config
 */
CKEDITOR.config.entities_greek = true;

/**
 * Whether to convert all remaining characters not included in the ASCII
 * character table to their relative decimal numeric representation of HTML entity.
 * When set to `force`, it will convert all entities into this format.
 *
 * For example the phrase `'This is Chinese: .'` is output
 * as `'This is Chinese: &#27721;&#35821;.'`
 *
 *		config.entities_processNumerical = true;
 *		config.entities_processNumerical = 'force'; // Converts from '&nbsp;' into '&#160;';
 *
 * @cfg {Boolean/String} [entities_processNumerical=false]
 * @member CKEDITOR.config
 */

/**
 * A comma separated list of  additional entities to be used. Entity names
 * or numbers must be used in a form that excludes the `'&amp;'` prefix and the `';'` ending.
 *
 *		config.entities_additional = '#1049'; // Adds Cyrillic capital letter Short I ().
 *
 * @cfg {String} [entities_additional='#39' (The single quote (') character)]
 * @member CKEDITOR.config
 */
CKEDITOR.config.entities_additional = '#39';

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( 'popup' );

CKEDITOR.tools.extend( CKEDITOR.editor.prototype, {
	/**
	 * Opens Browser in a popup. The `width` and `height` parameters accept
	 * numbers (pixels) or percent (of screen size) values.
	 *
	 * @member CKEDITOR.editor
	 * @param {String} url The url of the external file browser.
	 * @param {Number/String} [width='80%'] Popup window width.
	 * @param {Number/String} [height='70%'] Popup window height.
	 * @param {String} [options='location=no,menubar=no,toolbar=no,dependent=yes,minimizable=no,modal=yes,alwaysRaised=yes,resizable=yes,scrollbars=yes']
	 * Popup window features.
	 */
	popup: function( url, width, height, options ) {
		width = width || '80%';
		height = height || '70%';

		if ( typeof width == 'string' && width.length > 1 && width.substr( width.length - 1, 1 ) == '%' )
			width = parseInt( window.screen.width * parseInt( width, 10 ) / 100, 10 );

		if ( typeof height == 'string' && height.length > 1 && height.substr( height.length - 1, 1 ) == '%' )
			height = parseInt( window.screen.height * parseInt( height, 10 ) / 100, 10 );

		if ( width < 640 )
			width = 640;

		if ( height < 420 )
			height = 420;

		var top = parseInt( ( window.screen.height - height ) / 2, 10 ),
			left = parseInt( ( window.screen.width - width ) / 2, 10 );

		options = ( options || 'location=no,menubar=no,toolbar=no,dependent=yes,minimizable=no,modal=yes,alwaysRaised=yes,resizable=yes,scrollbars=yes' ) + ',width=' + width +
			',height=' + height +
			',top=' + top +
			',left=' + left;

		var popupWindow = window.open( '', null, options, true );

		// Blocked by a popup blocker.
		if ( !popupWindow )
			return false;

		try {
			// Chrome is problematic with moveTo/resizeTo, but it's not really needed here (#8855).
			var ua = navigator.userAgent.toLowerCase();
			if ( ua.indexOf( ' chrome/' ) == -1 ) {
				popupWindow.moveTo( left, top );
				popupWindow.resizeTo( width, height );
			}
			popupWindow.focus();
			popupWindow.location.href = url;
		} catch ( e ) {
			popupWindow = window.open( url, null, options, true );
		}

		return true;
	}
});

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview Increse and decrease indent commands.
 */

(function() {
	var listNodeNames = { ol:1,ul:1 },
		isNotWhitespaces = CKEDITOR.dom.walker.whitespaces( true ),
		isNotBookmark = CKEDITOR.dom.walker.bookmark( false, true );

	function indentCommand( editor, name ) {
		this.name = name;
		var useClasses = this.useIndentClasses = editor.config.indentClasses && editor.config.indentClasses.length > 0;
		if ( useClasses ) {
			this.classNameRegex = new RegExp( '(?:^|\\s+)(' + editor.config.indentClasses.join( '|' ) + ')(?=$|\\s)' );
			this.indentClassMap = {};
			for ( var i = 0; i < editor.config.indentClasses.length; i++ )
				this.indentClassMap[ editor.config.indentClasses[ i ] ] = i + 1;
		}

		this.startDisabled = name == 'outdent';

		this.allowedContent = {
			'div h1 h2 h3 h4 h5 h6 ol p pre ul': {
				// Do not add elements, but only text-align style if element is validated by other rule.
				propertiesOnly: true,
				styles: !useClasses ? 'margin-left,margin-right' : null,
				classes: useClasses ? editor.config.indentClasses : null
			}
		};

		// #10192: Either blocks intendation or lists are required - acitvate
		// indent commands in both situations. Lists are sufficient, because
		// indent is needed for leaving list with enter key.
		this.requiredContent = [
			'p' + ( useClasses ? '(' + editor.config.indentClasses[ 0 ] + ')' : '{margin-left}' ),
			'li'
		];
	}

	// Returns the CSS property to be used for identing a given element.
	function getIndentCssProperty( element, dir ) {
		return ( dir || element.getComputedStyle( 'direction' ) ) == 'ltr' ? 'margin-left' : 'margin-right';
	}

	function isListItem( node ) {
		return node.type == CKEDITOR.NODE_ELEMENT && node.is( 'li' );
	}

	indentCommand.prototype = {
		// It applies to a "block-like" context.
		context: 'p',

		refresh: function( editor, path ) {
			var list = path && path.contains( listNodeNames ),
				firstBlock = path.block || path.blockLimit;

			if ( list )
				this.setState( CKEDITOR.TRISTATE_OFF );

			else if ( !this.useIndentClasses && this.name == 'indent' )
				this.setState( CKEDITOR.TRISTATE_OFF );

			else if ( !firstBlock )
				this.setState( CKEDITOR.TRISTATE_DISABLED );

			else if ( this.useIndentClasses ) {
				var indentClass = firstBlock.$.className.match( this.classNameRegex ),
					indentStep = 0;

				if ( indentClass ) {
					indentClass = indentClass[ 1 ];
					indentStep = this.indentClassMap[ indentClass ];
				}

				if ( ( this.name == 'outdent' && !indentStep ) || ( this.name == 'indent' && indentStep == editor.config.indentClasses.length ) )
					this.setState( CKEDITOR.TRISTATE_DISABLED );
				else
					this.setState( CKEDITOR.TRISTATE_OFF );
			} else {
				var indent = parseInt( firstBlock.getStyle( getIndentCssProperty( firstBlock ) ), 10 );
				if ( isNaN( indent ) )
					indent = 0;
				if ( indent <= 0 )
					this.setState( CKEDITOR.TRISTATE_DISABLED );
				else
					this.setState( CKEDITOR.TRISTATE_OFF );
			}
		},
		exec: function( editor ) {
			var self = this,
				database = {};

			function indentList( listNode ) {
				// Our starting and ending points of the range might be inside some blocks under a list item...
				// So before playing with the iterator, we need to expand the block to include the list items.
				var startContainer = range.startContainer,
					endContainer = range.endContainer;
				while ( startContainer && !startContainer.getParent().equals( listNode ) )
					startContainer = startContainer.getParent();
				while ( endContainer && !endContainer.getParent().equals( listNode ) )
					endContainer = endContainer.getParent();

				if ( !startContainer || !endContainer )
					return;

				// Now we can iterate over the individual items on the same tree depth.
				var block = startContainer,
					itemsToMove = [],
					stopFlag = false;
				while ( !stopFlag ) {
					if ( block.equals( endContainer ) )
						stopFlag = true;
					itemsToMove.push( block );
					block = block.getNext();
				}
				if ( itemsToMove.length < 1 )
					return;

				// Do indent or outdent operations on the array model of the list, not the
				// list's DOM tree itself. The array model demands that it knows as much as
				// possible about the surrounding lists, we need to feed it the further
				// ancestor node that is still a list.
				var listParents = listNode.getParents( true );
				for ( var i = 0; i < listParents.length; i++ ) {
					if ( listParents[ i ].getName && listNodeNames[ listParents[ i ].getName() ] ) {
						listNode = listParents[ i ];
						break;
					}
				}
				var indentOffset = self.name == 'indent' ? 1 : -1,
					startItem = itemsToMove[ 0 ],
					lastItem = itemsToMove[ itemsToMove.length - 1 ];

				// Convert the list DOM tree into a one dimensional array.
				var listArray = CKEDITOR.plugins.list.listToArray( listNode, database );

				// Apply indenting or outdenting on the array.
				var baseIndent = listArray[ lastItem.getCustomData( 'listarray_index' ) ].indent;
				for ( i = startItem.getCustomData( 'listarray_index' ); i <= lastItem.getCustomData( 'listarray_index' ); i++ ) {
					listArray[ i ].indent += indentOffset;
					// Make sure the newly created sublist get a brand-new element of the same type. (#5372)
					if ( indentOffset > 0 ) {
						var listRoot = listArray[ i ].parent;
						listArray[ i ].parent = new CKEDITOR.dom.element( listRoot.getName(), listRoot.getDocument() );
					}
				}

				for ( i = lastItem.getCustomData( 'listarray_index' ) + 1;
				i < listArray.length && listArray[ i ].indent > baseIndent; i++ )
					listArray[ i ].indent += indentOffset;

				// Convert the array back to a DOM forest (yes we might have a few subtrees now).
				// And replace the old list with the new forest.
				var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode, listNode.getDirection() );

				// Avoid nested <li> after outdent even they're visually same,
				// recording them for later refactoring.(#3982)
				if ( self.name == 'outdent' ) {
					var parentLiElement;
					if ( ( parentLiElement = listNode.getParent() ) && parentLiElement.is( 'li' ) ) {
						var children = newList.listNode.getChildren(),
							pendingLis = [],
							count = children.count(),
							child;

						for ( i = count - 1; i >= 0; i-- ) {
							if ( ( child = children.getItem( i ) ) && child.is && child.is( 'li' ) )
								pendingLis.push( child );
						}
					}
				}

				if ( newList )
					newList.listNode.replace( listNode );

				// Move the nested <li> to be appeared after the parent.
				if ( pendingLis && pendingLis.length ) {
					for ( i = 0; i < pendingLis.length; i++ ) {
						var li = pendingLis[ i ],
							followingList = li;

						// Nest preceding <ul>/<ol> inside current <li> if any.
						while ( ( followingList = followingList.getNext() ) && followingList.is && followingList.getName() in listNodeNames ) {
							// IE requires a filler NBSP for nested list inside empty list item,
							// otherwise the list item will be inaccessiable. (#4476)
							if ( CKEDITOR.env.ie && !li.getFirst( function( node ) {
								return isNotWhitespaces( node ) && isNotBookmark( node );
							}))
								li.append( range.document.createText( '\u00a0' ) );

							li.append( followingList );
						}

						li.insertAfter( parentLiElement );
					}
				}
			}

			function indentBlock() {
				var iterator = range.createIterator(),
					enterMode = editor.config.enterMode;
				iterator.enforceRealBlocks = true;
				iterator.enlargeBr = enterMode != CKEDITOR.ENTER_BR;
				var block;
				while ( ( block = iterator.getNextParagraph( enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' ) ) )
					indentElement( block );
			}

			function indentElement( element, dir ) {
				if ( element.getCustomData( 'indent_processed' ) )
					return false;

				if ( self.useIndentClasses ) {
					// Transform current class name to indent step index.
					var indentClass = element.$.className.match( self.classNameRegex ),
						indentStep = 0;
					if ( indentClass ) {
						indentClass = indentClass[ 1 ];
						indentStep = self.indentClassMap[ indentClass ];
					}

					// Operate on indent step index, transform indent step index back to class
					// name.
					if ( self.name == 'outdent' )
						indentStep--;
					else
						indentStep++;

					if ( indentStep < 0 )
						return false;

					indentStep = Math.min( indentStep, editor.config.indentClasses.length );
					indentStep = Math.max( indentStep, 0 );
					element.$.className = CKEDITOR.tools.ltrim( element.$.className.replace( self.classNameRegex, '' ) );
					if ( indentStep > 0 )
						element.addClass( editor.config.indentClasses[ indentStep - 1 ] );
				} else {
					var indentCssProperty = getIndentCssProperty( element, dir ),
						currentOffset = parseInt( element.getStyle( indentCssProperty ), 10 );
					if ( isNaN( currentOffset ) )
						currentOffset = 0;
					var indentOffset = editor.config.indentOffset || 40;
					currentOffset += ( self.name == 'indent' ? 1 : -1 ) * indentOffset;

					if ( currentOffset < 0 )
						return false;

					currentOffset = Math.max( currentOffset, 0 );
					currentOffset = Math.ceil( currentOffset / indentOffset ) * indentOffset;
					element.setStyle( indentCssProperty, currentOffset ? currentOffset + ( editor.config.indentUnit || 'px' ) : '' );
					if ( element.getAttribute( 'style' ) === '' )
						element.removeAttribute( 'style' );
				}

				CKEDITOR.dom.element.setMarker( database, element, 'indent_processed', 1 );
				return true;
			}

			var selection = editor.getSelection(),
				bookmarks = selection.createBookmarks( 1 ),
				ranges = selection && selection.getRanges( 1 ),
				range;


			var iterator = ranges.createIterator();
			while ( ( range = iterator.getNextRange() ) ) {
				var rangeRoot = range.getCommonAncestor(),
					nearestListBlock = rangeRoot;

				while ( nearestListBlock && !( nearestListBlock.type == CKEDITOR.NODE_ELEMENT && listNodeNames[ nearestListBlock.getName() ] ) )
					nearestListBlock = nearestListBlock.getParent();

				// Avoid having selection enclose the entire list. (#6138)
				// [<ul><li>...</li></ul>] =><ul><li>[...]</li></ul>
				if ( !nearestListBlock ) {
					var selectedNode = range.getEnclosedNode();
					if ( selectedNode && selectedNode.type == CKEDITOR.NODE_ELEMENT && selectedNode.getName() in listNodeNames ) {
						range.setStartAt( selectedNode, CKEDITOR.POSITION_AFTER_START );
						range.setEndAt( selectedNode, CKEDITOR.POSITION_BEFORE_END );
						nearestListBlock = selectedNode;
					}
				}

				// Avoid selection anchors under list root.
				// <ul>[<li>...</li>]</ul> =>	<ul><li>[...]</li></ul>
				if ( nearestListBlock && range.startContainer.type == CKEDITOR.NODE_ELEMENT && range.startContainer.getName() in listNodeNames ) {
					var walker = new CKEDITOR.dom.walker( range );
					walker.evaluator = isListItem;
					range.startContainer = walker.next();
				}

				if ( nearestListBlock && range.endContainer.type == CKEDITOR.NODE_ELEMENT && range.endContainer.getName() in listNodeNames ) {
					walker = new CKEDITOR.dom.walker( range );
					walker.evaluator = isListItem;
					range.endContainer = walker.previous();
				}

				if ( nearestListBlock ) {
					var firstListItem = nearestListBlock.getFirst( isListItem ),
						hasMultipleItems = !!firstListItem.getNext( isListItem ),
						rangeStart = range.startContainer,
						indentWholeList = firstListItem.equals( rangeStart ) || firstListItem.contains( rangeStart );

					// Indent the entire list if cursor is inside the first list item. (#3893)
					// Only do that for indenting or when using indent classes or when there is something to outdent. (#6141)
					if ( !( indentWholeList && ( self.name == 'indent' || self.useIndentClasses || parseInt( nearestListBlock.getStyle( getIndentCssProperty( nearestListBlock ) ), 10 ) ) && indentElement( nearestListBlock, !hasMultipleItems && firstListItem.getDirection() ) ) )
						indentList( nearestListBlock );
				} else
					indentBlock();
			}

			// Clean up the markers.
			CKEDITOR.dom.element.clearAllMarkers( database );

			editor.forceNextSelectionCheck();
			selection.selectBookmarks( bookmarks );
		}
	};

	CKEDITOR.plugins.add( 'indent', {
		// TODO: Remove this dependency.
		requires: 'list',
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		icons: 'indent,indent-rtl,outdent,outdent-rtl', // %REMOVE_LINE_CORE%
		onLoad: function() {
			// [IE6/7] Raw lists are using margin instead of padding for visual indentation in wysiwyg mode. (#3893)
			if ( CKEDITOR.env.ie6Compat || CKEDITOR.env.ie7Compat ) {
				CKEDITOR.addCss( ".cke_editable ul," +
					".cke_editable ol" +
					"{" +
					"	margin-left: 0px;" +
					"	padding-left: 40px;" +
					"}" );
			}
		},
		init: function( editor ) {
			if ( editor.blockless )
				return;

			// Register commands.
			var indent = editor.addCommand( 'indent', new indentCommand( editor, 'indent' ) ),
				outdent = editor.addCommand( 'outdent', new indentCommand( editor, 'outdent' ) );

			if ( editor.ui.addButton ) {
				// Register the toolbar buttons.
				editor.ui.addButton( 'Indent', {
					label: editor.lang.indent.indent,
					command: 'indent',
					directional: true,
					toolbar: 'indent,20'
				});
				editor.ui.addButton( 'Outdent', {
					label: editor.lang.indent.outdent,
					command: 'outdent',
					directional: true,
					toolbar: 'indent,10'
				});
			}

			// Register dirChanged listener.
			editor.on( 'dirChanged', function( e ) {
				var range = editor.createRange();
				range.setStartBefore( e.data.node );
				range.setEndAfter( e.data.node );

				var walker = new CKEDITOR.dom.walker( range ),
					node;

				while ( ( node = walker.next() ) ) {
					if ( node.type == CKEDITOR.NODE_ELEMENT ) {
						// A child with the defined dir is to be ignored.
						if ( !node.equals( e.data.node ) && node.getDirection() ) {
							range.setStartAfter( node );
							walker = new CKEDITOR.dom.walker( range );
							continue;
						}

						// Switch alignment classes.
						var classes = editor.config.indentClasses;
						if ( classes ) {
							var suffix = ( e.data.dir == 'ltr' ) ? [ '_rtl', '' ] : [ '', '_rtl' ];
							for ( var i = 0; i < classes.length; i++ ) {
								if ( node.hasClass( classes[ i ] + suffix[ 0 ] ) ) {
									node.removeClass( classes[ i ] + suffix[ 0 ] );
									node.addClass( classes[ i ] + suffix[ 1 ] );
								}
							}
						}

						// Switch the margins.
						var marginLeft = node.getStyle( 'margin-right' ),
							marginRight = node.getStyle( 'margin-left' );

						marginLeft ? node.setStyle( 'margin-left', marginLeft ) : node.removeStyle( 'margin-left' );
						marginRight ? node.setStyle( 'margin-right', marginRight ) : node.removeStyle( 'margin-right' );
					}
				}
			});
		}
	});
})();

/**
 * Size of each indentation step.
 *
 *		config.indentOffset = 4;
 *
 * @cfg {Number} [indentOffset=40]
 * @member CKEDITOR.config
 */

/**
 * Unit for the indentation style.
 *
 *		config.indentUnit = 'em';
 *
 * @cfg {String} [indentUnit='px']
 * @member CKEDITOR.config
 */

/**
 * List of classes to use for indenting the contents. If it's `null`, no classes will be used
 * and instead the {@link #indentUnit} and {@link #indentOffset} properties will be used.
 *
 *		// Use the classes 'Indent1', 'Indent2', 'Indent3'
 *		config.indentClasses = ['Indent1', 'Indent2', 'Indent3'];
 *
 * @cfg {Array} [indentClasses=null]
 * @member CKEDITOR.config
 */

/**
 * @license Copyright (c) 2003-2013, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.html or http://ckeditor.com/license
 */

/**
 * @fileOverview Insert and remove numbered and bulleted lists.
 */

(function() {
	var listNodeNames = { ol:1,ul:1 },
		emptyTextRegex = /^[\n\r\t ]*$/;

	var whitespaces = CKEDITOR.dom.walker.whitespaces(),
		bookmarks = CKEDITOR.dom.walker.bookmark(),
		nonEmpty = function( node ) {
			return !( whitespaces( node ) || bookmarks( node ) );
		},
		blockBogus = CKEDITOR.dom.walker.bogus();

	function cleanUpDirection( element ) {
		var dir, parent, parentDir;
		if ( ( dir = element.getDirection() ) ) {
			parent = element.getParent();
			while ( parent && !( parentDir = parent.getDirection() ) )
				parent = parent.getParent();

			if ( dir == parentDir )
				element.removeAttribute( 'dir' );
		}
	}

	// Inheirt inline styles from another element.
	function inheirtInlineStyles( parent, el ) {
		var style = parent.getAttribute( 'style' );

		// Put parent styles before child styles.
		style && el.setAttribute( 'style', style.replace( /([^;])$/, '$1;' ) + ( el.getAttribute( 'style' ) || '' ) );
	}

	CKEDITOR.plugins.list = {
		/**
		 * Convert a DOM list tree into a data structure that is easier to
		 * manipulate. This operation should be non-intrusive in the sense that it
		 * does not change the DOM tree, with the exception that it may add some
		 * markers to the list item nodes when database is specified.
		 *
		 * @member CKEDITOR.plugins.list
		 * @todo params
		 */
		listToArray: function( listNode, database, baseArray, baseIndentLevel, grandparentNode ) {
			if ( !listNodeNames[ listNode.getName() ] )
				return [];

			if ( !baseIndentLevel )
				baseIndentLevel = 0;
			if ( !baseArray )
				baseArray = [];

			// Iterate over all list items to and look for inner lists.
			for ( var i = 0, count = listNode.getChildCount(); i < count; i++ ) {
				var listItem = listNode.getChild( i );

				// Fixing malformed nested lists by moving it into a previous list item. (#6236)
				if ( listItem.type == CKEDITOR.NODE_ELEMENT && listItem.getName() in CKEDITOR.dtd.$list )
					CKEDITOR.plugins.list.listToArray( listItem, database, baseArray, baseIndentLevel + 1 );

				// It may be a text node or some funny stuff.
				if ( listItem.$.nodeName.toLowerCase() != 'li' )
					continue;

				var itemObj = { 'parent': listNode, indent: baseIndentLevel, element: listItem, contents: [] };
				if ( !grandparentNode ) {
					itemObj.grandparent = listNode.getParent();
					if ( itemObj.grandparent && itemObj.grandparent.$.nodeName.toLowerCase() == 'li' )
						itemObj.grandparent = itemObj.grandparent.getParent();
				} else
					itemObj.grandparent = grandparentNode;

				if ( database )
					CKEDITOR.dom.element.setMarker( database, listItem, 'listarray_index', baseArray.length );
				baseArray.push( itemObj );

				for ( var j = 0, itemChildCount = listItem.getChildCount(), child; j < itemChildCount; j++ ) {
					child = listItem.getChild( j );
					if ( child.type == CKEDITOR.NODE_ELEMENT && listNodeNames[ child.getName() ] )
					// Note the recursion here, it pushes inner list items with
					// +1 indentation in the correct order.
					CKEDITOR.plugins.list.listToArray( child, database, baseArray, baseIndentLevel + 1, itemObj.grandparent );
					else
						itemObj.contents.push( child );
				}
			}
			return baseArray;
		},

		/**
		 * Convert our internal representation of a list back to a DOM forest.
		 *
		 * @member CKEDITOR.plugins.list
		 * @todo params
		 */
		arrayToList: function( listArray, database, baseIndex, paragraphMode, dir ) {
			if ( !baseIndex )
				baseIndex = 0;
			if ( !listArray || listArray.length < baseIndex + 1 )
				return null;
			var i,
				doc = listArray[ baseIndex ].parent.getDocument(),
				retval = new CKEDITOR.dom.documentFragment( doc ),
				rootNode = null,
				currentIndex = baseIndex,
				indentLevel = Math.max( listArray[ baseIndex ].indent, 0 ),
				currentListItem = null,
				orgDir, block,
				paragraphName = ( paragraphMode == CKEDITOR.ENTER_P ? 'p' : 'div' );
			while ( 1 ) {
				var item = listArray[ currentIndex ],
					itemGrandParent = item.grandparent;

				orgDir = item.element.getDirection( 1 );

				if ( item.indent == indentLevel ) {
					if ( !rootNode || listArray[ currentIndex ].parent.getName() != rootNode.getName() ) {
						rootNode = listArray[ currentIndex ].parent.clone( false, 1 );
						dir && rootNode.setAttribute( 'dir', dir );
						retval.append( rootNode );
					}
					currentListItem = rootNode.append( item.element.clone( 0, 1 ) );

					if ( orgDir != rootNode.getDirection( 1 ) )
						currentListItem.setAttribute( 'dir', orgDir );

					for ( i = 0; i < item.contents.length; i++ )
						currentListItem.append( item.contents[ i ].clone( 1, 1 ) );
					currentIndex++;
				} else if ( item.indent == Math.max( indentLevel, 0 ) + 1 ) {
					// Maintain original direction (#6861).
					var currDir = listArray[ currentIndex - 1 ].element.getDirection( 1 ),
						listData = CKEDITOR.plugins.list.arrayToList( listArray, null, currentIndex, paragraphMode, currDir != orgDir ? orgDir : null );

					// If the next block is an <li> with another list tree as the first
					// child, we'll need to append a filler (<br>/NBSP) or the list item
					// wouldn't be editable. (#6724)
					if ( !currentListItem.getChildCount() && CKEDITOR.env.ie && !( doc.$.documentMode > 7 ) )
						currentListItem.append( doc.createText( '\xa0' ) );
					currentListItem.append( listData.listNode );
					currentIndex = listData.nextIndex;
				} else if ( item.indent == -1 && !baseIndex && itemGrandParent ) {
					if ( listNodeNames[ itemGrandParent.getName() ] ) {
						currentListItem = item.element.clone( false, true );
						if ( orgDir != itemGrandParent.getDirection( 1 ) )
							currentListItem.setAttribute( 'dir', orgDir );
					} else
						currentListItem = new CKEDITOR.dom.documentFragment( doc );

					// Migrate all children to the new container,
					// apply the proper text direction.
					var dirLoose = itemGrandParent.getDirection( 1 ) != orgDir,
						li = item.element,
						className = li.getAttribute( 'class' ),
						style = li.getAttribute( 'style' );

					var needsBlock = currentListItem.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT && ( paragraphMode != CKEDITOR.ENTER_BR || dirLoose || style || className );

					var child,
						count = item.contents.length;
					for ( i = 0; i < count; i++ ) {
						child = item.contents[ i ];

						if ( child.type == CKEDITOR.NODE_ELEMENT && child.isBlockBoundary() ) {
							// Apply direction on content blocks.
							if ( dirLoose && !child.getDirection() )
								child.setAttribute( 'dir', orgDir );

							inheirtInlineStyles( li, child );

							className && child.addClass( className );
						} else if ( needsBlock ) {
							// Establish new block to hold text direction and styles.
							if ( !block ) {
								block = doc.createElement( paragraphName );
								dirLoose && block.setAttribute( 'dir', orgDir );
							}

							// Copy over styles to new block;
							style && block.setAttribute( 'style', style );
							className && block.setAttribute( 'class', className );

							block.append( child.clone( 1, 1 ) );
						}

						currentListItem.append( block || child.clone( 1, 1 ) );
					}

					if ( currentListItem.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT && currentIndex != listArray.length - 1 ) {
						var last = currentListItem.getLast();
						if ( last && last.type == CKEDITOR.NODE_ELEMENT && last.getAttribute( 'type' ) == '_moz' ) {
							last.remove();
						}

						if ( !( last = currentListItem.getLast( nonEmpty ) && last.type == CKEDITOR.NODE_ELEMENT && last.getName() in CKEDITOR.dtd.$block ) ) {
							currentListItem.append( doc.createElement( 'br' ) );
						}
					}

					var currentListItemName = currentListItem.$.nodeName.toLowerCase();
					if ( !CKEDITOR.env.ie && ( currentListItemName == 'div' || currentListItemName == 'p' ) )
						currentListItem.appendBogus();
					retval.append( currentListItem );
					rootNode = null;
					currentIndex++;
				} else
					return null;

				block = null;

				if ( listArray.length <= currentIndex || Math.max( listArray[ currentIndex ].indent, 0 ) < indentLevel )
					break;
			}

			if ( database ) {
				var currentNode = retval.getFirst(),
					listRoot = listArray[ 0 ].parent;

				while ( currentNode ) {
					if ( currentNode.type == CKEDITOR.NODE_ELEMENT ) {
						// Clear marker attributes for the new list tree made of cloned nodes, if any.
						CKEDITOR.dom.element.clearMarkers( database, currentNode );

						// Clear redundant direction attribute specified on list items.
						if ( currentNode.getName() in CKEDITOR.dtd.$listItem )
							cleanUpDirection( currentNode );
					}

					currentNode = currentNode.getNextSourceNode();
				}
			}

			return { listNode: retval, nextIndex: currentIndex };
		}
	};

	function changeListType( editor, groupObj, database, listsCreated ) {
		// This case is easy...
		// 1. Convert the whole list into a one-dimensional array.
		// 2. Change the list type by modifying the array.
		// 3. Recreate the whole list by converting the array to a list.
		// 4. Replace the original list with the recreated list.
		var listArray = CKEDITOR.plugins.list.listToArray( groupObj.root, database ),
			selectedListItems = [];

		for ( var i = 0; i < groupObj.contents.length; i++ ) {
			var itemNode = groupObj.contents[ i ];
			itemNode = itemNode.getAscendant( 'li', true );
			if ( !itemNode || itemNode.getCustomData( 'list_item_processed' ) )
				continue;
			selectedListItems.push( itemNode );
			CKEDITOR.dom.element.setMarker( database, itemNode, 'list_item_processed', true );
		}

		var root = groupObj.root,
			doc = root.getDocument(),
			listNode, newListNode;

		for ( i = 0; i < selectedListItems.length; i++ ) {
			var listIndex = selectedListItems[ i ].getCustomData( 'listarray_index' );
			listNode = listArray[ listIndex ].parent;

			// Switch to new list node for this particular item.
			if ( !listNode.is( this.type ) ) {
				newListNode = doc.createElement( this.type );
				// Copy all attributes, except from 'start' and 'type'.
				listNode.copyAttributes( newListNode, { start:1,type:1 } );
				// The list-style-type property should be ignored.
				newListNode.removeStyle( 'list-style-type' );
				listArray[ listIndex ].parent = newListNode;
			}
		}

		var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode );
		var child,
			length = newList.listNode.getChildCount();
		for ( i = 0; i < length && ( child = newList.listNode.getChild( i ) ); i++ ) {
			if ( child.getName() == this.type )
				listsCreated.push( child );
		}
		newList.listNode.replace( groupObj.root );
	}

	var headerTagRegex = /^h[1-6]$/;

	function createList( editor, groupObj, listsCreated ) {
		var contents = groupObj.contents,
			doc = groupObj.root.getDocument(),
			listContents = [];

		// It is possible to have the contents returned by DomRangeIterator to be the same as the root.
		// e.g. when we're running into table cells.
		// In such a case, enclose the childNodes of contents[0] into a <div>.
		if ( contents.length == 1 && contents[ 0 ].equals( groupObj.root ) ) {
			var divBlock = doc.createElement( 'div' );
			contents[ 0 ].moveChildren && contents[ 0 ].moveChildren( divBlock );
			contents[ 0 ].append( divBlock );
			contents[ 0 ] = divBlock;
		}

		// Calculate the common parent node of all content blocks.
		var commonParent = groupObj.contents[ 0 ].getParent();
		for ( var i = 0; i < contents.length; i++ )
			commonParent = commonParent.getCommonAncestor( contents[ i ].getParent() );

		var useComputedState = editor.config.useComputedState,
			listDir, explicitDirection;

		useComputedState = useComputedState === undefined || useComputedState;

		// We want to insert things that are in the same tree level only, so calculate the contents again
		// by expanding the selected blocks to the same tree level.
		for ( i = 0; i < contents.length; i++ ) {
			var contentNode = contents[ i ],
				parentNode;
			while ( ( parentNode = contentNode.getParent() ) ) {
				if ( parentNode.equals( commonParent ) ) {
					listContents.push( contentNode );

					// Determine the lists's direction.
					if ( !explicitDirection && contentNode.getDirection() )
						explicitDirection = 1;

					var itemDir = contentNode.getDirection( useComputedState );

					if ( listDir !== null ) {
						// If at least one LI have a different direction than current listDir, we can't have listDir.
						if ( listDir && listDir != itemDir )
							listDir = null;
						else
							listDir = itemDir;
					}

					break;
				}
				contentNode = parentNode;
			}
		}

		if ( listContents.length < 1 )
			return;

		// Insert the list to the DOM tree.
		var insertAnchor = listContents[ listContents.length - 1 ].getNext(),
			listNode = doc.createElement( this.type );

		listsCreated.push( listNode );

		var contentBlock, listItem;

		while ( listContents.length ) {
			contentBlock = listContents.shift();
			listItem = doc.createElement( 'li' );

			// Preserve preformat block and heading structure when converting to list item. (#5335) (#5271)
			if ( contentBlock.is( 'pre' ) || headerTagRegex.test( contentBlock.getName() ) )
				contentBlock.appendTo( listItem );
			else {
				contentBlock.copyAttributes( listItem );
				// Remove direction attribute after it was merged into list root. (#7657)
				if ( listDir && contentBlock.getDirection() ) {
					listItem.removeStyle( 'direction' );
					listItem.removeAttribute( 'dir' );
				}
				contentBlock.moveChildren( listItem );
				contentBlock.remove();
			}

			listItem.appendTo( listNode );
		}

		// Apply list root dir only if it has been explicitly declared.
		if ( listDir && explicitDirection )
			listNode.setAttribute( 'dir', listDir );

		if ( insertAnchor )
			listNode.insertBefore( insertAnchor );
		else
			listNode.appendTo( commonParent );
	}

	function removeList( editor, groupObj, database ) {
		// This is very much like the change list type operation.
		// Except that we're changing the selected items' indent to -1 in the list array.
		var listArray = CKEDITOR.plugins.list.listToArray( groupObj.root, database ),
			selectedListItems = [];

		for ( var i = 0; i < groupObj.contents.length; i++ ) {
			var itemNode = groupObj.contents[ i ];
			itemNode = itemNode.getAscendant( 'li', true );
			if ( !itemNode || itemNode.getCustomData( 'list_item_processed' ) )
				continue;
			selectedListItems.push( itemNode );
			CKEDITOR.dom.element.setMarker( database, itemNode, 'list_item_processed', true );
		}

		var lastListIndex = null;
		for ( i = 0; i < selectedListItems.length; i++ ) {
			var listIndex = selectedListItems[ i ].getCustomData( 'listarray_index' );
			listArray[ listIndex ].indent = -1;
			lastListIndex = listIndex;
		}

		// After cutting parts of the list out with indent=-1, we still have to maintain the array list
		// model's nextItem.indent <= currentItem.indent + 1 invariant. Otherwise the array model of the
		// list cannot be converted back to a real DOM list.
		for ( i = lastListIndex + 1; i < listArray.length; i++ ) {
			if ( listArray[ i ].indent > listArray[ i - 1 ].indent + 1 ) {
				var indentOffset = listArray[ i - 1 ].indent + 1 - listArray[ i ].indent;
				var oldIndent = listArray[ i ].indent;
				while ( listArray[ i ] && listArray[ i ].indent >= oldIndent ) {
					listArray[ i ].indent += indentOffset;
					i++;
				}
				i--;
			}
		}

		var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode, groupObj.root.getAttribute( 'dir' ) );

		// Compensate <br> before/after the list node if the surrounds are non-blocks.(#3836)
		var docFragment = newList.listNode,
			boundaryNode, siblingNode;

		function compensateBrs( isStart ) {
			if ( ( boundaryNode = docFragment[ isStart ? 'getFirst' : 'getLast' ]() ) && !( boundaryNode.is && boundaryNode.isBlockBoundary() ) && ( siblingNode = groupObj.root[ isStart ? 'getPrevious' : 'getNext' ]
			( CKEDITOR.dom.walker.invisible( true ) ) ) && !( siblingNode.is && siblingNode.isBlockBoundary( { br:1 } ) ) )
				editor.document.createElement( 'br' )[ isStart ? 'insertBefore' : 'insertAfter' ]( boundaryNode );
		}
		compensateBrs( true );
		compensateBrs();

		docFragment.replace( groupObj.root );
	}

	function listCommand( name, type ) {
		this.name = name;
		this.type = type;
		this.context = type;
		this.allowedContent = type + ' li';
		this.requiredContent = type;
	}

	var elementType = CKEDITOR.dom.walker.nodeType( CKEDITOR.NODE_ELEMENT );

	// Merge child nodes with direction preserved. (#7448)
	function mergeChildren( from, into, refNode, forward ) {
		var child, itemDir;
		while ( ( child = from[ forward ? 'getLast' : 'getFirst' ]( elementType ) ) ) {
			if ( ( itemDir = child.getDirection( 1 ) ) !== into.getDirection( 1 ) )
				child.setAttribute( 'dir', itemDir );

			child.remove();

			refNode ? child[ forward ? 'insertBefore' : 'insertAfter' ]( refNode ) : into.append( child, forward );
		}
	}

	listCommand.prototype = {
		exec: function( editor ) {
			// Run state check first of all.
			this.refresh( editor, editor.elementPath() );

			var doc = editor.document,
				config = editor.config,
				selection = editor.getSelection(),
				ranges = selection && selection.getRanges( true );

			// Midas lists rule #1 says we can create a list even in an empty document.
			// But DOM iterator wouldn't run if the document is really empty.
			// So create a paragraph if the document is empty and we're going to create a list.
			if ( this.state == CKEDITOR.TRISTATE_OFF ) {
				var editable = editor.editable();
				if ( !editable.getFirst( nonEmpty ) ) {
					config.enterMode == CKEDITOR.ENTER_BR ? editable.appendBogus() : ranges[ 0 ].fixBlock( 1, config.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' );

					selection.selectRanges( ranges );
				}
				// Maybe a single range there enclosing the whole list,
				// turn on the list state manually(#4129).
				else {
					var range = ranges.length == 1 && ranges[ 0 ],
						enclosedNode = range && range.getEnclosedNode();
					if ( enclosedNode && enclosedNode.is && this.type == enclosedNode.getName() )
						this.setState( CKEDITOR.TRISTATE_ON );
				}
			}

			var bookmarks = selection.createBookmarks( true );

			// Group the blocks up because there are many cases where multiple lists have to be created,
			// or multiple lists have to be cancelled.
			var listGroups = [],
				database = {},
				rangeIterator = ranges.createIterator(),
				index = 0;

			while ( ( range = rangeIterator.getNextRange() ) && ++index ) {
				var boundaryNodes = range.getBoundaryNodes(),
					startNode = boundaryNodes.startNode,
					endNode = boundaryNodes.endNode;

				if ( startNode.type == CKEDITOR.NODE_ELEMENT && startNode.getName() == 'td' )
					range.setStartAt( boundaryNodes.startNode, CKEDITOR.POSITION_AFTER_START );

				if ( endNode.type == CKEDITOR.NODE_ELEMENT && endNode.getName() == 'td' )
					range.setEndAt( boundaryNodes.endNode, CKEDITOR.POSITION_BEFORE_END );

				var iterator = range.createIterator(),
					block;

				iterator.forceBrBreak = ( this.state == CKEDITOR.TRISTATE_OFF );

				while ( ( block = iterator.getNextParagraph() ) ) {
					// Avoid duplicate blocks get processed across ranges.
					if ( block.getCustomData( 'list_block' ) )
						continue;
					else
						CKEDITOR.dom.element.setMarker( database, block, 'list_block', 1 );

					var path = editor.elementPath( block ),
						pathElements = path.elements,
						pathElementsCount = pathElements.length,
						listNode = null,
						processedFlag = 0,
						blockLimit = path.blockLimit,
						element;

					// First, try to group by a list ancestor.
					for ( var i = pathElementsCount - 1; i >= 0 && ( element = pathElements[ i ] ); i-- ) {
						if ( listNodeNames[ element.getName() ] && blockLimit.contains( element ) ) // Don't leak outside block limit (#3940).
						{
							// If we've encountered a list inside a block limit
							// The last group object of the block limit element should
							// no longer be valid. Since paragraphs after the list
							// should belong to a different group of paragraphs before
							// the list. (Bug #1309)
							blockLimit.removeCustomData( 'list_group_object_' + index );

							var groupObj = element.getCustomData( 'list_group_object' );
							if ( groupObj )
								groupObj.contents.push( block );
							else {
								groupObj = { root: element, contents: [ block ] };
								listGroups.push( groupObj );
								CKEDITOR.dom.element.setMarker( database, element, 'list_group_object', groupObj );
							}
							processedFlag = 1;
							break;
						}
					}

					if ( processedFlag )
						continue;

					// No list ancestor? Group by block limit, but don't mix contents from different ranges.
					var root = blockLimit;
					if ( root.getCustomData( 'list_group_object_' + index ) )
						root.getCustomData( 'list_group_object_' + index ).contents.push( block );
					else {
						groupObj = { root: root, contents: [ block ] };
						CKEDITOR.dom.element.setMarker( database, root, 'list_group_object_' + index, groupObj );
						listGroups.push( groupObj );
					}
				}
			}

			// Now we have two kinds of list groups, groups rooted at a list, and groups rooted at a block limit element.
			// We either have to build lists or remove lists, for removing a list does not makes sense when we are looking
			// at the group that's not rooted at lists. So we have three cases to handle.
			var listsCreated = [];
			while ( listGroups.length > 0 ) {
				groupObj = listGroups.shift();
				if ( this.state == CKEDITOR.TRISTATE_OFF ) {
					if ( listNodeNames[ groupObj.root.getName() ] )
						changeListType.call( this, editor, groupObj, database, listsCreated );
					else
						createList.call( this, editor, groupObj, listsCreated );
				} else if ( this.state == CKEDITOR.TRISTATE_ON && listNodeNames[ groupObj.root.getName() ] )
					removeList.call( this, editor, groupObj, database );
			}

			// For all new lists created, merge into adjacent, same type lists.
			for ( i = 0; i < listsCreated.length; i++ )
				mergeListSiblings( listsCreated[ i ] );

			// Clean up, restore selection and update toolbar button states.
			CKEDITOR.dom.element.clearAllMarkers( database );
			selection.selectBookmarks( bookmarks );
			editor.focus();
		},

		refresh: function( editor, path ) {
			var list = path.contains( listNodeNames, 1 ),
				limit = path.blockLimit || path.root;

			// 1. Only a single type of list activate.
			// 2. Do not show list outside of block limit.
			if ( list && limit.contains( list ) )
				this.setState( list.is( this.type ) ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );
			else
				this.setState( CKEDITOR.TRISTATE_OFF );
		}
	};

	var dtd = CKEDITOR.dtd;
	var tailNbspRegex = /[\t\r\n ]*(?:&nbsp;|\xa0)$/;

		// Merge list adjacent, of same type lists.
	function mergeListSiblings( listNode )
	{
		var mergeSibling;
		( mergeSibling = function( rtl )
		{
			var sibling = listNode[ rtl ? 'getPrevious' : 'getNext' ]( nonEmpty );
			if ( sibling &&
			     sibling.type == CKEDITOR.NODE_ELEMENT &&
			     sibling.is( listNode.getName() ) )
			{
				// Move children order by merge direction.(#3820)
				mergeChildren( listNode, sibling, null, !rtl );

				listNode.remove();
				listNode = sibling;
			}
		} )();
		mergeSibling( 1 );
	}

	function indexOfFirstChildElement( element, tagNameList ) {
		var child,
			children = element.children,
			length = children.length;

		for ( var i = 0; i < length; i++ ) {
			child = children[ i ];
			if ( child.name && ( child.name in tagNameList ) )
				return i;
		}

		return length;
	}

	// Check if node is block element that recieves text.
	function isTextBlock( node ) {
		return node.type == CKEDITOR.NODE_ELEMENT && ( node.getName() in CKEDITOR.dtd.$block || node.getName() in CKEDITOR.dtd.$listItem ) && CKEDITOR.dtd[ node.getName() ][ '#' ];
	}

	// Join visually two block lines.
	function joinNextLineToCursor( editor, cursor, nextCursor ) {
		editor.fire( 'saveSnapshot' );

		// Merge with previous block's content.
		nextCursor.enlarge( CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS );
		var frag = nextCursor.extractContents();

		cursor.trim( false, true );
		var bm = cursor.createBookmark();

		// Kill original bogus;
		var currentPath = new CKEDITOR.dom.elementPath( cursor.startContainer ),
				pathBlock = currentPath.block,
				currentBlock = currentPath.lastElement.getAscendant( 'li', 1 ) || pathBlock,
				nextPath = new CKEDITOR.dom.elementPath( nextCursor.startContainer ),
				nextLi = nextPath.contains( CKEDITOR.dtd.$listItem ),
				nextList = nextPath.contains( CKEDITOR.dtd.$list ),
				last;

		// Remove bogus node the current block/pseudo block.
		if ( pathBlock ) {
			var bogus = pathBlock.getBogus();
			bogus && bogus.remove();
		}
		else if ( nextList ) {
			last = nextList.getPrevious( nonEmpty );
			if ( last && blockBogus( last ) )
				last.remove();
		}

		// Kill the tail br in extracted.
		last = frag.getLast();
		if ( last && last.type == CKEDITOR.NODE_ELEMENT && last.is( 'br' ) )
			last.remove();

		// Insert fragment at the range position.
		var nextNode = cursor.startContainer.getChild( cursor.startOffset );
		if ( nextNode )
			frag.insertBefore( nextNode );
		else
			cursor.startContainer.append( frag );

		// Move the sub list nested in the next list item.
		if ( nextLi ) {
			var sublist = getSubList( nextLi );
			if ( sublist ) {
				// If next line is in the sub list of the current list item.
				if ( currentBlock.contains( nextLi ) ) {
					mergeChildren( sublist, nextLi.getParent(), nextLi );
					sublist.remove();
				}
				// Migrate the sub list to current list item.
				else
					currentBlock.append( sublist );
			}
		}

		var nextBlock, parent;
		// Remove any remaining zombies path blocks at the end after line merged.
		while ( nextCursor.checkStartOfBlock() && nextCursor.checkEndOfBlock() ) {
			nextPath = nextCursor.startPath();
			nextBlock = nextPath.block;

			// Check if also to remove empty list.
			if ( nextBlock.is( 'li' ) ) {
				parent = nextBlock.getParent();
				if ( nextBlock.equals( parent.getLast( nonEmpty ) ) && nextBlock.equals( parent.getFirst( nonEmpty ) ) )
					nextBlock = parent;
			}

			nextCursor.moveToPosition( nextBlock, CKEDITOR.POSITION_BEFORE_START );
			nextBlock.remove();
		}

		// Check if need to further merge with the list resides after the merged block. (#9080)
		var walkerRng = nextCursor.clone(), editable = editor.editable();
		walkerRng.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );
		var walker = new CKEDITOR.dom.walker( walkerRng );
		walker.evaluator = function( node ) { return nonEmpty( node ) && !blockBogus( node ); };
		var next = walker.next();
		if ( next && next.type == CKEDITOR.NODE_ELEMENT && next.getName() in CKEDITOR.dtd.$list )
			mergeListSiblings( next );

		cursor.moveToBookmark( bm );

		// Make fresh selection.
		cursor.select();

		editor.fire( 'saveSnapshot' );
	}

	function getSubList( li ) {
		var last = li.getLast( nonEmpty );
		return last && last.type == CKEDITOR.NODE_ELEMENT && last.getName() in listNodeNames ? last : null;
	}

	CKEDITOR.plugins.add( 'list', {
		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en-au,en-ca,en-gb,en,eo,es,et,eu,fa,fi,fo,fr-ca,fr,gl,gu,he,hi,hr,hu,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt-br,pt,ro,ru,sk,sl,sr-latn,sr,sv,th,tr,ug,uk,vi,zh-cn,zh', // %REMOVE_LINE_CORE%
		icons: 'bulletedlist,bulletedlist-rtl,numberedlist,numberedlist-rtl', // %REMOVE_LINE_CORE%
		requires: 'indent',
		init: function( editor ) {
			if ( editor.blockless )
				return;

			// Register commands.
			editor.addCommand( 'numberedlist', new listCommand( 'numberedlist', 'ol' ) );
			editor.addCommand( 'bulletedlist', new listCommand( 'bulletedlist', 'ul' ) );

			// Register the toolbar button.
			if ( editor.ui.addButton ) {
				editor.ui.addButton( 'NumberedList', {
					label: editor.lang.list.numberedlist,
					command: 'numberedlist',
					directional: true,
					toolbar: 'list,10'
				});
				editor.ui.addButton( 'BulletedList', {
					label: editor.lang.list.bulletedlist,
					command: 'bulletedlist',
					directional: true,
					toolbar: 'list,20'
				});
			}

			// Handled backspace/del key to join list items. (#8248,#9080)
			editor.on( 'key', function( evt ) {
				var key = evt.data.keyCode;

				// DEl/BACKSPACE
				if ( editor.mode == 'wysiwyg' && key in { 8:1,46:1 } ) {
					var sel = editor.getSelection(),
						range = sel.getRanges()[ 0 ];
					/* ------------------------------------------------------------------------
					/*** DYNAMIC DOCUMENTATION CHANGE ***
					// What Changed: Check for selection with no ranges
					// Testing Considerations: Click in a read-only portion of a DynDoc note
					// (create a collapsed selection).  Then press delete or backspace.
					// ------------------------------------------------------------------------*/
					if (!range)
						return;
					var path = range.startPath();

					if ( !range.collapsed )
						return;

					path = new CKEDITOR.dom.elementPath( range.startContainer );
					var isBackspace = key == 8;
					var editable = editor.editable();
					var walker = new CKEDITOR.dom.walker( range.clone() );
					walker.evaluator = function( node ) {
						return nonEmpty( node ) && !blockBogus( node );
					};
					// Backspace/Del behavior at the start/end of table is handled in core.
					walker.guard = function( node, isOut ) {
						return !( isOut && node.type == CKEDITOR.NODE_ELEMENT && node.is( 'table' ) );
					};

					var cursor = range.clone();

					if ( isBackspace ) {
						var previous, joinWith;

						// Join a sub list's first line, with the previous visual line in parent.
						if ( ( previous = path.contains( listNodeNames ) ) &&
						     range.checkBoundaryOfElement( previous, CKEDITOR.START ) &&
						     ( previous = previous.getParent() ) && previous.is( 'li' ) &&
						     ( previous = getSubList( previous ) ) ) {
							joinWith = previous;
							previous = previous.getPrevious( nonEmpty );
							// Place cursor before the nested list.
							cursor.moveToPosition(
								previous && blockBogus( previous ) ? previous : joinWith,
								CKEDITOR.POSITION_BEFORE_START );
						}
						// Join any line following a list, with the last visual line of the list.
						else {
							walker.range.setStartAt( editable, CKEDITOR.POSITION_AFTER_START );
							walker.range.setEnd( range.startContainer, range.startOffset );

							previous = walker.previous();

							if ( previous && previous.type == CKEDITOR.NODE_ELEMENT &&
							     ( previous.getName() in listNodeNames ||
							       previous.is( 'li' ) ) ) {
								if ( !previous.is( 'li' ) ) {
									walker.range.selectNodeContents( previous );
									walker.reset();
									walker.evaluator = isTextBlock;
									previous = walker.previous();
								}

								joinWith = previous;
								// Place cursor at the end of previous block.
								cursor.moveToElementEditEnd( joinWith );
							}
						}

						if ( joinWith ) {
							joinNextLineToCursor( editor, cursor, range );
							evt.cancel();
						}
						else {
							var list = path.contains( listNodeNames );
							// Backspace pressed at the start of list outdents the first list item. (#9129)
							if ( list && range.checkBoundaryOfElement( list, CKEDITOR.START ) ) {
								li = list.getFirst( nonEmpty );

								if ( range.checkBoundaryOfElement( li, CKEDITOR.START ) ) {
									previous = list.getPrevious( nonEmpty );

									// Only if the list item contains a sub list, do nothing but
									// simply move cursor backward one character.
									if ( getSubList( li ) ) {
										if ( previous ) {
											range.moveToElementEditEnd( previous );
											range.select();
										}

										evt.cancel();
									}
									else {
										editor.execCommand( 'outdent' );
										evt.cancel();
									}
								}
							}
						}

					} else {

						var next, nextLine, li = path.contains( 'li' );

						if ( li ) {
							walker.range.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );

							var last = li.getLast( nonEmpty );
							var block = last && isTextBlock( last ) ? last : li;

							// Indicate cursor at the visual end of an list item.
							var isAtEnd = 0;

							next = walker.next();

							// When list item contains a sub list.
							if ( next && next.type == CKEDITOR.NODE_ELEMENT &&
								 next.getName() in listNodeNames &&
								 next.equals( last ) )
							{
								isAtEnd = 1;

								// Move to the first item in sub list.
								next = walker.next();
							}
							// Right at the end of list item.
							else if ( range.checkBoundaryOfElement( block, CKEDITOR.END ) )
								isAtEnd = 1;


							if ( isAtEnd && next ) {
								// Put cursor range there.
								nextLine = range.clone();
								nextLine.moveToElementEditStart( next );

								joinNextLineToCursor( editor, cursor, nextLine );
								evt.cancel();
							}
						}
						else
						{
							// Handle Del key pressed before the list.
							walker.range.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );
							next = walker.next();

							if ( next && next.type == CKEDITOR.NODE_ELEMENT &&
							     next.is( listNodeNames ) ) {
								// The start <li>
								next = next.getFirst( nonEmpty );

								// Simply remove the current empty block, move cursor to the
								// subsequent list.
								if ( path.block &&
								     range.checkStartOfBlock() &&
								     range.checkEndOfBlock() ) {
									path.block.remove();
									range.moveToElementEditStart( next );
									range.select();
									evt.cancel();
								}
								// Preventing the default (merge behavior), but simply move
								// the cursor one character forward if subsequent list item
								// contains sub list.
								else if ( getSubList( next )  ) {
									range.moveToElementEditStart( next );
									range.select();
									evt.cancel();
								}
								// Merge the first list item with the current line.
								else {
									nextLine = range.clone();
									nextLine.moveToElementEditStart( next );
									joinNextLineToCursor( editor, cursor, nextLine );
									evt.cancel();
								}
							}
						}

					}

					// The backspace/del could potentially put cursor at a bad position,
					// being it handled or not, check immediately the selection to have it fixed.
					setTimeout( function() { editor.selectionChange( 1 ); } );
				}
			});
		}
	});
})();

(function(){

/******************************************************************************
/ Description: Editor grow plugin
/              Updates the CSS of editable content container to verify that the
/              editor can grow unlimitedly or to a defined max-height at which
/              scrolling is applied.
/
/              This is being utilized instead of the standard autogrow plugin
/              as it doesn't support min-height and max-height configurations
/              for inline editors
*******************************************************************************/

	/**
	 * Updates the max-height of the passed in editor
	 * @param  {CKEDITOR.editor} editor    CKEditor instance
	 * @param  {Number} maxHeight          Height to allow the contents to grow to before scrolling
	 * @return {undefined}
	 */
	var updateMaxHeight = function(editor, maxHeight) {
		if (maxHeight) {
			var contents = editor.ui.space( 'contents' );
			var editorContainer = editor.container;
			var newMaxHeight = maxHeight;
			// Don't include container in calculations
			if (editorContainer.$ && contents.$) {
				var paddingHeight = $(editorContainer.$).outerHeight(true) - $(contents.$).outerHeight(true);
				newMaxHeight = newMaxHeight - paddingHeight;
			}

			if (newMaxHeight < 0){
				newMaxHeight = 0;
			}

			contents.setStyles({
				'max-height' : newMaxHeight + 'px',
				'overflow-y' : 'auto'
			});
		}
	}

	CKEDITOR.plugins.add( 'cerngrow', {
		init: function( editor ) {
			editor.on( 'instanceReady', function() {
				var editable = editor.editable();
				var min = editor.config.cernGrow_minHeight;
				var max = editor.config.cernGrow_maxHeight;
				// plugin is only supported for inline editors
				if ( editable.isInline() ) {
					var contentsElement = editor.ui.space( 'contents' );
					contentsElement.setStyle( 'height', 'auto' );
					if (min) {
						contentsElement.setStyle( 'min-height', min + 'px');
					}
					updateMaxHeight(editor, max);

					// Allow updates based on resizing of container
					editor.on( 'updateEditorMaxHeight', function (event) {
						var editor = event.editor;
						var maxHeight = (event.data && event.data.maxHeight) || 0;
						if (editor && maxHeight){
							editor.config.cernGrow_maxHeight = maxHeight;
							updateMaxHeight(editor, maxHeight);
						}
					});
				}
			});
		}
	});
})();

/**
 * The minimum height that the editor can reach using the cernGrow feature.
 *
 *		config.cernGrow_minHeight = 300;
 *
 * @since 3.4
 * @cfg {Number} [cernGrow_minHeight=200]
 * @member CKEDITOR.config
 */

/**
 * The maximum height that the editor can reach using the cernGrow feature. Zero means unlimited.
 *
 *		config.cernGrow_maxHeight = 400;
 *
 * @since 3.4
 * @cfg {Number} [cernGrow_maxHeight=0]
 * @member CKEDITOR.config
 */
/*
 * Autosave plugin
 * 
 * Requires jQuery
 * Requires cerngetxhtml
 */

/**
 * @fileSave plugin.
 */

(function () {
	var pluginName = 'autosave';

	// Idle time threshold before the we automatically save, in milliseconds
	var AUTOSAVE_IDLE_THRESHOLD = 30 * 1000;

	/**
	 * This function encapsulates the intricacies of getting data from the editing area.
	 *
	 * @param editorInstance
	 *        The editor instance to extract the data from.
	 *
	 */
	var getData = function (editorInstance) {
		var contentData = null,
			placeholdertext = null,
			container = editorInstance.container.$,
			body = $(container).find(".cke_wysiwyg_div");

        // ensure that we remove the placeholdertext before we extract the content
		if (editorInstance.removePlaceHolderText) {
			editorInstance.removePlaceHolderText();
		}

		// get the content in the correct format
		if (editorInstance.config.emitValidXhtml) {
			contentData = editorInstance.getXhtml();
		} else {
			contentData = editorInstance.getData();
		}

        // put the placeholdertext back, if any
		if (editorInstance.applyPlaceholderText) {
			editorInstance.applyPlaceholderText();
		}

		return contentData;
	};

	// Register a plugin named "autosave".
	CKEDITOR.plugins.add(pluginName,
		{
			lang: ['en', 'en_gb', 'de', 'fr', 'es'],

			/**
			 * Performs plugin specific initialization on the given instance of the editor.
			 *
			 * Also provides instance scope variables and functions like:
			 * savefunction
			 * setDirtyFunction
			 * resetDirtyFunction
			 */
			init: function (editor) {
				var savefunction = null;
				var preSaveFunction = null;
				var setDirtyFunction = null;
				var resetDirtyFunction = null;
				// By default assume saving is on
				var canSaveFunction = function(){return true;};
				var saveButton = null;

				/**
				 * A handler to check for dirty data and keep the save button and external frameworks up to date on whether
				 * the data is dirty.
				 */
				var dirtyEventHandler = function (e) {
					if (saveButton === null) {
						return;
					}

					// if we have dirty data, and the save button is disabled, we will enable the button
					if (editor.isEditorDirty()) {
						// this and the above if statements are deliberately NOT combined
						if (saveButton.attr('disabled') !== undefined && canSaveFunction()) {
							saveButton.removeAttr('disabled');

							if (setDirtyFunction) {
								setDirtyFunction();
							}
						}
						// if we don't have dirty data and the save button is enabled, we need to disable the button
					} else if (saveButton.attr('disabled') === undefined) {
						saveButton.attr('disabled', 'disabled');

						if (resetDirtyFunction) {
							resetDirtyFunction();
						}
					}
				};

				if (editor.config.canSaveFunction) {
					canSaveFunction = editor.config.canSaveFunction;
				}
				if (editor.config.autosaveFunction) {
					savefunction = editor.config.autosaveFunction;
				}

				if (editor.config.setDirtyFunction) {
					setDirtyFunction = editor.config.setDirtyFunction;
				}

				if (editor.config.resetDirtyFunction) {
					resetDirtyFunction = editor.config.resetDirtyFunction;
				}

				preSaveFunction = editor.config.preSaveFunction || function(){};

				editor.on('instanceReady', function (e) {
					var editorInstance = e.editor,
						container = e.editor.container.$; // html container element

					// last time of activity, like a key press
					var lastActivityTime = 0;
					var timeoutId = 0;
					var pollingTimeout = null;
					var editableContent = editorInstance.editable().$;
					var POLL_INTERVAL = 3000;
					var placeHolderText = editorInstance.config.placeholderText;

					/**
					 * This method will filter out the placeholder text. If the placeholder text is within the CKEditor
					 * we assume the content is empty, thus will return <p></p>.
					 * @param {String} ckeditorContent - The contents within CKEditor.
					 * @returns {String} The contents of the CKEditor.
					 */
					function filterPlaceholder(ckeditorContent) {
						return (ckeditorContent === '<span id="placeHolderText">' + placeHolderText + '</span>') ? '<p></p>' : ckeditorContent;
					}

					//Start the contents of the CKEditor off so the check activity function will work
					var dataSinceLastActivity = filterPlaceholder(editableContent.innerHTML);

					/**
					 * The activity handler keeps track when the last activity happened.
					 *
					 * Currently, the handler is being triggered on every key press.
					 * So the "last activity" would be the "last key press" in this case.
					 */
					var activityHandler = function (e) {
						if (lastActivityTime === 0) {
							// no need to start the check till we are about ~75% of the way through the idle threshold
							timeoutId = window.setTimeout(autoSaveTimer, AUTOSAVE_IDLE_THRESHOLD * 0.75);
						}

						// update lastActivityTime
						lastActivityTime = (new Date()).getTime();
					};

					/**
					 * A timer to check every AUTOSAVE_IDLE_THRESHOLD milliseconds to see if the user has idled long enough to
					 * cause us to perform the save operation.
					 *
					 * This is the prevent too much UNSAVED data from being lost should a catastrophic event happens.
					 *
					 * Currently ticks every ~1 second interval.
					 */
					var autoSaveTimer = function (e) {
						// make sure there was activity and
						// make sure the editor's document is still valid (it could have been destroyed already)
						if (lastActivityTime === 0 || !editorInstance.document) {
							return;
						}


						// indicates whether any text is selected
						var hasSelectedText = false;
						// indicates whether the selected text is within the editing area
						var isWithinEditor = false;
						// assume that it isn't safe
						var isSafe = false;

						try {
							var saveButtonEnabled = (saveButton.attr('disabled') === undefined);
							if (CKEDITOR.env.ie) {
								var currentDocument = editorInstance.document.$;
								var currentSelection = currentDocument.selection.createRange();
								var editingArea = editorInstance.plugins.divarea ? editorInstance.ui.space('contents').$ : editorInstance.document.$.body;
								var editingAreaRange = null;
								if (currentSelection !== null) {
									editingAreaRange = currentDocument.body.createTextRange();
									editingAreaRange.moveToElementText(editingArea);
									isWithinEditor = editingAreaRange.inRange(currentSelection);

									hasSelectedText = currentSelection.text !== null && currentSelection.text !== '';
								}

								// Check if it is safe to save by verifying that the window isn't:
								// 1. out of focus
								// 2. has text selected AND the selected text is within the editing area
								//
								// On IE 8-10, if BOTH #1 and #2 are true, CKEDITOR.dom.text's getLength() method throws "Invalid argument" errors
								// because the CKEDITOR.dom.text.$ DOM element looks like a proper Javascript object, but it isn't backed by a real Javascript object.
								// So when its attributes get accessed, an "Invalid argument" error pops up.
								// For example, getLength()'s "this.$.nodeValue.length" will generate an error because nodeValue is being accessed.
								isSafe = canSaveFunction() && saveButtonEnabled && !( !currentDocument.hasFocus() && hasSelectedText && isWithinEditor );
							} else {
								isSafe = canSaveFunction();
							}

						} catch (er) {
							// error occurred while trying to see if it is safe to save.
							// so we assume that it isn't safe
							MP_Util.LogWarn("Assuming that it is not safe to auto save: " + er.message);
						}

						// check to see if the user has hit the idle limit and that it is safe to save
						if (isSafe && (new Date()).getTime() - lastActivityTime >= AUTOSAVE_IDLE_THRESHOLD) {
							// reset the last activity time
							lastActivityTime = 0;

							// perform the save action, if there's anything to save
							if (editorInstance.checkDirty()) {
								editorInstance.save();
							}
						} else {
							// the user is still typing, we will check again 1 second later
							timeoutId = window.setTimeout(autoSaveTimer, 1000);
						}
					};


                    /**
                     * Expose the autosave version of get data, which accounts for place holder texts. 
                     *
                     */
                    editorInstance.getAutosaveData = function () {
                    	return getData(editorInstance);
                    };

					/**
					 * Define and expose a save function on the editor so that external parties can trigger a save operation.
					 *
					 * Usage:
					 *    myEditorInstance.save(navCallBack)
					 *
					 *    @param navCallBack
					 *        An optional reference to the function to be called when the save operation has been completed.
					 *        It is a mechanism that will allow the caller know if the save operation was successful or not.
					 *    If the save operation was successful, a string of "S" will be passed to the callback function.
					 *    Otherwise, a string of "F" would be passed to the callback function.
					 */
					editorInstance.save = function (navCallBack) {
						var contentData = '';

						//Call the pre-save function to preform any processing required before saving.
						preSaveFunction();

						contentData = getData(editorInstance);

						//Call save function
						savefunction(contentData, function (callbackStatus) {
							var currentContent = '';
							saveButton = $('#' + container.id + ' button.autosave.save');
							//Call save-is-done-callback function
							if (callbackStatus == "S") {
								// check what the content looks like now
								// (the user could have added content while we were saving)
								currentContent = getData(editorInstance);

								//If the user hasn't added more content, we can safely reset the dirty flag
								if (currentContent === contentData) {
									//Disable the save button
									saveButton.attr('disabled', 'disabled');
									//Reset dirty flag on the editor as well as external dirty data frameworks
									e.editor.resetDirty();
									e.editor.saveEditorSnapshot();
									if (resetDirtyFunction) {
										resetDirtyFunction();
									}
								}

								//Call the callback function, if any
								if (navCallBack) {
									navCallBack("S");
								}
							}
							else {
								if (navCallBack) {
									navCallBack("F");
								}
							}
						});
					};
					var editorTextArea = $(container).find(".cke_wysiwyg_div");
                    /*
                    * Hide CK Editor save button if 'isSaveButtonEnabled' is set to false.
                    * This has to be set from the component where save button needs to be hidden.
                    * By default this is true and CKEditor save button is displayed.
                    */
                    if(editorInstance.isSaveButtonEnabled !== undefined && editorInstance.isSaveButtonEnabled){
                        $(container).find(".cke_inner").append('<button class="autosave save" type="button" disabled="disabled" value="Save">' + (editor.lang.autosave.autosave.save_button) + '</button>');
                        saveButton = $('#' + container.id + ' button.autosave.save');
                        //Go ahead and add the last save text so the save button will float correctly
                        $(saveButton).after('<div class="last-saved-text">&nbsp;</div>');

                        // attach listener to save button to call the save function
                        saveButton.click(function () {
                            // call save on the editor, without any call back functions
                            editorInstance.save();
                        });
                    }
					editorTextArea.keyup(function () {
						window.setTimeout(dirtyEventHandler, 0);
						clearTimeout(pollingTimeout);
						pollingTimeout = setTimeout(poll, POLL_INTERVAL);
					});
					editorTextArea.keyup(activityHandler);
					//Listen for the completion of spellcheck. It can potentially alter dirty state, so we need
					//to update it just in case.
					editorInstance.on('spellCheckComplete', dirtyEventHandler);
					editorInstance.on('saveSnapshot', activityHandler);
					editorInstance.on('afterCommandExec', activityHandler);

					// clean up when the instance is destroyed
					editorInstance.on('destroy', function () {
						// clear timeout
						window.clearTimeout(timeoutId);
						clearTimeout(pollingTimeout);
					});

					/**
					 * This method will check the contents of CKEditor since the last call and compare it with the
					 * current contents. If the content has changed, then activity has occurred and the activityHandler
					 * method will be called. The comparison first checks the length of the strings. If the length
					 * is the same, then we perform a more expensive string comparison operation.
					 */
					function checkActivity() {
						var ckeditorContent = filterPlaceholder(editableContent.innerHTML);
						if (ckeditorContent.length !== dataSinceLastActivity.length || ckeditorContent !== dataSinceLastActivity) {
							activityHandler();
							dataSinceLastActivity = ckeditorContent;
						}
					}

					/**
					 * This method acts as a polling loop that occurs every 2000 milliseconds (2 seconds). It will
					 * perform a check for activity as well as call the dirtyEventHandler to ensure the save button
					 * will enable if dragon dictation is being utilized.
					 */
					function poll() {
						checkActivity();
						dirtyEventHandler();
						pollingTimeout = setTimeout(poll, POLL_INTERVAL);
					}

					//When the user focuses on the instance of CKEditor, start polling the contents.
					editorInstance.on('focus', function () {
						pollingTimeout = setTimeout(poll, POLL_INTERVAL);
					});
					//When the user leaves focus of this instance of CKEditor, quit polling the contents.
					editorInstance.on('blur', function () {
						checkActivity();
						dirtyEventHandler();
						clearTimeout(pollingTimeout);
					});
				});	// end on instanceReady

				editor.on('saveSnapshot', dirtyEventHandler);

				editor.on('afterCommandExec', dirtyEventHandler);

			}	// end init
		});
})();

/******************************************************************************
/ Description:   AutoTextPluginHelper                                         /
-------------------------------------------------------------------------------
Mod Date         Engineer                Comment
--- -----     --------------------    -----------------------------------------
000 02/12     Adilson M. Ribeiro      Initial Creation
001 03/12     Adilson M. Ribeiro      Manage Auto Text from Toolbar
002 03/12     Vinod Sankaranarayanan  Added logic for autoscroll & fixed defect
*******************************************************************************/

function AutoTextPluginHelper() {

    /////////////////////////////////////////
    //************    PRIVATE    ************
    /////////////////////////////////////////

    // Array of words that match the abbreviation
    var m_arrAbbreviationList = null;

    // Array of delimiters to mark the start/end of an abbreviation position
    var m_arrDelimiters = ['\r', '\n', '\t', ' '];

    var m_nItemPosition = -1;
    var m_nMaxWordLength = 0;
    var m_nScrollbarWidth = 10;

    // This drop menu is shared between all helpers in a multi-editor scenario
    var m_oDropMenu = null;

    var m_sElementId = null;

    // Initialize dropdown colors in initAutoText.  If init here when minified the DDCOLOR object won't be
    // initialized yet.
    var m_colorTextDefault = null;
    var m_colorTextHighlighted = null;
    var m_colorBackgroundDefault = null;
    var m_colorBackgroundHighlighted = null;
    var m_sFontFace = "";

    // Minimum menu size in case of extreme cases
    var m_nMinimumMenuSize = 5;

    // approx menu element height
    var m_nMenuElementHeight = 20;

    // approx amount of scrolling
    var m_nScrollOffset = 15;

    // flag that indicates whether the plugin is enabled/disabled
    var m_bIsPluginEnabled = false;

    // the current zoom ratio
    var m_fZoomRatio = null;

    //////////////////////////////////////////////////////////////////////////////////
    /// \Function name    addWord
    /// \Brief            Add a word to the dropdown menu display list
    ///                   Attaches onmouseover, onmouseout and onclick events to each
    ///                   <div> element inserted
    ///
    /// \Parameter        oAutoTextHelper - this object so that private methods have
    ///                   access to the public ones
    /// \Parameter        sWord - word to be added to the display list
    //////////////////////////////////////////////////////////////////////////////////
    function addWord(oAutoTextHelper, sWord) {

        var oWord = document.createElement("div");
        oWord.style.cursor = 'default';
        oWord.appendChild(document.createTextNode(sWord));

        // attach events to listen for inside the dropdown element
        oWord.onclick = function () { oAutoTextHelper.onPopupClick(this); }
        oWord.ondblclick = function () { oAutoTextHelper.onPopupDblClick(this); }
        oWord.unselectable = 'on';
        oWord.onselectstart = function() { return false };

        m_oDropMenu.appendChild(oWord);

        // Set the default font to the dropdown
        m_oDropMenu.style.fontFamily = m_sFontFace;
        return oWord;
    }

    //////////////////////////////////////////////////////////////////////////////////
    /// \Function name    clearDropMenu
    /// \Brief            loop and remove all childnodes from the dropdown menu element
    //////////////////////////////////////////////////////////////////////////////////
    function clearDropMenu() {
        while (m_oDropMenu.hasChildNodes())
            m_oDropMenu.removeChild(m_oDropMenu.firstChild);

        m_oDropMenu.style.height = "auto";
        m_oDropMenu.style.width = "auto";
    }

    //////////////////////////////////////////////////////////////////////////////////
    /// \Function name    getAutoTextWords
    /// \Brief            Call win32 to get list of ALL words matching the abbreviations
    ///                   Note: Win32 returns words sorted alphabetically (a-z)
    ///
    /// \Returns          true - if new array of words matched the abbreviation
    ///                   false - if no matching result is returned from win32
    ///
    /// \Parameter        oAutoTextHelper - this object so that private methods have
    ///                   access to the public ones
    //////////////////////////////////////////////////////////////////////////////////
    function getAutoTextWords(oAutoTextHelper) {
        var rangeAbbreviation = oAutoTextHelper.getAbbreviationRange();
        if (!rangeAbbreviation)
            return false;

        var sText = rangeAbbreviation.text;

        // simply return if text is empty
        if (DDCOMMON.isEmpty(sText))
            return false;

        // call win32 to get the list matching the abbreviation
        m_arrAbbreviationList = CKEDITOR.AutoTextHelper.GetAbbreviations(sText);

        // If no matches found, hide the dropdown div
        if (DDCOMMON.isEmpty(m_arrAbbreviationList)) {
            setVisible(oAutoTextHelper, "hidden");
            m_nItemPosition = -1;
            return false;
        }

        // convert JSON string to an array object
        m_arrAbbreviationList = JSON.parse(m_arrAbbreviationList);

        return true;
    }

    /////////////////////////////////////////////////////////////////////////////
    /// \Function name      getElementText
    /// \Brief              Gets the text from the current element
    ///
    /// \Parameter          element - the source element
    ///
    /// \Returns            string
    /////////////////////////////////////////////////////////////////////////////
    function getElementText(oElement) {
        if (null == oElement)
            return "";

        // get the text from the element and replace all nbsp's with white spaces
        return oElement.innerText.replace(/&nbsp;/g, ' ');
    }

    /////////////////////////////////////////////////////////////////////////////
    /// \Function name      getLeftText
    /// \Brief              returns the text to the left of the cursor position
    ///
    /// \Parameter          sText - the current text
    /// \Parameter          nCurPos - the current cursor position
    ///
    /// \Returns            string
    /////////////////////////////////////////////////////////////////////////////
    function getLeftText(sText, nCurPos) {
        return sText.substring(getStartingPos(sText, nCurPos), nCurPos + 1);
    }

    /////////////////////////////////////////////////////////////////////////////
    /// \Function name      getStartingPos
    /// \Brief              Get the start position of the text before a delimiter
    ///
    /// \Parameter          sText - the text to iterate through to get start position
    /// \Parameter          nIdx - the current cursor position
    ///
    /// \Returns            number
    /////////////////////////////////////////////////////////////////////////////
    function getStartingPos(sText, nIdx) {
        // loop thru each char until a delimiter is found
        var nLength = sText.length;
        while (nIdx >= 0 && nIdx < nLength) {
            var ch = sText.charAt(nIdx);
            if (DDCOMMON.contains(m_arrDelimiters, ch))
                break; // found the delimiter!

            nIdx--;
        }
        return nIdx;
    }

    /**
     * Inserts HTML text into the given text range, replacing any previous text and HTML elements in
     * the range.
     * @param {AutoTextPluginHelper}    oAutoTextHelper
     * @param {string}                  sAbbreviation       The abbreviation for the auto-text phrase to enter
     */
    function insertText(oAutoTextHelper, sAbbreviation) {
        if (!oAutoTextHelper || DDCOMMON.isEmpty(sAbbreviation))
            return;

        // begin SLA Timer
        var hTimerHandle = CKEDITOR.DocUtilsHelper.StartSLATimer(g_sDYNDOC_SLA_TIMER_USR_EXECUTE_AUTOTEXT_DOCUMENT);

        // try-catch to simplify error-handling and stopping the SLA timer
        var editor = oAutoTextHelper.m_oEditor;
        var componentData = {};
        try {
            // Fire the "saveSnapshot" before inserting an autotext.
            editor.fire('saveSnapshot');

            // Check if spellcheck is already enabled; if not, don't re-enable it afterwards.
            var bSpellCheckWasEnabled = editor.isSpellCheckEnabled && editor.isSpellCheckEnabled();
            if (editor.disableSpellCheck)
                editor.disableSpellCheck();

            // Call win32 to get the HTML template text matching the selected abbreviation
            // NOTE:  This can interrupt JavaScript execution to show a confirmation dialog
            // NOTE:  This dialog can mess up the current selection; therefore we save the
            //        selection before showing the dialog
            var selectedRange = editor.document.$.selection.createRange();   // Save selection

            var autoTextNode = executeAutoText(sAbbreviation, componentData);
            if (!autoTextNode)
                return;
            if (selectedRange.moveStart)
                selectedRange.select(); // Restore selection

            // No other handlers can be invoked in between the time that this range
            // is obtained and the time that HTML is inserted.  Otherwise, the
            // range could become invalidated and could wipe out text that is
            // not the abbreviation.

            if (window.getSelection) {
                var rangeAbbreviation = oAutoTextHelper.getAbbreviationRange2();
                if (!rangeAbbreviation)
                    throw 'could not get abbreviation range';
            }
            else {
                var rangeAbbreviation = oAutoTextHelper.getAbbreviationRange();
                if (null == rangeAbbreviation || !rangeAbbreviation.parentElement().isContentEditable)
                    throw 'could not get abbreviation range';

                // Sanity check
                // Make sure the range text does not contain whitespace.  If it does, the abbreviation range is inaccurate.
                if (sAbbreviation.indexOf(rangeAbbreviation.text) !== 0 || /\s/gi.test(rangeAbbreviation.text))
                    throw 'range is invalid';
            }

            // Insert html into the note if not empty
            if (!DDCOMMON.isEmpty(autoTextNode.getHtml())) {
                if (window.getSelection)
                    rangeAbbreviation.deleteContents();
                else
                    rangeAbbreviation.text = '';

                var selection = editor.getSelection(true);
                var ckerange = selection.getRanges()[0];
                autoTextNode.addClass('autotext_wrapper');
                // Remove white-space:pre-wrap from auto-text HTML
                DDCOMMON.removeAllPreWrap(autoTextNode.$);
                ckerange.insertNode(autoTextNode);
                // insert node doesnt handle scrolling. Hence, explicitly scroll to the 
                // position where the auto text is inserted. CR 1-10943620721.
                autoTextNode.scrollIntoView();

                var childCount = autoTextNode.getChildCount();
                if (childCount) {
                    var SELECTOR = hasNewApi() ? '> table:last-child' : '.blocktext > span > table:last-child';
                    if ($(autoTextNode.$).find(SELECTOR).length) {
                        $(autoTextNode.$).append('&nbsp;');
                        // IE8 will throw exception if trying to reference the parentNode of a text that
                        // has been removed.  Just allow selection to go after the &nbsp; for old IE.
                        var bOldIE = CKEDITOR.env.ie && CKEDITOR.env.version < 9;
                        if (!bOldIE) {
                            // Position the cursor before the &nbsp;
                            // This must be in a setTimeout for the `select` call to work
                            var nbsp = autoTextNode.$.lastChild;
                            setTimeout(function() {
                                if (!document.body.contains(nbsp.parentNode))
                                    return;
                                var ckerange = editor.createRange();
                                ckerange.moveToPosition(new CKEDITOR.dom.text(nbsp), CKEDITOR.POSITION_BEFORE_START);
                                ckerange.select();

                                editor.fire('updateSnapshot');  // Make sure updated cursor position is in the snapshot
                            }, 0);
                        }
                    }
                    else {
                        // Handle IE rendering I-beam in the wrong place. Else the invalid selection can causes unexpected behavior like 
                        // moving the cursor up one line above the auto text instead of next line when enter is pressed post auto text insertion.
                        // Testing Considerations: Press enter or do undo/redo after the auto text insertion.
                        var lastNode = autoTextNode.getChild(childCount - 1);
                        ckerange.setStartAt(lastNode, CKEDITOR.POSITION_BEFORE_END);
                        ckerange.collapse(true);
                        ckerange.select();
                    }
                }

                autoTextNode.remove(true);
            }
            else {
                // Remove the abbriviation if autotext retruns null
                if (window.getSelection)
                    rangeAbbreviation.deleteContents();
                else
                    rangeAbbreviation.text = '';
            }

            // Fire the "saveSnapshot" after inserting an autotext.
            editor.fire('saveSnapshot');
            editor.fire('afterExecutingAutoText');
        }
        catch (e) {
            var message = e.message || e;
            DocHandleError('AutoTextPluginHelper::insertText:  ' + message + ' (Abbreviation:  ' + sAbbreviation + ')', 'DynDocCKEditor');
        }
        finally {
            if (bSpellCheckWasEnabled && editor.enableSpellCheck)
                editor.enableSpellCheck(true);

            //Prepare the Metadata JSON with required values
            var jsonMetadata = {};
            jsonMetadata[g_sTIMERPROP_META01] = sAbbreviation;
            var sMetadata2 = "HTML FT:" + componentData.LONG_BLOB_REFERENCE + "|ST:" + componentData.CODE_VALUE + "|TT:"
                    + componentData.CLINICAL_NOTE_TEMPLATE + "|T:" + componentData.DATA_TOKEN + "|DL:" + componentData.NOTE_PHRASE_DROP_LIST;
            jsonMetadata[g_sTIMERPROP_META02] = sMetadata2;

            //Convert JSON Object to String
            var sMetadataJson = null;
            sMetadataJson = JSON.stringify(jsonMetadata);
			
            if(typeof CKEDITOR.DocUtilsHelper.StopSLATimerWithMetaData !== 'undefined') {
                //Stop Timer and pass the necessary metadata
                CKEDITOR.DocUtilsHelper.StopSLATimerWithMetaData(g_sDYNDOC_SLA_TIMER_USR_EXECUTE_AUTOTEXT_DOCUMENT, hTimerHandle, sMetadataJson);
            }
            else {
                CKEDITOR.DocUtilsHelper.StopSLATimer(g_sDYNDOC_SLA_TIMER_USR_EXECUTE_AUTOTEXT_DOCUMENT, hTimerHandle);
            }

        }
    }

    //////////////////////////////////////////////////////////////////////////////////
    /// \Brief            Sets the foreground/background color for the given element's
    ///                   position inside the dropdown
    ///
    /// \Parameter        nPosition - position of the current selected element
    /// \Parameter        bgcolor - background color to set
    /// \Parameter        fgcolor - foreground color to set
    //////////////////////////////////////////////////////////////////////////////////
    function setColor(nPosition, bgcolor, fgcolor) {
        if (null == m_oDropMenu || m_oDropMenu.children.length <= 0)
            return;

        if (nPosition > -1 && nPosition <= m_arrAbbreviationList.length - 1) {
            m_oDropMenu.children[nPosition].style.background = bgcolor;
            m_oDropMenu.children[nPosition].style.color = fgcolor;
        }
    }

    //////////////////////////////////////////////////////////////////////////////////
    /// \Brief            Sets the visibility style (hidden/visible) of the element
    ///
    /// \Parameter        oAutoTextHelper - this object so that private methods have
    ///                   access to the public ones
    /// \Parameter        sFlag - flag indicating whether to show or hide the element
    //////////////////////////////////////////////////////////////////////////////////
    function setVisible(oAutoTextHelper, sFlag) {
        if (!m_oDropMenu)
            return;

        // Don't mess with ranges if the drop menu is already hidden,
        // and we are setting it to be hidden
        if (sFlag === 'hidden' && m_oDropMenu.style.visibility === sFlag)
            return;

        m_oDropMenu.attributes.editorName.value = oAutoTextHelper.m_oEditor.name;

        var selection = oAutoTextHelper.m_oEditor.getSelection();
        if (!selection || !selection.getStartElement()) {
            return;
        }

        var display = '';
        var rangeParent = selection.getStartElement();

        if (typeof rangeParent.$ !== 'undefined') {
            display = rangeParent.$.style.display;

            // ensure that the element is visible before calling focus on it
            if (CKEDITOR.env.ie && CKEDITOR.env.version < 9 && display !== 'none') {
                rangeParent.$.setActive();
            }
        }

        if ('hidden' === sFlag) {
            if (null != oAutoTextHelper.m_oAutoTextTimout) {
                clearTimeout(oAutoTextHelper.m_oAutoTextTimout);
                oAutoTextHelper.m_oAutoTextTimout = null;
            }

            m_oDropMenu.style.visibility = sFlag;
            return;
        }
        else if ('visible' === sFlag) {

            var iEditorOffsetTop = $(oAutoTextHelper.m_oEditor.editable().$).offset().top;
            var iEditorHeight = oAutoTextHelper.m_oEditor.editable().$.clientHeight;

            // "editor" range as opposed to window range that is assigned to oRange above
            var oEditorRange = oAutoTextHelper.m_oEditor.document.$.selection.createRange();
            if (!oEditorRange.moveStart) {
                DocHandleError('setVisible - Range is not TextRange', 'DynDocCKEditor', '', '');
                return;
            }

            oEditorRange.moveStart('character', -1);

            if (isCursorInEditableElement(oEditorRange, iEditorOffsetTop, iEditorHeight)) {
                positionListBox(oAutoTextHelper, oEditorRange);
                // setting the menu items background and foreground colors as white and black
                for (var i = 0; i < m_oDropMenu.childNodes.length; i++) {
                    setColor(i, m_colorBackgroundDefault, m_colorTextDefault);
                }
                m_oDropMenu.style.visibility = sFlag;
            }
            else
                m_oDropMenu.style.visibility = 'hidden';
        }
    }


    /**
     * Gets the current window height WRT zoom.
     *
     * @returns {number}
     */
    function getCurrentWindowHeight() {
        return $(window).height() * m_fZoomRatio;
    }

    /**
     * Gets the current window height WRT zoom.
     *
     * @returns {number}
     */
    function getCurrentWindowWidth() {
        return $(window).width() * m_fZoomRatio;
    }

    /**
     * Determines is a list box requires a scroll bar to be within view.
     *
     * @param iPopupHeight - the height of the auto text list box.
     * @param iPadding     - the padding used to keep the list box off the edges.
     * @returns {boolean}
     */
    function scrollBarRequired(iPopupHeight, iPadding) {
        return (iPopupHeight + 2 * iPadding) > (getCurrentWindowHeight());
    }

    /**
     * Determines if the cursor is above the top half of the viewable editing area.
     *
     * @param iCursorTop  - distance to top of the editor.
     * @param offsetTop   - offset if viewport is containes in an iframe.
     * @returns {boolean}
     */
    function cursorIsAboveTopHalfOfViewport(iCursorTop, offsetTop) {
        return iCursorTop > (offsetTop + getCurrentWindowHeight() / 2);
    }

    /**
     * Determines if the auto text phrase list box extends beyond the viewable editing area.
     *
     * @param iCursorLeft    - distance to the cursor from the left.
     * @param iPopupWidth    - height of the popup.
     * @param iPadding       - the padding used to keep the list box off the edges.
     * @param offsetLeft     - offset left if viewport is contained in an iframe.
     * @returns {boolean}
     */
    function listBoxExtendsBeyondViewportWidth(iCursorLeft, iPopupWidth, iPadding, offsetLeft) {
        return (iCursorLeft + iPopupWidth * m_fZoomRatio + 2 * iPadding) > (offsetLeft + getCurrentWindowWidth());
    }

    /**
     * Positions the auto text list box above the cursor.
     *
     * @param iCursorTop   - distance to top of the editor.
     * @param iPopupHeight - the height of the auto text list box.
     * @param iPadding     - the padding used to keep the list box off the edges.
     */
    function positionListBoxAboveCursor(iCursorTop, iPopupHeight, iPadding) {
        m_oDropMenu.style.top = ((iCursorTop - iPopupHeight - iPadding) / m_fZoomRatio) + $(window).scrollTop() + "px";
    }

    /**
     * Positions the auto text list box below the cursor.
     *
     * @param iCursorTop    - distance to top of the editor.
     * @param iPadding      - the padding used to keep the list box off the edges.
     * @param iCursorHeight - the bounding height of the text.
     */
    function positionListBoxBelowCursor(iCursorTop, iPadding, iCursorHeight) {
        m_oDropMenu.style.top = (iCursorTop + iCursorHeight + iPadding) / m_fZoomRatio + $(window).scrollTop() + "px";
    }

    /**
     * Positions the list box to the right of the cursor.
     *
     * @param iCursorLeft - distance to the cursor from the left.
     * @param iPadding    - the padding used to keep the list box off the edges.
     */
    function positionListBoxToRightOfCursor(iCursorLeft, iPadding) {
        m_oDropMenu.style.left = iCursorLeft / m_fZoomRatio + iPadding + $(window).scrollLeft() + "px";
    }

    /**
     * Positions the list box adjacent to the right of the viewable editing area.
     *
     * @param offsetLeft     -  offset left if viewport is contained in an iframe.
     * @param iPopupWidth    - the width of the auto text list box.
     * @param iPadding       - the padding used to keep the list box off the edges.
     */
    function positionListBoxAdjacentToRightOfViewport(offsetLeft, iPopupWidth, iPadding) {
        m_oDropMenu.style.left = offsetLeft - iPopupWidth - 2 * iPadding + getCurrentWindowWidth() / m_fZoomRatio + "px";
    }

    /**
     * Creates a scroll bar within the list box.
     *
     * @param iPadding - the padding used to keep the list box off the edges.
     */
    function createListBoxScrollBar(iPadding) {
        var bottomPaddingMultiplier = 5;
        var adjustedPadding = (iPadding * bottomPaddingMultiplier) * m_fZoomRatio;
        var currWindowHeight = getCurrentWindowHeight();

        $(m_oDropMenu).css({
            'height': currWindowHeight / m_fZoomRatio - adjustedPadding + "px",
            'width': m_nMaxWordLength + (2 * iPadding + m_nScrollbarWidth) * m_fZoomRatio + "px",
            'top': iPadding + ($(window).scrollTop() * m_fZoomRatio) + "px",
            'overflow-y': "scroll"
        });
    }

    /**
     * Positions the list box near the top of the viewport.
     *
     * @param iPadding - the padding used to keep the list box off the edges.
     */
    function placeListBoxNearTopOfViewport(iPadding) {
        m_oDropMenu.style.top = $(window).scrollTop() + (iPadding * m_fZoomRatio) + "px";
    }

    /**
     * Places the auto text list box near the bottom of the viewport.
     *
     * @param iViewportHeight - the height of the viewable editing area.
     * @param iPopupHeight    - the height of the auto text list box
     * @param iPadding        - the padding used to keep the list box off the edges.
     */
    function placeListBoxNearBottomOfViewport(iViewportHeight, iPopupHeight, iPadding) {
        m_oDropMenu.style.top = iViewportHeight - iPopupHeight - iPadding + "px";
    }

    /**
     * Positions the auto text list box according to scroll distance and
     * adds a buffer so the list box does not sit on top of the cursor.
     */
    function spaceListBoxFromCursor() {
        var buffer = 10;
        m_oDropMenu.style.left = parseInt(m_oDropMenu.style.left, 10) + buffer + $(window).scrollLeft() + "px";
    }

    /**
     * Determines if a cursor is inside an editor.
     *
     * @param oEditorRange    - the text range the user is in.
     * @param editorOffsetTop - the offset top of the current editor.
     * @param editorHeight    - the height of the current editor.
     * @returns {boolean}
     */
    function isCursorInEditableElement(oEditorRange, editorOffsetTop, editorHeight) {
        m_fZoomRatio = DDCOMMON.getZoomRatio(); // refresh the zoom ratio

        // getBoundingClientRect().height doesn't exist in IE8.
        if (CKEDITOR.env.ie && CKEDITOR.env.version < 9) {
            var clientRect = oEditorRange.getBoundingClientRect();
            var cursorMiddle = oEditorRange.offsetTop + ((clientRect.bottom - clientRect.top) / 2);
        }
        else var cursorMiddle = oEditorRange.offsetTop + oEditorRange.getBoundingClientRect().height / 2;

        var viewableWindowHeight = getCurrentWindowHeight();
        var editorOffsetTopWithScroll = (editorOffsetTop - $(window).scrollTop()) * m_fZoomRatio;
        var editorOffsetBottomWithScroll = editorOffsetTopWithScroll + editorHeight * m_fZoomRatio;
        // the editor can be partially in view, find the min bottom
        var minBottom = viewableWindowHeight < editorOffsetBottomWithScroll ? viewableWindowHeight : editorOffsetBottomWithScroll;

        return (cursorMiddle > editorOffsetTopWithScroll && cursorMiddle < minBottom);
    }

    /**
     * Determines if a the auto text list drops below the viewable area.
     *
     * @param popupBottom - distance to the bottom of the popup
     * @returns {boolean}
     */
    function listBelowViewableEditor(popupBottom) {
        return popupBottom > (getCurrentWindowHeight());
    }

    /**
     * Determines if the auto text list would rise above the viewable area.
     *
     * @param cursorTop  - distance to the top of the cursor.
     * @returns {boolean}
     */
    function listAboveViewableEditor(cursorTop) {
        return cursorTop < 0;
    }

    /**
     * Determines if a container of editor(s) is scrollable.
     *
     * @returns {boolean}
     */
    function isViewportScrollable() {
        return $("body").height() > $(window).height();
    }

    /**
     * Positions a scrollable list box according.
     *
     * @param iCursorLeft
     */
    function positionScrollableListBox(iCursorLeft) {
        var transform = iCursorLeft / m_fZoomRatio - parseInt(m_oDropMenu.style.width, 10) - 20;
        var scrollLeft = $(window).scrollLeft() * +m_fZoomRatio;

        if (scrollLeft) {
            if (transform < scrollLeft)
                m_oDropMenu.style.left = scrollLeft;
        }
        else {
            if (transform < 0)
                m_oDropMenu.style.left = "0px";
            else m_oDropMenu.style.left = transform + "px";
        }
    }

    /**
     * Positions the list box.
     *
     * @param oAutoTextHelper - the auto text helper object.
     * @param oEditorRange    - the text range the cursor is in.
     */
    function positionListBox(oAutoTextHelper, oEditorRange) {
        var iCursorTop = oEditorRange.offsetTop;
        var iCursorLeft = oEditorRange.offsetLeft + 10; //additional 10px to adjust to the right of the cursor

        // Number of pixels to keep the popup away from the cursor and boundaries.
        // Without the padding the popup's border is subject to being clipped.
        var iPadding = 2;

        // Popup dimensions
        var iPopupHeight = $(m_oDropMenu).outerHeight();
        var iPopupWidth = $(m_oDropMenu).outerWidth();

        var iframe = oAutoTextHelper.m_oEditor.getIframeElement && oAutoTextHelper.m_oEditor.getIframeElement();
        var offsetLeft = 0;
        var offsetTop = 0;
        if (iframe) {
            var iframeOffset = $(iframe).offset();
            offsetLeft = iframeOffset.left;
            offsetTop = iframeOffset.top;

            iCursorLeft += iframeOffset.left;
            iCursorTop += iframeOffset.top;
        }

        // Default to no scrollbar
        m_oDropMenu.style.height = "auto";
        m_oDropMenu.style.overflowY = "hidden";
        m_oDropMenu.style.overflowX = "hidden";

        // variables to help with zooming calculations
        var selection = oAutoTextHelper.m_oEditor.getSelection();
        var iBoundingHeight = getBoundingHeight(selection) * m_fZoomRatio;
        iPopupHeight *= m_fZoomRatio;

        // Calculate the top coordinate
        var bPositionAbove = cursorIsAboveTopHalfOfViewport(iCursorTop, offsetTop);
        if (bPositionAbove)
            positionListBoxAboveCursor(iCursorTop, iPopupHeight, iPadding);
        else positionListBoxBelowCursor(iCursorTop, iPadding, iBoundingHeight);

        // Calculate the left coordinate
        var bPositionRight = !listBoxExtendsBeyondViewportWidth(iCursorLeft, iPopupWidth, iPadding, offsetLeft);
        if (bPositionRight)
            positionListBoxToRightOfCursor(iCursorLeft, iPadding);
        else
            positionListBoxAdjacentToRightOfViewport(offsetLeft, iPopupWidth, iPadding);

        // Adjust scroll box as necessary
        if (scrollBarRequired(iPopupHeight, iPadding)) {
            createListBoxScrollBar(iPadding);
            placeListBoxNearTopOfViewport(iPadding);

            if (bPositionRight)
                spaceListBoxFromCursor();
            else
                positionScrollableListBox(iCursorLeft);
        }
        else if (isViewportScrollable()) {
            var iScrollPopupTop = iCursorTop - iPopupHeight - iPadding;
            var iScrollPopupBottom = iCursorTop + iPopupHeight + iPadding + iBoundingHeight;

            if (((bPositionAbove && listAboveViewableEditor(iScrollPopupTop))
                || (!bPositionAbove && listBelowViewableEditor(iScrollPopupBottom)))) {

                if (!bPositionRight) {
                    // Flex so the dropdown doesn't sit on the cursor
                    // Additional 10 so it doesn't sit too close to the cursor
                    var iLeftBuffer = getCurrentWindowWidth() - iCursorLeft - 10;
                    m_oDropMenu.style.left = parseInt(m_oDropMenu.style.left, 10) - iLeftBuffer + "px";
                }

                placeListBoxNearTopOfViewport(iPadding);
                spaceListBoxFromCursor();
            }
        }
        else {
            var iNonScrollPopupTop = parseInt(m_oDropMenu.style.top, 10) - offsetTop;
            var iNonScrollPopupBottom = iNonScrollPopupTop + iPopupHeight;

            if (bPositionAbove && listAboveViewableEditor(iNonScrollPopupTop)) {
                // Keep the popup adjacent to the top of the screen
                placeListBoxNearTopOfViewport(iPadding);
            }
            else if (!bPositionAbove && listBelowViewableEditor(iNonScrollPopupBottom)) {
                // Keep the popup adjacent to the bottom of the screen
                placeListBoxNearBottomOfViewport(getCurrentWindowHeight(), iPopupHeight, iPadding);
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////////////
    /// \Function name    findStringWidth
    /// \Brief            Finds the width of a string in pixels using the default font
    ///
    /// \Parameter        string - The string to be checked
    //////////////////////////////////////////////////////////////////////////////////
    function findStringWidth(string) {
        var oDummy = $('<div>').text(string).css({
            position: 'absolute',
            'float': 'left',
            border: '1px solid',
            whiteSpace: 'nowrap',
            visibility: 'hidden',
            padding: '2px 2px 2px 2px',
            fontSize: '10pt',
            fontFamily: m_sFontFace
        }).appendTo($('body'));
        var width = oDummy.outerWidth();

        oDummy.remove();

        return width;
    }

    /**
     * @private
     * Computes the boundingHeight of the current selection.
     *
     * @param selection  - The current selection
     * @returns {number} - The bounding height of the selection
     */
    function getBoundingHeight(selection) {
        if (selection.getRanges().length > 0) {
            // the bounding height should flex along with the current font size.
            var currFont = selection.getStartElement().getComputedStyle('font-family');
            var currFontSize = selection.getStartElement().getComputedStyle('font-size');
            var currLineHeight = selection.getStartElement().getComputedStyle('line-height');

            // cannot get computed style of line-height since line-height can be "normal".
            // create a dummy element and get it's clientHeight prop.
            var dummyElement = $("<div>").text("M").css({
                'visibility': 'hidden',
                'font-size': currFontSize,
                'font-family': currFont,
                'line-height': currLineHeight,
                'position': 'absolute',
                'top': 0,
                'left': 0
            }).appendTo($('body'));

            var dummyElementClientHeight = parseInt(dummyElement[0].clientHeight, 10);
            dummyElement.remove();

            var paddingBottom = parseInt(selection.getStartElement().getComputedStyle('padding-bottom'), 10);
            var paddingTop = parseInt(selection.getStartElement().getComputedStyle('padding-top'), 10);

            return dummyElementClientHeight - paddingBottom - paddingTop;
        }
        else {
            // if no range exists
            return 0;
        }
    }

    function cleanHtml(html) {
        return typeof CKEDITOR.DocUtilsHelper.CleanHtml === 'undefined' ? CKEDITOR.DynDocHelper.CleanHtml(html, 1) : CKEDITOR.DocUtilsHelper.CleanHtml(html, 1);
    }

    /**
     * @private
     * Put attributes on top-level nodes
     * @param {HTMLElement} ancestor
     * @param {string}      className       Class name to put on each of the top-level nodes
     * @param {Object}      [attributes]    Attributes to put on each of the top-level nodes
     */
    function wrapComponentAttributes(ancestor, className, attributes) {
        function isNodeInline(node) {
            return node.nodeType === Node.TEXT_NODE || $(node).css('display') === 'inline';
        }
        function copyAttributes(element) {
            $(element).addClass(className).attr(attributes || {});
        }

        var wrapStart;
        for (var current = ancestor.lastChild; current; current = current.previousSibling) {
            if (isNodeInline(current)) {
                if (!wrapStart)  // This is the last (right-most) node to format
                    wrapStart = current;

                var isInlineBoundary = !current.previousSibling || !isNodeInline(current.previousSibling);
                if (isInlineBoundary) {
                    // Wrap the inline nodes from `current` to `wrapStart`
                    var wrapper = document.createElement('span');
                    current.parentNode.insertBefore(wrapper, current);
                    for (var appendNode = wrapStart, next = appendNode && appendNode.previousSibling; appendNode && appendNode !== wrapper; appendNode = next, next = next.previousSibling) {
                        wrapper.insertBefore(appendNode, wrapper.firstChild);
                    }
                    copyAttributes(wrapper);

                    current = wrapper;
                    wrapStart = undefined;
                }
            }
            else if (current.nodeType === Node.ELEMENT_NODE) {
                copyAttributes(current);
            }
        }
    }

    /**
     * @private
     * Create HTML that can be inserted into the note from a note phrase component
     * @param {INotePhraseComp} notePhraseComp
     * @param {object} componentData
     * @returns {string} Phrase HTML
     */
    function createComponentHtml(notePhraseComp, componentData) {
        var html = notePhraseComp.rtf;  // Ha, Gotcha!  RTF is actually HTML!
        html = $.trim(cleanHtml(html));

        var $component = $('<div>').html(html);

        switch (notePhraseComp.fKeyName) {
            case 'CODE_VALUE':
                wrapComponentAttributes($component[0], g_sCLASS_BLOCK_SMART_TEMPLATE, {
                    'dd:template_cki':          notePhraseComp.templateCKI,
                    'data-refresh-group-id':    CKEDITOR.DocUtilsHelper.GenerateGUID()
                });
                componentData.CODE_VALUE++;
                break;

            case 'DATA_TOKEN':
                wrapComponentAttributes($component[0], g_sCLASS_BLOCK_TOKEN, {
                    'dd:token_name': notePhraseComp.templateCKI,
                    'data-refresh-group-id':    CKEDITOR.DocUtilsHelper.GenerateGUID()
                });
                componentData.DATA_TOKEN++;
                break;

            case 'LONG_BLOB_REFERENCE':
                wrapComponentAttributes($component[0], 'blockformattedtext');
                componentData.LONG_BLOB_REFERENCE++;
                break;

            case 'CLINICAL_NOTE_TEMPLATE':
                wrapComponentAttributes($component[0], g_sCLASS_BLOCK_CN_TEMPLATE, {
                    'dd:template_cki': notePhraseComp.templateCKI
                });
                componentData.CLINICAL_NOTE_TEMPLATE++;
                break;

            case 'NOTE_PHRASE_DROP_LIST':
                if (notePhraseComp.dropList) { // DropList information is available, so put it on the element
                    $component.wrapInner('<a class="blockdroplist" dd:drop_list_uuid="' + notePhraseComp.dropList.UUID + '"></a>');
                } else { // DropList information is NOT available, but still wrap an element with class name blockdroplist, so that we can format/style it if we want to
                    $component.wrapInner('<a class="blockdroplist"></a>');
                }
                componentData.NOTE_PHRASE_DROP_LIST++;
                break;
        }

        return $component.html();
    }

    /**
     * Create an element than can be inserted into the note, containing valid HTML from the given note phrase
     *
     * NOTE:  The outer element itself is meant to be transient, and should not be left in the DOM
     * @param {INotePhrase} notePhrase
     * @param {object} componentData
     * @returns {HTMLElement}   The ancestor auto text element
     */
    function createNotePhraseContainer(notePhrase, componentData) {
        var $phrase = $('<div>');

        _.extend(componentData, {
            'CODE_VALUE': 0,
            'DATA_TOKEN': 0,
            'LONG_BLOB_REFERENCE': 0,
            'CLINICAL_NOTE_TEMPLATE': 0,
            'NOTE_PHRASE_DROP_LIST': 0
        });

        for (var i = 0, count = notePhrase.getCompCount(); i < count; i++) {
            var notePhraseComp = notePhrase.getComp(i);
            $phrase.append(createComponentHtml(notePhraseComp, componentData));
        }

        DDCOMMON.removeAllPreWrap($phrase[0]);

        return $phrase[0];
    }

    var hasNewApi = _.memoize(function() {
        var bHasCleanHtml = typeof CKEDITOR.DocUtilsHelper.CleanHtml !== 'undefined' || (typeof CKEDITOR.DynDocHelper !== 'undefined' && typeof CKEDITOR.DynDocHelper.CleanHtml !== 'undefined');
        var bHasNewAPI = bHasCleanHtml && typeof CKEDITOR.AutoTextHelper.getNotePhraseManager !== 'undefined';
        if (typeof CKEDITOR.DynDocHelper !== 'undefined')
            CKEDITOR.DynDocHelper.ReportDebugMsg(bHasNewAPI ? 'Using new AutoText API' : 'Using old AutoText API', window.PROJECT_NAME || 'DynDocCKEditor');
        return bHasNewAPI;
    });

    /**
     * Execute the auto text and create a container node for the auto text contents
     *
     * NOTE:  The outer element itself is meant to be transient, and should not be left in the DOM
     * @param {string} abbreviation
     * @param {object} componentData
     * @returns {CKEDITOR.dom.element} The ancestor element of the executed auto text, or null if the phrase could not be executed
     */
    function executeAutoText(abbreviation, componentData) {
        if (CKEDITOR.dPatientId && CKEDITOR.dChartEncounterId && hasNewApi()) {
            // New way
            var notePhrase;
            // The argument true passed into executeHtmlBlockedText2 will determine whether or not to enable drop lists in the executed auto text phrase
            // When enabled, the display of drop list components (after inserted into the note) will show as a link, with a triangle to the right
            if (typeof CKEDITOR.AutoTextHelper.getNotePhraseManager().executeHtmlBlockedText2 !== 'undefined')
                notePhrase = CKEDITOR.AutoTextHelper.getNotePhraseManager().executeHtmlBlockedText2(abbreviation, CKEDITOR.dPatientId, CKEDITOR.dChartEncounterId, true);
            else
                notePhrase = CKEDITOR.AutoTextHelper.getNotePhraseManager().executeHtmlBlockedText(abbreviation, CKEDITOR.dPatientId, CKEDITOR.dChartEncounterId);
            return notePhrase ? CKEDITOR.dom.element.get(createNotePhraseContainer(notePhrase, componentData)) : null;
        }
        else {
            // Fallback; to be removed at a later date
            var html = CKEDITOR.AutoTextHelper.ExecuteAutoText(abbreviation);
            if (!html)
                return null;

            var autoTextNode = new CKEDITOR.dom.element('div');
            autoTextNode.setHtml(html);
            return autoTextNode;
        }
    }

    /////////////////////////////////////////
    //************    PUBLIC     ************
    /////////////////////////////////////////

    return {

        m_oEditor: null,

        // Timer id of the async keystroke handler
        m_oAutoTextTimout: null,

        syncPosition: function () {
            if (this.isPopupVisible())
                this.evaluateAt();
        },

        /**
         * Calls win32 to get a list of matching abbreviation(s) Builds a separate dropMenu <div>
         * for each abbreviation Calculates the length of the longest abbreviation Hides/Shows the
         * dropMenu <div> when appropriate
         *
         * @deprecated
         */
        evaluateAt: function () {
            // If the auto text drop down is for a different editor than the one currently being manipulated,
            // hide it and reset the item position before continuing.
            if (m_oDropMenu.attributes.editorName.value != this.m_oEditor.name) {
                setVisible(this, "hidden");
                m_nItemPosition = -1;
            }

            var nPrevAbbreviations = 0;
            if (true == this.isPopupVisible()) {
                nPrevAbbreviations = m_arrAbbreviationList.length;
            }

            // Call win32 to get list of abbreviations matching the text inside the editor
            if (!getAutoTextWords(this)) {
                setVisible(this, "hidden");
                m_nItemPosition = -1;
                return;
            }

            // Limit number of phrases to put in the menu
            var bTruncate = m_arrAbbreviationList.length > 80;
            if (bTruncate)
                m_arrAbbreviationList.length = 80;

            var nNewAbbreviations = m_arrAbbreviationList.length;
            m_nMaxWordLength = 0;

            var rangeAbbreviationRange = this.getAbbreviationRange();

            if (rangeAbbreviationRange && rangeAbbreviationRange.text.length > 0) {
                if (nNewAbbreviations > 0) {
                    clearDropMenu();

                    for (var i = 0; i < nNewAbbreviations; ++i) {
                        // add word to the div element
                        var element = addWord(this, m_arrAbbreviationList[i]);
                        m_oDropMenu.appendChild(element);

                        // calculate max abbreviation length
                        var width = findStringWidth(m_arrAbbreviationList[i]);
                        if (width > m_nMaxWordLength)
                            m_nMaxWordLength = width;
                    }

                    if (bTruncate) {
                        var MORE = this.m_oEditor.lang.cernautotext.ABBREVIATION_LIMIT_TEXT;
                        m_nMaxWordLength = Math.max(m_nMaxWordLength, findStringWidth(MORE));
                        $('<div>').text(MORE).css('font-style', 'italic').appendTo(m_oDropMenu);
                    }

                    setVisible(this, "visible");

                    // Set focus on the first element in the list - zero base index
                    if (nPrevAbbreviations != nNewAbbreviations || -1 == m_nItemPosition)
                        m_nItemPosition = 0;

                    setColor(m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                }
                else {
                    setVisible(this, "hidden");
                    m_nItemPosition = -1;
                }
            }
            else {
                setVisible(this, "hidden");
                m_nItemPosition = -1;
            }
        },

        /**
         * Calls win32 to get a list of matching abbreviation(s) Builds a separate dropMenu <div>
         * for each abbreviation Calculates the length of the longest abbreviation Hides/Shows the
         * dropMenu <div> when appropriate
         */
        evaluateAt2:  function() {
            // If the auto text drop down is for a different editor than the one currently being manipulated,
            // hide it and reset the item position before continuing.
            if (m_oDropMenu.attributes.editorName.value != this.m_oEditor.name) {
                setVisible(this, "hidden");
                m_nItemPosition = -1;
            }

            var nPrevAbbreviations = 0;
            if (true == this.isPopupVisible()) {
                nPrevAbbreviations = m_arrAbbreviationList.length;
            }

            var rangeAbbrevition = this.getAbbreviationRange2();
            if (rangeAbbrevition) {
                var sAbb = CKEDITOR.AutoTextHelper.GetAbbreviations(rangeAbbrevition.toString());
                if (sAbb) {
                    var arrAbb = JSON.parse(sAbb);
                    m_arrAbbreviationList = arrAbb;
                    m_nMaxWordLength = 0;

                    if (arrAbb.length) {
                        clearDropMenu();

                        // Limit number of phrases to put in the menu
                        var bTruncate = arrAbb.length > 80;
                        if (bTruncate)
                            arrAbb.length = 80;

                        var $container = $('<div>');
                        arrAbb.forEach(function(sAbb) {
                            var element = addWord(this, sAbb);
                            $container.append(element);

                            var width = findStringWidth(sAbb);
                            m_nMaxWordLength = Math.max(m_nMaxWordLength, width);
                        }, this);
                        if (bTruncate) {
                            var MORE = this.m_oEditor.lang.cernautotext.ABBREVIATION_LIMIT_TEXT;
                            m_nMaxWordLength = Math.max(m_nMaxWordLength, findStringWidth(MORE));
                            $('<div>').text(MORE).css('font-style', 'italic').appendTo($container);
                        }
                        $container.appendTo(m_oDropMenu);
                        $container[0].removeNode(false);

                        // Set focus on the first element in the list - zero base index
                        if (nPrevAbbreviations != arrAbb.length || -1 == m_nItemPosition)
                            m_nItemPosition = 0;
                    }
                }
            }

            if (arrAbb && arrAbb.length) {
                setVisible(this, 'visible');
                setColor(m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
            }
            else {
                setVisible(this, 'hidden');
                m_nItemPosition = -1;
            }
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      saveFocusedElement
        /// \Brief              Saves the element that is focused on input events
        ///
        /// \Parameter          element - The input event srcElement
        ///
        /// \Returns            void
        /////////////////////////////////////////////////////////////////////////////
        saveFocusedElement: function (element) {
            m_sElementId = element.id;
        },

        /**
         * Gets the range the spans a part of an abbreviation at the current cursor position
         * @returns {TextRange} The range that spans the abbreviation at the current cursor position
         */
        getAbbreviationRange: function () {
            if (!m_sElementId)
                return null;

            var oElement = this.m_oEditor.document.$.getElementById(m_sElementId);
            if (!oElement)
                return null;

            // get the range
            var oRange = this.m_oEditor.document.$.selection.createRange();
            if (!oRange || typeof oRange.text === 'undefined' || oRange.text.length > 0)   // Meaning more than one char selected
                return null;

            // get the 'element' text - the whole thing, nothing less!
            var sElementText = getElementText(oElement);

            // get text to the left of the cursor position
            var nCursorPosition = DDCOMMON.getCursorPosition(oElement, oRange);
            var sTextLeft = CKEDITOR.tools.trim(getLeftText(sElementText, nCursorPosition));

            // move the range to the left until a delimiter is found
            for (var i = sTextLeft.length; i >= 1; i--) {
                var ch = sTextLeft.charAt(i);
                if (DDCOMMON.contains(m_arrDelimiters, ch)) {
                    break;
                }
                oRange.moveStart('character', -1);
            }

            return oRange;
        },

        /**
         * Gets the range the spans a part of an abbreviation at the current cursor position
         * @returns {Range} The range that spans the abbreviation at the current cursor position
         */
        getAbbreviationRange2:  function() {
            var sel = getSelection();
            if (sel.rangeCount === 0)
                return null;

            var range = sel.getRangeAt(0);

            var rangeAbbr = range.cloneRange();

            // Get starting node (the right part of the abbreviation in the document)
            var node = range.startContainer;
            if (node.nodeType === Node.ELEMENT_NODE) {
                if (range.startOffset === 0) {
                    // startContainer follows the node that contains the end of the abbreviation
                    node = DDCOMMON.getPreviousInlineTextnode(node);
                }
                else {
                    // Abbreviation starts within the startContainer
                    node = range.startContainer.childNodes[range.startOffset - 1];
                }
                if (node) {
                    // Get the last text node within the starting node
                    if (node.nodeType === Node.ELEMENT_NODE)
                        node = DDCOMMON.getLastTextNode(node);
                    else if (node.nodeType === Node.TEXT_NODE)
                        window.nothing;
                    else
                        node = null;
                }
            }
            if (!node)
                return null;

            // Go back through the DOM until delimiter is found (or we reach the end of the contenteditable)
            var text = '';  // Text that is the abbreviation
            for (; node && DDCOMMON.isNodeEditable(node); node = DDCOMMON.getPreviousInlineTextnode(node)) {
                // If `node` is the startContainer, Get the part of the startContainer that ends the abbreviation
                var t = node === range.startContainer ? node.nodeValue.substring(0, range.startOffset) : node.nodeValue;
                // Find the abbreviation delimiter (if it exists)
                var pos = DDCOMMON.searchLast(t, /\s/);
                if (pos >= 0) {
                    text = t.substring(pos + 1) + text;
                    rangeAbbr.setStart(node, pos + 1);
                    break;  // We found all of the abbreviation
                }
                else {
                    text = t + text;
                    rangeAbbr.setStartBefore(node);
                }
            }
            return rangeAbbr;
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      hideDropMenu
        /// \Brief              External method that hides the dropmenu
        /////////////////////////////////////////////////////////////////////////////
        hideDropMenu: function () {
            if (this.isPluginEnabled())
                setVisible(this, "hidden");
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      initAutoText
        /// \Brief              Call win32 to determine whether to enable/disable plugin
        ///                     Iff enable plugin, initialize the auto text components
        /////////////////////////////////////////////////////////////////////////////
        initAutoText: function () {
            // Call win32 to determine whether to enable/disable auto text plugin
            m_bIsPluginEnabled = (1 == CKEDITOR.AutoTextHelper.IsAutoTextEnabled());

            if (!m_bIsPluginEnabled)
                return;

            m_colorTextDefault = DDCOLOR.getFontColorDefault();
            m_colorTextHighlighted = DDCOLOR.getFontColorSelected();
            m_colorBackgroundDefault = DDCOLOR.getDefaultBackgroundColor();
            m_colorBackgroundHighlighted = DDCOLOR.getTextHighlightColor();
            m_sFontFace = DDCOLOR.getDefaultFont();

            // Check to see if the dropdown 'div' element already exists
            m_oDropMenu = document.getElementById('dropmenudiv');

            // Create the default dropdown 'div' element if it doesn't exist
            // NOTE: We only want one instance of the dropdown that can be shared between all editors
            if (null == m_oDropMenu) {
                m_oDropMenu = $("<div class='dropmenudiv' id='dropmenudiv' editorName=''>")[0];
                document.body.appendChild(m_oDropMenu);
            }

            m_oDropMenu.style.hideFocus = true;
            m_oDropMenu.style.fontFamily = m_sFontFace;
            m_oDropMenu.style.fontSize = "13px";
            m_oDropMenu.style.paddingLeft = "2px";
            m_oDropMenu.style.paddingTop = "2px";
            m_oDropMenu.style.paddingRight = "2px";
            m_oDropMenu.style.paddingBottom = "2px";
            m_oDropMenu.style.border = "1px solid " + DDCOLOR.getDropdownBorder();
            m_oDropMenu.style.width = "auto";
            m_oDropMenu.style.background = m_colorBackgroundDefault;
            m_oDropMenu.style.position = "absolute";
            m_oDropMenu.style.zIndex = 9999;

            // Capture mouseover state so that the plugin can disable blur handlers
            $(m_oDropMenu)
                .mouseover(function(event) {
                    $(m_oDropMenu).data('isover', true);
                })
                .mouseout(function(event) {
                    $(m_oDropMenu).data('isover', false);
                });
            // NOTE:  Code consuming the 'isover' data should first check for visibility!

            setVisible(this, "hidden");
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      isPopupVisible
        /// \Brief              True if dropdown menu is visible, false otherwise
        /////////////////////////////////////////////////////////////////////////////
        isPopupVisible: function () {

            return ("visible" === m_oDropMenu.style.visibility) ? true : false;
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      isMouseOverPopup
        /// \Brief              True if dropdown menu is visible and the mouse is over it
        /////////////////////////////////////////////////////////////////////////////
        isMouseOverPopup: function() {
            return m_oDropMenu && this.isPopupVisible() && $(m_oDropMenu).data('isover');
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      isPluginEnabled
        /// \Brief              Gets the flag indicator
        ///
        /// \Returns            bool - status of the indicator
        /////////////////////////////////////////////////////////////////////////////
        isPluginEnabled: function () {
            return m_bIsPluginEnabled;
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      keyHandler
        /// \Brief              Event handler to provide keystroke input behavior
        ///                     to the dropdown menu UI object
        ///
        /// \Parameter          keyPress - specifies the key to handle events for
        /////////////////////////////////////////////////////////////////////////////
        keyHandler: function (keyPress) {
            if ("visible" === m_oDropMenu.style.visibility) {
                if (g_iDD_KEYCODE_KEYDOWN == keyPress) {
                    if (m_nItemPosition == m_arrAbbreviationList.length - 1) {
                        setColor(m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                        return;
                    }

                    if (m_arrAbbreviationList.length > 0 && m_nItemPosition <= m_arrAbbreviationList.length - 1) {
                        if (m_nItemPosition >= 0) {
                            setColor(m_nItemPosition, m_colorBackgroundDefault, m_colorTextDefault);
                        }
                        m_nItemPosition++;

                        if (m_nItemPosition <= m_arrAbbreviationList.length - 1) {
                            setColor(m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                        }

                        // Scrolling logic - Get the approximate number of elements by dividing the dropUp/dropDown menu's(DIV's)
                        // client area height by the approx. height of each element , then check this element count against
                        // the current menu item position. if the current item position is greater or equal , then scroll down
                        var nVisibleElementCnt = Math.round(m_oDropMenu.clientHeight / m_nMenuElementHeight);
                        if (m_nItemPosition >= nVisibleElementCnt - 1)
                            m_oDropMenu.scrollTop += m_nScrollOffset;
                    }
                }
                else if (g_iDD_KEYCODE_KEYUP == keyPress) {
                    if (0 == m_nItemPosition) {
                        setColor(m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                        return;
                    }

                    if (m_arrAbbreviationList.length > 0 && m_nItemPosition >= 0) {
                        if (m_nItemPosition > 0) {
                            setColor(m_nItemPosition, m_colorBackgroundDefault, m_colorTextDefault);
                            setColor(--m_nItemPosition, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                        }
                        else {
                            setColor(m_nItemPosition, m_colorBackgroundDefault, m_colorTextDefault);
                            m_nItemPosition--;
                        }

                        // Scrolling logic - Get the approximate number of elements by dividing the dropUp/dropDown menu's(DIV's)
                        // client area height by the approx. height of each element , then check this element count against
                        // the current menu item position. if the current item position is less or equal , then scroll up
                        var nVisibleElementCnt = Math.round(m_oDropMenu.clientHeight / m_nMenuElementHeight);
                        if (m_nItemPosition <= nVisibleElementCnt - 1 || nVisibleElementCnt <= m_nMinimumMenuSize)
                            m_oDropMenu.scrollTop -= m_nScrollOffset;
                    }
                }
                else if (g_iDD_KEYCODE_ENTER == keyPress) {   // Enter
                    if (m_nItemPosition <= -1 || m_nItemPosition >= m_arrAbbreviationList.length) {
                        setVisible(this, "hidden");
                        return;
                    }

                    // update the first child to match the selected item on the list
                    if (typeof this.firstChild != 'object' ||
                        this.firstChild != m_oDropMenu.childNodes[m_nItemPosition].firstChild)
                        this.firstChild = m_oDropMenu.childNodes[m_nItemPosition].firstChild;

                    // insert the text matching the template into the editor
                    if (null != this.firstChild) {
                        insertText(this, this.firstChild.nodeValue);
                    }

                    m_nItemPosition = -1;
                    setVisible(this, "hidden");
                }
                else if (g_iDD_KEYCODE_SPACE == keyPress) { // Space
                    setVisible(this, "hidden");
                }
            }
        },

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      onClick
        /// \Brief              Handle the click event
        ///
        ///                     NOTE: This function is being overridden by cerndyndocautotext
        ///
        /// \Parameter          oEditor - the current editor
        /// \Parameter          oEvent - the click event
        /////////////////////////////////////////////////////////////////////////////
        onClick: function (oEvent) {
            // retrieve new coordinates and text to the left of caret position
            // display dropdown menu if matching abbreviations
            this.saveFocusedElement(oEvent.data.$.srcElement);
            this.evaluateAt();
            this.keyHandler(oEvent.data.$.keyCode);
        },

        //////////////////////////////////////////////////////////////////////////////////
        /// \Function name    onPopupDblClick
        /// \Brief            Callback function to capture mouse events inside the
        ///                   dropdown element
        ///                   Called when user double clicks inside dropdown element
        //////////////////////////////////////////////////////////////////////////////////
        onPopupDblClick: function (oElementClicked) {
            // sets the focus to the editor and then insert the selected menu item to the editor
            this.m_oEditor.focus();

            if (window.getSelection)
                this.reselectEditor();

            // insert the text matching the template into the editor
            if (oElementClicked.firstChild) {
                insertText(this, oElementClicked.firstChild.nodeValue);
                this.m_oEditor.focus();
            }

            setVisible(this, "hidden");
            m_nItemPosition = -1;
        },

        //////////////////////////////////////////////////////////////////////////////////
        /// \Function name    onPopupClick
        /// \Brief            Callback function to capture mouse events inside the
        ///                   dropdown element
        ///                   Called when user clicks inside dropdown element
        //////////////////////////////////////////////////////////////////////////////////
        onPopupClick: function (oElementClicked) {

            setColor(m_nItemPosition, m_colorBackgroundDefault, m_colorTextDefault);
            for (var i = 0; i < m_oDropMenu.childNodes.length; i++) {
                if (m_oDropMenu.childNodes[i].firstChild.nodeValue == oElementClicked.firstChild.nodeValue) {
                    setColor(i, m_colorBackgroundHighlighted, m_colorTextHighlighted);
                    m_nItemPosition = i;
                    break;
                }
            }

            this.m_oEditor.focus();
            if (window.getSelection)
                this.reselectEditor();
        },

        reselectEditor:  window.getSelection ? function() {
            if (this.m_oEditor.getSelection().getRanges().length === 0 && this.savedRange) {
                // Lost editor selection; try to get it back
                if (typeof DynDocHelper !== 'undefined')
                    DynDocHelper.ReportDebugMsg('onPopupDblClick - no selection, selecting saved range', 'DynDocCKEditor');

                var sel = getSelection();
                sel.removeAllRanges();
                try {
                    sel.addRange(this.savedRange);
                }
                catch (e) {
                    DocHandleError('onPopupDblClick - Error selecting saved range - ' + (e.message || e), 'DynDocCKEditor');
                }
            }
        } : $.noop,

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name      showManageAutoTextDlg
        /// \Brief              call win32 to create and display the ManageAutoText dlg
        /////////////////////////////////////////////////////////////////////////////
        showManageAutoTextDlg: function () {
            CKEDITOR.AutoTextHelper.ShowManageAutoTextDlg();
        },

        //////////////////////////////////////////////////////////////////////////////////
        /// \Function name    selectionExists
        /// \Brief            Gets the range && checks if more than one char is selected
        ///                   Note: this normally happens when Shift + Left/Right key is pressed
        //////////////////////////////////////////////////////////////////////////////////
        selectionExists: function () {

            // get the range
            var oRange = this.m_oEditor.document.$.selection.createRange();
            if (oRange && oRange.moveStart && oRange.text.length > 0) {
                this.hideDropMenu();
                return true;
            }

            return false;
        },

        //////////////////////////////////////////////////////////////////////////////////
        /// \Function name    keyCodeHandledByPopup
        /// \Brief            True if popup is visible and keypress handled by the popup
        //////////////////////////////////////////////////////////////////////////////////
        keyCodeHandledByPopup: function (nKeyCode) {

            return (true == this.isPopupVisible() && (g_iDD_KEYCODE_KEYDOWN == nKeyCode || g_iDD_KEYCODE_KEYUP == nKeyCode || g_iDD_KEYCODE_ENTER == nKeyCode)) ? true : false;

        }
    }
} // End AutoTextPluginHelper

/******************************************************************************
/ Description:   Gets the coordinates and cursor position inside the editor   /
/                Gets the text to the left of the cursor position             /
/                Calls win32 to get the list matching the typed abbreviation  /
/                Draws a floating <div> with list of matching abbreviations,  /
/                and allows the user to select each one by using either the   /
/                keyboard (up/down/enter, etc) or mouse click                 /
--------------   --------------------------------------------------------------
Mod Date         Engineer              Comment
--- --------     --------------------  ----------------------------------------
000 02/12        Adilson M. Ribeiro    Initial Release
001 03/12        Adilson M. Ribeiro    Manage Auto Text from Toolbar
*******************************************************************************/

CKEDITOR.plugins.add('cernautotext', {
    lang: 'en,en-au,en-gb,de,fr,es,pt-br',

    m_mapHelpers: [],

    beforeInit: function (editor) {
        // load AutoTextPluginHelper namespace
        if (typeof DDCOMMON === 'undefined')
            CKEDITOR.scriptLoader.load(CKEDITOR.getUrl('js/dynDocCommonFunc.js'));

        if (typeof AutoTextPluginHelper === 'undefined') {
            CKEDITOR.scriptLoader.load(CKEDITOR.getUrl('plugins/cernautotext/js/autotext.js'));
        }

        var oHelper = new AutoTextPluginHelper();
        // Use Range instead of TextRange in IE9+
        if (window.getSelection)
            oHelper.evaluateAt = oHelper.evaluateAt2;
        this.m_mapHelpers[editor.name] = oHelper;
        oHelper.m_oEditor = editor;
    },

    init: function (editor) {
        var oHelper = this.m_mapHelpers[editor.name];

        // Manage AutoText command definition
        var manageAutoTextCmd = {
            canUndo: false,
            editorFocus: false,
            exec: function (editor) {
                oHelper.showManageAutoTextDlg();
            }
        };

        oHelper.initAutoText();

        // Hide AutoText command definition
        editor.addCommand(DDCMD_HIDE_AUTOTEXT_MENU, {
            canUndo: false,
            editorFocus: false,
            exec: function (editor) {
                return oHelper.hideDropMenu();
            }
        });

        editor.on('instanceReady', function() {
            if (CKEDITOR.env.ie && CKEDITOR.env.version >= 9) {
                var updateSavedRange = function() {
                    var sel = getSelection();
                    var range = sel.rangeCount && sel.getRangeAt(0);
                    if (range && DDCOMMON.isNodeEditable(range.startContainer) && DDCOMMON.containsNode(editor.editable().$, range.startContainer))
                        oHelper.savedRange = range;
                };
                editor.document.on('selectionchange', updateSavedRange);
                // Make key handler too since selectionchange doesn't fire when entering characters
                // (because we disable event propagation in one of the keydown event handlers)
                // `defer` is needed because we need to wait until the selection is updated
                editor.editable().on('keydown', CKEDITOR.tools.defer(updateSavedRange), null, null, -1 /* Very high priority so that it's called before propagation is canceled */);
            }
        });

        // Register the command
        var commandName = 'cernautotext',
            command = editor.addCommand(commandName, manageAutoTextCmd);

        // Register the toolbar button
        editor.ui.add('ManageAutoText', CKEDITOR.UI_BUTTON, {
            label:      editor.lang.cernautotext.MANAGE_AUTOTEXT,
            command:    commandName,
            icon:       CKEDITOR.getUrl('images/summview.gif')
        });

        // check if plugin is enabled first
        if (oHelper.isPluginEnabled()) {
            editor.on('contentDom', function () {
                // Adjust menu position on scroll
                editor.document.getBody().on('scroll', oHelper.syncPosition, oHelper);
                editor.editable().on('scroll', oHelper.syncPosition, oHelper);

                // NOTE:  Since we want to cancel the 'enter' command, these handlers must execute
                //        before commands are executed.  CKEditor events are handled in the
                //        bubbling phase (the only phase that IE7 supports).  So, in order to
                //        execute first, we need to attach these event handlers to the element at
                //        least as deep as the element that the commands are executing with.  Event
                //        handlers for commands are attached to the editor.editable() element.
                //        When the 'divarea' plugin is enabled, this is the div.cke_wysiwyg_div
                //        element.  So, we will attach to the same element, but taking a higher
                //        priority so that we can cancel further events.

                // Find the editor div.
                var editorElement = editor.editable().$;
                if (!editorElement.id)
                    editorElement.id = CKEDITOR.DocUtilsHelper.GenerateGUID();

                editorElement = CKEDITOR.dom.element.get(editorElement);

                // click
                editorElement.on('click', function (event) {
                    oHelper.onClick(event);
                });

                editorElement.on('mouseup', function (event) {
                    // Hide on right click
                    if (2 == event.data.$.button)
                        return oHelper.hideDropMenu();
                });

                // keyDown
                // Note: Priority 1 is intended for this handler to be handled ahead of all other plugins.
                //       This is need when the autotext dropdown menu is visible and we need to intercept
                //       certain events, before the editor and other plugins do.
                editorElement.on('keydown', function (event) {
                    if (oHelper.m_oAutoTextTimout) {
                        clearTimeout(oHelper.m_oAutoTextTimout);
                        oHelper.m_oAutoTextTimout = null;
                    }

                    if (!event || !event.data || !event.data.$)
                        return;

                    var nKeyCode = event.data.$.keyCode;

                    // redundant as oHelper.keyHandler checks space too but making
                    // synchronous makes the list box seem more responsive.
                    //
                    // Also note that tabbing to a control outside of the editor skips
                    // the tab's keyup event, so always handle in keydown.
                    if (g_iDD_KEYCODE_SPACE == nKeyCode || g_iDD_KEYCODE_TAB == nKeyCode || g_iDD_KEYCODE_ESC == nKeyCode) {
                        oHelper.hideDropMenu();
                        return;
                    }

                    // if keyDown | keyUp | Enter
                    if (oHelper.keyCodeHandledByPopup(nKeyCode)) {
                        // Handle arrow keys
                        if (nKeyCode == g_iDD_KEYCODE_KEYDOWN || nKeyCode == g_iDD_KEYCODE_KEYUP)
                            oHelper.keyHandler(nKeyCode);

                        // Stop the event to prevent other plugins from handling
                        event.stop();
                        event.data.preventDefault(true);
                    }
                }, null, null, 1); // priority 1 - means this event will be handled first

                // keypress
                // Note: Priority 1 is intended for this handler to be handled ahead of all other plugins.
                //       This is need when the autotext dropdown menu is visible and we need to intercept
                //       certain events, before the editor and other plugins do.
                editorElement.on('keypress', function (event) {
                    var nKeyCode = event.data.$.keyCode;

                    if (oHelper.keyCodeHandledByPopup(nKeyCode)) {

                        // Stop the event to prevent other plugins from handling
                        event.stop();
                        event.data.preventDefault(true);
                    }
                }, null, null, 1); // priority 1 - means this event will be handled first

                // keyUp
                // Note: Priority 1 is intended for this handler to be handled ahead of all other plugins.
                //       This is need when the autotext dropdown menu is visible and we need to intercept
                //       certain events, before the editor and other plugins do.
                editorElement.on('keyup', function (event) {
                    if (null != oHelper.m_oAutoTextTimout) {
                        clearTimeout(oHelper.m_oAutoTextTimout);
                        oHelper.m_oAutoTextTimout = null;
                    }
                    // Hides the listbox if a selection exists
                    if (oHelper.selectionExists())
                        return;

                    if (!event || !event.data || !event.data.$)
                        return;

                    var nKeyCode = event.data.$.keyCode;
                    var oSrcElem = event.data.$.srcElement;

                    var doKeyHandler = function() {
                        oHelper.saveFocusedElement(oSrcElem);
                        oHelper.evaluateAt();
                        oHelper.keyHandler(nKeyCode);
                    }

                    switch (nKeyCode) {
                    case g_iDD_KEYCODE_F3:
                        break;

                    case g_iDD_KEYCODE_SPACE:
                    case g_iDD_KEYCODE_TAB:
                    case g_iDD_KEYCODE_ESC:
                        oHelper.hideDropMenu();
                        break;

                    case g_iDD_KEYCODE_ENTER:
                        if (oHelper.isPopupVisible()) {
                            oHelper.keyHandler(nKeyCode);
                            // Stop the event to prevent other plugins from handling
                            event.stop();
                            // preventDefault has same effect as stop but seems to cooperate better when calling
                            // handleKeystroke synchronously vs. using settimeout
                            event.data.preventDefault(true);
                        }
                        break;

                    case g_iDD_KEYCODE_KEYDOWN:
                    case g_iDD_KEYCODE_KEYUP:
                        if (oHelper.isPopupVisible()) {
                            // Stop the event to prevent other plugins from handling
                            event.stop();
                            // preventDefault has same effect as stop but seems to cooperate better when calling
                            // handleKeystroke synchronously vs. using settimeout
                            event.data.preventDefault(true);
                        }
                        break;

                    default:
                        if (oHelper.isPopupVisible()) {
                            // Readjust the list box right away since it might overlap the cursor
                            doKeyHandler();
                        }
                        else {
                            // short timeOut (200ms) between key strokes
                            oHelper.m_oAutoTextTimout = setTimeout(doKeyHandler, 200);
                        }
                    }

                }, null, null, 1); // priority 1 - means this event will be handled first

            }); // contentDom

            // attach beforeCommandExec to the editor
            editor.on('beforeCommandExec', function (event) {
                if (DDCMD_SAVE == event.data.name ||
                    DDCMD_SAVECLOSE == event.data.name ||
                    DDCMD_SIGN == event.data.name ||
                    DDCMD_DQRRESULTS == event.data.name ||
                    DDCMD_INSERTFREETEXT == event.data.name ||
                    DDCMD_REMOVEELEMENT == event.data.name ||
                    DDCMD_REFRESHELEMENT == event.data.name ||
                    DDCMD_STRIKEELEMENT == event.data.name ||
                    DDCMD_NEXT_UNDERSCORE == event.data.name ||
                    DDCMD_PREV_UNDERSCORE == event.data.name) {

                    oHelper.hideDropMenu();
                }
            }); // beforeCommandExec

            // attach afterCommandExec to the editor
            editor.on('afterCommandExec', function (event) {
                if (DDCMD_UNDO == event.data.name || DDCMD_REDO == event.data.name ||
                    DDCMD_PASTE == event.data.name || DDCMD_CUT == event.data.name) {

                    var curSelection = editor.getSelection();

                    if (!curSelection) {
                        oHelper.hideDropMenu();
                        return;
                    }

                    // Get the current element
                    var oElement = curSelection.getStartElement();
                    if (oElement) {
                        oHelper.saveFocusedElement(oElement.$);
                        oHelper.evaluateAt();
                    }
                }
            }); //afterCommandExec
        } // if oHelper.isPluginEnabled()
    }  //init
});                  //cernautotext

/******************************************************************************
/ Description: The Get XHTML plugin will clean up the document by removing    /
/              XHTML elements and attributes that are injected by Dynamic     /
/              Documentation and that are NOT to be saved in the actual text  /
/              of the note.  Each plugin that injects something that is not   /
/              meant to be saved should register a filter with this plugin.   /
/              This filter should then remove the injected content as needed. /
******************************************************************************/

CKEDITOR.plugins.add('cerngetxhtml', {
    beforeInit: function (oEditor) {
        var m_aFilters = [];

        /////////////////////////////////////////////////////////////////////////////
        /// \Brief            Register a filter that removes temporary XHTML from the main body
        ///
        /// \Details          Each plugin that injects temporary XHTML into the main
        ///                   document should create a filter to remove that content
        ///                   and register it here.
        ///
        /// \Parameter        oEditor : The editor whose XHTML is to be retrieved
        /// \Parameter        oFilter : The function to be run that filters out temporary XHTML
        /////////////////////////////////////////////////////////////////////////////
        oEditor.registerXhtmlFilter = function(oFilter) {
            m_aFilters.push(oFilter);
        };

        /////////////////////////////////////////////////////////////////////////////
        /// \Brief              Invokes each of the callbacks registered by `registerXhtmlFilter`
        ///
        /// \Details            The caller is responsible for saving a snapshot of the editor prior
        ///                     to calling this, and restoring the snapshot when finished.
        ///
        /// \Parameter          element(Optional) : the element whose innerHTML is to be filtered
        ///
        /// \Returns            HTMLElement that belongs to a document fragment rather than the
        ///                     editor document, containing the filtered contributions
        /////////////////////////////////////////////////////////////////////////////
        oEditor.executeXhtmlFilters = function(element) {
            var doc = oEditor.document.$;

            var detached = doc.createElement('div');
            // Use innerHTML instead of cloneNode for now, in case there are corrupt nodes in the DOM (IE8-)
            // For the same reason, avoid getData() for now
            var html = element ? element.innerHTML : oEditor.editable().getHtml();
            detached.innerHTML = html;

            for (var i = 0; i < m_aFilters.length; i++) {
                m_aFilters[i](detached);
            }

            DDCOMMON.resetCaches();

            return detached;
        }

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name    getXhtml
        /// \Brief            Get the XHTML from the note that can be committed to the database
        ///
        /// \Details          Loop through the filters that have been registered with
        ///                   the plugin and remove any XHTML elements or attributes
        ///                   that are not meant to be saved to the database or be
        ///                   used by external callers. An example of removed material
        ///                   would be spellcheck spans.
        ///
        /// \Parameter        oEditor : The editor whose XHTML is to be retrieved
        /// \Returns          The body of the editor with all temporary XHTML removed
        /////////////////////////////////////////////////////////////////////////////
        oEditor.getXhtml = function () {
            var detached = this.executeXhtmlFilters();
            var sCleanedXHTML = oEditor.dataProcessor.toDataFormat(detached.innerHTML);

            if (this.config.emitValidXhtml) {
                // Proper xhtml must have the doctype, html, head, title, and body elements

                sCleanedXHTML = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' +
                                '\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:dd="DynamicDocumentation">' +
                                '\n<head><title></title></head>\n' +
                                '<body>\n' + sCleanedXHTML + '\n</body></html>';
            }

            return sCleanedXHTML;
        }; // getXhtml

        var m_aDirtyFilters = []; // Array of callback functions

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name    registerDirtyFilter
        /// \Brief            Registers a callback that will be called to filter
        ///                   transient contribution DOM data for HTML string comparison
        ///
        /// \Details          Order of callbacks invoked is not currently guaranteed
        ///
        /// \Parameter        callback : Callback invoked, given a DOM fragment
        ///                              containing a duplicate of the contribution
        /// \Returns          void
        /////////////////////////////////////////////////////////////////////////////
        oEditor.registerDirtyFilter = function(callback) {
            m_aDirtyFilters.push(callback);
        }

        /////////////////////////////////////////////////////////////////////////////
        /// \Function name    cleanContribution
        /// \Brief            Invokes each dirty filter callback to remove transient
        ///                   data from a copy of the contribution
        ///
        /// \Parameter        contribution : DOM element to be cleaned of transient data
        /// \Returns          A copy of the contribution element, modified to remove transient data
        /////////////////////////////////////////////////////////////////////////////
        oEditor.cleanContribution = function(contribution) {
            var frag = contribution.ownerDocument.createDocumentFragment();
            frag.appendChild(contribution.cloneNode(true));

            for (var i = 0; i < m_aDirtyFilters.length; i++) {
                var filter = m_aDirtyFilters[i];
                if (filter && filter.apply)
                    filter(frag);
            }

            return frag.firstChild;
        }

        // Register a filter that will remove all temporary XHTML injected into the document
        // such as the UI Droppable,JQuery, at the time of checking the document is Dirty or not.
        // we tried to use the JQuery droppable('destroy') but it is
        // removing the ui-droppable Class pemanently.
        // This will remove the JQuery attribute with Unique ID which was added along with the ui-droppable
        // we found some issues with the solution citrix box where the droppable("destroy") is called which adds the
        // onremove attribute occasionally due to race condition.
        oEditor.registerDirtyFilter(function(frag) {
            var $uiDroppable = $(frag.firstChild).find('.ui-droppable');
            // This will remove the jQuery attribute with Unique ID which was added along with the ui-droppable
            $uiDroppable.removeAttrs(/^jQuery/);

            // This will remove the ui-droppable which is added by the tagging feature.
            $uiDroppable.removeClass('ui-droppable');

            $(frag.firstChild).find('.ddsection').removeAttr("onremove");
        });
        oEditor.registerXhtmlFilter(function(detached) {
            $(detached).find('.ddsection').removeAttr('onremove');
        });
    }
});     // End plugin.add

(function() {

    /**
     * Get a node's nearest ancestor that is a block element
     *
     * @param node                  The node to look from
     * @param ancestorLimit         The node to stop looking up the DOM tree
     * @param [includeSelf=false]   Whether or not to consider `node` as an ancestor of itself
     * @returns {CKEDITOR.dom.element} The nearest ancestor of `node` that is a block element, or null
     */
    function getBlockAncestor(node, ancestorLimit, includeSelf) {
        if (node.type === CKEDITOR.NODE_TEXT)
            includeSelf = false;
        for (var current = includeSelf ? node : node.getParent(); current && current.type == CKEDITOR.NODE_ELEMENT && current.$ !== ancestorLimit.$; current = current.getParent()) {
            if (current.isBlockBoundary())
                return current;
        }
        return null;
    }

    /**
     * Shrinks an IE TextRange so that it does not start or end with whitespace characters
     * @param range     The TextRange to trim
     */
    function trimRangeWhitespace(range) {
        CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
        while (range.text.length && CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.test(range.text.charAt(0))) {
            range.moveStart('character', 1);
        }

        CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
        while (range.text.length && CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.test(range.text.charAt(range.text.length-1))) {
            range.moveEnd('character', -1);
        }
    }

    /**
     * @member CKEDITOR.SpellChecker
     * @static
     * @private
     *
     * Expands the given TextRange to encompass the word at that TextRange
     *
     * @param {TextRange}   subwordRange    TextRange at a word
     * @param {HTMLElement} ancestorLimit   Ancestor element that limits the boundaries of the new range
     * @returns {TextRange} A range that encompasses wordRange; wraps a word or is a collapsed range
     */
    function getWordRangeAtCursor(subwordRange, ancestorLimit) {
        var wordRange = subwordRange.duplicate();

        var limitRange = wordRange.duplicate();
        limitRange.moveToElementText(ancestorLimit);

        // Find left boundary of word
        while (wordRange.compareEndPoints('StartToStart', limitRange) > 0) {
            wordRange.moveStart('character', -1);
            CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
            if (CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.test(wordRange.text.charAt(0))) {
                // Move range back
                wordRange.moveStart('character', 1);

                break;
            }
        }

        // Find right boundary of word
        while (wordRange.compareEndPoints('EndToEnd', limitRange) < 0) {
            wordRange.moveEnd('character', 1);
            CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
            if (CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.test(wordRange.text.charAt(wordRange.text.length - 1))) {
                // Move range back
                wordRange.moveEnd('character', -1);

                break;
            }
        }

        return wordRange;
    }

    /**
     * Replace the contents of the given range with text and remove the parent squiggle span
     * @param range     IE TextRange
     * @param text      Text to put inside of the range
     * @returns {boolean}   true if the range text was changed
     */
    function replaceMisspelledWord(range, text) {
        range.text = text;

        var rangeParent = range.parentElement();
        var spellCheckSpan = DDCOMMON.hasClassName(rangeParent.className, g_sCLASS_SPELLCHECK) ?
            rangeParent :
            $(rangeParent).closest(g_sCLASS_SPELLCHECK).get(0);
        if (spellCheckSpan)
            spellCheckSpan.removeNode();

        return true;
    }

    /**
     * Restore the cursor position on scroll event
     * @param {CKEDITOR.eventInfo} eventInfo    Argument passed in from the CKEditor event framework
     * @note Must be called with the CKEDITOR.SpellChecker context
     */
    function handleEditorScroll(eventInfo) {
        // If the mousewheel caused this scroll event, don't prevent the scroll.  This is to
        // distinguish user input vs IE misbehavior (e.g. TextRange.prototype.select() causes the
        // element to scroll to the position of the TextRange).  This check is, more or less, just a
        // sanity check.
        if (eventInfo.data.$.wheelDelta || eventInfo.data.$.detail) {
            this.unlockEditorScroll();
            return;
        }

        if (this.scrollTop || this.scrollTop === 0) {
            var bToggleCssWasEnabled = true;
            if (typeof DYNDOCToggleCSS !== 'undefined') {
                bToggleCssWasEnabled = !DYNDOCToggleCSS.getDisablePlugin();
                DYNDOCToggleCSS.setDisablePlugin(true);
            }

            this.editor.editable().$.scrollTop = this.scrollTop;

            if (bToggleCssWasEnabled && typeof DYNDOCToggleCSS !== 'undefined')
                DYNDOCToggleCSS.setDisablePlugin(false);
        }
    }

    /**
     * @class CKEDITOR.SpellChecker
     * A SpellChecker for a particular editor
     */
    CKEDITOR.SpellChecker = CKEDITOR.tools.createClass({
        /**
         * @constructor
         * @param {CKEDITOR.editor} editor  The editor instance that this SpellChecker is for.
         *                                  SpellChecker instances should be 1-to-1 with ckeditor
         *                                  instances.
         */
        $:  function(editor) {
            this.editor = editor;

            this.bEnabled = CKEDITOR.SpellChecker.bEnabled;
            this.timeout = 50;
            this.restartSpellcheckTimer = null;
            this.mapTraversals = {};
            this.misspelledSpanIds = {};    // Maps id <=> id (faster to delete from object than array)
            this.bCleanupsEnabled = true;   // For debugging purposes
            this.currentCleanup = null;
            this.aQueuedCleanups = [];
            this.lastCleanup = 0;

            editor.on('contentDom', function() {
                var editable = editor.editable();
                // spellcheck may invalidate the bookmarks saved in the selection handler
                // so we disable on blur and re-enable on focus
                editable.on('blur',         this.disableSpellCheck, this);
                editable.on('focus', CKEDITOR.tools.defer(function () {
                    if (!editor.undoing && !editor.redoing)
                        this.enableSpellCheck(true)
                }.bind(this)));
                editable.on('keydown',      this.handleInputEvent, this);
                editable.on('keyup',        this.handleInputEvent, this);
                editable.on('click',        this.clickHandler, this);
                editor.document.on('focusout', this.blurHandler, this);
                if (editor.config.enterMode === CKEDITOR.ENTER_BR) {
                    var enter = editor.getCommand('enter');
                    enter && enter.on('exec', this.handleEnterEvent, this);
                }
                if (editor.config.shiftEnterMode === CKEDITOR.ENTER_BR) {
                    var shiftEnter = editor.getCommand('shiftEnter');
                    shiftEnter && shiftEnter.on('exec', this.handleEnterEvent, this);
                }

                editable.on('scroll', this.scrollHandler, this);

                editor.document.getWindow().once('focus', this.enableSpellCheck, this);
            }, this);

            editor.on('noteLoaded', this.enableSpellCheck, this);

            editor.on('afterCommandExec', function(event) {
                if (event.data.name == 'cut' || event.data.name == 'paste')
                    CKEDITOR.tools.setTimeout(this.spellCheckCurrentElement, 0, this, [ true ]);
            }, this);
            editor.on('loadSnapshot', function(event) {
                // Interrupt currently-running tasks since they are running on DOM nodes that no
                // longer exist
                this.disableSpellCheck();
                CKEDITOR.tools.setTimeout(function() {  // Let CKEditor do its range selection stuff before re-enabling spellcheck
                    this.enableSpellCheck();
                    CKEDITOR.tools.setTimeout(this.spellCheckCurrentElement, 0, this, [ true ]);
                }, 250, this);
            }, this);
            editor.on('paste', function(event) {
                CKEDITOR.tools.setTimeout(this.spellCheckCurrentElement, 0, this, [ true ]);
            }, this);
            editor.on(DDCMD_CONTENTHTMLLOADED, function(event) {
                var items = event.data && event.data.items;
                if (!items)
                    return;

                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var ckelement = CKEDITOR.dom.element.get(item);
                    if (!ckelement)
                        continue;

                    var ancestor = getBlockAncestor(ckelement, editor.editable(), true);
                    if (!ancestor)
                        ancestor = editor.editable();
                    this.startElementSpellcheck(ancestor);
                }
            }, this);

            // Register a filter that will remove all temporary XHTML injected into the document
            // such as the spellcheck span, at the time of checking the document is Dirty or not.
            editor.registerDirtyFilter && editor.registerDirtyFilter(function(frag) {
                for (var id in this.misspelledSpanIds) {
                    var element = frag.getElementById ? frag.getElementById(id) : frag.querySelector('#' + id);
                    if (element)
                        element.removeNode();
                    else
                        delete this.misspelledSpanIds[id];  // Make subsequent enumerations faster
                }
                return;

                var arrElements = $(frag.firstChild).find('.ddspellcheck');
                while (arrElements && arrElements.length > 0) {
                    Array.prototype.pop.call(arrElements).removeNode();
                }
            }.bind(this));

            if (editor.contextMenu) {
                editor.contextMenu.addListener(function(element, selection) {
                    if (!element)
                        return;

                    // Stop traversals that occur over this element
                    for (var cur = element.$; cur && cur !== this.editor.editable().$.parentNode; cur = cur.parentNode) {
                        var id = $(cur).attr('id');
                        var traversal = this.mapTraversals[id];
                        if (traversal)
                            traversal.cancel();
                    }

                    if (this.currentCleanup) {
                        // Stop cleanup if it goes over this element
                        for (var cur = element.$; cur && cur !== this.editor.editable().$.parentNode; cur = cur.parentNode) {
                            if (cur === this.currentCleanup.element) {
                                this.interruptCleanup();
                                break;
                            }
                        }
                    }
                }.bind(this));
            }

            editor.on('beforeDestroy', this.beforeDestroyHandler, this);

            /**
             * Disable spellcheck for this editor.
             *
             * It can be turned back on using editor.enableSpellCheck.
             * @method
             * @member CKEDITOR.editor
             */
            this.editor.disableSpellCheck = this.disableSpellCheck.bind(this);

            /**
             * Enable spellcheck for this editor.
             *
             * Note, this will not enable spellcheck if SpellCheck.bEnabled is false; it is the
             * master control switch.
             * @method
             * @member CKEDITOR.editor
             */
            this.editor.enableSpellCheck = this.enableSpellCheck.bind(this);

            /**
             * @method
             * @member CKEDITOR.editor
             * @return {Boolean} Whether or not spellcheck is enabled for this editor
             */
            this.editor.isSpellCheckEnabled = function() {
                return this.bEnabled && this.editor.undoing !== true && this.editor.redoing !== true;
            }.bind(this);
        },
        proto:  {

            /**
             * Saves the current scroll position, and adds a handler that prevents automatic scrolling
             */
            lockEditorScroll:  function() {
                this.scrollTop = this.editor.editable().$.scrollTop;
                this.editor.editable().on('scroll', handleEditorScroll, this);
                this.editor.editable().on('keydown', this.unlockEditorScroll, this);
            },

            /**
             * Removes the event handler that prevents automatic scrolling
             */
            unlockEditorScroll:  function() {
                this.editor.editable().removeListener('scroll', handleEditorScroll);
                this.editor.editable().removeListener('keydown', this.unlockEditorScroll);
                this.scrollTop = null;
            },

            /**
             * [Re-]starts the timer that will spellcheck the current element
             * @param {CKEDITOR.dom.event} event
             * @param {Number} [timeout]  Amount of time before spellcheck should start
             */
            handleInputEvent:  function(event, timeout) {
                if (!CKEDITOR.SpellChecker.bEnabled || !this.bEnabled)
                    return;

                if (this.restartSpellcheckTimer)
                    return;

                if (typeof timeout === 'undefined')
                    timeout = 750;

                this.restartSpellcheckTimer = CKEDITOR.tools.setTimeout(this.spellCheckCurrentElement, timeout, this);
            },

            /**
             * Spellchecks the current element
             * @param {CKEDITOR.dom.event} event
             */
            clickHandler:  function(event) {
                this.handleInputEvent(event, 500);
            },

            /**
             * Starts spellcheck for the blurring element
             * @param {CKEDITOR.dom.event} event
             */
            blurHandler:  function(event) {
                if (!this.bEnabled)
                    return;

                var element$ = event.data.$.srcElement;
                if (element$ && element$.isContentEditable) {
                    var element = CKEDITOR.dom.element.get(element$);
                    this.startElementSpellcheck(element);
                }
            },

            /**
             * If the cursor is after a <br> that is at the end of a .ddspellcheck, this moves
             * that <br> after the .ddspellcheck element and sets the selection after the <br>.
             *
             * This is to make sure the browser renders the new line.
             */
            handleEnterEvent:  function() {
                CKEDITOR.tools.setTimeout(function() {  // Wait until after the line break is entered
                    var PROJECT_NAME = window.PROJECT_NAME || window.PROJECT || 'DynDocCKEditor';

                    var range = this.editor.getSelection().getRanges()[0];
                    if (!range)
                        return;

                    var start = range.getBoundaryNodes().startNode;
                    if (start && start.is && start.is('br')) {
                        var br = start;
                        var $ddspellcheck = $(br.$).closest('.ddspellcheck');
                        if ($ddspellcheck.length && DDCOMMON.isNodeAtEnd(br.$, $ddspellcheck[0])) {
                            if (typeof DynDocHelper !== 'undefined')
                                DynDocHelper.ReportDebugMsg('Moving <br> outside ddspellcheck', PROJECT_NAME);

                            br.insertAfter(CKEDITOR.dom.element.get($ddspellcheck[0]));

                            // Put the selection after the moved <br>
                            range = this.editor.createRange();
                            range.moveToPosition(br, CKEDITOR.POSITION_AFTER_END);
                            range.select();

                            this.editor.fire('updateSnapshot');
                        }
                    }
                }, 0, this);
            },

            /**
             * Used to pause cernscayt tasks in order to prevent unwanted scrolling caused by these tasks
             * @param {CKEDITOR.dom.event} event
             */
            scrollHandler:  function(event) {
                this.lastScroll = new Date().getTime();
            },

            /**
             * Cleans up and removes listeners
             * @param {CKEDITOR.dom.event} event
             */
            beforeDestroyHandler:  function(event) {
                this.disableSpellCheck();

                if (this.editor.document)
                    this.editor.document.removeListener('focusout', this.blurHandler);
            },

            /**
             * Spellcheck the nearest block element that is at the current cursor position
             * @param {boolean} [bSpellcheckWordAtCursor]
             * @returns {boolean}  Whether or not the spellcheck was started
             */
            spellCheckCurrentElement:  function(bSpellcheckWordAtCursor) {
                this.restartSpellcheckTimer = null;

                var selection = this.editor.getSelection();
                if (!selection)
                    return false;
                if (selection.getType() !== CKEDITOR.SELECTION_TEXT)
                    return false;

                var ranges = selection.getRanges();
                if (ranges.length === 0)
                    return false;

                var range = ranges[0];
                if (!range)
                    return false;
                if (!range.collapsed)
                    return false;
                if (!DDCOMMON.isNodeEditable(range.startContainer.$))
                    return false;

                var element = range.startContainer;
                var ancestor = getBlockAncestor(element, this.editor.editable(), true);
                if (!ancestor || !ancestor.$.isContentEditable)
                    ancestor = this.editor.editable();
                this.startElementSpellcheck(ancestor, bSpellcheckWordAtCursor);

                return true;
            },

            /**
             * Starts spellcheck tasks for the given element, which run in the background
             * @param {CKEDITOR.dom.element|string} element     CKEditor element or element ID
             * @param {boolean} [bSpellcheckWordAtCursor]
             */
            startElementSpellcheck:  function(element, bSpellcheckWordAtCursor) {
                if (!this.bEnabled)
                    return;
                if (this.editor.mode !== 'wysiwyg')
                    return;
                if (this.editor.contextMenu && this.editor.contextMenu.isVisible())
                    return;

                if (typeof element === 'string')
                    element = CKEDITOR.dom.element.get(element);
                if (!element)
                    return;

                var selection = this.editor.getSelection();
                if (!selection)
                    return;
                var range = selection.getRanges()[0];
                if (!range || !range.collapsed)  // Only spellcheck when selection is collapsed
                    return;

                var wasDirty = this.editor.checkDirty();
                if (!element.getId()) {
                    element.$.id = this.createUniqueId();
                    this.editor.fire('updateSnapshot');
                }
                // Giving the element a scayt id can cause dirtiness, so reset the dirty state
                if (!wasDirty && this.editor.checkDirty()) {
                    this.editor.resetDirty();
                }

                if (this.currentCleanup) {
                    this.interruptCleanup();
                    this.dequeueCleanup();  // Just in case the spellcheck exits early without starting the next cleanup
                }

                var id = element.getId();
                var traversal = this.mapTraversals[id];
                if (traversal)
                    traversal.cancel();
                CKEDITOR.tools.setTimeout(function() {
                    if (!this.bEnabled)
                        return;
                    if (this.editor.mode !== 'wysiwyg')
                        return;
                    if (this.editor.contextMenu && this.editor.contextMenu.isVisible())
                        return;

                    // If user is scrolling, do the spellcheck tasks later to avoid unintentional
                    // scroll while saving & restoring the cursor position
                    if (this.isScrolling()) {
                        CKEDITOR.tools.setTimeout(this.startElementSpellcheck, 400, this, [ id, bSpellcheckWordAtCursor ]);
                        return;
                    }

                    this.spellCheckElement(id, bSpellcheckWordAtCursor);
                    try {
                        this.checkSpans(id);
                    }
                    catch (e) {
                        this.handleException(e, 'check spans');
                    }
                }, 250, this);
            },

            /**
             * @returns {boolean} Whether or not the user is scrolling (or rather, we recently received a scroll event)
             */
            isScrolling:  function() {
                return this.lastScroll && new Date().getTime() - this.lastScroll < 300;
            },

            /**
             * Checks individual pieces of the DOM for spelling errors, and adds spans to those
             * words that are misspelled.
             * This is asynchronous
             * @param {String} id   Id of the element in the DOM
             * @param {boolean} bSpellcheckWordAtCursor
             */
            spellCheckElement:  function(id, bSpellcheckWordAtCursor) {
                var element = CKEDITOR.dom.element.get(id);
                if (!element)
                    return;  // element died

                var traversal = new DDCOMMON.AsynchronousDfs(element.$,
                    function(node, evt) {
                        var wasDirty = this.editor.checkDirty();
                        if (!CKEDITOR.SpellChecker.bEnabled || !this.bEnabled)
                            return evt.traversal.cancel();

                        // Check if node has been removed from the DOM
                        if (typeof node.parentNode === 'unknown' || node.parentNode == null)
                            return evt.traversal.cancel();

                        // Don't wrap text multiple times
                        if ($(node).hasClass('ddspellcheck'))
                            return evt.cancelSubtree();

                        if (node.nodeType === Node.TEXT_NODE) {
                            if (node.nodeValue.length === 0)
                                return;
                            if ($.trim(node.nodeValue).length === 0)
                                return;
                            if (!DDCOMMON.isNodeEditable(node))
                                return;

                            if (node.previousSibling && typeof node.previousSibling.parentNode === 'unknown' ||
                            node.nextSibling && typeof node.nextSibling.parentNode === 'unknown') {
                                DocHandleError('cernscayt - Sibling node is corrupt; skipping DOM subtree', 'DynDocCKEditor', '', '');

                                if (evt.traversal.direction < 0 && node.parentNode.previousSibling && typeof node.parentNode.previousSibling !== 'unknown')
                                    evt.skipTo(node.parentNode.previousSibling);
                                else if (evt.traversal.direction > 0 && node.parentNode.nextSibling && typeof node.parentNode.nextSibling !== 'unknown')
                                    evt.skipTo(node.parentNode.nextSibling);
                                return evt.cancelSubtree();
                            }

                            // If user is scrolling, do the spellcheck later to avoid unintentional
                            // scroll while saving & restoring the cursor position
                            if (this.isScrolling())
                                return evt.skipTo(node);

                            try {
                                var selection = this.editor.getSelection(true);
                                var range = selection && selection.getRanges()[0];

                                // If the range is not collapsed, restart this spellcheck until it is no
                                // longer collapsed.
                                if (range && !range.collapsed) {
                                    var boundaries = range.getBoundaryNodes();
                                    var cursorNode = boundaries.startNode.$;
                                    if (DDCOMMON.isAncestor(cursorNode, element.$)) {
                                        evt.traversal.cancel();
                                        CKEDITOR.tools.setTimeout(this.startElementSpellcheck, 2000, this, [ id, bSpellcheckWordAtCursor ]);
                                        return;
                                    }
                                }

                                var bookmarks = null;
                                // Create a bookmark if and only if words span this text node that also
                                // span the current cursor position (the bookmark node)
                                var maybeCreateBookmarks = range ? function(node) {
                                    if (bookmarks)
                                        return;

                                    var boundaries = range && range.getBoundaryNodes();
                                    var cursorNode = boundaries && boundaries.startNode && boundaries.startNode.$;

                                    var wordContainers = CKEDITOR.SpellChecker.findWordPortions(node);
                                    for (var i = 0; !bookmarks && i < wordContainers.length; i++) {
                                        var portions = wordContainers[i].portions;
                                        for (var j = 0; !bookmarks && j < portions.length; j++) {
                                            var portion = portions[j];
                                            if (cursorNode === portion.node || cursorNode === portion.node.previousSibling || cursorNode === portion.node.nextSibling)
                                                bookmarks = selection.createBookmarks(true);
                                        }
                                    }
                                } : $.noop;

                                var bSomethingChanged = false;

                                maybeCreateBookmarks(node);

                                // If the bookmark split the node, check the sibling on the other side of that bookmark
                                var bCheckPrevious = DDCOMMON.isBookmarkElement(node.previousSibling);
                                var bCheckNext = DDCOMMON.isBookmarkElement(node.nextSibling);

                                var result = this.spellCheckTextNode(node, bSpellcheckWordAtCursor);
                                if (result.somethingChanged)
                                    bSomethingChanged = result.somethingChanged;
                                var endpoints = result.endpoints;

                                if (endpoints.length === 2) {
                                    var prev = endpoints[0] && endpoints[0].previousSibling;
                                    var next = endpoints[1] && endpoints[1].nextSibling;
                                }

                                if (bCheckPrevious && prev && prev.nodeType === Node.TEXT_NODE) {
                                    maybeCreateBookmarks(prev);
                                    result = this.spellCheckTextNode(prev);
                                    if (result.somethingChanged)
                                        bSomethingChanged = result.somethingChanged;
                                }

                                if (bCheckNext && next && next.nodeType === Node.TEXT_NODE) {
                                    maybeCreateBookmarks(next);
                                    result = this.spellCheckTextNode(next);
                                    if (result.somethingChanged)
                                        bSomethingChanged = result.somethingChanged;
                                }

                                if (bookmarks) {
                                    this.lockEditorScroll();

                                    try {
                                        selection.selectBookmarks(bookmarks);
                                    }
                                    finally {
                                        CKEDITOR.tools.setTimeout(this.unlockEditorScroll, 0, this);
                                    }
                                }

                                if (bSomethingChanged)
                                    this.editor.fire('updateSnapshot');

                                // If the spellcheck plugin modified the dirty state, reset it
                                if (!wasDirty && this.editor.checkDirty()) {
                                    this.editor.resetDirty();
                                }
                            }
                            catch (e) {
                                this.handleException(e, 'spellcheck');
                            }
                        }
                    }.bind(this),
                    function(node) {
                    },
                    function(node) { return this.isScrolling() ? 400 : node.nodeType === Node.TEXT_NODE ? 30 : 0 }.bind(this),
                    -1
                );
                this.mapTraversals[id] = traversal;
                traversal.start(this.queueCleanupElement.bind(this, element.$));
            },

            /**
             * Checks the given text node for spelling errors.
             * Misspelled words are wrapped in .ddspellcheck spans.
             * @param {TextNode} txtnode
             * @param {boolean} [bSpellcheckWordAtCursor]
             * @returns {{endpoints: Array, somethingChanged: boolean}} Since DOM mutations can
             *          invalidate the given text node, the endpoints signify which parts of the
             *          DOM the txtnode once encompassed.
             */
            spellCheckTextNode:  function(txtnode, bSpellcheckWordAtCursor) {
                var doc = txtnode.ownerDocument;

                var createReplacement = function(text) {
                    var $misspelled = $('<span>', doc).text(text).addClass('ddspellcheck');
                    // Create ID for this element so we can quickly find it later
                    var id = this.createUniqueId(/* temporary = */ true);
                    $misspelled.attr('id', id);
                    this.misspelledSpanIds[id] = id;
                    return $misspelled[0];
                }.bind(this);

                var firstNode = txtnode;
                var lastNode = txtnode;
                var bSomethingChanged = false;

                var aNodeSplits = [];
                var iNextNodeSplitSubstringStart = 0;
                var bFoundCurrentNode = false;
                var aWordContainers = CKEDITOR.SpellChecker.findWordPortions(txtnode);
                // Example:  <b>something te</b><i>stt</i><u>ing else</u>
                // And `txtnode` is the child of <i>, wordContainers would be something like:
                // [
                //     {
                //         word:  "testting",
                //         portions:  [
                //             {
                //                 node:  <The child text node of <b>>,
                //                 startIndex:  10,
                //                 endIndex:    -1
                //             },
                //             {
                //                 node:  <The child text node of <i>>,
                //                 startIndex:  0,
                //                 endIndex:    -1
                //             },
                //             {
                //                 node:  <The child text node of <u>>,
                //                 startIndex:  0,
                //                 endIndex:    3
                //             },
                //         ]
                //     }
                // ]
                // If there are multiple words in `txtnode`, there will be more objects in the array
                // (precisely one for each word).

                for (var i = 0; i < aWordContainers.length; i++) {
                    var wordContainer = aWordContainers[i];
                    if (wordContainer.portions.length === 0)
                        continue;

                    var bReplaceNodes = true;

                    if (!bSpellcheckWordAtCursor) {
                        // Check if this word immediately precedes the cursor; if so, disable node
                        // replacement for this word
                        var lastPortion = wordContainer.portions[wordContainer.portions.length-1];
                        if (lastPortion && lastPortion.endIndex < 0 || lastPortion.endIndex === lastPortion.node.nodeValue.length) {
                            var lastPortionNextNode = lastPortion.node;
                            do {
                                lastPortionNextNode = DDCOMMON.getNextNode(
                                    lastPortionNextNode,
                                    DDCOMMON.makeConjunction(DDCOMMON.stopAtBr, DDCOMMON.stopAtBlock),
                                    DDCOMMON.stopAtBlock
                                );
                            }
                            while (lastPortionNextNode && (DDCOMMON.isFillingChar(lastPortionNextNode) || lastPortionNextNode.nodeType === Node.TEXT_NODE && lastPortionNextNode.nodeValue.length === 0));
                            if (DDCOMMON.isBookmarkElement(lastPortionNextNode))
                                bReplaceNodes = false;
                        }
                    }

                    // Trim word of single-quotation marks
                    var match = /^(['"]*)(.*?)['"]*$/.exec(wordContainer.word);
                    var sWordTrimmed = match ? match[2] : wordContainer.word;
                    var correct = CKEDITOR.SpellChecker.checkSpelling(sWordTrimmed);
                    if (correct)
                        continue;

                    var wordPortions = wordContainer.portions;
                    for (var j = 0; j < wordPortions.length; j++) {
                        var portion = wordPortions[j];
                        var portionNode = portion.node;
                        if (portionNode === txtnode)
                            bFoundCurrentNode = true;
                        if (!bReplaceNodes)
                            continue;

                        if (portionNode === txtnode) {
                            // Create new nodes for the current node, but don't put them in
                            // yet because we would invalidate the node
                            if (portion.startIndex > 0) {
                                aNodeSplits.push(doc.createTextNode(portion.node.nodeValue.substring(iNextNodeSplitSubstringStart, portion.startIndex)));
                            }
                            var replacementString = portion.endIndex > 0 ? portion.node.nodeValue.substring(portion.startIndex, portion.endIndex) : portion.node.nodeValue.substring(portion.startIndex);
                            aNodeSplits.push(createReplacement(replacementString));
                            iNextNodeSplitSubstringStart = portion.endIndex >= 0 ? portion.endIndex : portion.node.nodeValue.length;

                            if (i === 0 && j === 0)
                                firstNode = aNodeSplits[0];
                            if (i === aWordContainers.length - 1 && j === wordPortions.length - 1)
                                lastNode = aNodeSplits[aNodeSplits.length - 1];
                        }
                        else {
                            var parent = portionNode.parentNode;

                            // This node comes before or after `txtnode`
                            if (bFoundCurrentNode && portion.endIndex > 0 && portion.endIndex < portion.node.nodeValue.length - 1) {
                                // Split node (that comes right of `txtnode`) into 2
                                var left = createReplacement(portion.node.nodeValue.substring(0, portion.endIndex));
                                var right = doc.createTextNode(portion.node.nodeValue.substring(portion.endIndex));
                                portion.node.parentNode.insertBefore(left, portion.node);
                                portion.node.parentNode.insertBefore(right, portion.node);
                                portion.node.parentNode.removeChild(portion.node);

                                if (i === aWordContainers.length - 1 && j === wordPortions.length - 1)
                                    lastNode = left;

                                bSomethingChanged = true;
                            }
                            else if (!bFoundCurrentNode && portion.startIndex > 0) {
                                // Split node (that comes left of `txtnode`) into 2
                                var left = doc.createTextNode(portion.node.nodeValue.substring(0, portion.startIndex));
                                var right = createReplacement(portion.node.nodeValue.substring(portion.startIndex));
                                portion.node.parentNode.insertBefore(left, portion.node);
                                portion.node.parentNode.insertBefore(right, portion.node);
                                portion.node.parentNode.removeChild(portion.node);

                                if (i === 0 && j === 0)
                                    firstNode = right;

                                bSomethingChanged = true;
                            }
                            else {
                                // Wrap whole node
                                var replacement = createReplacement(portion.node.nodeValue);
                                portion.node.parentNode.replaceChild(replacement, portion.node);

                                if (i === 0 && j === 0)
                                    firstNode = replacement;
                                if (i === aWordContainers.length - 1 && j === wordPortions.length - 1)
                                    lastNode = replacement;

                                bSomethingChanged = true;
                            }

                            // Remove double-nested spelling spans
                            var $nestingSpan = $(parent).closest('.ddspellcheck');
                            $nestingSpan.replaceWith($nestingSpan.contents());
                            // NOTE:  Don't need to do this with the portionNode === node
                            //        case because we already checked that this `node` is
                            //        not within one such span.
                        }
                    }
                }
                if (aNodeSplits.length) {
                    if (iNextNodeSplitSubstringStart < txtnode.nodeValue.length) {
                        aNodeSplits.push(doc.createTextNode(txtnode.nodeValue.substring(iNextNodeSplitSubstringStart)));
                        iNextNodeSplitSubstringStart = txtnode.nodeValue.length;
                    }

                    for (var i = 0; i < aNodeSplits.length; i++) {
                        txtnode.parentNode.insertBefore(aNodeSplits[i], txtnode)
                    }
                    txtnode.parentNode.removeChild(txtnode);

                    bSomethingChanged = true;
                }

                return {
                    endpoints:          [ firstNode, lastNode ],
                    somethingChanged:   bSomethingChanged
                };
            },

            /**
             * Looks for .ddspellcheck elements within the given `element` that are now invalid.
             * Invalid .ddspellcheck elements are those that:
             *  * Contain whitespace (contain more than a word)
             *  * Contain a correctly spelled word
             *  * Only part of a word is marked by .ddspellcheck spans
             * @param {HTMLElement|string} element  The element or element ID to look within for bad .ddspellcheck elements
             */
            checkSpans:  function(element) {
                if (typeof element === 'string' || element instanceof String) {
                    element = this.editor.document.$.getElementById(element);
                    if (!element || !element.ownerDocument.body.contains(element))
                        return;
                }

                var selection = null;
                var bookmarks = null;
                var bSomethingChanged = false;
                var wasDirty = this.editor.checkDirty();

                var removeElement = function(element) {
                    if (!element)
                        return;

                    if (!selection) {
                        selection = this.editor.getSelection();
                    }
                    if (selection && !bookmarks) {
                        bookmarks = selection.createBookmarks(true);
                    }
                    var $element = $(element);
                    $element.replaceWith($element.contents());

                    bSomethingChanged = true;
                }.bind(this);

                // Call this when the DOM contains invalid nodes to prevent IE from crashing the
                // process.  This will erase invalid nodes by setting the element's HTML to its
                // owner innerHTML and restart the spellcheck.
                var fixDom = function() {
                    this.disableSpellCheck();

                    element.innerHTML = element.innerHTML;  // Clean DOM tree of bad nodes
                    var selection = this.editor.getSelection();
                    selection && selection.reset();

                    setTimeout(function() {
                        if (typeof element.parentNode !== 'unknown' && element.ownerDocument.body.contains(element)) {
                            this.enableSpellCheck(false);
                            this.spellCheckElement(element.id, false);
                        }
                    }.bind(this), 1);
                }.bind(this);

                $(element).find('.ddspellcheck').each(function(i, highlight) {
                    if (!this.ownerDocument.body.contains(this)) {
                        // This could happen if we found a nested .ddspellcheck during iteration and removed it.
                        DocHandleError('cernscayt - checkSpans - ddspellcheck not contained in its document; skipping it', 'DynDocCKEditor', '', '');
                        return;
                    }

                    // Check for nested spans.  This shouldn't happen.  But if it does, fix it.
                    var $nested = $(this).find('.ddspellcheck');
                    if ($nested.length)
                        DocHandleError('cernscayt - checkSpans - found nested ddspellcheck span', 'DynDocCKEditor', '', '');
                    $nested.each(function() { removeElement(this) });

                    CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
                    if (highlight.innerText.search(CKEDITOR.SpellChecker.RE_WORD_BOUNDARY) >= 0) {
                        removeElement(highlight);
                    }
                    else {
                        var word = highlight.innerText;

                        var aOtherNodes = [];    // Used to detect if a word is only partially marked for misspelling

                        // Extend left until we find a word boundary
                        var current = DDCOMMON.getFirstTextNode(highlight);
                        while (current) {
                            current = DDCOMMON.getPreviousInlineTextnode(current);
                            if (current && typeof current.parentNode === 'unknown') {
                                DocHandleError('checkSpans - node is invalid; skipping', 'DynDocCKEditor');
                                fixDom();
                                return false; // break out of jQuery `each`
                            }
                            if (!current)
                                break;
                            if (current.nodeValue.length === 0)
                                continue;
                            if (DDCOMMON.isFillingChar(current))
                                continue;

                            var iLastBoundary = DDCOMMON.searchLast(current.nodeValue, CKEDITOR.SpellChecker.RE_WORD_BOUNDARY);
                            if (iLastBoundary >= current.nodeValue.length - 1)
                                break;

                            aOtherNodes.push(current);

                            if (iLastBoundary < 0) {
                                word = current.nodeValue + word;
                            }
                            else {
                                word = current.nodeValue.substring(iLastBoundary + 1);
                                break;
                            }
                        }

                        // Extend right until we found a word boundary
                        current = DDCOMMON.getLastTextNode(highlight);
                        while (current) {
                            current = DDCOMMON.getNextInlineTextnode(current);
                            if (current && typeof current.parentNode === 'unknown') {
                                DocHandleError('checkSpans - node is invalid; skipping', 'DynDocCKEditor');
                                fixDom();
                                return false; // break out of jQuery `each`
                            }
                            if (!current)
                                break;
                            if (current.nodeValue.length === 0)
                                continue;
                            if (DDCOMMON.isFillingChar(current))
                                continue;

                            CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
                            var iFirstBoundary = current.nodeValue.search(CKEDITOR.SpellChecker.RE_WORD_BOUNDARY);
                            if (iFirstBoundary === 0)
                                break;

                            aOtherNodes.push(current);

                            if (iFirstBoundary < 0) {
                                word += current.nodeValue;
                            }
                            else {
                                word = current.nodeValue.substring(0, iFirstBoundary);
                                break;
                            }
                        }

                        var correct = CKEDITOR.SpellChecker.checkSpelling(word);
                        if (correct) {
                            // Remove all misspell spans for this correct word
                            removeElement(highlight);

                            for (var i = 0; i < aOtherNodes.length; i++) {
                                var node = aOtherNodes[i];
                                removeElement($(node.parentNode).closest('.ddspellcheck')[0]);
                            }
                        }
                        else {
                            // If only part of a word is marked, remove all misspell spans
                            for (var i = 0; i < aOtherNodes.length; i++) {
                                var node = aOtherNodes[i];
                                if ($(node.parentNode).closest('.ddspellcheck').length === 0) {
                                    removeElement(highlight);
                                    break;
                                }
                            }
                        }
                    }
                });

                if (bookmarks)
                    selection.selectBookmarks(bookmarks);

                if (bSomethingChanged)
                    this.editor.fire('updateSnapshot');

                // If the spellcheck plugin modified the dirty state, reset it
                if (!wasDirty && this.editor.checkDirty()) {
                    this.editor.resetDirty();
                }
            },

            /**
             * Queues the given element for a cleanup task
             *
             * If no cleanup task is currently in progress, this will dequeue the first queued
             * cleanup and start the task.
             * @param {HTMLElement} element     The element to cleanup
             * @see CKEDITOR.SpellChecker.prototype#doCleanup
             */
            queueCleanupElement:  function(element) {
                if (!this.bCleanupsEnabled || !element)
                    return;

                if (this.currentCleanup && this.currentCleanup.element === element)
                    return;
                var lastCleanup = this.aQueuedCleanups[this.aQueuedCleanups.length-1];
                if (lastCleanup && typeof lastCleanup.element.parentNode !== 'unknown' && element === lastCleanup.element)
                    return;

                this.aQueuedCleanups.push({
                    element:  element
                });

                if (!this.currentCleanup && (this.editor.contextMenu == null || !this.editor.contextMenu.isVisible()))
                    this.dequeueCleanup();
            },

            /**
             * Dequeue the front cleanup task, and start the task.
             *
             * If there is already a task running, this will do nothing.
             */
            dequeueCleanup:  function() {
                if (!CKEDITOR.SpellChecker.bEnabled || !this.bEnabled)
                    return;
                if (!this.bCleanupsEnabled)
                    return;
                if (this.currentCleanup)
                    return;

                if (new Date().getTime() - this.lastCleanup < 2000) {
                    CKEDITOR.tools.setTimeout(this.dequeueCleanup, 2001, this);
                    return;
                }

                // If user is scrolling, do the cleanup later to avoid unintentional scroll while
                // saving & restoring the cursor position
                if (this.isScrolling()) {
                    CKEDITOR.tools.setTimeout(this.dequeueCleanup, 600, this);
                    return;
                }

                var cleanup = this.aQueuedCleanups.shift();
                if (!cleanup)
                    return;

                try {
                    this.doCleanup(cleanup);
                }
                catch (e) {
                    this.handleException(e, 'cleanup-dequeue');
                }
            },

            /**
             * Check an element for adjacent .ddspellcheck spans that can be combined.
             * @param {Object} cleanup  Contains the element that should be cleaned-up
             */
            doCleanup:  function(cleanup) {
                var cleanupTheCleanup = function() {
                    this.currentCleanup = null;
                    this.lastCleanup = new Date().getTime();
                    this.dequeueCleanup();
                }.bind(this);

                if (cleanup.element == null || typeof cleanup.element.parentNode === 'unknown') {
                    console.log('Cleanup no good for invalid element');
                    cleanupTheCleanup();
                    return;
                }
                if (!cleanup.element.ownerDocument.body.contains(cleanup.element)) {
                    cleanupTheCleanup();
                    return;
                }

                this.currentCleanup = cleanup;

                // First, lets normalize the element
                var selection = this.editor.getSelection(true);
                var range = selection && selection.getRanges()[0];
                if (range && !range.collapsed) {
                    // If selection is not collapsed, restart the cleanup task
                    this.interruptCleanup();
                    this.dequeueCleanup();
                    return;
                }

                var boundaries = range && range.getBoundaryNodes();
                var cursorNode = boundaries && boundaries.startNode && boundaries.startNode.$;
                if (selection && (cursorNode === cleanup.element || DDCOMMON.isAncestor(cursorNode, cleanup.element)))
                    var bookmarks = selection.createBookmarks(true);

                // FUTURE:  Re-enable call to `normalize` when corrupt nodes issue is cleared up.
                //          This might be causing the process to crash if the DOM contains corrupt
                //          nodes (IE8-).
                //cleanup.element.normalize();    // Messes up cursor position in IE if the cursor is within the element being normalized

                // Native IE8- normalize will wrap text nodes (this is different than the
                // MSDN description of normalize - shame on MS).  We should make sure the
                // call to normalize doesn't create nested .ddspellcheck.
                // NOTE:  Did not observe this behavior in IE9.
                $(cleanup.element).find('.ddspellcheck .ddspellcheck').each(function() {
                    var $this = $(this);
                    $this.replaceWith($this.contents());
                });

                if (bookmarks) {
                    this.lockEditorScroll();
                    try {
                        selection.selectBookmarks(bookmarks);
                    }
                    finally {
                        CKEDITOR.tools.setTimeout(this.unlockEditorScroll, 0, this);
                    }
                }

                var $spans = $(cleanup.element).find('.ddspellcheck');

                var editor = this.editor;

                var reallyDoCleanup = function() {
                    var wasDirty = this.editor.checkDirty();
                    var span = Array.prototype.pop.call($spans);
                    if (span == null || typeof span.parentNode === 'unknown')
                        return;
                    if (!span.ownerDocument.body.contains(span))
                        return;
                    if (span.previousSibling && typeof span.previousSibling.parentNode === 'unknown' ||
                    span.nextSibling && typeof span.nextSibling.parentNode === 'unknown')
                        throw new Error('Corrupt node at current spellcheck span');

                    var selection = editor.getSelection(true);
                    var bookmarks = null;
                    var createBookmarks = selection ? function() {
                        if (bookmarks)
                            return;
                        if (selection)
                            bookmarks = selection.createBookmarks(true);
                    } : $.noop;

                    // If cursor is in the nodes that we are combining, we will trash the bookmark;
                    // Don't combine nodes if the cursor is in one of them
                    var range = selection && selection.getRanges()[0];
                    if (range) {
                        var boundaries = range.getBoundaryNodes();
                        var cursorNode = boundaries && boundaries.startNode && boundaries.startNode.$;
                        if (cursorNode) {
                            if (cursorNode.previousSibling && typeof cursorNode.previousSibling.parentNode === 'unknown' ||
                            cursorNode.nextSibling && typeof cursorNode.nextSibling.parentNode === 'unknown')
                                throw new Error('Corrupt node at selection boundaries');
                        }
                    }

                    if (cursorNode === span || DDCOMMON.isAncestor(cursorNode, span))
                        return;
                    // Make checks prior to messing up the DOM:
                    var bCheckPrevious = !(cursorNode === span.previousSibling || DDCOMMON.isAncestor(cursorNode, span.previousSibling));
                    var bCheckNext = !(cursorNode === span.nextSibling || DDCOMMON.isAncestor(cursorNode, span.nextSibling));

                    var $span = $(span);

                    var bSomethingChanged = false;

                    if (bCheckPrevious) {
                        var $prev = $(span.previousSibling);
                        if ($prev.hasClass('ddspellcheck')) {
                            createBookmarks();
                            $span.prepend($prev.contents());
                            $prev.remove();
                            bSomethingChanged = true;
                        }
                    }

                    if (bCheckNext) {
                        var $next = $(span.nextSibling);
                        if ($next.hasClass('ddspellcheck')) {
                            createBookmarks();
                            $span.append($next.contents());
                            $next.remove();
                            bSomethingChanged = true;
                        }
                    }

                    if (bookmarks) {
                        this.lockEditorScroll();
                        try {
                            selection.selectBookmarks(bookmarks);
                        }
                        finally {
                            CKEDITOR.tools.setTimeout(this.unlockEditorScroll, 0, this);
                        }
                    }

                    if (bSomethingChanged)
                        editor.fire('updateSnapshot');

                    // If the cleanup function modified the dirty state, reset it
                    if (!wasDirty && this.editor.checkDirty()) {
                        this.editor.resetDirty();
                    }
                }.bind(this);

                // Break up work into pieces; async
                var delayNextCleanup = function() {
                    cleanup.timeout = CKEDITOR.tools.setTimeout(function() {
                        if (this.isScrolling()) {
                            this.interruptCleanup();
                            return;
                        }

                        try {
                            reallyDoCleanup();
                            if ($spans.length)
                                delayNextCleanup();
                            else
                                cleanupTheCleanup();
                        }
                        catch (e) {
                            this.handleException(e, 'cleanup');
                        }
                    }, 100, this);
                }.bind(this);

                delayNextCleanup();
            },

            /**
             * Stops the current cleanup operation and puts it back in the front of the queue
             */
            interruptCleanup:  function() {
                if (!this.currentCleanup)
                    return;

                // Stop current cleanup task; put it at the front of the queue
                clearTimeout(this.currentCleanup.timeout);
                this.aQueuedCleanups.unshift(this.currentCleanup);
                this.currentCleanup = null;
                this.lastCleanup = new Date().getTime();    // reset cleanup time so that next dequeueCleanup doesn't execute cleanup immediately
            },

            /**
             * Logs an exception, and stops spellcheck for a short while
             *
             * @param {Object}  e       Exception
             * @param {string}  task    Describes which cernscayt task the exception occurred in
             */
            handleException:  function(e, task) {
                var message = 'cernscayt - Exception ' + (task || '') + ':  ' + (e.message || e);
                DocHandleError(message, 'DynDocCKEditor');
                var data = window.printStackTrace ? 'Stacktrace:\r\n' + printStackTrace().join('\r\n') : '';
                CKEDITOR.DocUtilsHelper.LogException('DynDocCKEditor', message, 'plugins/cernscayt/plugin.js', '', data);

                this.editor.disableSpellCheck();
                // Give the browser time to recover, then re-enable spellcheck
                var editorName = this.editor.name;
                CKEDITOR.tools.setTimeout(function() {
                    // Check if editor has been destroyed first
                    if (CKEDITOR.instances[editorName] === this.editor)  // CKE 4.1+ can use editor.status instead
                        this.editor.enableSpellCheck();
                }, 5000, this);
            },

            /**
             * Enable spellcheck for this editor
             * @param {Boolean} [spellCheckCurrentElement]
             *                      Whether or not to start spellchecking the element at the current
             *                      cursor position
             */
            enableSpellCheck:  function(spellCheckCurrentElement) {
                this.bEnabled = CKEDITOR.SpellChecker.bEnabled;

                if (spellCheckCurrentElement)
                    this.spellCheckCurrentElement();
            },

            /**
             * Disable spellcheck for this editor and stop currently running spellcheck tasks
             */
            disableSpellCheck:  function() {
                this.bEnabled = false;

                for (var id in this.mapTraversals) {
                    if (!this.mapTraversals.hasOwnProperty(id))
                        continue;

                    var traversal = this.mapTraversals[id];
                    traversal && traversal.cancel();
                }

                this.interruptCleanup();
            },

            /**
             * Creates a unique ID, and returns it
             * @param {boolean} [bTemporary=false]  Whether or not the ID is to be saved with the document
             * @returns {string}    The ID
             * @static
             */
            createUniqueId:  function(bTemporary) {
                if (!bTemporary && top.DocUtilsHelper)
                    return top.DocUtilsHelper.GenerateGUID();

                if (!CKEDITOR.SpellChecker.nextUniqueNum)
                    CKEDITOR.SpellChecker.nextUniqueNum = 1;
                do {
                    var num = CKEDITOR.SpellChecker.nextUniqueNum++;
                    var sId = 'scayt' + num;
                }
                while (this.editor.document.$.getElementById(sId));

                return sId;
            }
        },

        statics:  {
            RE_WORD_CHARACTER:  /[a-zA-Z0-9\u2019\u00C0-\u02AF\u0386-\u04FF']/gm,
            RE_WORD_BOUNDARY:   /[^a-zA-Z0-9\u2019\u00C0-\u02AF\u0386-\u04FF']/gm,
            RE_WORD_BOUNDARIES: /[^a-zA-Z0-9\u2019\u00C0-\u02AF\u0386-\u04FF']+/gm,
            // 0x00C0-0x02AF - accented characters, Latin Extended, IPA Extensions
            // 0x0386-0x04FF - Greek and Coptic Cryllic
            // \u2019 - Angled apostrophe
            // See http://en.wikipedia.org/wiki/List_of_Unicode_characters

            bEnabled:  true,

            /**
             * @param {String} word     Word to spellcheck
             * @returns {Boolean} Spelled correctly or incorrectly
             * @static
             */
            checkSpelling:  function(word) {
                word = word.replace('\u2019', "'");
                var spelledCorrectly = CKEDITOR.SpellCheckHelper.CheckSpelling(word);
                return spelledCorrectly;
            },

            /**
             * Finds words in the given text node, and adjacent text nodes if words extend past the text node
             * @param {TextNode} txtnode
             * @returns {Object[]}  Array of objects like:
             *                          {
             *                              word:  string,
             *                              portions:   [
             *                                  {
             *                                      node:       TextNode,
             *                                      startIndex: Integer,
             *                                      endIndex:   Integer
             *                                  }
             *                              ]
             *                          }
             *                          where startIndex and endIndex are the index of the word into the node, or -1
             * @static
             */
            findWordPortions:  function(txtnode) {
                var wordContainers = [];

                // Find words within the txtnode
                var lastIndex = -1;
                do {
                    var wordStart = DDCOMMON.searchFrom(txtnode.nodeValue, CKEDITOR.SpellChecker.RE_WORD_CHARACTER, lastIndex + 1);
                    var wordEnd = DDCOMMON.searchFrom(txtnode.nodeValue, CKEDITOR.SpellChecker.RE_WORD_BOUNDARY, wordStart);

                    if (wordStart < 0)
                        break;

                    var word = wordEnd > wordStart ? txtnode.nodeValue.substring(wordStart, wordEnd) : txtnode.nodeValue.substring(wordStart);

                    var wordPortions = [
                        {
                            node:       txtnode,
                            startIndex: wordStart,
                            endIndex:   wordEnd     // -1 indicates that the word end is not found in `node`
                        }
                    ];
                    wordContainers.push({
                        word:       word,
                        portions:   wordPortions
                    });

                    lastIndex = wordEnd;
                }
                while (lastIndex >= 0);

                if (wordContainers.length === 0)
                    return wordContainers;

                // If first word started at the beginning of `txtnode`, we should look left for nodes
                // inline with `txtnode` that continue the word that starts at `txtnode`.
                if (wordContainers[0].portions[0].startIndex === 0) {
                    var current = wordContainers[0].portions[0].node;
                    var lastBoundary = -1;
                    do {
                        current = DDCOMMON.getPreviousInlineTextnode(current);
                        if (!current)
                            break;

                        if (current.nodeValue.length === 0)
                            continue;

                        lastBoundary = DDCOMMON.searchLast(current.nodeValue, CKEDITOR.SpellChecker.RE_WORD_BOUNDARY);
                        if (lastBoundary >= current.nodeValue.length - 1) // If node ends in boundary character, it is not part of the word
                            break;

                        var portion;
                        wordContainers[0].portions.unshift(portion = {
                            node:       current,
                            startIndex: lastBoundary >= 0 ? lastBoundary + 1 : 0,
                            endIndex:   -1      // -1 indicates that the word end is not found in this node
                        });
                        wordContainers[0].word = portion.node.nodeValue.substring(portion.startIndex) + wordContainers[0].word;
                    }
                    while (current && lastBoundary < 0);   // Keep going until we find node boundary
                }

                // If last word started at the end of `txtnode`, we should look right for nodes inline
                // with `txtnode` taht continue the word that ends at `txtnode`.
                var lastContainer = wordContainers[wordContainers.length-1];
                var lastPortion = lastContainer.portions[lastContainer.portions.length-1];
                if (lastPortion.endIndex > lastPortion.node.nodeValue.length - 1 || lastPortion.endIndex < 0) {
                    var current = lastPortion.node;
                    var firstBoundary = -1;
                    do {
                        current = DDCOMMON.getNextInlineTextnode(current);
                        if (!current)
                            break;

                        if (current.nodeValue.length === 0)
                            continue;

                        CKEDITOR.SpellChecker.RE_WORD_BOUNDARY.lastIndex = 0;
                        firstBoundary = current.nodeValue.search(CKEDITOR.SpellChecker.RE_WORD_BOUNDARY);
                        if (firstBoundary === 0) // If node starts with boundary character, it is not part of the word
                            break;

                        var portion;
                        lastContainer.portions.push(portion = {
                            node:       current,
                            startIndex: 0,
                            endIndex:   firstBoundary   // -1 indicates that the word end is not found in this node
                        });
                        lastContainer.word += portion.endIndex < 0 ? portion.node.nodeValue.substring(portion.startIndex) : portion.node.nodeValue.substring(portion.startIndex, portion.endIndex);
                    }
                    while (current && firstBoundary < 0);   // Keep going until we find node boundary
                }

                return wordContainers;
            },

            /**
             * A handler for a context menu listener in editor.contextMenu
             *
             * This populates suggested spellings for the currently selected word, and adds them to
             * the context menu.
             * @param {CKEDITOR.editor} editor
             * @param {CKEDITOR.dom.element} element
             * @param {CKEDITOR.dom.selection} selection
             * @returns {Object}    Spelling suggestions
             * @static
             */
            contextMenuHandler:  function(editor, element, selection) {
                if (selection == null || selection.getRanges().length == 0) {
                    DocHandleError('SpellCheckPluginHelper::contextMenuHandler, selection has no ranges');
                    return null;
                }

                // Don't display suggestions for read-only words
                if (selection.getRanges()[0].checkReadOnly())
                    return null;

                var range = editor.document.$.selection.createRange();
                if (!range.moveStart) {
                    DocHandleError('contextMenuHandler - Range is not TextRange', 'DynDocCKEditor', '', '');
                    return null;
                }
                trimRangeWhitespace(range); // remove whitespace from left and right part of selection.

                var selectedElement = range.parentElement();
                if (!selectedElement)
                    return null;

                var $editableAncestor = $(selectedElement).closest('[contentEditable=true]');
                if ($editableAncestor.length === 0) {
                    DocHandleError('contextMenuHandler - Cannot find contentEditable ancestor of misspelled word', 'DynDocCKEditor', '', '');
                    return null;
                }
                var wordRange = getWordRangeAtCursor(range, $editableAncestor[0]);
                var word = $.trim(wordRange.text);
                CKEDITOR.SpellChecker.RE_WORD_CHARACTER.lastIndex = 0;
                if (!word || !CKEDITOR.SpellChecker.RE_WORD_CHARACTER.test(word))
                    return null;

                // Check for surrounding quotations in the word
                var wordTrimMatch = /^(['"]*)(.*?)['"]*$/.exec(word);
                word = wordTrimMatch ? wordTrimMatch[2] : word;

                // Don't display suggestions for words that are spelled correctly
                var spelledCorrectly = CKEDITOR.SpellChecker.checkSpelling(word);
                if (spelledCorrectly)
                    return null;

                // Get suggested spellings for the word
                var items_suggestion = CKEDITOR.SpellCheckHelper.GetSuggestedSpelling(word);
                var suggestionsEnabledStatus = CKEDITOR.TRISTATE_OFF;
                if (!items_suggestion || !items_suggestion.length) {
                    items_suggestion = editor.lang.cernscayt.noSpellingSuggestions;
                    suggestionsEnabledStatus = CKEDITOR.TRISTATE_DISABLED;
                }
                items_suggestion = items_suggestion.split('\n');

                var mainSuggestions = {};

                var maxSuggestions = editor.config.scayt_maxSuggestions;
                if (typeof maxSuggestions != 'number')
                    maxSuggestions = 5;

                if (!maxSuggestions)
                    maxSuggestions = items_suggestion.length;

                /*  // TODO: Add the spellcheck commands (ignore, add, etc.) to the context menus
                 var contextCommands = oEditor.config.scayt_contextCommands || 'all';
                 contextCommands = contextCommands.split( '|' );
                 */

                // Add commands for each suggestion using the format scayt_suggestion_1, scayt_suggestion_2, ...
                // placing the suggested word on the respective commands in the suggestedWord field.
                for (var i = 0, l = items_suggestion.length; i < l; i += 1) {
                    var commandName = 'scayt_suggestion_' + i;
                    var exec = (function(sTextNew, oWordRange) {
                        return {
                            editorFocus: false,
                            exec: function () {
                                if (sTextNew.length > 0) {
                                    if (replaceMisspelledWord(oWordRange, sTextNew)) {
                                        // If the range contained whitespace, don't leave it selected.
                                        // Since replaceMisspelledWord changed the oWordRange text, the range is at the
                                        // end of the word.
                                        oWordRange.select();
                                    }
                                    this.canUndo = false;
                                }
                            }
                        };
                    })(items_suggestion[i], wordRange);

                    exec.canUndo = true;
                    exec.suggestedWord = items_suggestion[i];

                    if (i < maxSuggestions) {
                        CKEDITOR.SpellChecker.addButtonCommand(editor, items_suggestion[i], commandName, exec, 'scayt_suggest', i + 1);
                        mainSuggestions[commandName] = suggestionsEnabledStatus;
                    }
                }

                /*  // TODO: Add the spellcheck commands (ignore, add, etc.) to the context menus
                 if ( in_array( 'all', contextCommands )  || in_array( 'ignore', contextCommands)  )
                 {
                 var ignore_command = {
                 exec: function(){
                 scayt_control.ignore( node );
                 }
                 };
                 addButtonCommand( lang.ignore, 'scayt_ignore', ignore_command, 'scayt_control', 1 );
                 mainSuggestions[ 'scayt_ignore' ] = CKEDITOR.TRISTATE_OFF;
                 }

                 if ( in_array( 'all', contextCommands )  || in_array( 'ignoreall', contextCommands ) )
                 {
                 var ignore_all_command = {
                 exec: function(){
                 scayt_control.ignoreAll( node );
                 }
                 };
                 addButtonCommand(lang.ignoreAll, 'scayt_ignore_all', ignore_all_command, 'scayt_control', 2);
                 mainSuggestions['scayt_ignore_all'] = CKEDITOR.TRISTATE_OFF;
                 }

                 if ( in_array( 'all', contextCommands )  || in_array( 'add', contextCommands ) )
                 {
                 var addword_command = {
                 exec: function(){
                 window.scayt.addWordToUserDictionary( node );
                 }
                 };
                 addButtonCommand(lang.addWord, 'scayt_add_word', addword_command, 'scayt_control', 3);
                 mainSuggestions['scayt_add_word'] = CKEDITOR.TRISTATE_OFF;
                 }
                 */

                return mainSuggestions;
            },

            /**
             * Add spellcheck command with context menu
             * @param {CKEDITOR.editor} editor
             * @param {String} sLabel       Command label name (i18n or dictionary)
             * @param {String} sCmdName     Command name
             * @param {Object} oCommand     Command definition
             * @param {String} ctxMenuGroup Command group in context menu
             * @param {Number} ctxMenuOrder Command order in context menu
             * @static
             */
            addButtonCommand: function (editor, sLabel, sCmdName, oCommand, ctxMenuGroup, ctxMenuOrder) {
                // Add command
                editor.addCommand(sCmdName, oCommand);

                // If the "menu" plugin is loaded, register the menu item.
                if (editor.addMenuItems) {
                    editor.addMenuItem(sCmdName, {
                        label: sLabel,
                        command: sCmdName,
                        group: ctxMenuGroup,
                        order: ctxMenuOrder
                    });
                }
            }
        } // statics
    }); // CKEDITOR.SpellChecker

})();

CKEDITOR.plugins.add('cernscayt', {
    lang: 'en,en-gb,de,fr,es,pt-br',

    checkers:  {},

    init:  function(editor) {
        this.checkers[editor.name] = new CKEDITOR.SpellChecker(editor);

        var dirtyFilter = function(frag) {
            $(frag).find('.ddspellcheck').each(function() {
                var $spellcheck = $(this);
                $spellcheck.replaceWith($spellcheck.contents());
            });
            $(frag).find('[id^="scayt"]').removeAttr('id');
        };

        if (editor.registerDirtyFilter) {
            editor.registerDirtyFilter(function(frag) {
                dirtyFilter(frag.firstChild);
            });
        }
        if (editor.registerXhtmlFilter) {
            editor.registerXhtmlFilter(function(detached) {
                dirtyFilter(detached);
            });
        }
        if (editor.contextMenu && editor.addMenuItems) {
            editor.addMenuGroup('scayt_suggest', -1);
            editor.contextMenu.addListener(CKEDITOR.SpellChecker.contextMenuHandler.bind(this, editor));
        }
    }
});

///////////////////////////////
//* F3 HELPER IS OVERRIDDEN *//
///////////////////////////////
F3Helper = function() {
    return {
        isFreeText: function (oElement) {
            return true;
        }
    }
}();


CKEDITOR.plugins.add('cernf3', {
    lang: 'en,en-au,en-gb,de,fr,es,pt-br',

    init: function(editor) {
        var ddf3 = {
            canUndo: false,
            editorFocus: false,
            exec: function(editor) {
                var oInitialRange = editor.document.$.selection.createRange();
                // Make sure selection is in this document (not an iframe)
                if (oInitialRange.parentElement && oInitialRange.parentElement().ownerDocument !== editor.document.$)
                    return;

                // Search until reaching end of document twice.  First search goes from cursor position to end of document.
                // Second search goes from beginning of document to end of document (no simple way to detect when done searching
                // beginning to cursor position)
                var iEndOfDocument = 0;
                var bEndFound = false;
                while (iEndOfDocument < 2) {
                    var oRangeToSearch = oInitialRange.duplicate();

                    // If there are no more underscores left to select in the document
                    // it cycles back to the beginning
                    if (bEndFound) {
                        oInitialRange.collapse(true);
                        oInitialRange.moveToElementText(editor.document.$.body);
                        oRangeToSearch = oInitialRange.duplicate();
                        bEndFound = false;
                    }
                    // If the end of document has not been reached, range will
                    // surrounds everything after the most recently selected underscore
                    else {
                        oRangeToSearch.setEndPoint("StartToEnd", oInitialRange);
                        oInitialRange.moveToElementText(editor.document.$.body);
                        oRangeToSearch.setEndPoint("EndToEnd", oInitialRange);
                    }

                    // Finds the next underscore and sets the beginning and end
                    // of the range to surround it
                    if (oRangeToSearch.findText("_")) {
                        // Gets parent of the current underscore's text element
                        var oRange2Parent = oRangeToSearch.parentElement();

                        // Based on the text node the underscore is in, determines
                        // if it is inside free text or not
                        var bIsFreeText = F3Helper.isFreeText(oRange2Parent);
                        if (bIsFreeText) {
                            oRangeToSearch.select();
                            return;
                        }
                        // If underscore is not in a free text area, collapse the range to the end(false)
                        else {
                            oRangeToSearch.collapse(false);
                            oInitialRange = oRangeToSearch;
                        }
                    }
                    // If no underscore is found in the rest of the document
                    else {
                        bEndFound = true;
                        iEndOfDocument++;
                    }
                }
            } // exec
        };

        var ddf3_back = {
            canUndo: false,
            editorFocus: false,
            exec: function(editor) {
                var oInitialRange = editor.document.$.selection.createRange();

                // Search until reaching beginning of document twice.  First search goes from cursor position to beginning of document.
                // Second search goes from end of document to beginning of document (no simple way to detect when done searching
                // end to cursor position)
                var iStartOfDocument = 0;
                var bStartFound = false;
                while (iStartOfDocument < 2) {
                    var oRangeToSearch = oInitialRange.duplicate();

                    // If there are no more underscores left to select in the document
                    // it cycles backwards to the end
                    if (bStartFound) {
                        oInitialRange.collapse(false);
                        oInitialRange.moveToElementText(editor.document.$.body);
                        oRangeToSearch = oInitialRange.duplicate();
                        bStartFound = false;
                    }
                    // If the beginning of document has not been reached, range will
                    // surrounds everything before the most recently selected underscore
                    else {
                        oRangeToSearch.setEndPoint("EndToStart", oInitialRange);
                        oInitialRange.moveToElementText(editor.document.$.body);
                        oRangeToSearch.setEndPoint("StartToStart", oInitialRange);
                    }

                    // Finds the next underscore going backwards(-1) and sets the beginning and end
                    // of the range to surround it
                    if (oRangeToSearch.findText("_", -1, 0)) {
                        // Gets parent of the current underscore's text element
                        var oRange2Parent = oRangeToSearch.parentElement();

                        // Based on the text node the underscore is in, determines
                        // if it is inside free text or not
                        var bIsFreeText = F3Helper.isFreeText(oRange2Parent);
                        if (true == bIsFreeText) {
                            oRangeToSearch.select();
                            return;
                        }

                        // If underscore is not in a free text area, collapse the range to the beginning (true)
                        else {
                            oRangeToSearch.collapse(true);
                            oInitialRange = oRangeToSearch;
                        }
                    }

                    // If no underscore is found in the rest of the document
                    else {
                        bStartFound = true;
                        iStartOfDocument++;
                    }
                }
            }
        };

        DDCOMMON.addHotKeys(editor, editor.lang.cernf3.HotKeyArray);

        editor.addCommand(DDCMD_PREV_UNDERSCORE, ddf3_back);
        editor.addCommand(DDCMD_NEXT_UNDERSCORE, ddf3);
    }
});

///////////////////////////////
//* F3 HELPER IS OVERRIDDEN *//
///////////////////////////////
F3Helper = function () {
    return {
        isFreeText: function (oElement) {
            return oElement && oElement.isContentEditable;
        }
    }
}();


CKEDITOR.plugins.add('mpagesf3',
{
    lang: 'en,en-au,en-gb,de,fr,es,pt-br',

    init: function (editor) {
        var ddf3 =
		{
		    canUndo: false,
		    // focus prevents error from occurring with findtext while refreshing
		    editorFocus: true,
		    exec: function (editor) {
		    	// -------------------------------
		    	// MPages: set editing area to either the div container or the body...
		    	// based on whether the divarea plugin was used or not.
		    	// divarea plugin being used = no iframe
		    	// -------------------------------
		    	var editingArea = editor.plugins['divarea'] ?  editor.ui.space('contents').$ : editor.document.$.body;
		    	
		        var oInitialRange = editor.document.$.selection.createRange();
		        
		    	// -------------------------------
		    	// MPages: define a TextRange object to cover the editing area
		    	// -------------------------------
		        var editingAreaRange = oInitialRange.duplicate();
		        editingAreaRange.moveToElementText(editingArea);

		        // Search until reaching end of document twice.  First search goes from cursor position to end of document.
		        // Second search goes from beginning of document to end of document (no simple way to detect when done searching
		        // beginning to cursor position)
		        var iEndOfDocument = 0;
		        var bEndFound = false;
		        while (iEndOfDocument < 2) {
			    	// -------------------------------
			    	// MPages: set the initial search area to contain the entire editing area.
		        	// The beginning of the search range will be adjusted later, based on the current cursor position.
			    	// -------------------------------
		            var oRangeToSearch = editingAreaRange.duplicate();
		            
		            // If there are no more underscores left to select in the document
		            // it cycles back to the beginning
		            if (bEndFound == true) {
		                oInitialRange.collapse(true);
				    	// -------------------------------
		                // MPages: update range to wrap the editing area, which could be the document body or the div container
				    	// -------------------------------
		                oInitialRange.moveToElementText(editingArea);
		                oRangeToSearch = oInitialRange.duplicate();
		                bEndFound = false;
		            }

		            // If the end of document has not been reached, range will
		            // surrounds everything after the most recently selected underscore
		            else {	            	
				    	// -------------------------------
				    	// MPages: adjust the beginning of the search range based on the currently selected text or cursor position 
				    	// -------------------------------
		            	if (oInitialRange.text == '_') {
		            		oRangeToSearch.setEndPoint("StartToEnd", oInitialRange);
		            	}
		            	else {
		            		oRangeToSearch.setEndPoint("StartToStart", oInitialRange);
		            	}

		            }

		            // Finds the next underscore and sets the beginning and end
		            // of the range to surround it
		            if (oRangeToSearch.findText("_")) {
				    	// -------------------------------
		            	// MPages: check to see if we've reached past the editingArea, eg. Start of search is >= end of editingArea
				    	// -------------------------------
		            	if (!editingAreaRange.inRange(oRangeToSearch)) {
			                bEndFound = true;
			                iEndOfDocument++;
			                // continue while loop
			                continue;
		            	}
		            		

		                // Gets parent of the current underscore's text element
		                var oRange2Parent = oRangeToSearch.parentElement();

		                // Based on the text node the underscore is in, determines
		                // if it is inside free text or not
		                var bIsFreeText = F3Helper.isFreeText(oRange2Parent);
		                if (true == bIsFreeText) {
		                    oRangeToSearch.select();
		                    return;
		                }

		                // If underscore is not in a free text area, collapse the range to the end(false)
		                else {
		                    oRangeToSearch.collapse(false);
		                    oInitialRange = oRangeToSearch;
		                }
		            }

		            // If no underscore is found in the rest of the document
		            else {
		                bEndFound = true;
		                iEndOfDocument++;
		            }
		        }
		    }
		};

        var ddf3_back =
		{
		    canUndo: false,
		    // focus prevents error from occurring with findtext while refreshing
		    editorFocus: true,
		    exec: function (editor) {
		    	// -------------------------------
		    	// MPages: set editing area to either the div container or the body...
		    	// based on whether the divarea plugin was used or not.
		    	// divarea plugin being used = no iframe
		    	// -------------------------------
		    	var editingArea = editor.plugins['divarea'] ?  editor.ui.space('contents').$ : editor.document.$.body;

		        var oInitialRange = editor.document.$.selection.createRange();

		    	// -------------------------------
		    	// MPages: define a TextRange object to cover the editing area
		    	// -------------------------------
		        var editingAreaRange = oInitialRange.duplicate();
		        editingAreaRange.moveToElementText(editingArea);

		        
		        // Search until reaching beginning of document twice.  First search goes from cursor position to beginning of document.
		        // Second search goes from end of document to beginning of document (no simple way to detect when done searching
		        // end to cursor position)
		        var iStartOfDocument = 0;
		        var bStartFound = false;
		        while (iStartOfDocument < 2) {
			    	// -------------------------------
			    	// MPages: set the initial search area to contain the entire editing area.
		        	// The beginning of the search range will be adjusted later, based on the current cursor position.
			    	// -------------------------------
		            var oRangeToSearch = editingAreaRange.duplicate();
		            
		            // If there are no more underscores left to select in the document
		            // it cycles backwards to the end
		            if (bStartFound == true) {
		                oInitialRange.collapse(false);
				    	// -------------------------------
		                // MPages: update range to wrap the editing area, which could be the document body or the div container
				    	// -------------------------------
		                oInitialRange.moveToElementText(editingArea);
		                oRangeToSearch = oInitialRange.duplicate();
		                bStartFound = false;
		            }

		            // If the beginning of document has not been reached, range will
		            // surrounds everything before the most recently selected underscore
		            else {
				    	// -------------------------------
				    	// MPages: adjust the beginning of the search range based on the currently selected text or cursor position 
				    	// -------------------------------
		            	if (oInitialRange.text == '_') {            	
		            		oRangeToSearch.setEndPoint("EndToStart", oInitialRange);
		            	}
		            	else {
		            		oRangeToSearch.setEndPoint("EndToEnd", oInitialRange);
		            	}

		            }

		            // Finds the next underscore going backwards(-1) and sets the beginning and end
		            // of the range to surround it
		            if (oRangeToSearch.findText("_", -1, 0)) {
				    	// -------------------------------
		            	// MPages: check to see if we've reached past the editingArea, eg. Start of search is >= end of editingArea
				    	// -------------------------------
		            	if (!editingAreaRange.inRange(oRangeToSearch)) {
			                bStartFound = true;
			                iStartOfDocument++;
			                // continue while loop
			                continue;
		            	}

		                // Gets parent of the current underscore's text element
		                var oRange2Parent = oRangeToSearch.parentElement();

		                // Based on the text node the underscore is in, determines
		                // if it is inside free text or not
		                var bIsFreeText = F3Helper.isFreeText(oRange2Parent);
		                if (true == bIsFreeText) {
		                    oRangeToSearch.select();
		                    return;
		                }

		                // If underscore is not in a free text area, collapse the range to the beginning (true)
		                else {
		                    oRangeToSearch.collapse(true);
		                    oInitialRange = oRangeToSearch;
		                }
		            }

		            // If no underscore is found in the rest of the document
		            else {
		                bStartFound = true;
		                iStartOfDocument++;
		            }
		        }
		    }
		};

        DDCOMMON.addHotKeys(editor, editor.lang.mpagesf3.HotKeyArray);

        editor.addCommand(DDCMD_PREV_UNDERSCORE, ddf3_back);
        editor.addCommand(DDCMD_NEXT_UNDERSCORE, ddf3);
    }
});
/*
 * Disables drops into an editor.
 *
 * Currently utilized by MPages to disable dropping any element on page into editor
 */

CKEDITOR.plugins.add('cerndropdisable', {
    init:  function(editor) {
        editor.on('contentDom', function() {
            //Disable drop action in editor
            var editable = editor.editable();
            editable.attachListener(editable, 'drop', function(event) {
                event.data.preventDefault();
            });
        });
    }
});

// Dynamic Documentation CKEditor plugin
// The problem:  CKEditor will use the default labels ("Font" or "Font Size") when it cannot
//               determine the font of the current selection.  This happens when we've set the
//               inline style to some parent div (the first child of ddcontributionhtml).
//
// The fix:
//   We will detect selectionChange.  On selectionChange, if the font combos don't have a value
//   set, we will get the 'computed style' of the current selection and set the combos ourselves.

CKEDITOR.plugins.add('cernselectionfix', {
    init: function (editor) {
        // We need to make sure that we don't set the value of a richcombo to an option that is not
        // listed.  Unfortunately, a richcombos options are (1) [accessible] private, and (2) lazy
        // initialized.  So, we'll parse the configuration options.
        // Example return value:
        //     {
        //       '8px':    8,
        //       '9px':    9,
        //       '10px':  10,
        //       '12px':  12,
        //       '14px':  14,
        //     }
        //   So, if we get CSS style of '12px', we know to call setValue using 12.
        //
        // Calculate a mapping of computed font styles to their combo values, as per the config.
        // http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-font_names
        // http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-fontSize_sizes
        var parseStyles = function(configString) {
            var mappings = {};

            var options = configString.split(';');

            for (var i = 0; i < options.length; i++) {
                var parts = options[i].split('/');
                var name = CKEDITOR.tools.trim(parts[0]);
                if (name) {
                    // The `replace` call normalizes comma-separated lists by removing whitespace
                    // between items
                    var styles = (parts.length >= 2 ? parts[1] : parts[0]).replace(/,\s*/, ',').split(',');

                    for (var j = 0; j < styles.length; j++) {
                        mappings[CKEDITOR.tools.trim(styles[j].toLowerCase())] = name;
                    }
                }
            }

            return mappings;
        }

        var fontMappings = parseStyles(editor.config.font_names);
        var sizeMappings = parseStyles(editor.config.fontSize_sizes);

        var getComputedFontFamily = function(element) {
            for (var current = element; current && current.$ && current.$ !== editor.editable().$; current = current.getParent()) {
                var sFontFamily = current.getComputedStyle('fontFamily');
                // The computed value may include several fonts (including the fallback fonts).
                // Let's grab the first one.
                var sFirstFont = sFontFamily ? /^([^,]+),?/.exec(sFontFamily)[1] : '';
                if (!sFirstFont)
                    continue;
                sFirstFont = sFirstFont.toLowerCase();

                // If the font is 'inherit', keep going up the DOM tree
                if (sFirstFont === 'inherit')
                    continue;
                else
                    break;
            }

            return sFirstFont;
        }

        editor.on('selectionChange', function(event) {
            if (editor.mode != 'wysiwyg')
                return;

            var start = editor.getSelection().getStartElement();

            (function() {
                // Set the Font combo
                var fontcombo = editor.ui.get('Font');
                // If the combo value is blank, the font plugin was unable to determine the font of
                // the selection.  We will use the computed style to set the combo box value.
                if (fontcombo && !fontcombo.getValue()) {
                    var sFontFamily = getComputedFontFamily(start);
                    if (!sFontFamily)
                        return;

                    // Make sure that the calculated value is an option in the combo by checking our
                    // pre-calculated mapping, otherwise we will get JavaScript errors when the user
                    // tries to open the combo menu.
                    var sMappedFont = fontMappings[sFontFamily];
                    if (sMappedFont)
                        fontcombo.setValue(sMappedFont);
                }
            })();

            (function() {
                // Set the Font Size combo
                var fontsizecombo = editor.ui.get('FontSize');
                // If the combo value is blank, the font plugin was unable to determine the font of
                // the selection.  We will use the computed style to set the combo box value.
                if (fontsizecombo && !fontsizecombo.getValue()) {
                    var sFontSize = start.getComputedStyle('fontSize');

                    // Make sure that the calculated value is an option in the combo by checking our
                    // pre-calculated mapping, otherwise we will get JavaScript errors when the user
                    // tries to open the combo menu.
                    var sMappedSize = sizeMappings[sFontSize.toLowerCase()];
                    if (sMappedSize)
                        fontsizecombo.setValue(sMappedSize);
                }
            })();
        }, null, null, 100 /* low priority, run *after* the 'font' plugin! */);
    }  //init
});

// Handle unformatting collapsed selections

(function() {
    // Things that shouldn't ever be split
    var UNSPLITTABLEs = [
        g_sCLASS_EMR_CONTENT, g_sCLASS_EMR_CONTENT_ITEM,
        g_sCLASS_SECTION_DISP,
        'blocktext', g_sCLASS_BLOCK_CN_TEMPLATE, g_sCLASS_BLOCK_SMART_TEMPLATE, g_sCLASS_BLOCK_TOKEN,
        g_sCLASS_DQR_CONTENT, 'ddtagged', 'taggedtextnumber'
    ];
    var selector;
    function getUnsplittablesSelector() {
        if (!selector)
            selector = DDCOMMON.createSelector(UNSPLITTABLEs);
        return selector;
    }
    var HOOK_COMMANDS = [
        'bold', 'italic', 'underline', 'strike'  // These are all instances of CKEDITOR.styleCommand
    ];

    // Watch a styleCommand, and intercept cases where unformatting a collapsed selection
    function watchCommand(editor, command) {
        command.on('exec', function() {
            // Handle un-formatting
            if (this.state !== CKEDITOR.TRISTATE_ON)
                return;

            var sel = editor.getSelection();
            var range = sel.getRanges()[0];
            if (!range || !range.collapsed)  // ... un-formatting collapsed selections
                return;

            var style = command.style;
            var handled = setSelectionUnformatted(editor, style);
            if (handled) {
                // If handled, cancel the framework event
                editor.fire('selectionChange', { selection: sel, path: editor.elementPath() });  // Make sure buttons get updated
                return false;
            }
        });
    }

    // Make thu current selection unformatted (wrt `style`), but leave current formatting in place.
    // Return true if this function handles the formatting, else the style framework should handle it
    function setSelectionUnformatted(editor, style) {
        var sel = editor.getSelection();
        var path = editor.elementPath();
        // Find the elements for this style
        for (var i = 0; path && i < path.elements.length; i++) {
            var styleElement = path.elements[i];
            var $styleElement = $(styleElement.$);
            if ($styleElement.css('display') !== 'inline')  // CKE only supports these styles as inline styles
                break;

            if (!style.checkElementRemovable(styleElement))
                continue;

            // Find unsplittable elements within the style element; we have to move the formats around if we find them

            var $unsplittables = $styleElement.find(getUnsplittablesSelector());
            if ($unsplittables.length) {
                var bms = sel.createBookmarks();

                // The formatting element is currently an ancestor of the unsplittable.  Move the
                // formatting into and around the unsplittable:
                for (var j = 0; j < $unsplittables.length; j++) {
                    var unsplittable = CKEDITOR.dom.element.get($unsplittables[j]);

                    // Unformat the format element, then format the left portion and right portion

                    // Add a class so the CKE doesn't remove the element
                    styleElement.addClass('cke-unformat-tmp');
                    removeStyleFromElement(editor, styleElement, style);

                    // Re-format stuff preceding the unsplittable
                    var leftRange = editor.createRange();
                    leftRange.setStartAt(styleElement, CKEDITOR.POSITION_AFTER_START);
                    leftRange.setEndBefore(unsplittable);
                    style.applyToRange(leftRange);
                    // Re-format stuff following the unsplittable
                    var rightRange = editor.createRange();
                    rightRange.setStartAfter(unsplittable);
                    rightRange.setEndAt(styleElement, CKEDITOR.POSITION_BEFORE_END);
                    style.applyToRange(rightRange);

                    // Style inside the unsplittable, but split at the selection
                    styleAroundBookmark(editor, unsplittable, style, bms[0]);

                    styleElement.removeClass('cke-unformat-tmp');
                }

                sel.selectBookmarks(bms);
                return true;
            }
            else {
                var range = sel.getRanges()[0];
                if (!range)
                    return false;

                var bms = sel.createBookmarks();

                styleElement.addClass('cke-unformat-tmp');
                removeStyleFromElement(editor, styleElement, style);
                styleAroundBookmark(editor, styleElement, style, bms[0]);
                styleElement.removeClass('cke-unformat-tmp');

                sel.selectBookmarks(bms);
                return true;
            }
        }

        return false;
    }

    function removeStyleFromElement(editor, styleElement, style) {
        var styleRange = editor.createRange();
        styleRange.setStartAt(styleElement, CKEDITOR.POSITION_BEFORE_START);
        styleRange.setEndAt(styleElement, CKEDITOR.POSITION_AFTER_END);
        style.removeFromRange(styleRange, editor);
    }

    // Style the element, around the bookmark element, but not including the bookmark element
    function styleAroundBookmark(editor, element, style, bookmark) {
        var stickyNode = new CKEDITOR.dom.element('span');  // Prevent CKE from merging nodes across the bookmark
        stickyNode.setHtml('&nbsp;');
        stickyNode.insertAfter(bookmark.startNode);

        // Re-format the stuff inside the element preceding the bookmark
        var leftRange = editor.createRange();
        leftRange.setStartAt(element, CKEDITOR.POSITION_AFTER_START);
        leftRange.setEndAt(bookmark.startNode, CKEDITOR.POSITION_BEFORE_START);
        if (!leftRange.collapsed)
            style.applyToRange(leftRange);

        // Re-format the stuff inside the element following the bookmark
        var rightRange = editor.createRange();
        rightRange.setStartAt(stickyNode, CKEDITOR.POSITION_AFTER_END);
        rightRange.setEndAt(element, CKEDITOR.POSITION_BEFORE_END);
        // Set range paste <br> (cursor is at the end of a line)
        var rangeStart = rightRange.getBoundaryNodes().startNode;
        if (rangeStart && rangeStart.is && rangeStart.is('br'))
            rightRange.setStartAfter(rangeStart);
        if (!rightRange.collapsed)
            style.applyToRange(rightRange);

        stickyNode.remove();  // Goodbye
    }

    CKEDITOR.plugins.add('cernunformat', {
        init:  function(editor) {
            editor.on('instanceReady', function() {
                for (var i = 0; i < HOOK_COMMANDS.length; i++) {
                    var command = editor.getCommand(HOOK_COMMANDS[i]);
                    if (command)
                        watchCommand(editor, command);
                }
            });
        }
    });

})();

// Overrides the backspace and delete keys in certain situations.
//
// IE8- will sometimes create corrupt text nodes when deleting via key in contenteditables.  This
// plugin will override the keydown event in these cases to manually handle deleting characters.

CKEDITOR.plugins.add('cernbackspace', {
    init:  function(editor) {
        var isNodeEmpty = function (node) {
            switch (node.nodeType) {
                case 1: // Element
                    if($(node).is('br'))
                        return false;

                    for(var i = 0; i < node.childNodes.length; i++){
                        if (DDCOMMON.isBookmarkElement(node.childNodes[i]))
                            continue;
                        else if(!isNodeEmpty(node.childNodes[i]))
                            return false;
                    }

                    return true;

                case 3: // Text Node
                    return node.nodeValue.length === 0;

                default:
                    return false;
            }
        }

        var shouldRemove = function(node) {
            if ($(node).hasClass('ddfreetext') || $(node).is('br'))
                return false;
            if (node.nodeType === 1 && $(node).css('display') !== 'inline')
                return false;
            if (node === node.ownerDocument.body)
                return false;
            if (!DDCOMMON.isNodeEditable(node))
                return false;
            return isNodeEmpty(node);
        }

        var removeEmpties = function(i, node) {
            // Spans with ddremovablepadding class were added in SAX parser.
            $(node).find(".ddremovablepadding").each(removeEmpties);
            if (shouldRemove(node)){
                var $bkmark = $(node).find("[data-cke-bookmark]").detach();
                $(node).after($bkmark);
                node.parentNode.removeChild(node);
            }
        }

        if (typeof DocUtilsHelper !== 'undefined')
            DocUtilsHelper.DebugString('[DD] cernbackspace plugin is enabled');

        editor.on('contentDom', function() {
            // Support both editor in iframe and not-iframe (CKE4+divarea plugin) as well as multiple editors:
            var editable = editor.editable ? editor.editable() : editor.document;

            editable.on('keydown', function(event) {
                var KEYCODES = {
                    BACKSPACE:  8,
                    DELETE:     46
                };

                var keyCode = event.data.getKey();
                if ((keyCode === KEYCODES.BACKSPACE || keyCode === KEYCODES.DELETE) && event.data.getKeystroke() < 0x10000) {
                    var selection = editor.getSelection();
                    var range = selection && selection.getRanges()[0];
                    if (!range)
                        return;

                    var ierange = editor.document.$.selection.createRange();
                    if (!ierange.moveStart)  // Only handle TextRange
                        return;

                    // Don't delete non-editable areas
                    var rangeParent = ierange.parentElement();
                    if (rangeParent.isContentEditable == false)
                        return;

                    if (range.collapsed) {
                        // Find the character to delete
                        if (keyCode === KEYCODES.DELETE)
                            ierange.moveEnd('character', 1);
                        else if (keyCode === KEYCODES.BACKSPACE)
                            ierange.moveStart('character', -1);
                        if (ierange.text.length === 1
                        || (ierange.text.length === 0 && /^<br[^>]*\/?[^>]*>$/i.test(ierange.htmlText))) {
                            // continue
                        }
                        else
                            return;

                        // Only override delete/backspace if the character-to-delete is space, or is
                        // neighboring a space
                        var extendedRange = ierange.duplicate();
                        extendedRange.moveStart('character', -1);
                        extendedRange.moveEnd('character', 1);
                        if (extendedRange.text.indexOf(' ') < 0 && extendedRange.text.indexOf('\u00A0'/* non-breaking space */) < 0)
                            return;

                        // Select character to delete; selection.getRanges() will pick up this selection
                        ierange.select();
                        selection.reset();

                        try {
                            // Re-obtain CKE range since it has been modified
                            range = selection.getRanges()[0];
                            if (range) {
                                console.log('Handling ' + (keyCode === KEYCODES.DELETE ? 'delete' : 'backspace'));
                                // Delete the character
                                range.deleteContents(true);

                                function removeEmptyAncestors(range) {
                                    var ancestorNode = range.getCommonAncestor().$;
                                    while (shouldRemove(ancestorNode)) {
                                        var parent = ancestorNode.parentNode;
                                        parent.removeChild(ancestorNode);
                                        ancestorNode = parent;
                                    }
                                }

                                removeEmptyAncestors(range);

                                ierange = editor.document.$.selection.createRange();  // re-obtain range (used in `finally`)
                                event.data.preventDefault(false);
                            }
                            else {
                                DocHandleError('cernbackspace - Unable to obtain range after selecting character', 'DynDocCKeditor', '', '');
                            }
                        }
                        finally {
                            // Restore the I-beam:
                            if (ierange.moveStart) {
                                ierange.collapse(/* collapse to start = */true);
                                ierange.select();
                                selection.reset();
                            }
                        }
                    }
                    else {  // Selection is not collapsed
                        // Delete the current selection
                        console.log('Handling ' + (keyCode === KEYCODES.DELETE ? 'delete' : 'backspace'));
                        range.deleteContents(true);
                        var bms = selection.createBookmarks();
                        var anc = range.getCommonAncestor();
                        var $freetext = $(anc.$).closest('[contentEditable=true]');
                        if ($freetext.length > 0)
                            removeEmpties(0, $freetext[0]);

                        selection.selectBookmarks(bms);

                        // Restore I-beam
                        ierange = editor.document.$.selection.createRange();
                        if (ierange.moveStart) {
                            ierange.select();
                            selection.reset();
                        }

                        event.data.preventDefault(false);
                    }
                }
            }, this, null, /* high priority:  */0);
        });  // contentDom
    }  // init
});

/******************************************************************************
/ Description: Justify (left, right, center, block) plugin                    /
/              Overwrite for CKEditor justify plugin                          /
-------------------------------------------------------------------------------
Mod Date	   Engineer              Comment
--- --------   --------------------  ------------------------------------------
000 06/2011    Adilson M. Ribeiro    Initial Release
******************************************************************************/

DDJUSTIFYHANDLERS = function () {

    function getAlignment(element, useComputedState) {

        useComputedState = useComputedState === undefined || useComputedState;

        var align;
        if (useComputedState)
            align = element.getComputedStyle('text-align');
        else {
            while (!element.hasAttribute || !(element.hasAttribute('align') || element.getStyle('text-align'))) {
                var parent = element.getParent();
                if (!parent)
                    break;

                element = parent;
            }
            align = element.getStyle('text-align') || element.getAttribute('align') || '';
        }

        // Sometimes computed values doesn't tell.
        align && (align = align.replace(/(?:-(?:moz|webkit)-)?(?:start|auto)/i, ''));
        !align && useComputedState && (align = element.getComputedStyle('direction') == 'rtl' ? 'right' : 'left');

        return align;
    }

    function justifyCommand(editor, name, value) {

        this.editor = editor;
        this.name = name;
        this.value = value;
        this.context = 'p';

        var classes = editor.config.justifyClasses;
        if (classes) {
            switch (value) {
                case 'left':
                    this.cssClassName = classes[0];
                    break;
                case 'center':
                    this.cssClassName = classes[1];
                    break;
                case 'right':
                    this.cssClassName = classes[2];
                    break;
                case 'justify':
                    this.cssClassName = classes[3];
                    break;
            }

            this.cssClassRegex = new RegExp('(?:^|\\s+)(?:' + classes.join('|') + ')(?=$|\\s)');
        }
    } // End justifyCommand


    function onDirChanged(e) {
        var editor = e.editor;
        var range = editor.createRange();
        range.setStartBefore(e.data.node);
        range.setEndAfter(e.data.node);

        var walker = new CKEDITOR.dom.walker(range);
        var node;

        while ((node = walker.next())) {
            if (node.type == CKEDITOR.NODE_ELEMENT) {
                // A child with the defined dir is to be ignored.
                if (!node.equals(e.data.node) && node.getDirection()) {
                    range.setStartAfter(node);
                    walker = new CKEDITOR.dom.walker(range);
                    continue;
                }

                // Switch the alignment.
                var classes = editor.config.justifyClasses;
                if (classes) {
                    // The left align class.
                    if (node.hasClass(classes[0])) {
                        node.removeClass(classes[0]);
                        node.addClass(classes[2]);
                    }
                    // The right align class.
                    else if (node.hasClass(classes[2])) {
                        node.removeClass(classes[2]);
                        node.addClass(classes[0]);
                    }
                }

                // Always switch CSS margins.
                var style = 'text-align';
                var align = node.getStyle(style);

                if (align == 'left')
                    node.setStyle(style, 'right');
                else if (align == 'right')
                    node.setStyle(style, 'left');
            }
        }
    } // End onDirChanged


    /**
    * Function to wrap all the ddfreetext elements added as result of justify operation under a single parent 'div'.
    *
    * @param bookmarkitem   Element containig the bookmark.
    * @param editor         CKEditor instance
    */
    function wrapfreetextelements(bookmarkitem, editor) {
        if (!bookmarkitem)
            return;
        var oParentElement = bookmarkitem.getParent();
        if (!oParentElement)
            return;

        // The extra 'div' added will be having the attribute 'textwrappable' set to 'true'.
        // Hence get all the child elements having attribute 'textwrappable' equals 'true'
        // Include the bookmark item as well, which will be having the justifeid text.
        var aElementsWithClassName = [];
        var children = oParentElement.$.childNodes;
        for (var i = 0; i < children.length; i++) {
            if ((DDCOMMON.hasClassName(children[i].className, g_sCLASS_FREETEXT)) &&
                (DDCOMMON.hasClassName(children[i].className, g_sCLASS_TEXT_WRAPPABLE) || bookmarkitem.$ === children[i])) {
                aElementsWithClassName.push(children[i]);
            }
        }

        // Return from the function, if no child element was found with class name 'ddfreetext'.
        if ($(aElementsWithClassName).length <= 0)
            return;

        // Check whether any of the child elements contain the class name 'ddremovable'.
        var bIsddRemovable = $(aElementsWithClassName).hasClass(g_sCLASS_REMOVABLE);
        // Remove the unwanted class names.
        $(aElementsWithClassName).removeClass(g_sCLASS_FREETEXT);
        $(aElementsWithClassName).removeClass(g_sCLASS_REMOVABLE);
        $(aElementsWithClassName).removeClass(g_sCLASS_REFRESHABLE);
        $(aElementsWithClassName).removeClass(g_sCLASS_TEXT_WRAPPABLE);

        // If parent node already contains a 'ddfreetext', avoid adding it again.
        if (!DDCOMMON.hasClassName(oParentElement.$.className, g_sCLASS_FREETEXT)) {

            if (typeof CKEDITOR.DocUtilsHelper === 'undefined' || typeof CKEDITOR.DocUtilsHelper.GenerateGUID === 'undefined')
                return;

            // Generate the id for new div.
            var sGUID = CKEDITOR.DocUtilsHelper.GenerateGUID();
            // Create a new element 'div' and append the child items containing 'ddfreetext' to the same.
            var sDiv = ["<div class='", g_sCLASS_FREETEXT, "' dd:btnfloatingstyle='top-right' contentEditable='true' id='", sGUID, "' ", ">"];
            var newDiv = $('<div>', editor.document.$).addClass(g_sCLASS_FREETEXT).attr('dd:btnfloatingstyle', 'top-right').attr('contentEditable', true).attr('id', sGUID);
            // If child nodes contain a 'ddremovable' class name, insert the same to the parent as well.
            if (bIsddRemovable) {
                $(newDiv).addClass(g_sCLASS_REMOVABLE);
            }

            // Append the newly created 'div' to the existing parent element as the previous element of the bookmark item.
            oParentElement.$.insertBefore(newDiv[0], bookmarkitem.$);

            // Iterate through the child elements and add them to the newly created 'div'.
            for (var i = 0, count = $(aElementsWithClassName).length; i < count; i++) {
                var childItem = aElementsWithClassName[i];
                if (childItem) {
                    // Remove the unnecessary attributes.
                    childItem.removeAttribute(g_sATTRIBUTE_BTN_FLOAT_STYLE);
                    childItem.removeAttribute("contentEditable", 1);
                    childItem.removeAttribute('contenteditable', 1);

                    // Append the child item to the newely created div.
                    $(newDiv).append($(childItem).clone());
                    $(childItem).remove();
                }
            }
        }
    }

    justifyCommand.prototype = {

        exec: function (editor) {
            var selection = editor.getSelection();
            var enterMode = editor.config.enterMode;

            if (!selection)
                return;

            // Make serializable argument to true so that the bookmark can be used to restore the selection even when the nodes suffer mutation.
            var bookmarks = selection.createBookmarks(true);
            var ranges = selection.getRanges(true);

            var cssClassName = this.cssClassName;
            var iterator, block;
            var bookmarkitem;

            var useComputedState = editor.config.useComputedState;
            useComputedState = useComputedState === undefined || useComputedState;

            for (var i = ranges.length - 1; i >= 0; i--) {
                iterator = ranges[i].createIterator();
                iterator.enlargeBr = enterMode != CKEDITOR.ENTER_BR;

                while ((block = iterator.getNextParagraph(enterMode == CKEDITOR.ENTER_P ? 'p' : 'div'))) {

                    // If the returned block is a cloned node, then remove all the attributes for the newely created div.
                    if ((block.$.nextSibling && $(block.$.nextSibling).hasClass(g_sCLASS_TEXT_WRAPPABLE)) ||
                        (block.$.previousSibling && $(block.$.previousSibling).hasClass(g_sCLASS_TEXT_WRAPPABLE))) {
                        var attrArray = [];
                        for (var attr in block.$.attributes) {
                            if (attr.indexOf('class') === -1) {
                                attrArray.push(attr);
                            }
                        }
                        block.removeAttributes(attrArray);
                    }

                    // Remove any of the alignment classes from the className.
                    var className = cssClassName && (block.$.className = CKEDITOR.tools.ltrim(block.$.className.replace(this.cssClassRegex, '')));

                    var apply = (this.state == CKEDITOR.TRISTATE_OFF) && (!useComputedState || (getAlignment(block, true) != this.value));

                    if (cssClassName) {
                        // Append the desired class name.
                        if (apply)
                            block.addClass(cssClassName);
                        else if (!className)
                            block.removeAttribute('class');
                    }
                    else if (apply) {
                        block.setStyle('text-align', this.value);
                    }
                    bookmarkitem = block;
                }
            }

            // Create a new div and wrap all the freetext area under it.
            wrapfreetextelements(bookmarkitem, editor);

            editor.focus();
            editor.forceNextSelectionCheck();
            selection.selectBookmarks(bookmarks);
        },

        refresh: function (editor, path) {
            
            var firstBlock = path.block || path.blockLimit;
            this.setState(firstBlock.getName() != 'body' && getAlignment(firstBlock, this.editor.config.useComputedState) == this.value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);
        }
    };

    return {

        m_oEditor: null,

        createJustifyCommand: function (oEditor, sCmd, sAlignType) { return new justifyCommand(oEditor, sCmd, sAlignType); },

        destroyHandler: function () {
            DDJUSTIFYHANDLERS.m_oEditor.removeListener('dirChanged', onDirChanged);
            DDJUSTIFYHANDLERS.m_oEditor.removeListener('destroy', DDJUSTIFYHANDLERS.destroyHandler);
            DDJUSTIFYHANDLERS.m_oEditor = null;
        } // End destroyHandler
    } // End public functions

} ();      // End DDJUSTIFYHANDLERS

CKEDITOR.plugins.add('cerndyndocjustify', {

    lang: 'en,en-gb,en-au,de,fr,es,pt-br',
    icons: 'justifyblock,justifycenter,justifyleft,justifyright', // %REMOVE_LINE_CORE%

    // adding additional dependency to 'cerndyndocbasicstyles' plugin
    // so that way we only listen for the 'selectionchange' event once
    requires: 'cerndyndocbasicstyles,cerndyndoccommon',

    init: function (editor) {
        if (editor.blockless)
            return;

        DDJUSTIFYHANDLERS.m_oEditor = editor;

        // Register a filter that will remove the temporary XHTML injected into the document like ddtextwrappable.
        editor.on('instanceReady', function() {
            if (editor.registerXhtmlFilter)
                editor.registerXhtmlFilter(function() {
                    $(editor.editable().$).find( '.' + g_sCLASS_TEXT_WRAPPABLE).removeClass(g_sCLASS_TEXT_WRAPPABLE);
                });
        });

        var left    = new DDJUSTIFYHANDLERS.createJustifyCommand(editor, DDCMD_JUSTIFYLEFT, 'left');
        var center  = new DDJUSTIFYHANDLERS.createJustifyCommand(editor, DDCMD_JUSTIFYCENTER, 'center');
        var right   = new DDJUSTIFYHANDLERS.createJustifyCommand(editor, DDCMD_JUSTIFYRIGHT, 'right');
        var justify = new DDJUSTIFYHANDLERS.createJustifyCommand(editor, DDCMD_JUSTIFYBLOCK, 'justify');

        editor.addCommand(DDCMD_JUSTIFYLEFT, left);
        editor.addCommand(DDCMD_JUSTIFYCENTER, center);
        editor.addCommand(DDCMD_JUSTIFYRIGHT, right);
        editor.addCommand(DDCMD_JUSTIFYBLOCK, justify);

        if (editor.ui.addButton) {
            editor.ui.addButton('JustifyLeft', {
                label: editor.lang.cerndyndocjustify.left,
                command: DDCMD_JUSTIFYLEFT,
                toolbar: 'align,10'
            });
            editor.ui.addButton('JustifyCenter', {
                label: editor.lang.cerndyndocjustify.center,
                command: DDCMD_JUSTIFYCENTER,
                toolbar: 'align,20'
            });
            editor.ui.addButton('JustifyRight', {
                label: editor.lang.cerndyndocjustify.right,
                command: DDCMD_JUSTIFYRIGHT,
                toolbar: 'align,30'
            });
            editor.ui.addButton('JustifyBlock', {
                label: editor.lang.cerndyndocjustify.block,
                command: DDCMD_JUSTIFYBLOCK,
                toolbar: 'align,40'
            });
        }
        editor.on('dirChanged', DDJUSTIFYHANDLERS.onDirChanged);
    }
});


/**
* List of classes to use for aligning the contents. If it's `null`, no classes will be used
* and instead the corresponding CSS values will be used.
*
* The array should contain 4 members, in the following order: left, center, right, justify.
*
*		// Use the classes 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify'
*		config.justifyClasses = [ 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify' ];
*
* @cfg {Array} [justifyClasses=null]
* @member CKEDITOR.config
*/

/******************************************************************************
 / Description:   Display hyperlink when user hovers over structure content    /
 --------------   --------------------------------------------------------------
 Mod Date         Engineer              Comment
 --- --------     --------------------  ----------------------------------------
 000 07/2014      Adilson M. Ribeiro    Initial Release
 000 10/2014      Adilson M. Ribeiro    Updated to handle multiple editors from MPage
 *******************************************************************************/

// Begin MouseOverStructure Namespace
MouseOverStructure = function () {

    /////////////////////////////////////////
    //************    PRIVATE    ************
    /////////////////////////////////////////

    var m_sJSONClickedElement = "";

    /**
     * Recursively wrap text nodes with span.highlightable
     *
     * @param {HTMLElement} oElement  the 'ddstructuretext' element being moused over
     */
    function doWrap(oElement) {

        var $element = $(oElement);
        var $template = $('<span>').addClass('highlightable');  // A template element to clone

        $element.contents().each(function (i, node) {
            if (node.nodeType === Node.TEXT_NODE) {
                if ($.trim(node.nodeValue)) {
                    var $highlightable = $template.clone();
                    $highlightable.insertAfter(node);
                    $highlightable.append(node);
                }
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                doWrap(node);  // recurse
            }
        });
    }

    /////////////////////////////////////////
    //************    PUBLIC     ************
    /////////////////////////////////////////

    return {

        //Flag that indicates whether the plugin is enabled/disabled
        //This is always enabled in MPages due to the plugin being guaranteed to be available on load.
        m_bEnablePlugin: CKEDITOR.MPAGES ? true : false,

        /**
         * Returns the JSON string for the element being clicked.
         */
        getClickedElement: function () {
            return m_sJSONClickedElement;
        },

        /**
         * Wrap element text node with span.highlightable classname.
         *
         * @param {CKEDITOR.editor}     editor      The current/active editor
         * @param {HTMLElement|jQuery}  oElement    The 'ddstructuretext' element being moused over
         */
        makeHighlightable: function (editor, oElement) {
            if (null == editor || null == oElement || !this.m_bEnablePlugin)
                return;

            doWrap(oElement);
            editor.fire('updateSnapshot');
        },

        /**
         * Wrap element text node with span.highlightable classname.
         * Finds all attributes matching dd:ocid and dd:label and adds 'highlighted' classname
         *
         * @param {HTMLElement|jQuery} element  The 'ddstructuretext' element being moused over
         */
        addHighlight: function (element) {
            if (this.m_bEnablePlugin) {
                $(element).closest('[dd\\:ocid], [dd\\:label]').addClass('highlighted');
            }
        },

        /**
         * Finds all attributes matching dd:ocid and dd:label and removes 'highlighted' classname
         *
         * @param {HTMLElement|jQuery} element  The 'ddstructuretext' element being moused over
         */
        removeHighlight: function(element) {
            $(element).closest('[dd\\:ocid], [dd\\:label]').removeClass('highlighted');
        },

        /**
         * Given an element, search through the parents of the element in the DOM tree
         * and construct a new JSON string from the matching elements
         *
         * @param {CKEDITOR.editor} editor
         * @param {HTMLElement} oElement  the element being clicked
         */
        handleMouseClick: function (editor, oElement) {
            if (null == editor || null == oElement || !this.m_bEnablePlugin)
                return;

            // Check if element has 'highlightable' className. If not, search the element's
            // ancestors in the DOM tree until we find the closest one (if one exists).
            // This happens if user chooses to add any font-style (bold, italics, etc) to
            // the structured generated text
            if (!($(oElement).hasClass('highlightable'))) {
                oElement = $(oElement).closest('.highlightable')[0];

                if (!oElement)
                    return;
            }

            var jsonObj = [];

            // get all dd:ocids attributes
            $(oElement).parents('[dd\\:ocid]').each(function () {
                jsonObj.push( {
                    label: null,
                    ocid: $(this).attr('dd:ocid')
                });
            });

            // get all 'dd:labels' attributes
            $(oElement).parents('[dd\\:label]').each(function () {
                jsonObj.push({
                    label: $(this).attr('dd:label'),
                    ocid: null
                });
            });

            // build the string in reverse order starting with
            // the top-level element (ex: GroupBy->SubGroupBy->Item->Attribute)
            m_sJSONClickedElement = JSON.stringify(jsonObj.reverse());
            editor.fire('structureElementClicked', m_sJSONClickedElement);
        },

        /**
         * Updates the flag that determines whether this plugin is enabled or not
         *
         * @param {boolean} bFlag flag indicating whether to enable/disable the plugin
         */
        enablePlugin: function (bFlag) {
            this.m_bEnablePlugin = bFlag;
        }
    }
}(); // MouseOverStructure

CKEDITOR.plugins.add('cernstructure', {
    init: function (editor) {

        editor.on('updateStructuredContent', function(){
            MouseOverStructure.makeHighlightable(editor, $(editor.editable().$).find('.ddstructuredtext'));
        });

        editor.on('contentDom', function (event) {
            $(editor.editable().$).on('mouseenter', '.highlightable', function(event){
                MouseOverStructure.addHighlight(this);
                editor.fire('updateSnapshot');
            });
            $(editor.editable().$).on('mouseleave', '.highlightable', function(event){
                MouseOverStructure.removeHighlight(this);
                editor.fire('updateSnapshot');
            });
            editor.editable().on('click', function(event){
                if (!event || !event.data || !event.data.$)
                    return;

                MouseOverStructure.handleMouseClick(editor, event.data.$.srcElement);
            });
        }, this);

        editor.on('afterCommandExec',  function (event) {
            if (!event || !event.data)
                return;

            if (DDCMD_UNDO == event.data.name || DDCMD_REDO == event.data.name || DDCMD_LAYOUTDOCUMENT == event.data.name) {
                MouseOverStructure.makeHighlightable(editor, $(editor.editable().$).find('.ddstructuredtext'));
            }
        }, this);

        editor.on(DDCMD_CONTENTHTMLLOADED, function (event) {
            var items = event.data && event.data.items;
            $(items).find('.ddstructuredtext').each(function () { MouseOverStructure.makeHighlightable(editor, this) });
        }, this);

        var dirtyFilter = function(frag) {
            $(frag).find('span.highlightable').each(function() {
                var $highlightEl = $(this);
                $highlightEl.replaceWith($highlightEl.contents());
            });
            $(frag).find('.highlighted').removeClass('highlighted');
        };
        if (editor.registerDirtyFilter) {
            editor.registerDirtyFilter(function(frag) {
                dirtyFilter(frag.firstChild);
            });
        }
        if (editor.registerXhtmlFilter) {
            editor.registerXhtmlFilter(function(detached) {
                dirtyFilter(detached);
            });
        }
    }
});   //cernstructure

/////////////////////////////////////////////////////////////////////////////
g_sID_REMOVE_SECTION = 'ddRemoveSectionImage';
g_sID_INSERT_SECTION = 'ddInsertSectionImage';
g_sID_REMOVE_SUBSECTION = 'ddRemoveSubSectionImage';
g_sID_INSERT_SUBSECTION = 'ddInsertSubSectionImage';
g_sID_INSERT_FT_EMRITEM = 'ddInsertEmrImage';
g_sID_REMOVE_ELEMENT = 'ddRemoveElementImage';  // Any element other than section/subsection
g_sID_STRIKE_ELEMENT = 'ddStrikeElementImage';  // Any element other than section/subsection
g_sID_REFRESH_SECTION = 'ddRefreshSectionImage';
g_sID_REFRESH_SUBSECTION = 'ddRefreshSubSectionImage';
g_sDUMMY_IMG_ID = '9999Xb7-c4db-4217-b96e-9999Xb7';


(function() {

    /////////////////////////////////////////
    //************    PRIVATE    ************
    /////////////////////////////////////////
    /**
     * @constructor
     * @param {CKEDITOR.editor} editor Instance of CKEditor associated to cache
     */
    function FocusCache(editor) {
        this.m_aFocusElementsCache = null;
        this.m_editor = editor;

        /**
         * Get element of section currently in focus
         * @return {HTMLElement} DOM element of section in-focus; null if not found;
         */
        this.getFocusSection = function () {
            if (null == this.m_aFocusElementsCache || this.m_aFocusElementsCache.length < 1)
                return null;
            return this.m_aFocusElementsCache[this.m_aFocusElementsCache.length - 1];
        };

        /**
         * Get element of subsection currently in focus
         * @return {HTMLElement} DOM element of subsection in-focus; null if not found;
         */
        this.getFocusSubsection = function () {
            if (null == this.m_aFocusElementsCache || this.m_aFocusElementsCache.length < 2)
                return null;
            var oElement = this.m_aFocusElementsCache[this.m_aFocusElementsCache.length - 2];
            if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_SUBSECTION))
                return oElement;
            return null;
        };

        /**
         * Removes the class ddinfocus to all pertinent elements
         * that have been stored in the m_aFocusElementsCache array.
         *
         * Loops through the m_aFocusElementsCache array and removes
         * the "ddinfocus" class from their className attributes.
         * Remove "ddactionelement" from the top actionable element
         * Should leave the array completely empty at the end.
         */
        this.clear = function () {
            if (null == this.m_aFocusElementsCache || this.m_aFocusElementsCache.length == 0)
                return;

            // Clear Action Element flag from top actionable element
            $(this.m_aFocusElementsCache[0]).removeClass(g_sCLASS_ACTIONELEMENT);

            // Clear infocus flag from all elements in focus
            while (this.m_aFocusElementsCache.length) {
                var $element = $(this.m_aFocusElementsCache.pop());
                $element.removeClass(g_sCLASS_INFOCUS);
            }
        };

        /**
         * Remove given element and it's children elements from focus cache
         *
         * Loops through the m_aFocusElementsCache array and removes
         * the "ddinfocus" class from the given element, its children
         * elements, and it's non-actionable parent elements. And
         * remove these elements from the cache.
         *
         * @param  {HTMLElement} oElement Element to be removed from focus cache
         */
        this.removeElement = function (oElement) {
            if (null == oElement || null == this.m_aFocusElementsCache || this.m_aFocusElementsCache.length == 0)
                return;

            var iArrayCnt = this.m_aFocusElementsCache.length;
            if (oElement == this.m_aFocusElementsCache[iArrayCnt - 1])
                return this.clear();

            // Clear Action Element flag from top actionable element
            $(this.m_aFocusElementsCache[0]).removeClass(g_sCLASS_ACTIONELEMENT);

            var bFound = false;
            for (var i = 0; i < iArrayCnt; i++) {
                // When found given element in cache, check if the parent element
                // is actionable. If the parent is actionable, the remove all its children
                // elements from cache; otherwise move to next parent node till found an
                // actionable element
                if (bFound && isActionableElement(this.m_aFocusElementsCache[i])) {
                    this.m_aFocusElementsCache.splice(0, i);
                    return;
                }

                $(oElement).removeClass(g_sCLASS_INFOCUS);
                // Remove the element and child from in-focus cache and stop
                if (!bFound && oElement == this.m_aFocusElementsCache[i]) {
                    bFound = true;
                }
            }
        };


        /**
         * Adds the class ddinfocus to all pertinent elements
         * that are under the current mouse pointer
         *
         * adds the ddinfocus class to the proper actionable elements
         * and actionable parent elements (up to ddsection)
         * that are currently under the current mouse position.
         * Mark the top most actionable element.
         *
         * @param {HTMLElement} oElement The selected source element
         */
        this.setElementsInFocus = function (oElement) {
            // Clear cache first
            this.clear();

            if (null == oElement)
                return;

            if (this.m_aFocusElementsCache == null)
                this.m_aFocusElementsCache = [];

            var $e = $(oElement);

            // Mark the top most actionable element if it is not a free text, or section/subsection
            if (!$e.is(DDCOMMON.createSelector([ g_sCLASS_FREETEXT, g_sCLASS_SECTION, g_sCLASS_SUBSECTION ])))
                $e.addClass(g_sCLASS_ACTIONELEMENT);

            var editableBaseElement = this.m_editor.editable().$;
            // Walk up the DOM from the element to the parent section element
            // and mark all element in the path as "In Focus"
            for (; $e.length && $e[0] !== editableBaseElement && !$e.hasClass(g_sCLASS_CONTRIBUTION); $e = $e.parent()) {
                $e.addClass(g_sCLASS_INFOCUS);
                this.m_aFocusElementsCache.push($e[0]);
                if ($e.hasClass(g_sCLASS_SECTION))
                    break;
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Size of the floating button
    ///////////////////////////////////////////////////////////////////////
    DDENUM.ButtonSize = {
        "height": 11,
        "width": 19
    };

    ///////////////////////////////////////////////////////////////////////
    // Action button type
    ///////////////////////////////////////////////////////////////////////
    DDENUM.ActionType = {
        "refresh": 0,
        "remove": 1,
        "insertFreeText": 2,
        "strikethrough": 3
    };

    /*
     * Action Image Object Template
     * @constructor
     */
    function ActionImage(el) {
        this.$ = el;
        this.id = el.id;
        this.css = this.$.style;
        this.setTop = function (iTop) { this.css.posTop = iTop; };
        this.getTop = function () { return this.css.posTop; };
        this.setLeft = function (iLeft) { this.css.posLeft = iLeft; };
        this.getLeft = function () { return this.css.posLeft; };
        this.setHeight = function (iHeight) { this.css.height = iHeight; };
        this.getHeight = function () { return this.$.offsetHeight; };
        this.setWidth = function (iWidth) { this.css.width = iWidth; };
        this.getWidth = function () { return this.$.offsetWidth; };
        this.setVisibility = function (sVisibility) { this.css.visibility = sVisibility; };
        this.getVisibility = function () { return this.css.visibility; };
        this.getAttribute = function (attribute) { return this.$.getAttribute(attribute); };
        this.setAttribute = function (attribute, value) { return this.$.setAttribute(attribute, value); };
        this.getLinkedElement = function () { return this.$.linkedElement; };
        this.setLinkedElement = function (oElement) { this.$.linkedElement = oElement; };
        // Alternate Text to display in case the image is not found.  Also serves as the Tool Tip Text
        this.setAltText = function (sAltText) {
            // title and longDesc in favor of alt:
            // http://msdn.microsoft.com/en-us/library/cc288472.aspx#access
            this.setAttribute(g_sATTRIBUTE_ALT_TEXT, sAltText);
            this.setAttribute('title', sAltText);
            this.setAttribute('longDesc', sAltText);
        };
        this.hide = function () {
            this.setVisibility('hidden');
            this.setLinkedElement(null);
        };

        // When creating an action image, it automatically adds itself to the Action Image Cache
        if (!m_aActionImagesCache)
            m_aActionImagesCache = [];

        m_aActionImagesCache[this.id] = this;
    }

    /**
     * @param iTop
     * @param iLeft
     * @param iHeight
     * @param iWidth
     * @constructor
     */
    function OffsetPosition(iTop, iLeft, iHeight, iWidth) {
        this.Top = iTop;
        this.Left = iLeft;
        this.Height = iHeight;
        this.Width = iWidth;
    }

    /**
     * Check if given element can be applied to any action such as insert free text, refresh, or remove
     * @param  {HTMLElement}  oElement Element to check
     * @return {Boolean}      True if element can be applied to action
     */
    function isActionableElement(oElement) {
        return $(oElement).is('.ddremovable,.ddsection,.ddsubsection');
    }

    /**
     * Calculates the Proper Top and Left Position for the
     * Floating Action Images for section/subsection element
     *
     * Calculates the position of the floating action images
     * based on the editors position, the IFrames Scroll
     * position, element removable setting, button floating
     * style, and section/subsection content.
     * Per requirement, icon should start 10px after the text
     * and should have a 3px padding between
     *
     * @param  {HTMLElement} oElement the HTML DOM Element for the Section or subsection
     * @param  {Boolean} bRefreshable True if element is refreshable
     * @param  {Boolean} bRemovable   True if element is removable
     * @return {OffsetPosition} OffsetPosition with the calculated Top and Left values.
     */
    function calculateSectionImageTopAndLeft(oElement, bRefreshable, bRemovable) {
        if (!oElement)
            return null;

        var oHeadingElement = DDCOMMON.getSectionDisplayElement(oElement);
        if (oHeadingElement == null)
            return null;

        var oElementClientRects = oElement.getClientRects();
        var oHeadingClientRects = oHeadingElement.getClientRects();
        var eFloatingStyle = DDCOMMON.getButtonFloatingStyle(oElement);
        if (eFloatingStyle == DDENUM.BtnFloatingStyle.topRight || // Place action images to the top right corner of section/subsection
            oHeadingClientRects.length > 1) { // or section title wraps to multiple line
            var oImagePos = getImagePosAtTopRight(oElement);
            if (bRemovable)
                oImagePos.Left -= (DDENUM.ButtonSize.width + 3);
            if (bRefreshable)
                oImagePos.Left -= (DDENUM.ButtonSize.width + 3);
            return oImagePos;
        }
        else { // By default, section/subsection action images should start 10px after the section display text
            var iLeftPosition = oHeadingClientRects[0].right + 10;
            var iWidth = DDENUM.ButtonSize.width;
            if (bRemovable)
                iWidth += (DDENUM.ButtonSize.width + 3);
            if (bRefreshable)
                iWidth += (DDENUM.ButtonSize.width + 3);
            if (iLeftPosition + iWidth > oElementClientRects[0].right) {
                // If images fall outside the section element rectangle, move images
                // within the element, 1px to the rigth edge
                iLeftPosition = oElementClientRects[0].right - iWidth - 1;
            }

            return new OffsetPosition(oHeadingClientRects[0].top + 1, iLeftPosition, oElement.offsetHeight, oElement.offsetWidth);
        }
    }

    /**
     * Adjusts the image positions for the action images
     * associated to one particular section or sub section
     *
     * Re-calculates the position of the floating action images
     * of given section/subsection element, then adjust image
     * position, hide/display image according to the new position
     * of image(s). Will be called after inserting free text or
     * removing element.
     *
     * @param  {HTMLElement} oElement The DOM element of section or sub section.
     */
    function adjustSectionImagePositions(oElement) {
        if (null == oElement)
            return;

        var oInsertImage = null;
        var oRemoveImage = null;
        var oRefreshImage = null;

        if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_SECTION)) { // is section
            oRefreshImage = m_aActionImagesCache[g_sID_REFRESH_SECTION];
            oInsertImage = m_aActionImagesCache[g_sID_INSERT_SECTION];
            oRemoveImage = m_aActionImagesCache[g_sID_REMOVE_SECTION];
        }
        else if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_SUBSECTION)) { // subsection
            oRefreshImage = m_aActionImagesCache[g_sID_REFRESH_SUBSECTION];
            oInsertImage = m_aActionImagesCache[g_sID_INSERT_SUBSECTION];
            oRemoveImage = m_aActionImagesCache[g_sID_REMOVE_SUBSECTION];
        }
        else
            return;

        if (null != oRefreshImage && null == oRefreshImage.getLinkedElement()) oRefreshImage = null;
        if (null != oInsertImage && null == oInsertImage.getLinkedElement()) oInsertImage = null;
        if (null != oRemoveImage && null == oRemoveImage.getLinkedElement()) oRemoveImage = null;

        var imagePos = calculateSectionImageTopAndLeft(oElement, null != oRefreshImage, null != oRemoveImage);
        if (null == imagePos)
            return;

        var iLeft = imagePos.Left;
        if (null != oRefreshImage) {
            oRefreshImage.setVisibility('visible');
            oRefreshImage.setTop(imagePos.Top);
            oRefreshImage.setLeft(iLeft);
            iLeft += DDENUM.ButtonSize.width + 3;
        }
        if (null != oInsertImage) {
            oInsertImage.setVisibility('visible');
            oInsertImage.setTop(imagePos.Top);
            oInsertImage.setLeft(iLeft);
            iLeft += DDENUM.ButtonSize.width + 3;
        }
        if (null != oRemoveImage) {
            oRemoveImage.setVisibility('visible');
            oRemoveImage.setTop(imagePos.Top);
            oRemoveImage.setLeft(iLeft);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Cache used to store ActionImage Objects so that we do not have to
    // query the window's dom object for the action images each time we
    // we want to manipulate them.
    ///////////////////////////////////////////////////////////////////////
    var m_aActionImagesCache = {};

    /**
     * Class to handle attaching hover events to CKEditor instance
     * @constructor
     * @param {CKEDITOR.editor} editor Instance of CKEditor to which events will be attached
     */
    window.CernHoverHandler = function (editor) {
        //Instance variables
        this.m_oEditor = editor;
        //shared variable
        var self = this;

        ///////////////////////////////////////////////////////////////////////
        // an array of elements that currently have the ddinfocus classname
        // assigned to them, start with top-most actionable element, end with
        // section element.
        // Set on Mouse Movement and when clearing our styles
        ///////////////////////////////////////////////////////////////////////
        this.m_focusCache = new FocusCache(editor);

        ///////////////////////////////////////////////////////////////////////
        // variable to store a Timer object for the onScrollTimer.  This is used
        // so that we only adjust our action images 1 time if the user quickly
        // scrolls sending multiple OnScroll events for us to handle.
        ///////////////////////////////////////////////////////////////////////
        this.m_oScrollTimer = null;

        ///////////////////////////////////////////////////////////////////////
        // stores a Timer object used for handling Mouse Movement Adjustments.
        // With this timer, the System can accept multiple mouse movement events,
        // but only adjust the styles of the document once, after the user has
        // paused the mousements momentarily.  GREATLY Improves performance.
        ///////////////////////////////////////////////////////////////////////
        this.m_oMouseOnTimer = null;

        ///////////////////////////////////////////////////////////////////////
        // flag to indicate whether to enable/disable hover plugin
        ///////////////////////////////////////////////////////////////////////
        this.m_bDisablePlugin = false;
        this.m_iDisableCount = 0;

        ///////////////////////////////////////////////////////////////////////
        // flag to indicate whether document is authenticated or not
        // -1 indicates not set, 0 false, 1 true
        ///////////////////////////////////////////////////////////////////////
        this.m_iIsDocumentAuth = -1;

        ///////////////////////////////////////////////////////////////////////
        // Variable to maintain access permission of the loaded document.
        // Value 0: "UnChecked", 1: "ReadOnly", 2: "ReadWrite". "Unchecked"
        // means that the value hasn't been set yet.
        ///////////////////////////////////////////////////////////////////////
        this.m_eCheckedReadOnly = 0;

        ///////////////////////////////////////////////////////////////////////
        // flag to indicate whether strikethrought action is allowed
        ///////////////////////////////////////////////////////////////////////
        this.m_nIsStrikeThroughAllowed = -1;

        this.m_bImagesEnabled = true;

        if(!CernHoverHandler.EventHandlerMap) {
            CernHoverHandler.EventHandlerMap = {};
        }
        CernHoverHandler.EventHandlerMap[editor.id] = this;
    }

    /**
     * Return the handler associated with a given CKEditor instance
     * @param  {CKEDITOR.editor} editor Instance of ckeditor to find handler of
     * @return {CernHoverHandler}  Handler associated to editor
     */
    CernHoverHandler.getEditorEventHandler = function(editor){
        if(CernHoverHandler.EventHandlerMap){
            return CernHoverHandler.EventHandlerMap[editor.id];
        }
    }

    //Private Helper functions

    /**
     * Finds the coordinates to position an action image at
     * the top right corner of the element.
     * If given element has only one rectangle, place the image
     * at the top right corner of the rectangle;
     * otherwise, place the image at the top right corner of the
     * top-right rectangle
     *
     * @param  {HTMLElement} oElement DOM Element for the content item element
     * @return {OffsetPosition}  Postion with the calculated Top and Left values
     */
    function getImagePosAtTopRight(oElement) {
        if (!oElement)
            return null;

        // Get the collection of element rectangles
        var oElementClientRects = oElement.getClientRects();
        var rightPos = oElementClientRects[0].right;
        if (oElementClientRects.length > 1) { // has more that one line of text
            for (var i = 1; i < oElementClientRects.length && oElementClientRects[i].top == oElementClientRects[0].top; i++) {
                rightPos = oElementClientRects[i].right;
            }
        }

        // place image 3px to the right border of the element
        return new OffsetPosition(oElementClientRects[0].top, rightPos - DDENUM.ButtonSize.width - 3, oElement.offsetHeight, oElement.offsetWidth);
    }

    /**
     * Finds the coordinates to position an action image next to the text in the given element.
     *
     * @param  {HTMLElement} oElement DOM Element for the content item element
     * @return {OffsetPosition} Position with the calculated Top and Left values.
     */
    function getImagePosFloatRight(oElement) {
        if (null == oElement)
            return null;

        // Get client rectangles before inserting dummy image
        var oRectBefore = oElement.getClientRects();

        var rectLast = oRectBefore[oRectBefore.length - 1];
        var leftPos = rectLast.right;

        // If element is TR, just put the image to the right of the table
        if (oElement.tagName.toUpperCase() === 'TR')
            return new OffsetPosition(rectLast.top, leftPos - 8 /* subtract so that the image is easier to target */, oElement.offsetHeight, oElement.offsetWidth);

        if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_EMR_CONTENT_ITEM) == false) {
            // If this element wraps to multiple lines, place image the top-right corner.
            // When a vital sign element is wrapped to the next line, it will have 2 rectangles.
            // The first one is a dummy rectangle with same left and right value. The 2nd
            // is where the text is. Detect this case display the text along with text.
            if (oRectBefore.length > 2 || (oRectBefore.length == 2 && oRectBefore[0].left != oRectBefore[0].right)) {
                return getImagePosAtTopRight(oElement);
            }
        }

        // Create dummy image element and append it into the given element
        var sImage = ["<img id='", g_sDUMMY_IMG_ID, "' style='visibility:hidden' />"];
        var oDummyImage = oElement.document.createElement(sImage.join(""));
        oDummyImage.style.width = DDENUM.ButtonSize.width;
        oElement.appendChild(oDummyImage);

        // If the dummy image wrapps, place image at the top right corner of the last line
        var oRectAfter = oElement.getClientRects();
        if (oRectAfter.length > oRectBefore.length && oRectAfter[oRectAfter.length - 1].left < rectLast.right) {
            leftPos -= DDENUM.ButtonSize.width;
        }
        else {
            // Set the left/top position based on the image we just inserted
            // Place icon after the text with no padding between. Extra gap between icon and text will cause
            // icon disappear before moving cursor from text into icon.
            // NOTE: No need to pad 10px if coordinates overlap
            // NOTE: Some (div) element only take as much place as its text need, instead of the whole line.
            //       In this case, we need to keep the icon close to text so that icon won't disappear when
            //       moving mouse from element text to icon.
            leftPos = oDummyImage.getClientRects()[0].left;
        }

        // clean up: remove dummy image from the element
        oDummyImage.removeNode();
        return new OffsetPosition(rectLast.top, leftPos, oElement.offsetHeight, oElement.offsetWidth);
    }

    /**
    * Remove hovering border of all children elements and replace with normal borders
    *
    * @param {HTMLElement} oElement     The HTML element that will be deleted.
    */
    function removeChildHoverBorders(oElement) {
        $(oElement).children().removeClass(g_sCLASS_SIBLING);
    }

    /**
     * Searches the HTML for the elements associated to our hover
     * images and then removes them from the HTML
     * @param  {String} sClassName Is used as a flag to indicate if we are removing
     *  the images for a section or a subsection.  If we remove for a
     *  Section, we also remove for all of it's child subsections.
     */
    function removeImages(sClassName) {
        // No images have been added yet therefore no need to remove them
        if (!m_aActionImagesCache)
            return;

        hideActionElementImage();

        if (DDCOMMON.hasClassName(sClassName, g_sCLASS_SUBSECTION) ||
            DDCOMMON.hasClassName(sClassName, g_sCLASS_SECTION)) {
            // hide SubSection 'insert' image
            var oActionImg = m_aActionImagesCache[g_sID_INSERT_SUBSECTION];
            if (oActionImg != null) {
                removeChildHoverBorders(oActionImg.getLinkedElement());
                oActionImg.hide();
            }

            // hide SubSection 'remove' image
            oActionImg = m_aActionImagesCache[g_sID_REMOVE_SUBSECTION];
            if (oActionImg != null) {
                oActionImg.hide();
            }

            // hide SubSection 'refresh' image
            oActionImg = m_aActionImagesCache[g_sID_REFRESH_SUBSECTION];
            if (oActionImg != null) {
                oActionImg.hide();
            }
        }

        // hide the images for the section if we are processing a section change.
        if (DDCOMMON.hasClassName(sClassName, g_sCLASS_SECTION)) {

            oActionImg = m_aActionImagesCache[g_sID_INSERT_SECTION];
            if (oActionImg != null) {
                removeChildHoverBorders(oActionImg.getLinkedElement());
                oActionImg.hide();
            }

            oActionImg = m_aActionImagesCache[g_sID_REMOVE_SECTION];
            if (oActionImg != null) {
                oActionImg.hide();
            }

            var oActionImg = m_aActionImagesCache[g_sID_REFRESH_SECTION];
            if (oActionImg != null) {
                oActionImg.hide();
            }
        }

        var oActionImg = m_aActionImagesCache[g_sID_INSERT_FT_EMRITEM];
        if (oActionImg)
            oActionImg.hide();
    }


    /**
     * Hide existing hover image(s) of the top action element
     * that is neither section or subsection. And remove the
     * the action element flag from the element
     */
    function hideActionElementImage() {
        // No images have been added yet therefore no need to remove them
        if (!m_aActionImagesCache)
            return;

        $([ g_sID_REMOVE_ELEMENT, g_sID_INSERT_FT_EMRITEM, g_sID_STRIKE_ELEMENT ]).each(function(_, className) {
            var oActionImg = m_aActionImagesCache[className];
            if (oActionImg) {
                $(oActionImg.getLinkedElement()).removeClass(g_sCLASS_ACTIONELEMENT);
                oActionImg.hide();
            }
        });
    }

    /**
     * Retrieves the Action Image's related Section or SubSection
     * element and then finds the Section Display element
     * that is a child of that section or sub section
     * @param  {ActionImage} oImage ActionImage object that is associated
     *  to some section.
     * @return {HTMLElement} The section display element.
     */
    function getImageSectionHeading(oImage) {
        if (null == oImage)
            return null;

        var oSectionElement = oImage.getLinkedElement();
        if (null != oSectionElement)
            return DDCOMMON.getSectionDisplayElement(oSectionElement);
        else
            return null;
    }

    /**
     * Return the maximum (top) offset position for ancestors of the passed element
     * @param  {HTMLElement|jQuery} oElement Element to determine max offset for
     * @return {Integer} Maximum top-offset position found in elements ancestry
     */
    function getMaximumAncestorTopOffset(oElement) {
        var $element = $(oElement);
        var offsetTop = 0;
        var offset = 0;
        while ($element.length && $element[0].nodeType === Node.ELEMENT_NODE) {
            offsetTop = $element.offset().top;
            if (offsetTop > offset) {
                offset = offsetTop;
            }
            $element = $element.parent();
        }
        return offset;
    }

    /////////////////////////////////////////
    //************    PUBLIC     ************
    /////////////////////////////////////////

    /**
    * Create's the HTML for a New Action Image Node. Inserts the Action image in the DOM of the document.
    * Image displays at the given position and will act against the given element.
    * @param {HTMLElement}  oElement    The HTML DOM element to apply the action
    * @param {ActionType}   eActionType The type of action
    * @param {number}       iTop        Image's top position
    * @param {number}       iLeft       image's left position
    * @param {Function}     fOnClick    The function to call when the image is clicked.
    */
    CernHoverHandler.prototype.createActionImageHTML = function(oElement, eActionType, iTop, iLeft, fOnClick) {
        // If position is above editor, return early
        if (this.m_oEditor.document.$ === document) {
            if (iTop < getMaximumAncestorTopOffset($(this.m_oEditor.editable().$))) {
                return;
            }
        }

        var bIsSection = DDCOMMON.hasClassName(oElement.className, g_sCLASS_SECTION);
        var bIsSubSection = DDCOMMON.hasClassName(oElement.className, g_sCLASS_SUBSECTION);

        var sSrcPath = "";  // the src path to the image
        var sImageId = "";  // the image id to apply to the image
        var sAltText = "";  // Alternate Text to display in case the image is not found.  Also serves as the Tool Tip Text
        var sHoverUrl = ""; // hover image for action image
        switch (eActionType) {
            case DDENUM.ActionType.insertFreeText: // insert free text icon only displays @ section/subsection
                sSrcPath = CKEDITOR.getUrl("images/insert.png");
                sHoverUrl = CKEDITOR.getUrl("images/insertRollover.png");
                sImageId = bIsSection ? g_sID_INSERT_SECTION :
                           bIsSubSection ? g_sID_INSERT_SUBSECTION : g_sID_INSERT_FT_EMRITEM;
                sAltText = this.m_oEditor.lang.cernhover.insertFreeText;
                break;

            case DDENUM.ActionType.refresh: // refresh icon only displays @ section/subsection
                if (!bIsSection && !bIsSubSection) return;
                sSrcPath = CKEDITOR.getUrl("images/refresh.png");
                sHoverUrl = CKEDITOR.getUrl("images/refreshRollover.png");
                sImageId = bIsSection ? g_sID_REFRESH_SECTION : g_sID_REFRESH_SUBSECTION;
                sAltText = bIsSection ? this.m_oEditor.lang.cernhover.refreshSection :
                                        this.m_oEditor.lang.cernhover.refreshSubSection;
                break;

            case DDENUM.ActionType.remove:
                sSrcPath = CKEDITOR.getUrl("images/remove.png");
                sHoverUrl = CKEDITOR.getUrl("images/removeRollover.png");
                sImageId = bIsSection ? g_sID_REMOVE_SECTION :
                           bIsSubSection ? g_sID_REMOVE_SUBSECTION : g_sID_REMOVE_ELEMENT;
                sAltText = this.m_oEditor.lang.cernhover.removeFromNote;
                break;

            case DDENUM.ActionType.strikethrough:
                sSrcPath = CKEDITOR.getUrl("images/remove.png");
                sHoverUrl = CKEDITOR.getUrl("images/removeRollover.png");
                sImageId = g_sID_STRIKE_ELEMENT;
                sAltText = this.m_oEditor.lang.cernhover.strikeItem;
                break;
        }

        var actionImage = (null == m_aActionImagesCache) ? null : m_aActionImagesCache[sImageId];
        if (null == actionImage) {
            //create a new img element and append it to the body
            var imgElement = $('<img />', {
                'class': g_sCLASS_ACTION_IMAGE,
                id: sImageId,
                alt: sAltText,
                src: sSrcPath,
                css: {
                    height: DDENUM.ButtonSize.height + 'px',
                    width: DDENUM.ButtonSize.width + 'px',
                    posTop: iTop + 'px',
                    posLeft: iLeft + 'px'
                }
            });

            imgElement.prop('linkedElement', oElement);
            imgElement.on({
                'mouseover': function () { this.src = sHoverUrl },
                'mouseout':  function () { this.src = sSrcPath },
                'dragstart': function () { return false; },
                'onclick': fOnClick
            });

            $('body').append(imgElement);

            // Whenever a new ActionImage is created, it is automatically added to
            // the m_aActionImagesCache array and cached.
            new ActionImage(imgElement[0]);
        }
        else {
            actionImage.setLeft(iLeft);
            actionImage.setTop(iTop);

            // If the image offset would be off the text area due to scrolling, don't display the image
            actionImage.setVisibility("visible");
            actionImage.setAltText(sAltText);
            actionImage.setLinkedElement(oElement);
            actionImage.$.onclick = fOnClick;
        }

        if (typeof ModifyStructure !== 'undefined') {
            ModifyStructure.handleMouseOver(oElement);
        }
    };

    /**
    * This function loops thru section and searches if ddfreetext already exists.
    * It gives priority to DOC_COMP freetext over other freetext elemets.
    * DOC_COMP freetext must not be under a different EMR content section.
    * @param {HTMLElement} : The HTML DOM parent element.
    * Returns ddfreetext if it exists return first free text node, null otherwise.
    */
    function searchForFreeText(oParentElement) {

        if (!oParentElement)
            return null;

        // Look for freetext descendant of oParentElement under a DOC COMP but not under another non DOC COMP EMR content section.
        var lstFreeTextNodes = $(oParentElement).find('.ddemrcontent[dd\\:contenttype="DOC_COMP"] .ddcomponent .ddfreetext')
                                                .not('.ddemrcontent[dd\\:contenttype!="DOC_COMP"] .ddfreetext');
        if (0 != lstFreeTextNodes.length)
            return lstFreeTextNodes[0];

        // Look for direct freetext children of oParentElement
        lstFreeTextNodes = $(oParentElement).children(".ddfreetext");
        if (0 != lstFreeTextNodes.length)
            return lstFreeTextNodes[0];

        return null; // no free text found
    }

    /**
    * Inserts free text div to the current section or subSection.
    *
    * If the section/subSection already has a freeText div (ddfreetext),
    * set focus on the free text area and move cursor to the end
    * @param   {HTMLElement}  oElement the element whose action image that was clicked
    */
    CernHoverHandler.prototype.insertFreeText = function (oElement) {
        if (!oElement)
            return;

        // Check if section/subsection already has freetext under children / DOC_COMP (not under other emr content)
        var oFreeTextNode = searchForFreeText(oElement);
        var oInsertedFreeTextNode = null;
        if (!oFreeTextNode) {
            // Find place to insert free text and append
            if (typeof CKEDITOR.DocUtilsHelper !== 'undefined' && typeof CKEDITOR.DocUtilsHelper.GenerateGUID !== 'undefined') {
                // create free text area
                var $freetextDiv = $("<div></div>", {
                    "class": g_sCLASS_FREETEXT + ' ' + g_sCLASS_REMOVABLE,
                    "id": CKEDITOR.DocUtilsHelper.GenerateGUID(),
                    "dd:btnfloatingstyle": 'top-right',
                    "contentEditable": 'true'
                });

                // Freetext for EMR are indented:
                if ($(oElement).hasClass(g_sCLASS_EMR_CONTENT_ITEM))
                    $freetextDiv.css('margin-left', '.5em');

                var $ddComponents = $(oElement).find('.ddemrcontent[dd\\:contenttype="DOC_COMP"] .ddcomponent');

                if ($ddComponents.length > 0) 
                    oInsertedFreeTextNode = $ddComponents[0].appendChild($freetextDiv[0]);
                
                else 
                    oInsertedFreeTextNode = oElement.insertBefore($freetextDiv[0]);
            }

            // Search for the newly added freetext element
            oFreeTextNode = searchForFreeText(oElement);
        }

        // Delay 10 millisec, otherwise the cursor I-beam pointer remains on the current selected free-text
        if (oFreeTextNode) {
            setTimeout(function () {
                // Check if element still exists before trying to use it
                if (oFreeTextNode.ownerDocument.documentElement.contains(oFreeTextNode)) {
                    oFreeTextNode.focus();
                    // Put cursor at end of existing freetext.
                    if(!oInsertedFreeTextNode)
                        DDCOMMON.putCursorAtEnd(oFreeTextNode);
                }
            }, 10);
        }

        // Adjust position of section/subsection images when freetext inserted
        for (var index in this.m_focusCache.m_aFocusElementsCache) {
            adjustSectionImagePositions(this.m_focusCache.m_aFocusElementsCache[index]);
        }
    };

    /**
     * Insert action image(s) to given section/subsection element
     *  base on element class name and content:
     *   * Insert "refresh" button if element contains EMR content or Smart Template
     *   * Insert "insert free text" button to all section/subsection elements
     *   * Insert "remove" button if element is removable
     *  Calculate image position based on dd:btnfloatingstyle attribute.
     *  Define click handler for each image.
     *
     * @param  {HTMLElement} oElement HTML Dom element that need to insert action images into
     */
    CernHoverHandler.prototype.insertSectionActionImages = function(oElement) {
        var self = this;
        if (null == oElement)
            return;
        // Only display refresh image when element contains EMR Content or Smart Template
        var aRefreshableContent = DDCOMMON.getDescendentsByClassNames(oElement, [ g_sCLASS_EMR_CONTENT, g_sCLASS_BLOCK_SMART_TEMPLATE, g_sCLASS_BLOCK_TOKEN ]);
        var bRefreshable = aRefreshableContent && aRefreshableContent.length > 0;

        // Only display remove image when the element is removable
        var bRemovable = DDCOMMON.isElementRemovable(oElement);

        // Calculate the top left position of the first image
        var imagePos = calculateSectionImageTopAndLeft(oElement, bRefreshable, bRemovable);
        if (!imagePos)
            return;

        // Display the refresh image if the section contains EMR Content
        if (bRefreshable) {
            var refreshSectImageOnClickEventHandler = function () {
                // saveSnapshot is fired when the refresh image is clicked.
                self.m_oEditor.fire('saveSnapshot');

                self.m_oEditor.execCommand(DDCMD_REFRESHELEMENT, {
                    element:  event.srcElement.linkedElement
                });

                // Since the user clicked the image button, which is outside of the editor, the focus is
                // no longer in the editor.  Put the focus back in the editor so that things like keyboard
                // shortcuts still work.
                if (CKEDITOR.env.ie && CKEDITOR.env.version < 9)
                    self.m_oEditor.editable().$.setActive();
                self.m_oEditor.editable().$.focus();

                // saveSnapshot is fired after the refresh action is performed.
                self.m_oEditor.fire('saveSnapshot');
            };
            self.createActionImageHTML(oElement, DDENUM.ActionType.refresh, imagePos.Top, imagePos.Left, refreshSectImageOnClickEventHandler);
            imagePos.Left += (DDENUM.ButtonSize.width + 3);
        }

        // Display insert free text image if the element is ddinsertfreetext
        if ($(oElement).hasClass(g_sCLASS_INSERT_FREETEXT)) {
            var insertFreeTextImageOnClickEventHandler = function () {
                self.m_oEditor.execCommand(DDCMD_INSERTFREETEXT, event.srcElement.linkedElement);
            };
            self.createActionImageHTML(oElement, DDENUM.ActionType.insertFreeText, imagePos.Top, imagePos.Left, insertFreeTextImageOnClickEventHandler);
            imagePos.Left += (DDENUM.ButtonSize.width + 3);
        }

        // Display the remove image if self element is removable
        if (bRemovable) {
            var removeSectImageOnClickEventHandler = function () {
                self.m_oEditor.execCommand(DDCMD_REMOVEELEMENT, event.srcElement.linkedElement);
            };
            self.createActionImageHTML(oElement, DDENUM.ActionType.remove, imagePos.Top, imagePos.Left, removeSectImageOnClickEventHandler);
        }
    }

    /**
     * Inserts action image to given EMR or Freetext element.
     * Assigns the image id, height and width accordingly.
     * Defines the click handler for the image.
     * @param  {HTMLElement} oElement The element where the action image will be floating adjacent
     */
    CernHoverHandler.prototype.displayContentItemImage = function(oElement) {
        var self = this;
        if (null == oElement)
            return;

        if (this.m_bImagesEnabled == false)
            return;

        // Determine the correct position for the image
        var oImagePos = null;
        switch (DDCOMMON.getButtonFloatingStyle(oElement)) {
            case DDENUM.BtnFloatingStyle.topRight:
                oImagePos = getImagePosAtTopRight(oElement);
                break;

            default: // float right
                oImagePos = {};

                if (oElement.tagName.toUpperCase() == 'TR') {   // <tr> is special
                    oImagePos = getImagePosFloatRight(oElement);
                    // NOTE:  If you have a full-width <table>, consider using top-right instead of
                    //        float-right.
                }
                else {
                    var elementRects = oElement.getClientRects();
                    var lastElementRect = elementRects.length ? elementRects[elementRects.length-1] : null;

                    // Create a dummy <img> to insert that will give us the absolute coordinates
                    var $img = $('<img/>', self.m_oEditor.document.$).
                            attr('width', DDENUM.ButtonSize.width).
                            attr('height', DDENUM.ButtonSize.height).
                            css('visibility', 'hidden');

                    // Find the first block element, if any.  The <img> will be inserted
                    // immediately before the first block.  Or, if there is no child block
                    // elements, simply append it to the element.
                    var firstBlock = (function() {
                        var children = $(oElement).children();
                        for (var i = 0; i < children.length; i++) {
                            if ($(children[i]).css('display') == 'block' || children[i].tagName.toUpperCase() === 'BR')
                                return children[i];
                        }
                        return null;
                    })();
                    if (firstBlock)
                        $img.insertBefore(firstBlock);
                    else
                        oElement.appendChild($img[0]);

                    try {
                        var offset = $img.offset();
                        oImagePos.Left = offset.left;
                        oImagePos.Top  = offset.top;

                        // Adjust for scroll position (of both top document and iframe document!)
                        //oImagePos.Top -= $(document).scrollTop();
                        //if (document !== self.m_oEditor.document.$)
                        //    oImagePos.Top -= $(self.m_oEditor.document.$).scrollTop();

                        // Add padding for block elements, don't add padding for inline elements
                        var iPadding = 3;
                        if ($(oElement).css('display') === 'inline')
                            iPadding = 0;

                        oImagePos.Left += iPadding;
                    }
                    finally {
                        $img.remove();  // Remove dummy image
                    }
                    // If the icon is going to run below the element, move it back to the top-right of the last
                    // rectangle of the element
                    var scrollDiff = $(oElement).offset().top - lastElementRect.top;
                    if (lastElementRect && oImagePos.Top + DDENUM.ButtonSize.height > (scrollDiff + lastElementRect.bottom)) {
                        oImagePos.Top = lastElementRect.top;
                        oImagePos.Left = lastElementRect.right - DDENUM.ButtonSize.width;
                    }
                }   // if-else:  tag is TR
        }   // switch:  button floating style

        if (1 == this.isDocumentAuth()) {
            // If document is Authenticated, enable strikethrough functionality
            var strikeContentItemImageOnClickEvntHndlr = function () {
                self.m_oEditor.execCommand(DDCMD_STRIKEELEMENT, event.srcElement.linkedElement);
                try {
                    if (CKEDITOR.env.ie && CKEDITOR.env.version < 9)
                        self.m_oEditor.editable().$.setActive();
                    self.m_oEditor.editable().$.focus();
                }
                catch (e) {
                    DocHandleError('strike - Exception when setting focus to the editor:  ' + (e.message || e), 'DynDocCKEditor');
                }
            };
            self.createActionImageHTML(oElement, DDENUM.ActionType.strikethrough, oImagePos.Top, oImagePos.Left, strikeContentItemImageOnClickEvntHndlr);
        }
        else {
            var bIsInsertFreeText = DDCOMMON.hasClassName(oElement.className, g_sCLASS_INSERT_FREETEXT);  // Only show insert button for insertfreetext elements
            var bIsBlock = CKEDITOR.dtd.$block[oElement.tagName.toLowerCase()]; // Only show insert button for block elements
            var bIsTr = oElement.tagName.toUpperCase() === 'TR';    // Don't show insert button for TR's (NOTE:  Redundant as we are checking for bIsBlock)

            // Whether or not to show the insert freetext button
            var bInsertFreeTextBtn = bIsInsertFreeText && bIsBlock && !bIsTr && !DDCOMMON.hasClassName(oElement.className, g_sCLASS_FREETEXT);
            // Whether or not to show the remove element button
            var bRemoveElementBtn = DDCOMMON.hasClassName(oElement.className, g_sCLASS_REMOVABLE);

            if (bInsertFreeTextBtn) {
                var insertFreeTextImageOnClickEventHandler = function () {
                    self.m_oEditor.execCommand(DDCMD_INSERTFREETEXT, event.srcElement.linkedElement);
                };
                self.createActionImageHTML(oElement, DDENUM.ActionType.insertFreeText, oImagePos.Top, oImagePos.Left, insertFreeTextImageOnClickEventHandler);
            }

            if (bRemoveElementBtn) {
                if (bInsertFreeTextBtn)
                    oImagePos.Left += (DDENUM.ButtonSize.width + 3);
                var rmvContentItemImageOnClickEvntHndlr = function () {
                    self.m_oEditor.execCommand(DDCMD_REMOVEELEMENT, event.srcElement.linkedElement);
                };
                self.createActionImageHTML(oElement, DDENUM.ActionType.remove, oImagePos.Top, oImagePos.Left, rmvContentItemImageOnClickEvntHndlr);
            }
        }
    };


    /**
     * Removes the specified class name from each of the elements having this class name.
     *
     * @note This function may processor intensive.
     *
     * @param  {String} sClassNameToClear Class name you wish to remove from the document
     */
    CernHoverHandler.prototype.clearFullDocOfClass = function(sClassNameToClear) {
        var doc = this.m_oEditor.editable().$;
        $(doc).find('.' + sClassNameToClear).removeClass(sClassNameToClear);
    };

    /**
     * generateRemovableImage - Check preferences and generate the removeable icon if able
     * @param  {HTMLElement} oElement       Element currently hovered over
     * @param  {HTMLElement} oElementParent Parent section/subsection of hovered element
     */
    CernHoverHandler.prototype.generateRemovableImage = function(oElement, oElementParent) {
        var oRemovableElement;
        var bIsAuth = (1 == this.isDocumentAuth());
        if (false == bIsAuth || 1 == this.m_nIsStrikeThroughAllowed) {
            // Get the top most removable from the current element to parent elements
            oRemovableElement = DDCOMMON.getParentByClass(oElement, g_sCLASS_REMOVABLE);
            if (null != oRemovableElement && (  // TODO:  De-mystify
                oRemovableElement == oElementParent || // removable element is the parent section/subsection
                DDCOMMON.hasClassName(oRemovableElement.className, g_sCLASS_SECTION) ||
                DDCOMMON.hasClassName(oRemovableElement.className, g_sCLASS_SUBSECTION))) {
                oRemovableElement = null;
            }

            if (null == oRemovableElement) {
                // No removable element found, hide element image
                hideActionElementImage();
            }
            else if (DDCOMMON.hasClassName(oRemovableElement.className, g_sCLASS_FREETEXT)) {
                if (false == bIsAuth) {

                // Display for all removable free text elements in document
                    this.displayContentItemImage(oRemovableElement);
                }
                else {
                    var oContribution = DDCOMMON.getParentElementByClass(oRemovableElement, g_sCLASS_CONTRIBUTION);
                    if (null != oContribution && false == DDCOMMON.getAttributeBoolean(oContribution, g_sATTRIBUTE_ACTIVE)
                        && $.trim($(oRemovableElement).text()).length > 0) {

                        // Only display for removable free text elements in inactive contributions and free text has text to strike.
                        this.displayContentItemImage(oRemovableElement);
                    }
                }
            }
            else {
                this.displayContentItemImage(oRemovableElement);
            }
        }
        return oRemovableElement;
    };


    /**
     * Returns true if the section is standalone, otherwise returns false
     * @return {Boolean} Returns the 'isStandaloneSection' setting configured for the
     *                   current enditor.  This will generally be set as true in MPages
     *                   and false in Dynamic Documentation
     */
    CernHoverHandler.prototype.isStandaloneSection = function(){
        return this.m_oEditor.config.isStandaloneSection;
    }



    /**
     * Return true if the element is a section or subsection (based on styling)
     * @param  {HTMLElement}  oElement [description]
     * @return {Boolean}          [description]
     */
    function isSectionOrSubsection(oElement){
        // has true if has subsection or section class
        var isSectionOrSubsection = DDCOMMON.hasClassName(oElement.className, g_sCLASS_SECTION) ||
                                    DDCOMMON.hasClassName(oElement.className, g_sCLASS_SUBSECTION);
        return isSectionOrSubsection;
    }

    /**
     * Handles styling of parent content sections based on passed Parent Section Element
     *
     * This function determines whether the passed Parent
     * Section contains multiple subsections.  If it does,
     * it handles styling updates within the Parent Section
     * @param  {HTMLElement} oElementParent Element containing multiple sections to style
     */
    CernHoverHandler.prototype.handleMultipleContentSections = function(oElementParent) {
        var oElementCur = oElementParent.firstChild;
        var isStandalone = this.isStandaloneSection();
        var iFreeText = 0;
        var iEMRContent = 0;
        var iSubSections = 0;

        // Logic for standalone section
        var inSectionOrSubsection = isSectionOrSubsection(oElementParent);

        // Check if the parent element is a section, then count its freetext and emrcontents
        if (inSectionOrSubsection || isStandalone) {

            while (oElementCur != null) {

                if (DDCOMMON.hasClassName(oElementCur.className, g_sCLASS_FREETEXT)) {
                    iFreeText = iFreeText + 1;
                }
                else if (DDCOMMON.hasClassName(oElementCur.className, g_sCLASS_EMR_CONTENT)) {
                    iEMRContent = iEMRContent + 1;
                }
                else if (DDCOMMON.hasClassName(oElementCur.className, g_sCLASS_SUBSECTION)) {
                    iSubSections = iSubSections + 1;
                }

                oElementCur = oElementCur.nextSibling;
            }
        }

        // Add class back to each child
        oElementCur = oElementParent.firstChild;
        while (oElementCur != null) {
            if (isSectionOrSubsection && DDCOMMON.hasClassName(oElementCur.className, g_sCLASS_EMR_CONTENT)
                && oElementCur.childNodes.length > 0) {
                if (iFreeText + iEMRContent + iSubSections > 1) {
                    // More than one area of content in this paragraph, honor border-color set in stylesheet
                    oElementCur.className = DDCOMMON.appendClassName(oElementCur.className, g_sCLASS_SIBLING);
                }
            }
            oElementCur = oElementCur.nextSibling;
        }
    };

    /**
     * Returns true if the mouse event on the passed element
     * requires updates to currently displayed content;
     * false otherwise
     * @param  {HTMLElement} oElement Element event fires from
     * @return {Boolean} Returns true if event fired on element requires styling update
     */
    CernHoverHandler.prototype.eventRequiresUpdate = function(oElement){
        var $element = $(oElement);
        if ($element.hasClass(g_sCLASS_ACTION_IMAGE)){
            return false;
        }
        return true;
    };

    /**
     * Event Handler function for onmouseover event for editable content within editor
     * @param  {HTMLElement} oElement HTMLElement that fires mouseover event
     */
    CernHoverHandler.prototype.onMouseOver = function(oElement) {
        var requiresUpdate = this.eventRequiresUpdate(oElement);
        if (requiresUpdate) {
            var oParentElement = this.getParentSectionElement(oElement);
            this.handleMouseOffSectionContent(oElement);
            if (this.getDisablePlugin()) {
                return;
            }
            if (oParentElement) {
                this.handleSectionImages(oElement, oParentElement);
                this.removePreviousFocus(oElement, oParentElement);
                this.handleMultipleContentSections(oParentElement);
                var oRemovableElement = this.generateRemovableImage(oElement, oParentElement);
                this.setNewFocus(oElement, oParentElement, oRemovableElement);
            }
        }
    };

    /**
     * Event Handling function for the onmouseoff event for editable content within editor
     * @param  {HTMLElement} srcElement Element that mouse has left
     * @param  {HTMLElement} targetElement Element mouse moved to
     */
    CernHoverHandler.prototype.onMouseOff = function(srcElement, targetElement) {
        var requiresUpdate = this.eventRequiresUpdate(targetElement);
        if (requiresUpdate) {
            var srcParentElement = this.getParentSectionElement(srcElement);
            if (targetElement)
                this.handleMouseOffSectionContent(targetElement);
            if (this.getDisablePlugin())
                return;
            this.removePreviousFocus(srcElement, srcParentElement);
        }
    };

    /**
     * Determines whether displaying section images is necessary based on the current mouse event.
     * If it is, images will be displayed next to parent section.
     * @param  {HTMLElement} oElement Element that is being moused over
     * @param  {HTMLElement} oElementParent Parent section of mouseover element
     */
    CernHoverHandler.prototype.handleSectionImages = function(oElement, oElementParent) {
        if (0 == this.isDocumentAuth()) {
            this.displaySectionImages(oElementParent);
        }
        else {
            // Display Section images if in active contribution
            var oContribution = DDCOMMON.getParentElementByClass(oElement, g_sCLASS_CONTRIBUTION);
            if (oContribution) {
                if (true == DDCOMMON.getAttributeBoolean(oContribution, g_sATTRIBUTE_ACTIVE))
                    this.displaySectionImages(oElementParent);
            }
        }
    };


    /**
     * Custom Logic to insert Images into a section/subsection when hovering. If cursor is currently
     * inside a subsection, also insert images into parent section when needed.
     * @param  {HTMLElement} oElement The Section or Sub section that the cursor is currently in
     */
    CernHoverHandler.prototype.displaySectionImages = function(oElement) {
        if (null == oElement)
            return;

        var oFocusSection = this.m_focusCache.getFocusSection();
        var oFocusSubsection = this.m_focusCache.getFocusSubsection();

        if (oElement == oFocusSection) { // within the same section
            if (null != oFocusSubsection) { // focus was previously in a subsection of the same section
                removeImages(oFocusSubsection.className);
            }
        }

        var bUpdateParentSectionImage = false;
        var oImageParentSection = null;

        // When mouse is currently inside a subsection, check if parent section needs to insert images
        if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_SUBSECTION)) {
            var oElementParentSection = DDCOMMON.getParentByClass(oElement, g_sCLASS_SECTION);
            // check if document has section images
            var oInsertImage = null == m_aActionImagesCache ? null : m_aActionImagesCache[g_sID_INSERT_SECTION];
            if (oElementParentSection && oInsertImage) {
                // check if existing section image belongs to current section
                oImageParentSection = oInsertImage.getLinkedElement();
                if (null == oImageParentSection ||
                    oImageParentSection.id != oElementParentSection.id ||
                    oElementParentSection != oFocusSection) {
                    bUpdateParentSectionImage = true;
                }
            }
            else {
                // if parent section does not display add/remove images, insert images to parent section
                if (oElementParentSection){
                    bUpdateParentSectionImage = true;
                }
            }
        }
        if (bUpdateParentSectionImage) {
            // remove images in whole section and insert images into parent section
            removeImages(oElementParentSection.className);
            if (this.m_bImagesEnabled)
                this.insertSectionActionImages(oElementParentSection);
        }
        else {
            removeImages(oElement.className);
        }

        if (this.m_bImagesEnabled) {
            this.insertSectionActionImages(oElement);
        }
    };

    /**
     * Determines if mouse is out of parent section.  If it is, focus is cleared within the editor
     * @param  {HTMLElement} oElement       Element that fired event
     */
    CernHoverHandler.prototype.handleMouseOffSectionContent = function(oElement) {
        // Clear out focus and remove icons when focus is out of a section or MPage content
        var isStandaloneSection = this.isStandaloneSection();
        var parentSectionElement = this.getParentSectionElement(oElement);
        var inSection = false;
        if (parentSectionElement) {
            if (isStandaloneSection) {
                // For standalone also clear focus when mouse over content parent
                inSection = (parentSectionElement !== oElement);
            }
            else {
                inSection = true;
            }
        }

        if (!inSection) {
            this.clearFocus();
        }
    };

    /**
     * Retrieves the DOM element that contains the parent section of the passed element.
     * @param  {HTMLElement} oElement Element to find parent section of
     * @return {HTMLElement} Parent section element
     */
    CernHoverHandler.prototype.getParentSectionElement = function(oElement){
        var $element = $(oElement);
        var isStandalone = this.isStandaloneSection();
        var $oParentSection = null;
        var oParentSection = null;
        if (isStandalone){
            var $editable  = $(this.m_oEditor.editable().$);
            $oParentSection = $element.closest($editable);
        }
        else{
            $oParentSection = $element.closest(DDCOMMON.createSelector([ g_sCLASS_SUBSECTION, g_sCLASS_SECTION ]));
        }

        if ($oParentSection.length){
            oParentSection = $oParentSection[0];
        }

        return oParentSection;
    };

    /**
     * Updates previously focused sections and subsections based on passed Source Element
     * and Parent Section Element after a mouseout, mouseover, or focusout event.  Updates sibling borders.
     * @param  {HTMLElement} oElement Element that fired mouse event
     * @param  {HTMLElement} oElementParent Parent section of element that fired event
     */
    CernHoverHandler.prototype.removePreviousFocus = function(oElement, oElementParent){
        // Clear added borders from old in focus section/subsection
        var oFocusSection = this.m_focusCache.getFocusSection();
        var oFocusSubsection = this.m_focusCache.getFocusSubsection();
        //Within same section
        if (oElementParent === oFocusSection){
            if (oFocusSubsection){
                //Remove border if focus previously in subsection of same section
                removeChildHoverBorders(oFocusSubsection);
            }
        }
        else if (oElement !== oFocusSubsection){
            //Remove border of section if in different subsection
            removeChildHoverBorders(oFocusSection);
        }
    };

    /**
     * Sets the new focus for an onmouseover event based on the passed Source Element,
     * Parent Section Element, and Removable Icon Element
     * @param {HTMLElement} oElement            Element with focus
     * @param {HTMLElement} oElementParent      Parent Section Element of focused element
     * @param {HTMLElement} oRemovableElement   Removable icon element associated with focused element
     */
    CernHoverHandler.prototype.setNewFocus = function(oElement, oElementParent, oRemovableElement) {
        var editor = this.m_oEditor;
        var isStandalone = this.isStandaloneSection();
        if (!editor) {
            return;
        }
        if (oRemovableElement) {
            this.m_focusCache.setElementsInFocus(oRemovableElement);
        }
        else if (DDCOMMON.hasClassName(oElement.className, g_sCLASS_FREETEXT)) {
            this.m_focusCache.setElementsInFocus(oElement);
        }
        else if (!isStandalone) { // when no removable element found, set focus to parent section/subsection.
            this.m_focusCache.setElementsInFocus(oElementParent);
        }
    };

    /**
     * sets the disable plugin flag indicator
     * @param {Boolean} bFlag flag indicator to set
     */
    CernHoverHandler.prototype.setDisablePlugin = function (bFlag) {
        return this[bFlag ? 'disablePlugin' : 'enablePlugin']();
    };

    CernHoverHandler.prototype.disablePlugin = function() {
        this.m_iDisableCount++;
        return this.updateEnabledState();
    };

    CernHoverHandler.prototype.enablePlugin =  function() {
        if (this.m_iDisableCount > 0)
            this.m_iDisableCount--;
        return this.updateEnabledState();
    };

    CernHoverHandler.prototype.updateEnabledState = function() {
        this.m_bDisablePlugin = this.m_iDisableCount > 0;
        return !this.m_bDisablePlugin;
    };

    /**
     * Gets the flag indicator
     * @return {Boolean} True if disable is on, false otherwise
     */
    CernHoverHandler.prototype.getDisablePlugin = function () {

        // m_DocumentStatus is a variable that maintains access permission of the loaded document.
        // Value 0: "UnChecked", 1: "ReadOnly", 2: "ReadWrite". "Unchecked" means that the value hasn't been set yet.

        switch (this.m_eCheckedReadOnly) {
            // UnChecked
            case 0:
                var lFlag = false;

                if (null != DDCOMMON.m_oWin32Document) {
                    lFlag = DDCOMMON.m_oWin32Document.ReadOnly();

                    if (lFlag == true) {
                        this.m_eCheckedReadOnly = 1;
                        return (this.m_bDisablePlugin || true);
                    }
                    else {
                        this.m_eCheckedReadOnly = 2;
                        return (this.m_bDisablePlugin || false);
                    }
                }
                else {
                    return false;
                }

            // ReadOnly
            case 1: return (this.m_bDisablePlugin || true);

            // ReadWrite
            case 2: return (this.m_bDisablePlugin || false);
        }
    };


    /**
     * Logic to determine if document is authenticated. Assumes CernDynDocCommon's instanceReady has executed
     * @return {Number} 1 if document is authenticated (has active contributions)
     */
    CernHoverHandler.prototype.isDocumentAuth = function() {
        if (-1 == this.m_iIsDocumentAuth) {
            // Default to remove when not in Win32
            if (!DDCOMMON.m_oWin32Document){
                return 0;
            }
            if (DDCOMMON.m_oWin32Document.GetContributions().GetCount() > 1) {
                this.m_iIsDocumentAuth = 1;
            }
            else {
                this.m_iIsDocumentAuth = 0;
            }
        }
        return this.m_iIsDocumentAuth;
    };

    /**
     * Debounces mouse actions to ensure that only one mouse action happens after 100ms
     * @param  {Function} callback function to debounce
     */
    CernHoverHandler.prototype.debounceMouseEvent = function(oSourceElement, oTargetElement, callback) {
        if (!callback || !event){
            return;
        }
        var timeout = 100;
        if (this.m_oMouseOnTimer){
            clearTimeout(this.m_oMouseOnTimer);
        }

        this.m_oMouseOnTimer = setTimeout(function(){
            callback(oSourceElement, oTargetElement);
        }, timeout);
    };

    /**
     * Disable showing action images; and clear existing action images
     */
    CernHoverHandler.prototype.disableImages = function () {
        if (this.m_bImagesEnabled) {
            this.m_bImagesEnabled = false;
            removeImages(g_sCLASS_SECTION);
        }
    };


    /**
     * Enable showing action images
     */
    CernHoverHandler.prototype.enableImages =  function() {
        this.m_bImagesEnabled = true;
    };


    /**
     * Resets the document to a blank plain document as if nothing was under a hover
     *
     * Removes the action images, clears the "ddinfocus" class name from all elements
     * and removes and child hover border that was programmatically added.
     */
    CernHoverHandler.prototype.clearFocus =  function () {
        removeChildHoverBorders(this.m_focusCache.getFocusSection());

        // passing in g_sCLASS_SECTION will remove images for a Section and all it's child subsections.
        removeImages(g_sCLASS_SECTION);

        this.m_focusCache.clear();
    };

    /**
     * Handles adjust section image position command
     *
     * This function is used to reposition images after a content update requiring moving images has been made
     */
    CernHoverHandler.prototype.adjustSectionImagePositions = function(){
        for (var index in this.m_focusCache.m_aFocusElementsCache) {
            adjustSectionImagePositions(this.m_focusCache.m_aFocusElementsCache[index]);
        }
    };

    /**
     * Event Handler for the Remove image Click
     *
     * Determines the section which has been selected to be removed by the user and then
     * removes it and all of its children. The Undo log is appended by this action.
     * @param  {HTMLElement} oElement The element whose action image that was clicked
     */
    CernHoverHandler.prototype.removeElement = function(oElement) {
        if (!oElement)
            return;

        // If the element being removed is a Sub Section, need to remove all
        // elements from the inFocus cache except for the Section.
        var bIsSection = DDCOMMON.hasClassName(oElement.className, g_sCLASS_SECTION) || this.isStandaloneSection();
        var isDirty = this.m_oEditor.checkDirty();
        if (bIsSection) {
            this.clearFocus();
        }
        else {
            this.m_focusCache.removeElement(oElement);
            removeImages(oElement.className);
        }

        this.m_oEditor.fire('saveSnapshot');

        var oElementToRemove = oElement;
        var $oElement = $(oElement);

        // If removing the last non-heading TR, remove the whole table.
        if (oElement.tagName.toUpperCase() === g_sTABLE_ROW_TAGNAME) {
            var table = $oElement.closest(g_sTABLE_TAGNAME);
            // Find number of non-heading TRs.  If there are none, remove the entire table.
            // Non-heading TRs are those containing at least one TD.
            var aTrs = table.find(g_sTABLE_ROW_TAGNAME).filter(":visible");
            var iTrCount = aTrs.length;
            aTrs.each(function () {
                if (this === oElement)
                    iTrCount--;
                else if ($(this).find(g_sTABLE_CELL_TAGNAME).length == 0)
                    iTrCount--;
            });

            if (iTrCount == 0) {
                table.remove();
                oElementToRemove = null;    // Don't hide element again later
            }
        }

        var $section = $(oElement).closest('.ddsection');
        if (oElementToRemove) {
            var previousParent = $oElement.parent()[0];
            
            $oElement.remove();
            
            this.m_oEditor.fire('elementRemoved', {
                previousParent: previousParent
            });
        }

        if (!bIsSection) {
            // if section is now empty, just delete it
            if ($section.length && $section.children().length === 0 && $.trim($section.text()) === '')
                $section.remove();
        }
        var selection = this.m_oEditor.getSelection();
        selection && selection.reset();

        // Adjust position of section/subsection images
        for (var index in this.m_focusCache.m_aFocusElementsCache) {
            if (this.m_focusCache.m_aFocusElementsCache.hasOwnProperty(index))
                adjustSectionImagePositions(this.m_focusCache.m_aFocusElementsCache[index]);
        }

        // Since the user clicked the image button, which is outside of the editor, the focus is
        // no longer in the editor.  Put the focus back in the editor so that things like keyboard
        // shortcuts still work.
        try {
            if (CKEDITOR.env.ie && CKEDITOR.env.version < 9)
                this.m_oEditor.editable().$.setActive();
            this.m_oEditor.editable().$.focus();
        }
        catch (e) {
            DocHandleError('Exception when setting focus to the editor:  ' + (e.message || e), 'DynDocCkEditor');
        }

        // Commit the refreshed image to the undo stack.
        this.m_oEditor.fire('saveSnapshot');
    };


    /**
     * Searches the Entire Document and clears all elements with the Infocus and Sibling Tags
     *
     * Calls clearFulldocOfClass which does a Full DOM Walk to find all elements with a specific
     * class name and removes the class name from those elements
     * VERY PROCESSOR INTENSIVE!  USE SPARINGLY!
     */
    CernHoverHandler.prototype.clearBordersAndFocusFullDoc =  function () {
        this.clearFullDocOfClass(g_sCLASS_ACTIONELEMENT);
        this.clearFullDocOfClass(g_sCLASS_INFOCUS);
        this.m_focusCache.clear();
        this.clearFullDocOfClass(g_sCLASS_SIBLING);
        removeImages(g_sCLASS_SECTION);
    };

    /**
     * sets the m_eCheckedReadOnly variable value to 0
     *
     * THIS FUNCTION IS ONLY USED FOR UNIT TESTING PURPOSES NOT TO BE USED ELSEWHERE
     */
    CernHoverHandler.prototype.setCheckedReadOnly = function () {
        // Assertion:  This should never appear in msgviewwin:
        DocHandleError("CernHoverHandler::setCheckedReadOnly, This function was called.", "DynDocCKEditor", "", "");

        this.m_eCheckedReadOnly = 0;
    };

    /**
     * @param {number} iAllow Sets the m_nIsStrikeThroughAllowed
     */
    CernHoverHandler.prototype.setAllowStrike = function (iAllow) {
        this.m_nIsStrikeThroughAllowed = iAllow;
    };


    /**
     * Event Handler function for the IFrames' OnScroll Event.
     * This function is used to handle the OnScroll event fired by the IFRAME.
     */
    CernHoverHandler.prototype.onTextScroll = function () {
        if (!this.m_bDisablePlugin)
            this.clearBordersAndFocusFullDoc();
    };

    /**
     * Static function to ensure image cache is emptied before CKEditor destroyed
     */
    CernHoverHandler.unload = function () {

        window.onresize = null;
        if (null != m_aActionImagesCache) {
            for (var i = 0; i < m_aActionImagesCache.length; i++) {
                var oImage = m_aActionImagesCache[i];
                oImage.onclick = null;
                oImage.ondragstart = null;
                oImage.onmouseover = null;
                oImage.onmouseout = null;
                oImage.setLinkedElement(null);
            }
            m_aActionImagesCache = null;
        }
    };

    /**
     * Handles mouse over events for current instance of editor.  Takes a (mouseon) event.
     * @param  {HTMLEvent} event Mouseover event to handle
     */
    CernHoverHandler.prototype.mouseOverHandler = function (event) {
        var self = this;
        if (!event || !event.data)
            return;

        var onMouseOver = function(oSrcElement, oTargetElement) {
            self.onMouseOver(oSrcElement);
        }
        if (!this.getDisablePlugin()) {
            this.debounceMouseEvent(event.data.$.srcElement, event.data.$.fromElement, onMouseOver);
        }

    };  // End mouseOverHandler


    /**
     * Handles mouse out events for current instance of editor.  Takes a (mouseout) event.
     * @param  {HTMLEvent} event Mouseout event to handle
     */
    CernHoverHandler.prototype.mouseOutHandler = function(event) {
        var self = this;
        if (!event || !event.data)
            return;
        // srcElement - refers to element losing focus
        // toElement - refers to element gaining focus
        var onMouseOut = function(oSrcElement, oTargetElement) {
            self.onMouseOff(oSrcElement, oTargetElement);
        };
        if (!this.getDisablePlugin()) {
            this.debounceMouseEvent(event.data.$.srcElement, event.data.$.toElement, onMouseOut);
        }
    }; // End mouseOutHandler


    /**
     * Handles focusout events for current instance of editor.  Takes a (focusout) event.
     * @param  {HTMLEvent} event Focusout event to handle
     */
    CernHoverHandler.prototype.focusOutHandler = function(event) {
        var self = this;
        if (!event || !event.data)
            return;

        // srcElement - refers to the element losing focus
        // toElement - refers to the element gaining focus
        var onFocusOut = function(oSrcElement, oTargetElement) {
            self.onMouseOff(oSrcElement, oTargetElement);
        };

        if (!this.getDisablePlugin()) {
            this.debounceMouseEvent(event.data.$.srcElement, event.data.$.toElement, onFocusOut);
        }
    }; // End focusOutHandler

    /**
     * Handles attaching events to the current instance of editor.
     *
     * This function is used to attach events to ensure visual updates are
     * performed based on focus changes in the content.  Performed after content
     * has been loaded within the editor.
     */
    CernHoverHandler.prototype.contentDomHandler = function () {
        var self = this;
        var onScroll = function(event) {
            self.onTextScroll(event);
        };
        var onMouseOver = function(event) {
            self.mouseOverHandler(event);
        };
        var onMouseOut = function(event) {
            self.mouseOutHandler(event);
        }
        var onFocusOut = function(event) {
            self.focusOutHandler(event);
        };

        this.m_oEditor.editable().on('scroll', onScroll);

        // Fires when the user moves the mouse over the element you
        // registered the event on or one of its descendants
        this.m_oEditor.editable().on('mouseover', onMouseOver);

        // Fires when the user moves the mouse out of the element you
        // registered the event on or one of its descendants
        this.m_oEditor.editable().on('mouseout', onMouseOut);

        // Fire at the same time as focus and blur
        this.m_oEditor.editable().on('focusout', onFocusOut);

        // Disable action images while user is selecting text.  This prevents the selection
        // from jumping to the end of the document when the user drags the selection over one
        // of the action images.
        var editable = this.m_oEditor.editable();
        this.m_bMouseDown = false;
        editable.on('mousedown', function(event) {
            // If the user scrolls using the scrollbar, mousedown is triggered but not mouseup (why? why? why?).
            // Don't disable images when cursor is in the scrollbar area:
            if (event.data.$.offsetX >= editable.$.clientWidth)
                return;
            // Disable the images (set the m_bMouseDown flag) only if the left mouse button is pressed
            if (event.data.$.button == 0) 
                this.m_bMouseDown = true;
        }, this);
        editable.on('mousemove', function() {
            if (this.m_bMouseDown)
                this.disableImages();
        }, this);
        editable.on('mouseup', function(event) {
            if (event.data.$.button == 0) {
                this.m_bMouseDown = false;
                this.enableImages();
            }
        }, this);

    }; // End contentDomHandler

    /**
     * Handles 'preprocessing' necessary for the content after 'instanceReady' has been fired by the editor
     *
     * This function is used to handle updates needed after editor instance has been created.
     */
    CernHoverHandler.prototype.instanceReadyHandler = function () {

        // Register a filter that will remove all temporary XHTML injected into the document such as the refreshing attribute
        var editor = this.m_oEditor;
        editor.registerXhtmlFilter && editor.registerXhtmlFilter(function(detached) {
            var $detached = $(detached);
            // NOTE: Additional precaution to ensure we DON'T save the dummy image
            // element as part of the document. This should NEVER happen, but if it
            // does, we remove the element before we save.
            $detached.find('.' + g_sDUMMY_IMG_ID).remove();

            // Since we are closing the note, remove contentEditable attribute from the cloned object
            var $ddfreetext = $detached.find('.' + g_sCLASS_FREETEXT);
            $ddfreetext.each(function() {
                // IE7 only:  Remove both contentEditable and contenteditable.  See:
                // http://msdn.microsoft.com/en-us/library/ie/ms536696(v=vs.85).aspx #Remarks
                this.removeAttribute('contentEditable', 1);
                this.removeAttribute('contenteditable', 1);
            });

            // Don't store the refreshing attribute with the HTML.  Not expected to see any here but double checking
            // to prevent it from being ensured.
            var selector = DDCOMMON.createSelector([ g_sCLASS_EMR_CONTENT, g_sCLASS_BLOCK_CN_TEMPLATE, g_sCLASS_BLOCK_SMART_TEMPLATE, g_sCLASS_BLOCK_TOKEN ]);
            // TODO:  Move filter for some of these classes to refresh plugin:
            $detached.find(selector).removeAttr(g_sATTRIBUTE_DROP_TAG).removeAttr(g_sATTRIBUTE_INITIALIZING).removeAttr(g_sATTRIBUTE_REFRESHING).removeAttr(g_sATTRIBUTE_REFRESH_SMART_TEMPLATES).removeAttr(g_sATTRIBUTE_REFRESH_TOKENS).removeAttr(g_sATTRIBUTE_SILENTREFRESH);

            // Remove focus images before saving
            $detached.find('.' + g_sCLASS_INFOCUS).removeClass(g_sCLASS_INFOCUS);
            $detached.find('.' + g_sCLASS_SIBLING).removeClass(g_sCLASS_SIBLING);
            $detached.find('.' + g_sCLASS_ACTIONELEMENT).removeClass(g_sCLASS_ACTIONELEMENT);

        });

        // Ensure styling is updated after undo and redo
        var onUndoRedo = function() {
            editor.execCommand(DDCMD_REMOVEFLOATINGIMGS);
            //Putting focus back to the editor after undo or redo
            editor.focus();
        }
        var undoCmd = editor.getCommand('undo');
        if (undoCmd) {
            undoCmd.on('afterUndo', onUndoRedo);
        }
        var redoCmd = editor.getCommand('redo');
        if (redoCmd) {
            redoCmd.on('afterRedo', onUndoRedo);
        }

    }; // End instanceReadyHandler
    //Exit out of Public Functions
})();

CKEDITOR.plugins.add('cernhover',
{
    lang: 'en,en-gb,de,fr,es,pt-br,en-au',

    requires: 'divarea,cerngetxhtml',

    init: function (editor) {

        // load Event Handler namespace
        if (typeof CernHoverHandler === 'undefined'){
            CKEDITOR.scriptLoader.load(CKEDITOR.getUrl('plugins/cernhover/js/HoverHandler.js'));
        }
        var hoverHandler = new CernHoverHandler(editor);

        var iPref = -1;
        if (typeof CKEDITOR.PreferenceHelper !== 'undefined' && typeof CKEDITOR.PreferenceHelper.Preference !== 'undefined')
            iPref = !(CKEDITOR.PreferenceHelper.Preference("pvNotes.NoStrikeThrough"));

        hoverHandler.setAllowStrike(iPref);

        editor.addCommand(DDCMD_INSERTFREETEXT, {
            editorFocus: false,
            canUndo: true,
            exec: function (editor, oElement) {
                if (!hoverHandler.getDisablePlugin())
                    hoverHandler.insertFreeText(oElement);

                this.fire('afterddinsertfreetext');
            }
        });

        editor.addCommand(DDCMD_UPDATEIMGPOSITION, {
            editorFocus: false,
            canUndo: false,
            exec: function(editor) {
                hoverHandler.adjustSectionImagePositions();
            }
        });

        editor.addCommand(DDCMD_REMOVEELEMENT, {
            editorFocus: false,
            canUndo: false,
            exec: function (editor, oElement) {
                if (!hoverHandler.getDisablePlugin())
                    hoverHandler.removeElement(oElement);
                if (CKEDITOR.env.ie && CKEDITOR.env.version < 9)
                    editor.editable().$.setActive();
                editor.editable().$.focus();

                editor.fire('afterddremovesection');
            }
        });

        editor.addCommand(DDCMD_REMOVEFLOATINGIMGS, {
            editorFocus: false,
            canUndo: false,
            exec: function (editor) {
                hoverHandler.clearBordersAndFocusFullDoc();
            }
        });

        editor.addCommand('disableHover', {
            editorFocus:  false,
            canUndo:  false,
            exec:  function() {
                hoverHandler.setDisablePlugin(true);
            }
        });

        editor.addCommand('enableHover', {
            editorFocus:  false,
            canUndo:  false,
            exec:  function() {
                hoverHandler.setDisablePlugin(false);
            }
        });

        var onContentDom = function(){
             hoverHandler.contentDomHandler();
        };

        var instanceReadyHandler = function(){
            hoverHandler.instanceReadyHandler();
        };

        editor.on('contentDom', onContentDom);
        editor.on('instanceReady', instanceReadyHandler);

        editor.on('refreshingElement', function() {
            hoverHandler.clearBordersAndFocusFullDoc();
        });

        // attach beforeCommandExec to the editor
        editor.on('beforeCommandExec', function(event) {

            if (DDCMD_SAVE == event.data.name ||
                DDCMD_SAVECLOSE == event.data.name ||
                DDCMD_SIGN == event.data.name ||
                DDCMD_DQR == event.data.name ) {

                    // Don't save any ddinfocus/ddsibling classnames, don't try to restore the images/focus after the ensure.
                    editor.execCommand(DDCMD_REMOVEFLOATINGIMGS);
            }
        }); //beforeCommandExec

        editor.registerDirtyFilter && editor.registerDirtyFilter(function(frag) {
            $(frag.firstChild).find('.' + g_sCLASS_INFOCUS).removeClass(g_sCLASS_INFOCUS);
            $(frag.firstChild).find('.' + g_sCLASS_SIBLING).removeClass(g_sCLASS_SIBLING);
            $(frag.firstChild).find('.' + g_sCLASS_ACTIONELEMENT).removeClass(g_sCLASS_ACTIONELEMENT);
        });
    }
});

/******************************************************************************
/ Description: Editor dirty flag plugin
/              Tracks state of editor to determine whether content is dirty (using
/              dirty filters from cerngetxhtml).  Snapshot version of editor can be
/              saved for comparision on dirty check. 
*******************************************************************************/

CKEDITOR.plugins.add('cerndirty',
{
    requires: ['cerngetxhtml'],

    init: function (editor) {
        var m_cachedContentText = null;

        var getSanitizedEditorHtml = function() {
            var editableContentEl = editor.editable().$;
            var innerHtml = editor.cleanContribution(editableContentEl).innerHTML;
            //Use data processor to ensure that html is uniformly sanitized
            var xhtml = editor.dataProcessor.toDataFormat(innerHtml);
            //Ignore line breaks in dirty checking
            var sanitizedXhtml = xhtml.replace(/[\b\f\n\r\t]/gim,"");
            return sanitizedXhtml;
        };

        /**
         * Resets dirty checking to current editor content
         */
        editor.saveEditorSnapshot = function() {
            m_cachedContentText = getSanitizedEditorHtml();
        };

        /**
         * Returns true if the content of the editor is dirty
         * @return {Boolean} [description]
         */
        editor.isEditorDirty = function() {
            var sanitizedHtml = getSanitizedEditorHtml();
            if (sanitizedHtml === m_cachedContentText){
                return false;
            }
            else{
                return true;
            }
        };

        /**
         * Register a filter that will remove a temporary XHTML 'id' injected into the document
         * at the time of checking the document is Dirty or not.
         */	
        editor.registerDirtyFilter(function(frag) {
            $(frag.firstChild).find('.ddemrcontent,.ddemrcontentitem,.blockcntemplate,.blocksmarttemplate,.blocktoken,.ddfreetext,.ddgrouper').each(function () {
                $(this).removeAttr('id');
            });
        });
    }
});

// Testing:
//  * Auto-pop
//  * Tagged labs
//  * Tagged text
//  ** Footnotes
//  * Smart templates
//  ** in ref template
//  ** in auto-text
//  * Token refresh
//  * Checkpoint stuff
//  * Failed to save - out-of-date DOC_COMPs
//  * DQR
//  ** Generate section (delete A&P before Smart Review)

if (!window.PROJECT_NAME)
    window.PROJECT_NAME = 'DynDocCKEditor';

(function() {

    function isValidPlaceholder(element) {
        if (!element)
            return false;

        // Can a span be placed inside of this element?
        var elementDtd = CKEDITOR.dtd[element.tagName.toLowerCase()];
        return !!( elementDtd && elementDtd.span );
    }

    function isDocComp(element) {
        var $element = $(element);
        return $element.attr(g_sATTRIBUTE_CONTENTTYPE) === g_sEMR_CONTENT_TYPE_DOC_COMP;
    }

    function setRefreshingState(editor, newState) {
        var beforeState = editor.refreshState;
        editor.refreshState = newState;
        if (beforeState !== editor.refreshState) {
            editor.fire('refreshStateChange', {
                oldState:   beforeState,
                newState:   editor.refreshState
            });
        }
    }

    /**
     * @private
     *
     * Removes elements that have the same refresh-group-id as the given element
     *
     * @param {jQuery} $element     Element, having a groupId; the others like it will be removed,
     *                              but not the element itself
     * @param {CKEDITOR.editor} editor
     * @param {string}  className   Class name of the elements to be removed
     */
    function removeGroupedElements($element, editor, className) {
        var groupId = $element.data('refresh-group-id');
        if (groupId) {
            var matchesBlockId = function(z, placeholder) {
                return $(placeholder).data('refresh-group-id') === groupId;
            }
            var $grouped = $('.' + className, editor.editable().$).filter(matchesBlockId).not($element);
            $grouped.remove();
        }
    }

    CKEDITOR.plugins.add('cernrefresh', {
        init:  function(editor) {
            var plugin = this;

            editor.pendingRefresh = {};

            editor.refreshState = 'stable';

            editor.isElementRefreshing = function(element) {
                return plugin.isElementRefreshing(this, element);
            }

            //noinspection JSCheckFunctionSignatures
            editor.addCommand(DDCMD_REFRESHELEMENT, {
                // Data params:
                //  * element               The element to refresh
                //  * [success]             Callback to call if the refresh succeeds
                //  * [fail]                Callback to call if the refresh fails
                //  * [type]                'refreshing' or 'initializing'; default to 'refreshing'
                //  * [refreshTemplates]    Whether or not to refresh smart templates and tokens; defaults to true
                //  * [silentRefresh]       Whethor or not to suppress the refresh intent dialog; defaults to false
                //  * [tagIds]              Tag IDs to query for
                //  * [forceSnapshotUpdate] forces snapshots to update rather than saving new ones
                //  * [activityCallback]    Function to call after assigning an activity GUID to a refreshing element
                //  * [currentDtTm]         Date to populate in current_dt_tm field

                editorFocus: false,
                canUndo: false,
                exec:  function(editor, data) {
                    this.refreshElement(editor, data);
                }.bind(this)
            });

            // If the user deletes something that is refreshing, we update our pending list
            editor.on('change', function() {
                for (var id in editor.pendingRefresh) {
                    if (!editor.pendingRefresh.hasOwnProperty(id))
                        continue;

                    if (!document.getElementById(id))  // User removed a refreshing thing
                        this.removePending(editor, id);
                }
            }, this);

            editor.on('beforeSetEmrContent', function(event) {
                var $placeholder = $('#' + event.data.activityId);
                var $contentElement = $(event.data.contentElement);
                if ($placeholder.attr('dd:contenttype') === 'DXORDERS')
                    DDCOMMON.LegacyContentFixers.fixBadDxOrders($contentElement[0]);
            });

            var dirtyFilter = function(frag) {
                $(frag).find('.ddemrcontent,.ddemrcontentitem,.blockcntemplate,.blocksmarttemplate,.blocktoken,.ddfreetext').each(function() {
                    $(this).removeAttr('id');
                    $(this).removeAttr('dd:extractkey');
                });
            };

            if (editor.registerDirtyFilter) {
                editor.registerDirtyFilter(function(frag) {
                    dirtyFilter(frag.firstChild);
                });
            }
        },

        refreshElement:  function(editor, data) {
            var element = data.nodeType ? data : data.element;
            var $element = $(element);
            var $refreshables = $element.is('.ddemrcontent') ? $element : $element.find('.ddemrcontent:not(.ddemrcontent .ddemrcontent)');
            var type = data.type || g_sATTRIBUTE_REFRESHING;
            var refreshTemplates = typeof data.refreshTemplates === 'undefined' ? true : data.refreshTemplates;
            var currentDtTm = data.currentDtTm || new Date();

            // Refresh DOC_COMPs before child EMR content because the refresh intent dialog may show
            $refreshables.sort(function(a, b) { return isDocComp(a) ? -1 : isDocComp(b) ? 1 : 0 });

            var cancelAll = false;      // Whether to cancel all of the remaining refresh

            // Refresh all of them
            $refreshables.each(function(i, refreshable) {
                var bSilent = !!data.silentRefresh;

                var bKontinueRefresh = true; // Whether to continue refreshing this particular element
                var bRecursiveRefresh = false;
                var preRefreshData = $.extend({}, data, {
                    activityId: $element.attr('id'),
                    element:    refreshable,
                    type:       type,
                    stopElementRefresh:  function() { bKontinueRefresh = false },
                    cancel:     function() { cancelAll = true },
                    enableRecursiveRefresh:  function() { bRecursiveRefresh = true }
                });
                editor.fire('preRefreshEmrContent', preRefreshData);

                if (cancelAll)
                    return false;
                if (bKontinueRefresh) {
                    // Refresh linked elements
                    if (data.refreshLinked !== false) {
                        this.refreshLinked(editor, refreshable, {
                            type:           data.type,
                            silentRefresh:  data.silentRefresh,
                            currentDtTm:    currentDtTm,
                            refreshTemplates:   data.refreshTemplates
                        });
                    }
                    if (type !== g_sATTRIBUTE_DROP_TAG && event) {
                        var fnExtractEntityId = function () {
                            var entityId = parseFloat($(this).attr('dd:entityid'));
                            return entityId > 0 ? entityId : null;
                        };

                        var arrExistingIds = $(refreshable).find('.ddtagged.ddemrcontentitem').map(fnExtractEntityId);
                        data.tagIds = arrExistingIds;
                    }
                    
                    // ... then self element
                    return this.refreshEmrContent(editor, refreshable, type, currentDtTm, bSilent, bRecursiveRefresh, data.tagIds || [], data.activityCallback, data.success, data.fail, data.forceSnapshotUpdate);
                }
            }.bind(this));

            if (refreshTemplates && !cancelAll) {
                // Refresh all of the smart templates that are not in ddemrcontent
                var $smartTemplates = $element.is('.blocksmarttemplate') ? $element : $element.find('.blocksmarttemplate');
                $smartTemplates.each(function(i, element) {
                    if (document.body.contains(element))
                        this.refreshSmartTemplate(editor, element, data.success, data.fail);
                }.bind(this));

                if ($element.is('.blockcntemplate')) {
                    this.loadStandardTemplate(editor, element);
                }

                // Refresh all of the tokens that are not in ddemrcontent
                var $textTokens = $element.is('.blocktoken') ? $element : $element.find('.blocktoken');
                $textTokens.each(function(i, element) {
                    if (document.body.contains(element))
                        this.refreshTextToken(editor, element);
                }.bind(this));
            }
        },

        refreshEmrContent:  function(editor, element, type, currentDtTm, bSilent, bRecursiveRefresh, tagIds, activityCallback, successCallback, failCallback, forceSnapshotUpdate) {
            var $element = $(element);
            element = $element[0];
            var sOldHtml = $element.html();

            // Create new activity GUID
            $element.attr('id', CKEDITOR.DocUtilsHelper.GenerateGUID());
            if (activityCallback)
                activityCallback($element[0]);

            var sQueryByFilter = $element.attr('dd:querybyfilter');
            var bQueryByFilter = typeof sQueryByFilter === 'undefined' ? true : DDCOMMON.stringToBoolean(sQueryByFilter);
            var bQueryById = !bQueryByFilter;

            this.setLoading(editor, element, type);

            var req = {
                patient_id:             CKEDITOR.dPatientId,
                encounter_id:           CKEDITOR.dNoteEncounterId || 0.0,
                dd_ref_content_uuid:    $element.attr(g_sATTRIBUTE_REFERENCEUUID),
                user_tz:                CKEDITOR.lUserTimezone,
                workflow_id:            CKEDITOR.dWorkflowId || 0.0,
                workflow_component_concept: $element.attr(g_sATTRIBUTE_CONCEPT),
                ppr_Cd:                 CKEDITOR.dPPRCd,
                query_by_id_ind:        bQueryById ? 1 : 0,
                tagged_ids:             $.map(tagIds, function(id) { return { id: id } }),
                session_id:             CKEDITOR.dSessionId,
                user_id:                CKEDITOR.dUserId,
                chart_encounter_id:     CKEDITOR.dChartEncounterId,
                refreshing_ind: 	    type === g_sATTRIBUTE_DROP_TAG ? 0 : 1,
                workflow_component_concept_cki: $element.attr(g_sATTRIBUTE_CONCEPT_CKI),
                current_dt_tm:          DDCOMMON.convertDateObjectToSrvString(currentDtTm || new Date())
            };
            req = DDCOMMON.valueifyObject(req);

            CKEDITOR.DocUtilsHelper.CallCRMAsync(SERVICE_TASK, 969501, JSON.stringify(req), {
                activityId: $element.attr('id'),
                oldHtml:    sOldHtml,
                complete:  function(reply, obj) {
                    reply = JSON.parse(reply);

                    if (DDCOMMON.isStepSuccessful(reply)) {
                        $.extend(obj, reply);
                        this.setEmrContent(editor, obj, forceSnapshotUpdate);

                        if (bRecursiveRefresh) {
                            $element.find('.blocksmarttemplate,.blocktoken,.ddemrcontent').each(function() {
                                editor.execCommand(DDCMD_REFRESHELEMENT, {
                                    element:  this,
                                    currentDtTm:  currentDtTm   // Use the same current_dt_tm for nested refresh
                                });
                            });
                        }

                        if (successCallback)
                            successCallback(obj.activityId);
                    }
                    else {
                        DocHandleError('Error while loading EMR content:  ' + JSON.stringify(reply && reply.status_data), PROJECT_NAME);

                        if (failCallback)
                            failCallback(obj.activityId);
                        editor.fire('refreshEmrFail', {
                            activityId:  obj.activityId
                        });

                        this.setPlaceholderContent(editor, '#' + obj.activityId, obj.oldHtml || '');
                    }
                }.bind(this),
                callError:  function(obj) {
                    if (failCallback)
                        failCallback(obj.activityId);
                    editor.fire('refreshEmrFail', {
                        activityId:  obj.activityId
                    });

                    this.setPlaceholderContent(editor, '#' + obj.activityId, obj.oldHtml || '');
                }.bind(this)
            });
        },

        refreshTemplate:  function(editor, element, successCallback, failCallback) {
            var $element = $(element);

            var className = $element.hasClass(g_sCLASS_BLOCK_SMART_TEMPLATE) ? g_sCLASS_BLOCK_SMART_TEMPLATE :
                $element.hasClass(g_sCLASS_BLOCK_CN_TEMPLATE) ? g_sCLASS_BLOCK_CN_TEMPLATE : null;

            // Make sure element is a span so that we don't do bad things like leave a <table>
            // placeholder and later populate it with non-tbody things
            if (!isValidPlaceholder($element[0])) {
                var $newPlaceholder = $('<span>').addClass(className).attr({
                    'dd:template_cki':          $element.attr('dd:template_cki'),
                    'data-refresh-group-id':    $element.data('refresh-group-id')
                });
                $newPlaceholder.insertBefore($element);
                $element = $newPlaceholder;
                element = $newPlaceholder[0];
            }

            // Create new activity GUID
            $element.attr('id', CKEDITOR.DocUtilsHelper.GenerateGUID());

            var sTemplateCki = $element.attr(g_sATTRIBUTE_TEMPLATE_CKI);
            if (!sTemplateCki)
                return;

            var req = {
                patient_id: CKEDITOR.dPatientId,
                encntr_id:  CKEDITOR.dNoteEncounterId || 0.0,
                template_cki: sTemplateCki,
                format_cd:  CKEDITOR.DocUtilsHelper.GetCodeValueByMeaning(23, 'HTML')
            };
            req = DDCOMMON.valueifyObject(req);

            this.setLoading(editor, element);
            // Remove grouped template placeholders
            if (className)
                removeGroupedElements($element, editor, className);

            function handleError(obj) {
                this.setPlaceholderContent(editor, '#' + obj.activityId, '');

                if (failCallback)
                    failCallback(obj.activityId);
                editor.fire('refreshTemplateFail', {
                    activityId:  obj.activityId
                });
            }

            CKEDITOR.DocUtilsHelper.CallCRMAsync(SERVICE_TASK, 969555, JSON.stringify(req), {
                activityId:  $element.attr('id'),
                complete:  function(reply, obj) {
                    reply = JSON.parse(reply);
                    if (DDCOMMON.isStepSuccessful(reply)) {
                        $.extend(obj, reply);
                        obj.template_text = CKEDITOR.DocUtilsHelper.CleanHtml(obj.template_text, 1);

                        var $element = $('#' + obj.activityId);
                        if ($element.length === 0) {
                            DocHandleError('refreshTemplate on complete - element not found', PROJECT_NAME);
                            return;
                        }
                        this.setPlaceholderContent(editor, $element, obj.template_text);

                        if (successCallback)
                            successCallback(obj.activityId);
                    }
                    else {
                        handleError.call(this, obj);
                        DocHandleError('Error while loading template:  ' + JSON.stringify(reply && reply.status_data), PROJECT_NAME);
                    }
                }.bind(this),
                callError:  handleError.bind(this)
            });
        },

        refreshSmartTemplate:  function(editor, element, successCallback, failCallback) {
            return this.refreshTemplate(editor, element, successCallback, failCallback);
        },

        loadStandardTemplate:  function(editor, element) {
            return this.refreshTemplate(editor, element);
        },

        refreshTextToken:  function(editor, element) {
            var $element = $(element);

            // Make sure element is a span so that we don't do bad things like leave a <table>
            // placeholder and later populate it with non-tbody things
            if (!isValidPlaceholder($element[0])) {
                var $newPlaceholder = $('<span>').addClass(g_sCLASS_BLOCK_TOKEN).attr({
                    'dd:token_name':            $element.attr('dd:token_name'),
                    'data-refresh-group-id':    $element.data('refresh-group-id')
                });
                $newPlaceholder.insertBefore($element);
                $element = $newPlaceholder;
                element = $newPlaceholder[0];
            }

            // Create new activity GUID
            $element.attr('id', CKEDITOR.DocUtilsHelper.GenerateGUID());

            var sToken = $element.attr(g_sATTRIBUTE_TOKEN);
            if (!sToken)
                return;

            this.setLoading(editor, element);

            // Remove grouped token placeholders
            removeGroupedElements($element, editor, g_sCLASS_BLOCK_TOKEN);

            CKEDITOR.DocUtilsHelper.RefreshTextToken(sToken, CKEDITOR.dPatientId, CKEDITOR.dChartEncounterId, {
                activityId:  $element.attr('id'),
                complete:  function(responseHtml, obj) {
                    var $element = $('#' + obj.activityId);
                    if ($element.length === 0) {
                        DocHandleError('refreshTextToken on complete - element not found', PROJECT_NAME);
                        return;
                    }
                    this.setPlaceholderContent(editor, $element, CKEDITOR.DocUtilsHelper.CleanHtml(responseHtml, 1));
                }.bind(this)
            });
        },

        /**
         * Refresh the elements that are linked using the dd:linkedrefresh attribute
         * @param {CKEDITOR.editor} editor
         * @param {HTMLElement}     refreshable     Elements that have the same link name as `refreshable` will be refreshed
         * @param {Object}          data            Options for DDCMD_REFRESHELEMENT
         */
        refreshLinked:  function(editor, refreshable, data) {
            var linkName = $(refreshable).attr('dd:linkedrefresh');
            if (!linkName)
                return;

            editor.fire('lockSnapshot');

            try {
                var filterLinked = function(j, element) { return $(element).attr('dd:linkedrefresh') === linkName }
                $('.ddemrcontent', editor.editable().$).filter(filterLinked).each(function(z, otherElement) {
                    if (otherElement === refreshable)   // Don't refresh self
                        return;

                    editor.execCommand(DDCMD_REFRESHELEMENT, $.extend({}, data, {
                        element:        otherElement,
                        refreshLinked:  false   // Prevent circular linked refreshes
                    }));
                });
            }
            finally {
                editor.fire('unlockSnapshot');
            }
        },

        /**
         * Sets refresh content into the editor
         * @param {CKEDITOR.editor} editor
         * @param content       Refresh attributes object
         * @fires dynDocContentHTMLLoaded
         */
        setEmrContent:  function(editor, content, forceSnapshotUpdate) {
            var $tmp = $('<div>').html(content.html_text);
            DDCOMMON.removeDuplicateEntities(editor, $tmp);
            
            var $element = $('#' + content.activityId);
            if ($element.length === 0) {
                // Not found - log a message but do not display message dialog
                DocHandleError('setEmrContent - Cannot find element by content guid ' + content.activityId, 'DynDocCKEditor');
                return;
            }
            var bIsContent = $element.is('.ddemrcontent,.blockcntemplate,.blocksmarttemplate,.blocktoken');
            if (!bIsContent) {
                // Is not an EMR content element, text template element, smart template or token element
                DocHandleError('setEmrContent - ' + content.activityId + ' section is not ddemrcontent, blockcntemplate, blocksmarttemplate, or blocktoken.', 'DynDocCKEditor');
                return;
            }

            // If the emr's component entityId is zero, restore the HTML prior to refresh.
            if ((DDCOMMON.getAttributeBoolean($element[0], g_sATTRIBUTE_DROP_TAG) || DDCOMMON.getAttributeBoolean($element[0], g_sATTRIBUTE_REFRESHING)) && isDocComp($element[0])) {
                // Restore content for normal DOC_COMPs (that don't have nested .ddemrcontent)
                var bIsSimpleEmrContent = $tmp.find('.ddemrcontentitem .ddemrcontentitem').length === 0;
                if (bIsSimpleEmrContent) {
                    var fEntityId = parseFloat($tmp.find('.ddemrcontentitem').attr('dd:entityid'));
                    if (fEntityId == 0 && content.oldHtml)
                        $tmp.html(content.oldHtml);
                }
            }

            // Capability timer for refreshing EMR content of A&P when initializing the DD note
            if (DDCOMMON.getAttributeBoolean($element[0], g_sATTRIBUTE_INITIALIZING) && $element.attr('dd:contenttype') === 'DOC_COMP') {
                var $emrContent = $tmp.find('.ddemrcontent');
                if ($emrContent.length) {
                    // Comma separated list of the dd:contenttype, it will truncate if more than 255 char
                    var contentTypes = $emrContent.map(function() {
                        return $(this).attr('dd:contenttype');
                    }).get().join();

                    if (typeof DocUtilsHelper !== 'undefined' && typeof DocUtilsHelper.LogCheckpoint2 !== 'undefined') {
                        CKEDITOR.DocUtilsHelper.LogCheckpoint2(g_sDYNDOC_CKPT_DOC_COMP_REFRESH_WITH_EMRCONTENT, g_sDYNDOC_CKPT_SUBEVENT_CHECK,
                            "DynDocResource", "setEmrContent",
                            "concept_cki: " + $element.attr(g_sATTRIBUTE_CONCEPT_CKI), // Metadata 1
                            "content_type: " + contentTypes, // Metadata 2
                            ""); // Metadata 3
                    }
                }
            }

            // Restore previous non-workflow freetext contents
            var $old = $('<div>').html(content.oldHtml);
            var $oldFreetexts = $old.find('.ddfreetext');

            $oldFreetexts.each(function() {
                var $oldFreetext = $(this);

                // Don't restore HTML for freetext that is marked to be discarded
                if ($oldFreetext[0].getAttribute('dd:discardusertext')) {
                    if ($oldFreetext[0].getAttribute('dd:discardusertext').toLowerCase() === 'true')
                        return;
                }

                // Don't restore HTML for freetext that is for DOC_COMP
                if ($oldFreetext.closest('.ddcomponent,.ddemrcontentitem').is('.ddcomponent') || $element.attr('dd:contenttype') === 'DOC_COMP')
                    return;

                if ($.trim($oldFreetext.html())) {
                    var sEntityId;
                    var bMultipleEmrContentItems = false;
                    // Free text element will be a child of ddemrcontentitem if there is only one EMR content item.
                    // Free text element will be a sibling of ddemrcontentitem if there are multiple EMR content items.
                    // Find the closest ancestor with ddemrcontentitem
                    var $emrContentItem = $oldFreetext.closest('.ddemrcontentitem');
                    // If there is only one ddemrcontentitem, then it means that free text element is a child of ddemrcontentitem element,
                    // so get the entity id of closest ddemrcontentitem element
                    if ($emrContentItem.length === 1) {
                        sEntityId = $emrContentItem.attr(g_sATTRIBUTE_ENTITYID);
                    }
                    else {
                        // Otherwise, free text element is a sibling of ddemrcontentitem, so get the entity id of previous
                        // ddemrcontentitem element
                        sEntityId = $oldFreetext.prev('.ddemrcontentitem').attr(g_sATTRIBUTE_ENTITYID);
                        bMultipleEmrContentItems = true;
                    }

                    if (sEntityId) {
                        var $newFreetexts = $tmp.find('[dd\\:entityid=' + sEntityId + '] .ddfreetext');
                        if ($newFreetexts.length === 0) { // This handles the case where the user typed text then the format was edited to stop emitting the free text area prior to this refresh
                            var $contentWithoutFreetext = $tmp.find('[dd\\:entityid=' + sEntityId + ']');
                            if (bMultipleEmrContentItems) {
                                // If there are multiple EMR content items, add free text element as a
                                // sibling to all other ddemrcontentitems within the grouper element.
                                var $ddgrouper = $contentWithoutFreetext.closest('.ddgrouper');
                                if ($ddgrouper.length) {
                                    editor.execCommand(DDCMD_INSERTFREETEXT, $ddgrouper[0]);
                                    $ddgrouper.find('.ddfreetext').html($oldFreetext.html());
                                }
                                else
                                    DocHandleError('setEmrContent - ddgrouper not found for ddemrcontentitem element', 'DynDocCKEditor');
                            }
                            else {
                                // Otherwise, add free text element as a child element to ddemrcontentitem
                                // element
                                editor.execCommand(DDCMD_INSERTFREETEXT, $contentWithoutFreetext[0]);
                                $contentWithoutFreetext.find('.ddfreetext').html($oldFreetext.html());
                            }
                        }
                        else { // There can possibly be multiple freetext areas in one ddemrcontentitem
                            $newFreetexts.each(function() {
                                var $newFreetext = $(this);
                                // When an ddemrcontentitem has multiple descendent free text areas, each free text area has a unique dd:refreshid value
                                // In older content which doesn't have dd:refreshid, this would be null === null, which is still true
                                if ($newFreetext[0].getAttribute('dd:refreshid') === $oldFreetext[0].getAttribute('dd:refreshid')) {
                                    $newFreetext.html($oldFreetext.html());
                                }
                            });
                        }
                    }
                }
            });

            editor.fire('beforeSetEmrContent', {
                activityId:     content.activityId,
                contentElement: $tmp[0]
            });

            this.setPlaceholderContent(editor, $element, $tmp.html());
            if (content.extract_key)
                $element.attr(g_sATTRIBUTE_EXTRACTKEY, content.extract_key);

            // Assign IDs
            $element.find('.ddemrcontentitem,.blockcntemplate,.blocksmarttemplate,.blocktoken,.ddfreetext').each(function() {
                if (!this.id)
                    this.id = CKEDITOR.DocUtilsHelper.GenerateGUID();
            });

            if (DDCOMMON.getAttributeBoolean($element[0], g_sATTRIBUTE_REFRESH_SMART_TEMPLATES)) {
                // TODO
            }
            if (DDCOMMON.getAttributeBoolean($element[0], g_sATTRIBUTE_REFRESH_TOKENS)) {
                // TODO
            }

            // Remove refreshDocComp classes while taking a snapshot
            var $refreshDocComp = $(editor.editable().$).find('.refreshDocComp');
            $refreshDocComp.removeClass('refreshDocComp');
            editor.fire('updateSnapshot', {overrideFrozen: forceSnapshotUpdate});
            $refreshDocComp.addClass('refreshDocComp');
        },

        /**
         * Puts the element in a loading state
         * @param {CKEDITOR.editor} editor
         * @param {HTMLElement}     element
         * @param {"refreshing"/"initializing"} [type]
         * @fires refreshStateChange
         */
        setLoading: function(editor, element, type) {
            var $img = $('<img>').attr({
                unselectable:  'on',
                src:            CKEDITOR.getUrl('images/loading.gif')
            });
            var $element = $(element);
            $element.empty().append($img);
            $element.attr(type || g_sATTRIBUTE_REFRESHING, 'true');
            $element.parents('[contenteditable=true]').addBack('[contenteditable]').removeAttr('contenteditable');

            editor.pendingRefresh[element.id] = 1;
            setRefreshingState(editor, 'refreshing');
            editor.fire('refreshingElement', {
                activityId:  element.id
            });
        },

        /**
         * Sanitizes HTML content, places it in the element, and performs some book-keeping
         * @param {CKEDITOR.editor} editor
         * @param {HTMLElement/string/jQuery}   element     Element or selector to put content in
         * @param {string}          html    Content to put in the element
         * @fires refreshStateChange
         */
        setPlaceholderContent:  function(editor, element, html) {
            var $element = $(element);
            if ($element.length === 0)
                return;

            $element.html(html);

            // Clean it
            $element.find('title').remove();
            // Remove white-space:pre-wrap from HTML
            DDCOMMON.removeAllPreWrap($element[0]);
            // Remove comment nodes since CKEditor will throw errors when they are found
            // to be the startContainer or endContainer of a range.
            DDCOMMON.removeCommentNodes($element[0]);

            // When getting innerHTML, IE8- adds a trailing space to the end of each line.
            // When the undo plugin restores the snapshot contents, an extra text node is
            // inserted in places where IE had added an extra space.  As a result, the
            // snapshot bookmark indexes become invalid since the DOM tree is different than
            // when the snapshot was taken.  We'll add the spaces pre-emptively so that the
            // first snapshot calculates indexes with them.
            $element.html($element.html());

            $element.removeAttr(g_sATTRIBUTE_INITIALIZING).removeAttr(g_sATTRIBUTE_REFRESHING).removeAttr(g_sATTRIBUTE_DROP_TAG);

            this.removePending(editor, $element.attr('id'));

            // Make ancestor ddfreetext contenteditable if it has no more loading content
            var $freetext = $element.closest('.ddfreetext');
            if (!this.isElementRefreshing(editor, $freetext[0]))
                $freetext.attr('contentEditable', 'true');

            // Make descendent ddfreetext contenteditable
            $element.find('.ddfreetext').addBack('.ddfreetext').attr('contentEditable', 'true').
                // Also, give them IDs
                each(function(i, ddfreetext) {
                    $(ddfreetext).attr('id', CKEDITOR.DocUtilsHelper.GenerateGUID());
                });

            this.fireContentLoaded(editor, $element.attr('id'));

            editor.fire('updateSnapshot', { overrideFrozen: true });
        },

        fireContentLoaded:  function(editor, activityId) {
            editor.fire(DDCMD_CONTENTHTMLLOADED, {
                activityGuids:  [ activityId ],  // Deprecated
                activityId:     activityId,
                items:          [ document.getElementById(activityId) ]   // Deprecated
            });
        },

        removePending:  function(editor, id) {
            delete editor.pendingRefresh[id];

            if (Object.keys(editor.pendingRefresh).length === 0)
                setRefreshingState(editor, 'stable');
        },

        isElementRefreshing:  function(editor, element) {
            if (!element)
                return false;

            if (editor.pendingRefresh[element.id])
                return true;

            for (var id in editor.pendingRefresh) {
                if (!editor.pendingRefresh.hasOwnProperty(id))
                    continue;

                if ($('#' + id).closest(element).length > 0)
                    return true;
            }
            return false;
        }
    });

})();

/**
 * Constant for event name {@link CKEDITOR.editor#dynDocContentHTMLLoaded}
 *
 * @readonly
 * @property DDCMD_CONTENTHTMLLOADED
 */

/** @class CKEDITOR.editor */

/**
 * @readonly
 * @property {string} refreshState
 *
 * Indicates whether the editor is refreshing or not.  Possible values are 'stable' and
 * 'refreshing'
 */

/**
 * @event preRefreshEmrContent
 *
 * Fired prior to data retrieval
 *
 * @param {string}      activityId  The element being refreshed
 * @param {HTMLElement} element     The element being refreshed
 * @param {"refreshing"/"initializing"} type
 * @param {Function}    stopElementRefresh
 *                                  Stops refresh of the current element
 * @param {Function}    cancel      Stops refresh of all remaining elements
 * @param {Function}    enableRecursiveRefresh
 *                                  Causes nested refreshable content to be refreshed after the
 *                                  refresh of the current element completes.
 */

/**
 * @event refreshingElement
 *
 * Fired when refresh of an element begins
 *
 * This is fired after the element has already been set into a refreshing state.
 *
 * @param {string} activityId   The ID of the element that is refreshing
 */

/**
 * @event refreshStateChange

 * Fired when the {@link #refreshState} property changes

 * @param {string} oldState
 * @param {string} newState
 */

/**
 * @event beforeSetEmrContent
 *
 * Fired before setting content into an EMR content placeholder
 *
 * This gives the listener the opportunity to modify the contents that will placed into the
 * placeholder.
 *
 * @param {string}      activityId      The ID of the placeholder element that will be populated
 * @param {HTMLElement} contentElement  An element in a document fragment whose contents will be
 *                                      placed into the placeholder
 */

/**
 * @event dynDocContentHTMLLoaded
 *
 * AKA {@link global#DDCMD_CONTENTHTMLLOADED}.  Fired after replacing a refreshing element's content with new content
 *
 * @param {string} activityId   The ID of the element that was populated
 */

/**
 * @event refreshEmrFail
 *
 * Fired when EMR retrieval fails
 *
 * @param {string} activityId   The ID of the element that failed
 */

/**
 * @event refreshTemplateFail
 *
 * Fired when template load fails
 *
 * @param {string} activityId   The ID of the element that failed
 */

/**
 * @method isElementRefreshing
 * @param {HTMLElement} element
 * @returns {boolean} True if the element or one of its descendents is refreshing
 */

/******************************************************************************
/ Description: Editor dirty flag plugin
/              Tracks state of editor to determine whether content is dirty (using
/              dirty filters from cerngetxhtml).  Snapshot version of editor can be
/              saved for comparision on dirty check. 
*******************************************************************************/

CKEDITOR.plugins.add('mpagedirtyfilters',
{
    requires: ['cerngetxhtml'],

    init: function (editor) {

        editor.addCommand(DDCMD_SANITIZECONTENT,
        {
            editorFocus: false,
            canUndo: false,
            exec: function (editor, oElement) {
                DDCOMMON.removeAllPreWrap(oElement);
                DDCOMMON.removeCommentNodes(oElement);
                this.fire('ddaftersanitizecontent');
            }
        });

        //Addition of dirty filters
        var dirtyFilter = function(frag){
            $(frag).find('.ddfreetext').each(function() {
                $(this).removeAttr('contenteditable');
            });
        };

        if (editor.registerDirtyFilter){
            editor.registerDirtyFilter(function(frag){
                dirtyFilter(frag.firstChild);
            });
        }
    }
});

/**
 * @fileOverview cernzebrastripe plugin puts zebra stripes on tables
 * Tables to be zebra-striped by this plugin should wrap the non-header rows inside <tbody></tbody>
 */
(function(){
    /**
     * Put zebra stripes on a table
     * @param {jQuery} $tableToStripe         Table to put zebra stripes on
     */
    function zebraStripeTable($tableToStripe) {
        var sStripeColor = $tableToStripe.attr('dd:zebrastripecolor');
        var sHeaderColor = $tableToStripe.attr('dd:zebraheadercolor');
        if (sStripeColor) { 
            // Before striping, reset any previously colored rows by removing the bg color
            $tableToStripe.children('tbody').children('tr').css('background-color','');
            $tableToStripe.children('tbody').children('tr').find('.ddfreetext').css('background-color',''); // Also reset the bg color for free text areas
            // There can be nested tables, which may result in nested <tbody>s and <tr>s, so we only select the first level of children
            $tableToStripe.children('tbody').children('tr:odd').css('background-color',sStripeColor);
            $tableToStripe.children('tbody').children('tr:odd').find('.ddfreetext').css('background-color',sStripeColor);
        }
        if (sHeaderColor) {
            // Color <th> instead of <tr>, because there can also be vertical <th>s that are placed in the beginning of each row
            $tableToStripe.find('th').css('background-color', sHeaderColor);
        }
    }

    CKEDITOR.plugins.add('cernzebrastripe', {
        init: function(editor) {
            // Stripe all tables with attribute dd:zebrastripecolor inside the section refreshed
            editor.on(DDCMD_CONTENTHTMLLOADED, function (evt) {
                var $tablesToStripe = $(document.getElementById(evt.data.activityId)).find('table[dd\\:zebrastripecolor]');
                $tablesToStripe.each(function() {
                    var $tableToStripe = $(this);
                    zebraStripeTable($tableToStripe);
                });

                if ($tablesToStripe.length > 0)
                    editor.fire('updateSnapshot', {overrideFrozen:true});
            });

            // Stripe a table when an EMR item is removed from it
            editor.on('elementRemoved', function (evt) {
                var $tableToStripe = $(evt.data.previousParent).closest('table');
                zebraStripeTable($tableToStripe);
            });

            // Stripe tables that are pasted
            editor.on('paste', function(evt) {
                if (evt.data.type === 'html') {
                    var $pasteData = $('<div>').html(evt.data.dataValue);
                    $pasteData.find('table[dd\\:zebrastripecolor]').each(function() {
                        var $tableToStripe = $(this);
                        zebraStripeTable($tableToStripe);
                    });
                    evt.data.dataValue = $pasteData.html();
                }
            }, null, null, 10 );

            // Stripe tables that will be dropped as tagged HTML
            editor.on('droppingTag', function(evt) {
                var $tablesToStripe = evt.data.tagElement.find('table');
                $tablesToStripe.each(function() {
                    var $tableToStripe = $(this);
                    zebraStripeTable($tableToStripe);
                });
            });

            // Stripe tables that are part of the reference template
            // These tables are not in any EMR content sections, but are loaded with the note template
            editor.on('noteLoaded', function(evt) {
                $('table[dd\\:zebrastripecolor]').each(function() {
                    var $tableToStripe = $(this);
                    zebraStripeTable($tableToStripe);
                });
            });
        }
    });
})();

