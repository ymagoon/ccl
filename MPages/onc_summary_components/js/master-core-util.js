/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b="length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){
return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ba=/<([\w:]+)/,ca=/<|&#?\w+;/,da=/<(?:script|style|link)/i,ea=/checked\s*(?:[^=]|=\s*.checked.)/i,fa=/^$|\/(?:java|ecma)script/i,ga=/^true\/(.*)/,ha=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ia={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function ka(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,"script"),g.length>0&&ma(g,!i&&oa(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement("div")),g=(ba.exec(e)||["",""])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),"script"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(aa,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,"script"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),"none"!==c&&c||(qa=(qa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp("^("+Q+")(.*)$","i"),Ba=new RegExp("^([+-])=("+Q+")","i"),Ca={position:"absolute",visibility:"hidden",display:"block"},Da={letterSpacing:"0",fontWeight:"400"},Ea=["Webkit","O","Moz","ms"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Ha(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ia(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?"border":"content"),d,f)+"px"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",ta(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),"normal"===e&&b in Da&&(e=Da[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pa=/queueHooks$/,Qa=[Va],Ra={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||ta(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?ta(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta("show"),slideUp:Ta("hide"),slideToggle:Ta("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),
void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ab," ").indexOf(b)>=0)return!0;return!1}});var bb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cb=n.now(),db=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \t]*([^\r\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\/\//,kb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lb={},mb={},nb="*/".concat("*"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:"GET",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+"").replace(eb,"").replace(jb,pb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pb[3]||("http:"===pb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,"$1_="+cb++):d+(db.test(d)?"&":"?")+"_="+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nb+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&").replace(vb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&"withCredentials"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cb[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fb.pop()||n.expando+"_"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,"$1"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});
/*! jQuery UI - v1.11.4 - 2015-09-28
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, sortable.js, autocomplete.js, datepicker.js, menu.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}function s(e){for(var t,i;e.length&&e[0]!==document;){if(t=e.css("position"),("absolute"===t||"relative"===t||"fixed"===t)&&(i=parseInt(e.css("zIndex"),10),!isNaN(i)&&0!==i))return i;e=e.parent()}return 0}function n(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},e.extend(this._defaults,this.regional[""]),this.regional.en=e.extend(!0,{},this.regional[""]),this.regional["en-US"]=e.extend(!0,{},this.regional.en),this.dpDiv=a(e("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function a(t){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.delegate(i,"mouseout",function(){e(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).removeClass("ui-datepicker-next-hover")}).delegate(i,"mouseover",o)}function o(){e.datepicker._isDisabledDatepicker(d.inline?d.dpDiv.parent()[0]:d.input[0])||(e(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),e(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).addClass("ui-datepicker-next-hover"))}function r(t,i){e.extend(t,i);for(var s in i)null==i[s]&&(t[s]=i[s]);return t}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}};var h=0,l=Array.prototype.slice;e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var i,s,n=l.call(arguments,1),a=0,o=n.length;o>a;a++)for(i in n[a])s=n[a][i],n[a].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(n){var a="string"==typeof n,o=l.call(arguments,1),r=this;return a?this.each(function(){var i,a=e.data(this,s);return"instance"===n?(r=a,!1):a?e.isFunction(a[n])&&"_"!==n.charAt(0)?(i=a[n].apply(a,o),i!==a&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+n+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+n+"'")}):(o.length&&(n=e.widget.extend.apply(null,[n].concat(o))),this.each(function(){var t=e.data(this,s);t?(t.option(n||{}),t._init&&t._init()):e.data(this,s,new i(n,this))})),r}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget;var u=!1;e(document).mouseup(function(){u=!1}),e.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!u){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,n="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),u=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),u=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),function(){function t(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function i(t,i){return parseInt(e.css(t,i),10)||0}function s(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var n,a,o=Math.max,r=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,f=e.fn.position;e.position={scrollbarWidth:function(){if(void 0!==n)return n;var t,i,s=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),a=s.children()[0];return e("body").append(s),t=a.offsetWidth,s.css("overflow","scroll"),i=a.offsetWidth,t===i&&(i=s[0].clientWidth),s.remove(),n=t-i},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),n="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,a="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:a?e.position.scrollbarWidth():0,height:n?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:n,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s||n?i.width():i.outerWidth(),height:s||n?i.height():i.outerHeight()}}},e.fn.position=function(n){if(!n||!n.of)return f.apply(this,arguments);n=e.extend({},n);var p,m,g,v,y,b,_=e(n.of),x=e.position.getWithinInfo(n.within),w=e.position.getScrollInfo(x),k=(n.collision||"flip").split(" "),T={};return b=s(_),_[0].preventDefault&&(n.at="left top"),m=b.width,g=b.height,v=b.offset,y=e.extend({},v),e.each(["my","at"],function(){var e,t,i=(n[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):u.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=u.test(i[1])?i[1]:"center",e=d.exec(i[0]),t=d.exec(i[1]),T[this]=[e?e[0]:0,t?t[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===k.length&&(k[1]=k[0]),"right"===n.at[0]?y.left+=m:"center"===n.at[0]&&(y.left+=m/2),"bottom"===n.at[1]?y.top+=g:"center"===n.at[1]&&(y.top+=g/2),p=t(T.at,m,g),y.left+=p[0],y.top+=p[1],this.each(function(){var s,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),D=d+f+i(this,"marginRight")+w.width,S=c+b+i(this,"marginBottom")+w.height,N=e.extend({},y),M=t(T.my,u.outerWidth(),u.outerHeight());"right"===n.my[0]?N.left-=d:"center"===n.my[0]&&(N.left-=d/2),"bottom"===n.my[1]?N.top-=c:"center"===n.my[1]&&(N.top-=c/2),N.left+=M[0],N.top+=M[1],a||(N.left=h(N.left),N.top=h(N.top)),s={marginLeft:f,marginTop:b},e.each(["left","top"],function(t,i){e.ui.position[k[t]]&&e.ui.position[k[t]][i](N,{targetWidth:m,targetHeight:g,elemWidth:d,elemHeight:c,collisionPosition:s,collisionWidth:D,collisionHeight:S,offset:[p[0]+M[0],p[1]+M[1]],my:n.my,at:n.at,within:x,elem:u})}),n.using&&(l=function(e){var t=v.left-N.left,i=t+m-d,s=v.top-N.top,a=s+g-c,h={target:{element:_,left:v.left,top:v.top,width:m,height:g},element:{element:u,left:N.left,top:N.top,width:d,height:c},horizontal:0>i?"left":t>0?"right":"center",vertical:0>a?"top":s>0?"bottom":"middle"};d>m&&m>r(t+i)&&(h.horizontal="center"),c>g&&g>r(s+a)&&(h.vertical="middle"),h.important=o(r(t),r(i))>o(r(s),r(a))?"horizontal":"vertical",n.using.call(this,e,h)}),u.offset(e.extend(N,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=e.left-t.collisionPosition.marginLeft,h=n-r,l=r+t.collisionWidth-a-n;t.collisionWidth>a?h>0&&0>=l?(i=e.left+h+t.collisionWidth-a-n,e.left+=h-i):e.left=l>0&&0>=h?n:h>l?n+a-t.collisionWidth:n:h>0?e.left+=h:l>0?e.left-=l:e.left=o(e.left-r,e.left)},top:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollTop:s.offset.top,a=t.within.height,r=e.top-t.collisionPosition.marginTop,h=n-r,l=r+t.collisionHeight-a-n;t.collisionHeight>a?h>0&&0>=l?(i=e.top+h+t.collisionHeight-a-n,e.top+=h-i):e.top=l>0&&0>=h?n:h>l?n+a-t.collisionHeight:n:h>0?e.top+=h:l>0?e.top-=l:e.top=o(e.top-r,e.top)}},flip:{left:function(e,t){var i,s,n=t.within,a=n.offset.left+n.scrollLeft,o=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-o-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,f=-2*t.offset[0];0>u?(i=e.left+c+p+f+t.collisionWidth-o-a,(0>i||r(u)>i)&&(e.left+=c+p+f)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+f-h,(s>0||d>r(s))&&(e.left+=c+p+f))},top:function(e,t){var i,s,n=t.within,a=n.offset.top+n.scrollTop,o=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-o-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,f="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,m=-2*t.offset[1];0>u?(s=e.top+p+f+m+t.collisionHeight-o-a,(0>s||r(u)>s)&&(e.top+=p+f+m)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+f+m-h,(i>0||d>r(i))&&(e.top+=p+f+m))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,n,o,r=document.getElementsByTagName("body")[0],h=document.createElement("div");t=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(o in s)t.style[o]=s[o];t.appendChild(h),i=r||document.documentElement,i.insertBefore(t,i.firstChild),h.style.cssText="position: absolute; left: 10.7432222px;",n=e(h).offset().left,a=n>10&&11>n,t.innerHTML="",i.removeChild(t)}()}(),e.ui.position,e.widget("ui.draggable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}
},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,s._parent=i.helper.parent(),a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,b=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>b||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(n=m>=Math.abs(u-b),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||a||o||r,"outer"!==f.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-b),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable,e.widget("ui.sortable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(e,t,i){return e>=t&&t+i>e},_isFloating:function(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))},_create:function(){this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),e.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,i){var s=null,n=!1,a=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,a.widgetName+"-item")===a?(s=e(this),!1):void 0}),e.data(t.target,a.widgetName+"-item")===a&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var n,a,o=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),o.containment&&this._setContainment(),o.cursor&&"auto"!==o.cursor&&(a=this.document.find("body"),this.storedCursor=a.css("cursor"),a.css("cursor",o.cursor),this.storedStylesheet=e("<style>*{ cursor: "+o.cursor+" !important; }</style>").appendTo(a)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,n,a,o=this.options,r=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<o.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+o.scrollSpeed:t.pageY-this.overflowOffset.top<o.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-o.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<o.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+o.scrollSpeed:t.pageX-this.overflowOffset.left<o.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-o.scrollSpeed)):(t.pageY-this.document.scrollTop()<o.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-o.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<o.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+o.scrollSpeed)),t.pageX-this.document.scrollLeft()<o.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-o.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<o.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+o.scrollSpeed))),r!==!1&&e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],a=this._intersectsWithPointer(s),a&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===a?"next":"prev"]()[0]!==n&&!e.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],n):!0)){if(this.direction=1===a?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,n=this.placeholder.offset(),a=this.options.axis,o={};a&&"x"!==a||(o.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),a&&"y"!==a||(o.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,a=e.left,o=a+e.width,r=e.top,h=r+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>r&&h>s+l,c="y"===this.options.axis||t+u>a&&o>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>a&&o>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(e){var t="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top,e.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left,e.width),s=t&&i,n=this._getDragVerticalDirection(),a=this._getDragHorizontalDirection();return s?this.floating?a&&"right"===a||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var t=this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&t||"up"===s&&!t)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){r.push(this)}var s,n,a,o,r=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(a=e(l[s],this.document[0]),n=a.length-1;n>=0;n--)o=e.data(a[n],this.widgetFullName),o&&o!==this&&!o.options.disabled&&h.push([e.isFunction(o.options.items)?o.options.items.call(o.element):e(o.options.items,o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),o]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(r)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,n,a,o,r,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(n=e(c[i],this.document[0]),s=n.length-1;s>=0;s--)a=e.data(n[s],this.widgetFullName),a&&a!==this&&!a.options.disabled&&(d.push([e.isFunction(a.options.items)?a.options.items.call(a.element[0],t,{item:this.currentItem}):e(a.options.items,a.element),a]),this.containers.push(a));for(i=d.length-1;i>=0;i--)for(o=d[i][1],r=d[i][0],s=0,l=r.length;l>s;s++)h=e(r[s]),h.data(this.widgetName+"-item",o),u.push({item:h,instance:o,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,a;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=n.outerWidth(),s.height=n.outerHeight()),a=n.offset(),s.left=a.left,s.top=a.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)a=this.containers[i].element.offset(),this.containers[i].containerCache.left=a.left,this.containers[i].containerCache.top=a.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),n=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tbody"===s?t._createTrPlaceholder(t.currentItem.find("tr").eq(0),e("<tr>",t.document[0]).appendTo(n)):"tr"===s?t._createTrPlaceholder(t.currentItem,n):"img"===s&&n.attr("src",t.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(e,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_createTrPlaceholder:function(t,i){var s=this;t.children().each(function(){e("<td>&#160;</td>",s.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(t){var i,s,n,a,o,r,h,l,u,d,c=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!e.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(c&&e.contains(this.containers[i].element[0],c.element[0]))continue;c=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0);if(c)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,a=null,u=c.floating||this._isFloating(this.currentItem),o=u?"left":"top",r=u?"width":"height",d=u?"clientX":"clientY",s=this.items.length-1;s>=0;s--)e.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[o],l=!1,t[d]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(t[d]-h)&&(n=Math.abs(t[d]-h),a=this.items[s],this.direction=l?"up":"down"));if(!a&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;a?this._rearrange(t,a,null,!0):this._rearrange(t,null,this.containers[p].element,!0),this._trigger("change",t,this._uiHash()),this.containers[p]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.width():this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(t=e(n.containment)[0],i=e(n.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:n.scrollLeft())*s}},_generatePosition:function(t){var i,s,n=this.options,a=t.pageX,o=t.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(a=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(a=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1],o=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((a-this.originalPageX)/n.grid[0])*n.grid[0],a=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&n.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||n.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(n.push(function(e){this._trigger("remove",e,this._uiHash())}),n.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!t){for(s=0;n.length>s;s++)n[s].call(this,e);this._trigger("stop",e,this._uiHash())
}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}}),e.widget("ui.menu",{version:"1.11.4",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},items:"> *",menus:"ul",position:{my:"left-1 top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item":function(e){e.preventDefault()},"click .ui-menu-item":function(t){var i=e(t.target);!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(t):!this.element.is(":focus")&&e(this.document[0].activeElement).closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(t){if(!this.previousFilter){var i=e(t.currentTarget);i.siblings(".ui-state-active").removeClass("ui-state-active"),this.focus(t,i)}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(e,t){var i=this.active||this.element.find(this.options.items).eq(0);t||this.focus(e,i)},blur:function(t){this._delay(function(){e.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(e){this._closeOnDocumentClick(e)&&this.collapseAll(e),this.mouseHandled=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var t=e(this);t.data("ui-menu-submenu-carat")&&t.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(t){var i,s,n,a,o=!0;switch(t.keyCode){case e.ui.keyCode.PAGE_UP:this.previousPage(t);break;case e.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case e.ui.keyCode.HOME:this._move("first","first",t);break;case e.ui.keyCode.END:this._move("last","last",t);break;case e.ui.keyCode.UP:this.previous(t);break;case e.ui.keyCode.DOWN:this.next(t);break;case e.ui.keyCode.LEFT:this.collapse(t);break;case e.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case e.ui.keyCode.ENTER:case e.ui.keyCode.SPACE:this._activate(t);break;case e.ui.keyCode.ESCAPE:this.collapse(t);break;default:o=!1,s=this.previousFilter||"",n=String.fromCharCode(t.keyCode),a=!1,clearTimeout(this.filterTimer),n===s?a=!0:n=s+n,i=this._filterMenuItems(n),i=a&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(t.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(t,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}o&&t.preventDefault()},_activate:function(e){this.active.is(".ui-state-disabled")||(this.active.is("[aria-haspopup='true']")?this.expand(e):this.select(e))},refresh:function(){var t,i,s=this,n=this.options.icons.submenu,a=this.element.find(this.options.menus);this.element.toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length),a.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=e(this),i=t.parent(),s=e("<span>").addClass("ui-menu-icon ui-icon "+n).data("ui-menu-submenu-carat",!0);i.attr("aria-haspopup","true").prepend(s),t.attr("aria-labelledby",i.attr("id"))}),t=a.add(this.element),i=t.find(this.options.items),i.not(".ui-menu-item").each(function(){var t=e(this);s._isDivider(t)&&t.addClass("ui-widget-content ui-menu-divider")}),i.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!e.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(e,t){"icons"===e&&this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(t.submenu),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},focus:function(e,t){var i,s;this.blur(e,e&&"focus"===e.type),this._scrollIntoView(t),this.active=t.first(),s=this.active.addClass("ui-state-focus").removeClass("ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"),e&&"keydown"===e.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=t.children(".ui-menu"),i.length&&e&&/^mouse/.test(e.type)&&this._startOpening(i),this.activeMenu=t.parent(),this._trigger("focus",e,{item:t})},_scrollIntoView:function(t){var i,s,n,a,o,r;this._hasScroll()&&(i=parseFloat(e.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(e.css(this.activeMenu[0],"paddingTop"))||0,n=t.offset().top-this.activeMenu.offset().top-i-s,a=this.activeMenu.scrollTop(),o=this.activeMenu.height(),r=t.outerHeight(),0>n?this.activeMenu.scrollTop(a+n):n+r>o&&this.activeMenu.scrollTop(a+n-o+r))},blur:function(e,t){t||clearTimeout(this.timer),this.active&&(this.active.removeClass("ui-state-focus"),this.active=null,this._trigger("blur",e,{item:this.active}))},_startOpening:function(e){clearTimeout(this.timer),"true"===e.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(e)},this.delay))},_open:function(t){var i=e.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(t,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:e(t&&t.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(t),this.activeMenu=s},this.delay)},_close:function(e){e||(e=this.active?this.active.parent():this.element),e.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active")},_closeOnDocumentClick:function(t){return!e(t.target).closest(".ui-menu").length},_isDivider:function(e){return!/[^\-\u2014\u2013\s]/.test(e.text())},collapse:function(e){var t=this.active&&this.active.parent().closest(".ui-menu-item",this.element);t&&t.length&&(this._close(),this.focus(e,t))},expand:function(e){var t=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();t&&t.length&&(this._open(t.parent()),this._delay(function(){this.focus(e,t)}))},next:function(e){this._move("next","first",e)},previous:function(e){this._move("prev","last",e)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(e,t,i){var s;this.active&&(s="first"===e||"last"===e?this.active["first"===e?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[e+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[t]()),this.focus(i,s)},nextPage:function(t){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=e(this),0>i.offset().top-s-n}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(t),void 0)},previousPage:function(t){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=e(this),i.offset().top-s+n>0}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items).first())),void 0):(this.next(t),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||e(t.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,i)},_filterMenuItems:function(t){var i=t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(e.trim(e(this).text()))})}}),e.widget("ui.autocomplete",{version:"1.11.4",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var t,i,s,n=this.element[0].nodeName.toLowerCase(),a="textarea"===n,o="input"===n;this.isMultiLine=a?!0:o?!1:this.element.prop("isContentEditable"),this.valueMethod=this.element[a||o?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return t=!0,s=!0,i=!0,void 0;t=!1,s=!1,i=!1;var a=e.ui.keyCode;switch(n.keyCode){case a.PAGE_UP:t=!0,this._move("previousPage",n);break;case a.PAGE_DOWN:t=!0,this._move("nextPage",n);break;case a.UP:t=!0,this._keyEvent("previous",n);break;case a.DOWN:t=!0,this._keyEvent("next",n);break;case a.ENTER:this.menu.active&&(t=!0,n.preventDefault(),this.menu.select(n));break;case a.TAB:this.menu.active&&this.menu.select(n);break;case a.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(t)return t=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=e.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(e){return s?(s=!1,e.preventDefault(),void 0):(this._searchTimeout(e),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(e),this._change(e),void 0)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var i=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(s){s.target===t.element[0]||s.target===i||e.contains(i,s.target)||t.close()})})},menufocus:function(t,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",t,{item:n})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&e.trim(s).length&&(this.liveRegion.children().hide(),e("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,t){var i=t.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",e,{item:i})&&this._value(i.value),this.term=this._value(),this.close(e),this.selectedItem=i}}),this.liveRegion=e("<span>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),"source"===e&&this._initSource(),"appendTo"===e&&this.menu.element.appendTo(this._appendTo()),"disabled"===e&&t&&this.xhr&&this.xhr.abort()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_initSource:function(){var t,i,s=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(i,s){s(e.ui.autocomplete.filter(t,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(t,n){s.xhr&&s.xhr.abort(),s.xhr=e.ajax({url:i,data:t,dataType:"json",success:function(e){n(e)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),i=this.menu.element.is(":visible"),s=e.altKey||e.ctrlKey||e.metaKey||e.shiftKey;(!t||t&&!i&&!s)&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){return e=null!=e?e:this._value(),this.term=this._value(),e.length<this.options.minLength?this.close(t):this._trigger("search",t)!==!1?this._search(e):void 0},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var t=++this.requestIndex;return e.proxy(function(e){t===this.requestIndex&&this.__response(e),this.pending--,this.pending||this.element.removeClass("ui-autocomplete-loading")},this)},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return"string"==typeof t?{label:t,value:t}:e.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var i=this.menu.element.empty();this._renderMenu(i,t),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,i){var s=this;e.each(i,function(e,i){s._renderItemData(t,i)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,i){return e("<li>").text(i.label).appendTo(t)},_move:function(e,t){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[e](t),void 0):(this.search(null,t),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(e,t),t.preventDefault())}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,i){var s=RegExp(e.ui.autocomplete.escapeRegex(i),"i");return e.grep(t,function(e){return s.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,this.liveRegion.children().hide(),e("<div>").text(i).appendTo(this.liveRegion))}}),e.ui.autocomplete,e.extend(e.ui,{datepicker:{version:"1.11.4"}});var d;e.extend(n.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(e){return r(this._defaults,e||{}),this},_attachDatepicker:function(t,i){var s,n,a;s=t.nodeName.toLowerCase(),n="div"===s||"span"===s,t.id||(this.uuid+=1,t.id="dp"+this.uuid),a=this._newInst(e(t),n),a.settings=e.extend({},i||{}),"input"===s?this._connectDatepicker(t,a):n&&this._inlineDatepicker(t,a)},_newInst:function(t,i){var s=t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?a(e("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(t,i){var s=e(t);i.append=e([]),i.trigger=e([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp),this._autoSize(i),e.data(t,"datepicker",i),i.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,i){var s,n,a,o=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),o&&(i.append=e("<span class='"+this._appendClass+"'>"+o+"</span>"),t[r?"before":"after"](i.append)),t.unbind("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&t.focus(this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),a=this._get(i,"buttonImage"),i.trigger=e(this._get(i,"buttonImageOnly")?e("<img/>").addClass(this._triggerClass).attr({src:a,alt:n,title:n}):e("<button type='button'></button>").addClass(this._triggerClass).html(a?e("<img/>").attr({src:a,alt:n,title:n}):n)),t[r?"before":"after"](i.trigger),i.trigger.click(function(){return e.datepicker._datepickerShowing&&e.datepicker._lastInput===t[0]?e.datepicker._hideDatepicker():e.datepicker._datepickerShowing&&e.datepicker._lastInput!==t[0]?(e.datepicker._hideDatepicker(),e.datepicker._showDatepicker(t[0])):e.datepicker._showDatepicker(t[0]),!1}))},_autoSize:function(e){if(this._get(e,"autoSize")&&!e.inline){var t,i,s,n,a=new Date(2009,11,20),o=this._get(e,"dateFormat");o.match(/[DM]/)&&(t=function(e){for(i=0,s=0,n=0;e.length>n;n++)e[n].length>i&&(i=e[n].length,s=n);return s},a.setMonth(t(this._get(e,o.match(/MM/)?"monthNames":"monthNamesShort"))),a.setDate(t(this._get(e,o.match(/DD/)?"dayNames":"dayNamesShort"))+20-a.getDay())),e.input.attr("size",this._formatDate(e,a).length)}},_inlineDatepicker:function(t,i){var s=e(t);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),e.data(t,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(t),i.dpDiv.css("display","block"))},_dialogDatepicker:function(t,i,s,n,a){var o,h,l,u,d,c=this._dialogInst;return c||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=e("<input type='text' id='"+o+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.keydown(this._doKeyDown),e("body").append(this._dialogInput),c=this._dialogInst=this._newInst(this._dialogInput,!1),c.settings={},e.data(this._dialogInput[0],"datepicker",c)),r(c.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(c,i):i,this._dialogInput.val(i),this._pos=a?a.length?a:[a.pageX,a.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,u=document.documentElement.scrollLeft||document.body.scrollLeft,d=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+u,l/2-150+d]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),c.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),e.blockUI&&e.blockUI(this.dpDiv),e.data(this._dialogInput[0],"datepicker",c),this},_destroyDatepicker:function(t){var i,s=e(t),n=e.data(t,"datepicker");s.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),e.removeData(t,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),d===n&&(d=null))},_enableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!1,a.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}))},_disableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!0,a.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}),this._disabledInputs[this._disabledInputs.length]=t)},_isDisabledDatepicker:function(e){if(!e)return!1;for(var t=0;this._disabledInputs.length>t;t++)if(this._disabledInputs[t]===e)return!0;return!1},_getInst:function(t){try{return e.data(t,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,i,s){var n,a,o,h,l=this._getInst(t);return 2===arguments.length&&"string"==typeof i?"defaults"===i?e.extend({},e.datepicker._defaults):l?"all"===i?e.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),a=this._getDateDatepicker(t,!0),o=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),r(l.settings,n),null!==o&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,o)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(e(t),l),this._autoSize(l),this._setDate(l,a),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(e,t,i){this._optionDatepicker(e,t,i)},_refreshDatepicker:function(e){var t=this._getInst(e);t&&this._updateDatepicker(t)},_setDateDatepicker:function(e,t){var i=this._getInst(e);i&&(this._setDate(i,t),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(e,t){var i=this._getInst(e);return i&&!i.inline&&this._setDateFromField(i,t),i?this._getDate(i):null},_doKeyDown:function(t){var i,s,n,a=e.datepicker._getInst(t.target),o=!0,r=a.dpDiv.is(".ui-datepicker-rtl");if(a._keyEvent=!0,e.datepicker._datepickerShowing)switch(t.keyCode){case 9:e.datepicker._hideDatepicker(),o=!1;break;case 13:return n=e("td."+e.datepicker._dayOverClass+":not(."+e.datepicker._currentClass+")",a.dpDiv),n[0]&&e.datepicker._selectDay(t.target,a.selectedMonth,a.selectedYear,n[0]),i=e.datepicker._get(a,"onSelect"),i?(s=e.datepicker._formatDate(a),i.apply(a.input?a.input[0]:null,[s,a])):e.datepicker._hideDatepicker(),!1;case 27:e.datepicker._hideDatepicker();break;case 33:e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 34:e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&e.datepicker._clearDate(t.target),o=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&e.datepicker._gotoToday(t.target),o=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?1:-1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,-7,"D"),o=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?-1:1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,7,"D"),o=t.ctrlKey||t.metaKey;break;default:o=!1}else 36===t.keyCode&&t.ctrlKey?e.datepicker._showDatepicker(this):o=!1;o&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var i,s,n=e.datepicker._getInst(t.target);return e.datepicker._get(n,"constrainInput")?(i=e.datepicker._possibleChars(e.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(t){var i,s=e.datepicker._getInst(t.target);if(s.input.val()!==s.lastVal)try{i=e.datepicker.parseDate(e.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,e.datepicker._getFormatConfig(s)),i&&(e.datepicker._setDateFromField(s),e.datepicker._updateAlternate(s),e.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(t){if(t=t.target||t,"input"!==t.nodeName.toLowerCase()&&(t=e("input",t.parentNode)[0]),!e.datepicker._isDisabledDatepicker(t)&&e.datepicker._lastInput!==t){var i,n,a,o,h,l,u;i=e.datepicker._getInst(t),e.datepicker._curInst&&e.datepicker._curInst!==i&&(e.datepicker._curInst.dpDiv.stop(!0,!0),i&&e.datepicker._datepickerShowing&&e.datepicker._hideDatepicker(e.datepicker._curInst.input[0])),n=e.datepicker._get(i,"beforeShow"),a=n?n.apply(t,[t,i]):{},a!==!1&&(r(i.settings,a),i.lastVal=null,e.datepicker._lastInput=t,e.datepicker._setDateFromField(i),e.datepicker._inDialog&&(t.value=""),e.datepicker._pos||(e.datepicker._pos=e.datepicker._findPos(t),e.datepicker._pos[1]+=t.offsetHeight),o=!1,e(t).parents().each(function(){return o|="fixed"===e(this).css("position"),!o}),h={left:e.datepicker._pos[0],top:e.datepicker._pos[1]},e.datepicker._pos=null,i.dpDiv.empty(),i.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),e.datepicker._updateDatepicker(i),h=e.datepicker._checkOffset(i,h,o),i.dpDiv.css({position:e.datepicker._inDialog&&e.blockUI?"static":o?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),i.inline||(l=e.datepicker._get(i,"showAnim"),u=e.datepicker._get(i,"duration"),i.dpDiv.css("z-index",s(e(t))+2),e.datepicker._datepickerShowing=!0,e.effects&&e.effects.effect[l]?i.dpDiv.show(l,e.datepicker._get(i,"showOptions"),u):i.dpDiv[l||"show"](l?u:null),e.datepicker._shouldFocusInput(i)&&i.input.focus(),e.datepicker._curInst=i))}},_updateDatepicker:function(t){this.maxRows=4,d=t,t.dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t);var i,s=this._getNumberOfMonths(t),n=s[1],a=17,r=t.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&t.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),t.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===e.datepicker._curInst&&e.datepicker._datepickerShowing&&e.datepicker._shouldFocusInput(t)&&t.input.focus(),t.yearshtml&&(i=t.yearshtml,setTimeout(function(){i===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml),i=t.yearshtml=null},0))},_shouldFocusInput:function(e){return e.input&&e.input.is(":visible")&&!e.input.is(":disabled")&&!e.input.is(":focus")},_checkOffset:function(t,i,s){var n=t.dpDiv.outerWidth(),a=t.dpDiv.outerHeight(),o=t.input?t.input.outerWidth():0,r=t.input?t.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:e(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:e(document).scrollTop());return i.left-=this._get(t,"isRTL")?n-o:0,i.left-=s&&i.left===t.input.offset().left?e(document).scrollLeft():0,i.top-=s&&i.top===t.input.offset().top+r?e(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+a>l&&l>a?Math.abs(a+r):0),i},_findPos:function(t){for(var i,s=this._getInst(t),n=this._get(s,"isRTL");t&&("hidden"===t.type||1!==t.nodeType||e.expr.filters.hidden(t));)t=t[n?"previousSibling":"nextSibling"];return i=e(t).offset(),[i.left,i.top]},_hideDatepicker:function(t){var i,s,n,a,o=this._curInst;!o||t&&o!==e.data(t,"datepicker")||this._datepickerShowing&&(i=this._get(o,"showAnim"),s=this._get(o,"duration"),n=function(){e.datepicker._tidyDialog(o)},e.effects&&(e.effects.effect[i]||e.effects[i])?o.dpDiv.hide(i,e.datepicker._get(o,"showOptions"),s,n):o.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,a=this._get(o,"onClose"),a&&a.apply(o.input?o.input[0]:null,[o.input?o.input.val():"",o]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),e.blockUI&&(e.unblockUI(),e("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(e){e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(t){if(e.datepicker._curInst){var i=e(t.target),s=e.datepicker._getInst(i[0]);(i[0].id!==e.datepicker._mainDivId&&0===i.parents("#"+e.datepicker._mainDivId).length&&!i.hasClass(e.datepicker.markerClassName)&&!i.closest("."+e.datepicker._triggerClass).length&&e.datepicker._datepickerShowing&&(!e.datepicker._inDialog||!e.blockUI)||i.hasClass(e.datepicker.markerClassName)&&e.datepicker._curInst!==s)&&e.datepicker._hideDatepicker()}},_adjustDate:function(t,i,s){var n=e(t),a=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(a,i+("M"===s?this._get(a,"showCurrentAtPos"):0),s),this._updateDatepicker(a))},_gotoToday:function(t){var i,s=e(t),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)
},_selectMonthYear:function(t,i,s){var n=e(t),a=this._getInst(n[0]);a["selected"+("M"===s?"Month":"Year")]=a["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(a),this._adjustDate(n)},_selectDay:function(t,i,s,n){var a,o=e(t);e(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(o[0])||(a=this._getInst(o[0]),a.selectedDay=a.currentDay=e("a",n).html(),a.selectedMonth=a.currentMonth=i,a.selectedYear=a.currentYear=s,this._selectDate(t,this._formatDate(a,a.currentDay,a.currentMonth,a.currentYear)))},_clearDate:function(t){var i=e(t);this._selectDate(i,"")},_selectDate:function(t,i){var s,n=e(t),a=this._getInst(n[0]);i=null!=i?i:this._formatDate(a),a.input&&a.input.val(i),this._updateAlternate(a),s=this._get(a,"onSelect"),s?s.apply(a.input?a.input[0]:null,[i,a]):a.input&&a.input.trigger("change"),a.inline?this._updateDatepicker(a):(this._hideDatepicker(),this._lastInput=a.input[0],"object"!=typeof a.input[0]&&a.input.focus(),this._lastInput=null)},_updateAlternate:function(t){var i,s,n,a=this._get(t,"altField");a&&(i=this._get(t,"altFormat")||this._get(t,"dateFormat"),s=this._getDate(t),n=this.formatDate(i,s,this._getFormatConfig(t)),e(a).each(function(){e(this).val(n)}))},noWeekends:function(e){var t=e.getDay();return[t>0&&6>t,""]},iso8601Week:function(e){var t,i=new Date(e.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),t=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((t-i)/864e5)/7)+1},parseDate:function(t,i,s){if(null==t||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,a,o,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,u="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),d=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,c=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,m=-1,g=-1,v=-1,y=-1,b=!1,_=function(e){var i=t.length>n+1&&t.charAt(n+1)===e;return i&&n++,i},x=function(e){var t=_(e),s="@"===e?14:"!"===e?20:"y"===e&&t?4:"o"===e?3:2,n="y"===e?s:1,a=RegExp("^\\d{"+n+","+s+"}"),o=i.substring(h).match(a);if(!o)throw"Missing number at position "+h;return h+=o[0].length,parseInt(o[0],10)},w=function(t,s,n){var a=-1,o=e.map(_(t)?n:s,function(e,t){return[[t,e]]}).sort(function(e,t){return-(e[1].length-t[1].length)});if(e.each(o,function(e,t){var s=t[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(a=t[0],h+=s.length,!1):void 0}),-1!==a)return a+1;throw"Unknown name at position "+h},k=function(){if(i.charAt(h)!==t.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;t.length>n;n++)if(b)"'"!==t.charAt(n)||_("'")?k():b=!1;else switch(t.charAt(n)){case"d":v=x("d");break;case"D":w("D",d,c);break;case"o":y=x("o");break;case"m":g=x("m");break;case"M":g=w("M",p,f);break;case"y":m=x("y");break;case"@":r=new Date(x("@")),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"!":r=new Date((x("!")-this._ticksTo1970)/1e4),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"'":_("'")?k():b=!0;break;default:k()}if(i.length>h&&(o=i.substr(h),!/^\s+/.test(o)))throw"Extra/unparsed characters found in date: "+o;if(-1===m?m=(new Date).getFullYear():100>m&&(m+=(new Date).getFullYear()-(new Date).getFullYear()%100+(u>=m?0:-100)),y>-1)for(g=1,v=y;;){if(a=this._getDaysInMonth(m,g-1),a>=v)break;g++,v-=a}if(r=this._daylightSavingAdjust(new Date(m,g-1,v)),r.getFullYear()!==m||r.getMonth()+1!==g||r.getDate()!==v)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(e,t,i){if(!t)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,a=(i?i.dayNames:null)||this._defaults.dayNames,o=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(t){var i=e.length>s+1&&e.charAt(s+1)===t;return i&&s++,i},l=function(e,t,i){var s=""+t;if(h(e))for(;i>s.length;)s="0"+s;return s},u=function(e,t,i,s){return h(e)?s[t]:i[t]},d="",c=!1;if(t)for(s=0;e.length>s;s++)if(c)"'"!==e.charAt(s)||h("'")?d+=e.charAt(s):c=!1;else switch(e.charAt(s)){case"d":d+=l("d",t.getDate(),2);break;case"D":d+=u("D",t.getDay(),n,a);break;case"o":d+=l("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":d+=l("m",t.getMonth()+1,2);break;case"M":d+=u("M",t.getMonth(),o,r);break;case"y":d+=h("y")?t.getFullYear():(10>t.getYear()%100?"0":"")+t.getYear()%100;break;case"@":d+=t.getTime();break;case"!":d+=1e4*t.getTime()+this._ticksTo1970;break;case"'":h("'")?d+="'":c=!0;break;default:d+=e.charAt(s)}return d},_possibleChars:function(e){var t,i="",s=!1,n=function(i){var s=e.length>t+1&&e.charAt(t+1)===i;return s&&t++,s};for(t=0;e.length>t;t++)if(s)"'"!==e.charAt(t)||n("'")?i+=e.charAt(t):s=!1;else switch(e.charAt(t)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=e.charAt(t)}return i},_get:function(e,t){return void 0!==e.settings[t]?e.settings[t]:this._defaults[t]},_setDateFromField:function(e,t){if(e.input.val()!==e.lastVal){var i=this._get(e,"dateFormat"),s=e.lastVal=e.input?e.input.val():null,n=this._getDefaultDate(e),a=n,o=this._getFormatConfig(e);try{a=this.parseDate(i,s,o)||n}catch(r){s=t?"":s}e.selectedDay=a.getDate(),e.drawMonth=e.selectedMonth=a.getMonth(),e.drawYear=e.selectedYear=a.getFullYear(),e.currentDay=s?a.getDate():0,e.currentMonth=s?a.getMonth():0,e.currentYear=s?a.getFullYear():0,this._adjustInstDate(e)}},_getDefaultDate:function(e){return this._restrictMinMax(e,this._determineDate(e,this._get(e,"defaultDate"),new Date))},_determineDate:function(t,i,s){var n=function(e){var t=new Date;return t.setDate(t.getDate()+e),t},a=function(i){try{return e.datepicker.parseDate(e.datepicker._get(t,"dateFormat"),i,e.datepicker._getFormatConfig(t))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?e.datepicker._getDate(t):null)||new Date,a=n.getFullYear(),o=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":o+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o));break;case"y":case"Y":a+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o))}l=h.exec(i)}return new Date(a,o,r)},o=null==i||""===i?s:"string"==typeof i?a(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return o=o&&"Invalid Date"==""+o?s:o,o&&(o.setHours(0),o.setMinutes(0),o.setSeconds(0),o.setMilliseconds(0)),this._daylightSavingAdjust(o)},_daylightSavingAdjust:function(e){return e?(e.setHours(e.getHours()>12?e.getHours()+2:0),e):null},_setDate:function(e,t,i){var s=!t,n=e.selectedMonth,a=e.selectedYear,o=this._restrictMinMax(e,this._determineDate(e,t,new Date));e.selectedDay=e.currentDay=o.getDate(),e.drawMonth=e.selectedMonth=e.currentMonth=o.getMonth(),e.drawYear=e.selectedYear=e.currentYear=o.getFullYear(),n===e.selectedMonth&&a===e.selectedYear||i||this._notifyChange(e),this._adjustInstDate(e),e.input&&e.input.val(s?"":this._formatDate(e))},_getDate:function(e){var t=!e.currentYear||e.input&&""===e.input.val()?null:this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return t},_attachHandlers:function(t){var i=this._get(t,"stepMonths"),s="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){e.datepicker._adjustDate(s,-i,"M")},next:function(){e.datepicker._adjustDate(s,+i,"M")},hide:function(){e.datepicker._hideDatepicker()},today:function(){e.datepicker._gotoToday(s)},selectDay:function(){return e.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return e.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return e.datepicker._selectMonthYear(s,this,"Y"),!1}};e(this).bind(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(e){var t,i,s,n,a,o,r,h,l,u,d,c,p,f,m,g,v,y,b,_,x,w,k,T,D,S,N,M,C,P,A,I,H,z,F,E,W,O,L,j=new Date,R=this._daylightSavingAdjust(new Date(j.getFullYear(),j.getMonth(),j.getDate())),Y=this._get(e,"isRTL"),J=this._get(e,"showButtonPanel"),B=this._get(e,"hideIfNoPrevNext"),K=this._get(e,"navigationAsDateFormat"),U=this._getNumberOfMonths(e),V=this._get(e,"showCurrentAtPos"),q=this._get(e,"stepMonths"),G=1!==U[0]||1!==U[1],X=this._daylightSavingAdjust(e.currentDay?new Date(e.currentYear,e.currentMonth,e.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(e,"min"),$=this._getMinMaxDate(e,"max"),Z=e.drawMonth-V,et=e.drawYear;if(0>Z&&(Z+=12,et--),$)for(t=this._daylightSavingAdjust(new Date($.getFullYear(),$.getMonth()-U[0]*U[1]+1,$.getDate())),t=Q&&Q>t?Q:t;this._daylightSavingAdjust(new Date(et,Z,1))>t;)Z--,0>Z&&(Z=11,et--);for(e.drawMonth=Z,e.drawYear=et,i=this._get(e,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(et,Z-q,1)),this._getFormatConfig(e)):i,s=this._canAdjustMonth(e,-1,et,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":B?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(e,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(et,Z+q,1)),this._getFormatConfig(e)):n,a=this._canAdjustMonth(e,1,et,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":B?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",o=this._get(e,"currentText"),r=this._get(e,"gotoCurrent")&&e.currentDay?X:R,o=K?this.formatDate(o,r,this._getFormatConfig(e)):o,h=e.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(e,"closeText")+"</button>",l=J?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(e,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+o+"</button>":"")+(Y?"":h)+"</div>":"",u=parseInt(this._get(e,"firstDay"),10),u=isNaN(u)?0:u,d=this._get(e,"showWeek"),c=this._get(e,"dayNames"),p=this._get(e,"dayNamesMin"),f=this._get(e,"monthNames"),m=this._get(e,"monthNamesShort"),g=this._get(e,"beforeShowDay"),v=this._get(e,"showOtherMonths"),y=this._get(e,"selectOtherMonths"),b=this._getDefaultDate(e),_="",w=0;U[0]>w;w++){for(k="",this.maxRows=4,T=0;U[1]>T;T++){if(D=this._daylightSavingAdjust(new Date(et,Z,e.selectedDay)),S=" ui-corner-all",N="",G){if(N+="<div class='ui-datepicker-group",U[1]>1)switch(T){case 0:N+=" ui-datepicker-group-first",S=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:N+=" ui-datepicker-group-last",S=" ui-corner-"+(Y?"left":"right");break;default:N+=" ui-datepicker-group-middle",S=""}N+="'>"}for(N+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+S+"'>"+(/all|left/.test(S)&&0===w?Y?a:s:"")+(/all|right/.test(S)&&0===w?Y?s:a:"")+this._generateMonthYearHeader(e,Z,et,Q,$,w>0||T>0,f,m)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",M=d?"<th class='ui-datepicker-week-col'>"+this._get(e,"weekHeader")+"</th>":"",x=0;7>x;x++)C=(x+u)%7,M+="<th scope='col'"+((x+u+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+c[C]+"'>"+p[C]+"</span></th>";for(N+=M+"</tr></thead><tbody>",P=this._getDaysInMonth(et,Z),et===e.selectedYear&&Z===e.selectedMonth&&(e.selectedDay=Math.min(e.selectedDay,P)),A=(this._getFirstDayOfMonth(et,Z)-u+7)%7,I=Math.ceil((A+P)/7),H=G?this.maxRows>I?this.maxRows:I:I,this.maxRows=H,z=this._daylightSavingAdjust(new Date(et,Z,1-A)),F=0;H>F;F++){for(N+="<tr>",E=d?"<td class='ui-datepicker-week-col'>"+this._get(e,"calculateWeek")(z)+"</td>":"",x=0;7>x;x++)W=g?g.apply(e.input?e.input[0]:null,[z]):[!0,""],O=z.getMonth()!==Z,L=O&&!y||!W[0]||Q&&Q>z||$&&z>$,E+="<td class='"+((x+u+6)%7>=5?" ui-datepicker-week-end":"")+(O?" ui-datepicker-other-month":"")+(z.getTime()===D.getTime()&&Z===e.selectedMonth&&e._keyEvent||b.getTime()===z.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(O&&!v?"":" "+W[1]+(z.getTime()===X.getTime()?" "+this._currentClass:"")+(z.getTime()===R.getTime()?" ui-datepicker-today":""))+"'"+(O&&!v||!W[2]?"":" title='"+W[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+z.getMonth()+"' data-year='"+z.getFullYear()+"'")+">"+(O&&!v?"&#xa0;":L?"<span class='ui-state-default'>"+z.getDate()+"</span>":"<a class='ui-state-default"+(z.getTime()===R.getTime()?" ui-state-highlight":"")+(z.getTime()===X.getTime()?" ui-state-active":"")+(O?" ui-priority-secondary":"")+"' href='#'>"+z.getDate()+"</a>")+"</td>",z.setDate(z.getDate()+1),z=this._daylightSavingAdjust(z);N+=E+"</tr>"}Z++,Z>11&&(Z=0,et++),N+="</tbody></table>"+(G?"</div>"+(U[0]>0&&T===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),k+=N}_+=k}return _+=l,e._keyEvent=!1,_},_generateMonthYearHeader:function(e,t,i,s,n,a,o,r){var h,l,u,d,c,p,f,m,g=this._get(e,"changeMonth"),v=this._get(e,"changeYear"),y=this._get(e,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",_="";if(a||!g)_+="<span class='ui-datepicker-month'>"+o[t]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,_+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",u=0;12>u;u++)(!h||u>=s.getMonth())&&(!l||n.getMonth()>=u)&&(_+="<option value='"+u+"'"+(u===t?" selected='selected'":"")+">"+r[u]+"</option>");_+="</select>"}if(y||(b+=_+(!a&&g&&v?"":"&#xa0;")),!e.yearshtml)if(e.yearshtml="",a||!v)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(d=this._get(e,"yearRange").split(":"),c=(new Date).getFullYear(),p=function(e){var t=e.match(/c[+\-].*/)?i+parseInt(e.substring(1),10):e.match(/[+\-].*/)?c+parseInt(e,10):parseInt(e,10);return isNaN(t)?c:t},f=p(d[0]),m=Math.max(f,p(d[1]||"")),f=s?Math.max(f,s.getFullYear()):f,m=n?Math.min(m,n.getFullYear()):m,e.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";m>=f;f++)e.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";e.yearshtml+="</select>",b+=e.yearshtml,e.yearshtml=null}return b+=this._get(e,"yearSuffix"),y&&(b+=(!a&&g&&v?"":"&#xa0;")+_),b+="</div>"},_adjustInstDate:function(e,t,i){var s=e.drawYear+("Y"===i?t:0),n=e.drawMonth+("M"===i?t:0),a=Math.min(e.selectedDay,this._getDaysInMonth(s,n))+("D"===i?t:0),o=this._restrictMinMax(e,this._daylightSavingAdjust(new Date(s,n,a)));e.selectedDay=o.getDate(),e.drawMonth=e.selectedMonth=o.getMonth(),e.drawYear=e.selectedYear=o.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(e)},_restrictMinMax:function(e,t){var i=this._getMinMaxDate(e,"min"),s=this._getMinMaxDate(e,"max"),n=i&&i>t?i:t;return s&&n>s?s:n},_notifyChange:function(e){var t=this._get(e,"onChangeMonthYear");t&&t.apply(e.input?e.input[0]:null,[e.selectedYear,e.selectedMonth+1,e])},_getNumberOfMonths:function(e){var t=this._get(e,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(e,t){return this._determineDate(e,this._get(e,t+"Date"),null)},_getDaysInMonth:function(e,t){return 32-this._daylightSavingAdjust(new Date(e,t,32)).getDate()},_getFirstDayOfMonth:function(e,t){return new Date(e,t,1).getDay()},_canAdjustMonth:function(e,t,i,s){var n=this._getNumberOfMonths(e),a=this._daylightSavingAdjust(new Date(i,s+(0>t?t:n[0]*n[1]),1));return 0>t&&a.setDate(this._getDaysInMonth(a.getFullYear(),a.getMonth())),this._isInRange(e,a)},_isInRange:function(e,t){var i,s,n=this._getMinMaxDate(e,"min"),a=this._getMinMaxDate(e,"max"),o=null,r=null,h=this._get(e,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),o=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(o+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||t.getTime()>=n.getTime())&&(!a||t.getTime()<=a.getTime())&&(!o||t.getFullYear()>=o)&&(!r||r>=t.getFullYear())},_getFormatConfig:function(e){var t=this._get(e,"shortYearCutoff");return t="string"!=typeof t?t:(new Date).getFullYear()%100+parseInt(t,10),{shortYearCutoff:t,dayNamesShort:this._get(e,"dayNamesShort"),dayNames:this._get(e,"dayNames"),monthNamesShort:this._get(e,"monthNamesShort"),monthNames:this._get(e,"monthNames")}},_formatDate:function(e,t,i,s){t||(e.currentDay=e.selectedDay,e.currentMonth=e.selectedMonth,e.currentYear=e.selectedYear);var n=t?"object"==typeof t?t:this._daylightSavingAdjust(new Date(s,i,t)):this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return this.formatDate(this._get(e,"dateFormat"),n,this._getFormatConfig(e))}}),e.fn.datepicker=function(t){if(!this.length)return this;e.datepicker.initialized||(e(document).mousedown(e.datepicker._checkExternalClick),e.datepicker.initialized=!0),0===e("#"+e.datepicker._mainDivId).length&&e("body").append(e.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof t||"isDisabled"!==t&&"getDate"!==t&&"widget"!==t?"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof t?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this].concat(i)):e.datepicker._attachDatepicker(this,t)}):e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i))},e.datepicker=new n,e.datepicker.initialized=!1,e.datepicker.uuid=(new Date).getTime(),e.datepicker.version="1.11.4",e.datepicker});
/*
 * jQuery MultiSelect UI Widget 1.13
 * Copyright (c) 2012 Eric Hynds
 *
 * http://www.erichynds.com/jquery/jquery-ui-multiselect-widget/
 *
 * Depends:
 *   - jQuery 1.4.2+
 *   - jQuery UI 1.8 widget factory
 *
 * Optional:
 *   - jQuery UI effects
 *   - jQuery UI position utility
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 */
(function(d){var k=0;d.widget("ech.multiselect",{options:{header:!0,height:175,minWidth:225,classes:"",checkAllText:"Check all",uncheckAllText:"Uncheck all",noneSelectedText:"Select options",selectedText:"# selected",selectedList:0,show:null,hide:null,autoOpen:!1,multiple:!0,position:{}},_create:function(){var a=this.element.hide(),b=this.options;this.speed=d.fx.speeds._default;this._isOpen=!1;a=(this.button=d('<button type="button"><span class="ui-icon ui-icon-triangle-2-n-s"></span></button>')).addClass("ui-multiselect ui-widget ui-state-default ui-corner-all").addClass(b.classes).attr({title:a.attr("title"),"aria-haspopup":!0,tabIndex:a.attr("tabIndex")}).insertAfter(a);(this.buttonlabel=d("<span />")).html(b.noneSelectedText).appendTo(a);var a=(this.menu=d("<div />")).addClass("ui-multiselect-menu ui-widget ui-widget-content ui-corner-all").addClass(b.classes).appendTo(document.body),c=(this.header=d("<div />")).addClass("ui-widget-header ui-corner-all ui-multiselect-header ui-helper-clearfix").appendTo(a);(this.headerLinkContainer=d("<ul />")).addClass("ui-helper-reset").html(function(){return!0===b.header?'<li><a class="ui-multiselect-all" href="#"><span class="ui-icon ui-icon-check"></span><span>'+b.checkAllText+'</span></a></li><li><a class="ui-multiselect-none" href="#"><span class="ui-icon ui-icon-closethick"></span><span>'+b.uncheckAllText+"</span></a></li>":"string"===typeof b.header?"<li>"+b.header+"</li>":""}).append('<li class="ui-multiselect-close"><a href="#" class="ui-multiselect-close"><span class="ui-icon ui-icon-circle-close"></span></a></li>').appendTo(c);(this.checkboxContainer=d("<ul />")).addClass("ui-multiselect-checkboxes ui-helper-reset").appendTo(a);this._bindEvents();this.refresh(!0);b.multiple||a.addClass("ui-multiselect-single")},_init:function(){!1===this.options.header&&this.header.hide();this.options.multiple||this.headerLinkContainer.find(".ui-multiselect-all, .ui-multiselect-none").hide();this.options.autoOpen&&this.open();this.element.is(":disabled")&&this.disable()},refresh:function(a){var b=this.element,c=this.options,f=this.menu,h=this.checkboxContainer,g=[],e="",i=b.attr("id")||k++;b.find("option").each(function(b){d(this);var a=this.parentNode,f=this.innerHTML,h=this.title,k=this.value,b="ui-multiselect-"+(this.id||i+"-option-"+b),l=this.disabled,n=this.selected,m=["ui-corner-all"],o=(l?"ui-multiselect-disabled ":" ")+this.className,j;"OPTGROUP"===a.tagName&&(j=a.getAttribute("label"),-1===d.inArray(j,g)&&(e+='<li class="ui-multiselect-optgroup-label '+a.className+'"><a href="#">'+j+"</a></li>",g.push(j)));l&&m.push("ui-state-disabled");n&&!c.multiple&&m.push("ui-state-active");e+='<li class="'+o+'">';e+='<label for="'+b+'" title="'+h+'" class="'+m.join(" ")+'">';e+='<input id="'+b+'" name="multiselect_'+i+'" type="'+(c.multiple?"checkbox":"radio")+'" value="'+k+'" title="'+f+'"';n&&(e+=' checked="checked"',e+=' aria-selected="true"');l&&(e+=' disabled="disabled"',e+=' aria-disabled="true"');e+=" /><span>"+f+"</span></label></li>"});h.html(e);this.labels=f.find("label");this.inputs=this.labels.children("input");this._setButtonWidth();this._setMenuWidth();this.button[0].defaultValue=this.update();a||this._trigger("refresh")},update:function(){var a=this.options,b=this.inputs,c=b.filter(":checked"),f=c.length,a=0===f?a.noneSelectedText:d.isFunction(a.selectedText)?a.selectedText.call(this,f,b.length,c.get()):/\d/.test(a.selectedList)&&0<a.selectedList&&f<=a.selectedList?c.map(function(){return d(this).next().html()}).get().join(", "):a.selectedText.replace("#",f).replace("#",b.length);this.buttonlabel.html(a);return a},_bindEvents:function(){function a(){b[b._isOpen? "close":"open"]();return!1}var b=this,c=this.button;c.find("span").bind("click.multiselect",a);c.bind({click:a,keypress:function(a){switch(a.which){case 27:case 38:case 37:b.close();break;case 39:case 40:b.open()}},mouseenter:function(){c.hasClass("ui-state-disabled")||d(this).addClass("ui-state-hover")},mouseleave:function(){d(this).removeClass("ui-state-hover")},focus:function(){c.hasClass("ui-state-disabled")||d(this).addClass("ui-state-focus")},blur:function(){d(this).removeClass("ui-state-focus")}});this.header.delegate("a","click.multiselect",function(a){if(d(this).hasClass("ui-multiselect-close"))b.close();else b[d(this).hasClass("ui-multiselect-all")?"checkAll":"uncheckAll"]();a.preventDefault()});this.menu.delegate("li.ui-multiselect-optgroup-label a","click.multiselect",function(a){a.preventDefault();var c=d(this),g=c.parent().nextUntil("li.ui-multiselect-optgroup-label").find("input:visible:not(:disabled)"),e=g.get(),c=c.parent().text();!1!==b._trigger("beforeoptgrouptoggle",a,{inputs:e,label:c})&&(b._toggleChecked(g.filter(":checked").length!==g.length,g),b._trigger("optgrouptoggle",a,{inputs:e,label:c,checked:e[0].checked}))}).delegate("label","mouseenter.multiselect",function(){d(this).hasClass("ui-state-disabled")||(b.labels.removeClass("ui-state-hover"),d(this).addClass("ui-state-hover").find("input").focus())}).delegate("label","keydown.multiselect",function(a){a.preventDefault();switch(a.which){case 9:case 27:b.close();break;case 38:case 40:case 37:case 39:b._traverse(a.which,this);break;case 13:d(this).find("input")[0].click()}}).delegate('input[type="checkbox"], input[type="radio"]',"click.multiselect",function(a){var c=d(this),g=this.value,e=this.checked,i=b.element.find("option");this.disabled||!1===b._trigger("click",a,{value:g,text:this.title,checked:e})?a.preventDefault():(c.focus(),c.attr("aria-selected",e),i.each(function(){this.value===g?this.selected=e:b.options.multiple||(this.selected=!1)}),b.options.multiple||(b.labels.removeClass("ui-state-active"),c.closest("label").toggleClass("ui-state-active",e),b.close()),b.element.trigger("change"),setTimeout(d.proxy(b.update,b),10))});d(document).bind("mousedown.multiselect",function(a){b._isOpen&&(!d.contains(b.menu[0],a.target)&&!d.contains(b.button[0],a.target)&&a.target!==b.button[0])&&b.close()});d(this.element[0].form).bind("reset.multiselect",function(){setTimeout(d.proxy(b.refresh,b),10)})},_setButtonWidth:function(){var a=this.element.outerWidth(),b=this.options;/\d/.test(b.minWidth)&&a<b.minWidth&&(a=b.minWidth);this.button.width(a)},_setMenuWidth:function(){var a=this.menu,b=this.button.outerWidth()-parseInt(a.css("padding-left"),10)-parseInt(a.css("padding-right"),10)-parseInt(a.css("border-right-width"),10)-parseInt(a.css("border-left-width"),10);a.width(b||this.button.outerWidth())},_traverse:function(a,b){var c=d(b),f=38===a||37===a,c=c.parent()[f?"prevAll":"nextAll"]("li:not(.ui-multiselect-disabled, .ui-multiselect-optgroup-label)")[f?"last":"first"]();c.length?c.find("label").trigger("mouseover"):(c=this.menu.find("ul").last(),this.menu.find("label")[f? "last":"first"]().trigger("mouseover"),c.scrollTop(f?c.height():0))},_toggleState:function(a,b){return function(){this.disabled||(this[a]=b);b?this.setAttribute("aria-selected",!0):this.removeAttribute("aria-selected")}},_toggleChecked:function(a,b){var c=b&&b.length?b:this.inputs,f=this;c.each(this._toggleState("checked",a));c.eq(0).focus();this.update();var h=c.map(function(){return this.value}).get();this.element.find("option").each(function(){!this.disabled&&-1<d.inArray(this.value,h)&&f._toggleState("selected",a).call(this)});c.length&&this.element.trigger("change")},_toggleDisabled:function(a){this.button.attr({disabled:a,"aria-disabled":a})[a?"addClass":"removeClass"]("ui-state-disabled");var b=this.menu.find("input"),b=a?b.filter(":enabled").data("ech-multiselect-disabled",!0):b.filter(function(){return!0===d.data(this,"ech-multiselect-disabled")}).removeData("ech-multiselect-disabled");b.attr({disabled:a,"arial-disabled":a}).parent()[a?"addClass":"removeClass"]("ui-state-disabled");this.element.attr({disabled:a,"aria-disabled":a})},open:function(){var a=this.button,b=this.menu,c=this.speed,f=this.options,h=[];if(!(!1===this._trigger("beforeopen")||a.hasClass("ui-state-disabled")||this._isOpen)){var g=b.find("ul").last(),e=f.show,i=a.offset();d.isArray(f.show)&&(e=f.show[0],c=f.show[1]||this.speed);e&&(h=[e,c]);g.scrollTop(0).height(f.height);d.ui.position&&!d.isEmptyObject(f.position)?(f.position.of=f.position.of||a,b.show().position(f.position).hide()):b.css({top:i.top+a.outerHeight(),left:i.left});d.fn.show.apply(b,h);this.labels.eq(0).trigger("mouseover").trigger("mouseenter").find("input").trigger("focus");a.addClass("ui-state-active");this._isOpen=!0;this._trigger("open")}},close:function(){if(!1!==this._trigger("beforeclose")){var a=this.options,b=a.hide,c=this.speed,f=[];d.isArray(a.hide)&&(b=a.hide[0],c=a.hide[1]||this.speed);b&&(f=[b,c]);d.fn.hide.apply(this.menu,f);this.button.removeClass("ui-state-active").trigger("blur").trigger("mouseleave");this._isOpen=!1;this._trigger("close")}},enable:function(){this._toggleDisabled(!1)},disable:function(){this._toggleDisabled(!0)},checkAll:function(){this._toggleChecked(!0);this._trigger("checkAll")},uncheckAll:function(){this._toggleChecked(!1);this._trigger("uncheckAll")},getChecked:function(){return this.menu.find("input").filter(":checked")},destroy:function(){d.Widget.prototype.destroy.call(this);this.button.remove();this.menu.remove();this.element.show();return this},isOpen:function(){return this._isOpen},widget:function(){return this.menu},getButton:function(){return this.button},_setOption:function(a,b){var c=this.menu;switch(a){case "header":c.find("div.ui-multiselect-header")[b?"show":"hide"]();break;case "checkAllText":c.find("a.ui-multiselect-all span").eq(-1).text(b);break;case "uncheckAllText":c.find("a.ui-multiselect-none span").eq(-1).text(b);break;case "height":c.find("ul").last().height(parseInt(b,10));break;case "minWidth":this.options[a]=parseInt(b,10);this._setButtonWidth();this._setMenuWidth();break;case "selectedText":case "selectedList":case "noneSelectedText":this.options[a]=b;this.update();break;case "classes":c.add(this.button).removeClass(this.options.classes).addClass(b);break;case "multiple":c.toggleClass("ui-multiselect-single",!b),this.options.multiple=b,this.element[0].multiple=b,this.refresh()}d.Widget.prototype._setOption.apply(this,arguments)}})})(jQuery);
/**
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * @author Ariel Flesler
 * @version 2.1.1
 */
;(function(f){"use strict";"function"===typeof define&&define.amd?define(["jquery.scrollTo"],f):"undefined"!==typeof module&&module.exports?module.exports=f(require("jquery.txt")):f(jQuery)})(function($){"use strict";function n(a){return!a.nodeName||-1!==$.inArray(a.nodeName.toLowerCase(),["iframe","#document","html","body"])}function h(a){return $.isFunction(a)||$.isPlainObject(a)?a:{top:a,left:a}}var p=$.scrollTo=function(a,d,b){return $(window).scrollTo(a,d,b)};p.defaults={axis:"xy",duration:0,limit:!0};$.fn.scrollTo=function(a,d,b){"object"=== typeof d&&(b=d,d=0);"function"===typeof b&&(b={onAfter:b});"max"===a&&(a=9E9);b=$.extend({},p.defaults,b);d=d||b.duration;var u=b.queue&&1<b.axis.length;u&&(d/=2);b.offset=h(b.offset);b.over=h(b.over);return this.each(function(){function k(a){var k=$.extend({},b,{queue:!0,duration:d,complete:a&&function(){a.call(q,e,b)}});r.animate(f,k)}if(null!==a){var l=n(this),q=l?this.contentWindow||window:this,r=$(q),e=a,f={},t;switch(typeof e){case "number":case "string":if(/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(e)){e= h(e);break}e=l?$(e):$(e,q);if(!e.length)return;case "object":if(e.is||e.style)t=(e=$(e)).offset()}var v=$.isFunction(b.offset)&&b.offset(q,e)||b.offset;$.each(b.axis.split(""),function(a,c){var d="x"===c?"Left":"Top",m=d.toLowerCase(),g="scroll"+d,h=r[g](),n=p.max(q,c);t?(f[g]=t[m]+(l?0:h-r.offset()[m]),b.margin&&(f[g]-=parseInt(e.css("margin"+d),10)||0,f[g]-=parseInt(e.css("border"+d+"Width"),10)||0),f[g]+=v[m]||0,b.over[m]&&(f[g]+=e["x"===c?"width":"height"]()*b.over[m])):(d=e[m],f[g]=d.slice&& "%"===d.slice(-1)?parseFloat(d)/100*n:d);b.limit&&/^\d+$/.test(f[g])&&(f[g]=0>=f[g]?0:Math.min(f[g],n));!a&&1<b.axis.length&&(h===f[g]?f={}:u&&(k(b.onAfterFirst),f={}))});k(b.onAfter)}})};p.max=function(a,d){var b="x"===d?"Width":"Height",h="scroll"+b;if(!n(a))return a[h]-$(a)[b.toLowerCase()]();var b="client"+b,k=a.ownerDocument||a.document,l=k.documentElement,k=k.body;return Math.max(l[h],k[h])-Math.min(l[b],k[b])};$.Tween.propHooks.scrollLeft=$.Tween.propHooks.scrollTop={get:function(a){return $(a.elem)[a.prop]()}, set:function(a){var d=this.get(a);if(a.options.interrupt&&a._last&&a._last!==d)return $(a.elem).stop();var b=Math.round(a.now);d!==b&&($(a.elem)[a.prop](b),a._last=this.get(a))}};return p});
/**
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT.
 * @author Ariel Flesler
 * @version 1.3.1
 */
;(function($){var f='.serialScroll';var g=$.serialScroll=function(a){return $(window).serialScroll(a)};g.defaults={duration:1000,axis:'x',event:'click',start:0,step:1,lock:true,cycle:true,constant:true};$.fn.serialScroll=function(d){return this.each(function(){var c=$.extend({},g.defaults,d),event=c.event,step=c.step,lazy=c.lazy,context=c.target?this:document,$pane=$(c.target||this,context),pane=$pane[0],items=c.items,active=c.start,auto=c.interval,nav=c.navigation,timer;delete c.step;delete c.start;if(!pane)return;if(!lazy){items=getItems()}if(c.force||auto){jump({},active)}$(c.prev||[],context).bind(event,-step,move);$(c.next||[],context).bind(event,step,move);if(!pane._bound_){$pane.bind('prev'+f,-step,move).bind('next'+f,step,move).bind('goto'+f,jump)}if(auto){$pane.bind('start'+f,function(e){if(!auto){clear();auto=true;next()}}).bind('stop'+f,function(){clear();auto=false})}$pane.bind('notify'+f,function(e,a){var i=index(a);if(i>-1){active=i}});pane._bound_=true;if(c.jump){(lazy?$pane:getItems()).bind(event,function(e){jump(e,index(e.target))})}if(nav){nav=$(nav,context).bind(event,function(e){e.data=Math.round(getItems().length/nav.length)*nav.index(this);jump(e,this)})}function move(e){e.data+=active;jump(e,this)}function jump(e,a){if(!$.isNumeric(a)){a=e.data}var n,real=e.type,$items=c.exclude?getItems().slice(0,-c.exclude):getItems(),limit=$items.length-1,elem=$items[a],duration=c.duration;if(real)e.preventDefault();if(auto){clear();timer=setTimeout(next,c.interval)}if(!elem){n=a<0?0:limit;if(active!==n){a=n}else if(!c.cycle){return}else{a=limit-n}elem=$items[a]}if(!elem||c.lock&&$pane.is(':animated')||real&&c.onBefore&&c.onBefore(e,elem,$pane,getItems(),a)===false)return;if(c.stop){$pane.stop(true)}if(c.constant){duration=Math.abs(duration/step*(active-a))}$pane.scrollTo(elem,duration,c);trigger('notify',a)}function next(){trigger('next')}function clear(){clearTimeout(timer)}function getItems(){return $(items,pane)}function trigger(a){$pane.trigger(a+f,[].slice.call(arguments,1))}function index(a){if($.isNumeric(a)){return a}var b=getItems(),i;while((i=b.index(a))===-1&&a!==pane){a=a.parentNode}return i}})}})(jQuery);
/*!
 * jquery-timepicker v1.8.1 - A jQuery timepicker plugin inspired by Google Calendar. It supports both mouse and keyboard navigation.
 * Copyright (c) 2015 Jon Thornton - http://jonthornton.github.com/jquery-timepicker/
 * License: MIT
 */

!function(a){"object"==typeof exports&&exports&&"object"==typeof module&&module&&module.exports===exports?a(require("jquery.txt")):"function"==typeof define&&define.amd?define(["jquery"],a):a(jQuery)}(function(a){function b(a){var b=a[0];return b.offsetWidth>0&&b.offsetHeight>0}function c(b){if(b.minTime&&(b.minTime=u(b.minTime)),b.maxTime&&(b.maxTime=u(b.maxTime)),b.durationTime&&"function"!=typeof b.durationTime&&(b.durationTime=u(b.durationTime)),"now"==b.scrollDefault)b.scrollDefault=function(){return b.roundingFunction(u(new Date),b)};else if(b.scrollDefault&&"function"!=typeof b.scrollDefault){var c=b.scrollDefault;b.scrollDefault=function(){return b.roundingFunction(u(c),b)}}else b.minTime&&(b.scrollDefault=function(){return b.roundingFunction(b.minTime,b)});if("string"===a.type(b.timeFormat)&&b.timeFormat.match(/[gh]/)&&(b._twelveHourTime=!0),b.showOnFocus===!1&&-1!=b.showOn.indexOf("focus")&&b.showOn.splice(b.showOn.indexOf("focus"),1),b.disableTimeRanges.length>0){for(var d in b.disableTimeRanges)b.disableTimeRanges[d]=[u(b.disableTimeRanges[d][0]),u(b.disableTimeRanges[d][1])];b.disableTimeRanges=b.disableTimeRanges.sort(function(a,b){return a[0]-b[0]});for(var d=b.disableTimeRanges.length-1;d>0;d--)b.disableTimeRanges[d][0]<=b.disableTimeRanges[d-1][1]&&(b.disableTimeRanges[d-1]=[Math.min(b.disableTimeRanges[d][0],b.disableTimeRanges[d-1][0]),Math.max(b.disableTimeRanges[d][1],b.disableTimeRanges[d-1][1])],b.disableTimeRanges.splice(d,1))}return b}function d(b){var c=b.data("timepicker-settings"),d=b.data("timepicker-list");if(d&&d.length&&(d.remove(),b.data("timepicker-list",!1)),c.useSelect){d=a("<select />",{"class":"ui-timepicker-select"});var g=d}else{d=a("<ul />",{"class":"ui-timepicker-list"});var g=a("<div />",{"class":"ui-timepicker-wrapper",tabindex:-1});g.css({display:"none",position:"absolute"}).append(d)}if(c.noneOption)if(c.noneOption===!0&&(c.noneOption=c.useSelect?"Time...":"None"),a.isArray(c.noneOption)){for(var h in c.noneOption)if(parseInt(h,10)==h){var i=e(c.noneOption[h],c.useSelect);d.append(i)}}else{var i=e(c.noneOption,c.useSelect);d.append(i)}if(c.className&&g.addClass(c.className),(null!==c.minTime||null!==c.durationTime)&&c.showDuration){{"function"==typeof c.step?"function":c.step}g.addClass("ui-timepicker-with-duration"),g.addClass("ui-timepicker-step-"+c.step)}var k=c.minTime;"function"==typeof c.durationTime?k=u(c.durationTime()):null!==c.durationTime&&(k=c.durationTime);var m=null!==c.minTime?c.minTime:0,n=null!==c.maxTime?c.maxTime:m+w-1;m>n&&(n+=w),n===w-1&&"string"===a.type(c.timeFormat)&&c.show2400&&(n=w);var p=c.disableTimeRanges,q=0,v=p.length,x=c.step;"function"!=typeof x&&(x=function(){return c.step});for(var h=m,z=0;n>=h;z++,h+=60*x(z)){var A=h,B=t(A,c);if(c.useSelect){var C=a("<option />",{value:B});C.text(B)}else{var C=a("<li />");C.data("time",86400>=A?A:A%86400),C.text(B)}if((null!==c.minTime||null!==c.durationTime)&&c.showDuration){var D=s(h-k,c.step);if(c.useSelect)C.text(C.text()+" ("+D+")");else{var E=a("<span />",{"class":"ui-timepicker-duration"});E.text(" ("+D+")"),C.append(E)}}v>q&&(A>=p[q][1]&&(q+=1),p[q]&&A>=p[q][0]&&A<p[q][1]&&(c.useSelect?C.prop("disabled",!0):C.addClass("ui-timepicker-disabled"))),d.append(C)}if(g.data("timepicker-input",b),b.data("timepicker-list",g),c.useSelect)b.val()&&d.val(f(u(b.val()),c)),d.on("focus",function(){a(this).data("timepicker-input").trigger("showTimepicker")}),d.on("blur",function(){a(this).data("timepicker-input").trigger("hideTimepicker")}),d.on("change",function(){o(b,a(this).val(),"select")}),o(b,d.val(),"initial"),b.hide().after(d);else{var F=c.appendTo;"string"==typeof F?F=a(F):"function"==typeof F&&(F=F(b)),F.append(g),l(b,d),d.on("mousedown","li",function(){b.off("focus.timepicker"),b.on("focus.timepicker-ie-hack",function(){b.off("focus.timepicker-ie-hack"),b.on("focus.timepicker",y.show)}),j(b)||b[0].focus(),d.find("li").removeClass("ui-timepicker-selected"),a(this).addClass("ui-timepicker-selected"),r(b)&&(b.trigger("hideTimepicker"),d.on("mouseup.timepicker","li",function(){d.off("mouseup.timepicker"),g.hide()}))})}}function e(b,c){var d,e,f;return"object"==typeof b?(d=b.label,e=b.className,f=b.value):"string"==typeof b?d=b:a.error("Invalid noneOption value"),c?a("<option />",{value:f,"class":e,text:d}):a("<li />",{"class":e,text:d}).data("time",f)}function f(a,b){return a=b.roundingFunction(a,b),null!==a?t(a,b):void 0}function g(){return new Date(1970,1,1,0,0,0)}function h(b){var c=a(b.target),d=c.closest(".ui-timepicker-input");0===d.length&&0===c.closest(".ui-timepicker-wrapper").length&&(y.hide(),a(document).unbind(".ui-timepicker"),a(window).unbind(".ui-timepicker"))}function j(a){var b=a.data("timepicker-settings");return(window.navigator.msMaxTouchPoints||"ontouchstart"in document)&&b.disableTouchKeyboard}function k(b,c,d){if(!d&&0!==d)return!1;var e=b.data("timepicker-settings"),f=!1,d=e.roundingFunction(d,e);return c.find("li").each(function(b,c){var e=a(c);if("number"==typeof e.data("time"))return e.data("time")==d?(f=e,!1):void 0}),f}function l(a,b){b.find("li").removeClass("ui-timepicker-selected");var c=u(n(a),a.data("timepicker-settings"));if(null!==c){var d=k(a,b,c);if(d){var e=d.offset().top-b.offset().top;(e+d.outerHeight()>b.outerHeight()||0>e)&&b.scrollTop(b.scrollTop()+d.position().top-d.outerHeight()),d.addClass("ui-timepicker-selected")}}}function m(b,c){if(""!==this.value&&"timepicker"!=c){var d=a(this);if(!d.is(":focus")||b&&"change"==b.type){var e=d.data("timepicker-settings"),f=u(this.value,e);if(null===f)return void d.trigger("timeFormatError");var g=!1;null!==e.minTime&&f<e.minTime?g=!0:null!==e.maxTime&&f>e.maxTime&&(g=!0),a.each(e.disableTimeRanges,function(){return f>=this[0]&&f<this[1]?(g=!0,!1):void 0}),e.forceRoundTime&&(f=e.roundingFunction(f,e));var h=t(f,e);g?o(d,h,"error")&&d.trigger("timeRangeError"):o(d,h)}}}function n(a){return a.is("input")?a.val():a.data("ui-timepicker-value")}function o(a,b,c){if(a.is("input")){a.val(b);var d=a.data("timepicker-settings");d.useSelect&&"select"!=c&&"initial"!=c&&a.data("timepicker-list").val(f(u(b),d))}return a.data("ui-timepicker-value")!=b?(a.data("ui-timepicker-value",b),"select"==c?a.trigger("selectTime").trigger("changeTime").trigger("change","timepicker"):"error"!=c&&a.trigger("changeTime"),!0):(a.trigger("selectTime"),!1)}function p(c){var d=a(this),e=d.data("timepicker-list");if(!e||!b(e)){if(40!=c.keyCode)return!0;y.show.call(d.get(0)),e=d.data("timepicker-list"),j(d)||d.focus()}switch(c.keyCode){case 13:return r(d)&&y.hide.apply(this),c.preventDefault(),!1;case 38:var f=e.find(".ui-timepicker-selected");return f.length?f.is(":first-child")||(f.removeClass("ui-timepicker-selected"),f.prev().addClass("ui-timepicker-selected"),f.prev().position().top<f.outerHeight()&&e.scrollTop(e.scrollTop()-f.outerHeight())):(e.find("li").each(function(b,c){return a(c).position().top>0?(f=a(c),!1):void 0}),f.addClass("ui-timepicker-selected")),!1;case 40:return f=e.find(".ui-timepicker-selected"),0===f.length?(e.find("li").each(function(b,c){return a(c).position().top>0?(f=a(c),!1):void 0}),f.addClass("ui-timepicker-selected")):f.is(":last-child")||(f.removeClass("ui-timepicker-selected"),f.next().addClass("ui-timepicker-selected"),f.next().position().top+2*f.outerHeight()>e.outerHeight()&&e.scrollTop(e.scrollTop()+f.outerHeight())),!1;case 27:e.find("li").removeClass("ui-timepicker-selected"),y.hide();break;case 9:y.hide();break;default:return!0}}function q(c){var d=a(this),e=d.data("timepicker-list"),f=d.data("timepicker-settings");if(!e||!b(e)||f.disableTextInput)return!0;switch(c.keyCode){case 96:case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:case 105:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 65:case 77:case 80:case 186:case 8:case 46:f.typeaheadHighlight?l(d,e):e.hide()}}function r(a){var b=a.data("timepicker-settings"),c=a.data("timepicker-list"),d=null,e=c.find(".ui-timepicker-selected");return e.hasClass("ui-timepicker-disabled")?!1:(e.length&&(d=e.data("time")),null!==d&&("string"!=typeof d&&(d=t(d,b)),o(a,d,"select")),!0)}function s(a,b){a=Math.abs(a);var c,d,e=Math.round(a/60),f=[];return 60>e?f=[e,x.mins]:(c=Math.floor(e/60),d=e%60,30==b&&30==d&&(c+=x.decimal+5),f.push(c),f.push(1==c?x.hr:x.hrs),30!=b&&d&&(f.push(d),f.push(x.mins))),f.join(" ")}function t(b,c){if(null===b)return null;var d=new Date(v.valueOf()+1e3*b);if(isNaN(d.getTime()))return null;if("function"===a.type(c.timeFormat))return c.timeFormat(d);for(var e,f,g="",h=0;h<c.timeFormat.length;h++)switch(f=c.timeFormat.charAt(h)){case"a":g+=d.getHours()>11?x.pm:x.am;break;case"A":g+=d.getHours()>11?x.PM:x.AM;break;case"g":e=d.getHours()%12,g+=0===e?"12":e;break;case"G":e=d.getHours(),b===w&&(e=24),g+=e;break;case"h":e=d.getHours()%12,0!==e&&10>e&&(e="0"+e),g+=0===e?"12":e;break;case"H":e=d.getHours(),b===w&&(e=24),g+=e>9?e:"0"+e;break;case"i":var i=d.getMinutes();g+=i>9?i:"0"+i;break;case"s":b=d.getSeconds(),g+=b>9?b:"0"+b;break;case"\\":h++,g+=c.timeFormat.charAt(h);break;default:g+=f}return g}function u(a,b){if(""===a)return null;if(!a||a+0==a)return a;if("object"==typeof a)return 3600*a.getHours()+60*a.getMinutes()+a.getSeconds();a=a.toLowerCase().replace(/[\s\.]/g,""),("a"==a.slice(-1)||"p"==a.slice(-1))&&(a+="m");var c="("+x.am.replace(".","")+"|"+x.pm.replace(".","")+"|"+x.AM.replace(".","")+"|"+x.PM.replace(".","")+")?",d=new RegExp("^"+c+"([0-2]?[0-9])\\W?([0-5][0-9])?\\W?([0-5][0-9])?"+c+"$"),e=a.match(d);if(!e)return null;var f=parseInt(1*e[2],10),g=e[1]||e[5],h=f;if(12>=f&&g){var i=g==x.pm||g==x.PM;h=12==f?i?12:0:f+(i?12:0)}var j=1*e[3]||0,k=1*e[4]||0,l=3600*h+60*j+k;if(!g&&b&&b._twelveHourTime&&b.scrollDefault){var m=l-b.scrollDefault();0>m&&m>=w/-2&&(l=(l+w/2)%w)}return l}var v=g(),w=86400,x={am:"am",pm:"pm",AM:"AM",PM:"PM",decimal:".",mins:"mins",hr:"hr",hrs:"hrs"},y={init:function(b){return this.each(function(){var e=a(this),f=[];for(var g in a.fn.timepicker.defaults)e.data(g)&&(f[g]=e.data(g));var h=a.extend({},a.fn.timepicker.defaults,f,b);if(h.lang&&(x=a.extend(x,h.lang)),h=c(h),e.data("timepicker-settings",h),e.addClass("ui-timepicker-input"),h.useSelect)d(e);else{if(e.prop("autocomplete","off"),h.showOn)for(i in h.showOn)e.on(h.showOn[i]+".timepicker",y.show);e.on("change.timepicker",m),e.on("keydown.timepicker",p),e.on("keyup.timepicker",q),h.disableTextInput&&e.on("keypress.timepicker",function(a){a.preventDefault()}),m.call(e.get(0))}})},show:function(c){var e=a(this),f=e.data("timepicker-settings");if(c&&c.preventDefault(),f.useSelect)return void e.data("timepicker-list").focus();j(e)&&e.blur();var g=e.data("timepicker-list");if(!e.prop("readonly")&&(g&&0!==g.length&&"function"!=typeof f.durationTime||(d(e),g=e.data("timepicker-list")),!b(g))){e.data("ui-timepicker-value",e.val()),l(e,g),y.hide(),g.show();var i={};i.left=f.orientation.match(/r/)?e.offset().left+e.outerWidth()-g.outerWidth()+parseInt(g.css("marginLeft").replace("px",""),10):e.offset().left+parseInt(g.css("marginLeft").replace("px",""),10);var m;m=f.orientation.match(/t/)?"t":f.orientation.match(/b/)?"b":e.offset().top+e.outerHeight(!0)+g.outerHeight()>a(window).height()+a(window).scrollTop()?"t":"b","t"==m?(g.addClass("ui-timepicker-positioned-top"),i.top=e.offset().top-g.outerHeight()+parseInt(g.css("marginTop").replace("px",""),10)):(g.removeClass("ui-timepicker-positioned-top"),i.top=e.offset().top+e.outerHeight()+parseInt(g.css("marginTop").replace("px",""),10)),g.offset(i);var o=g.find(".ui-timepicker-selected");if(o.length||(n(e)?o=k(e,g,u(n(e))):f.scrollDefault&&(o=k(e,g,f.scrollDefault()))),o&&o.length){var p=g.scrollTop()+o.position().top-o.outerHeight();g.scrollTop(p)}else g.scrollTop(0);return f.stopScrollPropagation&&a(document).on("wheel.ui-timepicker",".ui-timepicker-wrapper",function(b){b.preventDefault();var c=a(this).scrollTop();a(this).scrollTop(c+b.originalEvent.deltaY)}),a(document).on("touchstart.ui-timepicker mousedown.ui-timepicker",h),a(window).on("resize.ui-timepicker",h),f.closeOnWindowScroll&&a(document).on("scroll.ui-timepicker",h),e.trigger("showTimepicker"),this}},hide:function(){var c=a(this),d=c.data("timepicker-settings");return d&&d.useSelect&&c.blur(),a(".ui-timepicker-wrapper").each(function(){var c=a(this);if(b(c)){var d=c.data("timepicker-input"),e=d.data("timepicker-settings");e&&e.selectOnBlur&&r(d),c.hide(),d.trigger("hideTimepicker")}}),this},option:function(b,e){return this.each(function(){var f=a(this),g=f.data("timepicker-settings"),h=f.data("timepicker-list");if("object"==typeof b)g=a.extend(g,b);else if("string"==typeof b&&"undefined"!=typeof e)g[b]=e;else if("string"==typeof b)return g[b];g=c(g),f.data("timepicker-settings",g),h&&(h.remove(),f.data("timepicker-list",!1)),g.useSelect&&d(f)})},getSecondsFromMidnight:function(){return u(n(this))},getTime:function(a){var b=this,c=n(b);if(!c)return null;var d=u(c);if(null===d)return null;a||(a=new Date);var e=new Date(a);return e.setHours(d/3600),e.setMinutes(d%3600/60),e.setSeconds(d%60),e.setMilliseconds(0),e},setTime:function(a){var b=this,c=b.data("timepicker-settings");if(c.forceRoundTime)var d=f(u(a),c);else var d=t(u(a),c);return a&&null===d&&c.noneOption&&(d=a),o(b,d),b.data("timepicker-list")&&l(b,b.data("timepicker-list")),this},remove:function(){var a=this;if(a.hasClass("ui-timepicker-input")){var b=a.data("timepicker-settings");return a.removeAttr("autocomplete","off"),a.removeClass("ui-timepicker-input"),a.removeData("timepicker-settings"),a.off(".timepicker"),a.data("timepicker-list")&&a.data("timepicker-list").remove(),b.useSelect&&a.show(),a.removeData("timepicker-list"),this}}};a.fn.timepicker=function(b){return this.length?y[b]?this.hasClass("ui-timepicker-input")?y[b].apply(this,Array.prototype.slice.call(arguments,1)):this:"object"!=typeof b&&b?void a.error("Method "+b+" does not exist on jQuery.timepicker"):y.init.apply(this,arguments):this},a.fn.timepicker.defaults={className:null,minTime:null,maxTime:null,durationTime:null,step:30,showDuration:!1,showOnFocus:!0,showOn:["click","focus"],timeFormat:"g:ia",scrollDefault:null,selectOnBlur:!1,disableTextInput:!1,disableTouchKeyboard:!1,forceRoundTime:!1,roundingFunction:function(a,b){if(null===a)return null;var c=a%(60*b.step);return c>=30*b.step?a+=60*b.step-c:a-=c,a},appendTo:"body",orientation:"l",disableTimeRanges:[],closeOnWindowScroll:!1,typeaheadHighlight:!0,noneOption:!1,show2400:!1,stopScrollPropagation:!1}});
(function(){(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["DE"]={closeText:"Schlieen",prevText:"&#x3C;Zurck",nextText:"Vor&#x3E;",currentText:"Heute",monthNames:["Januar","Februar","Mrz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthNamesShort:["Jan","Feb","Mr","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],dayNames:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],dayNamesShort:["So","Mo","Di","Mi","Do","Fr","Sa"],dayNamesMin:["So","Mo","Di","Mi","Do","Fr","Sa"],weekHeader:"KW",dateFormat:"dd.mm.yy",firstDay:1,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["DE"]});(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["EN_AU"]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"dd/mm/yy",firstDay:1,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["EN_AU"]});(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["EN_GB"]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"dd/mm/yy",firstDay:1,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["EN_GB"]});(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["ES"]={closeText:"Cerrar",prevText:"&#x3C;Ant",nextText:"Sig&#x3E;",currentText:"Hoy",monthNames:["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"],monthNamesShort:["ene","feb","mar","abr","may","jun","jul","ago","sep","oct","nov","dic"],dayNames:["domingo","lunes","martes","mircoles","jueves","viernes","sbado"],dayNamesShort:["dom","lun","mar","mi","jue","vie","sb"],dayNamesMin:["D","L","M","X","J","V","S"],weekHeader:"Sm",dateFormat:"dd/mm/yy",firstDay:1,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["ES"]});(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["FR"]={closeText:"Fermer",prevText:"Prcdent",nextText:"Suivant",currentText:"Aujourd'hui",monthNames:["janvier","fvrier","mars","avril","mai","juin","juillet","aot","septembre","octobre","novembre","dcembre"],monthNamesShort:["janv.","fvr.","mars","avr.","mai","juin","juil.","aot","sept.","oct.","nov.","dc."],dayNames:["dimanche","lundi","mardi","mercredi","jeudi","vendredi","samedi"],dayNamesShort:["dim.","lun.","mar.","mer.","jeu.","ven.","sam."],dayNamesMin:["D","L","M","M","J","V","S"],weekHeader:"Sem.",dateFormat:"dd/mm/yy",firstDay:1,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["FR"]});(function(factory){if(typeof define==="function"&&define.amd){define(["../datepicker"],factory)}else{factory(jQuery.datepicker)}})(function(datepicker){datepicker.regional["PT_BR"]={closeText:"Fechar",prevText:"&#x3C;Anterior",nextText:"Prximo&#x3E;",currentText:"Hoje",monthNames:["Janeiro","Fevereiro","Maro","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthNamesShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],dayNames:["Domingo","Segunda-feira","Tera-feira","Quarta-feira","Quinta-feira","Sexta-feira","Sbado"],dayNamesShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sb"],dayNamesMin:["Dom","Seg","Ter","Qua","Qui","Sex","Sb"],weekHeader:"Sm",dateFormat:"dd/mm/yy",firstDay:0,isRTL:false,showMonthAfterYear:false,yearSuffix:""};return datepicker.regional["PT_BR"]})})();
/*

Tooltipster 3.3.0 | 2014-11-08
A rockin' custom tooltip jQuery plugin

Developed by Caleb Jacob under the MIT license http://opensource.org/licenses/MIT

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

/* Tooltipster v3.3.0 */;(function(e,t,n){function s(t,n){this.bodyOverflowX;this.callbacks={hide:[],show:[]};this.checkInterval=null;this.Content;this.$el=e(t);this.$elProxy;this.elProxyPosition;this.enabled=true;this.options=e.extend({},i,n);this.mouseIsOverProxy=false;this.namespace="tooltipster-"+Math.round(Math.random()*1e5);this.Status="hidden";this.timerHide=null;this.timerShow=null;this.$tooltip;this.options.iconTheme=this.options.iconTheme.replace(".","");this.options.theme=this.options.theme.replace(".","");this._init()}function o(t,n){var r=true;e.each(t,function(e,i){if(typeof n[e]==="undefined"||t[e]!==n[e]){r=false;return false}});return r}function f(){return!a&&u}function l(){var e=n.body||n.documentElement,t=e.style,r="transition";if(typeof t[r]=="string"){return true}v=["Moz","Webkit","Khtml","O","ms"],r=r.charAt(0).toUpperCase()+r.substr(1);for(var i=0;i<v.length;i++){if(typeof t[v[i]+r]=="string"){return true}}return false}var r="tooltipster",i={animation:"fade",arrow:true,arrowColor:"",autoClose:true,content:null,contentAsHTML:false,contentCloning:true,debug:true,delay:200,minWidth:0,maxWidth:null,functionInit:function(e,t){},functionBefore:function(e,t){t()},functionReady:function(e,t){},functionAfter:function(e){},hideOnClick:false,icon:"(?)",iconCloning:true,iconDesktop:false,iconTouch:false,iconTheme:"tooltipster-icon",interactive:false,interactiveTolerance:350,multiple:false,offsetX:0,offsetY:0,onlyOne:false,position:"top",positionTracker:false,positionTrackerCallback:function(e){if(this.option("trigger")=="hover"&&this.option("autoClose")){this.hide()}},restoration:"current",speed:350,timer:0,theme:"tooltipster-default",touchDevices:true,trigger:"hover",updateAnimation:true};s.prototype={_init:function(){var t=this;if(n.querySelector){var r=null;if(t.$el.data("tooltipster-initialTitle")===undefined){r=t.$el.attr("title");if(r===undefined)r=null;t.$el.data("tooltipster-initialTitle",r)}if(t.options.content!==null){t._content_set(t.options.content)}else{t._content_set(r)}var i=t.options.functionInit.call(t.$el,t.$el,t.Content);if(typeof i!=="undefined")t._content_set(i);t.$el.removeAttr("title").addClass("tooltipstered");if(!u&&t.options.iconDesktop||u&&t.options.iconTouch){if(typeof t.options.icon==="string"){t.$elProxy=e('<span class="'+t.options.iconTheme+'"></span>');t.$elProxy.text(t.options.icon)}else{if(t.options.iconCloning)t.$elProxy=t.options.icon.clone(true);else t.$elProxy=t.options.icon}t.$elProxy.insertAfter(t.$el)}else{t.$elProxy=t.$el}if(t.options.trigger=="hover"){t.$elProxy.on("mouseenter."+t.namespace,function(){if(!f()||t.options.touchDevices){t.mouseIsOverProxy=true;t._show()}}).on("mouseleave."+t.namespace,function(){if(!f()||t.options.touchDevices){t.mouseIsOverProxy=false}});if(u&&t.options.touchDevices){t.$elProxy.on("touchstart."+t.namespace,function(){t._showNow()})}}else if(t.options.trigger=="click"){t.$elProxy.on("click."+t.namespace,function(){if(!f()||t.options.touchDevices){t._show()}})}}},_show:function(){var e=this;if(e.Status!="shown"&&e.Status!="appearing"){if(e.options.delay){e.timerShow=setTimeout(function(){if(e.options.trigger=="click"||e.options.trigger=="hover"&&e.mouseIsOverProxy){e._showNow()}},e.options.delay)}else e._showNow()}},_showNow:function(n){var r=this;r.options.functionBefore.call(r.$el,r.$el,function(){if(r.enabled&&r.Content!==null){if(n)r.callbacks.show.push(n);r.callbacks.hide=[];clearTimeout(r.timerShow);r.timerShow=null;clearTimeout(r.timerHide);r.timerHide=null;if(r.options.onlyOne){e(".tooltipstered").not(r.$el).each(function(t,n){var r=e(n),i=r.data("tooltipster-ns");e.each(i,function(e,t){var n=r.data(t),i=n.status(),s=n.option("autoClose");if(i!=="hidden"&&i!=="disappearing"&&s){n.hide()}})})}var i=function(){r.Status="shown";e.each(r.callbacks.show,function(e,t){t.call(r.$el)});r.callbacks.show=[]};if(r.Status!=="hidden"){var s=0;if(r.Status==="disappearing"){r.Status="appearing";if(l()){r.$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-"+r.options.animation+"-show");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i)}else{r.$tooltip.stop().fadeIn(i)}}else if(r.Status==="shown"){i()}}else{r.Status="appearing";var s=r.options.speed;r.bodyOverflowX=e("body").css("overflow-x");e("body").css("overflow-x","hidden");var o="tooltipster-"+r.options.animation,a="-webkit-transition-duration: "+r.options.speed+"ms; -webkit-animation-duration: "+r.options.speed+"ms; -moz-transition-duration: "+r.options.speed+"ms; -moz-animation-duration: "+r.options.speed+"ms; -o-transition-duration: "+r.options.speed+"ms; -o-animation-duration: "+r.options.speed+"ms; -ms-transition-duration: "+r.options.speed+"ms; -ms-animation-duration: "+r.options.speed+"ms; transition-duration: "+r.options.speed+"ms; animation-duration: "+r.options.speed+"ms;",f=r.options.minWidth?"min-width:"+Math.round(r.options.minWidth)+"px;":"",c=r.options.maxWidth?"max-width:"+Math.round(r.options.maxWidth)+"px;":"",h=r.options.interactive?"pointer-events: auto;":"";r.$tooltip=e('<div class="tooltipster-base '+r.options.theme+'" style="'+f+" "+c+" "+h+" "+a+'"><div class="tooltipster-content"></div></div>');if(l())r.$tooltip.addClass(o);r._content_insert();r.$tooltip.appendTo("body");r.reposition();r.options.functionReady.call(r.$el,r.$el,r.$tooltip);if(l()){r.$tooltip.addClass(o+"-show");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i)}else{r.$tooltip.css("display","none").fadeIn(r.options.speed,i)}r._interval_set();e(t).on("scroll."+r.namespace+" resize."+r.namespace,function(){r.reposition()});if(r.options.autoClose){e("body").off("."+r.namespace);if(r.options.trigger=="hover"){if(u){setTimeout(function(){e("body").on("touchstart."+r.namespace,function(){r.hide()})},0)}if(r.options.interactive){if(u){r.$tooltip.on("touchstart."+r.namespace,function(e){e.stopPropagation()})}var p=null;r.$elProxy.add(r.$tooltip).on("mouseleave."+r.namespace+"-autoClose",function(){clearTimeout(p);p=setTimeout(function(){r.hide()},r.options.interactiveTolerance)}).on("mouseenter."+r.namespace+"-autoClose",function(){clearTimeout(p)})}else{r.$elProxy.on("mouseleave."+r.namespace+"-autoClose",function(){r.hide()})}if(r.options.hideOnClick){r.$elProxy.on("click."+r.namespace+"-autoClose",function(){r.hide()})}}else if(r.options.trigger=="click"){setTimeout(function(){e("body").on("click."+r.namespace+" touchstart."+r.namespace,function(){r.hide()})},0);if(r.options.interactive){r.$tooltip.on("click."+r.namespace+" touchstart."+r.namespace,function(e){e.stopPropagation()})}}}}if(r.options.timer>0){r.timerHide=setTimeout(function(){r.timerHide=null;r.hide()},r.options.timer+s)}}})},_interval_set:function(){var t=this;t.checkInterval=setInterval(function(){if(e("body").find(t.$el).length===0||e("body").find(t.$elProxy).length===0||t.Status=="hidden"||e("body").find(t.$tooltip).length===0){if(t.Status=="shown"||t.Status=="appearing")t.hide();t._interval_cancel()}else{if(t.options.positionTracker){var n=t._repositionInfo(t.$elProxy),r=false;if(o(n.dimension,t.elProxyPosition.dimension)){if(t.$elProxy.css("position")==="fixed"){if(o(n.position,t.elProxyPosition.position))r=true}else{if(o(n.offset,t.elProxyPosition.offset))r=true}}if(!r){t.reposition();t.options.positionTrackerCallback.call(t,t.$el)}}}},200)},_interval_cancel:function(){clearInterval(this.checkInterval);this.checkInterval=null},_content_set:function(e){if(typeof e==="object"&&e!==null&&this.options.contentCloning){e=e.clone(true)}this.Content=e},_content_insert:function(){var e=this,t=this.$tooltip.find(".tooltipster-content");if(typeof e.Content==="string"&&!e.options.contentAsHTML){t.text(e.Content)}else{t.empty().append(e.Content)}},_update:function(e){var t=this;t._content_set(e);if(t.Content!==null){if(t.Status!=="hidden"){t._content_insert();t.reposition();if(t.options.updateAnimation){if(l()){t.$tooltip.css({width:"","-webkit-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-moz-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-o-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-ms-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms",transition:"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms"}).addClass("tooltipster-content-changing");setTimeout(function(){if(t.Status!="hidden"){t.$tooltip.removeClass("tooltipster-content-changing");setTimeout(function(){if(t.Status!=="hidden"){t.$tooltip.css({"-webkit-transition":t.options.speed+"ms","-moz-transition":t.options.speed+"ms","-o-transition":t.options.speed+"ms","-ms-transition":t.options.speed+"ms",transition:t.options.speed+"ms"})}},t.options.speed)}},t.options.speed)}else{t.$tooltip.fadeTo(t.options.speed,.5,function(){if(t.Status!="hidden"){t.$tooltip.fadeTo(t.options.speed,1)}})}}}}else{t.hide()}},_repositionInfo:function(e){return{dimension:{height:e.outerHeight(false),width:e.outerWidth(false)},offset:e.offset(),position:{left:parseInt(e.css("left")),top:parseInt(e.css("top"))}}},hide:function(n){var r=this;if(n)r.callbacks.hide.push(n);r.callbacks.show=[];clearTimeout(r.timerShow);r.timerShow=null;clearTimeout(r.timerHide);r.timerHide=null;var i=function(){e.each(r.callbacks.hide,function(e,t){t.call(r.$el)});r.callbacks.hide=[]};if(r.Status=="shown"||r.Status=="appearing"){r.Status="disappearing";var s=function(){r.Status="hidden";if(typeof r.Content=="object"&&r.Content!==null){r.Content.detach()}r.$tooltip.remove();r.$tooltip=null;e(t).off("."+r.namespace);e("body").off("."+r.namespace).css("overflow-x",r.bodyOverflowX);e("body").off("."+r.namespace);r.$elProxy.off("."+r.namespace+"-autoClose");r.options.functionAfter.call(r.$el,r.$el);i()};if(l()){r.$tooltip.clearQueue().removeClass("tooltipster-"+r.options.animation+"-show").addClass("tooltipster-dying");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(s)}else{r.$tooltip.stop().fadeOut(r.options.speed,s)}}else if(r.Status=="hidden"){i()}return r},show:function(e){this._showNow(e);return this},update:function(e){return this.content(e)},content:function(e){if(typeof e==="undefined"){return this.Content}else{this._update(e);return this}},reposition:function(){var n=this;if(e("body").find(n.$tooltip).length!==0){n.$tooltip.css("width","");n.elProxyPosition=n._repositionInfo(n.$elProxy);var r=null,i=e(t).width(),s=n.elProxyPosition,o=n.$tooltip.outerWidth(false),u=n.$tooltip.innerWidth()+1,a=n.$tooltip.outerHeight(false);if(n.$elProxy.is("area")){var f=n.$elProxy.attr("shape"),l=n.$elProxy.parent().attr("name"),c=e('img[usemap="#'+l+'"]'),h=c.offset().left,p=c.offset().top,d=n.$elProxy.attr("coords")!==undefined?n.$elProxy.attr("coords").split(","):undefined;if(f=="circle"){var v=parseInt(d[0]),m=parseInt(d[1]),g=parseInt(d[2]);s.dimension.height=g*2;s.dimension.width=g*2;s.offset.top=p+m-g;s.offset.left=h+v-g}else if(f=="rect"){var v=parseInt(d[0]),m=parseInt(d[1]),y=parseInt(d[2]),b=parseInt(d[3]);s.dimension.height=b-m;s.dimension.width=y-v;s.offset.top=p+m;s.offset.left=h+v}else if(f=="poly"){var w=[],E=[],S=0,x=0,T=0,N=0,C="even";for(var k=0;k<d.length;k++){var L=parseInt(d[k]);if(C=="even"){if(L>T){T=L;if(k===0){S=T}}if(L<S){S=L}C="odd"}else{if(L>N){N=L;if(k==1){x=N}}if(L<x){x=L}C="even"}}s.dimension.height=N-x;s.dimension.width=T-S;s.offset.top=p+x;s.offset.left=h+S}else{s.dimension.height=c.outerHeight(false);s.dimension.width=c.outerWidth(false);s.offset.top=p;s.offset.left=h}}var A=0,O=0,M=0,_=parseInt(n.options.offsetY),D=parseInt(n.options.offsetX),P=n.options.position;function H(){var n=e(t).scrollLeft();if(A-n<0){r=A-n;A=n}if(A+o-n>i){r=A-(i+n-o);A=i+n-o}}function B(n,r){if(s.offset.top-e(t).scrollTop()-a-_-12<0&&r.indexOf("top")>-1){P=n}if(s.offset.top+s.dimension.height+a+12+_>e(t).scrollTop()+e(t).height()&&r.indexOf("bottom")>-1){P=n;M=s.offset.top-a-_-12}}if(P=="top"){var j=s.offset.left+o-(s.offset.left+s.dimension.width);A=s.offset.left+D-j/2;M=s.offset.top-a-_-12;H();B("bottom","top")}if(P=="top-left"){A=s.offset.left+D;M=s.offset.top-a-_-12;H();B("bottom-left","top-left")}if(P=="top-right"){A=s.offset.left+s.dimension.width+D-o;M=s.offset.top-a-_-12;H();B("bottom-right","top-right")}if(P=="bottom"){var j=s.offset.left+o-(s.offset.left+s.dimension.width);A=s.offset.left-j/2+D;M=s.offset.top+s.dimension.height+_+12;H();B("top","bottom")}if(P=="bottom-left"){A=s.offset.left+D;M=s.offset.top+s.dimension.height+_+12;H();B("top-left","bottom-left")}if(P=="bottom-right"){A=s.offset.left+s.dimension.width+D-o;M=s.offset.top+s.dimension.height+_+12;H();B("top-right","bottom-right")}if(P=="left"){A=s.offset.left-D-o-12;O=s.offset.left+D+s.dimension.width+12;var F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_;if(A<0&&O+o>i){var I=parseFloat(n.$tooltip.css("border-width"))*2,q=o+A-I;n.$tooltip.css("width",q+"px");a=n.$tooltip.outerHeight(false);A=s.offset.left-D-q-12-I;F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_}else if(A<0){A=s.offset.left+D+s.dimension.width+12;r="left"}}if(P=="right"){A=s.offset.left+D+s.dimension.width+12;O=s.offset.left-D-o-12;var F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_;if(A+o>i&&O<0){var I=parseFloat(n.$tooltip.css("border-width"))*2,q=i-A-I;n.$tooltip.css("width",q+"px");a=n.$tooltip.outerHeight(false);F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_}else if(A+o>i){A=s.offset.left-D-o-12;r="right"}}if(n.options.arrow){var R="tooltipster-arrow-"+P;if(n.options.arrowColor.length<1){var U=n.$tooltip.css("background-color")}else{var U=n.options.arrowColor}if(!r){r=""}else if(r=="left"){R="tooltipster-arrow-right";r=""}else if(r=="right"){R="tooltipster-arrow-left";r=""}else{r="left:"+Math.round(r)+"px;"}if(P=="top"||P=="top-left"||P=="top-right"){var z=parseFloat(n.$tooltip.css("border-bottom-width")),W=n.$tooltip.css("border-bottom-color")}else if(P=="bottom"||P=="bottom-left"||P=="bottom-right"){var z=parseFloat(n.$tooltip.css("border-top-width")),W=n.$tooltip.css("border-top-color")}else if(P=="left"){var z=parseFloat(n.$tooltip.css("border-right-width")),W=n.$tooltip.css("border-right-color")}else if(P=="right"){var z=parseFloat(n.$tooltip.css("border-left-width")),W=n.$tooltip.css("border-left-color")}else{var z=parseFloat(n.$tooltip.css("border-bottom-width")),W=n.$tooltip.css("border-bottom-color")}if(z>1){z++}var X="";if(z!==0){var V="",J="border-color: "+W+";";if(R.indexOf("bottom")!==-1){V="margin-top: -"+Math.round(z)+"px;"}else if(R.indexOf("top")!==-1){V="margin-bottom: -"+Math.round(z)+"px;"}else if(R.indexOf("left")!==-1){V="margin-right: -"+Math.round(z)+"px;"}else if(R.indexOf("right")!==-1){V="margin-left: -"+Math.round(z)+"px;"}X='<span class="tooltipster-arrow-border" style="'+V+" "+J+';"></span>'}n.$tooltip.find(".tooltipster-arrow").remove();var K='<div class="'+R+' tooltipster-arrow" style="'+r+'">'+X+'<span style="border-color:'+U+';"></span></div>';n.$tooltip.append(K)}n.$tooltip.css({top:Math.round(M)+"px",left:Math.round(A)+"px"})}return n},enable:function(){this.enabled=true;return this},disable:function(){this.hide();this.enabled=false;return this},destroy:function(){var t=this;t.hide();if(t.$el[0]!==t.$elProxy[0]){t.$elProxy.remove()}t.$el.removeData(t.namespace).off("."+t.namespace);var n=t.$el.data("tooltipster-ns");if(n.length===1){var r=null;if(t.options.restoration==="previous"){r=t.$el.data("tooltipster-initialTitle")}else if(t.options.restoration==="current"){r=typeof t.Content==="string"?t.Content:e("<div></div>").append(t.Content).html()}if(r){t.$el.attr("title",r)}t.$el.removeClass("tooltipstered").removeData("tooltipster-ns").removeData("tooltipster-initialTitle")}else{n=e.grep(n,function(e,n){return e!==t.namespace});t.$el.data("tooltipster-ns",n)}return t},elementIcon:function(){return this.$el[0]!==this.$elProxy[0]?this.$elProxy[0]:undefined},elementTooltip:function(){return this.$tooltip?this.$tooltip[0]:undefined},option:function(e,t){if(typeof t=="undefined")return this.options[e];else{this.options[e]=t;return this}},status:function(){return this.Status}};e.fn[r]=function(){var t=arguments;if(this.length===0){if(typeof t[0]==="string"){var n=true;switch(t[0]){case"setDefaults":e.extend(i,t[1]);break;default:n=false;break}if(n)return true;else return this}else{return this}}else{if(typeof t[0]==="string"){var r="#*$~&";this.each(function(){var n=e(this).data("tooltipster-ns"),i=n?e(this).data(n[0]):null;if(i){if(typeof i[t[0]]==="function"){var s=i[t[0]](t[1],t[2])}else{throw new Error('Unknown method .tooltipster("'+t[0]+'")')}if(s!==i){r=s;return false}}else{throw new Error("You called Tooltipster's \""+t[0]+'" method on an uninitialized element')}});return r!=="#*$~&"?r:this}else{var o=[],u=t[0]&&typeof t[0].multiple!=="undefined",a=u&&t[0].multiple||!u&&i.multiple,f=t[0]&&typeof t[0].debug!=="undefined",l=f&&t[0].debug||!f&&i.debug;this.each(function(){var n=false,r=e(this).data("tooltipster-ns"),i=null;if(!r){n=true}else if(a){n=true}else if(l){console.log('Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the "multiple" option to attach more tooltips.')}if(n){i=new s(this,t[0]);if(!r)r=[];r.push(i.namespace);e(this).data("tooltipster-ns",r);e(this).data(i.namespace,i)}o.push(i)});if(a)return o;else return this}}};var u=!!("ontouchstart"in t);var a=false;e("body").one("mousemove",function(){a=true})})(jQuery,window,document);
var MPageUI = (function() {
	/* eslint-disable eqeqeq */
	/* eslint-disable no-unused-vars */
	/* eslint-disable new-cap */
	var objectAssign = (function() {
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;
		function ToObject(val) {
			if (val == null) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}
		function ownEnumerableKeys(obj) {
			var keys = Object.getOwnPropertyNames(obj);

			if (Object.getOwnPropertySymbols) {
				keys = keys.concat(Object.getOwnPropertySymbols(obj));
			}

			return keys.filter(function(key) {
				return propIsEnumerable.call(obj, key);
			});
		}
		return Object.assign || function(target, source) {
				var from;
				var keys;
				var to = ToObject(target);

				for (var s = 1; s < arguments.length; s++) {
					from = arguments[s];
					keys = ownEnumerableKeys(Object(from));

					for (var i = 0; i < keys.length; i++) {
						to[keys[i]] = from[keys[i]];
					}
				}

				return to;
			};
	})();
	/* eslint-enable eqeqeq */
	/* eslint-enable no-unused-vars */
	/* eslint-enable new-cap */

	var idGen = 0;
	var uiComponentPrefix = "mpageui_";
	return {
		extend: function(Subclass, ParentClass) {
			//Make the Subclass extend the ParentClass
			var parentClass = new ParentClass();
			Subclass.prototype = parentClass;
			Subclass.prototype.constructor = ParentClass;
		},
		/**
		 * Registers a UIComponent to the MPageUI framework.
		 * @param {MPageUI.UIComponent} component - The UIComponent object to be registered into the MPageUI framework.
		 * @private
		 * @returns {undefined} Returns undefined.
		 */
		registerComponent: function(component) {
			var gid = ++idGen + "";
			component.setId(uiComponentPrefix + gid);
		},
		/**
		 * Creates a new MPageUI class
		 * @param spec
		 * @returns {Function}
		 */
		createClass: function(spec) {
			var Constructor = function() {
				this.base();
				this.init();
			};
			//By default, inherit from the base UIComponent object
			Constructor.prototype = new MPageUI.UIComponent();
			Constructor.prototype.constructor = MPageUI.UIComponent;
			//Use object assign shim to mix the specification into the
			//base UIComponent
			objectAssign(Constructor.prototype, spec);
			return Constructor;
		}
	};
})();

MPageUI.UIComponent = (function() {
	/**
	 * The base UIComponent class. All 'widgets' that are part of the MPageUI framework must inherit from the base
	 * class.
	 * @returns {MPageUI.UIComponent} Returns self to allow chaining.
	 * @constructor
	 */
	var UIComponent = function() {
		this.m_id = "";
		this.m_parent = null;
		this.m_$rootElement = null;
		return this;
	};
	UIComponent.prototype = {
		/**
		 * This function shall house any post-render event attachments. The UIComponent must exist on the DOM before
		 * this function is called. It is expected that subclasses of the UIComponent provide an implementation of this
		 * function.
		 * @returns {MPageUI.UIComponent} Returns self to allow chaining.
		 */
		attachEvents: function() {
			return this;
		},
		/**
		 * Serves as the base constructor for any UIComponent. This function must be called within the constructor of
		 * any subclasses of the UIComponent. This ensures the UIComponent is properly registered with the MPageUI
		 * framework. Failure to register will result in unexpected behavior.
		 * @returns {MPageUI.UIComponent} Returns self to allow chaining.
		 */
		base: function() {
			MPageUI.registerComponent(this);
			return this;
		},
		/**
		 * This function clears any cached elements stored in the UIComponent. This ensures that the next time an
		 * element is requested, it will be queried from the DOM anew.
		 * @returns {MPageUI.UIComponent} Returns self to allow chaining.
		 */
		clearElementCache: function() {
			this.m_$rootElement = null;
			return this;
		},
		/**
		 * This function shall house any post-constructor initialization processing.
		 * @returns {boolean} Simply returns true until overridden by subclasses.
		 */
		init: function() {
			return true;
		},
		/**
		 * Retrieves the ID of the UIComponent.
		 * @returns {string} The ID of the UIComponent.
		 */
		getId: function() {
			return this.m_id;
		},
		/**
		 * Sets the ID of the UIComponent. This ID must be unique across all UIComponent objects as it should be applied
		 * to the root DOM element of the UIComponent.
		 * @param {string} id - The ID of the UIComponent.
		 * @returns {MPageUI.UIComponent} Returns self to allow chaining.
		 */
		setId: function(id) {
			if (typeof id !== "string") {
				throw new Error("UIComponent.prototype.setId expects a string.");
			}
			this.m_id = id;
			return this;
		},
		/**
		 * Retrieves the root element of the UIComponent. If this element has not been cached previously, it will
		 * be queried from the DOM, using the ID that was set prior to rendering the UIComponent.
		 * @returns {jQuery} The root jQuery DOM element of the UIComponent.
		 */
		getRootElement: function() {
			if (!this.m_$rootElement || !this.m_$rootElement.length) {
				this.m_$rootElement = $("#" + this.m_id);
			}
			return this.m_$rootElement;
		},
		/**
		 * The render function morphs the markup returned from the renderHtml function into a jQuery element. This
		 * element is then cached as the root element of the UIComponent. The element is decorated with the element's id
		 * as well as the data-lookup attribute.
		 * @returns {string} The UIComponent rendered as a rendered element.
		 */
		render: function() {
			return "";
		}
	};
	return UIComponent;
})();

/* global MPageUI */

MPageUI.Event = (function() {
	return {
		/**
		 * Creates a UIEvent object which wraps information about an event that occurred on a UIComponent object.
		 * @param {UIComponent} sourceUIComponent - The source of the event that was triggered.
		 * @param {Event} nativeEvent - The native browser event that occurred.
		 * @returns {MPageUI.Event.UIEvent} A UIEvent object which wraps information about the event that occurred.
		 */
		createUIEvent: function(sourceUIComponent, nativeEvent) {
			return new MPageUI.Event.UIEvent()
				.setSource(sourceUIComponent)
				.setNative(nativeEvent);
		},
		/**
		 * Creates a UIMessage object which wraps information about a message that is sent from a UIComponent to
		 * its parent.
		 * @param {MPageUI.UIComponent} sourceUIComponent - The source of the message.
		 * @param {string} event - The event that occurred.
		 * @returns {MPageUI.Event.UIMessage} The UIMessage object that was created.
		 */
		createUIMessage: function(sourceUIComponent, event) {
			return new MPageUI.Event.UIMessage()
				.setSource(sourceUIComponent)
				.setEvent(event);
		}
	};
})();

MPageUI.Event.UIEvent = (function() {
	/**
	 * The UIEvent class. This represents an event that occurs on a UIComponent.
	 * @returns {MPageUI.Event.UIEvent} Returns self to allow chaining.
	 * @constructor
	 */
	var UIEvent = function() {
		this.m_native = null;
		this.m_source = null;
		return this;
	};
	UIEvent.prototype = {
		getCurrentTargetElement: function() {
			if (!this.m_native) {
				return null;
			}
			return this.m_native.currentTarget || null;
		},
		/**
		 * Retrieves the native JavaScript event.
		 * @returns {Event} The native event that was triggered from some DOM action.
		 */
		getNative: function() {
			return this.m_native;
		},
		/**
		 * Sets the native JavaScript event.
		 * @param {Event} nativeEvent - The native JavaScript event that occurred.
		 * @returns {MPageUI.Event.UIEvent} Returns self to allow chaining.
		 */
		setNative: function(nativeEvent) {
			this.m_native = nativeEvent;
			return this;
		},
		/**
		 * Retrieves the source UIComponent.
		 * @returns {MPageUI.UIComponent} The source UIComponent.
		 */
		getSource: function() {
			return this.m_source;
		},
		/**
		 * Sets the source UIComponent.
		 * @param {MPageUI.UIComponent} source - The source UIComponent.
		 * @returns {MPageUI.Event.UIEvent} Returns self to allow chaining.
		 */
		setSource: function(source) {
			if (!MPageUI.UIComponent.prototype.isPrototypeOf(source)) {
				throw new Error("MPageUI.Event.UIEvent.prototype.setSource expects a UIComponent.");
			}
			this.m_source = source;
			return this;
		}
	};
	return UIEvent;
})();

MPageUI.Event.UIMessage = (function() {
	/**
	 * The UIMessage class. This is for packaging messages that can be sent from children UIComponent objects
	 * to their parents.
	 * @constructor
	 */
	var UIMessage = function() {
		this.m_event = "";
		this.m_source = null;
	};

	/**
	 * Retrieves the event identifier.
	 * @returns {string} The event identifier.
	 */
	UIMessage.prototype.getEvent = function() {
		return this.m_event;
	};

	/**
	 * Sets the event identifier. For example 'onButtonClick'.
	 * @param {string} event - The identifier of the event that occurred.
	 * @returns {MPageUI.Event.UIMessage} Returns self to allow chaining.
	 */
	UIMessage.prototype.setEvent = function(event) {
		if (typeof event !== "string") {
			throw new Error("MPageUI.Message.prototype.setEvent expects a string.");
		}
		this.m_event = event;
		return this;
	};

	/**
	 * Retrieves the UIComponent that is the source of the message.
	 * @returns {MPageUI.UIComponent} The UIComponent that is the source of the message.
	 */
	UIMessage.prototype.getSource = function() {
		return this.m_source;
	};

	/**
	 * Sets the source UIComponent. This is the UIComponent that sent the message.
	 * @param {MPageUI.UIComponent} source - The source UIComponent.
	 * @returns {MPageUI.Event.UIMessage} Returns self to allow chaining.
	 */
	UIMessage.prototype.setSource = function(source) {
		if (!MPageUI.UIComponent.prototype.isPrototypeOf(source)) {
			throw new Error("MPageUI.Message.prototype.setSource expects a UIComponent object.");
		}
		this.m_source = source;
		return this;
	};
	return UIMessage;
})();

/* global MPageUI */

MPageUI.ICONS = {
	ICON_MOVE_LEFT: 'icon-move-left',
	ICON_MOVE_RIGHT: 'icon-move-right'
};

/* global MPageUI */

MPageUI.Pager = (function() {
	/**
	 * The Pager UIComponent. This class is used for paging mechanisms.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 * @constructor
	 */
	var Pager = function() {
		//Super constructor
		this.base();
		this.m_currentPageLabel = "";
		this.m_previousLabel = "";
		this.m_nextLabel = "";
		this.m_currentPage = 0;
		this.m_numberPages = 0;
		this.m_wrap = false;
		this.m_onPageChangeCallback = null;

		//Element cache
		this.m_$currentPageElement = null;
		this.m_$nextElement = null;
		this.m_$previousElement = null;
		return this;
	};
	MPageUI.extend(Pager, MPageUI.UIComponent);

	/**
	 * Retrieves the current page element.
	 * @returns {jQuery} The current page element.
	 */
	Pager.prototype.getCurrentPageElement = function() {
		if (!this.m_$currentPageElement || !this.m_$currentPageElement.length) {
			this.m_$currentPageElement = this.getRootElement().find(".current-page");
		}
		return this.m_$currentPageElement;
	};

	/**
	 * Retrieves the next clickable target.
	 * @returns {jQuery} The next clickable target element.
	 */
	Pager.prototype.getNextElement = function() {
		if (!this.m_$nextElement || !this.m_$nextElement.length) {
			this.m_$nextElement = this.getRootElement().find(".next-page");
		}
		return this.m_$nextElement;
	};

	/**
	 * Retrieves the previous clickable target.
	 * @returns {jQuery} The previous clickable target element.
	 */
	Pager.prototype.getPreviousElement = function() {
		if (!this.m_$previousElement || !this.m_$previousElement.length) {
			this.m_$previousElement = this.getRootElement().find(".prev-page");
		}
		return this.m_$previousElement;
	};

	/**
	 * Sets the current page label. This pattern is used to update the page display, for instance 0 of 10 or 0 / 10.
	 * The pattern replaces the string ${currentPage} with the current page number. The pattern replaces ${numberPages}
	 * with the total number of pages. For example, if you wanted your page control to display '0 out of 10', you
	 * would set the pattern to '${currentPage} out of ${numberPages}'.
	 * @param {string} currentPageLabel - The current page label. The two recognized keywords are ${currentPage} and
	 * ${numberPages} which are replaced by the current page and total number of pages respectively.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setCurrentPageLabelPattern = function(currentPageLabel) {
		if (typeof currentPageLabel !== "string") {
			throw new Error("Pager.prototype.setCurrentPageLabel expects a string");
		}
		this.m_currentPageLabel = currentPageLabel;
		this.getCurrentPageElement().html(this.getCurrentPageLabel());
		return this;
	};

	/**
	 * Gets the current page label.
	 * @returns {string} The current page label as a string.
	 */
	Pager.prototype.getCurrentPageLabel = function() {
		return this.m_currentPageLabel.replace("${currentPage}", this.m_currentPage + 1).replace("${numberPages}", this.m_numberPages);
	};

	/**
	 * Sets the label to be displayed in the clickable previous target.
	 * @param {string} previousLabel - The label to be displayed in the previous target.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setPreviousLabel = function(previousLabel) {
		if (typeof previousLabel !== "string") {
			throw new Error("Pager.prototype.setPreviousLabel expects a string.");
		}
		this.m_previousLabel = previousLabel;
		return this;
	};

	/**
	 * Sets the label to be displayed in the clickable next target.
	 * @param {string} nextLabel - The label to be displayed in the next target.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setNextLabel = function(nextLabel) {
		if (typeof nextLabel !== "string") {
			throw new Error("Pager.prototype.setNextLabel expects a string.");
		}
		this.m_nextLabel = nextLabel;
		return this;
	};

	/**
	 * Updates the disabled state of the previous/next clickable targets.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.updateNextPreviousDisabled = function() {
		if (this.m_numberPages === Number.POSITIVE_INFINITY) {
			//Disable the previous target if you are at the first page.
			this.getPreviousElement().prop("disabled", (this.m_currentPage === 0)).attr("disabled", (this.m_currentPage === 0));
		}
		else {
			if (this.m_wrap) {
				return;
			}
			//Disable the previous target if you are at first page
			this.getPreviousElement().prop("disabled", (this.m_currentPage === 0)).attr("disabled", (this.m_currentPage === 0));

			//Disable the next target if you are at the last page.
			this.getNextElement().prop("disabled", (this.m_currentPage + 1 === this.m_numberPages)).attr("disabled", (this.m_currentPage + 1 === this.m_numberPages));
		}
	};

	/**
	 * Sets the number of pages to infinity and sets the current page to 1.
	 * @param {boolean} pagesUnknown - The indicator for specifying if the pages are unknown
	 * @return {MPageUI.Pager} Return self to allow chaining.
	 */
	Pager.prototype.setPagesUnknown = function(pagesUnknown) {
		if (typeof pagesUnknown !== "boolean") {
			throw new Error("Pager.prototype.setPagesUnknown expects a boolean.");
		}
		if (pagesUnknown) {
			this.m_numberPages = Number.POSITIVE_INFINITY;
		}
		return this;
	};

	/**
	 * Updates the Current Page label when the next/prev button is clicked.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.updateCurrentPageLabel = function() {
		this.getCurrentPageElement().html(this.getCurrentPageLabel());
	};

	/**
	 * Sets whether the pager should wrap the page index. If set to true, the page index will continually cycle from
	 * zero to the specified number of pages in the positive or negative direction (depending on
	 * @param {boolean} wrap - A boolean indicating that the pager should wrap or not.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setWrap = function(wrap) {
		this.m_wrap = wrap;
		return this;
	};

	/**
	 * Sets the maximum number of pages for the pager.
	 * @param {number} numberPages - An integer indicating how many pages the pager has.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setNumberPages = function(numberPages) {
		if (typeof numberPages !== "number") {
			throw new Error("Pager.prototype.setNumberPages expects a number.");
		}
		if (numberPages < 0 || numberPages % 1 !== 0) {
			throw new Error("Pager.prototype.setNumberPages expects a number greater than or equal to 0.");
		}
		this.m_numberPages = numberPages;
		return this;
	};

	/**
	 * Sets the current page for the pager.
	 * @param {number} currentPage - An integer indicating the current page.
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setCurrentPage = function(currentPage) {
		if (typeof currentPage !== "number") {
			throw new Error("Pager.prototype.setCurrentPage expects a number.");
		}
		if (currentPage < 0 || currentPage % 1 !== 0) {
			throw new Error("Pager.prototype.setCurrentPage expects a number greater than or equal to 0.");
		}
		this.m_currentPage = currentPage;
		if (!this.m_wrap) {
			this.updateNextPreviousDisabled();
		}
		this.updateCurrentPageLabel();
		return this;
	};

	/**
	 * Handles the event when the user clicks the first page target. This will automatically set the page index to 0,
	 * or the first page. Once the page index has been updated, the page change callback will be called with the current
	 * page index.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.onClickFirst = function() {
		this.setCurrentPage(0);
		if (this.m_onPageChangeCallback) {
			this.m_onPageChangeCallback({
				"currentPage": this.m_currentPage,
				"numberPages": this.m_numberPages
			});
		}
	};

	/**
	 * Handles the event when the user clicks the previous target. If the control is configured to wrap, the page index
	 * will continually cycle from zero to the specified number of pages. Otherwise, the page index will be clamped
	 * to zero. Once the page index has been updated, the page change callback will be called with the current page
	 * index.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.onClickPrevious = function() {
		if (this.m_numberPages === Number.POSITIVE_INFINITY && this.m_currentPage >= 0) {
			this.m_currentPage--;
			this.setCurrentPage(this.m_currentPage);
		}
		else {
			/* eslint-disable */
			if (this.m_wrap) {
				this.setCurrentPage(((this.m_currentPage - 1) + this.m_numberPages) % this.m_numberPages);
			}
			else {
				this.setCurrentPage(Math.max(0, this.m_currentPage - 1));
			}
			/* eslint-enable */
		}
		if (this.m_onPageChangeCallback) {
			this.m_onPageChangeCallback({
				"currentPage": this.m_currentPage,
				"numberPages": this.m_numberPages
			});
		}
	};

	/**
	 * Handles the event when the user clicks the next target. If the control is configured to wrap, the page index
	 * will continually cycle from zero to the specified number of pages. Otherwise, the page index will be clamped
	 * to zero. Once the page index has been updated, the page change callback will be called with the current page
	 * index.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.onClickNext = function() {
		if (this.m_numberPages === Number.POSITIVE_INFINITY) {
			this.m_currentPage++;
			this.setCurrentPage(this.m_currentPage);
		}
		else {
			/* eslint-disable */
			if (this.m_wrap) {
				this.setCurrentPage((this.m_currentPage + 1) % this.m_numberPages);
			}
			else {
				this.setCurrentPage(Math.min(this.m_numberPages, this.m_currentPage + 1));
			}
			/* eslint-enable */
		}
		if (this.m_onPageChangeCallback) {
			this.m_onPageChangeCallback({
				"currentPage": this.m_currentPage,
				"numberPages": this.m_numberPages
			});
		}
	};

	/**
	 * Handles the event when the user clicks the first page target. This will automatically set the page index to 0,
	 * or the first page. Once the page index has been updated, the page change callback will be called with the current
	 * page index.
	 * @returns {undefined} Returns undefined.
	 */
	Pager.prototype.onClickLast = function() {
		this.setCurrentPage(this.m_numberPages);
		if (this.m_onPageChangeCallback) {
			this.m_onPageChangeCallback({
				"currentPage": this.m_currentPage,
				"numberPages": this.m_numberPages
			});
		}
	};

	/**
	 * Sets the callback to be triggered when the page index changes.
	 * @param {function} callback - The callback function to be triggered when the page index changes. It is expected
	 * that this callback function provide a parameter for the current page index. For example...
	 * pager.setOnPageChangeCallback(function(pageIndex){ ... });
	 * @returns {MPageUI.Pager} Returns self to allow chaining.
	 */
	Pager.prototype.setOnPageChangeCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("Pager.prototype.setOnPageChangeCallback expects a function.");
		}
		this.m_onPageChangeCallback = callback;
		return this;
	};

	/**
	 * Overrides the base render function.
	 * @returns {string} Returns jquery pager object.
	 */
	Pager.prototype.render = function() {
		var previousDisabled = (!this.m_wrap ? " disabled='true'" : "");
		var pager = "<nav id='" + this.m_id + "' class='paginator'>";
		//Next
		pager += "<span class='next-pages'><a class='next-page' href='#' rel='next'>" + this.m_nextLabel + "</a></span>";
		//Previous
		pager += "<span class='prior-pages'><a class='prev-page' href='#' rel='prev'" + previousDisabled + ">" + this.m_previousLabel + "</a></span>";
		//Middle area (separator)
		pager += "<span class='current-page'>" + this.getCurrentPageLabel() + "</span></nav>";
		return pager;
	};

	/**
	 * Attaches the necessary events to an instance of the Pager. This function must be called after the Pager has
	 * been rendered to the DOM.
	 * @returns {undefined} Returns nothing.
	 */
	Pager.prototype.attachEvents = function() {
		var self = this;
		var $rootElement = this.getRootElement();
		$rootElement.on("click.mpageui", ".first-page", function() {
			self.onClickFirst();
		});
		$rootElement.on("click.mpageui", ".prev-page", function() {
			self.onClickPrevious();
		});
		$rootElement.on("click.mpageui", ".next-page", function() {
			self.onClickNext();
		});
		$rootElement.on("click.mpageui", ".last-page", function() {
			self.onClickLast();
		});
	};
	return Pager;
})();

/* global MPageUI, MenuSeparator */

/**
 * Enumeration for MPageUI Menu configuration
 * @readonly
 */
MPageUI.MENU_OPTIONS = {
	TYPE: {
		SELECT: 0,
		SEPARATOR: 1
	}
};

MPageUI.Menu = (function() {
	/**
	 * The Base Menu class.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 * @constructor
	 */
	var Menu = function() {
		this.base();
		return this;
	};
	MPageUI.extend(Menu, MPageUI.UIComponent);

	/**
	 * The base open function. This shall open the menu. Subclasses of the Menu must provide the implementation.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 */
	Menu.prototype.open = function() {
		return this;
	};

	/**
	 * The base close function. This shall close the menu. Subclasses of the Menu must provide the implementation.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 */
	Menu.prototype.close = function() {
		return this;
	};

	/**
	 * The base isOpen function. This shall determine if the menu is currently open. Subclasses of the Menu must
	 * provide the implementation.
	 * @returns {boolean} True if the menu is open, otherwise false.
	 */
	Menu.prototype.isOpen = function() {
		return false;
	};

	/**
	 * The base menu render function. This shall render the menu as an html string. Subclasses of the Menu must
	 * provide the implementation. Note that some menus may not render html, as they may be dynamically added to the
	 * DOM and managed by another component.
	 * @returns {string} The Menu rendered as an html string.
	 */
	Menu.prototype.render = function() {
		return "";
	};

	/* eslint-disable no-unused-vars */
	/**
	 * Adds an option to the menu. This shall add an option to the Menu whether it be a selectable option or
	 * a radio option. Subclasses of the Menu must provide the implementation. The option must be a JSON object of the
	 * form
	 * {
	 * 		label: 		"Label",
	 * 		type:		MPageUI.MENU_OPTIONS.TYPE.x,
	 * 		value: 		0.0 (or some other data)
	 * 		onSelect:	function() { ... }
	 * }
	 * @param {Object} option - The option to be added to the menu.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 */
	Menu.prototype.addOption = function(option) {
		return this;
	};
	/* eslint-enable no-unused-vars */

	/**
	 * Adds a set of options to the menu. This loops over the array of provided options and calls addOption on each.
	 * @param {Array<Object>} options - The array of options to be added to the menu.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 */
	Menu.prototype.addOptions = function(options) {
		if (!Array.prototype.isPrototypeOf(options)) {
			throw new Error("MPageUI.Dropdown.prototype.addOptions expects an array of options");
		}
		var optionCount = options.length;
		for (var i = 0; i < optionCount; i++) {
			this.addOption(options[i]);
		}
		return this;
	};

	/**
	 * Removes all options from the menu.
	 * @returns {MPageUI.Menu} Returns self to allow chaining.
	 */
	Menu.prototype.removeAllOptions = function() {
		return this;
	};

	/**
	 * This function will validate a provided option. If the option is not valid, an exception will be thrown to
	 * inform the consumer.
	 * @param {Object} option - The option to be verified.
	 * @throws {Error} An error indicating that the provided option was not valid.
	 * @returns {undefined} Returns nothing.
	 */
	Menu.prototype.validateOption = function(option) {
		if (typeof option !== "object") {
			throw new Error("MPageUI.Dropdown.prototype.addOption expects an object");
		}
		var optionType = option.type || MPageUI.MENU_OPTIONS.TYPE.SELECT;
		var menuOptionsTypeEnum = MPageUI.MENU_OPTIONS.TYPE;
		switch (optionType) {
			case menuOptionsTypeEnum.SELECT:
				if (!option.label) {
					throw new Error("MPageUI.Dropdown.prototype.addOption: 'select' options must provide a label.");
				}
				if (typeof option.label !== "string") {
					throw new Error("MPageUI.Dropdown.prototype.addOption: the label must be a string.");
				}
				if (!option.onSelect) {
					throw new Error("MPageUI.Dropdown.prototype.addOption: 'select' options must provide an onSelect callback.");
				}
				if (typeof option.onSelect !== "function") {
					throw new Error("MPageUI.Dropdown.prototype.addOption: the onSelect must be a function.");
				}
				break;
			case menuOptionsTypeEnum.SEPARATOR:
				break;
			default:
				throw new Error("MPageUI.Dropdown.prototype.addOption: the option must provide a 'type', use MPageUI.MENU_OPTIONS.TYPE");
		}
	};
	return Menu;
})();

MPageUI.StandardMPageMenu = (function() {
	/**
	 * The StandardMPageMenu class. This is a subclass of MPageUI.Menu. It provides the implementation by wrapping
	 * the existing standard menu API to ensure ease of compatibility if/when MPageUI converts to the Terra convention
	 * for menus.
	 * @param {string} anchorId - The id of the element that is to be the anchor for the standard menu.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 * @constructor
	 */
	var StandardMPageMenu = function(anchorId) {
		this.base();
		this.m_anchorId = anchorId;
		this.m_menuItemCounter = 0;
		this.m_standardMenu = null;
		this.init();
		return this;
	};
	MPageUI.extend(StandardMPageMenu, MPageUI.Menu);

	/**
	 * Overrides the base init function. This initializes an instance of the existing standard menu API.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 */
	StandardMPageMenu.prototype.init = function() {
		var self = this;
		this.m_standardMenu = new Menu(this.m_id + "_standardMenu");
		this.m_standardMenu.setTypeClass("dropdown-standard-menu");
		this.m_standardMenu.setAnchorElementId(this.m_anchorId);
		this.m_standardMenu.setAnchorConnectionCorner(["bottom", "right"]);
		this.m_standardMenu.setContentConnectionCorner(["top", "right"]);
		this.m_standardMenu.setIsRootMenu(true);
		//Hijack the setIsActive function so we can intelligently prevent memory leaks
		this.m_standardMenu.setIsActive = function(activeInd) {
			//Call the base setIsActive function
			Menu.prototype.setIsActive.call(self.m_standardMenu, activeInd);
			//If the menu is being closed, remove the menu from the global lookup
			if(!activeInd) {
				//Remove the standard menu
				MP_MenuManager.deleteMenuObject(self.m_standardMenu.getId());
			}
		};
		return this;
	};

	/**
	 * Overrides the base addOption function. This transforms the option data object into a subsequent MenuItem from
	 * the existing standard MPages menu API.
	 * @param {Object} option - The option object being added to the menu.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 */
	StandardMPageMenu.prototype.addOption = function(option) {
		this.validateOption(option);
		var menuOptionsTypeEnum = MPageUI.MENU_OPTIONS.TYPE;
		var optionType = option.type || menuOptionsTypeEnum.SELECT;
		var menuItem = null;
		switch (optionType) {
			case menuOptionsTypeEnum.SELECT:
				menuItem = new MenuSelection(this.m_id + "_menuSelection_" + this.m_menuItemCounter++);
				menuItem.setLabel(option.label);
				menuItem.setClickFunction(this.getSelectionFunction(option));
				break;
			case menuOptionsTypeEnum.SEPARATOR:
				menuItem = new MenuSeparator(this.m_id + "_menuSeparator_" + this.m_menuItemCounter++);
				break;
			default:
				throw new Error("MPageUI.Dropdown.prototype.addOption: the option must provide a 'type'");
		}
		this.m_standardMenu.addMenuItem(menuItem);
		MP_MenuManager.updateMenuObject(this.m_standardMenu);
		return this;
	};

	/**
	 * Overrides the base Menu.prototype.removeAllOptions function.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 */
	StandardMPageMenu.prototype.removeAllOptions = function() {
		var options = this.m_standardMenu.getMenuItemArray();
		var optionCount = options.length;
		for(var i = 0; i < optionCount; i++) {
			if(!this.m_standardMenu.removeMenuItem(options[i])) {
				logger.logWarning("MPageUI.StandardMPageMenu.prototype.removeAllOptions: error removing menu item");
			}
		}
		this.m_menuItemCounter = 0;
		MP_MenuManager.updateMenuObject(this.m_standardMenu);
		return this;
	};

	/**
	 * This generates a selection function that is triggered when one of the items in the menu is selected. It will
	 * call the onSelect callback function for the specified option, ensuring to pass the option as the context of the
	 * function call.
	 * @param {Object} option - The option for which the selection function is being generated.
	 * @returns {function} The selection function. This closes on the option to ensure the correct callback function
	 * is triggered.
	 */
	StandardMPageMenu.prototype.getSelectionFunction = function(option) {
		return function() {
			option.onSelect.call(option);
		};
	};

	/**
	 * Overrides the base isOpen function to determine if the standard menu is open.
	 * @returns {boolean} True if the menu is currently open (active), otherwise false.
	 */
	StandardMPageMenu.prototype.isOpen = function() {
		return this.m_standardMenu.isActive();
	};

	/**
	 * Overrides the base open function to open the standard menu.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 */
	StandardMPageMenu.prototype.open = function() {
		//Since the Menu is removed on close (see init function), make sure it is available to
		//the MP_MenuManager.
		MP_MenuManager.updateMenuObject(this.m_standardMenu);
		MP_MenuManager.showMenu(this.m_standardMenu.getId());
		return this;
	};

	/**
	 * Overrides the base close function to close the standard menu.
	 * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
	 */
	StandardMPageMenu.prototype.close = function() {
		MP_MenuManager.closeMenuStack(false);
		return this;
	};

	/**
	 * Overrides the base render function to render nothing. The StandardMPageMenu is a special case in that it is
	 * not truly rendered to the DOM, but it is desirable to treat it as a standard UIComponent.
	 * @returns {string} An empty string since the StandardMPageMenu is not rendered as a composite piece of another
	 * UIComponent.
	 */
	StandardMPageMenu.prototype.render = function() {
		return "";
	};

	return StandardMPageMenu;
})();

/* global MPageUI */

MPageUI.Dropdown = (function() {
	/**
	 * Base Dropdown interface. Exposes necessary functions for a drop-down control.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 * @constructor
	 */
	var Dropdown = function() {
		this.m_menu = null;
		return this;
	};
	MPageUI.extend(Dropdown, MPageUI.UIComponent);

	/**
	 * Adds an option to the dropdown.
	 * @param {Object} option - The option to be added to the dropdown. This must be of the following form.
	 * {
	 * 		label: 'Label',
	 * 		type:	MPageUI.MENU_OPTIONS.TYPE.x,
	 * 		onSelect: function() { ... }
	 * }
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.addOption = function(option) {
		this.m_menu.addOption(option);
		return this;
	};

	/**
	 * Adds a set of options to the dropdown.
	 * @param {Array<Object>} options - The list of options to be added to the dropdown.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.addOptions = function(options) {
		this.m_menu.addOptions(options);
		return this;
	};

	/**
	 * Removes all options for the dropdown.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.removeAllOptions = function() {
		this.m_menu.removeAllOptions();
		return this;
	};

	/**
	 * Determines if the dropdown is currently open.
	 * @private
	 * @returns {boolean} True if the dropdown is currently open, otherwise false.
	 */
	Dropdown.prototype.isOpen = function() {
		return this.m_menu.isOpen();
	};

	/**
	 * Opens the dropdown menu.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.open = function() {
		this.m_menu.open();
		return this;
	};

	/**
	 * Closes the dropdown menu.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.close = function() {
		this.m_menu.close();
		return this;
	};

	/**
	 * Toggles the open state of the dropdown menu.
	 * @returns {MPageUI.Dropdown} Returns self to allow chaining.
	 */
	Dropdown.prototype.toggle = function() {
		if (this.isOpen()) {
			this.close();
		}
		else {
			this.open();
		}
		return this;
	};

	return Dropdown;
})();

/* global MPageUI */

MPageUI.BUTTON_OPTIONS = {
	SHAPE: {
		NORMAL: "",
		PILL: "btn-pill"
	},
	STYLE: {
		NORMAL: "",
		PRIMARY: "btn-primary",
		SECONDARY: "btn-secondary",
		INVERSE: "btn-inverse",
		POSITIVE: "btn-positive",
		NEGATIVE: "btn-negative",
		LINK: "btn-link"
	},
	SIZE: {
		NORMAL: "",
		SMALL: "btn-small",
		LARGE: "btn-large",
		THINLINE: "btn-thinline"
	},
	TOGGLE: {
		NORMAL: "",
		DROPDOWN: "dropdown"
	},
	ICON_POSITION: {
		LEFT: 0,
		RIGHT: 1
	}
};

MPageUI.Button = (function() {
	/**
	 * The Button class.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 * @constructor
	 */
	var Button = function() {
		//Super constructor
		this.base();

		this.m_disabled = false;
		this.m_label = "";
		this.m_onClickCallback = null;

		this.m_shape = MPageUI.BUTTON_OPTIONS.SHAPE.NORMAL;
		this.m_size = MPageUI.BUTTON_OPTIONS.SIZE.NORMAL;
		this.m_style = MPageUI.BUTTON_OPTIONS.STYLE.NORMAL;
		this.m_dataToggle = MPageUI.BUTTON_OPTIONS.TOGGLE.NORMAL;

		this.m_icon = "";
		this.m_iconPosition = MPageUI.BUTTON_OPTIONS.ICON_POSITION.LEFT;
		return this;
	};
	MPageUI.extend(Button, MPageUI.UIComponent);

	/**
	 * Retrieves the disabled indicator for the button.
	 * @returns {boolean} True if the button is disabled, otherwise false.
	 */
	Button.prototype.isDisabled = function() {
		return this.m_disabled;
	};

	/**
	 * Sets the disabled indicator for the button.
	 * @param {boolean} disabled - The disabled state of the button.
	 * @throws {Error} An error indicating that the disabled parameter is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setDisabled = function(disabled) {
		if (typeof disabled !== "boolean") {
			throw new Error("Button.prototype.setDisabled expects a boolean.");
		}
		this.m_disabled = disabled;
		var $rootElement = this.getRootElement();
		$rootElement.prop("disabled", disabled);
		return this;
	};

	/**
	 * Sets the label of the Button.
	 * @param {string} label - The label of the Button.
	 * @throws {Error} An error indicating that the label parameter is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setLabel = function(label) {
		if (typeof label !== "string") {
			throw new Error("Button.prototype.setLabel expects a string.");
		}
		this.m_label = label;
		var $rootElement = this.getRootElement();
		$rootElement.html(this.renderButtonContents());
		return this;
	};
	/**
	 * Sets the shape of the Button.
	 * @param {string} shape - The shape of the button.
	 * @throws {Error} An error indicating that the shape parameter is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setShape = function(shape) {
		if (typeof shape !== "string") {
			throw new Error("Button.prototype.setShape expects a string.");
		}
		var $rootElement = this.getRootElement();
		if (shape !== this.m_shape) {
			$rootElement.removeClass(this.m_shape);
			$rootElement.addClass(shape);
		}
		this.m_shape = shape;
		return this;
	};
	/**
	 * Sets the size of the Button.
	 * @param {string} size - The size of the Button.
	 * @throws {Error} An error indicating that the size is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setSize = function(size) {
		if (typeof size !== "string") {
			throw new Error("Button.prototype.setSize expects a string.");
		}
		var $rootElement = this.getRootElement();
		if (size !== this.m_size) {
			$rootElement.removeClass(this.m_size);
			$rootElement.addClass(size);
		}
		this.m_size = size;
		return this;
	};
	/**
	 * Sets the style of the Button.
	 * @param {string} style - The style of the Button.
	 * @throws {Error} An error indicating that the style is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setStyle = function(style) {
		if (typeof style !== "string") {
			throw new Error("Button.prototype.setStyle expects a string.");
		}
		var $rootElement = this.getRootElement();
		if (style !== this.m_style) {
			$rootElement.removeClass(this.m_style);
			$rootElement.addClass(style);
		}
		this.m_style = style;
		return this;
	};
	/**
	 * Sets the data toggle attribute for the button.
	 * @param {string} dataToggle - The data-toggle attribute for the button. This will be rendered into the markup
	 * as <button data-toggle='dataToggle'>Sample</button>.
	 * @throws {Error} An error indicating that the dataToggle is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setDataToggle = function(dataToggle) {
		if (typeof dataToggle !== "string") {
			throw new Error("Button.prototype.setDataToggle");
		}
		var $rootElement = this.getRootElement();
		if (dataToggle !== this.m_dataToggle) {
			$rootElement.attr("data-toggle", dataToggle);
		}
		this.m_dataToggle = dataToggle;
		return this;
	};
	/**
	 * Sets the icon class for the button. Use the MPageUI.ICONS enumeration for supported icons.
	 * @param {string} icon - The icon CSS class for the button.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setIcon = function(icon) {
		if(typeof icon !== "string") {
			throw new Error("Button.prototype.setIcon expects a string.");
		}
		this.m_icon = icon;
		this.getRootElement().html(this.renderButtonContents());
		return this;
	};
	/**
	 * Sets the position of the icon within the button. Use MPageUI.BUTTON_OPTIONS.ICON_POSITION.
	 * @param {number} iconPosition - The icon position.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setIconPosition = function(iconPosition) {
		if(typeof iconPosition !== "number") {
			throw new Error("Button.prototype.setIconPosition expects a number.");
		}
		this.m_iconPosition = iconPosition;
		this.getRootElement().html(this.renderButtonContents());
		return this;
	};
	/**
	 * Sets the callback function that is triggered when the button is clicked.
	 * @param {function} callback - The function
	 * @throws {Error} An error indicating that the callback is an invalid type.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.setOnClickCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("Button.prototype.setOnClickCallback expects a function.");
		}
		this.m_onClickCallback = callback;
		return this;
	};
	/**
	 * Handles the click function for the button.
	 * @returns {undefined} Returns nothing.
	 */
	Button.prototype.onClick = function() {
		if (this.m_onClickCallback) {
			this.m_onClickCallback();
		}
	};
	/**
	 * Renders the button contents (what goes inside the <button></button> tags) as an html string
	 * @private
	 * @returns {string} The button contents rendered as an html string.
	 */
	Button.prototype.renderButtonContents = function() {
		var icon = this.renderIcon();
		var contents = this.m_label;
		if(!icon) {
			return contents;
		}
		if(!contents) {
			return icon;
		}
		//An icon and a label are present
		if(this.m_iconPosition === MPageUI.BUTTON_OPTIONS.ICON_POSITION.LEFT) {
			contents = icon + "&nbsp;" + contents;
		} else {
			contents = contents + "&nbsp;" + icon;
		}
		return contents;
	};
	/**
	 * Renders the button icon as an html string. If no icon is set on the button, it will return an empty string.
	 * @private
	 * @returns {string} The button icon as an html string. Empty if no icon is set.
	 */
	Button.prototype.renderIcon = function() {
		if(!this.m_icon) {
			return "";
		}
		return "<span class='" + this.m_icon + "'>&nbsp;</span>";
	};
	/**
	 * Renders the Button as an HTML string.
	 * @returns {string} The Button rendered as an HTML string.
	 */
	Button.prototype.render = function() {
		var disabled = this.m_disabled ? "disabled='true'" : "";
		var classes = "btn";
		var dataToggle = this.m_dataToggle ? ("data-toggle='" + this.m_dataToggle + "'") : "";
		var contents = this.renderButtonContents();
		classes += this.m_size ? " " + this.m_size : "";
		classes += this.m_shape ? " " + this.m_shape : "";
		classes += this.m_style ? " " + this.m_style : "";
		return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + disabled + " " + dataToggle + ">" + contents + "</button>";
	};

	/**
	 * Attaches the necessary events to the button. This function must be called after the button
	 * markup exists on the DOM.
	 * @returns {MPageUI.Button} Returns self to allow chaining.
	 */
	Button.prototype.attachEvents = function() {
		var self = this;
		this.getRootElement().on("click.mpageui", function() {
			self.onClick();
		});
		return this;
	};
	return Button;
})();

MPageUI.DropdownButton = (function() {
	/**
	 * The DropdownButton class. This creates a standard dropdown styled button.
	 * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
	 * @constructor
	 */
	var DropdownButton = function() {
		//Super constructor
		this.base();
		this.m_dataToggle = MPageUI.BUTTON_OPTIONS.TOGGLE.DROPDOWN;
		return this;
	};
	MPageUI.extend(DropdownButton, MPageUI.Button);

	/* eslint-disable no-unused-vars */
	/**
	 * Override the MPageUI.Button.prototype.setLabel function to do nothing, since we want to ensure the label is
	 * not altered.
	 * @param {string} label - The label for the button. This parameter is ignored.
	 * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
	 */
	DropdownButton.prototype.setLabel = function(label) {
		return this;
	};
	/* eslint-enable no-unused-vars */

	/* eslint-disable no-unused-vars */
	/**
	 * Overrides the MPageUI.Button.prototpye.setDataToggle function to do nothing to ensure the dropdown button
	 * always has the data-toggle='dropdown' attribute.
	 * @param {string} dataToggle - The data-toggle attribute value.
	 * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
	 */
	DropdownButton.prototype.setDataToggle = function(dataToggle) {
		return this;
	};
	/* eslint-enable no-unused-vars */

	/**
	 * Overrides the MPageUI.Button.prototype.render function to render the DropdownButton as an html string.
	 * @returns {string} The DropdownButton rendered as an html string.
	 */
	DropdownButton.prototype.render = function() {
		var disabled = this.m_disabled ? " disabled='true'" : "";
		var classes = "btn dropdown-toggle";
		var dataToggle = "data-toggle='" + this.m_dataToggle + "'";
		classes += (this.m_style ? " " + this.m_style : "");
		return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + dataToggle + disabled + "><span class='caret'></span></button>";
	};

	return DropdownButton;
})();

MPageUI.SplitButton = (function() {
	/**
	 * The SplitButton class.
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 * @constructor
	 */
	var SplitButton = function() {
		this.base();
		//this.m_menu -> inherited from MPageUI.Dropdown
		this.m_labelButton = null;
		this.m_dropdownButton = null;
		this.init();
		return this;
	};
	MPageUI.extend(SplitButton, MPageUI.Dropdown);

	/**
	 * Retrieves the label button.
	 * @returns {MPageUI.Button} The label button.
	 */
	SplitButton.prototype.getLabelButton = function() {
		return this.m_labelButton;
	};

	/**
	 * Retrieves the dropdown button.
	 * @returns {MPageUI.DropdownButton} The dropdown button.
	 */
	SplitButton.prototype.getDropdownButton = function() {
		return this.m_dropdownButton;
	};

	/**
	 * Sets the click callback function that is triggered when the label button is clicked.
	 * @param {function} labelButtonClickCallback - The click callback function that is triggered when the label button
	 * is clicked.
	 * @throws {Error} An error indicating that the labelButtonClickCallback is an invalid type.
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 */
	SplitButton.prototype.setLabelButtonClickCallback = function(labelButtonClickCallback) {
		if (typeof labelButtonClickCallback !== "function") {
			throw new Error("MPageUI.SplitButton.prototype.setLabelButtonClickCallback expects a function.");
		}
		this.m_labelButton.setOnClickCallback(labelButtonClickCallback);
		return this;
	};

	/**
	 * Sets the label of the SplitButton.
	 * @param {string} label - The label of the SplitButton.
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 */
	SplitButton.prototype.setLabel = function(label) {
		this.m_labelButton.setLabel(label);
		return this;
	};

	/**
	 * Sets the style for both the label button and the dropdown button.
	 * @param {string} style - The style to be applied to the label and dropdown button.
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 */
	SplitButton.prototype.setStyle = function(style) {
		this.m_labelButton.setStyle(style);
		this.m_dropdownButton.setStyle(style);
		return this;
	};

	/**
	 * Overrides the MPageUI.Dropdown.prototype.init function. This will initialize all children of the SplitButton.
	 * It first calls the super init function which initializes the menu object. This creates two buttons; a label
	 * button and a dropdown button.
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 */
	SplitButton.prototype.init = function() {
		var self = this;
		//Initialize the label and dropdown button
		this.m_labelButton = new MPageUI.Button();
		this.m_dropdownButton = new MPageUI.DropdownButton();
		this.m_dropdownButton.setOnClickCallback(function() {
			self.toggle();
		});
		this.m_menu = new MPageUI.StandardMPageMenu(this.m_dropdownButton.getId());
		return this;
	};

	/**
	 * Overrides the MPageUI.UIComponent.prototype.render function to return the SplitButton rendered as an html
	 * string.
	 * @returns {string} The SplitButton rendered as an html string.
	 */
	SplitButton.prototype.render = function() {
		var html = "<div id='" + this.m_id + "' class='btn-group'>";
		html += this.m_labelButton.render();
		html += this.m_dropdownButton.render();
		html += this.m_menu.render();
		return html + "</div>";
	};

	/**
	 * Attaches the necessary events to the SplitButton. This function must be called after the SplitButton
	 * exists on the DOM.
	 * @returns {undefined} Returns nothing.
	 */
	SplitButton.prototype.attachEvents = function() {
		this.m_labelButton.attachEvents();
		this.m_dropdownButton.attachEvents();
	};

	return SplitButton;
})();

MPageUI.ToggleButton = (function() {
	/**
	 * The ToggleButton class.
	 * @constructor
	 */
	var ToggleButton = function() {
		this.m_selected = false;
		this.m_onSelectCallback = null;
		this.m_onDeselectCallback = null;
		this.base();
	};
	MPageUI.extend(ToggleButton, MPageUI.Button);

	/**
	 * Determines if the toggle button is selected.
	 * @returns {boolean} A boolean indicating if the toggle button is selected or not.
	 */
	ToggleButton.prototype.isSelected = function() {
		return this.m_selected;
	};

	/**
	 * Selects the toggle button. This will do nothing if the toggle is already selected. Otherwise, the UI
	 * will be updated to reflect the selected state. If the consumer has provided an onSelect callback, that will be
	 * triggered.
	 * @returns {undefined} undefined
	 */
	ToggleButton.prototype.select = function() {
		//Simply return if the toggle is already selected
		if (this.m_selected) {
			return;
		}
		this.setSelected(true);
		if (this.m_onSelectCallback) {
			this.m_onSelectCallback();
		}
	};

	/**
	 * Deselects the toggle button. This will do nothing if the toggle is already deselected. Otherwise, the UI
	 * will be updated to reflect the deselected state. If the consumer has provided an onDeselect callback, that will be
	 * triggered.
	 * @returns {undefined} undefined
	 */
	ToggleButton.prototype.deselect = function() {
		//Simple return if the toggle is already deselected
		if (!this.m_selected) {
			return;
		}
		this.setSelected(false);
		if (this.m_onDeselectCallback) {
			this.m_onDeselectCallback();
		}
	};

	/**
	 * Overrides the base onClick function to provide toggle functionality. If the onClickCallback is set for the
	 * toggle button it will override the default behavior. Otherwise, it will toggle the state of the button
	 * between selected and deselected.
	 * @returns {undefined} undefined
	 */
	ToggleButton.prototype.onClick = function() {
		if (this.m_onClickCallback) {
			this.m_onClickCallback();
			return;
		}
		if (this.m_selected) {
			this.deselect();
		}
		else {
			this.select();
		}
	};

	/**
	 * Sets the callback function that is triggered when the toggle button is selected.
	 * @param {function} onSelectCallback - The callback function that is triggered when the toggle button is selected.
	 * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
	 */
	ToggleButton.prototype.setOnSelectCallback = function(onSelectCallback) {
		if (typeof onSelectCallback !== "function") {
			throw new Error("MPageUI.ToggleButton.prototype.setOnSelectCallback expects a function");
		}
		this.m_onSelectCallback = onSelectCallback;
		return this;
	};

	/**
	 * Sets the callback function that is triggered when the toggle button is deselected.
	 * @param {function} onDeselectCallback - The callback function that is triggered when the toggle button is deselected.
	 * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
	 */
	ToggleButton.prototype.setOnDeselectCallback = function(onDeselectCallback) {
		if (typeof onDeselectCallback !== "function") {
			throw new Error("MPageUI.ToggleButton.prototype.setOnDeselectCallback expects a function");
		}
		this.m_onDeselectCallback = onDeselectCallback;
		return this;
	};

	/**
	 * Sets the UI state of the toggle button to the provided selected state.
	 * @param {boolean} selected - The selected state of the toggle button. True is selected, false is deselected.
	 * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
	 */
	ToggleButton.prototype.setSelected = function(selected) {
		if (typeof selected !== "boolean") {
			throw new Error("MPageUI.ToggleButton.prototype.setActive expects a boolean");
		}
		var $rootElement = this.getRootElement();
		if (selected) {
			$rootElement.addClass("active");
		}
		else {
			$rootElement.removeClass("active");
		}
		this.m_selected = selected;
		return this;
	};

	/**
	 * Overrides the base render function. This renders the ToggleButton as an html string.
	 * @returns {string} The ToggleButton rendered as an html string.
	 */
	ToggleButton.prototype.render = function() {
		var disabled = this.m_disabled ? "disabled='true'" : "";
		var classes = "btn";
		var dataToggle = this.m_dataToggle ? ("data-toggle='" + this.m_dataToggle + "'") : "";
		classes += (this.m_size ? " " + this.m_size : "");
		classes += (this.m_shape ? " " + this.m_shape : "");
		classes += (this.m_style ? " " + this.m_style : "");
		classes += (this.m_selected ? " active" : "");
		return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + disabled + " " + dataToggle + ">" + this.m_label + "</button>";
	};

	return ToggleButton;
})();

/* global MPageUI */

MPageUI.DemoBanner = (function() {

	/**
	 * The DemoBanner class.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 * @constructor
	 */
	var DemoBanner = function() {
		//Super constructor
		this.base();

		this.m_name = "";
		this.m_age = 0;
		this.m_gender = "";
		this.m_dateOfBirth = null;
		this.m_isDeceased = false;
		this.m_dateOfDeath = null;
		this.m_location = "";
		this.m_identificationFields = null;
		this.m_contactInfoFields = null;

		return this;
	};
	MPageUI.extend(DemoBanner, MPageUI.UIComponent);

	/**
	 * Retrieves the name for the demoBanner.
	 * @returns {string} the name for the demoBanner.
	 */
	DemoBanner.prototype.getName = function() {
		return this.m_name;
	};

	/**
	 * Sets the name for the demoBanner.
	 * @param {string} name - The name for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setName = function(name) {
		this.m_name = name;
		return this;
	};

	/**
	 * Retrieves the age for the demoBanner.
	 * @returns {string} the age for the demoBanner.
	 */
	DemoBanner.prototype.getAge = function() {
		return this.m_age;
	};

	/**
	 * Sets the age for the demoBanner.
	 * @param {string} age - The age for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setAge = function(age) {
		this.m_age = age;
		return this;
	};

	/**
	 * Retrieves the date of birth for the demoBanner.
	 * @returns {string} the date of birth for the demoBanner.
	 */
	DemoBanner.prototype.getDOB = function() {
		return this.m_dateOfBirth;
	};

	/**
	 * Sets the date of birth for the demoBanner.
	 * @param {string} dob - The date of birth for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setDOB = function(dob) {
		this.m_dateOfBirth = dob;
		return this;
	};

	/**
	 * Retrieves the gender for the demoBanner.
	 * @returns {string} the gender for the demoBanner.
	 */
	DemoBanner.prototype.getGender = function() {
		return this.m_gender;
	};

	/**
	 * Sets the gender for the demoBanner.
	 * @param {string} sex - The gender for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setGender = function(sex) {
		this.m_gender = sex;
		return this;
	};

	/**
	 * Retrieves the deceased status for the demoBanner.
	 * @returns {boolean} the deceased status for the demoBanner.
	 */
	DemoBanner.prototype.getDeceasedIndicator = function() {
		return this.m_isDeceased;
	};

	/**
	 * Sets the deceased status for the demoBanner.
	 * @param {boolean} deceasedInd - The deceased status for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setDeceasedIndicator = function(deceasedInd) {
		this.m_isDeceased = deceasedInd;
		return this;
	};

	/**
	 * Retrieves the date of death for the demoBanner.
	 * @returns {string} the date of death.
	 */
	DemoBanner.prototype.getDateOfDeath = function() {
		return this.m_dateOfDeath;
	};

	/**
	 * Sets the date of death for the demoBanner.
	 * @param {string} dateOfDeath - The date of death.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setDateOfDeath = function(dateOfDeath) {
		this.m_dateOfDeath = dateOfDeath;
		return this;
	};

	/**
	 * Retrieves the location for the demoBanner.
	 * @returns {string} the location.
	 */
	DemoBanner.prototype.getLocation = function() {
		return this.m_location;
	};

	/**
	 * Sets the location for the demoBanner.
	 * @param {string} location  - The location for the demoBanner.
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 */
	DemoBanner.prototype.setLocation = function(location) {
		this.m_location = location;
		return this;
	};

	/**
	 * This function is used to add additional patient identifier fields.  Each new field will contain both a label
	 * and one or more value associated with those values to display with that label.
	 * Example. DemoBanner.addIdentifierField("MRNs", ["9B81A02E4193AE", "5B84868E41A"]);
	 * @param {string} label The label to display next to the value(s)
	 * @param {string|Array} values Either a single string value or an array of string values to display next to the label
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 **/
	DemoBanner.prototype.addIdentifierField = function(label, values) {
		if (!this.m_identificationFields) {
			this.m_identificationFields = [];
		}
		values = typeof values === "string" ? [values] : values;
		this.m_identificationFields.push({label: label, value: values});
		return this;
	};

	/**
	 * This function is used to add additional patient identifier fields.  Each new field will contain both a label
	 * and one or more value associated with those values to display with that label.
	 * @param {string} label The label to display next to the value(s)
	 * @param {string|Array} values Either a single string value or an array of string values to display next to the label
	 * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
	 **/
	DemoBanner.prototype.addContactInformationField = function(label, values) {
		if (!this.m_contactInfoFields) {
			this.m_contactInfoFields = [];
		}
		this.m_contactInfoFields.push({label: label, value: values});
		return this;
	};

	/**
	 * Builds the html for the demoBanner by including all the fields
	 * @returns {string} The DemoBanner rendered as an html string.
	 */
	DemoBanner.prototype.render = function() {
		var demoBannerHTML = "";
		//Render the Name, DOB, Sex and Location row
		demoBannerHTML += "<section id='" + this.m_id + "' class='demographics-banner'>";
		demoBannerHTML += "<header>";
		demoBannerHTML += "<div class='demographics-row'>";
		demoBannerHTML += "<h1>" + this.getName() + "</h1>";
		if (this.getLocation()) {
			demoBannerHTML += "<h1 title='" + this.getLocation() + "' class='demographics-location'>" + this.getLocation() + "</h1>";
		}
		demoBannerHTML += "</div>";
		demoBannerHTML += "<div class='demographics-row'>";
		demoBannerHTML += "<span class='demographics-single'>";
		if (this.getDOB()) {
			demoBannerHTML += i18n.DOB + ": " + "<b>" + (this.getDOB() || "") + "</b>";
		}
		if (this.getGender()) {
			demoBannerHTML += i18n.SEX + ": " + "<b>" + this.getGender() + "</b>";
		}
		//Render the identification row
		var idFields = this.m_identificationFields;
		var idFieldCnt = 0;
		if (idFields) {
			idFieldCnt = idFields.length;
			for (var x = 0; x < idFieldCnt; x++) {
				demoBannerHTML += idFields[x].label + ": " + "<b>" + idFields[x].value.join(",") + "</b>";
			}
		}
		demoBannerHTML += "</span></div></header></section>";
		return demoBannerHTML;
	};

	return DemoBanner;
})();




/* global MPageUI */
/**
 * Enumeration for AlertBanner options.
 * @readonly
 */
MPageUI.ALERT_OPTIONS = {
	TYPE: {
		INFO: "info-msg",
		SUCCESS: "success-msg",
		WARNING: "warning-msg",
		ERROR: "error-msg",
		SEVERE: "severe-msg",
		ADVISORY: "advisory-msg"
	}
};

MPageUI.AlertBanner = (function() {
	/**
	 * The MPageUI.AlertBanner class.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 * @constructor
	 */
	var AlertBanner = function() {
		this.base();
		this.m_dismissible = false;
		this.m_primaryText = "";
		this.m_secondaryText = "";
		this.m_time = null;
		this.m_bannerType = "";
		this.m_closeFunction = null;
		return this;
	};
	MPageUI.extend(AlertBanner, MPageUI.UIComponent);
	/* eslint-disable no-unused-vars */
	/**
	 * Sets whether the AlertBanner is dismissible or not.
	 * @param {boolean} dismissible - A boolean indicating if the AlertBanner is dismissible or not. True if it is dismissible,
	 * otherwise false.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setDismissible = function(dismissible) {
		//Check dismissible
		if (typeof dismissible !== "boolean") {
			throw new Error("AlertBanner.prototype.setDismissible expects a boolean.");
		}
		//Set dismissible
		this.m_dismissible = dismissible;
		return this;
	};
	/* eslint-enable no-unused-vars */
	/**
	 * Sets the primary text to be displayed in the alert.
	 * @param {string} primaryText - The primary text to be displayed in the alert banner.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setPrimaryText = function(primaryText) {
		//Check text
		if (typeof primaryText !== "string") {
			throw new Error("AlertBanner.prototype.setPrimaryText expects a string.");
		}
		//Set primary text
		this.m_primaryText = primaryText;
		return this;
	};
	/**
	 * Sets the secondary text to be displayed in the alert.
	 * @param {string} secondaryText - The secondary text to be displayed in the alert banner.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setSecondaryText = function(secondaryText) {
		//Check text
		if (typeof secondaryText !== "string") {
			throw new Error("AlertBanner.prototype.setSecondaryText expects a string.");
		}
		//Set secondary text
		this.m_secondaryText = secondaryText;
		return this;
	};
	/* eslint-disable no-unused-vars */
	/**
	 * Hides the alert banner
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining..
	 */
	AlertBanner.prototype.hide = function(){
		//hide the alert banner
		this.getRootElement().hide();
		return this;
	};
	
	/**
	 * Displays the alert banner
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.show = function(){
		//shows the alert banner and returns self
		this.getRootElement().show();
		return this;
	};
	/**
	 * Returns the function to be executed when close button is clicked
	 * 
	 * @returns {AlertBanner.m_closeFunction} the function to close the alert banner
	 */
	AlertBanner.prototype.getCloseFunction = function() {
		return this.m_closeFunction;
	};

	/**
	 * Sets the close function
	 * 
	 * @param {closeFunction}
	 *            closeFunction The function which is executed when we click on the close button 
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setCloseFunction = function(closeFunction) {
		if (typeof closeFunction !== "function") {
			throw new Error("AlertBanner.prototype.setCloseFunction expects a function.");
		}
		this.m_closeFunction = closeFunction;
		return this;
	};
	/**
	 * Sets the amount of time (in seconds) the AlertBanner will remain before disappearing.
	 * @param {number} timeInSeconds - The amount of time (in seconds) the AlertBanner will remain before disappearing.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setTime = function(timeInSeconds) {
		//Check time
		//Set time
		return this;
	};
	/* eslint-enable no-unused-vars */
	/**
	 * Sets the alert type. This must be a choice from the MPageUI.ALERT_OPTIONS.type enumeration.
	 * @param {string} type - The type of alert banner to be created.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.setType = function(type) {
		if (typeof type !== "string") {
			throw new Error("AlertBanner.prototype.setType expects a string.");
		}
		this.m_bannerType = type;
		return this;
	};
	/**
	 * Renders the Alert as an html string.
	 * @returns {string} The AlertBanner rendered as an html string.
	 */
	AlertBanner.prototype.render = function() {
		var bannerHTML = "";
		if (this.m_bannerType === "") {
			throw new Error("AlertBanner.prototype.render expects a valid banner type from MPageUI.ALERT_OPTIONS.TYPE");
		}
		//Construct banner rendering HTML
		bannerHTML = "<div id='" + this.m_id + "' class='alert-msg'>";
		bannerHTML += "<div class = '" + this.m_bannerType + "'>";
		bannerHTML += "<div class='alert-info'><span class='alert-icon'>&nbsp;</span>" + this.m_primaryText;
		bannerHTML += "<span class='alert-msg-secondary-text'>&nbsp;" + this.m_secondaryText + "</span></div>";
		if(this.m_dismissible){	
			bannerHTML += "<span id='alertClose" + this.m_id + "' class='alert-close-option'>&nbsp;</span>";
		}
		return bannerHTML + "</div></div>";

	};
	/**
	 * Attaches the necessary events to the close button. This function must be called after the alert banner
	 * markup exists on the DOM.
	 * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
	 */
	AlertBanner.prototype.attachEvents = function() {
		var self = this;
		self.getRootElement().on('click', "#alertClose" + self.m_id, function() {
			self.getCloseFunction()();
		});
		return self;
	};
	return AlertBanner;
})();


/* global MPageUI */

MPageUI.POPUP_OPTIONS = {
	POSITION: {
		RIGHT: "right",
		LEFT: "left",
		TOP: "top",
		TOP_RIGHT: "top-right",
		TOP_LEFT: "top-left",
		BOTTOM: "bottom",
		BOTTOM_RIGHT: "bottom-right",
		BOTTOM_LEFT: "bottom-left"
	},
	WIDTH: {
		SMALL: 200,
		MEDIUM: 400,
		LARGE: 600
	}
};

MPageUI.Popup = (function() {
	/**
	 * The Popup class.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 * @constructor
	 */
	var Popup = function() {
		//Super constructor
		this.base();
		this.m_headerHTML = "";
		this.m_bodyHTML = "";
		this.m_footerHTML = "";
		this.m_anchorId = "";
		this.m_position = MPageUI.POPUP_OPTIONS.POSITION.BOTTOM;
		this.m_width = MPageUI.POPUP_OPTIONS.WIDTH.SMALL;
		this.m_maxBodyHeight = "400px";
		this.m_popupExistsFlag = false;
		this.m_popupShowingFlag = false;
		return this;
	};

	MPageUI.extend(Popup, MPageUI.UIComponent);

	/**
	 * Returns whether the popup exists or not
	 * @returns {boolean} true or false based on if the popup exists or not
	 */
	Popup.prototype.exists = function() {
		return this.m_popupExistsFlag;
	};

	/**
	 * Returns whether the popup is open or not
	 * @returns {boolean} true or false based on if the popup is open or not
	 */
	Popup.prototype.isOpen = function() {
		return this.m_popupShowingFlag;
	};


	/**
	 * Calls the create and show functions. This function was only created to
	 * allow the sampler to call .render. It should not be used by
	 * external callers
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Popup.prototype.render = function() {
		this.show();
	};

	/**
	 * Creates the popup using the tooltipster plugin
	 * @throws {Error} An error indicating that the anchor id should already be set
	 * @private
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.create = function() {
		if (!this.m_anchorId) {
			throw new Error("MPageUI.Popup.prototype.create expects the anchor id to be set.");
		}

		var self = this;
		var anchorSelector = "#" + this.m_anchorId;
		var popupHTML = "";

		if (this.m_headerHTML) {
			popupHTML += "<div class='mpage-ui-popup-header'>" + this.m_headerHTML + "</div>";
		}

		popupHTML += "<div class='mpage-ui-popup-body' id='" + this.m_id + "' style='max-height:" + this.m_maxBodyHeight + "'>" + this.m_bodyHTML + "</div>";

		if (this.m_footerHTML) {
			popupHTML += "<div>" + this.m_footerHTML + "</div>";
		}

		$(anchorSelector).tooltipster({
			content: $(popupHTML),
			interactive: true,
			maxWidth: self.m_width,
			minWidth: self.m_width,
			position: self.m_position,
			restoration: "none",
			theme: "mpage-ui-popup",
			trigger: "custom",
			speed: 0
		});

		this.m_popupExistsFlag = true;

		return this;
	};

	/**
	 * Destroys the popup using and clears some member level variables
	 * @throws {Error} An error indicating that the anchor id should already be set
	 * @deprecated
	 * @private
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.destroy = function() {
		if (!this.m_anchorId) {
			throw new Error("MPageUI.Popup.prototype.destroy expects the anchor id to be set.");
		}
		//If the popup does not exist, then there is nothing to destroy
		if (!this.m_popupExistsFlag) {
			return this;
		}
		//destroy the popup
		var anchorSelector = "#" + this.m_anchorId;
		$(anchorSelector).tooltipster("destroy");
		//clear the member level variables
		this.m_popupExistsFlag = false;
		this.m_popupShowingFlag = false;
		this.m_headerHTML = "";
		this.m_bodyHTML = "";
		this.m_footerHTML = "";
		return null;
	};

	/**
	 * Shows the popup
	 * @throws {Error} An error indicating that the anchor id should already be set
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.show = function() {
		if (!this.m_anchorId) {
			throw new Error("MPageUI.Popup.prototype.show expects the anchor id to be set.");
		}

		//If the popup is already showing, no need to show again, just return self to allow chaining
		if (this.m_popupShowingFlag) {
			return this;
		}

		//If the popup does not already exist, call create
		if (!this.m_popupExistsFlag) {
			this.create();
		}

		var anchorSelector = "#" + this.m_anchorId;
		$(anchorSelector).tooltipster("show");
		this.m_popupShowingFlag = true;

		return this;
	};

	/**
	 * Hides the popup
	 * @throws {Error} An error indicating that the anchor id should already be set
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.hide = function() {
		if (!this.m_anchorId) {
			throw new Error("MPageUI.Popup.prototype.hide expects the anchor id to be set.");
		}

		//if the popup is showing, hide it
		if (this.m_popupShowingFlag) {
			var anchorSelector = "#" + this.m_anchorId;
			$(anchorSelector).tooltipster("hide");
			this.m_popupShowingFlag = false;
		}
		return this;
	};

	/**
	 * Toggles the popup to show and hide as needed
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.toggle = function() {
		if (this.m_popupShowingFlag) {
			this.hide();
		}
		else {
			this.show();
		}
		return this;
	};

	/**
	 * Sets the anchor id of the popup. This is the id of the element the popup should anchor to.
	 * @param {string} anchorId - The anchor id of popup
	 * @throws {Error} An error indicating that the anchor id parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setAnchorId = function(anchorId) {
		if (typeof anchorId !== "string") {
			throw new Error("MPageUI.Popup.prototype.setAnchorId expects a string.");
		}
		this.m_anchorId = anchorId;
		return this;
	};

	/**
	 * Sets the header of the popup
	 * @param {string} headerText - The header text to display in the popup
	 * @throws {Error} An error indicating that the header text parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setHeader = function(headerText) {
		if (typeof headerText !== "string") {
			throw new Error("MPageUI.Popup.prototype.setHeader expects a string.");
		}
		this.m_headerHTML = headerText;

		if (this.m_popupExistsFlag) {
			this.changePopupContent();
		}

		return this;
	};

	/**
	 * Sets the body content of the popup
	 * @param {string} bodyHTML - The body html string to display in the popup
	 * @throws {Error} An error indicating that the body html parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setBodyContent = function(bodyHTML) {
		if (typeof bodyHTML !== "string") {
			throw new Error("MPageUI.Popup.prototype.setBodyContent expects a string.");
		}

		this.m_bodyHTML = bodyHTML;

		if (this.m_popupExistsFlag) {
			this.changePopupContent();
		}

		return this;
	};

	/**
	 * Sets the footer of the popup
	 * @param {string} footerHTML - The footer html string to display in the popup
	 * @throws {Error} An error indicating that the footer html parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setFooter = function(footerHTML) {
		if (typeof footerHTML !== "string") {
			throw new Error("MPageUI.Popup.prototype.setFooter expects a string.");
		}
		this.m_footerHTML = footerHTML;

		if (this.m_popupExistsFlag) {
			this.changePopupContent();
		}

		return this;
	};

	/**
	 * Sets the position of the popup
	 * @param {string} position - The position string of the popup
	 * @throws {Error} An error indicating that the position parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setPosition = function(position) {
		if (typeof position !== "string") {
			throw new Error("MPageUI.Popup.prototype.setPosition expects a string.");
		}
		this.m_position = position;
		return this;
	};

	/**
	 * Sets the width of the popup
	 * @param {number} width - The width of the popup
	 * @throws {Error} An error indicating that the width parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setWidth = function(width) {
		if (typeof width !== "number") {
			throw new Error("MPageUI.Popup.prototype.setWidth expects a number.");
		}
		this.m_width = width;
		return this;
	};

	/**
	 * Sets the max body height of the popup (not the whole popup height). Should be passed
	 * as "400px" or "20%".
	 * @param {string} bodyMaxHeight - The maximum body height string of the popup
	 * @throws {Error} An error indicating that the position parameter is an invalid type.
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.setMaxBodyHeight = function(bodyMaxHeight) {
		if (typeof bodyMaxHeight !== "string") {
			throw new Error("MPageUI.Popup.prototype.setMaxBodyHeight expects a string.");
		}
		this.m_maxBodyHeight = bodyMaxHeight;
		return this;
	};

	/**
	 * Updates any of the three areas of the popup content. This function is called by
	 * other functions when a content area is set and the popup already exists
	 * @throws {Error} An error indicating that the anchor id should already be set
	 * @private
	 * @returns {MPageUI.Popup} Returns self to allow chaining.
	 */
	Popup.prototype.changePopupContent = function() {
		if (!this.m_anchorId) {
			throw new Error("MPageUI.Popup.prototype.changePopupContent expects the anchor id to be set.");
		}

		var popupHTML = "";
		var anchorSelector = "#" + this.m_anchorId;

		if (this.m_headerHTML) {
			popupHTML += "<div class='mpage-ui-popup-header'>" + this.m_headerHTML + "</div>";
		}

		popupHTML += "<div class='mpage-ui-popup-body' style='max-height:" + this.m_maxBodyHeight + "'>" + this.m_bodyHTML + "</div>";

		if (this.m_footerHTML) {
			popupHTML += "<div>" + this.m_footerHTML + "</div>";
		}

		$(anchorSelector).tooltipster("content", $(popupHTML));
		return this;
	};

	return Popup;
})();

/* global MPageUI */

MPageUI.SEGMENTED_CONTROL_OPTIONS = {
	SELECT_MODE: {
		SINGLE: 0,
		MULTI: 1
	}
};

MPageUI.SegmentedControl = (function() {
	/**
	 * The SegmentedControl class.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 * @constructor
	 */
	var SegmentedControl = function() {
		this.m_selectedSegments = null;
		this.m_segments = null;
		this.m_selectMode = MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE.SINGLE;
		this.base();
		return this;
	};
	MPageUI.extend(SegmentedControl, MPageUI.UIComponent);

	/**
	 * Retrieves the list of all selected segments.
	 * @private
	 * @returns {Array<Object>} The array of selected segments.
	 */
	SegmentedControl.prototype.getSelectedSegments = function() {
		if (!this.m_selectedSegments) {
			this.m_selectedSegments = [];
		}
		return this.m_selectedSegments;
	};

	/**
	 * Retrieves the list of all segments.
	 * @private
	 * @returns {Array<Object>} The array of segments.
	 */
	SegmentedControl.prototype.getSegments = function() {
		if (!this.m_segments) {
			this.m_segments = [];
		}
		return this.m_segments;
	};

	/**
	 * Sets the selection mode for the SegmentedControl. This will determine the behavior when the user interacts with
	 * the control.
	 * @param {number} selectMode - The selection mode for the SegmentedControl. This must be chosen from the
	 * MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE enumeration.
	 * @throws {Error} An error indicating that the provided option was not valid.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.setSelectMode = function(selectMode) {
		if (typeof selectMode !== "number") {
			throw new Error("MPageUI.SegmentedControl.prototype.setSelectMode expects an integer");
		}
		this.m_selectMode = selectMode;
		return this;
	};

	/**
	 * Activates a single segment object. This will add the segment to the list of selected segments and add an
	 * active class to the root element of the segment.
	 * @private
	 * @param {Object} segmentObject - The segment object to be activated.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.selectSegment = function(segmentObject) {
		//Update the UI
		var $segmentRootElement = segmentObject.uiComponent.getRootElement();
		$segmentRootElement.addClass("active");
		//Store the selected segment
		this.getSelectedSegments().push(segmentObject);
		//If the onSelect function has been provided for the segment
		if (segmentObject.segment.onSelect) {
			segmentObject.segment.onSelect.call(segmentObject.segment);
		}
		return this;
	};

	/**
	 * Deactivates a single segment object. This will remove the segment from the list of selected segments and remove
	 * the active class from the root element of the segment.
	 * @private
	 * @param {Object} segmentObject - The segment object to be deactivated.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.deselectSegment = function(segmentObject) {
		//Update the UI
		var $segmentRootElement = segmentObject.uiComponent.getRootElement();
		$segmentRootElement.removeClass("active");
		var selectedSegments = this.getSelectedSegments();
		var selectedSegmentCount = selectedSegments.length;
		//Loop through the list of selected segments and remove the specified segment from the list
		for (var i = 0; i < selectedSegmentCount; i++) {
			if (selectedSegments[i] === segmentObject) {
				selectedSegments.splice(i, 1);
				//If the onDeselect function has been provided for the segment
				if (segmentObject.segment.onDeselect) {
					segmentObject.segment.onDeselect.call(segmentObject.segment);
				}
				break;
			}
		}
		return this;
	};
	/**
	 * This function will validate a provided segment. If the segment is not valid, an exception will be thrown to
	 * inform the consumer.
	 * @param {Object} segment - The segment to be verified.
	 * @private
	 * @throws {Error} An error indicating that the provided segment was not valid.
	 * @returns {undefined} Returns nothing.
	 */
	SegmentedControl.prototype.validateSegment = function(segment) {
		if (typeof segment !== "object") {
			throw new Error("MPageUI.SegmentedControl.prototype.validateSegment expects an object");
		}
		//validate label 
		if (!segment.label) {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: label is required for this segment.");
		}
		//validate id 
		if (segment.id && typeof segment.id !== "string") {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the label must be a string.");
		}
		//validate disabled 
		if (segment.selected && typeof segment.selected !== "boolean") {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the selected attribute must be a boolean.");
		}
		//validate disabled 
		if (segment.disabled && typeof segment.disabled !== "boolean") {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the disabled attribute must be a boolean.");
		}
		//validate onSelect callback 
		if (!segment.onSelect) {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: onSelect callback is required for this segment.");
		}
		if (typeof segment.onSelect !== "function") {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the onSelect callback must be a function.");
		}
		//validate onDeselect callback 
		if (segment.onDeselect && typeof segment.onDeselect !== "function") {
			throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the onDeselect callback must be a function.");
		}
	};
	/**
	 * This function will disable the segment with a given index position
	 * @param  {number} index The index of the segment to be activated
	 * @throws {Error} An error is thrown if an invalid index is provided.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.disableSegmentAtIndex = function(index) {
		var segments = this.getSegments();
		var segment = null;
		if (index < 0 || index >= segments.length) {
			throw new Error("SegmentedControl.prototype.selectSegmentAtIndex expects an integer between 0 and the number of segments.");
		}
		segment = segments[index];
		//check if segment is selected deselect it
		if (this.isSegmentAtIndexSelected(index)) {
			this.deselectSegment(segment);
		}
		//set the segment as disabled
		segment.uiComponent.setDisabled(true);

		return this;
	};
	/**
	 * This private function will take a segment id as a parameter and return the segment with that id
	 * if there is no segment with the given id the function will return null
	 * @param  {String} id - The id of the segment.
	 * @throws {Error} An error is thrown if an invalid id is provided.
	 * @private
	 * @returns {MPageUI.SegmentedControl}    Returns the segment with the given id.
	 */
	SegmentedControl.prototype.getSegmentById = function(id) {
		//validate id to be a string
		if (typeof id !== "string") {
			throw new Error("SegmentedControl.prototype.deselectSegmentById expects id to be a string.");
		}
		var segments = this.getSegments();
		var segmentCount = segments.length;
		var segment = null;
		for (var i = 0; i < segmentCount; i++) {
			segment = segments[i];
			if (segment.segment.id === id) {
				return segment;
			}
		}
		return null;
	};
	/**
	 * This function will take a segment id as a parameter and deselect it
	 * @param  {String} id - The id of the segment
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.deselectSegmentById = function(id) {
		//get the segment with the id
		var segment = this.getSegmentById(id);
		var selectedSegments = null;
		if (segment) {
			//get all selected segments
			selectedSegments = this.getSelectedSegments();
			var selectedSegmentsCount = selectedSegments.length;
			//check if the segment is selected and deselect it
			for (var i = 0; i < selectedSegmentsCount; i++) {
				if (selectedSegments[i] === segment) {
					this.deselectSegment(segment);
				}
				break;
			}
		}
		return this;
	};
	/**
	 * This function will take a segment id as a parameter and change the state of the segment
	 * with the given id to disabled
	 * @param  {String} id - Segment id
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.disableSegmentById = function(id) {
		var segment = this.getSegmentById(id);
		//deselect the segment
		this.deselectSegmentById(id);
		//set the segment as disabled
		segment.uiComponent.setDisabled(true);
		return this;
	};
	/**
	 * This is a consumer-facing function that allows a segment to be activated via its index. The index is 0-based.
	 * @param {number} index - The index of the segment to be activated.
	 * @throws {Error} An error is thrown if an invalid index is provided.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.selectSegmentAtIndex = function(index) {
		var segments = this.getSegments();
		var segment = null;
		if (index < 0 || index >= segments.length) {
			throw new Error("SegmentedControl.prototype.selectSegmentAtIndex expects an integer between 0 and the number of segments.");
		}
		segment = segments[index];
		//Use the handle selection function
		this.handleSelection(segment);
		return this;
	};

	/**
	 * This is a consumer-facing function that allows a segment to be activated via its index. The index is 0-based.
	 * @param {number} index - The index of the segment to be activated.
	 * @throws {Error} An error is thrown if an invalid index is provided.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.deselectSegmentAtIndex = function(index) {
		var segments = this.getSegments();
		var segment = null;
		var selectedIndex = null;
		if (index < 0 || index >= segments.length) {
			throw new Error("MPageUI.SegmentedControl.prototype.deselectSegmentAtIndex expects a number between 0 and the number of segments.");
		}
		segment = segments[index];
		selectedIndex = this.getSelectedSegmentIndex(segment);
		//If the segment is already inactive
		if (selectedIndex < 0) {
			return this;
		}
		this.deselectSegment(segment);
		return this;
	};

	/**
	 * Returns a boolean indicating if the segment at the provided index is selected or not.
	 * @param {number} index - The index of the segment that is being checked.
	 * @throws {Error} An error is thrown if an invalid index is provided.
	 * @returns {boolean} True if the segment is selected otherwise false.
	 */
	SegmentedControl.prototype.isSegmentAtIndexSelected = function(index) {
		var segments = this.getSegments();
		if (index < 0 || index >= segments.length) {
			throw new Error("MPageUI.SegmentedControl.prototype.isSegmentAtIndexSelected expects a number between 0 and the number of segments.");
		}
		return this.getSelectedSegmentIndex(segments[index]) > -1;
	};

	/**
	 * Retrieves the index where the segment is within the array of selected segments. If the segment is not selected
	 * (not present in the array of selected segments), -1 will be returned.
	 * @param {Object} segment - The segment object for which we are retrieving the position in the array of selected
	 * segments.
	 * @private
	 * @returns {number} The index of the segment in the array of selected segments. Returns -1 if the segment was not
	 * found.
	 */
	SegmentedControl.prototype.getSelectedSegmentIndex = function(segment) {
		var segments = this.getSelectedSegments();
		var segmentCount = segments.length;
		for (var i = 0; i < segmentCount; i++) {
			if (segments[i] === segment) {
				return i;
			}
		}
		//Segment is not within the array of selected segments
		return -1;
	};

	/**
	 * Handles the selection of a segment object.
	 * @param {Object} segment - The segment object for which selection is being handled.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	SegmentedControl.prototype.handleSelection = function(segment) {
		var selectionModeEnum = MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE;
		//Checks if the segment is selected
		var selectedIndex = this.getSelectedSegmentIndex(segment);
		switch (this.m_selectMode) {
			//Multi selection mode
			case selectionModeEnum.MULTI:
				if (selectedIndex > -1) {
					this.deselectSegment(segment);
				}
				else {
					this.selectSegment(segment);
				}
				break;
			case selectionModeEnum.SINGLE:
			default:
				//Only do work if the segment is not selected
				if (selectedIndex < 0) {
					this.deselectAllSegments();
					this.selectSegment(segment);
				}
				break;
		}
	};

	/**
	 * Deactivates all segments. It first iterates over all selected segments, calling their onDeselect callback if
	 * provided.
	 * @returns {undefined} Returns nothing.
	 */
	SegmentedControl.prototype.deselectAllSegments = function() {
		var $rootElement = this.getRootElement();
		$rootElement.find(".active").removeClass("active");
		var selectedSegments = this.getSelectedSegments();
		var selectedSegmentCount = selectedSegments.length;
		var selectedSegment = null;
		for (var i = 0; i < selectedSegmentCount; i++) {
			selectedSegment = selectedSegments[i];
			if (selectedSegment.segment.onDeselect) {
				selectedSegment.segment.onDeselect.call(selectedSegment.segment);
			}
		}
		this.m_selectedSegments = [];
	};

	/**
	 * Adds a segment to the SegmentedControl. The segment
	 * @param {Object} segment - The segment to be added to the SegmentedControl. This must be of the following form.
	 * {
	 * 		id: 'segmentId' 
	 * 		label: 'Label', 
	 * 		selected: 'true/false' [optional - false if not set]
	 * 		disabled: true/false, [optional - false if not set]
	 * 		onSelect:	function() { ... }, 
	 * 		onDeselect: function() { ... } 
	 * }
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.addSegment = function(segment) {
		this.validateSegment(segment);
		var segmentObject = null;
		var segments = this.getSegments();
		var button = new MPageUI.ToggleButton();
		var self = this;
		button.setLabel(segment.label);
		button.setSelected(segment.selected || false);
		button.setDisabled(segment.disabled || false);
		button.setOnClickCallback(function() {
			self.handleSelection(segmentObject);
		});
		//Create a wrapping segment object which stores
		segmentObject = {
			"segment": segment,
			"uiComponent": button
		};
		segments.push(segmentObject);
		if (segment.selected) {
			this.getSelectedSegments().push(segmentObject);
		}
		return this;
	};

	/**
	 * Renders the SegmentedControl as an html string.
	 * @returns {string} The SegmentedControl rendered as an html string.
	 */
	SegmentedControl.prototype.render = function() {
		var segments = this.getSegments();
		var segmentCount = segments.length;
		var html = "<div id='" + this.m_id + "' class='btn-group'>";
		for (var i = 0; i < segmentCount; i++) {
			html += segments[i].uiComponent.render();
		}
		return html + "</div>";
	};

	/**
	 * Attaches the events to the segments.
	 * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
	 */
	SegmentedControl.prototype.attachEvents = function() {
		var segments = this.getSegments();
		var segmentCount = segments.length;
		for (var i = 0; i < segmentCount; i++) {
			segments[i].uiComponent.attachEvents();
		}
		return this;
	};

	/**
	 * Runs through each segment and clears the element cache for each component.
	 * @returns {undefined} Returns nothing.
	 */
	SegmentedControl.prototype.clearElementCache = function() {
		var segments = this.getSegments();
		var segmentCount = segments.length;
		for (var i = 0; i < segmentCount; i++) {
			segments[i].uiComponent.clearElementCache();
		}
	};

	return SegmentedControl;
})();

/* global MPageUI */

MPageUI.Grouper = (function() {
	/**
	 * The Grouper class.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 * @constructor
	 */
	var Grouper = function() {
		//Super constructor
		this.base();
		this.m_headerHTML = "";
		this.m_bodyHTML = "";
		this.m_isCollapsed = false;
		this.m_addIconCssClass = "";
	};

	MPageUI.extend(Grouper, MPageUI.UIComponent);

	/**
	 * Renders the grouper by generating and appending the HTML on the DOM.
	 * @returns {String} Returns the html representing the content of the grouper
	 */
	Grouper.prototype.render = function() {
		var html = "";
		var collapseCss = this.m_isCollapsed ? "collapsed" : "expanded";
		var hideCss = this.m_isCollapsed ? "mpage-ui-grouper-hide" : "";

		html += "<form class='mpage-ui-grouper' id='" + this.m_id + "'>"
		+ "<fieldset class='mpage-ui-grouper-content " + hideCss + "'>"
		+ "<legend class='mpage-ui-grouper-header'>"
		+ "<div class='collapse " + collapseCss + "'></div>"
		+ "<div class='sec-hdr'>" + this.m_headerHTML + "</div>"
		+ "<div class='mpage-ui-add-icon " + this.m_addIconCssClass + "'></div>"
		+ "</legend>"
		+ "<div class='mpage-ui-grouper-body'>"
		+ this.m_bodyHTML
		+ "</div>"
		+ "</fieldset>"
		+ "</form>";

		return html;
	};

	/**
	 * Attach event to DOM elements once the HTML has been rendered.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.attachEvents = function() {
		var self = this;

		//Expand/Collapse sections
		$("#" + this.m_id).find(".mpage-ui-grouper-content .collapse").on("click", function() {
			self.onClick(this);
		});

		return this;
	};

	/**
	 * Sets the header/title of the Grouper. This is the text listed at the top of the grouper.
	 * @param {string} header - The header of Grouper
	 * @throws {Error} An error indicating that the header parameter is an invalid type.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.setHeader = function(header) {
		if (typeof header !== "string") {
			throw new Error("MPageUI.Grouper.prototype.setHeader expects a string.");
		}
		this.m_headerHTML = header;

		return this;
	};

	/**
	 * Sets the content of the Grouper. This is the text listed in the body of the grouper.
	 * @param {string} body - The content of Grouper
	 * @throws {Error} An error indicating that the header parameter is an invalid type.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.setBody = function(body) {
		if (typeof body !== "string") {
			throw new Error("MPageUI.Grouper.prototype.setBody expects a string.");
		}
		this.m_bodyHTML = body;

		return this;
	};


	/**
	 * Sets whether or not the grouper should be collapsed on load.
	 * @param {Boolean} isCollapsed - A boolean indicating whether or not the grouper is collapsed.
	 * @throws {Error} An error indicating that the isCollapsed parameter is an invalid type.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.setIsCollapsed = function(isCollapsed) {
		if (typeof isCollapsed !== "boolean") {
			throw new Error("MPageUI.Grouper.prototype.setIsCollapsed expects a boolean.");
		}
		this.m_isCollapsed = isCollapsed;

		return this;
	};

	/**
	 * Sets a CSS class which would have URL to different icons that should be applied to the right of the header.
	 * @param {String} cssClass - A string representing the CSS class to be applied to the header
	 * @throws {Error} An error indicating that the cssClass parameter is an invalid type.
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.setAddIconCssClass = function(cssClass) {
		if (typeof cssClass !== "string") {
			throw new Error("MPageUI.Grouper.prototype.setShowAddIcon expects a string.");
		}
		this.m_addIconCssClass = cssClass;

		return this;
	};

	/**
	 * Expands the grouper
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.expand = function() {
		var $compId = $("#" + this.m_id);

		$compId.find(".mpage-ui-grouper-content .collapse").addClass("expanded").removeClass("collapsed");
		$compId.find(".mpage-ui-grouper-content").removeClass("mpage-ui-grouper-hide");
		this.setIsCollapsed(false);

		return this;
	};

	/**
	 * Collapses the grouper
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.collapse = function() {
		var $compId = $("#" + this.m_id);

		$compId.find(".mpage-ui-grouper-content .collapse").addClass("collapsed").removeClass("expanded");
		$compId.find(".mpage-ui-grouper-content").addClass("mpage-ui-grouper-hide");
		this.setIsCollapsed(true);

		return this;
	};

	/**
	 * Updates the body with the current private variables
	 * @param {string} body - The content of Grouper
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.updateBody = function(body) {
		var $compId = $("#" + this.m_id);

		this.setBody(body);
		$compId.find(".mpage-ui-grouper-body").html(this.m_bodyHTML);
		return this;
	};

	/**
	 * Updates the header with the current private variables
	 * @param {string} header - The header of Grouper
	 * @returns {MPageUI.Grouper} Returns self to allow chaining.
	 */
	Grouper.prototype.updateHeader = function(header) {
		var $compId = $("#" + this.m_id);

		this.setHeader(header);
		$compId.find(".sec-hdr").html(this.m_headerHTML);
		return this;
	};

	/**
	 * Defined click events for the expand/collapse functions
	 * @param {string} elem - The The window element clicked on
	 * @returns {Undefined} Returns nothing.
	 */
	Grouper.prototype.onClick = function(elem) {
		if ($(elem).hasClass("collapsed")) {
			this.expand();
		} else {
			this.collapse();
		}
	};

	return Grouper;
})();

/* global MPageUI */

MPageUI.TabControl = (function() {

	/**
	 * The TabControl class.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 * @constructor
	 */
	var TabControl = function() {
		//calls super class
		this.base();
		//total width of the tab controller
		this.m_totalWidth = null;
		//to store the list of tabs in the tab controller
		this.m_tabs = null;
		//flag to have the close tab option for the tabs
		this.m_canCloseTabs = false;
		//A flag to store the state of whether the scroll control should be shown given the current width of the control.
		this.m_displayScroller = false;
		// flag to have the drag and drop option for the tabs
		this.m_canSortTabs = false;
		// flag to have count option for tabs
		this.m_enableLabelCount = false;
		//callback function for the click/activate tab events
		this.m_onSelectCallback = null;
		//callback function for the deactivate tab events
		this.m_onDeselectCallback = null;
		//callback function for closing the tab
		this.m_onCloseCallback = null;
		//callback function for drag and drop option
		this.m_onSortCallback = null;
		//to have the default tab id
		this.m_defaultTab = null;
		//to store the list of activated tabs
		this.m_alreadyActivatedTabs = null;
		//to store the number of tabs shown
		this.m_numberOfTabsShown = null;
		//to store the index of the first tab shown
		this.m_firstTabIndex = 0;
		//to store which tab is currently active
		this.m_currentActiveTab = null;
		//to store the space for scroll elements(left and right arrow)
		this.m_scrollerWidth = 70;
		//to store the parent width of the tab controller
		this.m_parentWidth = null;
		//A flag to store whether the tabControl has been finalized or not.
		this.m_tabControlFinalized  = false;

		return this;
	};
	MPageUI.extend(TabControl, MPageUI.UIComponent);
	
	/**
	 * Flag indicating if a count needs to be shown on the tab
	 * @param {boolean} enableLabelCount - The flag to set the display state for tab label to have count.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setEnableLabelCount = function(enableLabelCount) {
		if ( typeof enableLabelCount !== "boolean") {
			throw new Error("TabControl.prototype.setEnableLabelCount expects a boolean.");
		}
		this.m_enableLabelCount = enableLabelCount;
		return this;
	};
	
	/**
	 * Update count label for a tab. The tab control must be rendered for this function
	 * @param {JSON} tab - tab for which count is to be updated
	 * @param {number} count - count on the tab to be updated
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.updateCountOnTab = function(tab, count) {
		this.validateTab(tab);
		
		if (typeof count !== "number"){
			throw new Error("MPageUI.TabControl.prototype.updateCountOnTab expects a number");
		}
		var countElement = $('#countTab' + tab.id);
		countElement.empty();
		countElement.append("(" + count + ")");
		this.resize(true);
	
		return this;
	};
	
	/**
	 * Update indicator on a tab. The tab control must be rendered for this function
	 * @param {JSON} tab - tab for which indicator is to be updated
	 * @param {String} indicatorHTML - indicator markup to be updated
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.updateIndicatorOnTab = function(tab, indicatorHTML) {
		this.validateTab(tab);
		
		if (typeof indicatorHTML !== "string"){
			throw new Error("MPageUI.TabControl.prototype.updateIndicatorOnTab expects a string");
		}
		
		if(!tab.hasIndicator) {
			throw new Error("MPageUI.TabControl.prototype.updateIndicatorOnTab: tab is not configured to have indicators on label");
		}
		
		var indicatorElement = $('#indicatorTab' + tab.id);
	
		if(indicatorElement.length === 0) {
			//get the label element object to inject indicator markup
			var labelElement = $("#labelTab" + tab.id);
			// Prepend indicator container and markup
			labelElement.prepend("<span id = 'indicatorTab" + tab.id + "' class='indicator-label'>" + indicatorHTML + "</span>");	
		}
		else {
			indicatorElement.empty();
			indicatorElement.append(indicatorHTML);
		}
		
		this.resize(true);
	
		return this;
	};
	
	/**
	 * Gets the indicator for the ability to allow tab label to have count.
	 * @returns {boolean} Returns indicator for enabling label count
	 */
	TabControl.prototype.getEnableLabelCount = function() {
		return this.m_enableLabelCount;
	};
	

	/**
	 * Sets the indicator for the ability to close tabs.
	 * @param {boolean} canCloseTabs - The flag to set the display state for close tab.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setCanCloseTabs = function(canCloseTabs) {
		if (typeof canCloseTabs !== "boolean") {
			throw new Error("TabControl.prototype.setCanCloseTabs expects a boolean.");
		}
		this.m_canCloseTabs = canCloseTabs;
		return this;
	};

	/**
	 * Sets the indicator for the ability to have sorting option for tabs.
	 * @param {boolean} canSortTabs - The flag to set the display state for having sorting option.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setCanSortTabs = function(canSortTabs) {
		if (typeof canSortTabs !== "boolean") {
			throw new Error("TabControl.prototype.setCanSortTabs expects a boolean.");
		}
		this.m_canSortTabs = canSortTabs;
		return this;
	};

	/**
	 * Sets the tab as default to make it active.
	 * @param {string} tabId - tab id for the tab to make it active by default.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setDefaultTab = function(tabId) {
		if (typeof tabId !== "string") {
			throw new Error("TabControl.prototype.setDefaultTab expects a string.");
		}
		this.m_defaultTab = tabId;
		return this;
	};

	/**
	 * Sets the call back function for on tab click/activation.
	 * @param {function} callback - The callback function for the tab click/activation.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setOnSelectCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("TabControl.prototype.setOnSelectCallback expects a function.");
		}
		this.m_onSelectCallback = callback;
		return this;
	};

	/**
	 * Sets the call back function for on tab deactivate.
	 * @param {function} callback - The callback function for the tab deactivate.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setOnDeselectCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("TabControl.prototype.setOnDeselectCallback expects a function.");
		}
		this.m_onDeselectCallback = callback;
		return this;
	};

	/**
	 * Sets the call back function for sorting of the tabs.
	 * @param {function} callback - The callback function for sorting of the tab.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setOnSortCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("TabControl.prototype.setOnSortCallback expects a function.");
		}
		this.m_onSortCallback = callback;
		return this;
	};

	/**
	 * Sets the call back function for tab close option.
	 * @param {function} callback - The call back function for tab close option.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setOnCloseCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("TabControl.prototype.setOnCloseCallback expects a function.");
		}
		this.m_onCloseCallback = callback;
		return this;
	};

	/**
	 * This function will validate a provided tab. If the tab is not valid, an exception will be thrown to
	 * inform the consumer.
	 * @param {Object} tab - The tab to be verified.
	 * @throws {Error} An error indicating that the provided tab was not valid.
	 * @returns {undefined} Returns nothing.
	 */
	TabControl.prototype.validateTab = function(tab) {
		if (typeof tab !== "object") {
			throw new Error("MPageUI.TabControl.prototype.validateTab expects an object");
		}
		//validate id
		if (typeof tab.id !== "string") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the id must be a string.");
		}
		//validate label
		if (typeof tab.label !== "string") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the label must be a string.");
		}
		//validate title
		if (typeof tab.title !== "string") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the title must be a string.");
		}
		//validate onSelect function only if it is set
		if (tab.onSelect && typeof tab.onSelect !== "function") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the onSelect callback must be a function.");
		}
		//validate onDeselect function only if it is set
		if (tab.onDeselect && typeof tab.onDeselect !== "function") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the onDeselect callback must be a function.");
		}
		//validate onClose function only if it is set
		if (tab.onClose && typeof tab.onClose !== "function") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the onClose callback must be a function.");
		}
		//validate canClose option only if it is set
		if (tab.canClose && typeof tab.canClose !== "boolean") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: the canClose callback must be a boolean.");
		}
		//validate hasIndicator option only if it is set
		if (tab.hasIndicator && typeof tab.hasIndicator !== "boolean") {
			throw new Error("MPageUI.TabControl.prototype.validateTab: hasIndicator must be boolean.");
		}
	};
		
	/**
	 * Function to get the list of tabs from the tab controller.
	 * @returns {Array} m_tabs - The array of tabs.
	 */
	TabControl.prototype.getTabs = function() {
		return this.m_tabs || [];
	}; 

	/**
	 * Function to set the list of tabs to the tab controller, This will determine the list of tabs that will be part of tab controller.
	 * @param {Array} tabs - The array of tabs.This must be of the following form.
	 * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.setTabs = function(tabs) {
		if (!Array.prototype.isPrototypeOf(tabs)) {
			throw new Error("TabControl.prototype.setTabs expects a array.");
		}
		//validate the tabs, it throws an error in case of validation fails
		for (var i = 0; i < tabs.length; i++) {
			this.validateTab(tabs[i]);
		}
		this.m_tabs = tabs;
		return this;
	};

	/**
	 * Add a tab to the tab control. this will add tab to to the tab existing tab control if tab controller available or
	 * it will create tab controller and add the tab onto it
	 * and it resizes the tab controller if addTab function is called after finalizing tab control.
	 * @param {Object} tab - the tab object.This must be of the following form.
	 * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean,
	 * 		hasIndicator: boolean
	 * }
	 * @param {boolean} activateNewTab - to decide whether to activate the tab
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.addTab = function(tab, activateNewTab) {
		//validate the tab object
		this.validateTab(tab);
		var rootElement = this.getRootElement();
		//initialize the tabs array if not exists.
		this.m_tabs = this.m_tabs || [];
		//check if tab controller is already available, if not push the tab to tabs array and return
		//then the consumers should have to call the render after adding the tab to get the tab controller
		if (!rootElement.length) {
			//check if the tab is already exists.
			if (!this.tabExists(tab.id)) {
				this.m_tabs.push(tab);
			}
			return;
		}
		var lastIndex = this.m_tabs.length - 1;
		var lastTabId = null;
		//check if the tab is already exists.
		if (!this.tabExists(tab.id)) {
			this.m_tabs.push(tab);
			//render the tab
			var tabElement = $(this.createTab(tab));
			if (this.m_tabs[lastIndex]) {
				lastTabId = this.m_tabs[lastIndex].id;
				var lastTab = this.getRootElement().find("#" + lastTabId + "tab");
				//add the new tab in the end of last tab if available
				lastTab.after(tabElement);
			} else {
				//add the new tab to the end of tab controller
				rootElement.append(tabElement);
			}
			if(this.m_tabControlFinalized) {
				//resize the tab controller
				this.resize(true);
			}
			//check if the tab added is need to be activated
			if(activateNewTab){
				//activate the new tab
				this.activateTab(tabElement);
			}
		}
	};

	/**
	 * Insert a tab to the tab control. this function should be called after the tab controller is available
	 * and if a tab needs to be added as part of the tab controller, it resize the tab controller after adding the tab
	 * @param {Object} newTab - the tab object.This must be of the following form.
	 * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.insertTab = function(newTab) {
		//throw error if tab controller is not available
		if (!this.getRootElement().length) {
			throw new Error("TabControl.prototype.insertTab: tab controller not available");
		}
		//validate the new tab
		this.validateTab(newTab);
		if (!this.tabExists(newTab.id)) {
			var tab = null;
			var currentIndex = 0;
			for (var i = 0; i < this.m_tabs.length; i++) {
				tab = this.m_tabs[i];
				if (tab.id === this.m_currentActiveTab) {
					currentIndex = i;
					break;
				}
			}
			//add the new tab next to current tab
			this.m_tabs.splice(currentIndex + 1, 0, newTab);
			//render the tab
			var tabElement = $(this.createTab(newTab));
			var currentTab = this.getRootElement().find("#" + this.m_currentActiveTab + "tab");
			//add the new tab next to current tab
			currentTab.after(tabElement);
			this.resize(true);
			//activate the new tab
			this.activateTab(tabElement);
		}
	};

	/**
	 * Function to return true if the tab is already exists in the tab controller.
	 * @private
	 * @param {string} tabId - the tabId to check.
	 * @returns {boolean} true - if tab exists, false- if not.
	 */
	TabControl.prototype.tabExists = function(tabId) {
		var existingTabs = this.m_tabs;
		for (var i = 0; i < existingTabs.length; i++) {
			if (existingTabs[i].id === tabId) {
				return true;
			}
		}
		return false;
	};

	/**
	 * Remove a tab from the tab control. It removes the tab and resize the tab controller
	 * @param {string} tabId - the tab id to remove.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.removeTab = function(tabId) {
		//throw error if tab controller is not available
		if (!this.getRootElement().length) {
			throw new Error("TabControl.prototype.removeTab: tab controller not available");
		}
		if (typeof tabId !== "string") {
			throw new Error("TabControl.prototype.removeTab expects a string.");
		}
		var tab = null;
		var hiddenTab = null;
		var count = 0;
		var tabToActivate = null;
		var isRemoveTabActive = false;
		var activatedPrevoiusTab = false;
		var removeTab = this.getRootElement().find("#" + tabId + "tab");

		// check if the removing tab is active
		if (removeTab.hasClass("tab-active")) {
			isRemoveTabActive = true;
		}
		// remove the closing tab from controller
		removeTab.remove();
		for (var i = 0; i < this.m_tabs.length; i++) {
			tab = this.m_tabs[i];
			//remove the closing tab from existing array
			if (tab.id === tabId) {
				this.m_tabs.splice(i, 1);
			}
		}

		//take the first hidden tab from the right and make it visible
		var nextTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
		hiddenTab = this.m_tabs[nextTabIndex];
		if (hiddenTab) {
			this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
		} else {
			//if there is not hidden tab in the right, get it form left
			hiddenTab = this.m_tabs[this.m_firstTabIndex - 1];
			if (hiddenTab) {
				this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
				this.m_firstTabIndex--;
			}
		}
		// resize the tab controller
		this.resize(true);
		//check if remove tab is active, then decide for making other tab active
		if (isRemoveTabActive) {
			//decide what tab to activate after closing the tab
			count = this.m_alreadyActivatedTabs.length;
			for (var j = count - 1; j >= 0; j--) {
				tabToActivate = this.getRootElement().find("#" + this.m_alreadyActivatedTabs[j]);
				if (tabToActivate.length) {
					this.activateTab(tabToActivate);
					activatedPrevoiusTab = true;
					break;
				}
			}
			//if there is no previous active tab found activate the first tab
			if (!activatedPrevoiusTab) {
				//check if tabs array has a tab
				if (this.m_tabs.length) {
					var firstTab = this.getRootElement().find("#" + this.m_tabs[0].id + "tab");
					this.activateTab(firstTab);
				}
			}
		}
	};
	
	/**
	 * Function to select the existing tab, it activate the tab and deactivate the previous activated tab by the tabId passed.
	 * and it scrolls the tab control to make the tab visible in the tab control
	 * @param {string} tabId - The tab id that needs to be activated.
	 * @returns {undefined} does not return anything
	 */	
	TabControl.prototype.selectTab = function(tabId) {
		//make the tab active
		this.activateTab($("#" + tabId + "tab"));
	}; 
	
	/**
	 * Function to activate the tab and deactivate the existing activated tab.
	 * @private
	 * @param {jQuery} tab - The tab element to activate.
	 * @returns {undefined} does not return anything
	 */
	TabControl.prototype.activateTab = function(tab) {
		var previouslyActiveTab = this.getRootElement().find(".tab-active");
		//initialize the activated tab array if not exists.
		this.m_alreadyActivatedTabs = this.m_alreadyActivatedTabs || [];
		//store previously activated tab
		if (previouslyActiveTab.length) {
			var previousTab = previouslyActiveTab[0].id;
			this.m_alreadyActivatedTabs.push(previousTab);
			//deactivate the previous active tab
			this.setTabAsActive(previouslyActiveTab, false);
		}
		//activate the current tab
		this.setTabAsActive(tab, true);
	};

	/**
	 * Function to render the tab controller with the available tabs.
	 * @returns {string} tabControllerHTML - HTML mark up for tab controller.
	 */
	TabControl.prototype.render = function() {
		return this.createTabControl();
	};

	/**
	 * Function to create the tab controller with the available tabs.
	 * @private
	 * @returns {string} tabControllerHTML - HTML mark up for tab controller.
	 */
	TabControl.prototype.createTabControl = function() {
		var tabControllerHTML = "";
		var tabs = this.m_tabs || [];
		var tabCount = tabs.length;
		var tab = null;
		var tabControllerCSS = "tabs";
		//add to the tab controller CSS if the secondary CSS has been provided
		if (this.m_secondaryCSS) {
			tabControllerCSS += " " + this.m_secondaryCSS;
		}
		// create Tab controller.
		tabControllerHTML = "<ul id='" + this.m_id + "' class='" + tabControllerCSS + "'>";
		for (var i = 0; i < tabCount; i++) {
			tab = tabs[i];
			// set the first tab active if no default tab is provided
			if (!this.m_defaultTab && i === 0) {
				this.setDefaultTab(tab.id);
			}
			tabControllerHTML += this.createTab(tab);
		}
		tabControllerHTML += "</ul>";
		return tabControllerHTML;
	};

	/**
	 * Function to create the tab with tab name, tile and close option if applicable.
	 * @private
	 * @param {object} tab - The tab to be rendered.
	 * @returns {string} tabHTML - HTML mark up for tab.
	 */
	TabControl.prototype.createTab = function(tab) {
		var tabHTML = "<li id = '" + tab.id + "tab' title='" + tab.title + "' class = 'tab-container' style= 'width: " + this.m_minWidth + "px'>";
		tabHTML += "<span id = 'labelTab" + tab.id + "' class='tab-label'>";
		if(tab.hasIndicator){
			tabHTML += "<span id = 'indicatorTab" + tab.id + "' class='indicator-label'>" + tab.indicatorHTML + "</span>";
		}
		tabHTML += "<span id = 'labelTextTab" + tab.id + "' class='tab-label-text'>" + tab.label + "</span>" ;
		if(this.getEnableLabelCount()) {
			tabHTML += "<span id = 'countTab" + tab.id + "' class='tab-count-label'>(" + tab.count + ")</span>";	
		}  
		tabHTML += "";
		var canClose = typeof tab.canClose === "boolean" ? tab.canClose : this.m_canCloseTabs;
		if (canClose) {
			tabHTML += "<span id = 'closeTab" + tab.id + "' class='close-tab'>&nbsp;</span>";
		}
		tabHTML += "</span></li>";
		return tabHTML;
	};

	/**
	 * Function to resize the tab controller, it sets the width for the each tabs from the total width.
	 * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert).
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.resize = function(resizeFromTabUpdate) {
		//check if it already contains the tab controller
		var tabContoller = this.getRootElement();
		if (!tabContoller.length) {
			throw new Error("TabControl.prototype.resize tab controller not exists");
		}
		var tabCount = this.m_tabs.length;
		var tab = null;
		var tabElement = null;
		var tabWidth = null;
		var totalWidth = null;
		var labelElement = null;
		var closeTabWidth = null;
		var labelTextElement = null;

		//reset the index if it is not resize from tab update
		if (!resizeFromTabUpdate) {
			this.m_firstTabIndex = 0;
		}
		//reset the number of tabs shown
		this.m_numberOfTabsShown = 0;
		//calculate the tab width
		tabWidth = this.calculatedTabWidth(resizeFromTabUpdate);
		totalWidth = this.m_totalWidth;
		for (var i = 0; i < tabCount; i++) {
			tab = this.m_tabs[i];
			tabElement = this.getRootElement().find("#" + tab.id + "tab");
			if (tabElement.length) {
				tabElement.outerWidth(tabWidth, true);
				//get the close tab width to set the tab name width
				closeTabWidth = this.getOtherChildrenWidth(tab);
				//once width is decided for the tab set the label width to have the name with ellipses
				labelElement = tabElement.find("#labelTab" + tab.id);
				labelTextElement = tabElement.find("#labelTextTab" + tab.id);
				var totalPaddingWidth = tabElement.innerWidth() - tabElement.width();
				var totalMarginWidth = tabElement.outerWidth() - tabElement.innerWidth();
				//reducing the close tabs width
				labelElement.outerWidth(tabWidth - totalPaddingWidth - totalMarginWidth, true);
				var labelWidth = labelElement.outerWidth();
				labelTextElement.css("maxWidth", labelWidth - closeTabWidth + "px");
				// make the tab active
				if (totalWidth < this.m_minWidth) {
					tabElement.addClass("hide-tab");
				}
				if (!tabElement.hasClass("hide-tab")) {
					totalWidth = totalWidth - tabWidth;
					this.m_numberOfTabsShown++;
				} else if (!resizeFromTabUpdate && totalWidth >= this.m_minWidth) {
					//if total width is more than min_width show the hidden tabs in case of window resize
					this.m_numberOfTabsShown++;
					tabElement.removeClass("hide-tab");
					totalWidth = totalWidth - tabWidth;
				}
			}
		}
		//in case of the the first/last element is hidden due to the scroll elements space
		//this is an edge case it happens only when removing the tab when tabs array has last two hidden elements left.
		//check if total width is greater than min_width, show last hidden tab
		if (resizeFromTabUpdate && totalWidth >= this.m_minWidth) {
			var hiddenTab = this.getRootElement().find(".hide-tab")[0];
			if (hiddenTab) {
				$(hiddenTab).removeClass("hide-tab");
				this.m_numberOfTabsShown++;
			}
		}
		//apply scroll Elements if needed
		this.applyScrollElements(resizeFromTabUpdate);
	};

	/**
	 * Function calculate the total width from the parent of tab controller.
	 * @private
	 * @returns {number} totalWidth.
	 */
	TabControl.prototype.getTotalWidth = function() {
		return this.getRootElement().parent().width();
	};

	/**
	 * Function to calculate the tab width from the the total width based on the number of tabs.
	 * @private
	 * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert)
	 * @returns {number} calculated tab width.
	 */
	TabControl.prototype.calculatedTabWidth = function(resizeFromTabUpdate) {
		//use the existing parent width for resize from tab update
		//otherwise get the width from its parent
		if (resizeFromTabUpdate) {
			this.m_totalWidth = this.m_parentWidth;
		} else {
			this.m_totalWidth = this.getTotalWidth();
			this.m_parentWidth = this.m_totalWidth;
		}
		var availableWidth = this.m_totalWidth / this.m_tabs.length;
		if (availableWidth >= this.m_maxWidth) {
			//The calculated tab width is larger than the max_width we define,
			//so there is enough space for all tabs, but we will limit their size to maxWidth
			this.m_displayScroller = false;
			return this.m_maxWidth;
		} else if (availableWidth >= this.m_minWidth) {
			//The calculated width is greater than the min_width
			//so we have enough space for all of the tabs to fit without scroll elements
			this.m_displayScroller = false;
			return availableWidth;
		} else {
			//The calculated width is lesser than our min_width
			//so we don't have enough space for all of the tabs, so adding a scroll elements and setting the tabs to min_width
			this.m_displayScroller = true;
			//accounting for scroll elements width by reducing it form the total width
			this.m_totalWidth -= this.m_scrollerWidth;
			//calculate the tabs width to use the total width for the tabs shown
			return this.calculateTabWidth();
		}
	};

	/**
	 * Function to get the width of the children other than label(tab name).
	 * @private
	 * @param {Object} tab- width calculation for particular tab
	 * @returns {number} close option width.
	 */
	TabControl.prototype.getOtherChildrenWidth = function(tab) {
	  // it gets the close options width and adds the padding/borders the tab has
	  var totalChildrenWidth = 0;
	  var defaultIndicatorWidth = 16;
	  var defaultCountWidth = 17;
	  
	  var canClose = typeof tab.canClose === "boolean" ? tab.canClose : this.m_canCloseTabs;
	  if (canClose) {
	  	totalChildrenWidth += this.getRootElement().find(".close-tab").outerWidth(true) + 4;
	  }
	  if(tab.hasIndicator) {
	  	var indicatorWidth = this.getRootElement().find("#indicatorTab" + tab.id).outerWidth(true);
	  	if(!indicatorWidth) {
	  		indicatorWidth += defaultIndicatorWidth;
	  	}
	    totalChildrenWidth += indicatorWidth;
	  }
	  if(this.getEnableLabelCount()) {
	  	var countWidth = this.getRootElement().find("#countTab" + tab.id).outerWidth(true);
	    if(!countWidth) {
	    	countWidth += defaultCountWidth;
	    }
	    totalChildrenWidth += countWidth;
	  }
	  // add padding width 
	  return totalChildrenWidth;
	};
	
	/**
	 * Function to calculate tab width based on total number of tabs can be shown.
	 * @private
	 * @returns {number} calculated tab width.
	 */
	TabControl.prototype.calculateTabWidth = function() {
		//take the total number of tabs that can be shown based on total width	
		//using Math.floor to get the lowest whole number to get the tabs that can be shown
		var numberOfTabs = Math.floor(this.m_totalWidth / this.m_minWidth);
		//use the total width to calculate the width for the tabs
		return this.m_totalWidth / numberOfTabs;
	};

	/**
	 * Function to apply the scroll elements  to the tab controller.
	 * @private
	 * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert)
	 * @returns {undefined} does not return anything
	 */
	TabControl.prototype.applyScrollElements = function(resizeFromTabUpdate) {
		var leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
		var rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
		//check if the scroll elements is needed
		if (this.m_displayScroller) {
			//create the scroll elements if it does not exist
			if (!leftArrow.length) {
				leftArrow = $("<li></li>").addClass("inactive-left-arrow").attr("id", this.m_id + "leftArrow");
				this.getRootElement().prepend(leftArrow);
			} else if (!resizeFromTabUpdate) {
				//in a case of resize if the left arrow is activated, then in the resize again
				//it may not need to be active
				leftArrow.removeClass("active-left-arrow");
				leftArrow.addClass("inactive-left-arrow");
			}
			if (!rightArrow.length) {
				rightArrow = $("<li></li>").addClass("active-right-arrow").attr("id", this.m_id + "rightArrow");
				this.getRootElement().append(rightArrow);
			} else if (this.haveNextTabs()) {
				//in a case of resize if the right arrow is deactivated, then in the resize again
				//it may need to be active
				rightArrow.removeClass("inactive-right-arrow");
				rightArrow.addClass("active-right-arrow");
			} else {
				rightArrow.removeClass("active-right-arrow");
				rightArrow.addClass("inactive-right-arrow");
			}

		} else {
			//remove scroll elements if it is not needed
			leftArrow.remove();
			rightArrow.remove();
		}
	};

	/**
	 * Function to scroll a tab controller to the first index provided
	 * and displays the number of tabs shown
	 * @private
	 * @param {number} firstIndex - the starting index of the tab
	 * @returns {undefined} does not return anything
	 */
	TabControl.prototype.scrollTabs = function(firstIndex) {
		//calculate the last index to be displayed
		var lastIndex = firstIndex + this.m_numberOfTabsShown;
		var tabs = this.m_tabs;
		var tab = null;
		var leftArrow = null;
		var rightArrow = null;
		for (var i = 0; i < tabs.length; i++) {
			tab = tabs[i];
			// check if index is in between first and last index
			if (i >= firstIndex && i < lastIndex) {
				this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
			} else {
				this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
			}
		}
		//activate or deactivate the left arrow if tabs are pushed
		leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
		//activate the left arrow if it reaches first index
		if (firstIndex > 0) {
			leftArrow.addClass("active-left-arrow");
			leftArrow.removeClass("inactive-left-arrow");
		} else {
			leftArrow.addClass("inactive-left-arrow");
			leftArrow.removeClass("active-left-arrow");
		}
		//activate or deactivate the right arrow when elements are pushed
		rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
		//deactivate the right arrow when it reaches the last tab
		if (lastIndex === this.m_tabs.length) {
			rightArrow.addClass("inactive-right-arrow");
			rightArrow.removeClass("active-right-arrow");
		} else {
			rightArrow.addClass("active-right-arrow");
			rightArrow.removeClass("inactive-right-arrow");
		}
	};

	/**
	 * Function to perform on next click(right arrow) operation.
	 * @private
	 * it shows the first hidden tab in the right and hides the first displayed tab
	 * @returns {undefined} does not return anything
	 */
	TabControl.prototype.scrollRight = function() {
		var tab = null;
		var tabs = this.m_tabs;
		var firstIndex = this.m_firstTabIndex;
		var nextTabIndex = firstIndex + this.m_numberOfTabsShown;
		var leftArrow = null;
		var rightArrow = null;
		for (var i = 0; i < tabs.length; i++) {
			tab = tabs[i];
			// check if index is first element
			if (i === firstIndex) {
				this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
				//increment the index
				this.m_firstTabIndex++;
				//activate the left scroll arrow
				leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
				leftArrow.removeClass("inactive-left-arrow");
				leftArrow.addClass("active-left-arrow");
			} else if (i === nextTabIndex) {
				//show the first hidden tab
				this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
			}
		}
		//if the next tab is last element is the last in the list, deactivate the right arrow
		if (nextTabIndex === this.m_tabs.length - 1) {
			rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
			rightArrow.addClass("inactive-right-arrow");
			rightArrow.removeClass("active-right-arrow");
		}

	};

	/**
	 * Function to perform on previous click(left arrow) operation.
	 * it shows the first hidden tab in the left and hides the last displayed tab
	 * @private
	 * @returns {undefined} does not return anything
	 */
	TabControl.prototype.scrollLeft = function() {
		var tab = null;
		var tabs = this.m_tabs;
		//gets the first previous index to show the hidden tab in the left
		var prevoiusIndex = this.m_firstTabIndex - 1;
		//gets the last index to hide the last tab
		var lastTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
		var leftArrow = null;
		var rightArrow = null;
		for (var i = 0; i < tabs.length; i++) {
			tab = tabs[i];
			//check if index last tab index, then hide the tab
			if (i === lastTabIndex) {
				this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
				rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
				rightArrow.removeClass("inactive-right-arrow");
				rightArrow.addClass("active-right-arrow");
			} else if (i === prevoiusIndex) {
				//hide the first hidden tab and decrement the first index
				this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
				this.m_firstTabIndex--;
			}
		}
		//check if index is zero, deactivate the left arrow since there is no hidden tab in the left.
		if (prevoiusIndex === 0) {
			leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
			leftArrow.addClass("inactive-left-arrow");
			leftArrow.removeClass("active-left-arrow");
		}
	};

	/**
	 *Function to return true if next tabs exists, currently hidden
	 * @private
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.haveNextTabs = function() {
		//calculate the last index from tabs array
		var lastIndex = this.m_tabs.length - 1;
		//get the last element and check if it is hidden
		var lastTab = this.getRootElement().find("#" + this.m_tabs[lastIndex].id + "tab");
		return lastTab.hasClass("hide-tab") ? true : false;
	};

	/**
	 * Function to update the tabs title, it should be called with valid tab object with the changed title
	 * @param {Object} tab - the tab object.This must be of the following form.
	 * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.updateTitle = function(tab) {
		//throw error if tab controller is not available
		if (!this.getRootElement().length) {
			throw new Error("TabControl.prototype.updateTitle: tab controller not available");
		}
		//throw error if tab does not exists
		if (!this.tabExists(tab.id)) {
			throw new Error("TabControl.prototype.updateTitle: tab does not exists");
		}
		//validate the tab object
		this.validateTab(tab);
		//get the tab object from root element
		var tabElement = this.getRootElement().find("#" + tab.id + "tab");
		//change the title
		$(tabElement).attr("title", tab.title);
	};

	/**
	 * Function to have sorting option for the tabs.
	 * @private
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.applyTabSorting = function() {
		var self = this;
		this.getRootElement().sortable({
			axis: "x",
			appendTo: "#" + this.m_id,
			containment: "parent",
			items: ".tab-container:not(.hide-tab)",
			delay: 100,
			distance: 5,
			forceHelperSize: true,
			forcePlaceholderSize: true,
			scroll: false,
			tolerance: "pointer",
			start: function(event, ui) {
				//set the height and width for the scroll elements on sorting
				ui.placeholder.height(28);
				ui.placeholder.width(ui.item[0].scrollWidth - 2);
			},
			stop: function(event, ui) {
				//removing the text tab from the id,
				//tab id is suffixed with the text 'tab', it needs to be removed.Example:tab1tab will be tab1
				var sortedTabId = ui.item[0].id.slice(0, -3);
				//re arrange the tabs array after sorting
				self.reArrangeTabs(sortedTabId);
				//pass the sorted array to callback
				if (self.m_onSortCallback) {
					self.m_onSortCallback(self.m_tabs);
				}
			},
			placeholder: "tab-placeholder"
		});
		this.getRootElement().disableSelection();
	};

	/**
	 * Function to re arrange the tabs array in case of sorting changes the index
	 * @private
	 * @param {string} sortedTabId - the tab id for the element which is being sorted
	 * @returns {undefined} does not return anything.
	 */
	TabControl.prototype.reArrangeTabs = function(sortedTabId) {
		var tab = null;
		var tabElement = null;
		var tabElementId = null;
		//Grab all of the tabs
		var sortedTabs = this.getRootElement().find(".tab-container");
		//remove the sorted tab from the existing array
		for (var i = 0; i < this.m_tabs.length; i++) {
			tab = this.m_tabs[i];
			if (tab.id === sortedTabId) {
				this.m_tabs.splice(i, 1);
				break;
			}
		}
		//find the sorted tab array in the sorted array
		for (var j = 0; j < sortedTabs.length; j++) {
			tabElement = sortedTabs[j];
			//removing the text tab from the id
			tabElementId = tabElement.id.slice(0, -3);
			if (tabElementId === sortedTabId) {
				//insert the tab into the tabs array in the index that matches the sorted tab id in the sortedTabs array
				this.m_tabs.splice(j, 0, tab);
				break;
			}
		}
	};

	/**
	 * Activate or deactivate a tabs visuals.As well execute the callback functions on tab activate and deactivate
	 * @private
	 * @param {jQuery} tabElement - The tab element which needs to be activated or deactivated
	 * @param {boolean} activateInd A boolean flag to indicate if the tab element should have active css class or not
	 * @return {undefined} This function does not return a value
	 */
	TabControl.prototype.setTabAsActive = function(tabElement, activateInd) {
		//get the tab object
		var tabId = tabElement[0].id.slice(0, -3);
		var tab = this.getTabById(tabId);
		//check if it is to activate tab
		if (activateInd) {
			tabElement.addClass("tab-active");
			this.m_currentActiveTab = tabId;
			//scroll the tabs to make activated visible in case if it is hidden
			this.makeTabVisible(tabId);
			//check if the current tab has a onSelectCallback function
			if (tab && tab.onSelect) {
				tab.onSelect(tab);
			} else if(this.m_onSelectCallback){
				//if there is no callback set in the tab level then call the callback function form the tab control
				this.m_onSelectCallback(tab);
			}
		} else {
			tabElement.removeClass("tab-active");
			//check if the current tab has a onDeselectCallback function
			if (tab && tab.onDeselect) {
				tab.onDeselect(tab);
			} else if(this.m_onDeselectCallback){
				//if there is no callback set in the tab level then call the callback function form the tab control
				this.m_onDeselectCallback(tab);
			}
		}
	};
	
	/**
	 * make the tab visible if it is hidden in the tabControl
	 * @private
	 * @param {string} tabId - tab id
	 * @returns {undefined} does not return anything.
	 */	
	TabControl.prototype.makeTabVisible = function(tabId) {
		var currentIndex = 0;
		var tab = null;
		var lastIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
		var totalTabs = this.m_tabs.length;
		for (var i = 0; i < this.m_tabs.length; i++) {
			tab = this.m_tabs[i];
			if (tab.id === tabId) {
				currentIndex = i;
				break;
			}
		}
		//check if the selecting tab is hidden
		if (this.m_firstTabIndex > 0 && currentIndex < this.m_firstTabIndex) {
			//scroll to the tabs to show the selected tab
			this.scrollTabs(currentIndex);
			this.m_firstTabIndex = currentIndex;
		} else if (lastIndex < totalTabs - 1 && currentIndex > lastIndex) {
			this.m_firstTabIndex = currentIndex - this.m_numberOfTabsShown + 1;
			this.scrollTabs(this.m_firstTabIndex);
		}
	}; 

	/**
	 * Function to get the tab from the tabId passed
	 * @private
	 * @param {string} tabId - tab id
	 * @returns {object} tab - tab object.
	 */
	TabControl.prototype.getTabById = function(tabId) {
		var existingTabs = this.m_tabs;
		var tab = null;
		for (var i = 0; i < existingTabs.length; i++) {
			tab = existingTabs[i];
			if (tab.id === tabId) {
				return tab;
			}
		}
		return null;
	};

	/**
	 * Attaches the necessary events to the Tab controller. This function must be called after the tab controller
	 * mark up exists on the DOM.
	 * @private
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.attachEvents = function() {
		var self = this;
		var rootElement = this.getRootElement();
		//event for right arrow(scroll element) click
		rootElement.on("click.mpageui", ".active-right-arrow", function() {
			self.scrollRight($(this));
		});
		//event for left arrow(scroll element) click
		rootElement.on("click.mpageui", ".active-left-arrow", function() {
			self.scrollLeft($(this));
		});
		// adding click event for the tabs
		rootElement.on("click.mpageui", ".tab-container", function(event) {
			// return if the element clicked is close option
			if ($(event.target).hasClass("close-tab")) {
				return;
			}
			self.activateTab($(this));
		});

		// adding click event for close tab
		rootElement.on("click.mpageui", ".close-tab", function() {
			var closingTab = this.id;
			//removing prefixed text(closetab) to identify the tab id
			var tabId = closingTab.slice(8);
			var tab = self.getTabById(tabId);
			//remove tab
			self.removeTab(tabId);
			//check to see the tab has its own call back function
			if (tab && tab.onClose) {
				tab.onClose(tab);
			} else if(self.m_onCloseCallback){
				//if tabs as no call back, then execute the tab control call back
				self.m_onCloseCallback(tab);
			}
		});

		return this;
	};

	/**
	 * Finalizes the Tab controller. This function must be called after the tab controller
	 * mark up exists on the DOM.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	TabControl.prototype.finalize = function() {
		this.attachEvents();
		// make the sorting option available if it is opted for
		if (this.m_canSortTabs) {
			this.applyTabSorting();
		}
		// Call resize to resize the tab controller.
		this.resize();
		//make the default tab active
		var defaultTab = this.getRootElement().find("#" + this.m_defaultTab + "tab");
		if (defaultTab.length) {
			this.activateTab(defaultTab);
		} else if (this.m_tabs.length > 0) {
			//make the first tab active
			var firstElement = this.getRootElement().find("#" + this.m_tabs[0].id + "tab");
			this.activateTab(firstElement);
		}
		this.m_tabControlFinalized = true;
		return this;
	};

	return TabControl;
})();

MPageUI.PrimaryTabControl = (function() {
	/**
	 * The PrimaryTabControl class.
	 * @returns {MPageUI.PrimaryTabControl} Returns self to allow chaining.
	 * @constructor
	 */
	var PrimaryTabControl = function() {
		this.base();
		//the minimum size of the tab
		this.m_minWidth = 140;
		//the maximum size of the tab
		this.m_maxWidth = 250;
		return this;
	};

	MPageUI.extend(PrimaryTabControl, MPageUI.TabControl);

	return PrimaryTabControl;
})();

MPageUI.SecondaryTabControl = (function() {
	/**
	 * The SecondaryTabControl class.
	 * @returns {MPageUI.SecondaryTabControl} Returns self to allow chaining.
	 * @constructor
	 */
	var SecondaryTabControl = function() {
		this.base();
		//the minimum size of the tab
		this.m_minWidth = 120;
		//the maximum size of the tab
		this.m_maxWidth = 200;
		//to store the CSS class name to set the specific styles for the tab control
		this.m_secondaryCSS = "secondary-tab";
		return this;
	};
	MPageUI.extend(SecondaryTabControl, MPageUI.TabControl);

	return SecondaryTabControl;
})();

MPageUI.AddTabControl = (function() {
	/**
	 * The AddTabControl class.
	 * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
	 * @constructor
	 */
	var AddTabControl = function() {
		//flag to have the add tab functionality
		this.m_displayAddTab = true;
		//callback function for clicking the add tab option
		this.m_onAddTabCallback = null;
		return this;
	};

	MPageUI.extend(AddTabControl, MPageUI.PrimaryTabControl);

	/**
	 * Function to set the call back for add tab option.
	 * @param {function} callback - The callback function for the add tab.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.TabControl} Returns self to allow chaining.
	 */
	AddTabControl.prototype.setOnAddTabCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("AddTabControl.prototype.setOnAddTabCallback expects a function.");
		}
		this.m_onAddTabCallback = callback;
		return this;
	};

	/**
	 * Override the MPageUI.PrimaryTabControl.render function to create tab control with the add tab option
	 * @returns {string} tabControlHTML - HTML mark up for add tab control.
	 */
	AddTabControl.prototype.render = function() {
		var tabControlHTML = this.createTabControl();
		tabControlHTML += this.createAddTab();
		return tabControlHTML;
	};

	/**
	 * Function to create add tab option of it is opted for.
	 * @private
	 * @returns {string} addTabHTML - HTML mark up for add tab.
	 */
	AddTabControl.prototype.createAddTab = function() {
		var addTabHTML = "";
		// Check to see if add tab (+) needs to be displayed.
		if (this.m_displayAddTab) {
			addTabHTML = "<div id ='" + this.m_id + "_addTab' class= 'add-tab-wrapper'> <span class= 'add-tab'></span> </div>";
		}
		return addTabHTML;
	};

	/**
	 * Attaches the necessary events to the Tab controller. This function must be called after the tab controller
	 * mark up exists on the DOM.
	 * @private
	 * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
	 */
	AddTabControl.prototype.attachAddTabEvent = function() {
		var self = this;
		//event for add tab click
		$("#" + this.m_id + "_addTab").on("click.mpageui", function() {
			self.m_onAddTabCallback();
		});
		return this;
	};

	/**
	 * Override the MPageUI.PrimaryTabControl.finalize function to Finalizes the AddTab controller. This function must be called after the tab controller
	 * mark up exists on the DOM.
	 * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
	 */
	AddTabControl.prototype.finalize = function() {
		//attaches the events from parent(PrimaryTabControl)
		this.attachEvents();
		this.attachAddTabEvent();
		// make the sorting option if it is opted for
		if (this.m_canSortTabs) {
			this.applyTabSorting();
		}
		// Call resize to resize the tab controller.
		this.resize();
		//make the default tab active
		var defaultTab = this.getRootElement().find("#" + this.m_defaultTab + "tab");
		if (defaultTab.length) {
			this.activateTab(defaultTab);
		} else if (this.m_tabs.length > 0) {
			//make the first tab active
			var firstElement = this.getRootElement().find("#" + this.m_tabs[0].id + "tab");
			this.activateTab(firstElement);
		}
		this.m_tabControlFinalized = true;
		return this;
	};

	/**
	 * Override the MPageUI.PrimaryTabControl.calculateTotalWidth Function to calculate the total width from the parent of tab controller.
	 * @private
	 * @returns {number} totalWidth.
	 */
	AddTabControl.prototype.getTotalWidth = function() {
		var parentWidth = this.getRootElement().parent().width();
		// reduce width for the add tab
		if (this.m_displayAddTab) {
			var addTabWidth = $("#" + this.m_id + "_addTab").outerWidth(true);
			parentWidth -= addTabWidth;
		}
		return parentWidth;
	};

	return AddTabControl;
})();

MPageUI.ViewpointTabControl = (function() {
	/**
	 * The ViewpointTabControl class.
	 * @returns {MPageUI.ViewpointTabControl} Returns self to allow chaining.
	 * @constructor
	 */
	var ViewpointTabControl = function() {
		this.base();
		return this;
	};
	MPageUI.extend(ViewpointTabControl, MPageUI.AddTabControl);

	/**
	 * overrides the parent removeTab function. It removes the tab and resize the tab controller
	 * @param {string} tabId - the tab id to remove.
	 * @param {boolean} doNotActivatePreviousTab - to decide whether to activate the previous tab or not.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {undefined} does not return anything.
	 */
	ViewpointTabControl.prototype.removeTab = function(tabId, doNotActivatePreviousTab) {
		//throw error if tab controller is not available
		if (!this.getRootElement().length) {
			throw new Error("TabControl.prototype.removeTab: tab controller not available");
		}
		if ( typeof tabId !== "string") {
			throw new Error("TabControl.prototype.removeTab expects a string.");
		}
		var tab = null;
		var hiddenTab = null;
		var count = 0;
		var tabToActivate = null;
		var isRemoveTabActive = false;
		var activatedPrevoiusTab = false;
		var removeTab = this.getRootElement().find("#" + tabId + "tab");

		// check if the removing tab is active
		if (removeTab.hasClass("tab-active")) {
			isRemoveTabActive = true;
		}
		// remove the closing tab from controller
		removeTab.remove();
		for (var i = 0; i < this.m_tabs.length; i++) {
			tab = this.m_tabs[i];
			//remove the closing tab from existing array
			if (tab.id === tabId) {
				this.m_tabs.splice(i, 1);
			}
		}

		//take the first hidden tab from the right and make it visible
		var nextTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
		hiddenTab = this.m_tabs[nextTabIndex];
		if (hiddenTab) {
			this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
		} else {
			//if there is not hidden tab in the right, get it form left
			hiddenTab = this.m_tabs[this.m_firstTabIndex - 1];
			if (hiddenTab) {
				this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
				this.m_firstTabIndex--;
			}
		}
		// resize the tab controller
		this.resize(true);
		//check if remove tab is active, then decide for making other tab active
		if (isRemoveTabActive && !doNotActivatePreviousTab) {
			//decide what tab to activate after closing the tab
			count = this.m_alreadyActivatedTabs.length;
			for (var j = count - 1; j >= 0; j--) {
				tabToActivate = this.getRootElement().find("#" + this.m_alreadyActivatedTabs[j]);
				if (tabToActivate.length) {
					this.activateTab(tabToActivate);
					activatedPrevoiusTab = true;
					break;
				}
			}
			//if there is no previous active tab found activate the first tab
			if (!activatedPrevoiusTab) {
				//check if tabs array has a tab
				if (this.m_tabs.length) {
					var firstTab = this.getRootElement().find("#" + this.m_tabs[0].id + "tab");
					this.activateTab(firstTab);
				}
			}
		}
	};

	return ViewpointTabControl;
})();

/* globals MPageUI, CERN_Validate */

/**
 * Enumeration for TextControl options.
 * Subclasses of TextControl can add a type to the enum and should set a field type in their constructor
 * @readonly
 */
MPageUI.TEXT_CONTROL_OPTIONS = {
	TYPE: {
		TEXT_AREA: "field-textarea"
	}
};

MPageUI.TextControl = (function() {
	/**
	 * The TextControl class.
	 * @returns {TextControl} Returns self to allow chaining.
	 * @constructor
	 */
	var TextControl = function() {
		// Super constructor
		this.base();
		this.m_headerLabel = "";
		this.m_width = null;
		this.m_currentValue = "";
		this.m_requiredInd = false;
		this.m_fieldType = "";

		// Callback functions
		this.m_onChangeCallback = null;

		// Element cache
		this.m_$inputElement = null;
		return this;
	};
	// Extend the base UIComponent class
	MPageUI.extend(TextControl, MPageUI.UIComponent);

	/**
	 * Sets the header label for the text box.
	 * @param {string} headerText - The label to display above the text control
	 * @throws {Error} An error is thrown if the headerText is not a string.
	 * @returns {MPageUI.TextControl} Returns self to allow chaining.
	 */
	TextControl.prototype.setHeaderLabel = function(headerText) {
		if (!CERN_Validate.string.isString(headerText)) {
			throw new Error("MPageUI.TextControl.prototype.setHeaderLabel expects a string.");
		}
		this.m_headerLabel = headerText;
		return this;
	};
	
	/**
	 * Sets the width of the text control in pixels. The width to be set needs to be a positive number.
	 * @param {number} width - The width of the text control in pixels.
	 * @returns {TextControl} Returns self to allow chaining.
	 */
	TextControl.prototype.setWidth = function(width) {
		if (!CERN_Validate.number.isPositive(width)) {
			throw new Error("TextControl.prototype.setWidth expects a number > 0");
		}
		this.m_width = width;
		return this;
	};
	
	/**
	 * Returns the current value of the text control.
	 * @returns {string} The current value of the text control.
	 */
	TextControl.prototype.getCurrentValue = function() {
		return this.m_currentValue;
	};
	
	/**
	 * Sets a value in the text control. This method needs to be called before the text control is rendered.
	 * Only string parameter is allowed.
	 * @param {string} value - The value to be set in the text control.
	 * @returns {TextControl} Returns self to allow chaining.
	 */
	TextControl.prototype.setCurrentValue = function(value) {
		if (!CERN_Validate.string.isString(value)) {
			throw new Error("TextControl.prototype.setCurrentValue expects a string.");
		}
		this.m_currentValue = value;
		// If the element has been rendered, update the value.
		this.getInputElement().val(value);
		//Update the state since the value has changed
		this.updateState();
		return this;
	};

	/**
	 * Returns whether the text control is required.
	 * @returns {boolean} Whether the text control is required.
	 */
	TextControl.prototype.isRequired = function() {
		return this.m_requiredInd;
	};
	
	/**
	 * Sets whether the text control is required.
	 * @param {boolean} required - Whether the text control is required.
	 * @returns {TextControl} Returns self to allow chaining.
	 */
	TextControl.prototype.setRequired = function(required) {
		if (typeof required !== "boolean") {
			throw new Error("TextControl.prototype.setRequired expects a boolean.");
		}
		this.m_requiredInd = required;
		return this;
	};

	/**
	 * Sets the callback function to be called when the content within the text control changes.
	 * The callback function must specify a content parameter as such:
	 * ex: control.setOnChangeCallback(function(content){ ... });
	 * @param {Function} onChangeCallback - The callback function to be called when the content within the text control changes.
	 * @returns {TextControl} Returns self to allow chaining.
	 */
	TextControl.prototype.setOnChangeCallback = function(onChangeCallback) {
		if (typeof onChangeCallback !== "function") {
			throw new Error("TextControl.prototype.setOnChangeCallback expects a function");
		}
		this.m_onChangeCallback = onChangeCallback;
		return this;
	};
	
	/**
	 * Overrides the base render function to render a place holder for text control.
	 * @returns {string} The TextControl object rendered as an html string.
	 */
	TextControl.prototype.render = function() {
		var html = "<p class='field " + this.m_fieldType + "'>";
		// Renders the label for the input
		html += this.renderLabel();
		// Can be overridden by subclasses of the text control
		html += this.renderInput();
		html += "</p>";
		return html;
	};

	/**
	 * Overrides the base render function to render a header label for the
	 * text control as an html string. If no header text is set then this
	 * function will return an empty html string.
	 *  @returns {string} The TextControl object rendered as an html string.
	 */
	TextControl.prototype.renderLabel = function() {
		var html = "";
		var labelClasses = [ "secondary-text" ];

		// HTML for label style
		if (this.m_headerLabel.length) {
			// Add an indicator for required field
			if (this.isRequired()) {
				labelClasses.push("tc-required-label");
				html += "<span class='tc-required-ind'>*</span>";
			}

			// HTML for label
			html += "<label for='" + this.m_id + "' class='" + labelClasses.join(" ") + "'>" + this.m_headerLabel + "</label>";
		}
		return html;
	};
	
	/**
	 * The base TextControl object does not implement this function, but some sub-classes of the TextControl class
	 * can override this method to render a specific type of input element
	 * @returns {undefined} Returns nothing.
	 */
	TextControl.prototype.renderInput = function(){
		return "";
	};

	/**
	 * Overrides the base attachEvents function to attach any JavaScript events
	 * to the component once it has been rendered to the DOM.
	 * @returns {undefined} Returns nothing.
	 */
	TextControl.prototype.attachEvents = function() {
		var self = this;
		var $rootElement = this.getRootElement();
		// Event handling for keup
		$rootElement.on("keyup.mpageui", function() {
			self.onUpdate(this.value);
		});
	};

	/**
	 * Handles the input update. This function is called on the keyup event of the text control.
	 * @param {string} currentValue - The current value in the text control
	 * @returns {undefined} Returns nothing.
	 */
	TextControl.prototype.onUpdate = function(currentValue) {
		this.setCurrentValue(currentValue);
		// Notify that the content has changed.
		if (this.m_onChangeCallback) {
			this.m_onChangeCallback(currentValue);
		}

		// Update the state
		this.updateState();
	};
	
	/**
	 * Handles updating the UI state of the text control.
	 * @returns {undefined} Returns nothing.
	 */
	TextControl.prototype.updateState = function() {
		// Handle required status
		if (this.isRequired()) {
			if (this.isEmpty()) {
				this.getInputElement().addClass("tc-required");
			} else {
				this.getInputElement().removeClass("tc-required");
			}
		}
	};
	
	/**
	 * Returns the input element. If the element is null, it will be queried from the DOM.
	 * @returns {jQuery} The input element.
	 */
	TextControl.prototype.getInputElement = function() {
		if (!this.m_$inputElement || !this.m_$inputElement.length) {
			this.m_$inputElement = $("#" + this.getId());
		}
		return this.m_$inputElement;
	};
	
	/**
	 * Determines if the control is empty.
	 * @returns {boolean} A boolean indicating if the control is empty.
	 */
	TextControl.prototype.isEmpty = function() {
		return CERN_Validate.string.isBlank(this.m_currentValue);
	};
	
	return TextControl;
})();

MPageUI.TextArea = (function() {
	/**
	 * The TextArea class. This creates a standard text area.
	 * @returns {MPageUI.TextArea} Returns self to allow chaining.
	 * @constructor
	 */
	var TextArea = function() {
		// Super constructor
		this.base();
		this.m_height = null;
		this.m_rows = 1;
		this.m_fieldType = MPageUI.TEXT_CONTROL_OPTIONS.TYPE.TEXT_AREA;
		return this;
	};
	MPageUI.extend(TextArea, MPageUI.TextControl);
	
	/**
	 * Sets the height of the <textarea> in pixels. This value can be null if no value
	 * has been explicitly provided. In this case, the <textarea> element will
	 * be styled natively via the "rows" attribute which defaults to 1.
	 * @param {number} height - The height of the <textarea> element in pixels.
	 * @returns {TextArea} Returns self to allow chaining.
	 */
	TextArea.prototype.setHeightInPixels = function(height) {
		if (!CERN_Validate.number.isPositive(height)) {
			throw new Error("TextArea.prototype.setHeightInPixels expects a number > 0.");
		}
		this.m_height = height;
		return this;
	};
	
	/**
	 * Sets the number of rows for the <textarea>. This refers to the native
	 * "rows" attribute on the <textarea> element. The row number to be set
	 * has to be greater than or equal to 1. For example: <textarea rows="1"></textarea>
	 * @param {number} rows - The number of native rows for the <textarea> element.
	 * @returns {TextArea} returns self to allows chaining.
	 */
	TextArea.prototype.setHeightInRows = function(rows) {
		if (!CERN_Validate.number.isGreaterThanOrEqualTo(1)) {
			throw new Error("TextArea.prototype.setHeightInRows expects an integer >= 1");
		}
		this.m_rows = rows;
		return this;
	};

	/**
	 * First calls the base render function to render the header label and then
	 * returns the header and TextArea as an html string.
	 * @returns {string} The TextArea object rendered as an html string.
	 */
	TextArea.prototype.renderInput = function() {
		// Call the base render function to get the header text
		var html = "";
		var inputClasses = [ "tc-text-area" ];

		// Add a class for required field
		if (this.isRequired() && this.isEmpty()) {
			inputClasses.push("tc-required");
		}

		// Create <textarea> style
		var style = "style='";
		style += this.m_width ? ("width:" + this.m_width + "px;") : "";
		style += this.m_height ? ("height:" + this.m_height + "px;") : "";
		style += "'";

		// HTML for <textarea>
		html = "<textarea id='" + this.m_id + "' class='" + inputClasses.join(" ") + "' rows= '" + this.m_rows + "' " + style + ">" + this.m_currentValue + "</textarea>";
		return html;
	};
	return TextArea;
})();

/* global MPageUI */

MPageUI.PlaceholderContent = (function() {
	/**
	 * The PlaceholderContent class. 
	 * This ui component will render a placeholder styled with a dashed border. 
	 * The contents will have primary text and only one actionable control. 
	 *  
	 * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
	 * @constructor
	 */
	var PlaceholderContent = function() {
		// Super constructor
		this.base();
		this.m_primaryText = "";
		this.m_actionableControl = null;
		this.m_rendered = false;
		return this;
	};
	MPageUI.extend(PlaceholderContent, MPageUI.UIComponent);
	
	
	/**
	 * Sets the primary text in the placeholder.
	 * @param {string} text - A string to be displayed in placeholder.
	 * @throws {Error} An error indicating that the text parameter is an invalid type.
	 * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
	 */
	PlaceholderContent.prototype.setPrimaryText = function (text){
		if(typeof text !== "string"){
			throw new Error("PlaceholderContent.prototype.setPrimaryText expects a string");
		}
		this.m_primaryText = text;
		return this;
	};
	
	/**
	 * Sets the control that will provide actionability. Currently limiting it to just the base Button object. 
	 * @param {MPageUI.Button} control - An instance of the MPageUI.Button component created by the consumer.
	 * @throws {Error} An error indicating that the control provided is not an instance of MPageUI.Button
	 * @returns {MPageUI.SplitButton} Returns self to allow chaining.
	 */
	PlaceholderContent.prototype.setActionableControl = function(control){
		if(!control || !MPageUI.Button.prototype.isPrototypeOf(control)){
			throw new Error("PlaceholderContent.prototype.setActionableControl expects an instance of MPageUI.Button.");
		}
		this.m_actionableControl = control;
		return this;
	};
	/**
	 * Retrieves the instance of the control that will have some actionablity.
	 * @returns {MPageUI.Button} The contextual view button.
	 */
	PlaceholderContent.prototype.getActionableControl = function(){
		return this.m_actionableControl;
	};
	/**
	 * Sets the flag whether to indicate PlaceholderContent has rendered.
	 * @param {boolean} rendered - Boolean to indicate whether the PlaceholderContent has rendered.
	 * @throws {Error} An error indicating that the parameter is an invalid type.
	 * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
	 */
	PlaceholderContent.prototype.setRendered = function (rendered){
		if(typeof rendered !== "boolean"){
			throw new Error("PlaceholderContent.prototype.setRendered expects a boolean");
		}
		this.m_rendered = rendered;
		return this;
	};
	
	/**
	 * Gets the flag that indicates whether the PlaceholderContent is rendered.
	 * @return {Boolean} Flag whether to indicate PlaceholderContent has rendered. 
	 */
	PlaceholderContent.prototype.hasRendered = function(){
		return this.m_rendered;
	};
	/**
	 * Overrides the MPageUI.UIComponent.prototype.render function to return the PlaceholderContent
	 * Renders a simple placeholder styled with a dashed border, with a primary text and an actionable control.
	 * @return {String} The HTML markup of ghosted view
	 */
	PlaceholderContent.prototype.render = function (){
		var placeholderContentHTML = "";
		placeholderContentHTML += "<div id='" + this.m_id + "' class='placeholder-content-container'>";
		placeholderContentHTML += "<span class='primary-text'>" + this.m_primaryText + "</span>";
		placeholderContentHTML += this.m_actionableControl ? "<span class ='actionable-control'>" + this.m_actionableControl.render() + "</span>" : "";
		placeholderContentHTML += "</div>";		
		return placeholderContentHTML;
	};
	return PlaceholderContent;
})();


/* eslint-disable no-underscore-dangle */
/* global MPageUI */
/* global MPageTooltip */

MPageUI.TABLE_OPTIONS = {
	HIGHLIGHT: {
		NONE: "",
		ROW: "table-hover",
		CELL: "table-hover-cell"
	},
	SORT: {
		ASCENDING: -1,
		DESCENDING: 1,
		NONE: 0
	},
	SELECT: {
		NONE: 0,
		SINGLE_ROW: 1,
		MULTI_ROW: 2
	}
};
MPageUI.Table = (function() {
	/**
	 * The Table class.
	 * The Table is to be used for html table functionality and extensions upon the table. The API provides a standard
	 * markup system and predefined styles to ensure consistency.
	 * @constructor
	 */
	var Table = function() {
		this.base();
		this.m_columns = null;
		this.m_data = null;
		this.m_groupingData = null;
		this.m_recordHash = null;
		this.m_selection = null;
		this.m_maxHeight = 200;
		this.m_options = {
			columns: {
				separators: true
			},
			highlight: MPageUI.TABLE_OPTIONS.HIGHLIGHT.NONE,
			namespace: "",
			rows: {
				striped: true
			},
			show: {
				header: true
			},
			select: MPageUI.TABLE_OPTIONS.SELECT.NONE
		};
		this.m_tableHover = null;
		//Callbacks
		this.m_rowClickCallback = null;
		this.m_cellClickCallback = null;
		this.m_columnHeaderClickCallback = null;
		this.m_groupClickCallback = null;
		this.m_hoverCallBack = null;

		//Selection range
		this.m_lastClickedRecord = null;
	};
	MPageUI.extend(Table, MPageUI.UIComponent);

	/**
	 * Returns the list of column configurations for the table.
	 * @returns {Array<object>} The list of column configurations for the table.
	 */
	Table.prototype.getColumns = function() {
		if (!this.m_columns) {
			this.m_columns = [];
		}
		return this.m_columns;
	};

	/**
	 * Sets the column data.
	 * @param {Array<object>} columns - The column data.
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setColumns = function(columns) {
		this.m_columns = columns;
		return this;
	};

	/**
	 * Checks if a given column field is sortable
	 * @throws {Error} Throws an error if the parameter is not a string.
	 * @param  {string}  columnId - The id of the column being tested.
	 * @return {boolean} true/false if the column specified is sortable
	 * @private
	 */
	Table.prototype.isColumnSortable = function(columnId) {
		if (typeof columnId !== "string") {
			throw new Error("MPageUI.Table.prototype.isColumnSortable expects columnId to be a string");
		}
		var columns = this.getColumns();
		var columnCount = columns.length;
		for (var i = 0; i < columnCount; i++) {
			var column = columns[i];
			//Find the column with the requested id
			if (column.id === columnId && column.sortOptions) {
				return true;
			}
		}
		return false;
	};
	/**
	 * Toggles the sort direction for a given column
	 * if the current sort direction is DESCENDING the function will set it to be ASCENDING.
	 * if the current sort direction is ASCENDING the function will set it to be DESCENDING.
	 * @return {undefined} Returns nothing
	 * @private
	 */
	Table.prototype.toggleSortDirection = function() {
		this.m_currentSortDirection *= -1;
	};

	/**
	 * Gets the sort class based on the sort direction
	 * ASCENDING will return "sort-asc"
	 * DESCENDING will return "sort-desc"
	 * @param  {Number} sortDirection 1 - DESCENDING
	 *                                0 - NONE
	 *                                -1 - ASCENDING
	 * @returns {String}               sort class
	 */
	Table.prototype.getSortClass = function(sortDirection) {
		switch (sortDirection) {
			case MPageUI.TABLE_OPTIONS.SORT.ASCENDING:
				return "sort-asc";
			case MPageUI.TABLE_OPTIONS.SORT.DESCENDING:
				return "sort-desc";
			default:
				return "";
		}
	};

	/**
	 * Sets the data that the table is to render. The table can render a list of records or a list of groups. Groups
	 * must be a container of records or groups (nested) and provide a label.
	 * @param {Object} data - The data to be rendered by the table. This must be of the form
	 * {
	 * 		groups: [
	 * 			label: "Group Label",
	 * 			records: [ ... ],
	 * 			groups: [ ... ]
	 * 		],
	 * }
	 * or
	 * {
	 * 		records: [
	 * 			{ ... },
	 * 			{ ... }
	 * 		],
	 * }
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setData = function(data) {
		this.validateData(data);
		this.m_data = data;
		this.resetSelection();
		//If grouping is already applied, process that now
		this.processGroups();
		this.processData();
		this.refresh();
		return this;
	};

	/**
	 * Processes the data provided to the table. This will hash the records, giving them a unique id that can link
	 * the markup back to the respective record.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.processData = function() {
		var data = this.m_data;
		var self = this;
		var groupCounter = 0;
		var recordCounter = 0;
		var recordHash = null;
		this.clearRecordHash();
		recordHash = this.getRecordHash();
		/**
		 * Recursively processes through the table data that was provided.
		 * @param {object} node - The current node being processed.
		 * @param {number} depth - The current depth in the recursion.
		 * @returns {undefined} Returns nothing
		 */
		function recursiveProcess(node, depth) {
			var records = node.records;
			var groups = node.groups;
			var recordCount = 0;
			var recordHashKey = null;
			var groupHashKey = null;
			var groupCount = 0;
			var record = null;
			var group = null;
			var i = 0;
			if (records && records.length) {
				recordCount = records.length;
				for (i = 0; i < recordCount; i++) {
					recordHashKey = "record_" + (recordCounter++);
					record = records[i];
					record._MPageUI = {
						recordHash: recordHashKey,
						selected: false,
						rowReference: (self.m_id + "_" + recordHashKey)
					};
					recordHash[record._MPageUI.recordHash] = record;
				}
			}
			if (groups && groups.length) {
				groupCount = groups.length;
				for (i = 0; i < groupCount; i++) {
					group = groups[i];
					//If the expanded attribute is not present, default to true
					if(typeof group.expanded === "undefined") {
						group.expanded = true;
					}
					groupHashKey = ((typeof group.id !== "undefined") ? (group.id + "") : ("group_" + (groupCounter++)));
					group._MPageUI = {
						depth: depth,
						groupHash: groupHashKey,
						groupReference: (self.m_id + "_" + groupHashKey)
					};
					recordHash[group._MPageUI.groupHash] = group;
					recursiveProcess(group, depth + 1);
				}
			}
		}

		recursiveProcess(data, 0);
	};

	/**
	 * A quick form of grouping that takes a set of group parameters and organizes the table records into groups based
	 * on qualifying fields. The groupData must be of the form.
	 * [
	 *        { field: "field1", display: "field1", expanded: true|false },
	 *        { field: "field2", display: "field2", expanded: true|false },
	 *        ...
	 *        { field: "fieldN", display: "fieldN", expanded: true|false }
	 * ]
	 * Where field is the field on which the group is created and
	 * display is the field in the record which populates the header of the group and
	 * expanded is the default expanded state of groups created on that field.
	 * @param {Array<object>} groupData - The group data which will organize the table records into groups.
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.setGrouping = function(groupData) {
		this.m_groupingData = groupData;
		if (!this.m_data) {
			return;
		}
		//Reset necessary selection tracking
		this.resetSelection();
		this.processGroups();
		this.processData();
		this.refresh();
	};

	/**
	 * Resets the variables that are used to track table selection data.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.resetSelection = function() {
		this.m_selection = null;
		this.m_lastClickedRecord = null;
	};

	/**
	 * Processes the table data into groups based on the grouping parameters specified when calling the setGrouping
	 * function. Once the existing data has been processed into groups, the internal data will be overwritten.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.processGroups = function() {
		if (!this.m_data) {
			return;
		}
		var groupData = this.m_groupingData;
		if (!groupData) {
			return;
		}
		var records = this.getAllRecords();
		var recordCount = records.length;
		var data = {};
		var groupHash = {};

		/**
		 * Recursively traverse down the group chain and build the group data structure with each record
		 * in its corresponding group.
		 * @param {object} record - The record being placed into the structure.
		 * @param {number} depth - How deep in the group tree the recursion is.
		 * @param {object} parent - The parent data object keeping track of assigned groups.
		 * @param {object} currentGroup - The current group in the group data tree.
		 * @returns {undefined} Returns nothing.
		 */
		function recursiveGroup(record, depth, parent, currentGroup) {
			//If the bottom has been reached (we must now process records)
			if (depth >= groupData.length) {
				if (!currentGroup.records) {
					currentGroup.records = [];
				}
				currentGroup.records.push(record);
				return;
			}
			var groupField = groupData[depth].field;
			var groupDisplayField = groupData[depth].display;
			var grouping = record[groupField];
			var groupExpanded = (typeof groupData[depth].expanded !== "undefined") ? groupData[depth].expanded : true;
			//We have not encountered a group for the hash of the record
			if (!parent[grouping]) {
				if (!currentGroup.groups) {
					currentGroup.groups = [];
				}
				//Add the new group to the hierachy of groups
				currentGroup.groups.push({
					label: record[groupDisplayField],
					expanded: groupExpanded
				});
				parent[grouping] = {};
				parent[grouping]._groupRef = currentGroup.groups.length - 1;
			}
			recursiveGroup(record, depth + 1, parent[grouping], currentGroup.groups[parent[grouping]._groupRef]);
		}

		//Iterate over each record and find its place in the group hierarchy
		for (var i = 0; i < recordCount; i++) {
			recursiveGroup(records[i], 0, groupHash, data);
		}
		//Overwrite existing data with newly grouped data
		this.m_data = data;
	};

	/**
	 * Retrieves the record hash object.
	 * @private
	 * @returns {Object<string, object>} The mapping of record id strings to record objects.
	 */
	Table.prototype.getRecordHash = function() {
		if (!this.m_recordHash) {
			this.m_recordHash = {};
		}
		return this.m_recordHash;
	};

	/**
	 * Performs validation on the data provided to the table.
	 * @param {object} data - The data provided to the table.
	 * @throws {Error} Throws an error if the following conditions are not met
	 * 1). The data is not an object
	 * 2). The data does not provide groups or records
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.validateData = function(data) {
		if (typeof data !== "object") {
			throw new Error("MPageUI.Table.prototype.validateData expects an object");
		}
		if (!data.groups && !data.records) {
			throw new Error("MPageUI.Table.prototype.validateData expects the data to have groups or records");
		}
	};

	/**
	 * Retrieves a flattened array of all records that reside in the table. Recards are leaf nodes.
	 * @returns {Array<object>} The flattened array of all records residing in the table.
	 */
	Table.prototype.getAllRecords = function() {
		var allRecords = [];
		if (!this.m_data) {
			return allRecords;
		}
		/**
		 * Recursively traverses the table data and finds all records (leaf nodes).
		 * @param {object} node - The current node being processed recursively.
		 * @returns {undefined} Returns nothing.
		 */
		function recursiveRecordFind(node) {
			var groups = node.groups;
			var records = node.records;
			var groupCount = 0;
			var recordCount = 0;
			var i = 0;
			if (records && records.length) {
				recordCount = records.length;
				for (i = 0; i < recordCount; i++) {
					allRecords.push(records[i]);
				}
			}
			if (groups && groups.length) {
				groupCount = groups.length;
				for (i = 0; i < groupCount; i++) {
					recursiveRecordFind(groups[i]);
				}
			}
		}

		recursiveRecordFind(this.m_data);
		return allRecords;
	};

	/**
	 * Clears the record hash.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.clearRecordHash = function() {
		this.m_recordHash = null;
	};

	/**
	 * Utility function to sort the table with specified options.
	 * {
	 * 		column: { id: "columnId", direction: MPageUI.TABLE_OPTIONS.SORT.ASCENDING | MPageUI.TABLE_OPTIONS.SORT.DESCENDING }
	 * }
	 * If sorting by column and the column is already being sorted and no
	 * direction is specified, the table will toggle the sort direction. If
	 * a direction is specified, the table will honor the direction. If the
	 * column is not currently sorted, the table will honor the direction if specified,
	 * otherwise, it will use the default sort direction as specified in the
	 * column's primary sort options.
	 * @param {Object} sortOptions - The sort options object. Currently only
	 * supports sorting by column.
	 *
	 *    column:{
	 *        id: "...", [required]
	 *        direction: MPagesUI.TABLE_OPTIONS.SORT.[ASCENDING|DESCENDING] [optional]
	 *    }
	 *
	 * @returns {Undefined} Returns nothing.
	 */
	Table.prototype.sortBy = function(sortOptions) {
		if (typeof sortOptions !== "object") {
			throw new Error("MPageUI.Table.prototype.sortBy the parameter is not an object");
		}
		if (sortOptions.column) {
			var columnId = sortOptions.column.id;
			var direction = sortOptions.column.direction || null;
			//Validate that the column is sortable meaning that sortOptions are available
			if (!this.isColumnSortable(columnId)) {
				return;
			}
			//If already sorted by this column
			if (this.m_currentlySortedColumnId === columnId) {
				if (direction !== null) {
					this.m_currentSortDirection = direction;
				} else {
					this.toggleSortDirection();
				}
			} else {
				//Currently not sorted by this column
				//If available use the direction from the sort options, otherwise use the primarysort direction defined on the column
				if (direction !== null) {
					this.m_currentSortDirection = direction;
				} else {
					var columnSortOptions = this.getColumnSortOptions(columnId);
					this.m_currentSortDirection = columnSortOptions.primary.direction;
				}
			}
			this.m_currentlySortedColumnId = columnId;
		}
		this.refresh();
	};
	/**
	 * Sets the configurable options for the table. All customization options are specified via this function. The
	 * options must be of the form
	 * {
	 * 		columns: {
	 *			separators: true | false
	 * 		},
	 *		highlight: MPageUI.TABLE_OPTIONS.HIGHLIGHT.[ROW|CELL],
	 *		namespace: "",
	 *		rows: {
	 *			striped: true | false
	 *		},
	 *		show: {
	 *			header: true | false
	 *		},
	 *		sort: {
	 *			sortable: true | false,
	 *			sortDirection: MPageUI.TABLE_OPTIONS.[ASCENDING|DESCENDING|NONE]
	 *		},
	 * }
	 * @throws {Error} If the parameter is not an object
	 * @param {object} options - The customization configuration object (see above).
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setOptions = function(options) {
		if (typeof options !== "object") {
			throw new Error("MPageUI.Table.prototype.setOptions the parameter is not an object");
		}
		var currentOptions = this.m_options;
		//Column options
		if (options.columns) {
			var columnOptions = currentOptions.columns;
			columnOptions.separators = (typeof options.columns.separators !== "undefined") ?
				options.columns.separators : columnOptions.separators;
		}
		//Highlight option
		if (options.highlight) {
			currentOptions.highlight = (typeof options.highlight !== "string") ? currentOptions.highlight : options.highlight;
		}
		//Row Options
		if (options.rows) {
			var rowOptions = currentOptions.rows;
			//Striped
			rowOptions.striped = (typeof options.rows.striped !== "undefined") ?
				options.rows.striped : rowOptions.striped;
		}
		//Show Options
		if (options.show) {
			var showOptions = currentOptions.show;
			//Header
			showOptions.header = (typeof options.show.header !== "undefined") ?
				options.show.header : showOptions.header;
		}
		//Select options
		if (options.select) {
			currentOptions.select = (typeof options.select !== "number") ? currentOptions.select : options.select;
		}
		//Namespace option
		if (options.namespace) {
			currentOptions.namespace = (typeof options.namespace !== "string") ? currentOptions.namespace : options.namespace;
		}
		return this;
	};

	/**
	 * Retrieves the full list of column ids associated to the table.
	 * @private
	 * @returns {Array<string>} The full list of column ids that have been bound to the table.
	 */
	Table.prototype.getAllColumnIds = function() {
		var columns = this.m_columns;
		var columnCount = columns.length;
		var allColumnIds = [];
		for (var i = 0; i < columnCount; i++) {
			allColumnIds.push(columns[i].id);
		}
		return allColumnIds;
	};

	/**
	 * Retrieve the list of column ids except for the specified id.
	 * @param {string} columnId - The columnId to be excluded from the full list of column ids.
	 * @private
	 * @returns {Array<string>} The list of column ids except for the field provided.
	 */
	Table.prototype.getAllColumnIdsExcept = function(columnId) {
		var columns = this.m_columns;
		var columnCount = columns.length;
		var allColumnIds = [];
		for (var i = 0; i < columnCount; i++) {
			if (columns[i].id !== columnId) {
				allColumnIds.push(columns[i].id);
			}
		}
		return allColumnIds;
	};

	/**
	 * Returns the list of selected objects. This is not to be confused with the consumer facing getSelectionData
	 * function.
	 * @private
	 * @returns {Array<object>} The list of selection data.
	 */
	Table.prototype.getSelection = function() {
		if (!this.m_selection) {
			this.m_selection = [];
		}
		return this.m_selection;
	};

	/**
	 * Retrieves the selection data in such a way that consumers can digest it. The data is returned in the form of
	 * [
	 *        {
	 * 			record: object,
	 * 			fields: [field1, field2, ..., field(n)] | null
	 *		}
	 * ]
	 * The data is an array of objects which specify which records have a selection and which fields in the record
	 * are selected. If the fields attribute is null, it is assumed that the entire record (row) is selected.
	 * @returns {Array} The list of selected records and fields (if any) that are currently selected in the table.
	 */
	Table.prototype.getSelectionData = function() {
		var selections = this.getSelection();
		var selectionCount = selections.length;
		var selectionData = [];
		for (var i = 0; i < selectionCount; i++) {
			selectionData.push({
				record: selections[i],
				columns: (selections[i]._MPageUI.cellSelection || null)
			});
		}
		return selectionData;
	};

	/**
	 * Retrieves a record object from an element.
	 * @param {jQuery} $element - The jQuery element from which the associated record will be retrieved.
	 * @private
	 * @returns {null|Object} The retrieved record or null.
	 */
	Table.prototype.getRecordFromElement = function($element) {
		var recordHashKey = $element.attr("data-record");
		var record = null;
		if (!recordHashKey) {
			return null;
		}
		record = this.getRecordHash()[recordHashKey];
		if (!record) {
			return null;
		}
		return record;
	};

	/**
	 * Sets the hover callback function to handle the event when a table row/cell is hovered over.
	 * @param {Function} hoverContentCallback - The callback function to produce the content for the hover event
	 * @param {String} highlightOption - The highlight option for the hover ROW|CELL|NONE
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setHover = function(hoverContentCallback, highlightOption) {
		if (typeof hoverContentCallback !== "function") {
			throw new Error("MPageUI.Table.prototype.setHover expects a function");
		}
		//Override the highlight option
		if (highlightOption) {
			this.m_options.highlight = highlightOption;
		}

		this.m_hoverCallBack = hoverContentCallback;
		return this;
	};
	/**
	 * Sets the callback function to handle the event when a table column header is clicked.
	 * @param {function} callback - The callback function to handle the column header click.
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setOnColumnHeaderClickCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("MPageUI.Table.prototype.setOnColumnHeaderClick expects a function");
		}
		this.m_columnHeaderClickCallback = callback;
		return this;
	};

	/**
	 * Sets the callback function to handle the event when a table cell is clicked.
	 * @param {function} callback - The callback function to handle the cell click event.
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setOnCellClickCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("MPageUI.Table.prototype.setOnCellClickCallback expects a function");
		}
		this.m_cellClickCallback = callback;
		return this;
	};

	/**
	 * Sets the callback function to handle the event when a table rows is clicked.
	 * @param {function} callback - The callback function to handle the row click event.
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setOnRowClickCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("MPageUI.Table.prototype.setOnRowClickCallback expects a function");
		}
		this.m_rowClickCallback = callback;
		return this;
	};

	/**
	 * Sets the callback function to handle the event when a table group (section) is clicked.
	 * @param {function} callback - The callback function to handle the group (section) click event.
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setOnGroupClickCallback = function(callback) {
		if (typeof callback !== "function") {
			throw new Error("MPageUI.Table.prototype.setOnGroupClickCallback expects a function");
		}
		this.m_groupClickCallback = callback;
		return this;
	};

	/**
	 * Handles the group section click event for the table.
	 * @param {Event} event - The jQuery event that occurred.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.onGroupClick = function(event) {
		var $targetElement = $(event.currentTarget);
		if (!$targetElement || !$targetElement.length) {
			logger.logWarning("MPageUI.Table.prototype.onGroupClick: a target element was not found.");
			return;
		}
		var groupHash = $targetElement.attr("data-group");
		if (!groupHash) {
			logger.logWarning("MPageUI.Table.prototype.onGroupClick: a group hash has not been associated to the group section, verify the group objects.");
			return;
		}
		var group = this.getRecordHash()[groupHash];
		if (!group) {
			logger.logWarning("MPageUI.Table.prototype.onGroupClick: a group was not found with the hash");
			return;
		}
		//If the group is collapsible toggle the group, undefined will default collapsible to true
		if (typeof group.collapsible === "undefined" || group.collapsible) {
			this.toggleGroup(group);
		}
		//Call the consumer provided callback
		if (this.m_groupClickCallback) {
			this.m_groupClickCallback({
				groups: [group],
				event: event
			});
		}
	};

	/**
	 * Retrieves the sort options for the column with the specified id.
	 * @param {string} columnId - The id of the column for which we are retrieving sort options.
	 * @returns {Object|null} The sort options for the specified column or null
	 * if the column was not found.
	 * @private
	 */
	Table.prototype.getColumnSortOptions = function(columnId) {
		var columns = this.getColumns();
		//Iterate through the columns and check if the requested column contains sort options if so return the sort options
		for (var i = 0; i < columns.length; i++) {
			var column = columns[i];
			if (column.id === columnId && column.sortOptions) {
				return column.sortOptions;
			}
		}
		//No sortOptions found for the selected column
		return null;
	};
	/**
	 * Handles the column header click event for the table.
	 * @param {Event} event - The jQuery event that occurred.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.onColumnHeaderClick = function(event) {
		var $targetElement = $(event.currentTarget);
		if (!$targetElement || !$targetElement.length) {
			logger.logWarning("MPageUI.Table.prototype.onColumnHeaderClick: a target element was not found.");
			return;
		}
		var columnId = $targetElement.attr("data-column");
		if (!columnId) {
			logger.logWarning("MPageUI.Table.prototype.onColumnHeaderClick: a field has not been associated to the column, verify the column objects.");
			return;
		}
		var columnSortOptions = this.getColumnSortOptions(columnId);
		var canUserSort = true;
		if(columnSortOptions && typeof columnSortOptions.userSort !== "undefined") {
			canUserSort =  columnSortOptions.userSort;
		}
		if(canUserSort){
			this.sortBy({
				"column": {id: columnId}
			});
		}
		if (this.m_columnHeaderClickCallback) {
			this.m_columnHeaderClickCallback({
				records: this.getAllRecords(),
				columns: [columnId],
				event: event
			});
		}
	};

	/**
	 * Hover event to be triggered upon hovering over a table cell and display the content set via setHover()
	 * this function will display the content in a hover utilizing the MPageTooltip
	 * @param  {Event} event jQuery event the occured
	 * @return {Undefined}       Returns nothing.
	 * @private
	 */
	Table.prototype.onHover = function(event) {
		//Do nothing if no hover callback is available
		if (!this.m_hoverCallBack) {
			return;
		}
		//Get the table row element in order to get the row record data
		var $targetElement = $(event.currentTarget.parentElement);
		var record = null;
		var columnId = null;
		var data = {};
		//No target element available
		if (!$targetElement || !$targetElement.length) {
			logger.logWarning("MPageUI.Table.prototype.onHover: a target element was not found.");
			return;
		}
		//Get the record data from the table row element
		record = this.getRecordFromElement($targetElement);
		//No record available
		if (!record) {
			logger.logWarning("MPageUI.Table.prototype.onHover: could not find a record for the row");
			return;
		}
		//Get the table cell element
		$targetElement = $(event.currentTarget);
		//The column name of the cell that is being hovered over
		columnId = $targetElement.attr("data-column");
		//Create the data object that will be used with the hover content callback
		data = {
			records: [record],
			columns: [columnId],
			event: event
		};
		//Get hover content with the callback
		var content = this.m_hoverCallBack(data);
		//Initialize the hover if not available
		if (!this.m_tableHover) {
			this.m_tableHover = new MPageTooltip().setShowDelay(0);
		}
		//Set the hover
		this.m_tableHover.setX(event.pageX).setY(event.pageY).setAnchor($targetElement).setContent(content);
		//Display the hover
		this.m_tableHover.show();
	};
	/**
	 * Handles the row click event for the table.
	 * @param {Event} event - The jQuery event that occurred.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.onRowClick = function(event) {
		var $targetElement = $(event.currentTarget);
		var record = null;
		if (!$targetElement || !$targetElement.length) {
			logger.logWarning("MPageUI.Table.prototype.onRowClick: a target element was not found.");
			return;
		}
		record = this.getRecordFromElement($targetElement);
		if (!record) {
			return;
		}
		this.handleSelection(record, event);
		if (this.m_rowClickCallback) {
			this.m_rowClickCallback({
				records: [record],
				event: event
			});
		}
	};

	/**
	 * In the list of all records, returns the index of the specified record.
	 * @param {object} record - The record for which the index will be found.
	 * @returns {number} The index of the record, if found, otherwise it will
	 * return -1.
	 */
	Table.prototype.getRecordIndex = function(record) {
		var records = this.getAllRecords();
		for (var i = 0; i < records.length; i++) {
			if (records[i] === record) {
				return i;
			}
		}
		return -1;
	};

	/**
	 * Handles the table select functionality when the user shift-clicks a
	 * record in the table.
	 * @param {object} record - The record being selected.
	 * @param {object} lastClickedRecord - The record that was last selected
	 * (this becomes the anchor for the shift-select).
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.handleShiftSelect = function(record, lastClickedRecord) {
		//Record index values
		var currentIndex = this.getRecordIndex(record);
		var indexOfLastSelectedRecord = this.getRecordIndex(lastClickedRecord);
		//Range information
		var startRange = indexOfLastSelectedRecord;
		var endRange = indexOfLastSelectedRecord;
		//No record has been previously selected
		if (!lastClickedRecord) {
			startRange = 0;
			endRange = currentIndex;
		} else {
			if (currentIndex < indexOfLastSelectedRecord) {
				startRange = currentIndex;
			} else {
				endRange = currentIndex;
			}
		}
		//Perform the actual selection
		this.select({
			records: this.getAllRecords().slice(startRange, endRange + 1),
			options: {clearPrevious: true}
		});
	};

	/**
	 * Handles the table select functionality when the user ctrl-clicks a record
	 * in the table.
	 * @param {object} record - The record being selected.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.handleControlSelect = function(record) {
		var selectOptions = {
			records: [record],
			options: {
				toggle: true
			}
		};
		this.select(selectOptions);
		this.m_lastClickedRecord = record;
	};

	/**
	 * Handles the table single select functionality (when the user simply clicks
	 * on a record in the table).
	 * @param {object} record - The record being selected.
	 * @param {Array<object>} currentSelection - The current table selection.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.handleSingleSelect = function(record, currentSelection) {
		var selectOptions = {
			records: [record],
			options: {}
		};
		if (currentSelection.length === 1 && currentSelection[0] === record) {
			selectOptions.options.toggle = true;
		} else {
			selectOptions.options.clearPrevious = true;
		}
		this.select(selectOptions);
		this.m_lastClickedRecord = record;
	};

	/**
	 * Handles the selection logic for the table.
	 * @param {object} record - The record object that was selected (as derived
	 * from the row that was clicked).
	 * @param {MouseEvent} event - The mouse event that triggered the selection.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.handleSelection = function(record, event) {
		var selectMode = this.m_options.select;
		var selectModeEnum = MPageUI.TABLE_OPTIONS.SELECT;
		var currentSelection = this.getSelection();
		var shiftHeld = event.shiftKey;
		var ctrlHeld = event.ctrlKey;
		var lastClickedRecord = this.m_lastClickedRecord;
		switch (selectMode) {
			case selectModeEnum.SINGLE_ROW:
				this.handleSingleSelect(record, currentSelection);
				break;
			case selectModeEnum.MULTI_ROW:
				if (shiftHeld) {
					this.handleShiftSelect(record, lastClickedRecord);
				} else if (ctrlHeld) {
					this.handleControlSelect(record);
				} else {
					this.handleSingleSelect(record, currentSelection);
				}
				break;
			default:
				break;
		}
	};

	/**
	 * Handles the cell click event. If the consumer has provided the cell click callback, that function is triggered.
	 * @param {Event} event - The jQuery event that occurred.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.onCellClick = function(event) {
		var $targetElement = $(event.currentTarget);

		var record = null;
		var columnId = null;
		if (!$targetElement || !$targetElement.length) {
			logger.logWarning("MPageUI.Table.prototype.onCellClick: a target element was not found.");
			return;
		}
		record = this.getRecordFromElement($targetElement);
		columnId = $targetElement.attr("data-column");
		if (!record) {
			return;
		}
		if (!columnId) {
			return;
		}
		if (this.m_cellClickCallback) {
			this.m_cellClickCallback({
				records: [record],
				columns: [columnId],
				event: event
			});
		}
	};

	/**
	 * Handles the group section click event.
	 * @param {object} group - The group being toggled.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.toggleGroup = function(group) {
		var $tableBody = this.getRootElement().find("tbody");
		group.expanded = !group.expanded;
		//Optimization. Without detaching, a recursive hide will cause N reflows. Detaching will only trigger 2 reflows.
		$tableBody.detach();
		var $groupElement = $tableBody.find("#" + group._MPageUI.groupReference);

		/**
		 * Recursively hides elements in the table.
		 * @param {object} node - The current node being processed.
		 * @returns {undefined} Returns nothing.
		 */
		function recursiveHide(node) {
			var groups = node.groups;
			var records = node.records;
			var groupCount = 0;
			var recordCount = 0;
			var record = null;
			var childGroup = null;
			var i = 0;
			if (records) {
				recordCount = records.length;
				for (i = 0; i < recordCount; i++) {
					record = records[i];
					$tableBody.find("#" + record._MPageUI.rowReference).hide();
				}
				//If this node has no records, attempt to hide the no records found row (it should be the next immediate sibling)
				if (!recordCount) {
					$tableBody.find("#" + node._MPageUI.groupReference).next("[data-type='no-records']").hide();
				}
			}
			if (groups && groups.length) {
				groupCount = groups.length;
				for (i = 0; i < groupCount; i++) {
					childGroup = groups[i];
					$tableBody.find("#" + childGroup._MPageUI.groupReference).hide();
					//Optimization. Only recursively hide subsequent groups if it is currently expanded.
					if (childGroup.expanded) {
						recursiveHide(childGroup);
					}
				}
			}
		}

		/**
		 * Recursively shows elements in the table. If a node has not yet been rendered, it will render the node.
		 * @param {object} node - The current node being processed.
		 * @returns {undefined} Returns nothing.
		 */
		function recursiveShow(node) {
			var groups = node.groups;
			var records = node.records;
			var groupCount = 0;
			var recordCount = 0;
			var record = null;
			var childGroup = null;
			var nodeIsExpanded = node.expanded;
			var i = 0;
			if (records && nodeIsExpanded) {
				recordCount = records.length;
				for (i = 0; i < recordCount; i++) {
					record = records[i];
					$tableBody.find("#" + record._MPageUI.rowReference).css("display", "");
				}
				//If this node has no records, attempt to show the no records found row (it should be the next immediate sibling)
				if (!recordCount) {
					$tableBody.find("#" + node._MPageUI.groupReference).next("[data-type='no-records']").css("display", "");
				}
			}
			if (groups && groups.length && nodeIsExpanded) {
				groupCount = groups.length;
				for (i = 0; i < groupCount; i++) {
					childGroup = groups[i];
					$tableBody.find("#" + childGroup._MPageUI.groupReference).css("display", "");
					recursiveShow(childGroup);
				}
			}
		}

		if (!group.expanded) {
			$tableBody.find("#" + group._MPageUI.groupReference).addClass("collapsed");
			recursiveHide(group);
		} else {
			$tableBody.find("#" + group._MPageUI.groupReference).removeClass("collapsed");
			//If this node was pruned, render its children...
			if (group._MPageUI.pruned) {
				group._MPageUI.pruned = null;
				$groupElement.after(this.renderData(group, group._MPageUI.depth + 1));
			} else {
				recursiveShow(group);
			}
		}
		//Re-attach the table body to the table once we have finished manipulating the DOM.
		this.getRootElement().find(".table-body>table:first-child").append($tableBody);
		this.resize();
	};

	/**
	 * Finds the specified record in the list of records that currently have some form of selection (record or column).
	 * @param {object} record - The record being checked.
	 * @private
	 * @returns {number} The index in the array of selected records, otherwise -1 is returned.
	 */
	Table.prototype.getSelectionIndex = function(record) {
		var selection = this.getSelection();
		var selectionCount = selection.length;
		for (var i = 0; i < selectionCount; i++) {
			if (selection[i] === record) {
				return i;
			}
		}
		return -1;
	};

	/**
	 * For the specified column, searches through the list of selected column (if any) and determines if the column
	 * is currently selected for the record. If the column is selected in the record, the index in the array is returned.
	 * Otherwise, -1 is returned to indicate the column is not selected on the record.
	 * @param {object} record - The record in which the search will be performed.
	 * @param {string} column - The name of the column being tested.
	 * @private
	 * @returns {number} The index in the array of selected columns, otherwise -1 is returned.
	 */
	Table.prototype.getSelectedCellIndex = function(record, column) {
		var mpageUIData = record._MPageUI;
		var selectedCells = mpageUIData.cellSelection;
		if (!selectedCells) {
			return -1;
		}
		var selectedCellCount = selectedCells.length;
		for (var i = 0; i < selectedCellCount; i++) {
			if (selectedCells[i] === column) {
				return i;
			}
		}
		return -1;
	};

	/**
	 * An advanced selection function. This will perform selection on the table. The selection options must be of the form
	 * {
	 * 		records: [ ... ] (a list of records to select)
	 *		columns: [ ... ] (a list of field identifiers)
	 *		options: {
	 *			toggle: true | false (boolean indicating if selection should toggle),
	 *			clearPrevious: true | false (boolean indicating if previous selection should be cleared)
	 *		}
	 * }
	 * WARNING: Using field (cell) selection can be non-performant. The table must keep track of which fields are
	 * selected and apply styling to each cell individually.
	 * @param {object} selectOptions - The select parameters (see above).
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.select = function(selectOptions) {
		var records = selectOptions.records;
		if (!records) {
			records = this.getAllRecords();
		}
		var recordCount = records.length;
		var record = null;
		var columns = selectOptions.columns;
		var toggle = selectOptions.options && selectOptions.options.toggle || false;
		var clearPrevious = selectOptions.options && selectOptions.options.clearPrevious || false;
		var fieldCount = columns ? columns.length : 0;
		if (clearPrevious) {
			this.deselectAll();
		}
		//If selection should qualify on records
		for (var i = 0; i < recordCount; i++) {
			record = records[i];
			if (!columns) {
				if (toggle) {
					this.toggleRecordSelection(record);
				}
				else {
					this.selectRecord(record);
				}
			}
			else {
				for (var j = 0; j < fieldCount; j++) {
					if (toggle) {
						this.toggleCellSelection(record, columns[j]);
					}
					else {
						this.selectCell(record, columns[j]);
					}
				}
			}
		}
	};

	/**
	 * Toggles the selection state of the cell.
	 * @param {object} record - The record in which the cell being toggled resides.
	 * @param {string} column - The column within the record that is being toggled.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.toggleCellSelection = function(record, column) {
		var selectedCellIndex = this.getSelectedCellIndex(record, column);
		if (selectedCellIndex > -1 || record._MPageUI.selected) {
			this.deselectCell(record, column);
		} else {
			this.selectCell(record, column);
		}
	};

	/**
	 * Selects the cell.
	 * @param {object} record - The record in which the cell being selected resides.
	 * @param {string} column - The column within the record that is being selected.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.selectCell = function(record, column) {
		var mpageUIData = record._MPageUI;
		var selectedCellIndex = this.getSelectedCellIndex(record, column);
		if (mpageUIData.selected || selectedCellIndex > -1) {
			return;
		}
		if (!mpageUIData.cellSelection) {
			mpageUIData.cellSelection = [];
		}
		mpageUIData.cellSelection.push(column);
		var selectedIndex = this.getSelectionIndex(record);
		if (selectedIndex < 0) {
			this.getSelection().push(record);
		}
		if (mpageUIData.cellSelection.length === this.m_columns.length) {
			mpageUIData.cellSelection = null;
			$("#" + record._MPageUI.rowReference).addClass("selected").find(".selected").removeClass("selected");
			mpageUIData.selected = true;
		} else {
			$("#" + record._MPageUI.rowReference + " td[data-column='" + column + "']").addClass("selected");
		}
	};

	/**
	 * Deselects the specified cell (a cell is denoted by a record and field identifier).
	 * @param {object} record - The record the desired cell lies within.
	 * @param {string} column - The field in the record object which is considered the cell
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.deselectCell = function(record, column) {
		var mpageUIData = record._MPageUI;
		var wasSelected = mpageUIData.selected;
		var selectedCellIndex = this.getSelectedCellIndex(record, column);
		var isCellSelected = (selectedCellIndex > -1) || wasSelected;
		var cellSelection = null;
		if (!isCellSelected) {
			return;
		}
		cellSelection = mpageUIData.cellSelection;
		if (wasSelected) {
			mpageUIData.cellSelection = cellSelection = this.getAllColumnIdsExcept(column);
			$("#" + record._MPageUI.rowReference).removeClass("selected");
			record._MPageUI.selected = false;
			for (var i = 0; i < cellSelection.length; i++) {
				$("#" + record._MPageUI.rowReference + " td[data-column='" + cellSelection[i] + "']").addClass("selected");
			}
		}
		if (selectedCellIndex > -1) {
			cellSelection.splice(selectedCellIndex, 1);
		}
		//If there are no more cells selected, remove the record from selection
		if (!cellSelection.length) {
			mpageUIData.cellSelection = null;
			this.getSelection().splice(this.getSelectionIndex(record), 1);
		}
		$("#" + record._MPageUI.rowReference + " td[data-column='" + column + "']").removeClass("selected");
	};

	/**
	 * Deselects everything in the table.
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.deselectAll = function() {
		var selectedRecords = this.getSelection();
		var selectedRecordCount = selectedRecords.length;
		var selectedRecord = null;
		var mpageUIData = null;
		for (var i = 0; i < selectedRecordCount; i++) {
			selectedRecord = selectedRecords[i];
			mpageUIData = selectedRecord._MPageUI;
			mpageUIData.selected = false;
			mpageUIData.cellSelection = null;
		}
		this.getRootElement().find(".selected").removeClass("selected");
		this.m_selection = null;
	};

	/**
	 * Toggles the selection of the specified record. If it is selected, it will be deselected and vice-versa.
	 * @param {object} record - The JSON record for which selected status will be toggled.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.toggleRecordSelection = function(record) {
		var mpageUIData = record._MPageUI;
		//Some cells are selected, so we need to toggle them
		if (mpageUIData.cellSelection) {
			this.select({
				records: [record],
				columns: this.getAllColumnIds(),
				options: {
					toggle: true
				}
			});
			return;
		}
		if (mpageUIData.selected) {
			this.deselectRecord(record);
		} else {
			this.selectRecord(record);
		}
	};

	/**
	 * Selects the specified record.
	 * @param {object} record - The record to be selected
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.selectRecord = function(record) {
		var mpageUIData = record._MPageUI;
		var selectionIndex = this.getSelectionIndex(record);
		//If the record is already currently selected, return
		if (mpageUIData.selected) {
			return;
		}
		var $recordElement = $("#" + record._MPageUI.rowReference);
		//If the record had cells selected, we can remove that and save some memory
		if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
			$recordElement.find(".selected").removeClass("selected");
			mpageUIData.cellSelection = null;
		}
		$recordElement.addClass("selected");
		record._MPageUI.selected = true;
		//If the record selection has not been stored off
		if (selectionIndex < 0) {
			this.getSelection().push(record);
		}
	};

	/**
	 * Deselects the specified record.
	 * @param {object} record - The record to be
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.deselectRecord = function(record) {
		var mpageUIData = record._MPageUI;
		var selectionIndex = this.getSelectionIndex(record);
		if (selectionIndex < 0) {
			return;
		}
		var $recordElement = $("#" + record._MPageUI.rowReference);
		//If the record had cells selected, we must deselect the cells as they are part of the record
		if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
			mpageUIData.cellSelection = null;
			$recordElement.find(".selected").removeClass("selected");
		}
		$recordElement.removeClass("selected");
		mpageUIData.selected = false;
		this.getSelection().splice(selectionIndex, 1);
	};

	/**
	 * Renders the colgroup markup which allows consumers to style their
	 * columns appropriately.
	 * @returns {string} The colgroup and col tags rendered as an HTML string.
	 */
	Table.prototype.renderColumns = function() {
		var html = "<colgroup>";
		html += this.getColumns().map(function(column) {
			return "<col class='" + (column.css || "") + "'>";
		}).join("");
		return html + "</colgroup>";
	};

	/**
	 * Renders the table as an html string.
	 * @returns {string} The table rendered as an html string.
	 */
	Table.prototype.render = function() {
		/*
		 * With a split head table, the following must happen
		 * 1). A wrapper div is created to encompass the entire DOM structure of the table
		 * 2). The table head and body are split into two separate tables
		 * 3). The header is rendered into the top table
		 * 4). The body is rendered into the lower table
		 * 5). The root of the split table becomes the wrapping element
		 */
		var classes = this.getClasses();
		var html = "<div id='" + this.m_id + "' class='" + classes + "'>";
		html += "<div class='table-head'><table>";
		html += this.renderColumns();
		html += this.renderHeader();
		html += "</table></div>";
		html += "<div class='table-body'><table>";
		html += this.renderColumns();
		html += this.renderBody();
		html += "</table></div></div>";
		return html;
	};

	/**
	 * Retrieves the CSS classes that will be applied to the table at the top
	 * DOM level. This is driven off of the options provided to the table.
	 * @private
	 * @returns {string} The set of CSS classes to be applied to the table.
	 */
	Table.prototype.getClasses = function() {
		var classes = "table-base";
		classes += (this.m_options.namespace) ? " " + this.m_options.namespace : "";
		classes += (this.m_options.rows.striped ? " table-striped" : "");
		classes += (this.m_options.columns.separators ? " table-with-separators" : "");
		classes += (this.m_options.highlight ? " " + this.m_options.highlight : "");
		return classes;
	};

	/**
	 * Renders the header of the table as an html string.
	 * @private
	 * @returns {string} The header of the table rendered as an html string.
	 */
	Table.prototype.renderHeader = function() {
		if (!this.m_options.show.header) {
			return "";
		}
		var header = "<thead><tr>";
		var sortClass = "";
		var columns = this.m_columns;
		var columnCount = columns ? columns.length : 0;
		var cellStyles = "";
		var canUserSort = true;
		var column = 0;
		for (var i = 0; i < columnCount; i++) {
			canUserSort = true;
			column = columns[i];
			sortClass = "";
			cellStyles = "";
			if (column.width) {
				cellStyles = "width='" + column.width + "'";
			}
			//set the sort class if the column is sortable
			if (this.isColumnSortable(column.id)) {
				//check if the user is allowed to sort this column
				canUserSort = (typeof column.sortOptions.userSort !== "undefined") ? column.sortOptions.userSort : true;
				if(canUserSort) {
					//add the sortable class to show the hover on the column header
					sortClass += " sortable ";
					//current sorted column will display the sort direction indicator
					if (this.m_currentlySortedColumnId === column.id) {
						sortClass += this.getSortClass(this.m_currentSortDirection);
					}
				}
			}
			header += "<th class='" + sortClass + "' data-column='" + columns[i].id + "' scope='col'" + cellStyles + ">" + (columns[i].label || "&nbsp;") + "</th>";
		}
		return header + "</tr></thead>";
	};

	/**
	 * Helper function to compare two values.
	 * @param a the first value to compare
	 * @param b the second value to compare
	 * @returns {number} a comparison value 1, -1, or 0, where 0 means equality
	 * @private
	 */
	Table.prototype.compare = function(a, b) {
		try {
			//Perform special logic for setting up sort values for comparison
			if (typeof a === "number" || typeof b === "number") {
				a = a || 0;
				b = b || 0;
			} else if (typeof a === "string" || typeof b === "string") {
				a = (a || "").toUpperCase();
				b = (b || "").toUpperCase();
			}
			if (a > b) {
				return -1;
			} else if (a < b) {
				return 1;
			} else {
				return 0;
			}
		} catch (exe) {
			logger.logError("Called MPageUI.Table.prototype.compare(a,b) with an invalid value for a or b");
			return 0;
		}
	};

	/**
	 * Gets the sort function to be used to sort the records of a given column.
	 * @returns {Function} The sort function.
	 * @private
	 */
	Table.prototype.getSortFunction = function() {
		var self = this;
		var currentColumn = this.m_currentlySortedColumnId;
		var columnSortOptions = this.getColumnSortOptions(currentColumn);
		var primaryField = columnSortOptions.primary.field;
		var currentSortDirection = this.m_currentSortDirection;
		return function(rowA, rowB) {
			var rowAVal = rowA[primaryField];
			var rowBVal = rowB[primaryField];
			var comparison = self.compare(rowAVal, rowBVal);
			//If the comparison on the primary sort fields isn't 0 (not equal), return this value
			if (comparison !== 0) {
				return currentSortDirection * comparison;
			}
			//check if secondary fields are available within the sort options for the current column
			if (columnSortOptions && columnSortOptions.secondary) {
				var secondarySortFields = columnSortOptions.secondary;
				var secondarySortFieldsCount = secondarySortFields.length;
				for (var i = 0; i < secondarySortFieldsCount; i++) {
					rowAVal = rowA[secondarySortFields[i].field];
					rowBVal = rowB[secondarySortFields[i].field];
					comparison = self.compare(rowAVal, rowBVal);
					if (comparison !== 0) {
						return secondarySortFields[i].direction * comparison;
					}
				}
			}
			//If we've made it this far, all fields are equal, so return 0
			return 0;
		};
	};

	/**
	 * Renders a no results message in the case that no records are present.
	 * @param {string} noRecordsMessage - The message to be displayed indicating
	 * that no records are present.
	 * @param {number} depth - The depth in the data tree at which the no
	 * records message is being rendered.
	 * @returns {string} The no records table row markup rendered as a string.
	 * @private
	 */
	Table.prototype.renderNoRecords = function(noRecordsMessage, depth) {
		return "<tr data-type='no-records' class='table-row no-records group-level-" + depth + "'>" +
			"<td class='table-cell' colspan='" + this.m_columns.length + "'>" + noRecordsMessage + "</td></tr>";
	};

	/**
	 * Renders the data that has been bound to the table.
	 * @param {object} data - The data bound to the table.
	 * @param {number} startDepth - The depth at which rendering started.
	 * @private
	 * @returns {string} The table body content rendered to an html string.
	 */
	Table.prototype.renderData = function(data, startDepth) {
		var self = this;
		var html = "";

		/**
		 * Recursively traverses through the table data and renders a flat html table.
		 * @param {object} node - The current node being rendered.
		 * @param {number} depth - The current recursion depth.
		 * @returns {undefined} Returns nothing.
		 * @private
		 */
		function recursiveRender(node, depth) {
			var records = node.records;
			var sortFunction = null;
			var columnSortData = self.getColumnSortOptions(self.m_currentlySortedColumnId);
			var groups = node.groups;
			var group = null;
			var expanded = true;
			if (records) {
				//check if the table is sortable
				if (columnSortData && records.length) {
					sortFunction = self.getSortFunction();
					records.sort(sortFunction);
				}
				if (records.length) {
					html += self.renderRecords(records, depth, node);
				} else {
					html += self.renderNoRecords(node.no_records || i18n.discernabu.NO_RESULTS_FOUND, depth);
				}
			}
			if (groups && groups.length) {
				for (var i = 0; i < groups.length; i++) {
					group = groups[i];
					if (typeof group.expanded !== "undefined") {
						expanded = group.expanded;
					}
					//get the group records count
					if (group.showCount) {
						group.recordCount = self.getRecordsCount(group, 0);
					}
					//Render the group markup
					html += self.renderGroup(group, depth);
					//Don't bother rendering children if the group is collapsed (save some DOM memory and processing)
					if (expanded) {
						recursiveRender(group, depth + 1);
					} else {
						group._MPageUI.pruned = true;
					}
				}
			}
		}

		recursiveRender(data, startDepth);
		return html;
	};

	/**
	 * Gets the record count for a group if showCount is set to true
	 * @param {object} data - The data bound to the table.
	 * @private
	 * @returns {number} The table body content rendered to an html string.
	 */
	Table.prototype.getRecordsCount = function(data) {
		var recordsCount = 0;

		/**
		 * Recursively traverses through the table groups and counts the records
		 * @param {object} node - The current node being rendered.
		 * @param {number} depth - The current recursion depth.
		 * @returns {undefined} Returns nothing.
		 */
		function recursiveRecordCount(node) {
			var records = node.records;
			var groups = node.groups;
			var group = null;
			if (records && records.length) {
				recordsCount += records.length;
			}
			if (groups && groups.length) {
				for (var i = 0; i < groups.length; i++) {
					group = groups[i];
					recursiveRecordCount(group);
				}
			}
		}

		recursiveRecordCount(data);
		return recordsCount;
	};

	/**
	 * Renders a group to an html string.
	 * @param {object} group - The group object to be rendered.
	 * @param {number} depth - The depth at which the group is being rendered.
	 * @private
	 * @returns {string} The group rendered as an html string.
	 */
	Table.prototype.renderGroup = function(group, depth) {
		var groupClasses = "table-section " + "group-level-" + depth;
		if(group.css) {
			groupClasses += (" " + group.css);
		}
		var showCount = group.showCount || false;
		var expanded = true;
		var collapsible = true;
		if (typeof group.collapsible !== "undefined") {
			collapsible = group.collapsible;
		}
		if (typeof group.expanded !== "undefined") {
			expanded = group.expanded;
		}
		if (!expanded) {
			groupClasses += " collapsed";
		}
		if (collapsible) {
			groupClasses += " collapsible";
		}
		//Group count display
		var groupCountHtml = (showCount) ? "<span data-group-count='" + group.recordCount + "' class='table-section-count'>&nbsp;(" + group.recordCount + ")</span>" : "";
		var html = "";
		html += "<tr id='" + group._MPageUI.groupReference + "' data-group='" + group._MPageUI.groupHash + "' class='" + groupClasses + "'>";
		html += "<th data-group='" + group._MPageUI.groupHash + "' colspan='" + this.m_columns.length + "'><span class='table-section-icon'></span>" + group.label + groupCountHtml + "</th>";
		return html + "</tr>";
	};

	/**
	 * Renders a list of table records as an html string.
	 * @param {Array<object>} records - The list of records to be rendered as an html string.
	 * @param {number} depth - The depth at which the records are being rendered (typically 0).
	 * @param {object} parentNode - The data node that is the parent to the record. This will
	 * either be the root data or a group.
	 * @private
	 * @returns {string} The list of records rendered as an html string.
	 */
	Table.prototype.renderRecords = function(records, depth, parentNode) {
		var html = "";
		var recordCount = records.length;
		var record = null;
		var column = null;
		var columns = this.m_columns;
		var columnCount = columns.length;
		var columnId = null;
		var contentFunction = null;
		var mpageUIData = null;
		var rowClasses = "";
		var cellClasses = "";
		var cellSelection = null;
		var cellStyle = "";
		var parentGroup = "";
		//Iterate over each result
		for (var i = 0; i < recordCount; i++) {
			rowClasses = "table-row";
			record = records[i];
			//Retrieve the stored MPageUI data
			mpageUIData = record._MPageUI;
			if (mpageUIData.selected) {
				rowClasses += " selected";
			}
			if (depth > 0) {
				parentGroup = "data-group='" + parentNode._MPageUI.groupHash + "'";
				rowClasses += " group-level-" + depth;
			}
			rowClasses += ((i % 2 === 0) ? "" : " stripe");
			html += "<tr id='" + this.m_id + "_" + record._MPageUI.recordHash + "'" + parentGroup + " data-record='" + record._MPageUI.recordHash + "' class='" + rowClasses + "'>";
			//Iterate over each column, rendering the field of the result
			for (var j = 0; j < columnCount; j++) {
				cellStyle = "";
				cellClasses = "table-cell";
				column = columns[j];
				//Determine which field the column is to render
				columnId = column.id;
				if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
					cellSelection = mpageUIData.cellSelection;
					for (var k = 0; k < cellSelection.length; k++) {
						if (columnId === cellSelection[k]) {
							cellClasses += " selected";
						}
					}
				}
				if (column.width) {
					cellStyle += "width='" + column.width + "'";
				}
				//Render the cell
				html += column.row_heading ?
					"<th scope='row'>" :
				"<td data-record='" + record._MPageUI.recordHash + "' data-column='" + column.id + "' class='" + cellClasses + "'" + cellStyle + ">";

				//Determine if the column provides a processor function
				contentFunction = column.contents;
				if (contentFunction) {
					html += contentFunction(record);
				}
				html += column.row_heading ? "</th>" : "</td>";
			}
			html += "</tr>";
		}
		return html;
	};

	/**
	 * Renders the body of the table as an html string.
	 * @private
	 * @returns {string} The body of the table rendered as an html string.
	 */
	Table.prototype.renderBody = function() {
		var body = "";
		var data = this.m_data;
		body += "<tbody>" + this.renderData(data, 0) + "</tbody>";
		return body;
	};

	/**
	 * Refreshes the table by replacing the inner contents.
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.refresh = function() {
		var $rootElement = this.getRootElement();
		//Do not attempt to refresh if the table has not been rendered
		if (!$rootElement || !$rootElement.length) {
			return;
		}
		$rootElement.find(".table-head>table:first-child")[0].innerHTML = (this.renderColumns() + this.renderHeader());
		$rootElement.find(".table-body>table:first-child")[0].innerHTML = (this.renderColumns() + this.renderBody());
		this.resize();
	};

	/**
	 * Resizes the table it checks if scrolling is applied, and if so it shifts the header over to compensate for the scrollbar
	 * in the table body.
	 * @return {undefined} Returns nothing
	 */
	Table.prototype.resize = function() {
		if (!this.m_options.show.header) {
			return;
		}
		var $rootElement = this.getRootElement();
		//Not rendered to the DOM
		if ((!$rootElement || !$rootElement.length)) {
			return;
		}
		//apply max height to the table body
		this.applyMaxHeight();
		//shift the table header if scrolling is applied
		this.shiftTableHeader();
	};

	/**
	 * Applies max height to the table body based
	 * on the max height that was set for the table.
	 * @private
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.applyMaxHeight = function() {
		var $rootElement = this.getRootElement();
		var maxHeight = this.getMaxHeight();
		//find the table header height
		var $tableHeader = $rootElement.find('.table-head');
		var tableHeaderHeight = $tableHeader[0].offsetHeight;
		//Calculate the new body max-height
		var newBodyMaxHeight = maxHeight - tableHeaderHeight;
		//set the new table body max-height
		var $tableBody = $rootElement.find('.table-body');
		$tableBody.css({"max-height": newBodyMaxHeight + "px"});
	};

	/**
	 * Shifts table header when scrolling is applied.
	 * @private
	 * @return {undefined} Returns nothing.
	 */
	Table.prototype.shiftTableHeader = function() {
		var $rootElement = this.getRootElement();
		var $tableBody = $rootElement.find('.table-body');

		var scrollHeight = $tableBody[0].scrollHeight;
		var offsetHeight = $tableBody[0].offsetHeight;
		//Scrolling is applied
		if (scrollHeight > offsetHeight) {
			$rootElement.find(".table-head").addClass("shifted");
		} else {
			$rootElement.find(".table-head").removeClass("shifted");
		}
	};

	/**
	 * Gets the max height for the table.
	 * @returns {number} The max height of the table.
	 */
	Table.prototype.getMaxHeight = function() {
		return this.m_maxHeight;
	};

	/**
	 * Sets the max height for the table
	 * @throws {Error} If height is not a number
	 * @param {number} height to be set as max height for the component table
	 * @returns {MPageUI.Table} Returns self to allow chaining.
	 */
	Table.prototype.setMaxHeight = function(height) {
		if (typeof height !== "number") {
			throw new Error("MPageUI.Table.prototype.setMaxHeight expects a number");
		}
		this.m_maxHeight = height;
		//Resize after the max height is set
		this.resize();
		return this;
	};

	/**
	 * Attaches the necessary events to the table. This must be called after the Table instance has been rendered
	 * to the DOM.
	 * @returns {undefined} Returns nothing.
	 */
	Table.prototype.attachEvents = function() {
		var $rootElement = this.getRootElement();
		var self = this;
		//Table column header click
		$rootElement.on("click.mpageui", "thead th", function(event) {
			self.onColumnHeaderClick(event);
		});
		//Table row click
		$rootElement.on("click.mpageui", "tbody tr.table-row", function(event) {
			self.onRowClick(event);
		});
		//Table cell click
		$rootElement.on("click.mpageui", "tbody tr td.table-cell", function(event) {
			self.onCellClick(event);
		});
		//Table group section click
		$rootElement.on("click.mpageui", "tbody tr.table-section", function(event) {
			self.onGroupClick(event);
		});
		//Hover - mouse enter
		$rootElement.on("mouseenter.mpageui", "tbody tr td.table-cell", function(event) {
			self.onHover(event);
		});
	};

	return Table;
})();

/* eslint-enable no-underscore-dangle */
//Check to see if the interpolate function is already defined by the browser.
if(!String.prototype.interpolate) {
	/**
	 * Takes an object and injects is properties into a string template
	 * @param {object} valueMap The object whose properties should be used to generate the final interpolated string
	 * @returns {string} The interpolated string
	 */
	String.prototype.interpolate = function(valueMap) { //eslint-disable-line no-extend-native
		return this.replace(/\{([^}]+)\}/g, function(dummy, v) {
			return valueMap[v];
		});
	};
}

//Check to see if the repeat function is already defined by the browser.
if(!String.prototype.repeat) {
	/**
	 * Takes a string and repeats it a determined number of times.  Implementation taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
	 * @param {number} count The number of times to repeat the string
	 * @returns {string} The repeated string
	 */
	String.prototype.repeat = function(count){ //eslint-disable-line no-extend-native, complexity
		if (this == null) { //eslint-disable-line eqeqeq
			throw new TypeError('can\'t convert ' + this + ' to object');
		}
		var str = '' + this;
		count = +count;
		if (count != count) {//eslint-disable-line eqeqeq, no-self-compare
			count = 0;
		}
		if (count < 0) {
			throw new RangeError('repeat count must be non-negative');
		}
		if (count == Infinity) { //eslint-disable-line eqeqeq
			throw new RangeError('repeat count must be less than infinity');
		}
		count = Math.floor(count);
		if (str.length == 0 || count == 0) { //eslint-disable-line eqeqeq
			return '';
		}
		// Ensuring count is a 31-bit integer allows us to heavily optimize the
		// main part. But anyway, most current (August 2014) browsers can't handle
		// strings 1 << 28 chars or longer, so:
		if (str.length * count >= 1 << 28) {
			throw new RangeError('repeat count must not overflow maximum string size');
		}
		var rpt = '';
		for (;;) {
			if ((count & 1) == 1) { //eslint-disable-line eqeqeq
				rpt += str;
			}
			count >>>= 1;
			if (count == 0) { //eslint-disable-line eqeqeq
				break;
			}
			str += str;
		}
		return rpt;
	};
}

//Check to see if the method function is already defined by the browser.
if(!Function.prototype.method) {
	/**
	 * @deprecated
	 * A helper function to attach a new function to the prototype
	 * @param {string} name The name given to the function
	 * @param {function} func The function to apply to the prototype
	 * @returns {function} returns the object the new function was added to
	 */
	Function.prototype.method = function(name, func) { //eslint-disable-line no-extend-native
		this.prototype[name] = func;
		return this;
	};
}

//Check to see if the inherits function is already defined by the browser.
if(!Function.prototype.inherits) {
	/**
	 * @deprecated
	 * A function to copy the prototype information of one object to another.
	 * @param {function} Parent The parent Object/Function to inherit from
	 * @returns {function} The Object/Function what has inherited from Parent
	 */
	Function.prototype.inherits = function(Parent) { //eslint-disable-line no-extend-native
		var d = {},
			p = (this.prototype = new Parent());
		this.method('uber', function uber(name) { //eslint-disable-line complexity
			if (!(name in d)) {
				d[name] = 0;
			}
			var f, r, t = d[name],
				v = Parent.prototype;
			if (t) {
				while (t) {
					v = v.constructor.prototype;
					t -= 1;
				}
				f = v[name];
			}
			else {
				f = p[name];
				if (f == this[name]) { //eslint-disable-line eqeqeq
					f = v[name];
				}
			}
			d[name] += 1;
			r = f.apply(this, Array.prototype.slice.apply(arguments, [ 1 ]));
			d[name] -= 1;
			return r;
		});
		return this;
	};
}

//Check to see if the createAttribute function is already defined by the browser.
if(!Function.prototype.createAttribute) {
	/**
	 * Creates getters and setters for the class based on attributeName.
	 *
	 * Example:
	 *
	 * MyClass.createAttribute("Color", "blue");
	 *
	 * The call above will create this.getColor() and this.setColor(value).
	 * A member variable mColor will also be created, with the default value of
	 * "blue".
	 * @param {string} attributeName The name of the attribute to create
	 * @param {object} defaultValue The default value for the attribute item
	 * @returns {undefined} This function does not return a value
	 */
	Function.prototype.createAttribute = function(attributeName, defaultValue) { //eslint-disable-line no-extend-native
		this.prototype['m_' + attributeName] = defaultValue;

		this.prototype['get' + attributeName] = function() {
			return this['m_' + attributeName];
		};

		this.prototype['set' + attributeName] = function(value) {
			this['m_' + attributeName] = value;
		};
	};
}
/**
 * The autotextHelper object is a web equivalent for the AUTOTEXTHELPER APIs used within Millennium.  This interface is defined in the
 * docphraseautocomplete.idl file which can be found here: http://ipvmphysdoc02:8080/source/xref/WIN32/CPP/DocPhraseAutoComplete/docphraseautocomplete.idl#247
 * The implementations can be found here: http://ipvmphysdoc02:8080/source/xref/WIN32/CPP/DocPhraseAutoComplete/AutoTextDiscernObject.cpp
 */
var autotextHelper = {
    patientId : 0.0,
    encounterId : 0.0,
    notePhraseComponents : [],
    abbreviations : [],
    abbreviationsRetrieved : false
};

/**
 * Setter for patient/encounter ids
 * @param {Object} patientId The person id assigned to the patient
 * @param {Object} encounterId  The id assigned to the encounter
 * @return {Object} this object, for chaining
 */
autotextHelper.SetPatientInfo = function(patientId, encounterId){
    this.patientId = patientId;
    this.encounterId = encounterId;
    return this;
};

/**
 * Get an array of abbreviations that start with the param abbr
 * @param {String} abbr
 * @returns {Array} Abbreviations starting with this abbr
 */
autotextHelper.GetAbbreviations = function(abbr){
    if (!this.IsAutoTextEnabled()) {
        return "";
    }
    if (!abbr) {
        return "";
    }
    var abbreviationList = [];

    for (var i = 0; i < this.abbreviations.length; i++) {
        var notePhrase = this.abbreviations[i];

        if (notePhrase.ABBREVIATION.indexOf(abbr) === 0) {
            abbreviationList.push(notePhrase.ABBREVIATION);
        }
    }
    if (abbreviationList.length == 0) {
        return "";
    }
    return JSON.stringify(abbreviationList);
};

/**
 * Return autotext array corresponding to the abbreviation
 * @param {String} abbr an abbreviation that has been selected from the list of known abbreviations
 * @returns {Array} array of autotext matching the abbreviation
 */
autotextHelper.ExecuteAutoText = function(abbr){
    var helper = this;

    if (!this.IsAutoTextEnabled()) {
        helper.notePhraseComponents = [];
    }
    else {
        var filteredAbbreviations = [];

        for (var i = 0; i < this.abbreviations.length; i++) {
            var notePhrase = this.abbreviations[i];

            if (notePhrase.ABBREVIATION == abbr) {
                filteredAbbreviations.push(notePhrase);
            }
        }
        if (filteredAbbreviations.length != 1) {
            //
            // abbreviation was not found
            //
            helper.notePhraseComponents = [];
        }
        else {
            var note_phrase_id = filteredAbbreviations[0].NOTE_PHRASE_ID;
            var executeAutotextRequest = new ScriptRequest();

            //var executeAutotextTimer = new RTMSTimer("TODO: Set to timer name");
            executeAutotextRequest.setProgramName("MP_GET_DD_EXECUTE_AUTOTEXT");
            executeAutotextRequest.setParameterArray(["^MINE^", this.patientId.toFixed(10), this.encounterId.toFixed(10), note_phrase_id.toFixed(10)]);
            executeAutotextRequest.setAsyncIndicator(false);
            executeAutotextRequest.setResponseHandler(function (scriptReply) {
                var executeAutotextReply = scriptReply.getResponse();
                if (executeAutotextReply.STATUS_DATA.STATUS === "S") {
                    helper.notePhraseComponents = executeAutotextReply.COMPONENTS;
                }
                else {
                    helper.notePhraseComponents = [];
                }
            });
            //executeAutotextRequest.setLoadTimer(executeAutotextTimer);
            executeAutotextRequest.performRequest();
        }
    }
	//Eventually will need to do processing on the HTML markup returned from the service.
    return helper.notePhraseComponents;
};

/**
 * This function is used to check whether autotext is enabled or not by verifying the autotext Application, Task and Request combination are defined.
 * Application: 3202004
 * Task: 3202004
 * Request: 969551
 * @return (boolean) returns whether abbreviations are available
 */
autotextHelper.IsAutoTextEnabled = function(){
    if (!this.abbreviationsRetrieved) {
        this.abbreviationsRetrieved = true;

        var helper = this;
        var retrieveNotePhraseRequest = new ScriptRequest();

        //var retrieveNotePhraseTimer = new RTMSTimer("TODO: Set to timer name");
        retrieveNotePhraseRequest.setProgramName("MP_GET_DD_AUTOTEXT_ABBR");
        retrieveNotePhraseRequest.setParameterArray(["^MINE^", 1, 1]); // it is ok to get system and user abbrs in one call
        retrieveNotePhraseRequest.setAsyncIndicator(false);
        retrieveNotePhraseRequest.setResponseHandler(function(scriptReply){
            var retrieveNotePhraseReply=scriptReply.getResponse();
            if(retrieveNotePhraseReply.STATUS_DATA.STATUS === "S"){
                helper.abbreviations = retrieveNotePhraseReply.PHRASES;
            }
            else{
                helper.abbreviations = [];
            }
        });
        //retrieveNotePhraseRequest.setLoadTimer(retrieveNotePhraseTimer);
        retrieveNotePhraseRequest.performRequest();
    }
    return this.abbreviations.length > 0;
};

/**
 * This function is used to show the 'Manage Autotext' dialog, but that is currently unsupported outside of Millennium,
 * so this function merely logs a warning and returns.
 */
autotextHelper.ShowManageAutoTextDlg = function(){
    if(logger && logger.logWarning){
        logger.logWarning("Autotext Manager is not available outside of Millennium");
    }
};
/**
 * The CERN_Browser artifact will contain any reusable functions that pertain to the current browser.
 * This class will have functions that return information about what is available in a browser (like
 * if canvas is available).
 * @namespace
 */
CERN_Browser = {
	m_isCanvasAvailable : null	
};

/**
 * A check to see if the canvas functionality is available
 * @returns {boolean} true or false if canvas is available in the current browser
 */
CERN_Browser.isCanvasAvailable = function() {
	//if variable is already set, just return the variable value
	if (typeof this.m_isCanvasAvailable !== 'boolean') {
		//code to see if canvas is available, use !! to cast the result to a boolean
		this.m_isCanvasAvailable = !!document.createElement('canvas').getContext;
	}
	
	return this.m_isCanvasAvailable;
};
/*globals pvFrameworkLink, Infobutton, MPAGES_EVENT*/

/**
 * @namespace
 * The CERN_Platform namespace is utilized to house information about the Millennium Platform.  It also contains functions
 * which will allow the consumer to indirectly interact with specific Millennium Win32 APIs.  Essentially the CERN_Platform will
 * act as a middle man between the Millennium platform and the consumer.  This will allow the for passivity when MPages are being
 * run within and outside of a Millennium context.  More specific information can be found in each of the available functions below.
 */
var CERN_Platform = {
	m_inMillenniumContext: null,
	m_inPatientChartContext: null,
	m_inTouchMode: false,
	m_scriptServletLoc: "",
	m_webappRoot : null,
	m_criterion: null
};

/**
 * This function is used to retrieve the criterion object that is used to identify basic information about the execution of
 * an MPageView.
 * @return {object} The parsed criterion object
 */
CERN_Platform.getCriterion = function(){
	if(!this.m_criterion){
		try{
			this.m_criterion = JSON.parse(m_criterionJSON);
		}
		catch(err){
			logger.logError("Unable to successfully parse the criterion JSON: " + m_criterionJSON);
			throw new Error("Unable to successfully parse the criterion JSON");
		}
	}
	return this.m_criterion;
};

/**
 * Returns an object via DiscernObjectFactory with the specified name. If not within the context of Millennium,
 * getDiscernObjectWebEquivalent function returns the web equivalent of a Discern object if it exists else null will
 * be returned.
 * @param {string} objectName - The name of the object to be obtained via DiscernObjectFactory or web equivalent of a Discern object.
 * @returns {object} The discern object or its web equivalent if available
 */
CERN_Platform.getDiscernObject = function (objectName) {
	try {
		return this.inMillenniumContext() ? window.external.DiscernObjectFactory(objectName) : this.getDiscernObjectWebEquivalent(objectName);
	} catch (exe) {
		logger.logError("In CERN_Platform.getDiscernObject: An error occurred when trying to retrieve: " + objectName + " from window.external.DiscernObjectFactory");
		return null;
	}
};

/**
 * This function will return the web equivalent of a Discern object if it exists.  Web equivalents mimic the APIs that are available
 * within Discern Object.
 * @param {string} discernObjectName The name of the discern object being retrieved
 * @return {object} The web equivalent of the discern object or null if it does not exist
 */
CERN_Platform.getDiscernObjectWebEquivalent = function(discernObjectName){
	switch(discernObjectName){
		case "DOCUTILSHELPER":
			return null; //docUtilsHelper;
		case "AUTOTEXTHELPER":
			return null; //autotextHelper;
		case "PVFRAMEWORKLINK":
			return pvFrameworkLink;
		case "INFOBUTTONLINK":
			return new Infobutton();
		case "CHECKPOINT":
			return new webCheckpoint.checkpoint();
		case "PVCONTXTMPAGE":
			return WebPVContxtMpage;	
		default:
			return null;
	}
};

/**
 * The inMillenniumContext function can be used to determine if the the current MPage is being run from within the context of a
 * Millennium application or not.  From there the consumer can utilize Win32 pieces of functionality or gracefully degrade based on the
 * availability of alternative solutions.
 * @return {boolean} true if the mpage is being run within Millennium, false otherwise.
 */
CERN_Platform.inMillenniumContext = function () {
	if (this.m_inMillenniumContext === null) {
		this.m_inMillenniumContext = (window.external && (typeof window.external.DiscernObjectFactory !== "undefined")) ? true : false;
	}
	return this.m_inMillenniumContext;
};

/**
 * This function is used to determine if the MPagesView is being shown within the context of a patient's chart.
 * It determines this by checking the global criterion object for a person_id.  If that is populated, the MPages
 * is for sure being shown within some patient context.  Otherwise, if it is not populated we can assume the MPage
 * is being shown in a different context.
 * @return {boolean} True if the MPage is being shown within a patient context, false otherwise
 */
CERN_Platform.inPatientChartContext = function(){
	if (this.m_inPatientChartContext === null) {
		//Get the criterion object and check the personid
		var criterion = this.getCriterion().CRITERION;
		this.m_inPatientChartContext = criterion.PERSON_ID ? true : false;
	}
	return this.m_inPatientChartContext;
};

/**
 * Returns a flag indicating if touch mode is enabled
 * @returns {boolean} A flag indicating if touch mode is enabled
 */
CERN_Platform.isTouchModeEnabled = function () {
	return this.m_inTouchMode;
};

/**
 * Sets the servlet location.
 * @param {String} servletLocation A string used to indicate the location of servlet.
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.setScriptServletLocation = function(servletLocation) {
    this.m_scriptServletLoc = servletLocation;
};

/**
 *Gets the servlet location.
 *@returns {String} A string used to indicate the location of the script servlet.
 */
CERN_Platform.getScriptServletLocation = function() {
    return this.m_scriptServletLoc;
};

 /*
 * Sets a flag to indicate if touch mode is enabled
 * @param {boolean} touchModeFlag A flag to indicate if touch mode is enabled
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.setTouchModeEnabled = function (touchModeFlag) {
	this.m_inTouchMode = touchModeFlag;
	// Add a class to body if touch mode is enabled
	// No need to remove the class if touch mode is disabled because the page refreshes and MPage is painted again
	if(touchModeFlag){
		$("body").addClass("touch-mode");
	}
};

/**
 * Single function to redirect the page, for use in CCLLINK replacement
 * @param {Object} newUrl The new page location
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.setLocation = function(newUrl){
	window.location.assign(newUrl);
};

/**
 * This function is used to refresh the MPage View programatically.  Determines the parameters to utilze based on the 
 * context of the MPage.
 */
CERN_Platform.refreshMPage = function(){
	var criterion = CERN_Platform.getCriterion().CRITERION;
	var cclParams = null;
	
	//Determine if we are viewing the current MPage in a patient context
	if(CERN_Platform.inPatientChartContext()){
		cclParams = ["^MINE^", criterion.PERSON_ID + ".0", criterion.ENCNTRS[0].ENCNTR_ID + ".0", criterion.PRSNL_ID + ".0", criterion.POSITION_CD + ".0", criterion.PPR_CD + ".0", "^" + criterion.EXECUTABLE + "^", "^" + CERN_driver_static_content.replace(/\\/g, "\\\\") + "^", "^" + CERN_driver_mean + "^", criterion.DEBUG_IND];
	}
	else{
		cclParams = ["^MINE^", criterion.PRSNL_ID + ".0", criterion.POSITION_CD + ".0", "^" + criterion.EXECUTABLE + "^", "^" + CERN_driver_static_content.replace(/\\/g, "\\\\") + "^", "^" + CERN_driver_mean + "^", criterion.DEBUG_IND];
	}
	CCLLINK(CERN_driver_script, cclParams.join(","), 1);
};

/**
 * This function will create a global CCLLINK function that will launch a CCL program through the MPages webserver and displaying the contents.
 * This also prevents situations where IE pre-loads global functions before JS execution.
 * @param {String} reportName - CCL program name
 * @param {String} prompts - prompt parameters for the reportName
 * @param {String} linkDestination - a function used in the original CCLLINK to determine if the URL is launched into a separate DiscernReportViewer.
 * 										This is ignored in this implementation.
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.CCLLINK = function(reportName, prompts, linkDestination){
	//For web enabled MPages, only enable CCLLINK functionality if the reportName is "MP_UNIFIED_DRIVER" or "MP_UNIFIED_ORG_DRIVER".  
	//All other implementations should fail silently.
	if(/^MP_UNIFIED_.*DRIVER/.test(reportName.toUpperCase())){
		CERN_Platform.setLocation(window.location.href);
	} else {
		logger.logWarning("CCLLINK is not supported outside of Millennium for program: " + reportName + ".");
	}
};

/**
 * A replacement for the MPAGES_EVENT function that will do nothing, but prevent a failure.
 * @param {String} eventType - the type of event to be used.  This will be ignored in this function
 * @param {String} eventParams - the parameters of the event to be used.  This will be ignored in this function.
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.MPAGES_EVENT = function(eventType, eventParams){
	return;
};

/**
 * This function will create a global APPLINK function that will do nothing, but prevent a failure.
 * @param {Integer} mode - A numeric value representing the mode to start the application link
 * 		0 - Used for starting a solution by executable name
 * 		1 - Used for starting a solution by the application object, such as DiscernAnalytics.Application
 * 		100 - Used to launch a file, link, or executable through a shell execute.
 * @param {String} appname - The application executable name
 * @param {String} params - The person_id, encntr_id and Powerchart tab name.
 * @returns {undefined} This function does not return a value
 */
CERN_Platform.APPLINK = function(mode, appname, params){
	return;
};

/*This function retrieves a cookie that contains info about the context root for the webpage
 * Then creates and returns the mpRoot as a string
 */
CERN_Platform.makeRoot = function(){
	return document.cookie.replace(/(?:(?:^|.*;\s*)mpRoot\s*\=\s*([^;]*).*$)|^.*$/, "$1");
};

/**
 * This function will attempt to read the context root of the webapp from a cookie named "mpRoot", and then return the full URL 
 *   of the webapp with context root.
 *   Note that the "mpRoot" cookie is the context root string is created by the login.jsp page.
 * @param none
 * @returns {String} A string representing the full URL of the webapp.  For example: "https://subDomainName.domainName.com/webappName/canonical.domain.name"
 */
CERN_Platform.getWebappRoot = function() {
	var setWebAppRoot = function (newRoot) {	
		if (newRoot) {
			CERN_Platform.m_webappRoot = location.protocol + "//" + location.host + newRoot;
		}
	};

	if (typeof this.m_webappRoot !== 'string') {
		setWebAppRoot(CERN_Platform.makeRoot());
	}
	return this.m_webappRoot;
};


/**
 * This code will update the CCLLINK function if necessary, ensuring that it's action is similar both inside and outside of a Win32
 * context.  It is defined at a global level since CCLLINK is defined at the global level.  Default CCLLINK functionality is detailed
 * here:
 * https://wiki.ucern.com/display/public/MPDEVWIKI/CCLLINK
 */
if(typeof CCLLINK === "undefined"){
	CCLLINK = CERN_Platform.CCLLINK;
}

/**
 * This code will update the MPAGES_EVENT function if necessary, ensuring that it's action is will not cause a failure message.
 * It is defined at a global level since MPAGES_EVENT is defined at the global level.  Default MPAGES_EVENT functionality is detailed
 * here:
 * https://wiki.ucern.com/display/public/MPDEVWIKI/MPAGES_EVENT
 */
if(typeof MPAGES_EVENT === "undefined"){
	MPAGES_EVENT = CERN_Platform.MPAGES_EVENT;
}

/**
 * This code will update the APPLINK function if necessary, ensuring that it's action is similar both inside and outside of a Win32
 * context.  It is defined at a global level since APPLINK is defined at the global level.  Default APPLINK functionality is detailed
 * here:
 * https://wiki.ucern.com/display/public/MPDEVWIKI/APPLINK
 */
if(typeof APPLINK === "undefined"){
	APPLINK = CERN_Platform.APPLINK;
}
/**
 * The validation library. This object contains a set of static functions which perform
 * standard validation operations.
 * @type {Object}
 */
var CERN_Validate = {};

CERN_Validate.string = {};

/**
 * This function will verify if the value passed in is a string. it will return true if the following conditions are met
 * , otherwise it will return false.
 * typeof value === "string"
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is a string, otherwise false.
 */
CERN_Validate.string.isString = function (value) {
	return typeof value === "string";
};

/**
 * This function will check to see if the string contains a numeric value. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * The string is a parseable number
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is a numeric string, otherwise false.
 */
CERN_Validate.string.isNumeric = function (value) {
	return CERN_Validate.string.isString(value) &&
		/^[-+]?[0-9]*[.,]?[0-9]+$/.test(value) &&
		(CERN_Validate.number.isNumber(parseFloat(value)));
};

/**
 * This function is used to check and see if a string is empty or not. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * value === ""
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is empty, otherwise false.
 */
CERN_Validate.string.isEmpty = function(value) {
	return CERN_Validate.string.isString(value) && value === "";
};

/**
 * This function will determine if a string is blank, meaning it contains only whitespace or is an empty string. This
 * function will return true if the following conditions are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * The string is empty or contains only whitespace characters
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is empty or contains only whitespace, otherwise false.
 */
CERN_Validate.string.isBlank = function(value) {
	return CERN_Validate.string.isEmpty(value) || /^[\s\n\r]*$/.test(value);
};

CERN_Validate.number = {};

/**
 * This function can be used to see if the value passed in is a number or not. This function will return true if the
 * following conditions are met, otherwise it will return false.
 * typeof value == "number"
 * The value passed in is finite (not infinity, negative infinity or NaN)
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is a number, otherwise false.
 */
CERN_Validate.number.isNumber = function(value) {
	return typeof value === "number" && isFinite(value);
};

/**
 * This function will validate if a value is an integer. It will return true of the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value % 1 === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an integer, otherwise false.
 */
CERN_Validate.number.isInteger = function(value) {
	return CERN_Validate.number.isNumber(value) && (value % 1 === 0);
};

/**
 * This function will validate if a value is a floating point number. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value % 1 !== 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an integer, otherwise false.
 */
CERN_Validate.number.isFloat = function(value) {
	return CERN_Validate.number.isNumber(value) && (value % 1 !== 0);
};

/**
 * This function will validate if a number is negative. It will return true if the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value < 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the number is negative, otherwise false.
 */
CERN_Validate.number.isNegative = function(value) {
	return CERN_Validate.number.isNumber(value) && value < 0;
};

/**
 * This function will validate if a number is positive. It will return true if the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value > 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the number is negative, otherwise false.
 */
CERN_Validate.number.isPositive = function(value) {
	return CERN_Validate.number.isNumber(value) && value > 0;
};

/**
 * This function will validate if a number is greater than or equal to another number. It will return true if the
 * following conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(compareTo) is true
 * value >= compareTo
 * @param {number} value - The value being tested.
 * @param {number} compareTo - The number to compare the value against.
 * @returns {boolean} True if the value is greater than or equal to the comparison value, otherwise false.
 */
CERN_Validate.number.isGreaterThanOrEqualTo = function(value, compareTo) {
	return CERN_Validate.number.isNumber(value) && CERN_Validate.number.isNumber(compareTo) && value >= compareTo;
};

/**
 * This function will validate if a number is less than or equal to another number. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(compareTo) is true
 * value <= compareTo
 * @param {number} value - The value being tested.
 * @param {number} compareTo - The number to compare the value against.
 * [value is number, compareTo is number, value <= compareTo]
 * @returns {boolean} True if the value is less than or equal to the comparison value, otherwise false.
 */
CERN_Validate.number.isLessThanOrEqualTo = function(value, compareTo) {
	return CERN_Validate.number.isNumber(value) && CERN_Validate.number.isNumber(compareTo) && value <= compareTo;
};

/**
 * This function will validate if a number is zero. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is 0, otherwise false.
 */
CERN_Validate.number.isZero = function(value) {
	return CERN_Validate.number.isNumber(value) && value === 0;
};

/**
 * This function will validate if a number is even. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isInteger(value) is true
 * value % 2 === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an even integer, otherwise false.
 */
CERN_Validate.number.isEven = function(value) {
	return CERN_Validate.number.isInteger(value) && value % 2 === 0;
};

/**
 * This function will validate if a number is odd. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isInteger(value) is true
 * value % 2 !== 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an odd integer, otherwise false.
 */
CERN_Validate.number.isOdd = function(value) {
	return CERN_Validate.number.isInteger(value) && value % 2 !== 0;
};

/**
 * This function will validate if a number is within a specified range. This can be both inclusive or exclusive.
 * This function will return true if the following conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(rangeStart) is true
 * CERN_Validate.number.isNumber(rangeEnd) is true
 * If the inclusive flag is true
 * 		The value is between rangeStart and rangeEnd, but not equal to either
 * If the inclusive flag is false
 *		The value is between rangeStart and rangeEnd or is equal to either
 * @param {number} value - The value being tested.
 * @param {number} rangeStart - The start of the range.
 * @param {number} rangeEnd - The end of the range.
 * @param {boolean} inclusive - Flag indicating if the range is inclusive or not.
 * @returns {boolean} True if the value is within the range, otherwise false.
 */
CERN_Validate.number.isWithinRange = function(value, rangeStart, rangeEnd, inclusive) {
	if(!CERN_Validate.number.isNumber(rangeStart) || !CERN_Validate.number.isNumber(rangeEnd)) {
		return false;
	}
	if(!CERN_Validate.number.isNumber(value)) {
		return false;
	}
	if(rangeStart > rangeEnd) {
		var tempValue = rangeStart;
		rangeStart = rangeEnd;
		rangeEnd = tempValue;
	}
	if(inclusive) {
		return value >= rangeStart && value <= rangeEnd;
	}
	else {
		return value > rangeStart && value < rangeEnd;
	}
};

CERN_Validate.array = {};

/**
 * This function can be used to verify if the value passed in is an array. It will return true if the following
 * conditions are met, otherwise it will return false.
 * Array.prototype.isPrototypeOf(value)
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is an Array, otherwise false.
 */
CERN_Validate.array.isArray = function(value) {
	return Array.prototype.isPrototypeOf(value);
};

/**
 * This function will validate if an array does not contain any elements. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.array.isArray(value) is true
 * The length of array is equal to 0.
 * @param {Array} value - The value being tested.
 * @returns {boolean} True if the Array is emtpy, otherwise false.
 */
CERN_Validate.array.isEmpty = function(value) {
	return CERN_Validate.array.isArray(value) && value.length === 0;
};

/**
 * This function will validate if an array contains a specific value. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.array.isArray(value) is true.
 * containsValue is one of the elements defined within the array.
 * @param {Array} value - The array in which we are checking for the containsValue parameter.
 * @param {Object} containsValue - The value we are checking the array for.
 * @returns {boolean} True if the array contains the containsValue parameter.
 */
CERN_Validate.array.contains = function(value, containsValue) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(value[i] === containsValue) {
			return true;
		}
	}
	return false;
};

/**
 * This function will validate that all of the values within an array are strings. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are strings (uses CERN_Validate.string.isString).
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only strings.
 */
CERN_Validate.array.containsOnlyStrings = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!CERN_Validate.string.isString(value[i])) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are numbers. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true
 * All values within the array are numbers
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only numbers.
 */
CERN_Validate.array.containsOnlyNumbers = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!CERN_Validate.number.isNumber(value[i])) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are objects. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are objects.
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only Objects.
 */
CERN_Validate.array.containsOnlyObjects = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(typeof value[i] !== "object") {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are objects of a specified prototype. It will
 * return true if the following conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are objects of the specified prototype.
 * @param {Array} value - The array being tested.
 * @param {Object.prototype} objectPrototype - The prototype we are testing.
 * @returns {boolean} True if all items in the array are objects of the specified prototype.
 */
CERN_Validate.array.containsOnlyObjectsOfPrototype = function(value, objectPrototype) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!objectPrototype.prototype.isPrototypeOf(value[i])) {
			return false;
		}
	}
	return true;
};

CERN_Validate.object = {};

/**
 * This function will validate that the value is an object type. It will return true if the following conditions are met.
 * typeof value === "object".
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is an object type, otherwise false.
 */
CERN_Validate.object.isObject = function(value) {
	return typeof value === "object";
};

/**
 * This function will validate that the Object is empty. It will return true if the following conditions are met.
 * CERN_Validate.object.isObject(value) is true.
 * value is completely empty (has no properties).
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is empty, otherwise false.
 */
CERN_Validate.object.isEmpty = function(value) {
	if(!CERN_Validate.object.isObject(value)) {
		return false;
	}
	for(var key in value) {
		if(value.hasOwnProperty(key)) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that the Object contains the specified key. It will return true if the following
 * conditions are met.
 * CERN_Validate.object.isObject(value) is true.
 * typeof value[key] !== "undefined".
 * @param {Object} value - The value being tested.
 * @param {Object} key - The key to test for.
 * @returns {boolean} True if the value contains the specified key.
 */
CERN_Validate.object.hasKey = function(value, key) {
	return CERN_Validate.object.isObject(value) && typeof value[key] !== "undefined";
};



/**
 * @class
 * This webCheckpoint object is the main entry point of the CHECKPOINT API for web enabled MPages.
 * It maintains session info such as process ID and thread ID needed by the RTMS subsystem.
 * It bundles individual CHECKPOINTS generated in JavaScript and sends them to the /checkpoint restlet
 *   available in web enabled MPages.
 * This is a self executing function, and is done this way to avoid any race conditions when initializing
 *   the webCheckpoint.checkpoints object.
 */

var webCheckpoint = function(){

	var checkpoints = {};
	var api;

	/**
	 * Function to initialize the checkpoints object and values within.
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name calculateOffset
	 * @return {undefined} Nothing
	 */
	function chkInit(){
		//Variables for calculating random min/max ProcessID and ThreadID values
		var maxPID = 99999999;
		var minPID = 1;
		var maxTID = 999;
		var minTID = 1;
		checkpoints.PID = "" + Math.floor(Math.random() * (maxPID - minPID + 1)) + minPID;
		checkpoints.PTM = "" + (new Date()).valueOf();
		checkpoints.TID = "" + Math.floor(Math.random() * (maxTID - minTID + 1)) + minTID;
		checkpoints.NODE = location.protocol + "//" + location.host;
		checkpoints.APP = "MPages Web";
		checkpoints.CHKS = [];

		//Self executing function to submit queued timers in batches every 30 seconds
		(function runSubmit() {
			try{
				webCheckpoint.submit();
			} catch (exe) {
				//do nothing
			}
			setTimeout(runSubmit, 30000);
		})();

		// Add onbeforeunload listener to submit all queued checkpoints.
		// This function gets called upon navigation away from the webpage (redirect/refresh/close) and
		// guarantees the submission of all checkpoints that currently exist within the checkpoint batch array.
		window.onbeforeunload = function() {
			webCheckpoint.submit();
		};
	}

	/**
	 * Calculates the time offset between Process start time and the time the
	 * checkpoint is created
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name calculateOffset
	 * @param {number} processStartTime The raw javascript time for when the process started
	 * @return {string} Representation of the calculated offset in nanoseconds
	 */
	function calculateOffset(processStartTime){
		//Multiply by 1000000 to convert milliseconds to nanoseonds
		return ((new Date()).valueOf() - processStartTime) * 1000000 + "";
	}

	/**
	 * Clears checkpoints from the the checkpoint queue
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name clearQueuedCheckpoints
	 * @return {undefined} Nothing
	 */
	function clearQueuedCheckpoints() {
		checkpoints.CHKS.length = 0;
	}


	/**
	 * Sets the node name for the checkpoint
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkSetNodeName
	 * @param {string} nodeName The node name passed to RTMS. For example, "http://webserver/webapp_context_root"
	 * @return {undefined} Nothing
	 */
	function chkSetNodeName(nodeName){
		checkpoints.NODE = nodeName;
	}

	/**
	 * Sets the Application name for the checkpoint
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkSetAppName
	 * @param {string} applicationName The application name passed to RTMS. For example, "MPages Web".
	 * @return {undefined} Nothing
	 */
	function chkSetAppName(applicationName){
		checkpoints.APP = applicationName;
	}

	/**
	 * Return the Process Start Time (PTM) value from the checkpoints object
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkGetProcessStartTime
	 * @return {string} The Process Start Time (PTM) value from the checkpoints object
	 */
	function chkGetProcessStartTime() {
		return checkpoints.PTM;
	}

	/**
	 * Return the JSON string representation of the webCheckpoint.checkpoints object
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkToJSON
	 * @return {undefined} Nothing
	 */
	function chkToJSON() {
			return JSON.stringify(checkpoints);
	}

	/**
	 * Add a published checkpoint instance to the queue for submittal to the ./mpages/checkpoint restlet.
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkAddCheckpoint
	 * @param {Object} [checkpoint] An instance of webCheckpoint.checkpoint()
	 * @param {String} [checkpoint.ProjectName] The project name for the timer
	 * @param {String} [checkpoint.ClassName] The class name for the timer
	 * @param {String} [checkpoint.EventName] The event name for the timer
	 * @param {String} [checkpoint.SubEventName] The sub event name for the timer
	 * @param {String} [checkpoint.Offset] The offset from the process start time for the timer
	 * @param {Object} [checkpoint.MetaData] Arbitrary metadata for that timer that can be any number of name-value pairs
	 * @return {undefined} Nothing
	 */
	function chkAddCheckpoint(checkpoint){
		var tChk = {};
		tChk.PN = checkpoint.ProjectName || "";
		tChk.CN = checkpoint.ClassName || "";
		tChk.EN = checkpoint.EventName || "";
		tChk.SN = checkpoint.SubEventName || "";
		tChk.OT = checkpoint.Offset || calculateOffset(this.getProcessStartTime());
		tChk.META = checkpoint.m_metaData || {};
		checkpoints.CHKS.push(tChk);
	}

	/**
	 * Return the collection of checkpoint objects
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkGetCheckpoints
	 * @return {object} The checkpoints in webCheckpoint.checkpoints
	 */
	function chkGetCheckpoints() {
		return checkpoints;
	}

	/**
	 * Object that is similar to a single instace of window.external.DiscernObjectFactory("CHECKPOINT")
	 *
	 * @function
	 * @memberof webCheckpoint
	 * @name chkCheckpoint
	 * @return {object} A CHECKPOINT object that is equivalent to that of the win32 "CHECKPOINT" object
	 */
	function chkCheckpoint() {
		var chkObj = {};
		chkObj.ClassName = "";
		chkObj.ProjectName = "";
		chkObj.EventName = "";
		chkObj.SubEventName = "";
		chkObj.m_metaData = {};
		chkObj.MetaData = function(key, value) {
			if(this.m_metaData && key && value) {
				try {
					this.m_metaData[key] = value;
				} catch (e) {
					logger.logError("Error adding MetaData [" + key + "] = " + value + "; on Checkpoint");
				}
			}
		};
		chkObj.Publish = function(){
			webCheckpoint.addCheckpoint(this);
		};
		return chkObj;
	}


	/**
	 * Submit array of queued checkpoints to the J2EE timer restlet
	 *
	 * @static
	 * @function
	 * @memberof webCheckpoint
	 * @name chkSubmit
	 * @return {undefined} Nothing
	 */
	function chkSubmit(){
		if(checkpoints.CHKS && checkpoints.CHKS.length === 0){
			return false;
		}
		try{
			var endpoint = CERN_Platform.getWebappRoot() + "/mpages/checkpoint";
			var postObj = {};
			postObj.checkpoint = webCheckpoint.toJSON();
			//After the JSON string to POST has been created, clear out any checkpoints that have been queued:
			clearQueuedCheckpoints();

			$.ajax(
				{
					type: "POST",
					contentType: "application/json",
					url: endpoint,
					data: postObj,
					success: function( ){
						logger.logDebug("SUCCESS!");
					},
					error: function(jqXHR, textStatus, errorThrown) {
						logger.logError("Error occurred from submit checkpoints  <br />Status: " + textStatus + "<br />HTTP error: " + errorThrown);
					}
				}
			);
		} catch(e){
			logger.logError("Error encountered trying to submit checkpoints: <br />Message: " + e.description + "<br />Name: " + e.name + "<br />Number: " + e.number);
		}
	}

	//Only initialize the webCheckpoint.checkpoints object if executing outside of win32 applications.
	if(!CERN_Platform.inMillenniumContext()){
		chkInit();
	}

	// Construct and return the public API.
	api = {
		"setNodeName": chkSetNodeName,
		"getProcessStartTime": chkGetProcessStartTime,
		"setAppName": chkSetAppName,
		"addCheckpoint": chkAddCheckpoint,
		"getCheckpoints": chkGetCheckpoints,
		"submit": chkSubmit,
		"checkpoint": chkCheckpoint,
		"toJSON": chkToJSON,
		"init": chkInit
	};

	return api;
}();
/**
 * The DocUtilsHelper object is a web equivalent for the DOCUTILSHELPER APIs used within Millennium.  This interface is defined in the
 * DocUtilsDiscernObject.h file which can be found here: http://ipvmphysdoc02:8080/source/xref/WIN32/CPP/DynDocMPagesUtils/DocUtilsDiscernObject.h
 * The implementations can be found here: http://ipvmphysdoc02:8080/source/xref/WIN32/CPP/DynDocMPagesUtils/DocUtilsDiscernObject.cpp
 */
var docUtilsHelper = {};

/**
 * This function is used to generate a globally unique id and is based on rfc4122.
 * @return (string) A hexadecimal string which represents a globally unique ID
 */
docUtilsHelper.GenerateGUID = function () {
	var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	var chars = CHARS, uuid = [];

	// rfc4122, version 4 form
	var r;

	// rfc4122 requires these characters
	uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
	uuid[14] = '4';

	// Fill in random data.  At i==19 set the high bits of clock sequence as
	// per rfc4122, sec. 4.1.5
	for (var i = 0; i < 36; i++) {
		if (!uuid[i]) {
			r = 0 | Math.random() * 16;
			uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
		}
	}
	return uuid.join('');
};

/**
 * This function is used to log exceptions to the web based logging mechanism.
 * @param {Object} projectName Name of the project that is logging the error
 * @param {Object} errorMessage Error message
 * @param {Object} originatingFile File of originating exception
 * @param {Object} lineNumber Line number in file of originating exception
 * @param {Object} additionalData Additional data to log
 */
docUtilsHelper.LogException = function (projectName, errorMessage, originatingFile, lineNumber, additionalData) {
	if (logger && logger.logError) {
		var newLine = (CERN_Platform.inMillenniumContext()) ? "<br />" : "\r\n";
		logger.logError("[" + time + "] " + originatingFile + " @" + lineNumber + " (" + projectName + ")" + errorMessage + newLine + additionalData);
	}
};

docUtilsHelper.StartSLATimer = function(timerId) {
	logger.logWarning("The DOCUTILSHELPER.StartSLATimer performs no functionality in browser.");
};

docUtilsHelper.StopSLATimer = function(timerId, timerHandle) {
	logger.logWarning("The DOCUTILSHELPER.StopSLATimer performs no functionality in browser.");
};

docUtilsHelper.GetDefaultFontFace = function() {
	return "Tahoma";
};

docUtilsHelper.GetDefaultColorScheme = function (colorType) {
	switch (colorType) {
		case  8:
			return "000000";
		case  9:
			return "000000";
		case 10:
			return "505050";
		case 11:
			return "7c7c7c";
		case 12:
			return "ffffff";

		case 19:
			return "ffffff";
		case 20:
			return "ffffcc";
		case 21:
			return "3380e5";

		case 42:
			return "d4dbe0";
		case 44:
			return "79868f";

		case 129:
			return "7f94a5";
		case 130:
			return "667a8a";
		case 131:
			return "ffffff";
	}
	return "ff0ff0";
};

/** The functions below are defined in the DOCUTILSHELPER object but do not have not yet been implemented**/
/*
 docUtilsHelper.GetDefaultFontFace = function(){};
 docUtilsHelper.GetDefaultColorScheme = function(colorType){};
 docUtilsHelper.StartSLATimer = function(timerName){};
 docUtilsHelper.StopSLATimer = function(timerName, timer){};
 docUtilsHelper.StopSLATimerWithInvalidTimerFailure = function(timerName, timer){};
 docUtilsHelper.StopSLATimerWithFailure = function(timerName){};
 docUtilsHelper.FindSLATimer = function(findSLATimer){};
 docUtilsHelper.LogError = function(message, project){};
 docUtilsHelper.GetCDFMeaning = function(codeSet, codeValue){};
 docUtilsHelper.GetCodeValueByMeaning = function(codeSet, mean){};
 docUtilsHelper.DebugString = function(outputString){};
 docUtilsHelper.SetMPagesProperties = function(properties){};
 docUtilsHelper.LogCheckpoint = function(checkpointName, timerPropOne, timerPropTwo, timerPropThree){};
 docUtilsHelper.LogCheckpoint2 = function(eventName, subEventName, project, class, timerPropOne, timerPropTwo, timerPropThree){};
 docUtilsHelper.SetHWnd = function(window){};
 docUtilsHelper.SendWndMessage = function(identifier, wParam, lParam){};
 docUtilsHelper.AddToWndMessageMap = function(identifier, message){};
 docUtilsHelper.ShouldLogErrors = function(){};
 docUtilsHelper.GetIeVersion = function(){};
 */
/**
 * @class
 * This Infobutton object is the main entry point of Infobutton API.
 * It will launch the Infobutton URL based on parameters it receives.
 *   - In non-Millennium context, it will launch the URL in the same window 
 * in a different tab or a new window based on the browser settings.
 */
var Infobutton = function() {
    //Accessible variables
    this.m_personId = 0.0;
    this.m_encounterId = 0.0;
    this.m_primaryCriteriaCd = 0.0;
    //(1 for patient, 2 for provider)
    this.m_queryPurposeInd = 1;   
    this.m_performerInd = 2;    
    this.m_eventId = 0.0;
    this.m_eventCd = 0.0;
    this.m_eventClassCd = 0.0;
    this.m_resultValue = "";
    this.m_resultValueCd = 0.0;
    this.m_resultUnitCd = 0.0;
    this.m_synonymId = 0.0;
    this.m_nomenclatureId = 0.0;
    this.m_searchNomenclatureId = 0.0;
    this.m_description = "";
    this.m_UUID = "";
    this.m_infoButtonType = 0;
    this.m_infoButtonObject = null;
};
/**
 * This static object is used by Infobutton object to determine the type
 * of Infobutton(Problem/Diagnosis/Result/Medication Allergy)
 * 1 - Problem  2 - Diagnosis  4 - Medication 8- Result 16 - Medication Allergy
 */
Infobutton.infobuttonTypes = {
    PROBLEM: 1,
    DIAGNOSIS: 2,
    MEDICATION: 4,
    RESULT: 8,
    MEDICATION_ALLERGY: 16  //Currently not used,for future enhancements.
};

/**
 * Retrieves the person ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The person ID of the person
 */
Infobutton.prototype.getPersonId = function() {
    return this.m_personId;
};

/**
 * Set the person ID that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} personId The persn ID of the patient
 */
Infobutton.prototype.setPersonId = function(personId) {
    if ( typeof personId !== "number" || personId < 0) {
        throw new Error("Infobutton: Invalid personId");
    }
    this.m_personId = personId;
};

/**
 * Retrieves the encounter ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The encounter ID of the patient
 */
Infobutton.prototype.getEncounterId = function() {
    return this.m_encounterId;
};

/**
 * Set the encounter ID that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} encounterId The encounter ID of the patient
 */
Infobutton.prototype.setEncounterId = function(encounterId) {
    if ( typeof encounterId !== "number" || encounterId < 0) {
        throw new Error("Infobutton: Invalid encounterId");
    }
    this.m_encounterId = encounterId;
};

/**
 * Retrieves the primary criteria code that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The primary criteria code value (from code set 15783)
 */
Infobutton.prototype.getPrimaryCriteriaCd = function() {
    return this.m_primaryCriteriaCd;
};

/**
 * Set the primary criteria code that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} primaryCriteriaCd The primary criteria code value (from code set 15783)
 */
Infobutton.prototype.setPrimaryCriteriaCd = function(primaryCriteriaCd) {
    if ( typeof primaryCriteriaCd !== "number" || primaryCriteriaCd < 0) {
        throw new Error("Infobutton: Invalid primaryCriteriaCd");
    }
    this.m_primaryCriteriaCd = primaryCriteriaCd;
};

/**
 * Retrieves the query purpose indicator that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The patient education indicator (1 for patient, 2 for provider)
 */
Infobutton.prototype.getQueryPurposeInd = function() {
    return this.m_queryPurposeInd;
};

/**
 * Set the query purpose indicator that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} queryPurposeInd the patient education indicator (1 for patient, 2 for provider)
 */
Infobutton.prototype.setQueryPurposeInd = function(queryPurposeInd) {
    if ( typeof queryPurposeInd !== "number" || queryPurposeInd < 0) {
        throw new Error("Infobutton: Invalid queryPurposeInd");
    }
    this.m_queryPurposeInd = queryPurposeInd;
};

/**
 * Retrieves the query performer indicator that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The patient education indicator (1 for patient, 2 for provider)
 */
Infobutton.prototype.getPerformerInd = function() {
    return this.m_performerInd;
};

/**
 * Set the query performer indicator that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} performerInd The query performer indicator (1 for patient, 2 for provider)
 */
Infobutton.prototype.setPerformerInd = function(performerInd) {
    if ( typeof performerInd !== "number" || performerInd < 0) {
        throw new Error("Infobutton: Invalid performerInd");
    }
    this.m_performerInd = performerInd;
};

/**
 * Retrieves the event ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The event ID of the result
 */
Infobutton.prototype.getEventId = function() {
    return this.m_eventId;
};

/**
 * Set the event ID that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} eventId The event ID of the result.
 */
Infobutton.prototype.setEventId = function(eventId) {
    if ( typeof eventId !== "number" || eventId < 0) {
        throw new Error("Infobutton: Invalid eventId");
    }
    this.m_eventId = eventId;
};

/**
 * Retrieves the synonymId ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The synonymId ID of the medication
 */
Infobutton.prototype.getSynonymId = function() {
    return this.m_synonymId;
};

/**
 * Set the synonymId that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} synonymId The synonymId of the medication
 */
Infobutton.prototype.setSynonymId = function(synonymId) {
    if ( typeof synonymId !== "number" || synonymId < 0) {
        throw new Error("Infobutton: Invalid synonymId");
    }
    this.m_synonymId = synonymId;
};

/**
 * Retrieves the nomenclature ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The nomenclature ID of the Problem/Diagnosis.
 */
Infobutton.prototype.getNomenclatureId = function() {
    return this.m_nomenclatureId;
};

/**
 * Set the nomenclature ID that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} nomenclatureId The nomenclature ID of the Problem/Diagnosis.
 */
Infobutton.prototype.setNomenclatureId = function(nomenclatureId) {
    if ( typeof nomenclatureId !== "number" || nomenclatureId < 0) {
        throw new Error("Infobutton: Invalid nomenclatureId");
    }
    this.m_nomenclatureId = nomenclatureId;
};

/**
 * Retrieves the search nomenclature ID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The search nomenclature ID of the Problem/Diagnosis.
 */
Infobutton.prototype.getSearchNomenclatureId = function() {
    return this.m_searchNomenclatureId;
};

/**
 * Set the search nomenclature ID that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 * @param {number} searchNomenclatureId The search nomenclature ID of the Problem/Diagnosis.
 */
Infobutton.prototype.setSearchNomenclatureId = function(searchNomenclatureId) {
    if ( typeof searchNomenclatureId !== "number" || searchNomenclatureId < 0) {
        throw new Error("Infobutton: Invalid searchNomenclatureId");
    }
    this.m_searchNomenclatureId = searchNomenclatureId;
};

/**
 * Retrieves the Problem/Diagnoses description that will be used by the Infobutton object to launch Infobutton URL.
 * @return {string} The description of the Problem/Diagnoses
 */
Infobutton.prototype.getDescription = function() {
    return this.m_description;
};

/**
 * Set the Problem/Diagnoses description that will be used by the Infobutton object to launch Infobutton URL
 * @param {string} description The description of the Problem/Diagnoses
 */
Infobutton.prototype.setDescription = function(description) {
    if ( typeof description !== "string") {
        throw new Error("Infobutton: Invalid description");
    }
    this.m_description = description;
};

/**
 * Retrieves the infobutton type that will be used by the Infobutton object to launch Infobutton URL.
 * @return {number} The Infobutton type for Problem/Diagnosis/Result/Medication Allergy.
 *  1 - Problem  2 - Diagnosis  4 - Medication 8- Result 16 - Medication Allergy
 */
Infobutton.prototype.getInfobuttonType = function() {
    return this.m_infoButtonType;
};

/**
 * Set the infobutton type that will be used by the Infobutton object to launch Infobutton URL.
 * It should be a non-negative number.
 *  1 - Problem  2 - Diagnosis  4 - Medication 8- Result 16 - Medication Allergy
 * @param {number} infobuttonType The Infobutton type for Problem/Diagnosis/Result/Medication Allergy.
 */
Infobutton.prototype.setInfobuttonType = function(infobuttonType) {
    var infobuttonTypeFound = false;
    if ( typeof infobuttonType !== "number" || infobuttonType < 0 ) {
        throw new Error("Infobutton: Invalid infobuttonType");
    }
    for (var index in Infobutton.infobuttonTypes) {
        if (Infobutton.infobuttonTypes[index] === infobuttonType) {
            infobuttonTypeFound = true;
        }
    }
    if ( infobuttonTypeFound ) {
        this.m_infoButtonType = infobuttonType;
    }
    else{
        throw new Error("Infobutton: Invalid infobuttonType");
    }       
};

/**
 * Retrieves the UUID that will be used by the Infobutton object to launch Infobutton URL.
 * @return {string} The UUID is the unique id for each request to the infobutton service.
 */
Infobutton.prototype.getUUID = function() {
    this.m_UUID = this.generateUUID();
    return this.m_UUID;
};

/**
 *This function generates the unique id UUID that will be used by the Infobutton object to launch Infobutton URL.
 */
Infobutton.prototype.generateUUID = function() {
    var dateTime = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (dateTime + Math.random() * 16) % 16 | 0;
        dateTime = Math.floor(dateTime / 16);
        return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);
    });
    return uuid;
};

/*
 * SetInfoButtonData allows the user to set all of the basic data elements at once, rather than calling each setter.
 * @param {double} personId The person id
 * @param {double} encounterId The encounter id
 * @param {double} priCriteriaCd The primary search criteria code value (from code set 15783)
 * @param {int} queryPurposeInd The patient education indicator (1 for patient, 2 for provider)
 * @param {int} performerInd The query performer indicator (1 for patient, 2 for provider)
 */
Infobutton.prototype.SetInfoButtonData = function(personId, encounterId, priCriteriaCd, queryPurposeInd, performerInd) {
    this.setPersonId(personId);
    this.setEncounterId(encounterId);
    this.setPrimaryCriteriaCd(priCriteriaCd);
    this.setQueryPurposeInd(queryPurposeInd);
    this.setPerformerInd(performerInd);
};

/*AddResult adds a Result to the infoButtonData search criteria result.Only eventId will be used for non Millenium
 * because the other params are fetched from the script mp_get_infobutton_data based on eventId and using this signature
 * to avoid changes to the consumers of Infobutton API and to be inline with COM wrapper DLL INFOBUTTONLINK.
 * @param {double} eventId The EventId for the Result criterion
 * @param {double} eventCd The Event code value for the Result criterion
 * @param {double} eventClassCd The Event Class code value for the Result criterion
 * @param {string} resultValue The Result Value string for the Result criterion
 * @param {double} resultValueCd The Result Value code value for the Result criterion
 * @param {double} resultUnitCd The Result Unit code value for the Result criterion
 */
Infobutton.prototype.AddResult = function(eventId, eventCd, eventClassCd, resultValue, resultValueCd, resultUnitCd) {
    this.setEventId(eventId);
    this.setInfobuttonType(Infobutton.infobuttonTypes.RESULT);
};

/* AddMedication adds a Medication to the infoButtonData search criteria.It checks that the parameters
 * are valid and then adds the passed in values to the medication list
 * @param {double} synonymId The SynonymId of the medication criterion
 */
Infobutton.prototype.AddMedication = function(synonymId) {
    this.setSynonymId(synonymId);
    this.setInfobuttonType(Infobutton.infobuttonTypes.MEDICATION);

};
/*
 * AddProblem adds a Problem to the infoButtonData search criteria. It checks that the parameters are
 * valid and then adds the passed in values to the problem list
 * @param {double} nomenclatureId The NomenclatureId for the Problem criterion
 * @param {double} searchNomenclatureId The SearchNomenclatureId for the Problem criterion
 * @param {string} problemDescription A plain text description of the Problem criterion
 */
Infobutton.prototype.AddProblem = function(nomenclatureId, searchNomenclatureId, problemDescription) {
    this.setNomenclatureId(nomenclatureId);
    this.setSearchNomenclatureId(searchNomenclatureId);
    this.setDescription(problemDescription);
    this.setInfobuttonType(Infobutton.infobuttonTypes.PROBLEM);

};
/*
 * AddDiagnosis adds a Diagnosis to the infoButtonData search criteria.
 * It checks that the parameters are valid and then adds the passed in values to the diagnosis list
 * @param {double} nomenclatureId The NomenclatureId for the Diagnosis criterion
 * @param {double} searchNomenclatureId The SearchNomenclatureId for the Diagnosis criterion
 * @param {string} diagnosisDescription A plain text description of the Diagnosis criterion
 */
Infobutton.prototype.AddDiagnosis = function(nomenclatureId, searchNomenclatureId, diagnosisDescription) {
    this.setNomenclatureId(nomenclatureId);
    this.setSearchNomenclatureId(searchNomenclatureId);
    this.setDescription(diagnosisDescription);
    this.setInfobuttonType(Infobutton.infobuttonTypes.DIAGNOSIS);
};

/*
 * LaunchInfoButton runs a service to launch an InfoButton url based on the criteria set.
 * If the service returns a url, that url is launch in a new browser window,otherwise
 * an error is returned.
 */
Infobutton.prototype.LaunchInfoButton = function() {
    try {
        var recordData = null;
        var scriptRequest = new ScriptRequest();
        scriptRequest.setProgramName("mp_get_infobutton_data");
        scriptRequest.setParameterArray(["^MINE^", this.getPersonId() + ".0", this.getEncounterId() + ".0", this.getInfobuttonType(), this.getNomenclatureId() + ".0", this.getSearchNomenclatureId() + ".0", "^" + this.getDescription() + "^", this.getSynonymId() + ".0", this.getEventId() + ".0", this.getPrimaryCriteriaCd() + ".0", "^" + this.getUUID() + "^"]);
        scriptRequest.setResponseHandler(function(scriptReply) {
            try {
                recordData = scriptReply.getResponse();
                if (scriptReply.getStatus() === "S") {
                    if (recordData.URL !== "") {
                        window.open(recordData.URL);
                    } else {
                        throw new Error(recordData.ERROR_TEXT);
                    }
                } else {
                    logger.logJSError(recordData.ERROR_TEXT, this, "INFOBUTTONLINK.js", "LaunchInfoButton");
                    throw new Error(recordData.ERROR_TEXT);
                }
            } catch (err) {
                var errorMessage = i18n.discernabu.INFO_BUTTON_ERROR_MSG;
                logger.logError(errorMessage);
                var errorModal = MP_ModalDialog.retrieveModalDialogObject("infoButtonErrorModal");
                if (!errorModal) {
                    errorModal = MP_Util.generateModalDialogBody("infoButtonErrorModal", "error", errorMessage, i18n.discernabu.INFO_BUTTON_ERROR_ACTION);
                    errorModal.setHeaderTitle(i18n.ERROR_OCCURED);
                    var closeButton = new ModalButton("closeButton");
                    closeButton.setText(i18n.CLOSE).setCloseOnClick(true);
                    errorModal.addFooterButton(closeButton);
                }
                MP_ModalDialog.updateModalDialogObject(errorModal);
                MP_ModalDialog.showModalDialog("infoButtonErrorModal");
                return;
            }
        });
        scriptRequest.performRequest();
    } catch (err) {
        logger.logJSError(err, this, "INFOBUTTONLINK.js", "LaunchInfoButton");        
        throw err;
    }
};

/*globals Util, _g, _gbt, ha, hs, MP_MenuManager, MP_Bedrock, Menu, FlowsheetTable, RenderStrategy, MPageGroupValue, MPageGrouper, MPageEventCodeGroup, MPageEventSetGroup, MPageSequenceGroup, CERN_COMPONENT_TYPE_WORKFLOW*/

/**
 * MPageComponent constructor
 * @constructor
 */
function MPageComponent() {

	//General variables
	this.m_AutoSuggestAddTimerName = "";
	this.m_AutoSuggestScript = "";
	this.m_brlookbackUnits = 0;
	this.m_brlookbackUnitTypeFlag = 0;
	this.m_column = 0;
	this.m_componentPreferences = null;
	this.m_compDisp = true;
	this.m_compLoad = false;
	this.m_compLoadTimerName = "";
	this.m_compMenuId = "";
	this.m_componentId = 0.0;
	this.m_compRenderTimerName = "";
	this.m_componentTable = null;
	this.m_flowsheetTable = null;
	this.criterion = null;
	//m_dateFormat: 1 = date only,2= date/time and 3 = elapsed time
	this.m_dateFormat = 2;
	this.m_displayFilters = null;
	this.m_editMode = false;
	this.m_filterMappingsObj = {};
	this.m_footerText = "";
	//m_grouper_arr: an array of objects structure like {"label":"group label", "eventSets": []}
	this.m_grouper_arr = null;
	this.m_grouperFilterCatalogCodes = null;
	this.m_grouperFilterCatLabel = "";
	this.m_grouperFilterCriteria = null;
	this.m_grouperFilterEventSets = null;
	this.m_grouperFilterLabel = "";
	this.m_groups = null;
	this.m_hasActionsMenu = false;
	this.m_hasCompFilters = false;
	this.m_hasLookBackDropDown = false;
	this.m_includeLineNumber = false;
	this.m_isAlwaysExpanded = false;
	this.m_isCustomizeView = false;
	this.m_isExpanded = false;
	this.m_isPlusAdd = false;
	this.m_isPlusAddCustom = false;
	this.m_isRefreshEnabled = true;
	this.m_isScrollEnabled = false;
	this.m_iViewItemsArr = null;
	this.m_iViewMenuItems = null;
	this.m_label = "";
	this.m_link = "";
	this.m_lookbackDays = 0;
	this.m_lookBackMenuItems = null;
	this.m_lookbackUnits = 0;
	this.m_resultRangeDirection = 0;
	//m_lookbackUnitTypeFlag: 1 = hours,2=Days,3=Weeks,4= Months,5= Years
	this.m_lookbackUnitTypeFlag = 0;
	this.m_menuItems = null;
	this.m_menuOptionNames = [];
	this.m_menuOptions = [];
	this.m_newLink = false;
	this.m_pageGroupSeq = 0;
	this.m_renderStrategy = null;
	this.m_reportId = 0;
	this.m_reportMean = "";
	this.m_resourceRequired = false;
	this.m_rootComponentNode = null;
	this.m_sectionContentNode = null;
	this.m_sequence = 0;
	//m_scope: 1=person,2=encounter
	this.m_scope = 0;
	this.m_ScopeHTML = "";
	this.m_scrollNumber = 0;
	this.m_selectedDataGroup = null;
	this.m_selectedTimeFrame = null;
	this.m_styles = null;
	this.m_subLabel = "";
	//m_toggleStatus: 0 - component off, 1 - component on, 2 - component retuired
	this.m_toggleStatus = 1;

	//properties for toggle icons on component headers
	this.m_activeHeaderToggleIndex = 0;
	this.m_headerToggleObjects = null;

	//the aggregate timer created by the containing view to measure the page load time
	this.m_aggregateTimer = null;
	this.m_hiLookupKey = "";
	this.m_aliasType = "";
	this.m_aliasPoolCd = 0.0;
	this.m_externalDataInd = false;
	this.m_hiTestUri = "";
	//Patient entered data bedrock indicator
	this.m_patEnteredDataInd = false;
	//Medication Reconciliation Statuses
	this.m_medHistory = false;
	this.m_medRecAdmit = false;
	this.m_medRecTransfer = false;
	this.m_medRecCrossEncTx = false;
	this.m_medRecDischarge = false;
	//properties for gapcheck functionality
	this.m_isRequired = false;
	this.m_overrideInd = false;
	this.m_isSatisfied = false;
	this.m_disclaimerText ="";
	
	//properties for contextual view functionality
	this.m_isContextualViewCompatible = false;
	this.m_isAddedToContextualView = false;
	this.m_contextualViewControl = null;
	this.m_contextualViewControlInPlaceholderView = null;
	this.m_placeholderView = null;
	this.m_rootPlaceholderComponentNode = null;
	this.m_canHaveContextualViewControl = false;
	this.m_sequenceInContextualView = 0;
};

//This object is used to convert full bedrock filter field names to their shorthand versions
MPageComponent.prototype.bedrockShorthandConversions = {
	PARENT_ENTITY_ID: "PE_ID",
	PARENT_ENTITY_NAME: "PE_NM",
	CDF_MEANING: "CDF_MN",
	GROUP_SEQ: "G_SQ",
	VALUE_SEQ: "V_SQ",
	FREETEXT_DESC: "FTXT",
	VALUE_TYPE_FLAG: "V_TYP",
	QUALIFIER_FLAG: "Q_FLG"
};

/* Adders - functions used to add content to MPageComponent object elements */
MPageComponent.prototype.addDisplayFilter = function(value) {
	if (this.m_displayFilters === null) {
		this.m_displayFilters = [];
	}
	this.m_displayFilters.push(value);
};

/**
 * Add a filter mapping object to the collection of filter mappings.  Filter mappings are referenced by name, so if a filter already
 * exists with the same name it will be overwritten.
 * @param {String} filterName The name of the filter object to add.
 * @param {Object} filterObject The object containing all of the filter properties used when loading settings.
 */
MPageComponent.prototype.addFilterMappingObject = function(filterName, filterObject) {
	//Convert full length field names into short hand if they are not already shorthand
	if (filterObject && typeof this.bedrockShorthandConversions[filterObject.field] !== 'undefined') {
		filterObject.field = this.bedrockShorthandConversions[filterObject.field];
	}
	this.m_filterMappingsObj[filterName] = filterObject;
};

MPageComponent.prototype.addIViewMenuItem = function(value) {
	if (this.m_iViewMenuItems === null) {
		this.m_iViewMenuItems = [];
	}
	this.m_iViewMenuItems.push(value);
};

MPageComponent.prototype.addLookbackMenuItem = function(value) {
	if (this.m_lookBackMenuItems === null) {
		this.m_lookBackMenuItems = [];
	}
	this.m_lookBackMenuItems.push(value);
};

MPageComponent.prototype.addGroup = function(value) {
	if (this.m_groups === null) {
		this.m_groups = [];
	}
	this.m_groups.push(value);
};

MPageComponent.prototype.addGrouperFilterCatalogCodes = function(value) {
	if (this.m_grouperFilterCatalogCodes === null) {
		this.m_grouperFilterCatalogCodes = [];
	}
	this.m_grouperFilterCatalogCodes.push(value);
};

MPageComponent.prototype.addGrouperFilterCriteria = function(value) {
	if (this.m_grouperFilterCriteria === null) {
		this.m_grouperFilterCriteria = [];
	}
	this.m_grouperFilterCriteria.push(value);

};

MPageComponent.prototype.addGrouperFilterEventSets = function(value) {
	this.addGrouperFilterCriteria(value);
};

MPageComponent.prototype.addMenuDither = function(itemName) {
	var menuItem = _g(this.m_menuOptions[itemName].id);
	if (menuItem) {
		Util.Style.acss(menuItem, "opts-menu-item-dthr");
		this.m_menuOptions[itemName].isMenuDithered = true;
	}
};

MPageComponent.prototype.addMenuItem = function(value) {
	if (this.m_menuItems === null) {
		this.m_menuItems = [];
	}
	this.m_menuItems.push(value);
};

MPageComponent.prototype.addMenuOption = function(itemName, id, text, ditherOnLoad, evtType, fn) {
	var actionSec = _g("optsMenuActions" + this.m_componentId);
	if (actionSec) {
		if (!actionSec.hasChildNodes()) {
			var isMenuDithered = (ditherOnLoad) ? ditherOnLoad : false;
			this.m_menuOptions[itemName] = {
				itemName: itemName,
				id: id,
				text: text,
				ditherOnLoad: ditherOnLoad,
				isMenuDithered: isMenuDithered,
				evtType: evtType,
				fn: fn
			};
			this.m_menuOptionNames.push(itemName);
		}
	}
};

/* Getters - functions used to retrieve items stored within the MPageComponent object*/
/**
 * Get the aggregate timer created by the containing view to measure the page load time
 * @return {AggregateTimer} the aggregate timer created by the containing view to measure the page load time
 */
MPageComponent.prototype.getAggregateTimer = function() {
	return this.m_aggregateTimer;
};

MPageComponent.prototype.getAutoSuggestAddScript = function() {
	return (this.m_AutoSuggestScript);
};

MPageComponent.prototype.getAutoSuggestAddTimerName = function() {
	return (this.m_AutoSuggestAddTimerName);
};

MPageComponent.prototype.getBrLookbackUnits = function() {
	return (this.m_brlookbackUnits);
};

MPageComponent.prototype.getBrLookbackUnitTypeFlag = function() {
	return (this.m_brlookbackUnitTypeFlag);
};

MPageComponent.prototype.getColumn = function() {
	return (this.m_column);
};

MPageComponent.prototype.getCompColor = function() {
	var style = this.getStyles();
	if (style) {
		return style.getColor();
	}
	else {
		return;
	}
};

MPageComponent.prototype.getComponentId = function() {
	return (this.m_componentId);
};

MPageComponent.prototype.getComponentLoadTimerName = function() {
	return (this.m_compLoadTimerName);
};

MPageComponent.prototype.getComponentRenderTimerName = function() {
	return (this.m_compRenderTimerName);
};

/**
 * Architectural method of creating a component's table to ensure that necessary fields are set.
 * Namely the namespace of the table which ensures unique identifiers for table DOM elements.
 * This helps to enforce namespacing.
 */
MPageComponent.prototype.getComponentTable = function() {
	return this.m_componentTable;
};

/**
 * For each compoent a criterion is defined for usage.  This criterion contains information such
 * as the person, encounter, personnel, etc.
 * @return {Criterion} Returns a Criterion object containing information such as the patient, encounter, personnel.
 */
MPageComponent.prototype.getCriterion = function() {
	return (this.criterion);
};

MPageComponent.prototype.getCustomizeView = function() {
	return this.m_isCustomizeView;
};

MPageComponent.prototype.getDateFormat = function() {
	//1 = date only,2= date/time and 3 = elapsed time
	return (this.m_dateFormat);
};

MPageComponent.prototype.getDisplayEnabled = function() {
	return (this.m_compDisp);
};

MPageComponent.prototype.getDisplayFilters = function() {
	return this.m_displayFilters;
};

MPageComponent.prototype.getFilters = function() {
	return (this.m_filters);
};

/**
 * Gets the array of filter mapping objects used to apply MPages View level settings.
 * @return {Array[Object]} An array of filter mapping objects.
 */
MPageComponent.prototype.getFilterMappingsObj = function() {
	return this.m_filterMappingsObj;
};

MPageComponent.prototype.getFooterText = function() {
	return (this.m_footerText);
};

MPageComponent.prototype.getGrouperCatalogCodes = function(index) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].catalogCodes : "";
	}
};

MPageComponent.prototype.getGrouperCatLabel = function(index) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].catLabel : "";
	}
};

MPageComponent.prototype.getGrouperCriteria = function(index) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].criteria : "";
	}
};

MPageComponent.prototype.getGrouperFilterCatalogCodes = function() {
	return this.m_grouperFilterCatalogCodes;
};

MPageComponent.prototype.getGrouperFilterCatLabel = function() {
	return this.m_grouperFilterCatLabel;
};

MPageComponent.prototype.getGrouperFilterCriteria = function() {
	return this.m_grouperFilterCriteria;
};

MPageComponent.prototype.getGrouperFilterEventSets = function() {
	return (this.getGrouperFilterCriteria());
};

MPageComponent.prototype.getGrouperFilterLabel = function() {
	return this.m_grouperFilterLabel;
};

MPageComponent.prototype.getGrouperEventSets = function(index) {
	return this.getGrouperCriteria(index);
};

MPageComponent.prototype.getGrouperLabel = function(index) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].label : "";
	}
};

MPageComponent.prototype.getGroups = function() {
	if (this.m_groups === null) {
		this.m_groups = [];
	}
	return (this.m_groups);
};

MPageComponent.prototype.getGrp1CatalogCodes = function() {
	return this.getGrouperCatalogCodes(0);
};

MPageComponent.prototype.getGrp1CatLabel = function() {
	return this.getGrouperCatLabel(0);
};

MPageComponent.prototype.getGrp1Criteria = function() {
	return this.getGrouperCriteria(0);
};

MPageComponent.prototype.getGrp1EventSets = function() {
	return this.getGrouperCriteria(0);
};

MPageComponent.prototype.getGrp1Label = function() {
	return this.getGrouperLabel(0);
};

MPageComponent.prototype.getGrp2CatalogCodes = function() {
	return this.getGrouperCatalogCodes(1);
};

MPageComponent.prototype.getGrp2CatLabel = function() {
	return this.getGrouperCatLabel(1);
};

MPageComponent.prototype.getGrp2Criteria = function() {
	return this.getGrouperCriteria(1);
};

MPageComponent.prototype.getGrp2EventSets = function() {
	return this.getGrouperCriteria(1);
};

MPageComponent.prototype.getGrp2Label = function() {
	return this.getGrouperLabel(1);
};

MPageComponent.prototype.getGrp3CatalogCodes = function() {
	return this.getGrouperCatalogCodes(2);
};

MPageComponent.prototype.getGrp3CatLabel = function() {
	return this.getGrouperCatLabel(2);
};

MPageComponent.prototype.getGrp3Criteria = function() {
	return this.getGrouperCriteria(2);
};

MPageComponent.prototype.getGrp3EventSets = function() {
	return this.getGrouperCriteria(2);
};

MPageComponent.prototype.getGrp3Label = function() {
	return this.getGrouperLabel(2);
};

MPageComponent.prototype.getGrp4CatalogCodes = function() {
	return this.getGrouperCatalogCodes(3);
};

MPageComponent.prototype.getGrp4CatLabel = function() {
	return this.getGrouperCatLabel(3);
};

MPageComponent.prototype.getGrp4Criteria = function() {
	return this.getGrouperCriteria(3);
};

MPageComponent.prototype.getGrp4EventSets = function() {
	return this.getGrouperCriteria(3);
};

MPageComponent.prototype.getGrp4Label = function() {
	return this.getGrouperLabel(3);
};

MPageComponent.prototype.getGrp5CatalogCodes = function() {
	return this.getGrouperCatalogCodes(4);
};

MPageComponent.prototype.getGrp5CatLabel = function() {
	return this.getGrouperCatLabel(4);
};

MPageComponent.prototype.getGrp5Criteria = function() {
	return this.getGrouperCriteria(4);
};

MPageComponent.prototype.getGrp5EventSets = function() {
	return this.getGrouperCriteria(4);
};

MPageComponent.prototype.getGrp5Label = function() {
	return this.getGrouperLabel(4);
};

MPageComponent.prototype.getGrp6CatalogCodes = function() {
	return this.getGrouperCatalogCodes(5);
};

MPageComponent.prototype.getGrp6CatLabel = function() {
	return this.getGrouperCatLabel(5);
};

MPageComponent.prototype.getGrp6Criteria = function() {
	return this.getGrouperCriteria(5);
};

MPageComponent.prototype.getGrp6EventSets = function() {
	return this.getGrouperCriteria(5);
};

MPageComponent.prototype.getGrp6Label = function() {
	return this.getGrouperLabel(5);
};

MPageComponent.prototype.getGrp7CatalogCodes = function() {
	return this.getGrouperCatalogCodes(6);
};

MPageComponent.prototype.getGrp7CatLabel = function() {
	return this.getGrouperCatLabel(6);
};

MPageComponent.prototype.getGrp7Criteria = function() {
	return this.getGrouperCriteria(6);
};

MPageComponent.prototype.getGrp7EventSets = function() {
	return this.getGrouperCriteria(6);
};

MPageComponent.prototype.getGrp7Label = function() {
	return this.getGrouperLabel(6);
};

MPageComponent.prototype.getGrp8CatalogCodes = function() {
	return this.getGrouperCatalogCodes(7);
};

MPageComponent.prototype.getGrp8CatLabel = function() {
	return this.getGrouperCatLabel(7);
};

MPageComponent.prototype.getGrp8Criteria = function() {
	return this.getGrouperCriteria(7);
};

MPageComponent.prototype.getGrp8EventSets = function() {
	return this.getGrouperCriteria(7);
};

MPageComponent.prototype.getGrp8Label = function() {
	return this.getGrouperLabel(7);
};

MPageComponent.prototype.getGrp9CatalogCodes = function() {
	return this.getGrouperCatalogCodes(8);
};

MPageComponent.prototype.getGrp9CatLabel = function() {
	return this.getGrouperCatLabel(8);
};

MPageComponent.prototype.getGrp9Criteria = function() {
	return this.getGrouperCriteria(8);
};

MPageComponent.prototype.getGrp9EventSets = function() {
	return this.getGrouperCriteria(8);
};

MPageComponent.prototype.getGrp9Label = function() {
	return this.getGrouperLabel(8);
};

MPageComponent.prototype.getGrp10CatalogCodes = function() {
	return this.getGrouperCatalogCodes(9);
};

MPageComponent.prototype.getGrp10CatLabel = function() {
	return this.getGrouperCatLabel(9);
};

MPageComponent.prototype.getGrp10Criteria = function() {
	return this.getGrouperCriteria(9);
};

MPageComponent.prototype.getGrp10EventSets = function() {
	return this.getGrouperCriteria(9);
};

MPageComponent.prototype.getGrp10Label = function() {
	return this.getGrouperLabel(9);
};

MPageComponent.prototype.getHasActionsMenu = function() {
	return this.m_hasActionsMenu;
};

MPageComponent.prototype.getPreferencesObj = function() {
	return this.m_componentPreferences;
};

MPageComponent.prototype.getIViewItemsArrElement = function(index, nameSelect) {
	if (!this.m_iViewItemsArr) {
		this.m_iViewItemsArr = [];
	}

	if (index !== null && !isNaN(index)) {
		switch (nameSelect) {
			case "BAND":
				return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].bandName : "";
			case "SECTION":
				return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].sectionName : "";
			case "ITEM":
				return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].itemName : "";
			default:
				return "";
		}
	}
};

MPageComponent.prototype.getIViewMenuItems = function() {
	return this.m_iViewMenuItems;
};

MPageComponent.prototype.getLabel = function() {
	return (this.m_label);
};

MPageComponent.prototype.getLink = function() {
	return (this.m_link);
};

MPageComponent.prototype.getLookbackDays = function() {
	return (this.m_lookbackDays);
};

MPageComponent.prototype.getLookbackMenuItems = function() {
	return this.m_lookBackMenuItems;
};

MPageComponent.prototype.getResultRangeDirection = function() {
	return (this.m_resultRangeDirection);
};
MPageComponent.prototype.getLookbackUnits = function() {
	return (this.m_lookbackUnits);
};

MPageComponent.prototype.getLookbackUnitTypeFlag = function() {
	return (this.m_lookbackUnitTypeFlag);
};

MPageComponent.prototype.getMedHistory = function() {
	return (this.m_medHistory);
};

MPageComponent.prototype.getMedRecAdmit = function() {
	return (this.m_medRecAdmit);
};

MPageComponent.prototype.getMedRecTransfer = function() {
	return (this.m_medRecTransfer);
};

MPageComponent.prototype.getMedRecCrossEncTx = function() {
	return (this.m_medRecCrossEncTx);
};

MPageComponent.prototype.getMedRecDischarge = function() {
	return (this.m_medRecDischarge);
};

/**
 * Retrieves the menu that is created by the architecture for this component
 * @return {Menu} The Menu object created for this component by the architecture
 */
MPageComponent.prototype.getMenu = function() {
	return MP_MenuManager.getMenuObject(this.m_compMenuId);
};

MPageComponent.prototype.getMenuItems = function() {
	return this.m_menuItems;
};

MPageComponent.prototype.getMenuOptionNames = function() {
	return this.m_menuOptionNames;
};

MPageComponent.prototype.getMenuOptions = function() {
	return this.m_menuOptions;
};

MPageComponent.prototype.getMPageName = function() {
	return (this.m_MPageName);
};

MPageComponent.prototype.getPageGroupSequence = function() {
	return (this.m_pageGroupSeq);
};

MPageComponent.prototype.getRenderStrategy = function() {
	return this.m_renderStrategy;
};

MPageComponent.prototype.getReportId = function() {
	return (this.m_reportId);
};

MPageComponent.prototype.getReportMean = function() {
	return (this.m_reportMean);
};

MPageComponent.prototype.getRootComponentNode = function() {
	if (this.m_rootComponentNode === null) {
		var style = this.getStyles();
		this.m_rootComponentNode = _g(style.getId());
	}
	return (this.m_rootComponentNode);
};

MPageComponent.prototype.getSectionContentNode = function() {
	if (this.m_sectionContentNode === null) {
		var style = this.getStyles();
		this.m_sectionContentNode = _g(style.getContentId());
	}
	return (this.m_sectionContentNode);
};

MPageComponent.prototype.getSelectedDataGroup = function() {
	return (this.m_selectedDataGroup);
};

MPageComponent.prototype.getSelectedTimeFrame = function() {
	return (this.m_selectedTimeFrame);
};

MPageComponent.prototype.getSequence = function() {
	return (this.m_sequence);
};

MPageComponent.prototype.getScope = function() {
	return (this.m_scope);
};

MPageComponent.prototype.getScopeHTML = function() {
	return (this.m_ScopeHTML);
};

MPageComponent.prototype.getScrollNumber = function() {
	return (this.m_scrollNumber);
};

MPageComponent.prototype.getSubLabel = function() {
	return (this.m_subLabel);
};

MPageComponent.prototype.getToggleStatus = function() {
	return this.m_toggleStatus;
};

/**
 * Determines if the component will respect the pregnancy onset as the default lookback when available
 * @return {Boolean} true if the onset will be respected, false otherwise
 */
MPageComponent.prototype.getPregnancyLookbackInd = function() {
	return this.m_pregLookbackInd;
};

/**
 * For each component a Healthe Intent lookup key is defined for usage.  This key tells HI who to identify a patient
 * @return {m_hiLookupKey} Returns a Healthe Intent lookup key.
 */
MPageComponent.prototype.getHILookupKey = function() {
	return (this.m_hiLookupKey);
};

/**
 * For each component a Healthe Intent alias type is defined for usage.  This key tells HI how to identify a patient
 * such as by id or by mrn.
 * @return {m_aliasType} Returns a Healthe Intent alias type.
 */
MPageComponent.prototype.getAliasType = function() {
	return (this.m_aliasType);
};

/**
 * For each component a Healthe Intent alias pool code is defined for usage.  This key tells HI from what alias pool/group
 * the lookup may be in.
 * @return {m_aliasPoolCd} Returns a Healthe Intent alias pool code.
 */
MPageComponent.prototype.getAliasPoolCd = function() {
	return (this.m_aliasPoolCd);
};

/**
 * Displays the value for the indicator that determine whether to show data from external sources or not
 * @return {m_externalDataInd} Returns a true or false.
 */
MPageComponent.prototype.getExternalDataInd = function() {
	return (this.m_externalDataInd);
};

/**
 * getPatientEnteredDataInd Returns the value for the patient entered data indicator which is set in bedrock
 * @return {boolean} m_patEnteredDataInd - true/false
 */
MPageComponent.prototype.getPatientEnteredDataInd = function() {
	return this.m_patEnteredDataInd;
};
/**
 * Displays the text of the Healthe Intent Test Service URI
 * @return {m_hiTestUri} Returns a test service URI.
 */
MPageComponent.prototype.getHITestUri = function() {
	return (this.m_hiTestUri);
};

/* Checkers - functions used to check the state of variables contained within the MPageComponent object */
MPageComponent.prototype.hasInfoButton = function() {
	return (this.m_hasInfoButton);
};
MPageComponent.prototype.setSequenceInContextualView = function(value) {
	this.m_sequenceInContextualView = value;
};

MPageComponent.prototype.setHasInfoButton = function(value) {
	this.m_hasInfoButton = (value == 1 ? true : false);
};

MPageComponent.prototype.isInfoButtonEnabled = function() {
	return (this.m_isInfoEnabled);
};

MPageComponent.prototype.setIsInfoButtonEnabled = function(value) {
	this.m_isInfoEnabled = (value == 1 ? true : false);
};

MPageComponent.prototype.showInfoButton = function(compObj, stateInd) {
	var contentBodyObj = this.getSectionContentNode();
	//Then search node for info-icon
	var infoButtons = $(contentBodyObj)
		.find(".info-icon");
	if (stateInd) {
		$(infoButtons)
			.removeClass("hidden");
	}
	else {
		$(infoButtons)
			.addClass("hidden");
	}
};

MPageComponent.prototype.hasCompFilters = function() {
	return (this.m_hasCompFilters);
};

MPageComponent.prototype.hasLookBackDropDown = function() {
	return (this.m_hasLookBackDropDown);
};

MPageComponent.prototype.isDisplayable = function() {
	if (this.isComponentFiltered()) {
		return false;
	}
	return this.m_compDisp;
};

/*Getter and  setter for Gap Check functionality*/
/**
 * This method returns the disclaimer text that gets added to the unsatisfied components header
 * @return {string} Returns a Disclaimer text.
 */
MPageComponent.prototype.getRequiredCompDisclaimerText = function () {
	return this.m_disclaimerText;
};
/**
 * This method sets the disclaimer text at the component level that gets added to the unsatisfied components header
 * @param {string} text :disclaimer text specific to the component.
 * @return {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setRequiredCompDisclaimerText = function (text) {
	this.m_disclaimerText = text;
};
/**
 * This method returns a boolean indicating the component is required or not. 
 * @return {boolean} returns the boolean value set.
 */
MPageComponent.prototype.getGapCheckRequiredInd = function () {
	return this.m_isRequired;
};
/**
 * This method sets a boolean value indicating whether it is a required component or not in the given view based on bedrock setting. 
 * @param  {boolean}requiredStatus boolean value set based on the component bedrock setting
 * @return {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setGapCheckRequiredInd = function (requiredStatus) {
	this.m_isRequired = requiredStatus;
};
/**
 * This method returns a boolean indicating whether override reason is required or not for an unsatisfied component.
 * @return {boolean} returns the boolean value set.
 */
MPageComponent.prototype.getOverrideInd = function () {
	return this.m_overrideInd;
};
/**
 * Determines if the unsatisfied component needs override reason to be added or not.
 * @param  {overrideStatus} boolean value indicating if override reason is required or not for an unsatisfied component
 * @return {null} this method does not have a return value.
 */
MPageComponent.prototype.setOverrideInd = function (overrideStatus) {
	this.m_overrideInd = overrideStatus;
};
/**
 * This method returns a boolean based on the validation which is specific to the component.
 * @return {boolean} returns the boolean value set.
 */
MPageComponent.prototype.getSatisfiedInd = function () {
	return this.m_isSatisfied;
};
/**
 * This method sets a boolean value after checking the condition required for the discharge process, which is specific to the component.
 * @param  {statisfiedStatus} value set based on the validation added at component level.
 * @return {null} this method does not have a return value.
 */
MPageComponent.prototype.setSatisfiedInd = function (statisfiedStatus) {
	this.m_isSatisfied = statisfiedStatus;
};
/**
 * Checks the display filters for the component.
 * @return {boolean} True if the component should not be displayed because of a filter, false otherwise.
 */
MPageComponent.prototype.isComponentFiltered = function() {
	if (this.m_displayFilters !== null && this.m_displayFilters.length > 0) {
		for (var x = this.m_displayFilters.length; x--;) {
			var displayFilter = this.m_displayFilters[x];
			if (displayFilter.checkFilters() === false) {
				CERN_EventListener.removeAllListeners(this, this);
				return true;
			}
		}
	}
	return false;
};

MPageComponent.prototype.isAlwaysExpanded = function() {
	return (this.m_isAlwaysExpanded);
};

MPageComponent.prototype.isEditMode = function() {
	return (this.m_editMode);
};

MPageComponent.prototype.isExpanded = function() {
	return (this.m_isExpanded);
};

MPageComponent.prototype.isIViewAdd = function() {};

/**
 * Return true if the component has been defined as including the line number within the
 * title text of the component.
 */
MPageComponent.prototype.isLineNumberIncluded = function() {
	return this.m_includeLineNumber;
};

MPageComponent.prototype.isLoaded = function() {
	return (this.m_compLoad);
};

MPageComponent.prototype.isMenuDithered = function(itemName) {
	return this.m_menuOptions[itemName].isMenuDithered;
};

MPageComponent.prototype.isNewLink = function() {
	return (this.m_newLink);
};

/**
 * Retrieves the plus add indicator that will be used to launch the win32 and custom functionality.
 * @return {boolean} Flag indicating whether the plus add button on the component header should be displayed or not
 * based on the plusaddcustom indicator,in Millennium Context or non Millennium context and the bedrock settings.
 */
MPageComponent.prototype.isPlusAddEnabled = function() {
	if (this.isPlusAddCustom() && this.m_isPlusAdd) {
		return true;
	}
	if (!CERN_Platform.inMillenniumContext()) {
		return false;
	}
	return (this.m_isPlusAdd);
};

/**
 * Getter for refreshEnabled, a boolean that indicates whether the
 * workflow component will be rendered with an enabled component
 * refresh button or not.
 * @return {boolean}
 */
MPageComponent.prototype.isRefreshEnabled = function() {
	return (this.m_isRefreshEnabled);
};

MPageComponent.prototype.isResourceRequired = function() {
	return (this.m_resourceRequired);
};

MPageComponent.prototype.isScrollingEnabled = function() {
	return (this.m_isScrollEnabled);
};

/**
 * Retrieves the plus add flag which signifies if the addPlus functionality is custom or not.
 * @return {boolean} Flag indicating whether the functionality tied to the plus add is custom or not.
 */
MPageComponent.prototype.isPlusAddCustom = function() {
	return (this.m_isPlusAddCustom);
};

MPageComponent.prototype.getStyles = function() {
	return (this.m_styles);
};

/**
 * Retrieves the flag that indicates whether the component is Contextual view compatible
 * @return {boolean} Flag indicating whether the component is Contextual view compatible
 */
MPageComponent.prototype.isContextualViewCompatible = function() {
	return this.m_isContextualViewCompatible;
};

/**
 * Retrieves the flag that indicates whether the component is added to Contextual view 
 * @return {boolean} Flag indicating whether the component is added to Contextual view 
 */
MPageComponent.prototype.isAddedToContextualView = function() {
	return this.m_isAddedToContextualView;
};

 /**
 * Retrieves the instance of MPageUI.Button for the contextual view control in actual component 
 * @return {MPageUI.Button} The instance of MPageUI.Button for the contextual view control in actual component.
 */
MPageComponent.prototype.getContextualViewControl = function() {
	return this.m_contextualViewControl;
};
/**
 * Retrieves the flag that indicates whether the component can have Contextual view control
 * @return {boolean} Flag indicating whether the component can have Contextual view control
 */
MPageComponent.prototype.canHaveContextualViewControl = function() {
	return this.m_canHaveContextualViewControl;
};

/**
 * Retrieves the instance of MPageUI.Button for the contextual view control in PlaceholderView
 * @return {MPageUI.Button} The instance of MPageUI.Button for the contextual view control in PlaceholderView.
 */
MPageComponent.prototype.getContextualViewControlInPlaceholderView = function() {
	return this.m_contextualViewControlInPlaceholderView;
};

/**
 * Retrieves the sequence of the component in Contextual view 
 * @return {Number} The value that indicates the sequence of the component in contextual view.
 */
MPageComponent.prototype.getSequenceInContextualView = function(value) {
	return this.m_sequenceInContextualView;
};
/**
 * Sets the root node of the component as PlaceholderView
 * @param {Object} obj The dom node representing the placeholder view of component
 */
MPageComponent.prototype.getRootPlaceholderComponentNode = function() {
	if(this.m_rootPlaceholderComponentNode === null || !this.m_rootPlaceholderComponentNode.length) {
		var style = this.getStyles();
		this.m_rootPlaceholderComponentNode = $("#"+style.getId()+"PlaceholderView");
	}
	return (this.m_rootPlaceholderComponentNode);
};

/**
 * Sets the instance of PlaceholderView
 * @param {Object} obj An Instance of PlaceholderView
 */
MPageComponent.prototype.getPlaceholderView = function() {
	return this.m_placeholderView;
};


/* Setters - functions used to set the values of MPageComponent object elements*/

/**
 * Set the aggregate timer created by the containing view to measure the page load time
 * @param {AggregateTimer} value the aggregate timer created by the containing view to measure the page load time
 */
MPageComponent.prototype.setAggregateTimer = function(value) {
	this.m_aggregateTimer = value;
};

MPageComponent.prototype.setAlwaysExpanded = function(value) {
	this.m_isAlwaysExpanded = value;
};

MPageComponent.prototype.setAutoSuggestAddScript = function(value) {
	this.m_AutoSuggestScript = value;
};

MPageComponent.prototype.setAutoSuggestAddTimerName = function(value) {
	this.m_AutoSuggestAddTimerName = value;
};

MPageComponent.prototype.setBrLookbackUnits = function(value) {
	this.m_brlookbackUnits = value;
};

MPageComponent.prototype.setBrLookbackUnitTypeFlag = function(value) {
	this.m_brlookbackUnitTypeFlag = value;
};

MPageComponent.prototype.setColumn = function(value) {
	this.m_column = value;
};

MPageComponent.prototype.setCompColor = function(color) {
	var style = this.getStyles();
	if (style) {
		if (color && color.length > 0) {
			style.setColor(color);
		}
	}
};

MPageComponent.prototype.setCompFilters = function(value) {
	this.m_hasCompFilters = value;
};

MPageComponent.prototype.setComponentId = function(value) {
	this.m_componentId = value;
	var styles = this.getStyles();
	if (styles !== null) {
		styles.setComponentId(value);
	}
};

MPageComponent.prototype.setComponentLoadTimerName = function(value) {
	this.m_compLoadTimerName = value;
};

MPageComponent.prototype.setComponentRenderTimerName = function(value) {
	this.m_compRenderTimerName = value;
};

MPageComponent.prototype.setComponentTable = function(componentTable) {
	if (!ComponentTable.prototype.isPrototypeOf(componentTable)) {
		throw new Error("Called setComponentTable on MPageComponent with non ComponentTable type for componentTable parameter");
	}
	this.m_componentTable = componentTable;
};

MPageComponent.prototype.getComponentTable = function() {
	return (this.m_componentTable);
};

MPageComponent.prototype.setFlowsheetTable = function(flowsheetTable) {
	if (!(FlowsheetTable.prototype.isPrototypeOf(flowsheetTable))) {
		throw new Error("Called setFlowsheetTable on MPageComponent with non FlowsheetTable type for FlowsheetTable parameter");
	}

	this.m_flowsheetTable = flowsheetTable;
};

MPageComponent.prototype.getFlowsheetTable = function() {
	return (this.m_flowsheetTable);
};
/**
 * Sets the criterion
 * @param {Criterion} value The Criterion object in which to initialize the component with.
 */
MPageComponent.prototype.setCriterion = function(value) {
	this.criterion = value;
};

MPageComponent.prototype.setCustomizeView = function(value) {
	this.m_isCustomizeView = value;
};

MPageComponent.prototype.setDateFormat = function(value) {
	this.m_dateFormat = value;
};

MPageComponent.prototype.setDisplayEnabled = function(value) {
	this.m_compDisp = value;
};

MPageComponent.prototype.setDisplayFilters = function(value) {
	this.m_displayFilters = value;
};

MPageComponent.prototype.setEditMode = function(value) {
	this.m_editMode = value;
};

MPageComponent.prototype.setExpandCollapseState = function(value) {
	this.m_isExpanded = value;
	var i18nCore = i18n.discernabu;
	var parentNode = this.getRootComponentNode();
	var expColNode = Util.Style.g("sec-hd-tgl", parentNode, "span");
	if (value) {
		Util.Style.rcss(parentNode, "closed");
		expColNode[0].innerHTML = "-";
		expColNode[0].title = i18nCore.HIDE_SECTION;
	}
	else {
		Util.Style.acss(parentNode, "closed");
		expColNode[0].innerHTML = "+";
		expColNode[0].title = i18nCore.SHOW_SECTION;
	}
};

MPageComponent.prototype.setExpanded = function(value) {
	this.m_isExpanded = value;
};

/**
 * Sets the filter mappings object which will be used when loading settings from the preferences model.  The filterObj parameter must
 * not be null.  If it is null it will be ignored.
 * @param {Object} filterObj An object which contains the filter mappings of the MPageView object
 * @return {Boolean} True if the m_filterMappingsObj was set to filterObj, false otherwise
 */
MPageComponent.prototype.setFilterMappingsObj = function(filterObj) {
	if (filterObj) {
		this.m_filterMappingsObj = filterObj;
		return true;
	}
	return false;
};

MPageComponent.prototype.setFooterText = function(value) {
	this.m_footerText = value;
};

MPageComponent.prototype.setGrouperCatalogCodes = function(index, CatalogCodeItem) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		if (this.m_grouper_arr[index]) {
			this.m_grouper_arr[index].catalogCodes = CatalogCodeItem;
		}
		else {
			this.m_grouper_arr[index] = {};
			this.m_grouper_arr[index].catalogCodes = CatalogCodeItem;
		}
	}
};

MPageComponent.prototype.setGrouperCatLabel = function(index, label) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		if (this.m_grouper_arr[index]) {
			this.m_grouper_arr[index].catLabel = label;
		}
		else {
			this.m_grouper_arr[index] = {};
			this.m_grouper_arr[index].catLabel = label;
		}
	}
};

MPageComponent.prototype.setGrouperCriteria = function(index, Criteria) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		if (this.m_grouper_arr[index]) {
			this.m_grouper_arr[index].criteria = Criteria;
		}
		else {
			this.m_grouper_arr[index] = {};
			this.m_grouper_arr[index].criteria = Criteria;
		}
	}
};

MPageComponent.prototype.setGrouperEventSets = function(index, EventSetItem) {
	this.setGrouperCriteria(index, EventSetItem);
};

MPageComponent.prototype.setGrouperLabel = function(index, label) {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	if (index !== null && !isNaN(index)) {
		if (this.m_grouper_arr[index]) {
			this.m_grouper_arr[index].label = label;
		}
		else {
			this.m_grouper_arr[index] = {};
			this.m_grouper_arr[index].label = label;
		}
	}
};

MPageComponent.prototype.setGrp1CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(0, value);
};

MPageComponent.prototype.setGrp1CatLabel = function(value) {
	this.setGrouperCatLabel(0, value);
};

MPageComponent.prototype.setGrp1Criteria = function(value) {
	this.setGrouperCriteria(0, value);
};

MPageComponent.prototype.setGrp1EventSets = function(value) {
	this.setGrouperCriteria(0, value);
};

MPageComponent.prototype.setGrp1Label = function(value) {
	this.setGrouperLabel(0, value);
};

MPageComponent.prototype.setGrp2CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(1, value);
};

MPageComponent.prototype.setGrp2CatLabel = function(value) {
	this.setGrouperCatLabel(1, value);
};

MPageComponent.prototype.setGrp2Criteria = function(value) {
	this.setGrouperCriteria(1, value);
};

MPageComponent.prototype.setGrp2EventSets = function(value) {
	this.setGrouperCriteria(1, value);
};

MPageComponent.prototype.setGrp2Label = function(value) {
	this.setGrouperLabel(1, value);
};

MPageComponent.prototype.setGrp3CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(2, value);
};

MPageComponent.prototype.setGrp3CatLabel = function(value) {
	this.setGrouperCatLabel(2, value);
};

MPageComponent.prototype.setGrp3Criteria = function(value) {
	this.setGrouperCriteria(2, value);
};

MPageComponent.prototype.setGrp3EventSets = function(value) {
	this.setGrouperCriteria(2, value);
};

MPageComponent.prototype.setGrp3Label = function(value) {
	this.setGrouperLabel(2, value);
};

MPageComponent.prototype.setGrp4CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(3, value);
};

MPageComponent.prototype.setGrp4CatLabel = function(value) {
	this.setGrouperCatLabel(3, value);
};

MPageComponent.prototype.setGrp4Criteria = function(value) {
	this.setGrouperCriteria(3, value);
};

MPageComponent.prototype.setGrp4EventSets = function(value) {
	this.setGrouperCriteria(3, value);
};

MPageComponent.prototype.setGrp4Label = function(value) {
	this.setGrouperLabel(3, value);
};

MPageComponent.prototype.setGrp5CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(4, value);
};

MPageComponent.prototype.setGrp5CatLabel = function(value) {
	this.setGrouperCatLabel(4, value);
};

MPageComponent.prototype.setGrp5Criteria = function(value) {
	this.setGrouperCriteria(4, value);
};

MPageComponent.prototype.setGrp5EventSets = function(value) {
	this.setGrouperCriteria(4, value);
};

MPageComponent.prototype.setGrp5Label = function(value) {
	this.setGrouperLabel(4, value);
};

MPageComponent.prototype.setGrp6CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(5, value);
};

MPageComponent.prototype.setGrp6CatLabel = function(value) {
	this.setGrouperCatLabel(5, value);
};

MPageComponent.prototype.setGrp6Criteria = function(value) {
	this.setGrouperCriteria(5, value);
};

MPageComponent.prototype.setGrp6EventSets = function(value) {
	this.setGrouperCriteria(5, value);
};

MPageComponent.prototype.setGrp6Label = function(value) {
	this.setGrouperLabel(5, value);
};

MPageComponent.prototype.setGrp7CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(6, value);
};

MPageComponent.prototype.setGrp7CatLabel = function(value) {
	this.setGrouperCatLabel(6, value);
};

MPageComponent.prototype.setGrp7Criteria = function(value) {
	this.setGrouperCriteria(6, value);
};

MPageComponent.prototype.setGrp7Label = function(value) {
	this.setGrouperLabel(6, value);
};

MPageComponent.prototype.setGrp8CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(7, value);
};

MPageComponent.prototype.setGrp8CatLabel = function(value) {
	this.setGrouperCatLabel(7, value);
};

MPageComponent.prototype.setGrp8Criteria = function(value) {
	this.setGrouperCriteria(7, value);
};

MPageComponent.prototype.setGrp8EventSets = function(value) {
	this.setGrouperCriteria(7, value);
};

MPageComponent.prototype.setGrp8Label = function(value) {
	this.setGrouperLabel(7, value);
};

MPageComponent.prototype.setGrp9CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(8, value);
};

MPageComponent.prototype.setGrp9CatLabel = function(value) {
	this.setGrouperCatLabel(8, value);
};

MPageComponent.prototype.setGrp9Criteria = function(value) {
	this.setGrouperCriteria(8, value);
};

MPageComponent.prototype.setGrp9EventSets = function(value) {
	this.setGrouperCriteria(8, value);
};

MPageComponent.prototype.setGrp9Label = function(value) {
	this.setGrouperLabel(8, value);
};

MPageComponent.prototype.setGrp10CatalogCodes = function(value) {
	this.setGrouperCatalogCodes(9, value);
};

MPageComponent.prototype.setGrp10CatLabel = function(value) {
	this.setGrouperCatLabel(9, value);
};

MPageComponent.prototype.setGrp10Criteria = function(value) {
	this.setGrouperCriteria(9, value);
};

MPageComponent.prototype.setGrp10EventSets = function(value) {
	this.setGrouperCriteria(9, value);
};

MPageComponent.prototype.setGrp10Label = function(value) {
	this.setGrouperLabel(9, value);
};

MPageComponent.prototype.setGrouperFilterCatalogCodes = function(value) {
	this.m_grouperFilterCatalogCodes = value;
};

MPageComponent.prototype.setGrouperFilterCatLabel = function(value) {
	this.m_grouperFilterCatLabel = value;
};

MPageComponent.prototype.setGrouperFilterCriteria = function(value) {
	this.m_grouperFilterCriteria = value;
};

MPageComponent.prototype.setGrouperFilterEventSets = function(value) {
	this.setGrouperFilterCriteria(value);
};

MPageComponent.prototype.setGrouperFilterLabel = function(value) {
	this.m_grouperFilterLabel = value;
};

MPageComponent.prototype.setGroups = function(value) {
	this.m_groups = value;
};

MPageComponent.prototype.setHasActionsMenu = function(value) {
	this.m_hasActionsMenu = value;
};

MPageComponent.prototype.setLookBackDropDown = function(value) {
	this.m_hasLookBackDropDown = value;
};

/**
 * Allows each component to define, based on requirements, whether or not to display the number of
 * line items within the title text of the component.
 * @param {Boolean} value If true, the line number associated to the component will display within the
 * title text of the component.  Else, the line number will not display within the title text of the
 * component.
 */
MPageComponent.prototype.setIncludeLineNumber = function(value) {
	this.m_includeLineNumber = value;
};

MPageComponent.prototype.setIViewItemsArrElement = function(index, sBandName, sSectionName, sItemName) {
	if (!this.m_iViewItemsArr) {
		this.m_iViewItemsArr = [];
	}

	if (index !== null && !isNaN(index)) {
		this.m_iViewItemsArr[index] = {
			bandName: sBandName,
			sectionName: sSectionName,
			itemName: sItemName
		};
	}
};

MPageComponent.prototype.setIViewMenuItems = function(value) {
	this.m_iViewMenuItems = value;
};

MPageComponent.prototype.setLabel = function(value) {
	this.m_label = value;
};

MPageComponent.prototype.setLink = function(value) {
	this.m_link = value;
};

MPageComponent.prototype.setLoaded = function(value) {
	this.m_compLoad = value;
};

MPageComponent.prototype.setLookbackDays = function(value) {
	this.m_lookbackDays = value;
};

MPageComponent.prototype.setLookbackMenuItems = function(value) {
	this.m_lookBackMenuItems = value;
};

MPageComponent.prototype.setLookbackUnits = function(value) {
	this.m_lookbackUnits = value;
};

MPageComponent.prototype.setResultRangeDirection = function(value) {
	this.m_resultRangeDirection = value;
};
MPageComponent.prototype.setLookbackUnitTypeFlag = function(value) {
	this.m_lookbackUnitTypeFlag = value;
};

MPageComponent.prototype.setMedHistory = function( value) {
	this.m_medHistory = value;
};

MPageComponent.prototype.setMedRecAdmit = function(value) {
	this.m_medRecAdmit = value;
};

MPageComponent.prototype.setMedRecTransfer = function(value) {
	this.m_medRecTransfer = value;
};

MPageComponent.prototype.setMedRecCrossEncTx = function(value) {
	this.m_medRecCrossEncTx = value;
};

MPageComponent.prototype.setMedRecDischarge = function(value) {
	this.m_medRecDischarge = value;
};

/**
 * Sets the menu object that will be used for this component.  The actual menu object is not stored in the component
 * but is instead stored in the MP_MenuManager cache for Menu objects so it can be accessed outside of the component.
 * @param {Menu} menuObj The menu object that will be used when rendering this components menu
 */
MPageComponent.prototype.setMenu = function(menuObj) {
	//Store the id for this menu so we can fetch it in the getMenu function
	this.m_compMenuId = menuObj.getId();
	//Store the Menu object into the MenuManager cache of Menu objects
	MP_MenuManager.updateMenuObject(menuObj);
};

MPageComponent.prototype.setMenuItems = function(value) {
	this.m_menuItems = value;
};

MPageComponent.prototype.setMenuOptionNames = function(value) {
	if (value) {
		this.m_menuOptionNames = value;
	}
	else {
		this.m_menuOptionNames = [];
	}
};

MPageComponent.prototype.setMenuOptions = function(value) {
	if (value) {
		this.m_menuOptions = value;
	}
	else {
		this.m_menuOptions = [];
	}
};

MPageComponent.prototype.setMenuOptionText = function(itemName, text) {
	if (text) {
		this.m_menuOptions[itemName].text = text;
		var menuItem = _g(this.m_menuOptions[itemName].id);
		if (menuItem) {
			menuItem.innerHTML = text;
		}
	}
};

MPageComponent.prototype.setMPageName = function(value) {
	this.m_MPageName = value;
};

MPageComponent.prototype.setNewLink = function(value) {
	this.m_newLink = value;
};

MPageComponent.prototype.setPageGroupSequence = function(value) {
	this.m_pageGroupSeq = value;
};

MPageComponent.prototype.setPreferencesObj = function(value) {
	this.m_componentPreferences = value;
};

MPageComponent.prototype.setRenderStrategy = function(renderStrategy) {
	if (renderStrategy && RenderStrategy.prototype.isPrototypeOf(renderStrategy)) {
		renderStrategy.setComponentToRender(this);
		this.m_renderStrategy = renderStrategy;
	}
};

MPageComponent.prototype.setPlusAddEnabled = function(value) {
	this.m_isPlusAdd = value;
};

/**
 * Set the plus add custom indicator flag if the functionality tied to the plus add is custom or not.
 * @param {boolean} plusAddCustomInd Flag indicating whether the functionality tied to the plus add is custom or not.
 */
MPageComponent.prototype.setPlusAddCustomInd = function(plusAddCustomInd) {
	this.m_isPlusAddCustom = plusAddCustomInd;
};

/**
 * Set the refresh enabled boolean. This is used by workflow render strategy
 * to determine whether to draw an enabled component refresh button or not.
 * @param {boolean} refreshEnabledBool
 */
MPageComponent.prototype.setRefreshEnabled = function(refreshEnabledBool) {
	this.m_isRefreshEnabled = refreshEnabledBool;
};

MPageComponent.prototype.setReportId = function(value) {
	this.m_reportId = value;
};

MPageComponent.prototype.setReportMean = function(value) {
	this.m_reportMean = value;
};

MPageComponent.prototype.setResourceRequired = function(value) {
	this.m_resourceRequired = value;
};

MPageComponent.prototype.setRootComponentNode = function(value) {
	this.m_rootComponentNode = value;
};

MPageComponent.prototype.setScope = function(value) {
	this.m_scope = value;
};

MPageComponent.prototype.setScopeHTML = function(value) {
	this.m_ScopeHTML = value;
};

MPageComponent.prototype.setScrollingEnabled = function(value) {
	this.m_isScrollEnabled = value;
};

MPageComponent.prototype.setScrollNumber = function(value) {
	this.m_scrollNumber = value;
};

MPageComponent.prototype.setSectionContentNode = function(value) {
	this.m_sectionContentNode = value;
};

MPageComponent.prototype.setSelectedDataGroup = function(value) {
	this.m_selectedDataGroup = value;
};

MPageComponent.prototype.setSelectedTimeFrame = function(value) {
	this.m_selectedTimeFrame = value;
};

MPageComponent.prototype.setSequence = function(value) {
	this.m_sequence = value;
};

MPageComponent.prototype.setStyles = function(value) {
	this.m_styles = value;
};

MPageComponent.prototype.setSubLabel = function(value) {
	this.m_subLabel = value;
};

MPageComponent.prototype.setToggleStatus = function(toggleStatus) {
	if (typeof toggleStatus === "string") {
		this.m_toggleStatus = parseInt(toggleStatus, 10);
	}
	else if (typeof toggleStatus === "number") {
		this.m_toggleStatus = toggleStatus;
	}
};

/**
 * Sets if the component will respect the pregnancy onset as the default lookback when available
 * @param {Boolean} true if the onset will be respected, false otherwise
 */
MPageComponent.prototype.setPregnancyLookbackInd = function(value) {
	this.m_pregLookbackInd = value;
};

/**
 * Sets the Healthe Intent lookup key.
 * @param {String} Healthe Intent lookup key.
 */
MPageComponent.prototype.setHILookupKey = function(value) {
	this.m_hiLookupKey = value;
};

/**
 *Sets the Healthe Intent alias type for the component.
 * @param {String} Healthe Intent alias type.
 */
MPageComponent.prototype.setAliasType = function(value) {
	this.m_aliasType = value;
};

/**
 * Sets the Healthe Intent alias pool code for each component.
 * @param {Number} Healthe Intent alias pool code.
 */
MPageComponent.prototype.setAliasPoolCd = function(value) {
	this.m_aliasPoolCd = value;
};

/**
 * Sets the value for the indicator that determine whether to show data from external sources or not
 * @param {Boolean} True to show external data, false otherwise.
 */
MPageComponent.prototype.setExternalDataInd = function(value) {
	this.m_externalDataInd = value;
};

/**
 * Sets the value for the indicator that determine whether to show patient entered data or not
 * @param {Boolean} True to show patient entered data, false otherwise.
 */
MPageComponent.prototype.setPatientEnteredDataInd = function(value) {
	this.m_patEnteredDataInd = value;
};


/**
 * Sets the text of the Healthe Intent Test Service URI
 * @param {String} sets the test service URI.
 */
MPageComponent.prototype.setHITestUri = function(value) {
	this.m_hiTestUri = value.replace(/&#047;/g, '/');
};

/**
 * Sets whether the component is Contextual view compatible
 * @param  {boolean}  value [boolean to indicated whether the current component is Contextual view compatible]
 */
MPageComponent.prototype.setContextualViewCompatible = function(value) {
	this.m_isContextualViewCompatible = value;
};

/**
 * Sets the flag whether the component is added Contextual view
 * @param  {boolean}  value [flag whether the component is added Contextual view]
 */
MPageComponent.prototype.setAddedToContextualView = function(value) {
	this.m_isAddedToContextualView = value;
};

/**
 * Sets the instance of MPageUI.Button for the contextual view control in actual component 
 * @param  {MPageUI.Button}  value Instance of MPageUI.Button for the contextual view control in actual component 
 */
MPageComponent.prototype.setContextualViewControl = function(value) {
	this.m_contextualViewControl = value;
};

/**
 * Sets the flag whether the component can have the control to launch the Contextual view
 * @param  {boolean}  value The flag whether the component can have the control to launch the Contextual view
 */
MPageComponent.prototype.setHasContextualViewControl = function(value) {
	this.m_canHaveContextualViewControl = value;
};

/**
 * Sets the instance of MPageUI.Button for the contextual view control in placeholder view
 * @param  {MPageUI.Button}  value Instance of MPageUI.Button for the contextual view control in in placeholder view.
 */
MPageComponent.prototype.setContextualViewControlInPlaceholderView = function(value) {
	this.m_contextualViewControlInPlaceholderView = value;
};
/**
 * Sets the root node of the component as PlaceholderView
 * @param {Object} obj The dom node representing the placeholder view of component
 */
MPageComponent.prototype.setRootPlaceholderComponentNode = function(obj) {
	this.m_rootPlaceholderComponentNode = obj;
};

/**
 * Sets the instance of PlaceholderView
 * @param {Object} obj An Instance of PlaceholderView
 */
MPageComponent.prototype.setPlaceholderView = function(obj) {
	this.m_placeholderView = obj;
};

/**
 * Sets the sequence of the component in the Contextual View
 * @param {Number} value The sequence of the component in Contextual view.
 */
MPageComponent.prototype.setSequenceInContextualView = function(value) {
	this.m_sequenceInContextualView = value;
};


/* Miscellaneous - A variety of functions which are used when rendering the component */

/**
 * This function is used to generate the HTML mark-up for a component when no results have been retrieved for the component.
 * @return {string} The HTML mark-up that will be used as the component display
 */
MPageComponent.prototype.generateNoDataFoundHTML = function() {
	var i18nCore = i18n.discernabu;
	return ("<h3 class='info-hd'><span class='res-normal'>" + i18nCore.NO_RESULTS_FOUND + "</span></h3><span class='res-none'>" + i18nCore.NO_RESULTS_FOUND + "</span>");
};
/**
 * This function is used to generate the HTML mark-up for a component when a script failure has occurred.
 * @return {string} The HTML mark-up that will be used as the component display
 */
MPageComponent.prototype.generateScriptFailureHTML = function() {
	var i18nCore = i18n.discernabu;
	var nameSpace = this.getStyles()
		.getNameSpace() + "-";
	//Create the HTML that will be returned to the component
	return "<h3 class='info-hd'><span class='res-normal'>" + i18nCore.ERROR_RETREIVING_DATA + "</span></h3><dl class='" + nameSpace + "info error-message error-text'><dd><span>" + i18nCore.ERROR_RETREIVING_DATA + "</span></dd></dl>";
};
/**
 * Applies a template (class) to the sec-content element, allowing the component to inherit the specified template and its styles
 * @param {string} template : The template (class) to apply to the component
 */
MPageComponent.prototype.applyTemplate = function(template) {
	var contentNode = this.getSectionContentNode();
	Util.Style.acss(contentNode, template);
};

MPageComponent.prototype.createAccordionContent = function() {
	return this.m_renderStrategy.createComponentFilter();
};

MPageComponent.prototype.createAccordionControls = function() {
	var i18nCore = i18n.discernabu;
	var mnuCompId = this.getComponentId();
	var pageControl = $("<div></div>")
		.addClass("lb-pg-hd lb-page-ctrl");

	//Create the filter controls
	var setDefaultControl = $("<a></a>")
		.addClass("setDefault")
		.html(i18nCore.SET_AS_DEFAULT);
	var clearAllControl = $("<a></a>")
		.addClass("resetAll")
		.html(i18nCore.RESET_ALL);

	// Attach the click events
	setDefaultControl.click(function() {
		MP_Core.AppUserPreferenceManager.SaveCompPreferences(mnuCompId);
	});
	clearAllControl.click(function() {
		MP_Core.AppUserPreferenceManager.ClearCompPreferences(mnuCompId);
	});
	pageControl.append(setDefaultControl);
	pageControl.append(clearAllControl);

	return pageControl;
};

MPageComponent.prototype.createMenu = function() {
	var arr = this.m_menuOptionNames;
	var l = arr.length;
	var actionSec = _g("optsMenuActions" + this.m_componentId);
	if (actionSec) {
		if (actionSec.hasChildNodes()) {
			actionSec.innerHTML = "";
		}

		var d = Util.ce('div');
		for (var i = 0; i < l; i++) {
			var optClass = 'opts-menu-item';
			var curOpt = this.m_menuOptions[arr[i]];
			if (curOpt.ditherOnLoad) {
				optClass += ' opts-menu-item-dthr';
			}

			var t = Util.cep("div", {
				id: curOpt.id,
				className: optClass
			});
			t.innerHTML = curOpt.text;
			if (curOpt.evtType && typeof curOpt.fn === 'function') {
				Util.addEvent(t, curOpt.evtType, curOpt.fn);
			}
			d.appendChild(t);
		}

		if (l > 0) {
			var personalizeSec = _g("optsMenupersonalize" + this.m_componentId);
			if (personalizeSec) {
				Util.Style.acss(personalizeSec, "opts-personalize-sec-divider");
			}
		}
		actionSec.appendChild(d);
	}
};

/**
 * This function is used to parse the various fields of a bedrock component filter.  The objects created from the
 * parsing are returned to the calling function so the application of the filter values can be made.
 * @param {object}	compFilter : The JSON object for a component filter containing all of the necessary information
 * for the specific component filer.
 * @return {[MPageGroupValue]} An array of MPageGroupValue objects.
 */
MPageComponent.prototype.getFilterValues = function(compFilter) {
	var value = null;
	var valueArr = [];
	var valueCnt = compFilter.VALS.length;
	var valueObj = null;
	var x = 0;
	for (x = 0; x < valueCnt; x++) {
		valueObj = compFilter.VALS[x];
		value = new MPageGroupValue();
		value.setId(valueObj.PE_ID); //PE_ID is shorthand for Parent Entity ID
		value.setName(valueObj.PE_NM); //PE_NM is shorthand for Parent Entity Name
		value.setMeaning(valueObj.CDF_MN); //CDF_MN is shorthand for CDF Meaning
		value.setDescription(valueObj.FTXT); //FTXT is shorthand for Freetext Description
		value.setSequence(valueObj.G_SQ); //G_SQ is shorthand for Group Sequence
		value.setValueSequence(valueObj.V_SQ); //V_SQ is shorthand for Value Sequence 
		value.setValueTypeFlag(valueObj.V_TYP); //V_TYP is shorthand for Value Type Flag 
		value.setQualifierFlag(valueObj.Q_FLG); //Q_FLG is shorthand for Qualifier Flag
		valueArr.push(value);
	}
	return valueArr;
};

/**
 * Initializes hover functionality for all elements within a specified node that follow a specific pattern:
 * A DL element of class "result-info" immediately followed by an element of class "result-details"
 * @param {node} baseNode : The element to search within (The "scope" of the search)
 */
MPageComponent.prototype.initHovers = function(baseNode) {
	// Obtain all results with the "result-info" class in the base element
	var results = Util.Style.g("result-info", baseNode, "DL");
	// Initialize hovers for each result that follows the pattern
	for (var i = results.length; i--;) {
		var curResult = results[i];
		// Obtain the element that immediately follows the result in the DOM
		var nextElement = Util.gns(curResult);
		if (nextElement) {
			// If this next element has a "result-details" class, call hs() to set up the hover
			if (Util.Style.ccss(nextElement, "result-details")) {
				hs(curResult, nextElement, this);
			}
		}
	}
};

/**
 * This function is used to process the Category Type Assignment information from a component filter.
 * @param {object} compFilter This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadCategoryTypeAssignments = function(compFilter) {
	var ctaArr = null;
	var ctaCnt = 0;
	var ctaVal = null;
	var curSeq = -1;
	var grouper = null;
	var group = null;
	var x = 0;
	ctaArr = this.getFilterValues(compFilter);
	ctaCnt = ctaArr.length;
	grouper = new MPageGrouper();
	for (x = 0; x < ctaCnt; x++) {
		ctaVal = ctaArr[x];
		if (ctaVal.getSequence() != curSeq) {
			group = new MPageCodeValueGroup();
			curSeq = ctaVal.getSequence();
			group.setSequence(curSeq);
			grouper.addGroup(group);
		}
		group.addCode(ctaVal.getId());
	}
	this.addGroup(grouper);
};

/**
 * This function is used to process the Clinical Event Grouper information from a component filter.
 * @param {object} compFilter This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadCEGroupers = function(compFilter) {
	var ceArr = null;
	var ceCnt = 0;
	var curSeq = -1;
	var desc = "";
	var group = null;
	var grouper = null;
	var groupArr = null;
	var groupCnt = 0;
	var id = 0;
	var value = null;
	var x = 0;
	var y = 0;
	//Understood that these grouped results have a title and then a list of event codes associated
	//to them.  The identifier for each group is that the group sequence is the same for the results.
	//Only one field will have a free text description, the other results will be event codes

	//because bedrock is nice enough to store the grouping of event codes seperate from a flat list of
	//the codes, overwrite the existing group with the new MPageGrouper
	groupArr = this.getGroups();
	if (groupArr && groupArr.length !== 0) {
		groupCnt = groupArr.length;
		for (x = 0; x < groupCnt; x++) {
			group = groupArr[x];
			if (group.getSequence() == compFilter.F_SQ) { //F_SQ is shorthand for Filter Sequence
				ceArr = this.getFilterValues(compFilter);
				ceCnt = ceArr.length;
				grouper = new MPageGrouper();
				grouper.setGroupId(group.getGroupId());
				//for alignment with sequencing of groups
				grouper.setGroupName(group.getGroupName());
				for (y = 0; y < ceCnt; y++) {
					value = ceArr[y];
					if (value.getSequence() != curSeq) {
						curSeq = value.getSequence();
						group = new MPageEventCodeGroup();
						group.setSequence(curSeq);
						grouper.addGroup(group);
					}
					id = value.getId();
					desc = value.getDescription();
					if (id > 0) {
						group.addEventCode(id);
					}
					if (desc !== "") {
						group.setGroupName(desc);
					}
				}
				groupArr[x] = grouper;
			}
		}
	}
};

/**
 * This function is used to process the component color information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadComponentColor = function(compFilter) {
	var colorArr = null;
	var color = null;

	//Make sure the color hasn't already been set by the user preferences
	if (!this.getCompColor()) {
		colorArr = this.getFilterValues(compFilter);
		//Only use the first color returned
		color = colorArr[0].m_meaning.replace("_", "")
			.toLowerCase();
		this.setCompColor(color);
	}
};

/**
 * This function is used to process the Event Code information from a component filter.  This function also handles sequenced Event
 * Code filters.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadEventCodes = function(compFilter) {
	var compGroups = null;
	var compGroupCnt = 0;
	var ecArr = [];
	var ecCnt = 0;
	var group = null;
	var newGroup = false;
	var x = 0;

	//Locate existing group with the same id
	compGroups = this.getGroups();
	compGroupCnt = compGroups.length;
	for (x = 0; x < compGroupCnt; x++) {
		if (compGroups[x].getSequence() == compFilter.F_SQ) { //F_SQ is shorthand for Filter Sequence
			group = compGroups[x];
			break;
		}
	}

	//Check to see if the existing group is already available.
	if (group) {
		if (group.isSequenced()) {
			//If the group is already sequenced we should be done with this set of event codes
			return;
		}
		else {
			//If the group is available and not already sequenced the we are now examining the
			//EVENT_SEQ and need to clear the previous set of event codes
			group.setEventCodes(null);
		}
	}
	else {
		//No group exists for this component filter so create one.
		group = new MPageEventCodeGroup();
		group.setGroupId(compFilter.F_ID); //F_ID is shorthand for Filter Id(br_datamart_filter_id)
		group.setGroupName(compFilter.F_MN); //F_MN is shorthand for Filter Mean
		group.setSequence(compFilter.F_SQ); //F_SQ is shorthand for Filter Sequence
		//Set a flag indicating that we are creating a new group
		newGroup = true;
	}

	//Load the event codes
	group.setSequenced(compFilter.FC_MN === "EVENT_SEQ" ? true : false); //FC_MN is shorthand for Filter Category Mean
	ecArr = this.getFilterValues(compFilter);
	ecCnt = ecArr.length;
	for (x = 0; x < ecCnt; x++) {
		group.addEventCode(ecArr[x].getId());
	}

	//Store the group in the component
	if (newGroup) {
		this.addGroup(group);
	}
};

/**
 * This function is used to process the Event Set information from a component filter.  This function also handles sequenced Event
 * Set filters.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadEventSets = function(compFilter) {
	var compGroups = null;
	var compGroupCnt = 0;
	var esArr = null;
	var esCnt = 0;
	var esValue = null;
	var group = null;
	var groupIndx = 0;
	var isMultiValue = false;
	var newGroup = null;
	var seqGroup = null;
	var tempAr = [];
	var tempMap = [];
	var x = 0;
	//Locate existing group with the same id
	compGroups = this.getGroups();
	compGroupCnt = compGroups.length;
	for (x = 0; x < compGroupCnt; x++) {
		if (compGroups[x].getSequence() == compFilter.F_SQ) { //F_SQ is shorthand for Filter Sequence
			group = compGroups[x];
			groupIndx = x;
			break;
		}
	}

	//Check to see if the existing group is already available
	if (group) {
		if (MPageSequenceGroup.prototype.isPrototypeOf(group) || group.isSequenced()) {
			//If the group is already sequenced we should be done with this set of event sets
			return;
		}
		else {
			//If the group is available and not already sequenced the we are now examining the
			//EVENT_SET_SEQ and need to clear the previous set of event codes
			group.setEventSets(null);
		}
	}
	else {
		//No group exists for this component filter so create one
		group = new MPageEventSetGroup();
		group.setGroupId(compFilter.F_ID); //F_ID is shorthand for Filter Id(br_datamart_filter_id)
		group.setGroupName(compFilter.F_MN); //F_MN is shorthand for Filter Mean
		group.setSequence(compFilter.F_SQ); //F_SQ is shorthand for Filter Sequence
		newGroup = true;
	}

	//Load the event sets
	group.setSequenced(compFilter.FC_MN === "EVENT_SET_SEQ" ? true : false); //FC_MN is shorthand for Filter Category Mean
	esArr = this.getFilterValues(compFilter);
	esCnt = esArr.length;
	for (x = 0; x < esCnt; x++) {
		esValue = esArr[x];
		group.addEventSet(esValue.getId());
		tempAr.push(esValue.getId());
		//The isMultiValue is special logic used when loading Vitals sequencing on paired results.
		if (esValue.getName() != "CODE_VALUE") {
			isMultiValue = true;
		}
		MP_Util.AddItemToMapArray(tempMap, esValue.getName(), esValue.getId());
	}
	//The isMultiValue is special logic used when loading Vitals sequencing on paired results.
	if (isMultiValue) {
		seqGroup = new MPageSequenceGroup();
		seqGroup.setMultiValue(isMultiValue);
		seqGroup.setItems(tempAr);
		seqGroup.setMapItems(tempMap);
		seqGroup.setSequence(group.getSequence());
		seqGroup.setGroupId(group.getGroupId());
		seqGroup.setGroupName(group.getGroupName());
		if (newGroup) {
			this.addGroup(seqGroup);
		}
		else {
			compGroups[groupIndx] = seqGroup;
		}
		return;
	}

	//Store the group in the component
	if (newGroup) {
		this.addGroup(group);
	}
};

/**
 * This function is used to process the iView Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadIViewOptions = function(compFilter) {
	var iViewArr = null;
	var iViewCnt = 0;
	var iViewItem = null;
	var menuItem = null;
	var x = 0;
	iViewArr = this.getFilterValues(compFilter);
	iViewCnt = iViewArr.length;
	for (x = 0; x < iViewCnt; x++) {
		iViewItem = iViewArr[x];
		menuItem = new MP_Core.MenuItem();
		menuItem.setName(iViewItem.getName());
		menuItem.setDescription(iViewItem.getDescription());
		menuItem.setId(iViewItem.getId());
		menuItem.setValSequence(iViewItem.getValueSequence());
		menuItem.setValTypeFlag(iViewItem.getValueTypeFlag());
		this.addIViewMenuItem(menuItem);
	}
};

/**
 * This function loads the specialized filter mappings for a component if required.
 * @return {null}
 */
MPageComponent.prototype.loadFilterMappings = function() {
	//Do nothing:  The component will implement this function if necessary
};

/**
 * This function loads the default filter mappings used for all components.  These filter mappings will attempt to handle the parsing
 * and processing of a variety of standard filter types.  If a component needs to handle these types of component filters in a
 * specialized way the component should override the specific filter and handle the processing of the data on its own.
 * @return {null}
 */
MPageComponent.prototype.loadDefaultFilterMappings = function() {
	//Create filter mappings objects complete with any fields necessary
	this.addFilterMappingObject("EVENT", {
		setFunction: this.loadEventCodes,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("EVENT_SET", {
		setFunction: this.loadEventSets,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("PRIM_EVENT_SET", {
		setFunction: this.loadEventSets,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("COLOR_THEME_CDS", {
		setFunction: this.loadComponentColor,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("LOOK_BACK", {
		setFunction: this.loadLookbackOptions,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("PF_MULTI_SELECT", {
		setFunction: this.loadPowerFormOptions,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("IVIEW_SELECT", {
		setFunction: this.loadIViewOptions,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("CAT_TYPE_ASSIGN", {
		setFunction: this.loadCategoryTypeAssignments,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("CE_GROUP", {
		setFunction: this.loadCEGroupers,
		type: "DEFAULT_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("EVENT_SEQ", {
		setFunction: this.loadEventCodes,
		type: "DEFAULT_SEQUENCED_FILTER",
		field: "ALL"
	});
	this.addFilterMappingObject("EVENT_SET_SEQ", {
		setFunction: this.loadEventSets,
		type: "DEFAULT_SEQUENCED_FILTER",
		field: "ALL"
	});
};

/**
 * This function is used to process the Lookback Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadLookbackOptions = function(compFilter) {
	var lbArr = null;
	var lbCnt = 0;
	var lookback = null;
	var menuItem = null;
	var x = 0;
	lbArr = this.getFilterValues(compFilter);
	lbCnt = lbArr.length;
	for (x = 0; x < lbCnt; x++) {
		lookback = lbArr[x];
		menuItem = new ResultRangeSelection();
		menuItem.setUnits(parseInt(lookback.getDescription(),10));
		menuItem.setScope(this.getScope());
		switch (lookback.getMeaning()
			.toUpperCase()) {
			case "HOURS":
				menuItem.setType(1);
				break;
			case "DAYS":
				menuItem.setType(2);
				break;
			case "WEEKS":
				menuItem.setType(3);
				break;
			case "MONTHS":
				menuItem.setType(4);
				break;
			case "YEARS":
				menuItem.setType(5);
				break;
		}
		menuItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(menuItem));
		this.addLookbackMenuItem(menuItem);
	}
	//Add the default value to the menu
	menuItem = new ResultRangeSelection();
	menuItem.setUnits(this.getBrLookbackUnits());
	menuItem.setScope(this.getScope());
	menuItem.setType(this.getBrLookbackUnitTypeFlag());
	menuItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(menuItem));
	this.addLookbackMenuItem(menuItem);
};

/**
 * This function is utilized to load the individual filter mappings for a component.  These filter mappings are either defined as a
 * default or defined within the individual implementation of a component.
 * @param {object} mappedFilter : The filter mapping object that will be used to load the compFilter information for the component.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 */
MPageComponent.prototype.loadMappedSettings = function(mappedFilter, compFilter) {
	var field = null;
	var type = null;
	var setFunction = null;
	var valueArr = [];
	var valueCnt = 0;
	var value = null;
	var setValues = [];
	var x = 0;
	valueArr = this.getFilterValues(compFilter);
	valueCnt = valueArr.length;

	//Check to make sure all of the necessary elements are established for the filter mapping
	field = mappedFilter.field;
	type = mappedFilter.type;
	setFunction = mappedFilter.setFunction;
	if (!setFunction || !field || !type) {
		return false;
	}

	//Prepare the parameters to pass into the filter setFunction
	for (x = 0; x < valueCnt; x++) {
		value = valueArr[x];
		switch (field.toUpperCase()) {
			case "FTXT": //FTXT is shorthand for Freetext Description
				setValues.push(value.getDescription());
				break;
			case "PE_ID": //PE_ID is shorthand for Parent Entity Id
				setValues.push(value.getId());
				break;
			case "NOMEN":
				setValues.push({
					nomen_id: value.getId(),
					seq: value.getValueSequence(),
					qual_flag: value.getQualifierFlag()
				});
				break;
			case "V_SQ": //V_SQ is shorthand for Value Sequence
				setValues.push({
					id: value.getId(),
					seq: value.getValueSequence()
				});
				break;
			case "LOOK_BACK":
				setValues.push({
					value: value.getDescription(),
					units: value.getMeaning()
				});
				break;
			default:
				break;
		}
	}

	//Make the call into the setFunction with the appropriate parameters.
	switch (type.toUpperCase()) {
		case "ARRAY":
		case "NOMEN":
		case "VALUE_SEQ":
			//Using the call function will pass the setValues in as one array of values
			setFunction.call(this, setValues);
			break;
		case "STRING":
		case "NUMBER":
		case "OBJECT":
			//using the apply function will pass the array setValues in as multiple parameters to the setFunction
			setFunction.apply(this, setValues);
			break;
		case "BOOLEAN":
			setFunction.call(this, (setValues[0] === "1") ? true : false);
			break;
		default:
			//Call the function that the component developer has defined to set the value.  This is generic and what is done with the
			//compFilter is up to the component developer.
			setFunction.call(this, compFilter);
			break;
	}
};

/**
 * This function is used to process the PowerForm Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @return {null}
 */
MPageComponent.prototype.loadPowerFormOptions = function(compFilter) {
	var menuItem = null;
	var pfArr = null;
	var pfCnt = 0;
	var powerForm = null;
	var x = 0;
	pfArr = this.getFilterValues(compFilter);
	pfCnt = pfArr.length;
	for (x = 0; x < pfCnt; x++) {
		powerForm = pfArr[x];
		menuItem = new MP_Core.MenuItem();
		menuItem.setName(powerForm.getName());
		menuItem.setDescription(powerForm.getDescription());
		menuItem.setId(powerForm.getId());
		this.addMenuItem(menuItem);
	}
};

MPageComponent.prototype.openTab = function() {
	alert("ERROR: openTab has not been implemented within the component");
};

/**
 * The fireDiagnosisAddedEvent function should be called by
 * the diagnosis-o1, consolidated-problems-o1 and
 * consolidated-problems-o2 components when a new diagnosis is
 * added. The listeners are intended to be structured documentation
 * components.
 */
MPageComponent.prototype.fireDiagnosisAddedEvent = function() {
	CERN_EventListener.fireEvent(this, this, EventListener.EVENT_DIAGNOSIS_ADDED, null);
};

/**
 * The listenForDiagnosisEvents function should be called by components
 * that want to handle the diagnosis added event. It is intended to be called
 * in the documentation-base component so that structured documentation components
 * can completely refresh. This function will cause the caller to listen for events
 * regarding diagnoses from diagnosis, consolidated-problem o1 and o2 and
 * components that use the entity framework.
 */
MPageComponent.prototype.listenForDiagnosisEvents = function() {
	CERN_EventListener.addListener(this, EventListener.EVENT_DIAGNOSIS_ADDED, this.onDiagnosisAdded, this);
	CERN_EventListener.addListener(this, EventListener.EVENT_CONDITIONS_UPDATE, this.onDiagnosisAdded, this);
};

/**
 * The onDiagnosisAdded should be implemented in any class that calls
 * handleDiagnosisAddedEvents()
 */
MPageComponent.prototype.onDiagnosisAdded = function() {
	//
	// this is intentionally a stub and should be implemented by the caller of handleDiagnosesAddedEvents()
	//
};


/**
 * This function is used to refresh the contents of a component.
 */
MPageComponent.prototype.refreshComponent = function() {
	if (this.isDisplayable()) {
		//If we are working with a workflow component clear any flags that may have been set
		if (this.getStyles()
			.getComponentType() === CERN_COMPONENT_TYPE_WORKFLOW) {
			CERN_EventListener.fireEvent(this, this, EventListener.EVENT_CRITICAL_UPDATE, {
				"critical": null
			});
			CERN_EventListener.fireEvent(this, this, EventListener.EVENT_COUNT_UPDATE, {
				"count": null
			});
			CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
				"error": null
			});
		}

		this.startComponentDataRetrieval();
	}
};

MPageComponent.prototype.removeMenuDither = function(itemName) {
	var menuItem = _g(this.m_menuOptions[itemName].id);
	if (menuItem) {
		Util.Style.rcss(menuItem, "opts-menu-item-dthr");
		this.m_menuOptions[itemName].isMenuDithered = false;
	}
};

MPageComponent.prototype.renderAccordion = function(component) {};

/**
 * This function will be used to resize the component based on the type.
 */
MPageComponent.prototype.resizeComponent = function() {
	var calcHeight = "";
	var compHeight = 0;
	var compDOMObj = null;
	var compType = this.getStyles()
		.getComponentType();
	var container = null;
	var contentBodyHeight = 0;
	var contentBodyObj = null;
	var miscHeight = 20;
	var viewHeight = 0;

	if (compType === CERN_COMPONENT_TYPE_WORKFLOW) {
		container = $("#vwpBody");
		if (!container.length) {
			return;
		}
		viewHeight = container.height();

		//Make sure component is rendered
		compDOMObj = $("#" + this.getStyles()
			.getId());
		if (!compDOMObj.length) {
			return;
		}

		//Get the overall height of the content-body section if available at this time
		contentBodyObj = compDOMObj.find(".content-body");
		if (contentBodyObj.length) {
			//Get the overall component height
			compHeight = compDOMObj.height();
			//Get the height of the content-body
			contentBodyHeight = contentBodyObj.height();
			//Calculate the estimated max height of the components content-body element
			calcHeight = (viewHeight - (compHeight - contentBodyHeight + miscHeight)) + "px";
			//apply the max-height settings
			contentBodyObj.css("max-height", calcHeight)
				.css("overflow-y", "auto");
		}
	}
	//If the component has a component table, call the table's post-resize function
	if (this.getComponentTable()) {
		this.getComponentTable()
			.updateAfterResize();
	}

	//If the component has a flowsheet table, call the table's post-resize function
	if (this.getFlowsheetTable()) {
		this.getFlowsheetTable()
			.updateAfterResize();
	}
};

MPageComponent.prototype.RetrieveRequiredResources = function() {
	alert("ERROR: RetrieveRequiredResources has not been implemented within the component");
};

MPageComponent.prototype.sortGrouperArrayByLabel = function() {
	if (!this.m_grouper_arr) {
		this.m_grouper_arr = [];
	}

	this.m_grouper_arr.sort(function(a, b) {
		if (a.label && b.label) {
			var aLabel = a.label.toUpperCase();
			var bLabel = b.label.toUpperCase();
			if (aLabel < bLabel) {
				return -1;
			}
			else {
				if (aLabel === bLabel) {
					return 0;
				}
				else {
					return 1;
				}
			}
		}
		else if (a.catLabel && b.catLabel) {
			var aCatLabel = a.catLabel.toUpperCase();
			var bCatLabel = b.catLabel.toUpperCase();
			if (aCatLabel < bCatLabel) {
				return -1;
			}
			else {
				if (aCatLabel === bCatLabel) {
					return 0;
				}
				else {
					return 1;
				}
			}
		}
		else if (a.label || a.catLabel) {
			return 1;
		}
		else {
			return -1;
		}
	});

};

MPageComponent.prototype.updateLabel = function(value) {
	this.m_label = value;
	var rootComponentNode = this.getRootComponentNode();
	var secHead = Util.gc(rootComponentNode, 0);
	var secTitle = Util.gc(Util.Style.g('sec-title', secHead, 'span')[0], 0);
	var anchor = _gbt("a", secTitle);
	if (anchor[0]) { //If secTitle is a link update the link
		anchor[0].innerHTML = value;
	}
	else { //otherwise update just the title
		secTitle.innerHTML = value;
	}
};

MPageComponent.prototype.updateSubLabel = function(value) {
	//Update the Label sub header
	this.m_subLabel = value;
	var rootComponentNode = this.getRootComponentNode();
	var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
	totalCount[0].innerHTML = this.m_subLabel;
};

/* Core - These are the core functions called when instantiating, initializing, rendering and
 * finalizing component.  If you are adding or modifying these functions in any way be sure you
 * understand the full implications of your actions as ALL components and MPages utilize these functions */

/**
 * Perform any special setup needed for the components before being rendered.  The core functionality saves the criterion
 * object in the component and loads the default filter mappings for all components.
 * @param {Criterion} criterion A criterion object which will be used when performing component actions.
 */
MPageComponent.prototype.initializeComponent = function(criterion) {

	//Set the criterion object for the component
	this.setCriterion(criterion);

	//Load the base component filter mappings and any other mappings the component may need.
	this.loadDefaultFilterMappings();
	this.loadFilterMappings();

	//Perform any other initialization that needs to be done for the component.
};

/**
 * This function is used to load all of the component's settings.  The first part of this process loads all of the architectural
 * settings like the expand/collapse state, component color etc...  First the default and Bedrock defined settings are applied.
 * Once those have been set the User's preferences are then used to override any default settings that have been applied.  The
 * second part of the process sets the non-architectural settings like event set and event code settings defined on a per component
 * basis.  This process uses filter mappings to apply the setting in various ways.  The filter mappings can come from the component
 * definition or from an older switch case in the bedrock.js file.
 * @param {object} compSettings : An object which contains all of the settings that will be applied to a specific component.
 */
MPageComponent.prototype.loadComponentSettings = function(compSettings) {
	var compFilter = null;
	var filterCnt = 0;
	var filterMappingObj = null;
	var mappedFilter = null;
	var oldBRSetPrefFunc = null;
	var prefManager = MP_Core.AppUserPreferenceManager;
	var userPrefs = null;
	var x = 0;

	//Load the default settings
	this.setComponentId(compSettings.F_ID); //F_ID is shorthand for Filter Id (br_datamart_filter_id)
	this.setReportId(compSettings.R_ID); //R_ID is shorthand for Report Id (br_datamart_report_id)
	this.setReportMean(compSettings.R_MN); //R_MN is shorthand for Report Mean
	this.setLabel(compSettings.LBL);
	this.setMenuOptionNames(null);
	this.setMenuOptions(null);
	this.setLink(compSettings.LNK);
	this.setScrollNumber(compSettings.SCR_NM); //SCR_NM is shorthand for Scroll Number
	this.setScrollingEnabled(compSettings.SCR_EN); //SCR_EN is shorthand for Scroll Enabled 
	this.setPlusAddEnabled((compSettings.PLS_AD === 1 ? true : false));
	this.setDateFormat(compSettings.DT_DSP); //DT_DSP is shorthand for Date Display Flag
	this.setBrLookbackUnits(compSettings.LB_UNT || 0); //LB_UNT is shorthand for Lookback Units
	this.setBrLookbackUnitTypeFlag(compSettings.LB_TYP || 0); //LB_TYP is shorthand for Lookback Type Flag
	//The following bedrock settings are not applied if they have already been set at the component level
	this.setLookbackDays(this.getLookbackDays() || 0);
	this.setLookbackUnits(this.getLookbackUnits() || compSettings.LB_UNT || 0); //LB_UNT is shorthand for Lookback Units
	this.setLookbackUnitTypeFlag(this.getLookbackUnitTypeFlag() || compSettings.LB_TYP || 0); //LB_TYP is shorthand for Lookback Type Flag
	this.setScope(this.getScope() || compSettings.SCP); //SCP is shorthand for Scope

	//Retrieve the user level preferences for this component
	userPrefs = prefManager.GetComponentById(compSettings.F_ID); //F_ID is shorthand for Filter Id (br_datamart_filter_id)
	//Load the user level settings if available
	if (userPrefs) {
		this.setIsInfoButtonEnabled(userPrefs.IsInfoButtonEnabled);
		this.setExpanded(userPrefs.expanded);
		this.setColumn(userPrefs.col_seq);
		this.setSequence(userPrefs.row_seq);
		this.setPageGroupSequence(userPrefs.group_seq);
		this.setGrouperFilterLabel(userPrefs.grouperFilterLabel || "");
		this.setGrouperFilterCatalogCodes(userPrefs.grouperFilterCatalogCodes || null);
		this.setGrouperFilterCatLabel(userPrefs.grouperFilterCatLabel || "");
		this.setGrouperFilterCriteria(userPrefs.grouperFilterCriteria || null);
		this.setSelectedTimeFrame(userPrefs.selectedTimeFrame || null);
		this.setSelectedDataGroup(userPrefs.selectedDataGroup || null);
		this.setPreferencesObj(userPrefs.preferencesObj || null);
		if (userPrefs.compThemeColor) {
			this.setCompColor(userPrefs.compThemeColor);
		}
		//Set the component toggle status.  If defined as 'Required' in bedrock, override the users prefs.
		//0 - off, 1 - on, 2 - required
		if (userPrefs.toggleStatus !== "undefined" && userPrefs.toggleStatus !== null) {
			if (compSettings.TS !== 2) { //TS is shorthand for Toggle Status
				this.setToggleStatus(userPrefs.toggleStatus);
			}
			else {
				this.setToggleStatus(compSettings.TS); //TS is shorthand for Toggle Status
			}
		}
		else {
			this.setToggleStatus(compSettings.TS); //TS is shorthand for Toggle Status
		}
		//Check for contextual view preferences. 
		if (typeof userPrefs.preferencesObj !== "undefined" && userPrefs.preferencesObj !== null) {			
			if (typeof userPrefs.preferencesObj.contextualViewPrefs !== "undefined" && userPrefs.preferencesObj.contextualViewPrefs !==null){
				this.setAddedToContextualView(userPrefs.preferencesObj.contextualViewPrefs.isAddedToContextualView);			
				this.setSequenceInContextualView(userPrefs.preferencesObj.contextualViewPrefs.row_seq);
			}
		}
	}
	else {
		//No user settings for this component so load client level settings
		this.setExpanded(compSettings.EXP); //EXP is shorthand for Expanded
		this.setColumn(compSettings.C_SQ); //C_SQ is shorthand for Column Sequence
		this.setSequence(compSettings.R_SQ); //R_SQ is shorthand for Row Sequence
		this.setPageGroupSequence(compSettings.G_SQ); //G_SQ is shorthand for Group Sequence
		this.setCompColor(compSettings.THM); //THM is shorthand for Theme
		this.setToggleStatus(compSettings.TS); //TS is shorthand for Toggle Status
	}

	//Load all of the non-standard component settings
	filterMappingObj = this.getFilterMappingsObj();
	filterCnt = compSettings.FILT.length;
	for (x = 0; x < filterCnt; x++) {
		compFilter = compSettings.FILT[x];

		//Check for component defined filters
		mappedFilter = filterMappingObj[compFilter.F_MN]; //F_MN is shorthand for Fitler Mean
		if (mappedFilter) {
			//Call the loadMappedSettings function to load the settings
			this.loadMappedSettings(mappedFilter, compFilter);
			continue;
		}
		else {
			//Attempt to check the older bedrock filter loading
			oldBRSetPrefFunc = MP_Bedrock.MPage.Component.getComponentFilterFuncsPassthrough(this.getStyles()
				.getNameSpace(), compSettings.R_MN); //R_MN is shorthand for Report Mean
			if (oldBRSetPrefFunc(this, compFilter.F_MN, this.getFilterValues(compFilter))) { //F_MN is shorthand for Filter Mean
				continue;
			}

			//Check the default mappings if there were no custom mappings
			mappedFilter = filterMappingObj[compFilter.FC_MN]; //FC_MN is shorthand for Filter Category Mean
			if (mappedFilter) {
				//Call the appropriate function of the mapped object
				mappedFilter.setFunction.call(this, compFilter);
				continue;
			}
		}
	}
};

/**
 * This function is used to create the component menu
 */
MPageComponent.prototype.createMainMenu = function() {
	if (this.isDisplayable()) {
		var compId = "mainCompMenu" + this.getStyles()
			.getId();
		var compMenu = new Menu(compId);
		compMenu.setIsRootMenu(true);
		compMenu.setAnchorElementId(compId);
		compMenu.setAnchorActiveClass("opts-menu-open");
		compMenu.setTypeClass("menu-wrkflw-comp-menu");
		compMenu.setAnchorConnectionCorner(["bottom", "right"]);
		compMenu.setContentConnectionCorner(["top", "right"]);
		compMenu.setContentParentId(this.getStyles()
			.getId());

		//Set this components menu which will also add it to the MenuManager
		this.setMenu(compMenu);
	}
};

/**
 * This function is used to setup any display filters that a component might have.  For instance the Growth Chart
 * component is only valid for individuals younger than the age of 20 yrs, so it should not display when the
 * patient is older than that age.
 */
MPageComponent.prototype.loadDisplayFilters = function() {
	//should be implemented at the component level for setting up display filters.
};

/**
 * This function is used to begin the data retrieval process.  It determines if the component should attempt to retrieve its
 * required data or if it requires some additional resource before it can start the data retrieval process.
 */
MPageComponent.prototype.startComponentDataRetrieval = function() {
	if (this.isResourceRequired()) {
		//This component requires data from a shared resource before it can start the data retrieval process.
		this.RetrieveRequiredResources();
	}
	else {
		//Make the necessary calls to start the components data retrieval process.
		this.retrieveComponentData();
	}
};

/**
 * This function is used to make the necessary data retrieval calls for the component.  The base functionality will call the
 * InsertDate function for older components which have not yet been updated to the generic component loading scheme.
 */
MPageComponent.prototype.retrieveComponentData = function() {
	try {
		if (typeof this.InsertData == 'function') {
			this.InsertData();
		}
	}
	catch (err) {
		MP_Util.LogJSError(err, this, "base-component.js", "retrieveComponentData");
		throw (err);
	}

};

/**
 * This is the older base class implementation of the components data retrieval script.  This function should be overridden for each
 * component.
 * @deprecated Component developers should now be suing the retrieveComponentData() function.
 */
MPageComponent.prototype.InsertData = function() {
	alert("ERROR: InsertData has not been implemented within the component");
};

/**
 * This function is used to pass the data retrieved for the component to the component for rendering.  The base functionality will
 * call the HandleSuccess function for older components which have not yet been updated to the generic component loading scheme.
 * Newer components will override this function as its main rendering function.
 * @param {object} recordData : The data object returned to the component form its data retrieval calls.
 */
MPageComponent.prototype.renderComponent = function(recordData) {
	//call the default HandleSuccess function if the component has not yet implemented the renderComponent function
	this.HandleSuccess(recordData);
};

/**
 * This is the older base class implementation of the components rendering script.  This function should be overridden for each
 * component.
 * @deprecated Component developers should now be suing the renderComponent() function.
 */
MPageComponent.prototype.HandleSuccess = function() {
	alert("ERROR: HandleSuccess has not been implemented within the component");
};

/**
 * This function will allow the component to handle any preprocessing that may need to take place before
 * calls are made to retrieve the data for the component.  The base class implementation does not perform any
 * actions at this time, but may in the future.  It is recommend that component developers overriding this function
 * still call the base class implementation.
 */
MPageComponent.prototype.preProcessing = function() {

};

/*
 * This function is used to finalize the component once it has finished generating its content.  It will be used to insert the
 * html or jquery element passed into the function into the component's section content node.  Once the content has been added
 * the function will then initialize hovers, initialize subsection toggles and initialize scrolling.
 * @param {string | jQuery} componentContent This will be an HTML string or a jQuery object which will be appended to the
 * component's section content node.
 * @param {string} resultCountText This will be an HTML string or a jQuery object which will be used as the result count shown
 * next to the component title.
 */
MPageComponent.prototype.finalizeComponent = function(componentContent, resultCountText) {
	//replace count text
	var rootComponentNode = this.getRootComponentNode();
	var self = this;
	//There are certain circumstances where a components DOM element will have been removed.
	//ie. selecting a view from the viewpoint drop down and then selecting another.
	if (rootComponentNode) {
		var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
		if (resultCountText) {
			//Make sure the count text is not hidden.
			$(totalCount)
				.removeClass("hidden");
			totalCount[0].innerHTML = resultCountText;
		}
		else {
			//If there is no count text to show then hide the element so it doesn't take up space.
			$(totalCount)
				.addClass("hidden");
		}

		//replace content with HTML or a jQery object
		var node = this.getSectionContentNode();
		if (typeof componentContent == "string") {
			node.innerHTML = componentContent;
		}
		else {
			$(node)
				.html(componentContent);
		}
		//init hovers
		this.initHovers(node);

		//init subsection toggles
		MP_Util.Doc.InitSubToggles(node, "sub-sec-hd-tgl");

		//init scrolling
		//Wrap in timeout to momentarily break the JS processing up and allow the browser to render.
		setTimeout(function() {
			MP_Util.Doc.InitScrolling(Util.Style.g("scrollable", node, "div"), self.getScrollNumber(), "1.6");
		}, 0);

		//Check to see if the component has an error message displayed
		var errorElement = $(rootComponentNode)
			.find(".error-message");
		if (errorElement.length) {
			//Add an error icon to the component title
			$(rootComponentNode)
				.find(".sec-title>span:first-child")
				.addClass("error-icon-component");
			//Ensure the bottom border on the error message is red and the padding is consistent
			$(errorElement)
				.css("border", "1px solid #C00")
				.css("padding", "2px 4px");
			//Fire and event to inform any listener that the component has errored
			CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
				"error": true
			});
		}
		else {
			//Remove the error icon in the component title
			$(rootComponentNode)
				.find(".sec-title>span:first-child")
				.removeClass("error-icon-component");
			//Fire and event to inform any listener that the component has not errored
			CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
				"error": false
			});
		}
		if (this.m_flowsheetTable) {
			this.m_flowsheetTable.finalize();
		}
		//If the component has a table, call the finalize method
		else if (this.m_componentTable) {
			this.m_componentTable.finalize();
		}
		
		if (self.getGapCheckRequiredInd()) {
			var disclaimerContainer =null;
			var disclaimerObj = null
			disclaimerContainer = $(rootComponentNode).find('.disclaimer-text');
			if (!disclaimerContainer.length) {
				disclaimerObj = self.createComponentDisclaimerContainer();
				var disclaimerMessageHTML = disclaimerObj.render();
				//Add a class to Alert Banner to differentiate it from other banners added to the component
				disclaimerContainer = $(disclaimerMessageHTML).addClass('disclaimer-text');
				var contentNodeHeader = $(rootComponentNode).find("H2")[0];
				$(contentNodeHeader).after(disclaimerContainer);
				//attach event to the close button
				disclaimerObj.attachEvents();
			}
			self.updateComponentRequiredIndicator();
		}
	}
	//notify the aggregate timer that the component has finished loading
	this.notifyAggregateTimer();
};

/**
 * This function returns true if the component is marked as required.
 * @return {boolean} returns the current state of required components.
 */
MPageComponent.prototype.getRequiredInd = function(){
	return ((this.getToggleStatus() === 2) || this.getGapCheckRequiredInd());
};

/**
 * This function will be used to notify the aggregate timer that the component is loaded
 * if the containing view has passed the aggregate timer reference to this component.
 */
MPageComponent.prototype.notifyAggregateTimer = function() {
	if (this.m_aggregateTimer instanceof AggregateTimer) {
		this.m_aggregateTimer.completeTask(this.getStyles()
			.getId());
	}
};

/**
 * This function will be used to save single component preferences with the option of being save synchronous or asynchronous
 */
MPageComponent.prototype.savePreferences = function(saveAsync) {
	MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(this, saveAsync);
};

/**
 * This function will be used to handle any processing that needs to take place after the component has been rendered.  If the
 * component developer needs to implement this function it is recommended that the base function is still called within the new
 * implementation.
 */
MPageComponent.prototype.postProcessing = function() {
	//Resize the component appropriately if it is shown within a workflow
	var self = this;
	setTimeout(function() {
		self.resizeComponent();
	}, 50);
	//Any additional functionality that needs to happen after the component is rendered can happen here.
};

/**
 * This function creates the disclaimer which specifies the satisfier condition for the Gap check functionality
 * The visibility of the disclaimer is stored as a object preference and the disclaimer is visible based on the preference value
 * @return {Object} Object of the Disclaimer.
 */
MPageComponent.prototype.createComponentDisclaimerContainer = function () {
	var self = this;
	var componentId = self.getComponentId();
	var prefObj = self.getPreferencesObj() || {};
	var isPrefObjSet = (typeof prefObj.REQUIRED !== "undefined") ? prefObj.REQUIRED : 0;
	var localeString = self.getRequiredCompDisclaimerText()||"";
	self.setPreferencesObj(prefObj);
	var alertBanner = new MPageUI.AlertBanner();
	alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.ADVISORY);
	alertBanner.setPrimaryText(localeString);
	alertBanner.setDismissible(true);
	alertBanner.setCloseFunction(function () {
		alertBanner.hide();
		var requiredIndObj = $("#reqInd"+componentId);
		requiredIndObj.removeClass("hidden");
		prefObj.REQUIRED  = 1;
		self.setPreferencesObj(prefObj);
		self.savePreferences(true);
	});
	return alertBanner;
};

/**
 * This function Hides the Required Indicators when the condition is satisfied for a component or else it would display the 
 * Required Indicator disclaimer based on the preference object value.
 * @return {undefined} This function does not return a value
 */
MPageComponent.prototype.updateComponentRequiredIndicator = function () {
	var componentNode = this.getRootComponentNode();
	var componentNodeObj = $(componentNode);
	if (componentNode) {
		var componentReqIndObj = componentNodeObj.find('.component-required-ind');
		var componentDisclaimerContainer = componentNodeObj.find('.disclaimer-text');
		if (this.getSatisfiedInd()) {
			componentReqIndObj.addClass('hidden');
			componentDisclaimerContainer.hide();
		} else {
			var prefObj = this.getPreferencesObj() || {};
			var isPrefObjSet = (typeof prefObj.REQUIRED !== "undefined") ? prefObj.REQUIRED : 0;
			if (isPrefObjSet) {
				componentReqIndObj.removeClass('hidden');
				componentDisclaimerContainer.hide();
			} else {
				componentDisclaimerContainer.show();
				componentReqIndObj.addClass('hidden');
			}
		}
	}
};
/**
 * This function creates a group of toggles at the component section header according to the component's toggle related attributes.
 * A <span> tag is created for each toggle icon. Clicking on an icon will automatically changes toggles' css styles and changes
 * ActiveHeaderToggleIndex attribute of this component. When consumed, it will append toggles to component section header.
 * @return {jQuery Object} jQuery object of the toggle images's container
 */
MPageComponent.prototype.createHeaderToggles = function() {
	var self = this;
	var toggles = this.getHeaderToggles();
	if (toggles.length === 0) {
		return null;
	}
	var toggleHTML = '<div class="hdr-toggle-container" id="hdrToggleContainer' + this.getComponentId() + '">';
	var curIndex = this.getActiveHeaderToggleIndex();
	var len = toggles.length;
	for (var i = 0; i < len; i++) {
		//create a custom attribute (part of html5 feature) "data-button-index" to track index
		toggleHTML += '<span class="hdr-toggle ' + (curIndex === i ? toggles[i].active : toggles[i].inactive) + '" data-toggle-button-index="' + i + '">' + (toggles[i].text || '&nbsp;') + '</span>';
	}
	toggleHTML += '</div>';
	var togglesContainer = $(toggleHTML);
	//use delegate event handler on the container level. So each icon doesn't need a separate event handler
	togglesContainer.on("click", "span", function() {
		var index = parseInt($(this)
			.attr("data-toggle-button-index"), 10);
		self.activateHeaderToggle(index);
	});
	return togglesContainer;
};

/**
 * This function activates the header toggle of the provided index by switching to it.
 *
 * @param {Number} index The numeric index of the header toggle to switch to.
 */
MPageComponent.prototype.activateHeaderToggle = function(index) {
	var togglesContainer = $('#hdrToggleContainer' + this.getComponentId());
	var toggles = this.getHeaderToggles();
	var prevIdx = this.getActiveHeaderToggleIndex();
	//Do nothing when clicking on an active button
	if (index === prevIdx) {
		return;
	}
	//change css styles
	var prevButton = togglesContainer.children('[data-toggle-button-index="' + prevIdx + '"]');
	prevButton.removeClass(toggles[prevIdx].active)
		.addClass(toggles[prevIdx].inactive);
	var curButton = togglesContainer.children('[data-toggle-button-index="' + index + '"]');
	curButton.removeClass(toggles[index].inactive)
		.addClass(toggles[index].active);

	this.setActiveHeaderToggleIndex(index);
	this.handleHeaderToggleClick(index);
};


/**
 * It adds a pair of toggle styles.
 *
 * This functionality is superceded by the addHeaderToggle() method.
 *
 * @deprecated Please use addHeaderToggle() instead.
 * @param {string} activeStyle CSS classes when icon is active. CSS class names are separated by spaces
 * @param {string} inactiveStyle CSS classes when icon is inactive. CSS class names are separated by spaces
 */
MPageComponent.prototype.addHeaderToggleStyle = function(activeStyle, inactiveStyle) {
	this.addHeaderToggle({
		active: activeStyle,
		inactive: inactiveStyle
	});
};

/**
 * This function handles toggle click event. It's designed for developers to override it.
 * @param {Number} index Currently selected toggle index
 */
MPageComponent.prototype.handleHeaderToggleClick = function(index) {};

/**
 * Gets the index of the toggle button that the user currently has selected.
 * @return {Number} The index of the currently selected toggle button
 */
MPageComponent.prototype.getActiveHeaderToggleIndex = function() {
	return this.m_activeHeaderToggleIndex;
};

/**
 * Sets the index of the toggle button that the user currently has selected.
 * @param {Number} index The index of the toggle button which is currently select by the user
 */
MPageComponent.prototype.setActiveHeaderToggleIndex = function(index) {
	this.m_activeHeaderToggleIndex = index;
};

/**
 * Get toggles' styles in array. Each element is an object with active and inactive attributes that
 * specify css classes for toggle icons
 *
 * This functionality is superceded by the getHeaderToggles() method.
 *
 * @deprecated Please use getHeaderToggles() instead.
 * @return {Array} Array of objects that specify toggles' active and inactive styles
 */
MPageComponent.prototype.getHeaderToggleStyles = function() {
	return this.getHeaderToggles();
};

/**
 * Set toggles' styles in array. Each element is an object with active and inactive attributes that
 * specify css classes for toggle icons
 *
 * This functionality is superceded by the setHeaderToggles() method.
 *
 * @deprecated Please use setHeaderToggles() instead.
 * @param {Array} toggleStyles Array of objects that specify toggles' active and inactive styles
 */
MPageComponent.prototype.setHeaderToggleStyles = function(toggleStyles) {
	this.setHeaderToggles(toggleStyles);
};

/**
 * Get toggle objects as an array. Each array element is a toggle object with various attributes that defines the header toggles.
 *
 * Currently supported attributes in the toggle objects:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @return {Array} Array of objects that specify toggles' various attributes
 */
MPageComponent.prototype.getHeaderToggles = function() {
	if (this.m_headerToggleObjects === null) {
		this.m_headerToggleObjects = [];
	}
	return this.m_headerToggleObjects;
};

/**
 * Set toggles objects as an array. Each array element is a toggle object various attributes that defines the header toggles.
 *
 * Currently supported attributes in the toggle objects:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @param {Array} toggleObjects Array of objects that specify toggles' various attributes
 */
MPageComponent.prototype.setHeaderToggles = function(toggleObjects) {
	this.m_headerToggleObjects = toggleObjects;
};

/**
 * It adds a toggle object to existing array of toggle objects.
 * A new empty array is created if necessary.
 *
 * Currently supported attributes in the toggle object:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @param {Object} toggleObject Toggle object to be added.
 */
MPageComponent.prototype.addHeaderToggle = function(toggleObject) {
	if (this.m_headerToggleObjects === null) {
		this.m_headerToggleObjects = [];
	}
	this.m_headerToggleObjects.push(toggleObject);
};

/**
 * Function called within RenderStrategy that allows component level changes to the header link
 * using the component.setLink function.  
 * @return {undefined}
 */
MPageComponent.prototype.onTitleClick = function() {
	if(!CERN_Platform.inMillenniumContext()){
		return;
	}
	var criterion = this.getCriterion();
	var tabLink = this.getLink();
	//create anchor
	var sParms = "/PERSONID=" + criterion.person_id + " /ENCNTRID=" + criterion.encntr_id + " /FIRSTTAB=^" + tabLink + "^";
	APPLINK(0, criterion.executable, sParms);
};

/**
 * Updates the 'As Of' display in the component with the last refresh date of the workflow component
 * @return {jQuery} the refresh button that can be added to the DOM
 */
MPageComponent.prototype.updateComponentAsOfDisplay = function() {
	//Update the as of display in the refresh button hover
	$('#mainCompRefresh' + this.getComponentId())
		.attr("title", this.getAsOfDateString());
};

/**
 * Return an AsOf date string for the title of this component
 * @return {String} an internationalized as of date string
 */
MPageComponent.prototype.getAsOfDateString = function() {
	//Get the last refresh date and format the display
	var dateObj = new Date();
	var dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	var dateString = dateFormatter.format(dateObj, mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS);

	//Update the as of display in the refresh button hover
	var rawLabel = this.getLabel() + " - " + i18n.discernabu.AS_OF_TIME.replace("{0}", dateString);
	//this will allow the as of date string to display properly in a title attr of a <div>
	return $('<textarea />')
		.html(rawLabel)
		.text();
};

/**
 * The postDOMLocationChange function is used to provide MPageComponent objects the chance to revert any changes 
 * made by the browser when the DOM contents of the component have been relocated. For instance when Dragging 
 * and Dropping a component tables are scrolled back to the 0px offset. This scroll reset may produce visual 
 * inconsistencies in component. The base class implementation does not perform any actions at this time. 
 * It is up to the component that overrides this method to decide how to implement this.
 */
MPageComponent.prototype.postDOMLocationChange = function() {
   
};

/**
 * Creates the component level Contextual view control
 * @return {MPageUI.Button} An instance of MPageUI.Button 
 */
MPageComponent.prototype.createComponentContextualViewControl = function(){			
	if(!this.isContextualViewCompatible()){
		return;
	}
	var compId = this.getComponentId();
	var self = this;
	var contextualViewButton = new MPageUI.Button();
	contextualViewButton.setStyle(MPageUI.BUTTON_OPTIONS.STYLE.LINK);
	contextualViewButton.setSize(MPageUI.BUTTON_OPTIONS.SIZE.SMALL);	
	return contextualViewButton;
};

/**
 * Creates a placeholder view of component.
 * @return {Object} jQuery object that would represent the placeholder View object.
 */
MPageComponent.prototype.createPlaceholderViewOfComponent = function() {	
	if(!this.m_placeholderView){
		this.m_placeholderView = new MPageUI.PlaceholderContent();
		this.m_placeholderView.setPrimaryText(this.getLabel());		
		this.m_contextualViewControlInPlaceholderView = this.createComponentContextualViewControl();
		this.m_contextualViewControlInPlaceholderView.setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);
		this.m_placeholderView.setActionableControl(this.m_contextualViewControlInPlaceholderView);				
	}		
	return $("<div>" + this.m_placeholderView.render() + "</div>").addClass("section").attr("id", this.getStyles().getId() + "PlaceholderView");
};
/**
 * The Dummy component style
 * @constructor
 * @returns {undefined} This function does not return a value
 */
function DummyComponentStyle() {
	this.initByNamespace("dummy-component");
}

DummyComponentStyle.prototype = new ComponentStyle();
DummyComponentStyle.prototype.constructor = ComponentStyle;

/**
 * The constructor of dummy component. It sets the criterion and component style
 * objects just like the real components. 
 * @constructor
 * @param {Criterion} criterion
 */
function DummyComponent(criterion) {
	this.setCriterion(criterion);
	this.setStyles(new DummyComponentStyle());
}

DummyComponent.prototype = new MPageComponent();
DummyComponent.prototype.constructor = MPageComponent;

/**
 * Override MPageComponent's postProcessing to do nothing. 
 * We don't need the resize logic in this dummy component. 
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.postProcessing = function() {
	
};

/**
 * Override MPageComponent's retrieveComponentData to render the UI directly. 
 * There's no data to retrieve
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.retrieveComponentData = function() {
	this.renderComponent();
};

/**
 * It displays the informational text on the component that indicates this 
 * component is no longer available. 
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.renderComponent = function() {
	//Initialize a new alert banner instance
	var alertBanner = new MPageUI.AlertBanner();
	 
	//Set the type of alert banner to be displayed
	alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.INFO);

	//Set the primary text for the alert banner
	alertBanner.setPrimaryText(i18n.discernabu.MPageView.COMPONENT_NOT_AVAILABLE);

	// finalize the component with the informational text
	this.finalizeComponent(alertBanner.render(), "");
};
/*globals _g, m_bedrockMpage, createPageCriterion, OpenDischargeProcess, CERN_DEMO_BANNER_O1, m_viewpointJSON, validateWindowResize, SummaryRenderStrategy, Util, DynamicMenu, Menu, MenuItem, MenuSelection, MenuSeparator, MP_MenuManager, AggregateTimer */
/**
 * The MPageView object
 * @constructor
 * @author Greg Howdeshell
 * @author Steven Lewis
 */
function MPageView() {
	/*Variables*/
	this.components = null;
	this.componentIds = null;
	this.container = null;
	this.criterion = null;
	this.helpFileName = "";
	this.helpFileURL = "https://wiki.ucern.com/display/r1mpagesHP/MPages+Help+Pages";
	this.isCustomizeView = false;
	this.m_categoryMean = "";
	this.m_capTimerName = "";
	this.m_csEnabled = false;
	this.m_dpEnabled = false;
	this.m_filterMappingsObj = {};
	this.m_helpFilePath = "";
	this.m_helpFileURL = "";
	//This flag is used to determine if the current context of the MPagesView is valid for the type of view
	this.m_isContextValid = null;
	this.m_isCustomizeEnabled = true;
	this.m_viewSettings = null;
	this.m_printableReportName = null;
	this.m_subTimerName = "";
	this.m_titleAnchors = null;
	//The user preferences object that has been created for this MPagesView
	this.m_userPreferences = null;
	//The view type is used to determine what type of view this MPageView object is
	this.m_viewType = "";
	this.name = null;
	this.pageId = 0.0;
	this.viewpointIndicator = false;
	this.allExpanded = false;
	this.m_scrollOffsetPosition = 0;

	//flag indicating whether Drag and Drop function is already initialized
	this.m_dragNDropInitialized = false;
}

/**
 * Create the aggregate timer object to measure the page load time
 * It will choose the right timer name based on whether it is the initial page load or the user is switching to another view.
 * @return {AggregateTimer} the aggregate timer object
 */
MPageView.prototype.createAggregateTimer = function() {
	var pageLoadTimerName = null;
	var viewCategoryMean = this.getCategoryMean();

	//get the timer name depending on whether the view is loaded during the initial page load
	if (MP_Viewpoint.getInitialViewId() !== viewCategoryMean) {
		//use the timer name the measures the page load timer when the user switches the view in a viewpoint
		pageLoadTimerName = "USR:MPG.VIEWPOINT load switch view";
	}
	else {
		//use the same timer as defined in mp_unified_driver
		pageLoadTimerName = "USR:MPG.MP_UNIFIED_DRIVER load entire page";
	}

	//Create the page load timer here
	var aggregateTimer = new AggregateTimer(pageLoadTimerName, viewCategoryMean);
	return aggregateTimer;
};

/** Static Variables **/
//This object is used to convert full bedrock filter field names to their shorthand versions
MPageView.prototype.bedrockShorthandConversions = {
	PARENT_ENTITY_ID: "PE_ID",
	PARENT_ENTITY_NAME: "PE_NM",
	GROUP_SEQ: "G_SQ",
	VALUE_SEQ: "V_SQ",
	FREETEXT_DESC: "FTXT"
};

/** Adders **/

/**
 * Adds the id of a component to the list of component ids contained in this MPageView object.
 * @param {number} compId The primary key of a component contained in this MPageView object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.addComponentId = function(compId) {
	if (this.componentIds === null) {
		this.componentIds = [];
	}
	this.componentIds.push(compId);
};

/**
 * Adds a component to the existing MPage
 * @param {MPageComponent} componentObj The MPageComponent object to add to the MpageView
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.addComponent = function(componentObj) {
	if (this.components === null) {
		this.components = [];
	}
	this.components.push(componentObj);
};

/**
 * Add a filter mapping object to the collection of mappings.  Filter mappings are referenced by name, so if a filter already exists
 * with the same name it will be overwritten.
 * @param {String} filterName The name of the filter object to add.
 * @param {Object} filterObject The object containing all of the filter properties used when loading settings.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.addFilterMappingObject = function(filterName, filterObject) {
	//Convert full length field names into short hand if they are not already shorthand
	if (filterObject && typeof this.bedrockShorthandConversions[filterObject.field] !== "undefined") {
		filterObject.field = this.bedrockShorthandConversions[filterObject.field];
	}
	this.m_filterMappingsObj[filterName] = filterObject;
};

/**
 * Adds the HTML code for an anchor tag to be shown at the top of an MPages View.  The parameter passed in should be syntactically
 * correct HTML as it will be placed directly into the DOM.
 * @param {String} anchorHTML The HTML markup for the anchor to be added to the MPages View.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.addTitleAnchor = function(anchorHTML) {
	if (this.m_titleAnchors === null) {
		this.m_titleAnchors = [];
	}
	this.m_titleAnchors.push(anchorHTML);
};

/**
 * Method to apply the scroll position back to the MpageView
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.applyOffsetPosition = function() {
	var mpageViewId = this.getCategoryMean();
	$("#" + mpageViewId)
		.parent()
		.scrollTop(this.m_scrollOffsetPosition);
};

/**
 * This function is used to display a message to the user stating that the context the MPageView
 * is being viewed within is invalid.  See documentation for the MPageView.isContextValid function
 * for a detailed list of valid contexts.
 * @returns {undefined} This function does not return a value
 */
MPageView.prototype.displayInvalidContextMessage = function(){
	//If we are in a patient context and we are making it into this function we need to show the message stating that a patient context
	//is invalid for this MPageView
	var contextMessage = CERN_Platform.inPatientChartContext() ? i18n.discernabu.MPageView.PATIENT_CONTEXT_INVALID : i18n.discernabu.MPageView.ORGANIZER_CONTEXT_INVALID;
	var modalId = "ContextModal" + this.getCategoryMean();
	//Show a Modal Dialog with the invalid context messaging
	var warningModal = MP_ModalDialog.retrieveModalDialogObject(modalId);
	if(!warningModal){
		warningModal = MP_Util.generateModalDialogBody(modalId, "warning", contextMessage, i18n.discernabu.MPageView.CONTACT_SYSTEM_ADMIN);
		warningModal.setHeaderTitle(i18n.discernabu.MPageView.INVALID_CONTEXT);
		var okButton = new ModalButton("okButton");
		okButton.setText(i18n.discernabu.CONFIRM_OK);
		warningModal.addFooterButton(okButton);
	}
	MP_ModalDialog.addModalDialogObject(warningModal);
	MP_ModalDialog.showModalDialog(modalId);
};

/** Getters **/

/**
 * Gets the name of the capitalization timer for this instance of the MPageView object.
 * @return {String} The name of the capitalization timer.
 */
MPageView.prototype.getCapTimerName = function() {
	return this.m_capTimerName;
};

/**
 * Gets the category mean assigned to this instance of the MPageView object.
 * @return {String} The category mean of this MPageView object.
 */
MPageView.prototype.getCategoryMean = function() {
	return this.m_categoryMean;
};

/**
 * Gets the array of component ids that are set to load with this instance of the MPageView object.
 * @return {Array} An array of components ids
 */
MPageView.prototype.getComponentIds = function() {
	return this.componentIds;
};

/**
 * Gets the array of MPageComponent objects associated to this instance of the MPageView object.
 * @return {Array} An array of MPageComponent objects.
 */
MPageView.prototype.getComponents = function() {
	return this.components;
};

/**
 * Gets the container that this view resides in
 * @return {Object} the container for this view
 */
MPageView.prototype.getContainer = function() {
	return this.container;
};

/**
 * Returns the criterion object stored in the MPageView object.  The criterion object contains information such as the person_id,
 * encntr_id, personnel_id, etc.
 * @return {Criterion} A Criterion object containing information such as the person_id, encntr_id, personnel_id, etc.
 */
MPageView.prototype.getCriterion = function() {
	return this.criterion;
};

/**
 * Gets the the flag which determines if the user is allowed to customize a MPages View or not.
 * @return {Boolean} A boolean flag which determines if the user is allowed to customize a MPages View or not.
 */
MPageView.prototype.getCustomizeEnabled = function() {
	return this.m_isCustomizeEnabled;
};

/**
 * Gets the the flag which determines whether or not to add the customization option to the MPages View.
 * @return {Boolean} A boolean flag which determines whether or not to add the customization option to the MPages View.
 */
MPageView.prototype.getCustomizeView = function() {
	return this.isCustomizeView;
};

/**
 * Gets the array of filter mapping objects used to apply MPages View level settings.
 * @return {Array} An array of filter mapping objects.
 */
MPageView.prototype.getFilterMappingsObj = function() {
	return this.m_filterMappingsObj;
};

/**
 * Return the help file name that is to be loaded when the help file icon is clicked.
 * @return {String} An string containing the file path location of a help file.
 */
MPageView.prototype.getHelpFileName = function() {
	return this.helpFileName;
};

/**
 * Return the help file URL that is to be loaded when the help file icon is clicked.
 * @return {String} The URL of the help file
 */
MPageView.prototype.getHelpFileURL = function() {
	return this.helpFileURL;
};

/**
 * Gets the name associated to the MPages View
 * @return {String} The name of the MPages View
 */
MPageView.prototype.getName = function() {
	return this.name;
};

/**
 * Gets the primary key associated to the MPageView object.
 * @return {Number} The key of the MPageView object
 */
MPageView.prototype.getPageId = function() {
	return this.pageId;
};

/**
 * Gets the page level settings object loaded from the preferences model.
 * @return {Object} The preferences object used to set the MPageView object settings.
 */
MPageView.prototype.getViewSettings = function() {
	return this.m_viewSettings;
};

/**
 * Returns the printable report name if it has been set.
 * @return {String} The name given to the printable report.
 */
MPageView.prototype.getPrintableReportName = function() {
	return this.m_printableReportName;
};

/**
 * Gets the subtimer name to be associated with the capitalization timer.
 * @return {String} The name of the subtimer
 */
MPageView.prototype.getSubTimerName = function() {
	return this.m_subTimerName;
};

/**
 * Gets the array of HTML anchor elements that will be added to the MPages View.
 * @return {Array} An array of HTML string which makeup the MPages options
 */
MPageView.prototype.getTitleAnchors = function() {
	return this.m_titleAnchors;
};

/**
 * Gets the user preferences that have been created for this MPages View.
 * @return {object} The user preferences that have been set for this MPages View
 */
MPageView.prototype.getUserPreferences = function() {
	return this.m_userPreferences;
};

/**
 * Gets the view type of the MPages View.
 * @return {string} The view type of the MPages View
 */
MPageView.prototype.getViewType = function() {
	return this.m_viewType;
};

/** Boolean Checks **/

/**
 * A check for the m_csEnabled flag which determines if the chart search functionality should be available for the user.
 * @return {Boolean} True if chart search is to be displayed within the MPage.  False otherwise.
 */
MPageView.prototype.isChartSearchEnabled = function() {
	return this.m_csEnabled;
};

/**
 * This function is used to see if the context in which this MPageView is being shown is valid.  For example if we 
 * are in a patients chart, attempting to show an MPageView that is intended to show population data in not contextually valid.
 * Inversely, if we are at the organizer level it does not make sense to show patient level data.
 * 
 * Views valid within a patient chart context
 *  Workflow Views
 *  Summary Views
 *  QOC Views
 *  Standalone MPageViews (soon to be obsolete)
 * Views valid outside of a patient chart context
 *  Organizer Patient Worklists
 *  Organizer Provider Worklists
 *  Organizer Dashboards
 * @return {boolean} True if the context of the view is valid, false otherwise
 */
MPageView.prototype.isContextValid = function(){
	if(this.m_isContextValid === null){
		var viewType = this.getViewType();
		//Check to determine the context
		if(CERN_Platform.inPatientChartContext()){
			//We are in the context of a patient's chart so only show views which are valid within this context
			this.m_isContextValid = !/(^PO_.*|^PRO_.*|^DASH_.*)/.test(viewType);
		}
		else{
			//We are not in the context of a patient chart so only show views which are valid outside of a patient chart context
			this.m_isContextValid = /(^PO_.*|^PRO_.*|^DASH_.*)/.test(viewType);
		}
	}
	return this.m_isContextValid;
};

/**
 * A check for the m_dpEnabled flag which determines if the discharge process functionality should be available for the user.
 * @return {Boolean} True if discharge process icon is to be displayed within the MPage.  False otherwise.
 */
MPageView.prototype.isDischargeProcessEnabled = function() {
	return this.m_dpEnabled;
};

/**
 * A check for the allExpanded flag which determines if all the components are currently expanded or not.
 * @return {Boolean} True if all components are expanded.  False otherwise.
 */
MPageView.prototype.isAllExpanded = function() {
	return this.allExpanded;
};

/**
 * Method to save the offsetPosition of the MpageView
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.saveOffsetPosition = function() {
	var mpageViewId = this.getCategoryMean();
	var scrollDiv = $("#" + mpageViewId)
		.parent();
	this.m_scrollOffsetPosition = $(scrollDiv)
		.scrollTop();
};

/** Setters **/

/**
 * Sets the name of the capitalization timer for this instance of the MPageView object.  The capTimerName parameter must be a string,
 * otherwise it is ignored.
 * @param {String} capTimerName The name of the capitalization timer.
 * @return {Boolean} True if the capitalization timer name was set, false otherwise.
 */
MPageView.prototype.setCapTimerName = function(capTimerName) {
	if (capTimerName && typeof capTimerName === "string") {
		this.m_capTimerName = capTimerName;
		return true;
	}
	return false;
};

/**
 * Sets the category mean of the MPageView object.  The categoryMean parameter must be a string, otherwise it is ignored.
 * @param {String} categoryMean The category mean of the MPageView object
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setCategoryMean = function(categoryMean) {
	if (categoryMean && typeof categoryMean === "string") {
		this.m_categoryMean = categoryMean;
		return true;
	}
	return false;
};

/**
 * Sets whether or not to display chart search functionality
 * @param {Boolean} showChartSearch The boolean value in which to note to display or not display chart search.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setChartSearchEnabled = function(showChartSearch) {
	this.m_csEnabled = showChartSearch;
};

/**
 * Sets the container that this view resides within (either in viewpoint or not)
 * @param {Object} container the DOM container that this view will reside in
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setContainer = function(container) {
	if (container) {
		this.container = container;
	}
};

/**
 * Sets whether or not to discharge process functionality
 * @param {Boolean} showDischargeProcess The boolean value in which to note to display or not display discharge process.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setDischargeProcessEnabled = function(showDischargeProcess) {
	this.m_dpEnabled = showDischargeProcess;
};

/**
 * Sets the array of components ids which are the primary keys to the MPageComponent objects that are part of this MPageView object.
 * @param {Array} compIdArr The array of component ids.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setComponentIds = function(compIdArr) {
	this.componentIds = compIdArr;
};

/**
 * Sets the list of MPageComponent objects which are contained within this MPageView object.
 * @param {Array} componentArr The array of MPageComponent objects which are contained within this MPageView object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setComponents = function(componentArr) {
	this.components = componentArr;
};

/**
 * Sets the Criterion object for this instance of the MPageView object.
 * @param {Criterion} criterionObj The Criterion object in which to initialize the MPageView object with.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setCriterion = function(criterionObj) {
	this.criterion = criterionObj;
};

/**
 * Sets the flag which determines if the customization option will be enabled or disabled within the MPages View.
 * @param {Boolean} customizedEnabled A flag which determines if customization of the MPages View is enabled or disabled.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setCustomizeEnabled = function(customizedEnabled) {
	this.m_isCustomizeEnabled = customizedEnabled;
};

/**
 * Sets the flag which determines if the customization option will be shown to the user or not on the MPages View.
 * @param {Boolean} customizeView A flag which determines if the customization option will be shown to the user or not.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setCustomizeView = function(customizeView) {
	this.isCustomizeView = customizeView;
};

/**
 * Sets the filter mappings object which will be used when loading settings from the preferences model.  The filterObj parameter must
 * not be null.  If it is null it will be ignored.
 * @param {Object} filterObj An object which contains the filter mappings of the MPageView object
 * @return {Boolean} True if the m_filterMappingsObj was set to filterObj, false otherwise
 */
MPageView.prototype.setFilterMappingsObj = function(filterObj) {
	if (filterObj) {
		this.m_filterMappingsObj = filterObj;
		return true;
	}
	return false;
};

/**
 * Sets the help file name that is to be loaded when the help file icon is clicked.
 * @param {String} fileName The name of the help file to be loaded when the help icon is clicked.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setHelpFileName = function(fileName) {
	this.helpFileName = fileName;
};

/**
 * Sets the help file URL that is to be loaded when the help file icon is clicked.
 * @param {String} fileURL The name of the help file to be loaded when the help icon is clicked.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setHelpFileURL = function(fileURL) {
	this.helpFileURL = fileURL;
};

/**
 * Sets the name given to the MPages View.  The mpageName parameter must not be blank or null.  If it is the existing name will not
 * be modified.
 * @param {String} mpageName the name to be given to the MPages View
 * @return {Boolean} True if the MPages View name was set, otherwise false.
 */
MPageView.prototype.setName = function(mpageName) {
	if (mpageName && typeof mpageName === "string") {
		this.name = mpageName;
		return true;
	}
	return false;
};

/**
 * Sets the primary key associated to the MPageView object.
 * @param {Number} mpageId The primary key to be associated to the MPageView object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setPageId = function(mpageId) {
	this.pageId = mpageId;
};

/**
 * Sets the page settings object used when initializing MPageView object elements.
 * @param {Object} settingsObj The settings object from the preferences model.
 * @return {Boolean} True if the page settings were set successfully, false otherwise
 */
MPageView.prototype.setViewSettings = function(settingsObj) {
	if (settingsObj) {
		this.m_viewSettings = settingsObj;
		return true;
	}
	return false;
};

/**
 * Sets the view type for this MPageView object.
 * @param {string} viewType The view type
 * @return {boolean} True if the view type was set successfuly, false otherwise
 */
MPageView.prototype.setViewType = function(viewType){
	if(viewType && typeof viewType === "string"){
		this.m_viewType = viewType;
		return true;
	}
	return false;
};

/**
 * Sets the printable report script/name of the MPages View iff the reportName is a string.
 * @param {String} reportName The reportName value will hold the script name (from bedrock) that will be used/executed to print a report.
 * @return {String} This function returns the report name if it was set, null otherwise
 */
MPageView.prototype.setPrintableReportName = function(reportName) {
	if (reportName && typeof reportName === "string") {
		this.m_printableReportName = reportName;
		return this.m_printableReportName;
	}
	return null;
};

/**
 * Sets the name of the capitalization subtimer.
 * @param {String} timerName The name to give to the capitalization subtimer
 * @return {Boolean} This function returns true if the sub timer name was set successfully, false otherwise
 */
MPageView.prototype.setSubTimerName = function(timerName) {
	if (timerName && typeof timerName === "string") {
		this.m_subTimerName = timerName;
		return true;
	}
	return false;
};

/**
 * Sets the user preferences that have been generated for this MPages View.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setUserPreferences = function(userPrefs){
	this.m_userPreferences = userPrefs;
};

/**
 * Sets the array of anchors/additional options to be shown on MPages View.  The strings passed in the anchorArr should be
 * syntactically correct HTML as it will be placed directly into the DOM.
 * @param {Array} anchorArr An array of HTML strings which will be loaded into the MPages View.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setTitleAnchors = function(anchorArr) {
	this.m_titleAnchors = anchorArr;
};

/**
 * Sets the flag which determines if all components are expanded or collapsed.
 * @param {Boolean} allExpandedInd A flag which determines if all the components are expanded or collapsed. True means
 * all are expanded, false means all are collapsed.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.setIsAllExpanded = function(allExpandedInd) {
	this.allExpanded = allExpandedInd;
};

/** Initialization and rendering functions for the MPageView objects **/

/**
 * Initializes the MPageView with the basic information needed to render the MPages View.  This includes registering unload and
 * resize events with the custom component framework, loading the default filtermappings for the MPageView, creating timers
 * based on the timer names in m_capTimerName and m_subTimerName and finally creating and storing the criterion object in the
 * MPageView object.  This function can be extended and/or overwritten in a MPageView prototyped object.
 * @return {boolean} True if the MPagesView was initialized successfully, false otherwise
 */
MPageView.prototype.initializeView = function() {
	try {
		//Load the filter mappings
		this.loadFilterMappings();

		//Load the timer information
		this.setCapTimerName("CAP:MPG Launch MPage");
		this.setSubTimerName(this.getCategoryMean());

		//Create the MPage timers based on names set in the MPageView object
		this.createMPageTimerObject();

		//Create and set the criterion object for the MPageView
		this.setCriterion(createPageCriterion(this.getCategoryMean()));

		return true;
	}
	catch (err) {
		logger.logJSError(err, null, "MPageView.js", "initializeView");
		throw err;
	}
};

/**
 * Loads and stores the settings from the preferences model into the MPageView object.  This includes setting the page id, loading
 * the application and user preferences model and applying the filter mappings loaded in the MPageView.loadFilterMappings() function.
 * It is not recommended to override or extend this function.
 * @return {boolean} True if the page settings were loaded successfully, false otherwise
 */
MPageView.prototype.loadViewSettings = function() {
	var bValue = "";
	var filter = null;
	var filterMappingsObj = null;
	var pageFilters = null;
	var viewSettings = null;
	var value = null;
	var sValue = "";
	var x = 0;

	try {
	
		//Retrieve and store the page level settings from the preference model
		viewSettings = this.getViewSettingsObject();
		if (!viewSettings) {
			throw new Error(i18n.VIEW_SETTINGS_UNAVAILABLE);
		}
		this.setViewSettings(viewSettings);

		//Set the page id from the bedrock contents
		this.setPageId(viewSettings.C_ID); //C_ID is shorthand for Category Id (br_datamart_category_id)
		
		//Set the view type for this view
		this.setViewType(viewSettings.BR_SET.VT_MN);

		//Create the preference manager for user preferences
		/*eslint-disable new-cap*/
		MP_Core.AppUserPreferenceManager.Initialize(this.getCriterion(), this.getCategoryMean());
		if (viewSettings.BR_SET.UP.length > 0) { //BR_SET is shorthand for Bedrock Settings and UP is shorthand for User Preferences
			MP_Core.AppUserPreferenceManager.SetPreferences(viewSettings.BR_SET.UP);
		}
		/*eslint-enable new-cap*/

		//Set the page level settings
		filterMappingsObj = this.getFilterMappingsObj();
		pageFilters = viewSettings.BR_SET.PS; //BR_SET is shorthand for Bedrock Settings and PS is the shorthand for Page Settings
		
		//Create Shared Resource containing the page level filters
		var plfResource = this.loadPageLevelFiltersSharedResource(pageFilters, this.getCategoryMean());
		
		for (x = pageFilters.length; x--;) {
			filter = filterMappingsObj[pageFilters[x].F_MN]; //F_MN is shorthand for Filter Mean
			if (filter) {
				value = pageFilters[x].VALS[0];
				sValue = "";
				bValue = "";
				switch (filter.type.toUpperCase()) {
					case "BOOLEAN":
						if (value && typeof value[filter.field] !== "undefined") {
							sValue = value[filter.field];
							/*eslint-disable no-extra-parens*/
							bValue = (sValue === "0") ? false : true;
							/*eslint-enable no-extra-parens*/
							filter.setFunction.call(this, bValue);
						}
						break;
					case "STRING":
						if (value && typeof value[filter.field] !== "undefined") {
							sValue = value[filter.field];
							filter.setFunction.call(this, sValue);
						}
						break;
				}
			}
		}
		return true;
	}
	catch (err) {
		logger.logJSError(err, null, "MPageView.js", "loadViewSettings");
		throw err;
	}
};


/**
 * Creates the Page Level Filters Shared Resource if it doesn't exist, else populates the existing Shared Resource with the 
 * proper page level filter data.
 * It is not recommended to override or extend this function.
 * @param {object} The object containing all the page level filters
 * @return {object} The Page Level Filters Shared Resource Object
 */
MPageView.prototype.loadPageLevelFiltersSharedResource = function(pageFiltersObj, viewCatMean) {
	// create the page level filters shared resource
	var resourceName = viewCatMean + "pageLevelFilters";
	var plfResource = MP_Resources.getSharedResource(resourceName);
	if (!plfResource) {
		plfResource = new SharedResource(resourceName);
		MP_Resources.addSharedResource(resourceName, plfResource);
	}
	
	//If the resource already exists make sure that there is data in it and it is available
	var plFilters = plfResource.getResourceData();
	if(plfResource.isResourceAvailable() && plFilters.length > 0) {
		return plfResource;
	}
	else {
		if(pageFiltersObj){
			plfResource.setResourceData(pageFiltersObj);
			plfResource.setIsAvailable(true);
			return plfResource;
		}
		else {
			//Return the shared resource, which at this point should have isResourceAvailable() == false && getResourceData() == null
			return plfResource;
		}
	}
};


/**
 * This function will be used by MPageView instances to handle any pre-processing that needs to take place prior
 * to initializing the components and rendering the contents of the MPages View.  This function is a stub and is 
 * intended to be overwritten by the MPageView instance.
 * @this {MPagesView}
 * @return null 
 */
MPageView.prototype.preProcessing = function(){

};
/**
 * Perform the initialization of all of the components which will appear on this MPages View.  Initialization includes loading all
 * preferences from the preference model into the components, applying user level settings to the components and finally storing
 * the newly created MPageComponent objects in the components[] array of the MPageView object.  It is not recommend to overwrite
 * this function, but it can be extended to further setup the components of an MPages View.  For example, setting forced lookback
 * ranges for certain components on an MPages View.
 * @return {boolean} True if the component settings were initialized properly, false otherwise
 */
MPageView.prototype.initializeComponents = function() {
	var component = null;
	var componentsArr = [];
	var componentCnt = 0;
	var compSettings = null;
	var viewSettings = null;
	var x = 0;

	try {
		//Load the component ids and initialize the components
		viewSettings = this.getViewSettings();
		componentsArr = viewSettings.BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for Component Settings
		componentCnt = componentsArr.length;
		for (x = 0; x < componentCnt; x++) {
			compSettings = componentsArr[x];
			//Create the component and prepare it for rendering
			component = this.createMPageComponentObject(compSettings.F_MN); //F_MN is shorthand for Filter Mean
			if (component) {
				//Initialize the component
				component.initializeComponent(this.getCriterion());
				//Set Component Preferences based on bedrock settings and user preferences
				component.loadComponentSettings(compSettings);
				//Load the display filters of the component
				component.loadDisplayFilters();
				//Let the component handle any preprocessing actions that may need to take place before it will be rendered
				component.preProcessing();
				//Add the component to the component array
				this.addComponent(component);
				//Add the component id to the list of ids
				this.addComponentId(componentsArr[x].R_ID); //R_ID is shorthand for Report Id (br_datamart_report_id)
			}
		}
		return true;
	}
	catch (err) {
		logger.logJSError(err, null, "MPageView.js", "initializeComponents");
		throw err;
	}
};


/**
 * This function is used to handle the window.resize events that are fired when the browser window is resized.  The base
 * functionality calls the resizeComponent function for all MPageComponent objects.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.resizeView = function() {
	var compObj = null;
	var components = null;
	//Get each component associated with this view
	components = this.getComponents();
	for (var x = components.length; x--;) {
		compObj = components[x];
		if (compObj.isDisplayable()) {
			compObj.resizeComponent();
		}
	}
};

/**
 * This function is used to create the necessary MPageComponent object based on the filterMean for the component.
 * @param {String} compFilterMean The filter mean associated with the component object to initialize
 * @return {MPageComponent} This function retuns the MPageComponent associated to the component filter mean passed in
 * if one exists.
 */
MPageView.prototype.createMPageComponentObject = function(compFilterMean) {
	var criterion = this.getCriterion();
	var CompDef = null;
	//Check to see if the component has registered itself
	CompDef = MP_Util.getObjectDefinitionMapping(compFilterMean);
	if (CompDef) {
		return new CompDef(criterion);
	}

	//If the compDef is not defined we will fall back to our trusty switch case.
	/*eslint-disable no-undef, block-scoped-var*/
	switch (compFilterMean.toUpperCase()) {
		case "DMS_ALLERGIES":
		case "WF_ALLERGY":
			return new AllergyComponentWF(criterion);
		case "ALLERGY":
			return new AllergyComponent(criterion);
		case "ANCIL_DOC":
			return new DocumentComponent(criterion);
		case "APNEA":
			return new ABDComponent(criterion);
		case "CLIN_DOC":
			return new DocumentComponent(criterion);
		case "CONSOL_PROBLEMS":
		case "NARRATIVE_PROBLEM":
			return new CvComponent(criterion);
		case "CURR_STATUS":
			return new CurStatusComponentO1(criterion);
		case "DC_ACTIVITIES":
			return new ActivitiesComponent(criterion);
		case "DC_CARE_MGMT":
			return new DischargePlanningComponent(criterion);
		case "DMS_DIAGNOSIS":
		case "DC_DIAGNOSIS":
		case "DIAGNOSIS":
		case "DX":
			return new DiagnosesComponent(criterion);
		case "DC_ORDER":
			return new DischargeOrdersComponent(criterion);
		case "DC_READINESS":
			return new DischargeIndicatorComponent(criterion);
		case "DC_RESULTS":
			return new ResultsComponent(criterion);
		case "DC_SOCIAL":
			return new SocialComponent(criterion);
		case "ED_TIMELINE":
			return new TimelineComponent(criterion);
		case "FAMILY_HX":
			return new FamilyHistoryComponent(criterion);
		case "FIM":
			return new FunIndepMeasuresComponentO1(criterion);
		case "FLAG_EVENTS":
			return new FlaggedEventsComponent(criterion);
		case "FLD_BAL":
			return new IntakeOutputComponent(criterion);
		case "FOLLOWUP":
			return new FollowUpComponent(criterion);
		case "FUTURE_ORD":
			return new FutureOrdersComponent(criterion);
		case "GOALS":
			return new GoalsComponentO1(criterion);
		case "GRAPHS":
			return new VSTimelineComponent(criterion);
		case "GROWTH_CHART":
			return new GrowthChartComponent(criterion);
		case "HEALTH_MAINT":
			return new HmiComponent(criterion);
		case "HOME_MEDS":
			return new HomeMedicationsComponent(criterion);
		case "ICU_FLOWSHEET":
			return new ICUFlowsheetComponent(criterion);
		case "IMMUNIZATIONS":
			return new ImmunizationComponent(criterion);
		case "INCOMPLETE_ORDERS":
		case "ORDERS":
			return new OrdersComponent(criterion);
		case "INTER_TEAM":
			return new InterTeamComponentO1(criterion);
		case "DMS_LAB":
			return new LabPagerComponent(criterion);
		case "LAB":
			return new LaboratoryComponent(criterion);
		case "LINES":
			return new LinesTubesDrainsComponent(criterion);
		case "MEDS":
			return new MedicationsComponent(criterion);
		case "MED_REC":
			return new MedicationReconciliationComponent(criterion);
		case "WF_MBIOLOGY":
			return new MicrobiologyComponentWF(criterion);
		case "MICRO":
			return new MicrobiologyComponent(criterion);
		case "NC_DC_PLAN":
			return new DischargePlanComponent(criterion);
		case "NC_OVERDUE_TASKS":
		case "OVERDUE_TASKS":
			return new TaskActivityComponent(criterion);
		case "NC_PLAN":
			return new PlanofCareComponent(criterion);
		case "NC_PSYCHOSOC":
			return new PsychosocialFactorsComponent(criterion);
		case "NC_PT_ASSESS":
			return new PatientAssessmentComponent(criterion);
		case "NC_PT_BACKGROUND":
			return new PatientBackgroundComponent(criterion);
		case "NEO_OVERVIEW":
			return new NeonateOverviewComponent(criterion);
		case "NEO_TASK_TIMELINE":
			return new NeonateTaskTimelineComponent(criterion);
		case "NEO_WEIGHT":
			return new NeonateMeasurementComponent(criterion);
		case "NEO_HYPERBILI":
			return new NeonateBilirubinComponent(criterion);
		case "NEO_TRANSFUSION":
			return new NeonateTransfusionComponent(criterion);
		case "NEW_DOC":
			return new NewDocumentEntryComponent(criterion);
		case "NEW_ORDERS":
			return new NewOrderEntryComponent(criterion);
		case "NOTES":
			return new NotesRemindersComponent(criterion);
		case "PATH":
			return new PathologyComponent(criterion);
		case "PAT_ED":
		case "PT_ED":
			return new PatientFamilyEduSumComponent(criterion);
		case "PRECAUTIONS":
			return new PrecautionsComponentO1(criterion);
		case "PREG_ASSESS":
			return new PresAssessInitialExamComponent(criterion);
		case "PREG_ASSESS_2":
			return new PregAssessment2Component(criterion);
		case "PREG_ASSESS_3":
			return new PregAssessment3Component(criterion);
		case "PREG_BIRTH_PLAN":
			return new BirthPlanComponent(criterion);
		case "PREG_ED":
			return new EducationAndCounselingComponent(criterion);
		case "PREG_EDD_MAINT":
			return new EDDMaintenanceComponent(criterion);
		case "PREG_FETAL_MON":
			return new FetalMonitoringComponent(criterion);
		case "PREG_GENETIC_SCR":
			return new GeneticScreeningComponent(criterion);
		case "PREG_HX":
			return new PregnancyHistoryComponent(criterion);
		case "PREG_OVERVIEW":
			return new PregnancyOverviewComponent(criterion);
		case "PREG_RESULTS":
			return new ResultTimelineComponent(criterion);
		case "PT_INFO":
			return new PatientInfoComponent(criterion);
		case "RAD":
			return new DiagnosticsComponent(criterion);
		case "RESP":
			return new RespiratoryComponent(criterion);
		case "RESP_ASSESS":
			return new RespAssessmentsComponent(criterion);
		case "RESP_TX":
			return new RespTreatmentsComponent(criterion);
		case "SIG_EVENTS":
			return new SignificantEventO1Component(criterion);
		case "SOCIAL_HX":
			return new SocialHistoryComponent(criterion);
		case "SURG_PROC_HX":
			return new Procedure2Component(criterion);
		case "TREATMENTS":
			return new TreatmentsComponentO1(criterion);
		case "TRIAGE_DOCUMENT":
			return new TriageDocComponent(criterion);
		case "VISITS":
			return new VisitsComponent(criterion);
		case "VS":
			return new VitalSignComponent(criterion);
		case "WF_RAD":
			return new DiagnosticsComponent2(criterion);
		case "WF_VS":
			return new VitalSignComponentWF(criterion);
		case "WEIGHT":
			return new WeightsComponent(criterion);
		case "WF_MEDS":
			return new MedicationsComponentO2(criterion);
		case "PROC_INFO":
			return new ProceduralInfoComponent(criterion);
		case "PERIOP_TRACK":
			return new PeriopTrackComponent(criterion);
		case "INTRAOP_SUMMARY":
			return new IntraopSummaryComponent(criterion);
		case "PREOP_CHECKLIST":
			return new PreopChcklstComponent(criterion);
		case "POSTOP_SUMMARY":
			return new PostopSummaryComponent(criterion);
		case "EP_DA":
			return new DiscernAnalyticsComponent(criterion);
		case "DMS_REFERENCE":
			return new ClinicalDecSuppComponent(criterion);
		case "DMS_SCREENINGS":
			return new ScreeningsComponent(criterion);
		case "DMS_DIET":
			return new DietsComponent(criterion);
		case "DMS_ANTIDIABETIC":
			return new MedsSpecificComponent(criterion);
		case "DMS_MEDS_GLUC_LVL":
			return new MedsGlucoseComponent(criterion);
		case "DMS_INS_24_HRS":
			return new InsulinReqComponent(criterion);
		case "DMS_GRAPH":
			return new DiabetesGraphComponent(criterion);
		case "CLIN_TRIALS":
			return new ClinicalTrialsComponent(criterion);
		case "CHEMO_REVIEW":
			return new ChemotherapyReviewComponent(criterion);
		case "WF_ASSESSMENT_PLAN":
			return new DocumentationIPComponent(criterion);
		case "WF_CHIEF_COMPLAINT":
			return new ChiefComplaintComponent(criterion);
		case "WF_FLD_BAL":
			return new IntakeOutputOpt2Component(criterion);
		case "WF_HOME_MEDS":
			return new HomeMedicationsComponent2(criterion);
		case "WF_HX_PRESENT_ILL":
			return new DocumentationHPIComponent(criterion);
		case "WF_NEW_ORDERS":
			return new NewOrderEntryO2Component(criterion);
		case "WF_ORDER_PROFILE":
			return new OrderProfileComponent(criterion);
		case "WF_PHYSICAL_EXAM":
			return new DocumentationPEComponent(criterion);
		case "WF_REVIEW_SYMPT":
			return new DocumentationROSComponent(criterion);
		case "THER_TREAT":
			return new TherTreatmentComponent(criterion);
		case "SAFETY":
			return new SafetyComponent(criterion);
		case "BH_ASSESSMENTS":
			return new BhAssessmentComponent(criterion);
		default:
			logger.logMessage("Unknown filter mean: [" + compFilterMean + "]. The component may have been deprecated, or it failed to be loaded in the static content.");
			return new DummyComponent(criterion);
	}
	/*eslint-enable no-undef*/
};

/**
 * Creates a new instance of a render strategy. By default, it returns a Summary Render Strategy
 * @return {RenderStrategy} Returns a new RenderStrategy for this MPagesView
 */
MPageView.prototype.createNewRenderStrategy = function() {
	return new SummaryRenderStrategy();
};

/**
 * Used to render the MPages View once it has been initialized and setup.  Calls the MP_Util.Doc.InitLayout function to render the
 * HTML of the page layout.  Once the page layout has been rendered, the Chart Search functionality and demo banner are added to
 * the MPage View.  Finally the component script calls are executed within the MP_Util.Doc.RenderLayout() function call.  It is
 * not recommended to override this function.  If special logic needs to be executed when loading the Chart Search functionality
 * or loading the Demographics Banner, those specific functions can be overridden instead.
 * @return {boolean} True if the page was rendered successfully, false otherwise
 */
MPageView.prototype.renderView = function() {
	/*eslint-disable new-cap*/
	var timerRenderView = MP_Util.CreateTimer("ENG:MPG.MPageView - renderMPage", this.getCategoryMean());
	/*eslint-enable new-cap*/
	var component = null;
	var componentList = null;
	var componentCount = 0;
	var groups = [];
	var group = null;
	var collapsedComponents = [];
	var numberRows = 0;
	var numberGroups = 0;

	try {
		
		//Check to see if this view is even valid in the current context.
		if(!this.isContextValid()){
			//The current context is not valid for this view so we need to show a context error message
			this.displayInvalidContextMessage();
			return;
		}
		
		// Create the aggregate timer object to measure page load time
		var aggregateTimer = this.createAggregateTimer();
		// Mark the timer as started because it is already started either in the driver script or in ViewPoint before the view is initialized.
		aggregateTimer.markTimerStarted();

		//Store the container, so we can easily access it later
		this.setContainer($("#" + this.getCategoryMean()));

		//Check to see if any component are defined for this MPageView.  Return if there are not any
		componentList = this.getComponents();
		if (!(componentList && componentList.length)) {
			throw new Error(i18n.VIEW_SETTINGS_UNAVAILABLE);
		}

		//get the total number of components
		componentCount = componentList.length;

		//Render the component shells
		this.renderComponents(componentList);

		//Get the component list as the group/column list
		componentList = MP_Util.GetComponentArray(componentList);

		//Create the page level menu
		this.loadPageMenu();

		//Additional page setup
		MP_Util.Doc.AddCustomizeLink(this.getCriterion());
		MP_Util.Doc.SetupExpandCollapse(this.getCategoryMean());
		MP_Util.Doc.SetupCompFilters(this.getComponents());
		MP_Util.Doc.CreateCompMenus(this.getComponents(), false);

		numberGroups = componentList.length;

		window.setTimeout(function() {
			//the number of all displayable components
			var initialComponentCount = 0;
			var i = 0;
			var j = 0;
			var k = 0;
			//Create the correct ordering
			for (i = 0; i < numberGroups; i++) {
				groups[i] = {};
				groups[i].ROWS = [];
				group = componentList[i];
				var numberColumns = group.length;
				//Iterate through the columns of the group
				for (j = 0; j < numberColumns; j++) {
					var column = group[j];
					numberRows = column.length;
					for (k = 0; k < numberRows; k++) {
						component = column[k];
						if (!groups[i].ROWS[k]) {
							groups[i].ROWS[k] = [];
						}
						if (component.isDisplayable() && component.isExpanded() && !component.isLoaded()) {
							groups[i].ROWS[k].push(component);
						}
						else if (component.isDisplayable() && !component.isExpanded() && !component.isLoaded()) {
							collapsedComponents.push(component);
						}
					}
				}
			}
			//Start the data retrieval for expanded components
			for (i = 0; i < numberGroups; i++) {
				group = groups[i];
				numberRows = group.ROWS.length;
				for (j = 0; j < numberRows; j++) {
					var row = group.ROWS[j];
					var numberComponents = row.length;
					for (k = 0; k < numberComponents; k++) {
						component = row[k];
						component.setLoaded(true);
						// register the component in the aggregate timer before data retrieval begins
						aggregateTimer.registerTask(component.getStyles()
							.getId());
						// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
						component.setAggregateTimer(aggregateTimer);
						//count the component because it will be loaded
						initialComponentCount++;
						component.startComponentDataRetrieval();
					}
				}
			}
			//Now start the data retrieval for the collapsed components
			for (i = 0; i < collapsedComponents.length; i++) {
				component = collapsedComponents[i];
				component.setLoaded(true);
				// register the component in the aggregate timer before data retrieval begins
				aggregateTimer.registerTask(component.getStyles()
					.getId());
				// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
				component.setAggregateTimer(aggregateTimer);
				//count the component because it will be loaded
				initialComponentCount++;
				component.startComponentDataRetrieval();
			}

			//add the total number of components to meta data
			aggregateTimer.addMetaData("component.count", componentCount);

			//add the number of initially loaded components to meta data (all components are loaded in initial load)
			aggregateTimer.addMetaData("component.initialLoadCount", initialComponentCount);

			// Lock the registration when initial loading components are registered.
			aggregateTimer.lockRegistration();
		}, 0);
		return true;
	}
	catch (err) {
		if (timerRenderView) {
			timerRenderView.Abort();
			timerRenderView = null;
		}
		logger.logJSError(err, null, "MPageView.js", "renderView");
		throw err;
	}
	finally {
		if (timerRenderView) {
			timerRenderView.Stop();
		}
	}
};

/**
 * This function renders the components in the correct layout format
 * @param {Array} components The list of components to render
 * @param {Object} parentContainer The DOM element that will contain all of the rendered components.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.renderComponents = function(components, parentContainer) {
	if (!components || !components.length) {
		logger.logError("No components were provided to the renderComponents() method");
		return;
	}
	this.storeViewComponents(components);
	var columnArray = null;
	var componentGroupArray = MP_Util.GetComponentArray(components);
	var container = this.getContainer() || parentContainer;
	for (var x = 0; x < componentGroupArray.length; x++) {
		columnArray = componentGroupArray[x];
		var columnLength = columnArray.length;
		var columnSuperDiv = $("<div></div>")
			.addClass("col-group");
		$(container)
			.append($("<div></div>")
				.append(columnSuperDiv));
		switch (columnLength) {
			case 1:
				columnSuperDiv.addClass("one-col");
				break;
			case 2:
				columnSuperDiv.addClass("two-col");
				break;
			case 3:
				columnSuperDiv.addClass("three-col");
				break;
			case 4:
				columnSuperDiv.addClass("four-col");
				break;
			default:
				columnSuperDiv.addClass("five-col");
		}
		var outerCol1 = $("<div></div>")
			.addClass("col-outer1");
		var outerCol2 = $("<div></div>")
			.addClass("col-outer2");
		outerCol2.append(outerCol1);
		columnSuperDiv.append(outerCol2);
		for (var y = 0; y < columnLength; y++) {
			var columnClassName = "col" + (y + 1);
			var componentArray = columnArray[y];
			var columnDiv = $("<div></div>")
				.addClass(columnClassName)
				.appendTo(outerCol1);
			for (var z = 0, zl = componentArray.length; z < zl; z++) {
				var component = componentArray[z];
				//Give the component a render strategy based on the view you are in
				component.setRenderStrategy(this.createNewRenderStrategy());
				columnDiv.append(component.getRenderStrategy()
					.createComponentShell());
			}
		}
	}
};

/**
 * Any post processing that needs to be completed by the MPageView object will be completed in this function.  No functionality has
 * been implemented at this time for the base function, but this can be overridden in objects which prototype the MPagesView object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.postProcessing = function() {

};


/**
 * Stores the components in the CERN_MPageComponents global object
 * @param {Array} components The list of MpageComponents to store in the global object
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.storeViewComponents = function(components) {
	MP_Util.addComponentsToGlobalStorage(components);
};

/** Support functions used for the MPageView objects **/

/**
 * Loads the default MPage View level filter mappings.  These mappings can be overwritten by using the
 * MPageView.setFilterMappingObject() function with the same name as any of the existing filter mappings.  Filter mappings can also
 * be overridden by defining a loadFilterMappings function in a MPageView prototyped
 * object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.loadFilterMappings = function() {
	//A filter mapping that indicates whether the Chart Search will be displayed.
	this.addFilterMappingObject("CHART_SEARCH", {
		setFunction: this.setChartSearchEnabled,
		type: "Boolean",
		field: "FTXT"
	});
	//A filter mapping that indicates whether the Discharge Process will be displayed.
	this.addFilterMappingObject("DISCHARGE_PROCESS", {
		setFunction: this.setDischargeProcessEnabled,
		type: "Boolean",
		field: "FTXT"
	});
	//A filter mapping used to set the Label/name of an MPages View.  This name is used for the actual MPage name and the name used on
	// the viewpoint tab.
	this.addFilterMappingObject("VIEWPOINT_LABEL", {
		setFunction: this.setName,
		type: "String",
		field: "FTXT"
	});
	//A filter mapping used to set the printable report name.
	//The filter mean for this setting is named PREG_PRINT but it is not isolated to just the Pregnancy Summary.  It also applies to the
	// View Builder MPages as well and is a setting to call a printable Discern report.
	this.addFilterMappingObject("PREG_PRINT", {
		setFunction: this.setPrintableReportName,
		type: "String",
		field: "FTXT"
	});
};

/**
 * Base implementation for loading the component selection menu.  This option is not supported in all MPages, thus this function
 * should be implemented in the individual MPagesView Objects.
 * @return {Boolean} True if the component selection menu option was added to the page, false otherwise.
 */
MPageView.prototype.loadComponentSelection = function() {
	return null;
};

/**
 * If the m_printableReport element is populated for the MPageView then add the Print Report menu option to the page menu.
 * @return {Boolean} True if the Printable Report menu option was added to page, false otherwise.
 */
MPageView.prototype.loadPrintableReportMenuItem = function() {
	var criterion = this.getCriterion();
	var printItem = null;
	var printReport = this.getPrintableReportName();

	//Check to see if this MPageView has a printable report
	if (!printReport) {
		return null;
	}
	//Create the menu item since a printable report name has been retrieved
	printItem = new MenuSelection("printReport" + this.getCategoryMean());
	printItem.setLabel(i18n.PRINT_REPORT);
	printItem.setClickFunction(function() {
		MP_Util.PrintReport(printReport, criterion.person_id + ".0", criterion.encntr_id + ".0");
	});
	return printItem;
};

/**
 * Adds help menu item to the page level menu.
 * @return {Boolean} True if the help menu option was added to page, false otherwise.
 */
MPageView.prototype.loadHelpMenuItem = function() {
	var helpMenuItem = null;
	var that = this;

	//Create the menu item that will be added to the page level menu
	helpMenuItem = new MenuSelection("helpMenu" + this.getCategoryMean());
	helpMenuItem.setLabel(i18n.discernabu.HELP);
	helpMenuItem.setClickFunction(function() {
		MP_Util.Doc.LaunchHelpWindow(that.getHelpFileURL());
	});
	return helpMenuItem;
};

/**
 * Adds expand/collapse menu item to the page level menu.
 * @return {Boolean} True if the Expand/Collapse menu option was added to page, false otherwise.
 */
MPageView.prototype.loadExpandCollapseAllMenuItem = function() {
	var categoryMean = this.getCategoryMean();
	var expColItem = null;
	var i18nCore = i18n.discernabu;
	var that = this;

	expColItem = new MenuSelection("expandCollapse" + categoryMean);
	expColItem.setLabel(i18nCore.EXPAND_ALL);
	expColItem.setCloseOnClick(false);
	expColItem.setSelectedClass("");
	expColItem.setClickFunction(function() {
		var toggleContainer = null;
		try {
			toggleContainer = that.getContainer();
			if (!toggleContainer.length) {
				logger.logWarning("The container that houses the components to be toggled was not found");
				return false;
			}
			if (that.isAllExpanded()) {
				//All components are currently expanded
				$(toggleContainer)
					.find(".section")
					.addClass("closed");
				expColItem.setLabel(i18nCore.EXPAND_ALL);
				$(toggleContainer)
					.find(".sec-hd-tgl")
					.attr("title", i18nCore.SHOW_SECTION);
			}
			else {
				//All components are currently collapsed
				$(toggleContainer)
					.find(".section")
					.removeClass("closed");
				expColItem.setLabel(i18nCore.COLLAPSE_ALL);
				$(toggleContainer)
					.find(".sec-hd-tgl")
					.attr("title", i18nCore.HIDE_SECTION);
			}
			//Invert boolean for whether components are expanded or collapsed
			that.setIsAllExpanded(!that.isAllExpanded());
		}
		catch (err) {
			logger.logJSError(err, null, "MPageView.js", "toggleExpandCollapse");
		}
	});
	return expColItem;
};

/**
 * Creates the MPage View level timer objects based on the m_capTimerName and m_subTimerName strings set in the individual MPageView
 * prototyped objects, ie DischargeSummaryMPage.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.createMPageTimerObject = function() {
	var capTimerName = this.getCapTimerName();
	var subTimerName = this.getSubTimerName();
	if (capTimerName) {
		var rtmsTimer = new RTMSTimer(capTimerName, subTimerName);
		rtmsTimer.start();
		rtmsTimer.stop();
	}
};

/**
 * This function is used to retrieve the settings for a specific MPage View.  If the settings are already available in the
 * m_bedrockMPage object then those will be returned.  If the settings are not available then they will be retrieved using
 * the mp_view_data_load script.
 * @return {Object} An object which contains the settings for this MPageView object.
 */
MPageView.prototype.getViewSettingsObject = function() {
	var x = 0;
	var categoryMean = this.getCategoryMean();
	var criterion = this.getCriterion();
	var viewSettings = null;

	//See if the page settings are already available
	if (m_bedrockMpage) {
		for (x = m_bedrockMpage.MPAGE.length; x--;) {
			if (categoryMean === m_bedrockMpage.MPAGE[x].SETTINGS.C_MN.toUpperCase()) {
				return m_bedrockMpage.MPAGE[x].SETTINGS;
			}
		}
	}
	
	//The debug_ind contains various settings which are documented here: https://wiki.ucern.com/display/associates/Discern+ABU+Development+Liaison+-+MP_UNIFIED_DRIVER+Usage#DiscernABUDevelopmentLiaison-MP_UNIFIED_DRIVERUsage-DEBUGMAP
	//The 2^3 bit (decimal 8) signifies if the the cached bedrock settings should be ignored.
	var ignoreCache = ((parseInt(criterion.debug_ind, 10) & 0x08) === 8) ? 1 : 0;
	
	//Page settings not available.  Retrieve them from the Database.
	//Check the ignore cache setting
	var settingsRequest = new ScriptRequest();
	settingsRequest.setName("View Settings Retrieval");
	settingsRequest.setProgramName("MP_GET_MPAGE_SETTINGS");
	settingsRequest.setParameterArray(["^MINE^", "^" + categoryMean + "^", criterion.provider_id + ".0", criterion.position_cd + ".0", 0, ignoreCache, criterion.encntr_id + ".0"]);
	settingsRequest.setAsyncIndicator(false);
	settingsRequest.setRawDataIndicator(true);
	settingsRequest.setResponseHandler(function(scriptReply) {
		try {
			var response = scriptReply.getResponse();
			m_bedrockMpage = JSON.parse(response).MP_SETTINGS;
			viewSettings = m_bedrockMpage.MPAGE[0].SETTINGS;
		}
		catch (err) {
			logger.logJSError(err, null, "MPageView.js", "getViewSettingsObject");
			viewSettings = null;
		}
	});
	settingsRequest.performRequest();
	return viewSettings;
};

/**
 * This function creates the layout menu where users will select between a one to three column view.
 * @return {Menu} Returns the menu that will be used as the layout selector.
 */
MPageView.prototype.createLayoutMenu = function() {
	var categoryMean = this.getCategoryMean();
	var mPageObj = this;

	var layoutSelector = new DynamicMenu("layoutSelction" + categoryMean);
	layoutSelector.setLabel(i18n.discernabu.VIEW_LAYOUT);
	layoutSelector.setIsRootMenu(false);
	layoutSelector.setAnchorConnectionCorner(["top", "left"]);
	layoutSelector.setContentConnectionCorner(["top", "right"]);
	layoutSelector.setContentCreationFunction(function() {
		var col1 = null;
		var col2 = null;
		var col3 = null;
		var curColGroupClass = "";
		var i18nCore = i18n.discernabu;
		var initialColCnt = 0;
		var layoutClasses = [];
		var menuContainer = null;
		var menuSeperator = null;
		var resetLayout = null;
		//Determine Which dom element to examine to get the column layout
		var vpParent = typeof m_viewpointJSON === "string" ? "#" + categoryMean + " " : "";
		//Determine how many columns are currently being shown so we can highlight that element in the menu
		var colGroups = $(vpParent + ".col-group:last");
		if (colGroups.length) {
			curColGroupClass = $(colGroups)
				.attr("class")
				.replace("col-group ", "");
		}
		switch (curColGroupClass) {
			case "three-col":
				initialColCnt = 3;
				break;
			case "two-col":
				initialColCnt = 2;
				break;
			case "one-col":
				initialColCnt = 1;
				break;
		}

		//create the menu contents
		menuContainer = $("<div></div>")
			.addClass("menu-layout-menu")
			.attr("id", layoutSelector.getId());
		layoutClasses = ["view-layout1", "view-layout2", "view-layout3"];
		layoutClasses[initialColCnt - 1] += " view-layout-selected";
		//Apply click events to each col section
		categoryMean = vpParent ? categoryMean : "";
		col1 = $("<div class='" + layoutClasses[0] + "' data-cols='1'>" + i18nCore.COLUMN_ONE + "</div>")
			.click(function() {
				//Update the selectedClass
				var selectorId = layoutSelector.getId();
				$("#" + selectorId + " .view-layout-selected")
					.removeClass("view-layout-selected");
				$("#" + selectorId + " .view-layout1")
					.addClass("view-layout-selected");
				//Update the layout
				if (colGroups.length) {
					mPageObj.changeLayout(1, categoryMean);
				}
			});

		col2 = $("<div class='" + layoutClasses[1] + "' data-cols='2'>" + i18nCore.COLUMN_TWO + "</div>")
			.click(function() {
				//Update the selectedClass
				var selectorId = layoutSelector.getId();
				$("#" + selectorId + " .view-layout-selected")
					.removeClass("view-layout-selected");
				$("#" + selectorId + " .view-layout2")
					.addClass("view-layout-selected");
				//Update the layout
				if (colGroups.length) {
					mPageObj.changeLayout(2, categoryMean);
				}
			});

		col3 = $("<div class='" + layoutClasses[2] + "' data-cols='3'>" + i18nCore.COLUMN_THREE + "</div>")
			.click(function() {
				//Update the selectedClass
				var selectorId = layoutSelector.getId();
				$("#" + selectorId + " .view-layout-selected")
					.removeClass("view-layout-selected");
				$("#" + selectorId + " .view-layout3")
					.addClass("view-layout-selected");
				//Update the layout
				if (colGroups.length) {
					mPageObj.changeLayout(3, categoryMean);
				}
			});

		resetLayout = $("<div class='reset-layout' data-cols='0'>" + i18nCore.RESET_LAYOUT + "</div>")
			.click(function() {
				//Update the layout
				if (colGroups.length) {
					MP_Util.Doc.ResetLayoutSettings(mPageObj);
				}
			});
		menuSeperator = $("<div></div>")
			.addClass("menu-item")
			.addClass("menu-separator");
		//Append the layout selections
		$(menuContainer)
			.append(col1, col2, col3, menuSeperator, resetLayout);
		//Rerturn the jQuery object
		return menuContainer;
	});
	return layoutSelector;
};

/**
 * This function creates the menu item which will be used to clear use preferences.
 * @return {MenuSelection} This function returns the MenuSelection which can be used to clear user preferences
 */
MPageView.prototype.createClearPrefsMenuItem = function() {
	var clearPrefs = new MenuSelection("clearPrefs" + this.getCategoryMean());
	clearPrefs.setLabel(i18n.discernabu.CLEAR_PREFERENCES);
	clearPrefs.setCloseOnClick(true);
	clearPrefs.setClickFunction(function() {
		var i18nCore = i18n.discernabu;
		var confirmMsg = i18nCore.CLEAR_ALL_PREFS + "<br />" + i18nCore.CLEAR_ALL_PREFS_CANCEL;
		MP_Util.AlertConfirm(confirmMsg, i18nCore.CLEAR_PREFERENCES, i18nCore.CONFIRM_CLEAR, i18nCore.CONFIRM_CANCEL, true, MP_Core.AppUserPreferenceManager.ClearPreferences);
	});
	return clearPrefs;
};

/**
 * This function creates the MenuSelection element that allows users to frag and drop MPage components.
 * @return {MenuSelection} The MenuSelection object which will be used to toggle drag and drop on and off
 */
MPageView.prototype.loadDragAndDropMenuItem = function() {
	var categoryMean = this.getCategoryMean();
	var parentEleId = "";

	var activeView = $("#" + categoryMean);
	if (activeView.length) {
		parentEleId = "#" + categoryMean;
	}
	else {
		activeView = $(document.body);
	}

	var self = this;
	var dnd = new MenuSelection("dragNDrop" + categoryMean);
	dnd.setLabel(i18n.DRAG_AND_DROP);
	dnd.setCloseOnClick(false);
	dnd.setClickFunction(function() {
		if (dnd.isSelected()) {
			//Add the Drag and Drop css class from the view container
			$(activeView)
				.addClass("dnd-enabled");

			//initialize Drag and Drop if not initialized yet. Otherwise simply enabled it.
			if (self.m_dragNDropInitialized) {
				// re-enables sortable
				$(parentEleId + " .col-outer1:last .col1," + parentEleId + " .col-outer1:last .col2," + parentEleId + " .col-outer1:last .col3")
					.sortable("enable");
				// update the cursor back to the move icon
				$(parentEleId + " .col-outer1:last .sec-hd")
					.css("cursor", "move");
			}
			else {
				//drag and drop is enabled as part of the initialization
				self.initDragAndDrop(categoryMean);
				//set the flag to true so it won't initialize again when the menu item is clicked
				self.m_dragNDropInitialized = true;
			}
		}
		else {
			//Remove the Drag and Drop css class from the view container
			$(activeView)
				.removeClass("dnd-enabled");

			//Disables Drag and Drop in the View
			$(parentEleId + " .col-outer1:last .col1," + parentEleId + " .col-outer1:last .col2," + parentEleId + " .col-outer1:last .col3")
				.sortable("disable");
			//Update the cursor to switch from the move icon to auto
			$(parentEleId + " .col-outer1:last .sec-hd")
				.css("cursor", "auto");
		}
	});
	return dnd;
};

/**
 * Initialize the Drag and Drop function for the components
 * @param {String} categoryMeaning The category mean of the current view
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.initDragAndDrop = function(categoryMeaning) {
	var parentElement = null;
	var self = this;
	var vpParent = "";
	if (categoryMeaning && typeof m_viewpointJSON === "string") {
		vpParent = "#" + categoryMeaning + " ";
	}
	var compSelectorStr = vpParent + " .col-outer1:last .col1," + vpParent + " .col-outer1:last .col2," + vpParent + " .col-outer1:last .col3";
	var components = $(compSelectorStr);

	components.sortable({
		connectWith: compSelectorStr + " ",
		items: " .section",
		zIndex: 1005,
		appendTo: "body",
		handle: "h2",
		over: function(event, ui) {
			if (ui.sender && $(this).attr("class") !== ui.sender.attr("class")) {
				$(this).css("z-index", "1");
			}
		},
		start: function(event, ui) {
			$(this)
				.css("z-index", "2");
			ui.item.css("z-index", "2");

			// get sortable containers, assuming connectWith is NOT optimized
			var containers = $(this)
				.parent()
				.children();

			var tallest = 0;
			// may not need height: auto
			containers.height("auto");
			containers.each(function() {
				if ($(this)
					.height() > tallest) {
					tallest = $(this)
						.height();
				}
			});

			containers.height(tallest + $(ui.item)
				.height());
		},
		stop: function(event, ui) {
			ui.item.css("z-index", "1");
			$(this)
				.css("z-index", "1");
			if (ui.sender) {
				ui.sender.css("z-index", "1");
			}
			CERN_EventListener.fireEvent(null, self, EventListener.EVENT_COMP_CUSTOMIZE, null);
			// get sortable containers, assuming connectWith is NOT optimized
			var containers = $(this)
				.parent()
				.children();
			// set height back to their natural height
			containers.height("auto");
		},
		update: function(event, ui) {
			//only write preference when the destination DOM is updated
			if (this === ui.item.parent()[0]) {
				setTimeout(function() {
					MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(self.getComponents(), true, true);
				}, 0);
			}
		}
	});

	//Determine if the drag and drop should be active or not
	parentElement = vpParent ? $(vpParent) : $(document.body);
	if ($(parentElement)
		.hasClass("dnd-enabled")) {
		components.sortable("enable");
		$(vpParent + " .col-outer1:last .sec-hd")
			.css("cursor", "move");
	}
	else {
		components.sortable("disable");
		$(vpParent + " .col-outer1:last .sec-hd")
			.css("cursor", "auto");
	}
};

/**
 * This function changes the layout of the current view with a different number of columns
 * @param {Number} newColCnt Number of columns of the new layout
 * @param {String} catMean Category Mean of the current view
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.changeLayout = function(newColCnt, catMean) {
	var viewpointState = catMean ? "#" + catMean + " " : "";
	var colClasses = ["one-col", "two-col", "three-col"];
	var curColCnt;
	var curColGroupClass = $(viewpointState + ".col-group:last")
		.attr("class")
		.replace("col-group ", "");

	switch (curColGroupClass) {
		case "three-col":
			curColCnt = 3;
			break;
		case "two-col":
			curColCnt = 2;
			break;
		case "one-col":
			curColCnt = 1;
			break;
	}

	if (newColCnt < curColCnt) { //removing columns
		var comps = null;
		if (newColCnt === 1) {
			comps = $(viewpointState + ".col-group:last .section")
				.not(viewpointState + ".col1 .section");
			$(viewpointState + ".col-group:last .col1")
				.append(comps);
			$(viewpointState + ".col-group:last .col2")
				.remove();
			$(viewpointState + ".col-group:last .col3")
				.remove();
		}
		else if (newColCnt === 2) {
			comps = $(viewpointState + ".col-group:last .col3 .section");
			$(viewpointState + ".col-group:last .col2")
				.append(comps);
			$(viewpointState + ".col-group:last .col3")
				.remove();
		}
		//save new layout
		setTimeout(function() {
			MP_Core.AppUserPreferenceManager.SaveCompPreferences(null, "", null, true);
		}, 0);

		$(viewpointState + ".col-group:last")
			.attr("class", "col-group " + colClasses[newColCnt - 1]);
	}
	else if (newColCnt > curColCnt) { //adding columns
		if ((newColCnt - curColCnt) === 1) {
			var colHTML = (curColCnt == 1) ? "<div class='col2'></div>" : "<div class='col3'></div>";
			$(viewpointState + ".col-outer1:last")
				.append(colHTML);
		}
		else if ((newColCnt - curColCnt) === 2) {
			$(viewpointState + ".col-outer1:last")
				.append("<div class='col2'></div><div class='col3'></div>");
		}

		$(viewpointState + ".col-group:last")
			.attr("class", "col-group " + colClasses[newColCnt - 1]);
		this.initDragAndDrop(catMean);
	}
};

/**
 * Loads the page menu for a specific MPageView object.
 * @return {undefined} This function does not return a value
 */
MPageView.prototype.loadPageMenu = function() {
	var categoryMean = this.getCategoryMean();
	var tempMenuItem = null;
	
	//Create the menu object for this page
	var pageMenu = new Menu("pageMenu" + categoryMean);
	pageMenu.setTypeClass("menu-page-menu");
	pageMenu.setIsRootMenu(true);
	pageMenu.setAnchorElementId("pageMenu" + categoryMean);
	pageMenu.setAnchorConnectionCorner(["bottom", "right"]);
	pageMenu.setContentConnectionCorner(["top", "right"]);
	pageMenu.setLabel("");

	//Create the layout selector menu item
	tempMenuItem = this.createLayoutMenu();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Create the drag and drop menu item
	tempMenuItem = this.loadDragAndDropMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Expand/Collapse Menu Option
	tempMenuItem = this.loadExpandCollapseAllMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Component Selection menu option
	tempMenuItem = this.loadComponentSelection();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Print report menu item
	tempMenuItem = this.loadPrintableReportMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Add a seperator
	pageMenu.addMenuItem(new MenuSeparator("separator"));

	//Create the clear preferences menu item
	tempMenuItem = this.createClearPrefsMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Create the clear preferences menu item
	tempMenuItem = this.loadHelpMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Add the menu object to the menu manager
	MP_MenuManager.addMenuObject(pageMenu);

	//Update the click event on the menu to launch this menu when clicked.
	$("#pageMenu" + categoryMean)
		.unbind("click")
		.click(function() {
			if (pageMenu.isActive()) {
				MP_MenuManager.closeMenuStack(true);
			}
			else {
				MP_MenuManager.showMenu("pageMenu" + categoryMean);
			}
		});
};
/**
 * A constructor used to create a new DummyMPage object
 * @constructor
 */
DummyMPage = function(){
	//Log info for debugger
	logger.logMessage("Rendering Dummy MPages View");
};

/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
DummyMPage.prototype = new MPageView();
DummyMPage.prototype.constructor = MPageView;

/**
 * It overrides the base initializeView to do nothing and simply return true.
 * @returns {boolean} Whether it has initialized view successfully
 */
DummyMPage.prototype.initializeView = function() {
	// There's nothing to initialize, so it's always successful. 
	return true;
};

/**
 * It overrides the base loadViewSettings to do nothing and simply return true.
 * @returns {boolean} Whether it has loaded the view settings successfully
 */
DummyMPage.prototype.loadViewSettings = function() {
	// There's nothing to load, so it's always successful. 
	return true;
};

/**
 * It overrides the base initializeComponents to do nothing and simply return true. 
 * @return {boolean} True if the component settings were initialized properly, false otherwise
 */
DummyMPage.prototype.initializeComponents = function() {
	// There're no components to load because this page is no longer available. 
	// So it is always completed successfully. 
	return true;
};


/**
 * It renders the informational text on the view. 
 * @return {boolean} True if the page was rendered successfully, false otherwise
 */
DummyMPage.prototype.renderView = function() {
	//Store the container, so we can easily access it later
	this.setContainer($("#" + this.getCategoryMean()));

	//Initialize a new alert banner instance
	var alertBanner = new MPageUI.AlertBanner();

	//Set the type of alert banner to be displayed
	alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.INFO);

	//Set the primary text for the alert banner
	alertBanner.setPrimaryText(i18n.discernabu.MPageView.VIEW_NOT_AVAILABLE);
	
	$(this.getContainer()).html(alertBanner.render());

	return true;
};

/**
 * It overrides the base resizeView function since this page only displays an informational text. 
 * There's no need to have special logic in JavaScript for resizing. 
 * @returns {undefined} This function does not return a value
 */
DummyMPage.prototype.resizeView = function() {};
/**
 * This WebPVContxtMpage object is the web equivalent of PVCONTXTMPAGE
 */
var WebPVContxtMpage = {
  patientId : 0.0,
  validEncounters : ""
};

/**
 * The function to get the valid encounters for the patient id passed.
 * Make a call to retrieve viewable encounters from clinical context service, using the script mp_exec_std_request.
 * The clinical context service (msvc_svr_get_clinctx, 3200310) will return the authorized (viewable) encounters for the patient in context:
 * Application Number: 3202004
 * Task Number: 3202004
 * Request Number: 3200310
 * This logic will be consumed when PVCONTXTMPAGE is not available
 * @param {Number} patientId - unique identifier for patient.
 * @returns {String} viewableEncounters returns the viewableEncounters for passed patientId
 */

WebPVContxtMpage.GetValidEncounters = function(patientId) {
	var self = this;
	// return validEncounter if it is already available for the patientId
	if(self.patientId === patientId && self.validEncounters) {
		return self.validEncounters;
	} 
	var viewableEncounters = "";
	var request = new ScriptRequest();
	var programName = "mp_exec_std_request";
	var jsonString = '{"REQUESTIN":{"PATIENT_ID":' + patientId + '.0,"LOAD":{"AUTH_ENCOUNTER":1}}}';
	var params = ['^MINE^', '~' + jsonString + '~', 3202004, 3202004, 3200310];
	request.setProgramName(programName);
	request.setParameterArray(params);
	request.setAsyncIndicator(false);
	request.setResponseHandler(function(replyObj) {
		if (replyObj.getStatus() === "S") {
			try {
				var recordData = replyObj.getResponse();
				viewableEncounters = $.map(recordData.AUTH_ENCOUNTER.AUTH_ENCOUNTERS, function(o) {
					return o.ENCOUNTER_ID + ".0";
				}).join(",");
				logger.logDebug("Viewable Encounters obtained from ClinicalContext service: " + viewableEncounters);
			} catch(err) {
				logger.logJSError(err, self, "PVCONTXTMPAGE.js", "GetValidEncounters");
				throw new Error("PVCONTXTMPAGE: Error parsing valid encounters");
			}
		} else {
			logger.logError("Unable to retrieve Viewable Encounters from ClinicalContext service");
			throw new Error("PVCONTXTMPAGE: Error getting valid encounters");
		}
	});
	request.performRequest();		
	if(viewableEncounters) {
		self.validEncounters = viewableEncounters;
		self.patientId = patientId;
	}		
	return viewableEncounters;
}; 
/**
 * The pvFrameworkLink is the web equivalent of the PVFRAMEWORKLINK API used in the context of Millennium.
 */
var pvFrameworkLink = {
	m_pendingDataIndicator : 0
};

/**
 * Sets the pending data indicator for the pvFrameworkLink implementation of PVFRAMEWORKLINK.
 * @param {Integer} pendingDataIndicator - The pending data indicator.
 * 0 = false (no pending data)
 * 1 = true (pending data)
 */
pvFrameworkLink.SetPendingData = function(pendingDataIndicator) {
	if(typeof pendingDataIndicator !== "number" || pendingDataIndicator < 0 || pendingDataIndicator > 1) {
		throw new Error("Error: pvFrameworkLink.SetPendingData expects an integer value of 0 or 1.");
	}
	this.m_pendingDataIndicator = pendingDataIndicator;
};

/**
 * Web implementation of PVFRAMEWORKLINK LaunchPopup. Does nothing in browser.
 * @constructor
 */
pvFrameworkLink.LaunchPopup = function() {
	logger.logWarning("PVFRAMEWORKLINK: LaunchPopup is not supported outside of Millennium.");
};

/**
 * Web implementation of PVFRAMEWORKLINK SetPopupBoolProp. Does nothing in browser.
 * @param {String} propertyName - The boolean property name.
 * @param {Integer} propertyIndicator - The boolean property value (0 = false, 1 = true)
 */
pvFrameworkLink.SetPopupBoolProp = function(propertyName, propertyIndicator) {
	logger.logWarning("PVFRAMEWORKLINK: SetPopupBoolProp is not supported outside of Millennium.");
};

/**
 * Web implementation of PVFRAMEWORKLINK SetPopupStringProp. Does nothing in browser.
 * @param {String} propertyName - The string property name.
 * @param {String} propertyStringValue - The string value for the specified propertyName.
 */
pvFrameworkLink.SetPopupStringProp = function(propertyName, propertyStringValue) {
	logger.logWarning("PVFRAMEWORKLINK: SetPopupStringProp is not supported outside of Millennium.");
};

/**
 * Web implementation of PVFRAMEWORKLINK SetPopupDoubleProp. Does nothing in browser.
 * @param {String} propertyName - The double property name.
 * @param {Number} propertyDoubleValue - The double value for the specified propertyName.
 */
pvFrameworkLink.SetPopupDoubleProp = function(propertyName, propertyDoubleValue) {
	logger.logWarning("PVFRAMEWORKLINK: SetPopupDoubleProp is not supported outside of Millennium.");
};

/**
 * Web implementation of PVFRAMEWORKLINK SetPopupLongProp. Does nothing in browser.
 * @param {String} propertyName - The long property name.
 * @param {Number} propertyLongValue - The long value for the specified propertyName.
 */
pvFrameworkLink.SetPopupLongProp = function(propertyName, propertyLongValue) {
	logger.logWarning("PVFRAMEWORKLINK: SetPopupLongProp is not supported outside of Millennium.");
};

/**
 * Web implementation of PVFRAMEWORKLINK SetStoreInfo. Does nothing in browser.
 * @param {String} propertyName - The key string value.
 * @param {Object} propertyValue - The value for the specified key.
 */
pvFrameworkLink.SetStoreInfo = function(propertyName, propertyValue) {
	logger.logWarning("PVFRAMEWORKLIN: SetStoreInfo is not supported outside of Millennium.");
};
/*
 * CPMPageComponent
 */
function CPMMPageComponent(){
    //These member variable declarations are for reference and don't actually serve a functional purpose
    this.m_menuIds = null;
    this.m_intentionCd = 0;
    this.m_intentionMean = "";
    this.m_conceptCd = 0;
    this.m_conceptMean = "";
    this.m_conceptDisp = "";
    this.m_nodeId = 0;
    this.m_cpComponentId = 0;
    this.m_customContentLocation = "";
    this.m_customOptionsObject = null;
    this.m_triggeringNomenclature = 0;
	this.m_isHidden = false;
	
	this.m_conceptGroupCd = 0;
	this.m_conceptGroupConfig = [];
    this.m_conceptGroupMeanings = [];

    this.m_componentConfig = [];
    this.m_pathwayActions = [];
}

CPMMPageComponent.prototype = new MPageComponent();
CPMMPageComponent.prototype.constructor = MPageComponent;

CPMMPageComponent.prototype.getConceptGroupCd = function() {
    return this.m_conceptGroupCd;
};

CPMMPageComponent.prototype.getNodeId = function() {
    return this.m_nodeId;
};

CPMMPageComponent.prototype.getCpComponentId = function() {
    return this.m_cpComponentId;
};

CPMMPageComponent.prototype.getPathwayActions = function() {
    if(this.m_pathwayActions){
        return this.m_pathwayActions;
    }
    else{
        return([]);
    }
};

CPMMPageComponent.prototype.getPathwayId = function() {
    return this.m_pathwayId;
};

CPMMPageComponent.prototype.setConceptGroupCd = function(val) {
    this.m_conceptGroupCd = val;   
};

CPMMPageComponent.prototype.setNodeId = function(val) {
    this.m_nodeId = val;
};

CPMMPageComponent.prototype.setCpComponentId = function(val) {
    this.m_cpComponentId = val;
};

CPMMPageComponent.prototype.setPathwayActions = function(val) {
    this.m_pathwayActions = val;
};

CPMMPageComponent.prototype.setPathwayId = function(val) {
    this.m_pathwayId = val;
};

CPMMPageComponent.prototype.setComponentConfig = function(val) {
    this.m_componentConfig = val;
};

CPMMPageComponent.prototype.getComponentConfig = function() {
    if (!this.m_componentConfig){
        this.m_componentConfig = [];
    }
    return this.m_componentConfig;
};

CPMMPageComponent.prototype.getConceptGroupConfig = function() {
	if (!this.m_conceptGroupConfig){
		this.m_conceptGroupConfig = [];
	}
    return this.m_conceptGroupConfig;
};

CPMMPageComponent.prototype.setConceptGroupConfig = function(val) {
    this.m_conceptGroupConfig = val;
};

CPMMPageComponent.prototype.getConceptGroupMeanings = function() {
	if (!this.m_conceptGroupMeanings){
		this.m_conceptGroupMeanings = [];
	}
    return this.m_conceptGroupMeanings;
};

CPMMPageComponent.prototype.setConceptGroupMeanings = function(val) {
    if (typeof val == "string"){
        this.m_conceptGroupMeanings = [val];
    }
    else{
        this.m_conceptGroupMeanings = val;
    }   
};

CPMMPageComponent.prototype.loadComponentSettings = function(compSettings){
};


CPMMPageComponent.prototype.processComponentConfig = function(conceptData, componentSettings){
    return;
};

CPMMPageComponent.prototype.processPathwayActions = function(pathwayActions){
    return;
};

CPMMPageComponent.prototype.getCustomContentLocation = function(){
    return this.m_customContentLocation;
};

CPMMPageComponent.prototype.setCustomContentLocation = function(path){
    this.m_customContentLocation = path;
};

CPMMPageComponent.prototype.getMenuIds = function(){
    if (!this.m_menuIds){
        this.m_menuIds = [];
    }
    return this.m_menuIds;
};

CPMMPageComponent.prototype.addMenuId = function(id){
    if (typeof id !== "string"){
        MP_Util.LogError("Id supplied to addMenuId is not a valid string.");
    }
    var menuIdArray = this.getMenuIds();
    menuIdArray.push(id);
};

CPMMPageComponent.prototype.commitChanges = function(flag){
    //Implemented by components
    return;
};

CPMMPageComponent.prototype.cleanUp = function(){
    //Grab the menu id's array and delete menus
    var arrLen = 0;
    var x;
    var y;
    var mLen = 0;
    if (this.m_menuIds && this.m_menuIds.length > 0){
        arrLen = this.m_menuIds.length;
        for (x = arrLen; x--;){
            var menu = MP_MenuManager.getMenuObject(this.m_menuIds[x]);
            var menuItems = menu.getMenuItemArray();
            for (y = 0, mLen = menuItems.length; y < mLen; y++){
                menu.removeMenuItem(menuItems[y]);
            }
            MP_MenuManager.deleteMenuObject(this.m_menuIds[x]);
        }
        this.m_menuIds = null;
    }

    //Remove from global namespace
    var components = CERN_MPageComponents;
    var comp;
    var cLen = components.length;
    for (x = cLen; x--;){
        comp = components[x];
        if (comp.m_componentId === this.getComponentId()){
            components.splice(x, 1); //Remove
        }
    }
};

CPMMPageComponent.prototype.setConceptDisp = function(disp){
    this.m_conceptDisp = disp;
};

CPMMPageComponent.prototype.getConceptDisp = function(){
    return this.m_conceptDisp;
};

CPMMPageComponent.prototype.setConceptCd = function(num){
    if (typeof num !== "number"){
        throw new Error("Invalid Cocnept CD passed to 'setConceptCd'");
    }
    this.m_conceptCd = num;
};

CPMMPageComponent.prototype.getConceptCd = function(){
    return this.m_conceptCd;
};

CPMMPageComponent.prototype.setIntentionCd = function(num){
    if (typeof num !== "number"){
        throw new Error("Invalid Intention CD passed to 'setIntentionCd'");
    }
    this.m_intentionCd = num;
};

CPMMPageComponent.prototype.getIntentionCd = function(){
    return this.m_intentionCd;
};

CPMMPageComponent.prototype.setIntentionMean = function(mean){
    if (typeof mean !== "string"){
        throw new Error("Invalid Intention meaning passed to 'setIntentionMean'");
    }
    this.m_intentionMean = mean;
};

CPMMPageComponent.prototype.getIntentionMean = function(){
    return this.m_intentionMean;
};

CPMMPageComponent.prototype.setConceptMean = function(mean){
    if (typeof mean !== "string"){
        throw new Error("Invalid Concept meaning passed to 'setConceptMean'");
    }
    this.m_conceptMean = mean;
};

CPMMPageComponent.prototype.getConceptMean = function(){
    return this.m_conceptMean;
};

CPMMPageComponent.prototype.loadUserPrefs = function(){
    var userPrefs = MP_Core.AppUserPreferenceManager.GetComponentById(this.getComponentId());
    var preferenceObj;
    if (!userPrefs){
        return;
    }

    preferenceObj = userPrefs.preferencesObj || {};
    this.setPreferencesObj(preferenceObj);
    if (typeof preferenceObj.EXPANDED === 'number'){
        //convert number to bool
        this.setExpanded(!!preferenceObj.EXPANDED);
    }
};

CPMMPageComponent.prototype.setTriggeringNomenclature = function(nomenclatureId){
    if (typeof nomenclatureId !== "number"){
        throw new Error("Type Error: Non-number 'nomenclatureId' passed into CPMMPageComponent method 'setTriggeringNomenclatureId'");
    }
    this.m_triggeringNomenclature = nomenclatureId;
};

CPMMPageComponent.prototype.getTriggeringNomenclature = function(){
    if (!this.m_triggeringNomenclature){
        this.m_triggeringNomenclature = 0;
    }
    return this.m_triggeringNomenclature;
};

CPMMPageComponent.prototype.setCustomOptionsObject = function(obj){
    this.m_customOptionsObject = obj;
};

CPMMPageComponent.prototype.getCustomOptionsObject = function(){
    return this.m_customOptionsObject || null;
};

/**
 * Return if the component is visible in the CPM.  Ex. Add as a Menu item instead.
 * @returns {boolean} - true if visible false if otherwise
 */
CPMMPageComponent.prototype.getIsHidden = function(){
    return this.m_isHidden;
};

/**
 *Sets if the component is to be visible or not
 * @param {boolean} 
 */
CPMMPageComponent.prototype.setIsHidden = function(isHidden){
    if (typeof isHidden !== "boolean") {
        throw new Error("Called setIsHidden on CPMMPageComponent with non boolean type for isHidden parameter");
    }
    this.m_isHidden = isHidden;
};

/**
 * Base method for autosave. To be implmented by components who need autosave functionality
 * @returns{String} - String of JSON showing what Items were saved. 
 */
CPMMPageComponent.prototype.autoSave = function() {
    return("");
};

CPMMPageComponent.attachMethods = function(constructor){
    var CPMPrototype = CPMMPageComponent.prototype;
    var consPrototype = constructor.prototype;
    var key;
    //Loop through all CPMMpageComponent prototype methods
    for (key in CPMPrototype){
        if (CPMPrototype.hasOwnProperty(key)){
            //Only add to the constructor if constructor doesn't already have its own implementation
                if (!consPrototype[key]){
                consPrototype[key] = CPMPrototype[key];
            }
        }
    }
};/**
 * MPageCPNodeController
 * This class must be further implemented in a subclass
 * Handles a map of meanings to component constructors, creating a view, and defines some interface methods
 * @constructor
 */
function MPageCPNodeController(){
    this.m_id = "";
    //Stores the container html id where the view will eventually be rendered
    this.m_containerId = "";
    this.m_nodeConfiguration = null;
    this.m_conceptConfiguration = null;
    this.m_componentList = null;  //Will contain component objects
    this.m_view = null;
    this.m_conceptMean = "";
    this.m_conceptCd = 0;
    this.m_pathwayTypeMean = "";
    this.m_pathwayTypeCd = 0;
    this.m_pathwayId = 0;
    this.m_pathwayInstance = null;
    this.m_customContentLocation = "";
	this.m_isHidden = false;
}

/**
 * Contains the mapping of meanings to component constructors
 * Shared across all instances of MPageCPNodeController
 * @type {{string, constructor}}
 */
MPageCPNodeController.prototype.componentMapping = {};

/**
 * Gets the component mapping map
 * @returns {{string, constructor}}
 */
MPageCPNodeController.prototype.getComponentMapping = function(){
    return this.componentMapping;
};

/**
 * Gets the controller's ID
 * @returns {string|number}
 */
MPageCPNodeController.prototype.getId = function(){
    return this.m_id;
};

/**
 * Sets the controller's ID
 * Throws an error if passed in 'id' is not a string or a number
 * @param {string|number} id - controller's identifier
 */
MPageCPNodeController.prototype.setId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into MPageCPNodeController method 'setId'");
    }
    this.m_id = id;
};

/**
 * Gets the Concept Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getConceptCd = function(){
    return this.m_conceptCd;
};

/**
 * Sets the Concept Code Value
 * Throws an error if passed in 'conceptCd' is not a number
 * @param {number} conceptCd - Concept Code Value
 */
MPageCPNodeController.prototype.setConceptCd = function(conceptCd){
    if (typeof conceptCd !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setConceptCd'");
    }
    this.m_conceptCd = conceptCd;
};

/**
 * Gets the Pathway ID
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayId= function(){
    return this.m_pathwayId;
};

/**
 * Sets the Pathway ID
 * Throws an error if passed in 'pathwayId' is not a number
 * @param {number} pathwayId - Pathway ID
 */
MPageCPNodeController.prototype.setPathwayId= function(pathwayId){
    if (typeof pathwayId !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setPathwayId'");
    }
    this.m_pathwayId = pathwayId;
};


/**
 * Gets the Pathway Type Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayTypeCd = function(){
    return this.m_pathwayTypeCd;
};


/**
 * Sets the Pathway Type Code Value
 * Throws an error if passed in 'pathwayTypeCd' is not a number
 * @param {number} pathwayTypeCd - Pathway Type Code
 */
MPageCPNodeController.prototype.setPathwayTypeCd= function(pathwayTypeCd){
    if (typeof pathwayTypeCd !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setPathwayTypeCd'");
    }
    this.m_pathwayTypeCd = pathwayTypeCd;
};

/**
 * Gets the Pathway Type Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayTypeMean = function(){
    return this.m_pathwayTypeMean;
};


/**
 * Sets the Pathway Type Code Value
 * Throws an error if passed in 'pathwayTypeMean' is not a string
 * @param {number} pathwayTypeMean - Pathway Type Mean
 */
MPageCPNodeController.prototype.setPathwayTypeMean= function(pathwayTypeMean){
    if (typeof pathwayTypeMean !== 'string'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'pathwayTypeMean'");
    }
    this.m_pathwayTypeMean = pathwayTypeMean;
};

/**
 * Gets the Pathway Instance 
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayInstance = function(){
    return this.m_pathwayInstance;
};


/**
 * Sets the Pathway Instance
 * Throws an error if passed in 'pathwayInstance' is not a object
 * @param {Object} pathwayInstance - Pathway Instance
 */
MPageCPNodeController.prototype.setPathwayInstance= function(pathwayInstance){
    if (typeof pathwayInstance !== 'object'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'pathwayTypeMean'");
    }
    this.m_pathwayInstance = pathwayInstance;
};

/**
 * Gets the Concept Configuration
 * @returns {object}
 */
MPageCPNodeController.prototype.getConceptConfig = function(){
    return this.m_conceptConfiguration;
};


/**
 * Sets the Concept Configuration 
 * @param {object} conceptConfig - Concept Configuration
 */
MPageCPNodeController.prototype.setConceptConfig = function(conceptConfig){
 
    this.m_conceptConfiguration = conceptConfig;
};

/**
 * Gets the Node Configuration
 * @returns {object}
 */
MPageCPNodeController.prototype.getNodeConfig = function(){
    return this.m_nodeConfiguration;
};


/**
 * Sets the Node Configuration 
 * @param {object} nodeConfig - Node Configuration
 */
MPageCPNodeController.prototype.setNodeConfig = function(nodeConfig){
 
    this.m_nodeConfiguration = nodeConfig;
};


/**
 * Gets the Custom Components static content location
 * Note: This method should be temporary until code is merged into core MPage codebase
 * @returns {string} - file path
 */
MPageCPNodeController.prototype.getCustomContentLocation = function(){
    return this.m_customContentLocation;
};

/**
 * Sets the Custom Components static content location
 * Note: This method should be temporary until code is merged into core MPage codebase
 * @param {string} path - file path
 */
MPageCPNodeController.prototype.setCustomContentLocation = function(path){
    this.m_customContentLocation = path;
};

/**
 * Gets the Container Id
 * The container id is the id of the HTML element that will contain the view/components
 * @returns {string} - HTML ID
 */
MPageCPNodeController.prototype.getContainerId = function(){
    return this.m_containerId;
};

/**
 * Sets the Container Id
 * The container id is the id of the HTML element that will contain the view/components
 * Throws an error if passed in 'id' is not a string or a number
 * @param {string} id - HTML ID of an element within the DOM
 */
MPageCPNodeController.prototype.setContainerId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into MPageCPNodeController method 'setContainerId'");
    }
    this.m_containerId = id;
};

/**
 * Gets the Concept Meaning
 * @returns {string} - concept meaning
 */
MPageCPNodeController.prototype.getConceptMean = function(){
    return this.m_conceptMean;
};

/**
 *Sets the Concept Meaning
 * Throws an error if passed in 'mean' is not a string
 * @param {string} mean - concept meaning
 */
MPageCPNodeController.prototype.setConceptMean = function(mean){
    if (typeof mean !== 'string'){
        throw new Error("Type Error: Non-string type 'mean' passed into MPageCPNodeController method 'setCocneptMean'");
    }
    this.m_conceptMean = mean;
};

/**
 * Gets the controller's list of MPageComponents
 * This method will always return an array
 * @returns {Array<MPageComponent>} - an array of MPageComponents
 */
MPageCPNodeController.prototype.getComponentList = function(){
    if (!this.m_componentList){
        this.m_componentList = [];
    }
    return this.m_componentList;
};

/**
 * Sets the controller's list of MPageComponents
 * This method is expected to be used to null an existing array
 * @param {null|Array} list - null to clear the existing array, or an array of MPageComponents
 */
MPageCPNodeController.prototype.setComponentList = function(list){
    this.m_componentList = list;
};

/**
 * Gets the controller's View
 * Creates a new instance of CPNodeView if there isn't an existing view referenced
 * @returns {CPNodeView|Object} - view
 */
MPageCPNodeController.prototype.getView = function(){
    if (!this.m_view){
        this.m_view = new CPNodeView();
    }
    return this.m_view;
};

/**
 * Sets the controller's View
 * @param {CPNodeView} view - instance of CPNodeView or subclass of CPNodeView
 */
MPageCPNodeController.prototype.setView = function(view){
    this.m_view = view;
};

/**
 * Adds a pairing of a meaning and component constructor to the component mapping map
 * Throws an error if the passed in 'meaning' is not a string
 * Throws an error if the passed in 'classConstructor' is not a function
 * Throws an error if the passed in 'meaning' is already stored in the map
 * @param {string} meaning - identifier
 * @param {constructor} classConstructor - component constructor
 */
MPageCPNodeController.prototype.addComponentMapping = function(meaning, classConstructor){
    var componentMapping = this.getComponentMapping();
    if (typeof meaning !== "string"){
        throw new Error("Type Error: Non-string 'meaning' passed into MPageCPNodeController method 'addComponentMapping'");
    }
    if (typeof classConstructor !== "function"){
        throw new Error("Type Error: Non-function 'classConstructor' passed into MPageCPNodeController method 'addComponentMapping'");
    }
    if (componentMapping[meaning]){
        throw new Error("Runtime Error: 'meaning' already exists in MPageCPNodeController componentMapping - '" + meaning + "'");
    }

    componentMapping[meaning] = classConstructor;
};

/**
 * Gets the component constructor based on a meaning
 * Will return null if the meaning does not exist in the component mapping map
 * Throws an error if passed in 'meaning' is not a string
 * @param {string} meaning - identifier
 * @returns {constructor|null} - component constructor
 */
MPageCPNodeController.prototype.getConstructorByMeaning = function(meaning){
    if (typeof meaning !== "string"){
        throw new Error("Type Error: Non-string 'meaning' passed into MPageCPNodeController method 'getConstructorByMeaning'");
    }
    if (!this.getComponentMapping()[meaning]){
        return null;
    }
    return this.getComponentMapping()[meaning];
};

/**
 * Tells the stored view to commit component actions
 * Example: save text from CKEditor
 */
MPageCPNodeController.prototype.commitComponentActions = function(){
    this.getView().commitComponentChanges(true);
};

/**
 * Tells the stored view to undo component actions
 * Example: remove added orders from the scratchpad
 */
MPageCPNodeController.prototype.undoComponentActions = function(){
    this.getView().commitComponentChanges(false);
};

/**
 * Tells the stored view to destroy itself
 * The view should handle cleaning up its components
 */
MPageCPNodeController.prototype.dispose = function(){
    this.getView().destroyView();
};

/**
 * Processes Pathway configuration
 * Sets base information for Pathway
 * @param {Object} config
 */
MPageCPNodeController.prototype.processPathwayConfiguration = function(config){

   	if (!config) {
		throw new Error("Runtime Error: Undefined config passed into CPMController method 'processPathwayConfiguration'");
	}

	this.setPathwayId(config.PATHWAY_ID);
	this.setPathwayTypeMean(config.PATHWAY_TYPE_MEAN);
	this.setPathwayTypeCd(config.PATHWAY_TYPE_CD);

	if(config.CONCEPT_LIST.length == 1){
		this.setConceptConfig(config.CONCEPT_LIST[0].CG_LIST);
	}

    if(config.PATHWAY_INSTANCE){
        this.setPathwayInstance(config.PATHWAY_INSTANCE);
    }

	this.setNodeConfig(config.NODE_LIST);
};

/**
 * Gets concept group configuration by concept group meanings. 
 * @param {Array} meanings - List of meanings to match concetp config on
 * @param {Number} intentionCd -Intention of current component to match concept groups on
 */
MPageCPNodeController.prototype.getConceptGroupConfigByMeaning = function(meanings, intentionCd) {
	var conceptConfig = this.m_conceptConfiguration || [];
	var componentConceptConfig = [];
	for(var x = conceptConfig.length; x--;){
		if(meanings.indexOf(conceptConfig[x].CONCEPT_GROUP_CD_MEAN) >= 0  && intentionCd == conceptConfig[x].INTENTION_CD){
			componentConceptConfig.push(conceptConfig[x]);
		}
	}

	return(componentConceptConfig);
};

/**
 *  
 * Gets a list of actions for the component. 
 * @param {Number} cpComponentId - componentId to retrieve actions for. 
 */
MPageCPNodeController.prototype.getComponentActions = function(cpComponentId) {
    
    var pathwayInstance = null;
    var pathwayActions = null;
    var node = null;
    var component = null;
    var actions = [];
    var x,y;

    pathwayInstance = this.getPathwayInstance();

    if(pathwayInstance){
        pathwayActions = pathwayInstance.PATHWAY_ACTIONS;
        for(x = pathwayActions.NODE_LIST.length; x--;){
            node = pathwayActions.NODE_LIST[x];
            for(y = node.COMPONENT_LIST.length; y--;){
                component = node.COMPONENT_LIST[y];
                if(component.COMPONENT_ID === cpComponentId){
                    actions = component.ACTIONS;
                    return(actions);
                }
            }
        }

    }
    
    return(actions);
};

/**
 * Based on a Node Id, get the 
 * Throws an error if passed in 'nodeId' is not found
 * @param {Number} nodeId - ID of Node to return
 */
MPageCPNodeController.prototype.getNodeById = function(nodeId) {

	var nodes = this.m_nodeConfiguration;

	for(var x = nodes.length; x--;){
		if(nodes[x].CP_NODE_ID == nodeId){
			return(nodes[x]);
		}

	}

};

/**
 * Processes Node configuration
 * This method is meant to be implemented in subclasses
 * Throws an error if this method is called without being overwritten
 * @param {Number} NodeId
 */
MPageCPNodeController.prototype.processNodeConfiguration = function(nodeId){
    throw new Error("Error: 'processNodeConfiguration' not implemented on 'MPageCPNodeController'");
};

/**
 * CPMController
 * Subclass of MPageCPNodeController
 * Handles retrieving CPM config based on a Concept, and the creation of the CPM components and View
 * Handles telling the View when to render, or dispose itself
 * @constructor CPMController
 */
function CPMController(){
    this.m_triggeringNomenclature = 0;
    this.m_customOptionsObject = null;
	this.m_cpmTabMenuId = null;
}

CPMController.prototype = new MPageCPNodeController();
CPMController.prototype.constructor = CPMController;

CPMController.prototype.setCPMTabMenuId = function(menuId){
    this.m_cpmTabMenuId = menuId;
};

CPMController.prototype.getCPMTabMenuId = function(){
    return this.m_cpmTabMenuId;
};

CPMController.prototype.getTriggeringNomenclature = function(){
    return this.m_triggeringNomenclature;
};

CPMController.prototype.setTriggeringNomenclature = function(nomenclatureId){
    if (typeof nomenclatureId !== "number"){
        throw new Error("Type Error: 'nomenclatureId' passed into CPMController method 'setTriggeringNomenclature'");
    }
    this.m_triggeringNomenclature = nomenclatureId;
};

CPMController.prototype.getCustomOptionsObject = function(){
    return this.m_customOptionsObject;
};

CPMController.prototype.setCustomOptionsObject = function(obj){
    this.m_customOptionsObject = obj;
};

var CPM_MPageComponents = null;
var CPMCurrCompIndex = null;

CPMController.prototype.addOutsideComponents = function(componentConfigList) {
	componentConfigList.push({
	    COMP_TYPE_CD_MEANING : "IMPRESSIONS",
	    COMP_DETAIL_LIST : []
	  });
};

CPMController.prototype.processOutsideComponent = function(component, pos) {
	component.setSequence(100 + pos);
	component.setPageGroupSequence(1);
	component.setColumn(1);
};

CPMController.prototype.createCpmConfigRequest = function(pathwayId, conceptCd) {
	var request;

	request = new MP_Core.ScriptRequest(this, "ENG:CPMController_retrieveNodeConfiguration");
	request.setProgramName("cp_load_pathway_config");
	request.setParameters(["^MINE^", pathwayId +".0", conceptCd + ".0"]);
	request.setAsync(true);

	return request;
};

/**
 * Processes the configuration to create components
 * Overrides superclass' implementation
 * Throws an error if nodeConfig evaluates to false
 */
CPMController.prototype.processNodeConfiguration = function(nodeId) {

	var defaultSequence = 900;//arbitrary high sequence and group for use when no sequence or group data is available
	var defaultGroup = 900;
	var config = this.getNodeById(nodeId);
	if (!config) {
		throw new Error("Runtime Error: Undefined config passed into CPMController method 'processNodeConfiguration'");
	}

	var componentConfigList = config.COMPONENT_LIST || [];
	var intentionMean = config.INTENTION_CD_MEANING || "";
	var componentList = this.getComponentList();
	var conceptMean = config.CONCEPT_CD_MEAN || "";
    var conceptDisp = config.CONCEPT_CD_DISP || "";
	var intentionCd = config.INTENTION_CD || 0;
	var conceptCd = config.CONCEPT_CD || 0;
    var pathwayId = this.getPathwayId() || 0;
	var view = this.getView();
	var componentConfig, conceptGroupConfig, componentActions, compMeaning, compConstructor, component, i, cLen, cpComponentId, conceptGroupCd;

	view.setViewSettings(config);

	this.addOutsideComponents(componentConfigList);

	if (CPMCurrCompIndex == undefined) {
		CPMCurrCompIndex = 0;
	} else {
		CPMCurrCompIndex = componentConfigList.length;
	}

	this.buildTabMenu(conceptCd);

	for ( i = 0, cLen = componentConfigList.length; i < cLen; i++) {
		componentConfig = componentConfigList[i];
		compMeaning = componentConfig.COMP_TYPE_CD_MEANING;
        cpComponentId = componentConfig.CP_COMPONENT_ID;
        conceptGroupCd = componentConfig.CONCEPT_GROUP_CD;
		if (!compMeaning) {
			continue;
		}

		compConstructor = this.getConstructorByMeaning(compMeaning);

		if (!compConstructor) {
			continue;
		}

		component = new compConstructor();
		component.setCustomOptionsObject(this.getCustomOptionsObject());
		component.setIntentionCd(intentionCd);
		component.setIntentionMean(intentionMean);
		component.setConceptCd(conceptCd);
		component.setConceptMean(conceptMean);
        component.setConceptDisp(conceptDisp);
		component.setTriggeringNomenclature(this.getTriggeringNomenclature());
		component.setAlwaysExpanded(true);
		component.setCustomContentLocation(this.getCustomContentLocation());
        component.setCpComponentId(cpComponentId);
		component.setComponentId(this.getId() + i);
        component.setNodeId(nodeId);
        component.setPathwayId(pathwayId);
        component.setConceptGroupCd(conceptGroupCd);
		component.setComponentConfig(componentConfig);
		
		if (componentConfig.ROW != 0 && componentConfig.GROUP != 0 && componentConfig.COLUMN != 0){
			component.setSequence(componentConfig.ROW); 
			component.setPageGroupSequence(componentConfig.GROUP);
			component.setColumn(componentConfig.COLUMN);
		}else{
			component.setSequence(defaultSequence); // set sequence to a high sequence if there is no sequence available
			defaultSequence ++; //increment to prevent multiple components with the same sequence
			component.setPageGroupSequence(defaultGroup);
			component.setColumn(1);
		}

        //Any actions taken from the component. 
        componentActions = this.getComponentActions(cpComponentId);  
        component.setPathwayActions(componentActions);
        component.processPathwayActions(componentActions);
		
		//Get the concept level config needed
		conceptGroupConfig = this.getConceptGroupConfigByMeaning(component.getConceptGroupMeanings(), intentionCd);
		component.setConceptGroupConfig(conceptGroupConfig);
	
        component.processComponentConfig(componentConfig, conceptGroupConfig);

		if (!component.getIsHidden()) {
			componentList.push(component);
			view.addComponent(component);
		}
		
		//Hardcoded lookback logic for CPM. Because Vitals and labs are updated
		//to honor scope correctly this reverts the scope to operate like it was
		//before it was correct
		if(component instanceof VitalsCPMComponent || component instanceof LabsCPMComponent){
			component.setScope(2);
		}
		
	}
}; 

CPMController.prototype.buildTabMenu = function(conceptCd) {
	var menuContainer = $("#" + this.getCPMTabMenuId());
	var compSelMenuId = "cpmTabMenu" + conceptCd;
	var compSelMenu = null;
    var cpmDocI18n = i18n.discernabu.cpm_core_o1;

	//If the menu item already exists remove it
	if (MP_MenuManager.getMenuObject(compSelMenuId)) {
		MP_MenuManager.deleteMenuObject(compSelMenuId);
	}
	
	//Create the menu
	compSelMenu = new Menu(compSelMenuId);
	compSelMenu.setTypeClass("menu-page-menu");
	compSelMenu.setIsRootMenu(true);	
	compSelMenu.setLabel("");
	compSelMenu.setAutoFlipVertical(false);
	compSelMenu.setAnchorElementId("chxTabsMenu" + conceptCd);
	compSelMenu.setAnchorConnectionCorner(["bottom","right"]);
	compSelMenu.setContentConnectionCorner(["top","right"]);
	
    // For the sake of consistency pre-load the links and diagrams menu items and default to disabled.
    // this is to facilitate the functionality of having components show up in the menu dithered regardless of if they are on the page or not
    
	var linksMenuItem = "cpmTabLinksMenu" + conceptCd;
    var linksItem = new Menu(linksMenuItem);
    linksItem.setLabel(cpmDocI18n.LINKSLABEL);
    linksItem.setCloseOnClick(false);
    linksItem.setAnchorConnectionCorner(["top","left"]);
    linksItem.setContentConnectionCorner(["top","right"]);
    linksItem.setIsDisabled(true);
    linksItem.setTypeClass("diaglinks-cpm-menu-item-disabled");
    compSelMenu.addMenuItem(linksItem);
    
    var diagramMenuItem = "cpmTabDiagramsMenu" + conceptCd;
    var diagramItem = new Menu(diagramMenuItem);
    diagramItem.setLabel(cpmDocI18n.DIAGLABEL);
    diagramItem.setCloseOnClick(false);
    diagramItem.setAnchorConnectionCorner(["top","left"]);
    diagramItem.setContentConnectionCorner(["top","right"]);
    diagramItem.setIsDisabled(true);
    diagramItem.setTypeClass("diaglinks-cpm-menu-item-disabled");
    compSelMenu.addMenuItem(diagramItem);



	//Add the menu object to the menu manager
	MP_MenuManager.addMenuObject(compSelMenu);
	
	//Create CPM Tab specific menu
	menuContainer.append("<div id='chxTabsMenu"+conceptCd+"' class='cpm-tab-menu-inactive'>&nbsp;</div>");
		
};

/**
 * Sets the required fields on the stored View
 */
CPMController.prototype.configureView = function(){
    var view = new CPMView();
    view.setName("CPM");
    view.setId("cpm" + this.getId());
    view.setRenderStrategyConstructor(CPMRenderStrategy);
    view.setCustomCSS("wf cpm");
    view.setContainer($("#" + this.getContainerId()));
    view.setContainerId(this.getContainerId());
    this.setView(view);
};

/**
 * Begins rendering the view/components in the HTML element specified by the Container ID
 * Throws an error if the containerId has not been set
 */
CPMController.prototype.render = function(){
    var containerId = this.getContainerId();
    var view = this.getView();
    if (!containerId){
        throw new Error("Runtime Error: No 'containerId' set on instance of 'CPMController'");
    }
    //Empty the container's innerHTML so we can fill it with what we want
    $("#" + this.getContainerId()).empty();

    view.initializeComponents();
    view.renderMPage();
};


var CPM_Util = function () {
	return {
		refreshComponentsToStorage : function (components) {
			if (!components || !components.length) {
				return;
			}
			
			if(!CPMCurrCompIndex) CPMCurrCompIndex =0 ;

			CPM_MPageComponents = [];
    			
			for (var x = CPMCurrCompIndex, xl = components.length;
				x < xl;
				x++) {
				if (components[x]) {
					CPM_MPageComponents.push(components[x]);
				}
			}
		}
	};
}();	



/**
 * Sets the layout of the components within the view
 * Note: This logic is in place until this is configurable
 */

CPMController.prototype.processComponentLayout = function() {
	var componentList = this.getComponentList();
	var component, i, cLen;
	var vitalsComponentIndex = -1;
	var labsComponentIndex = -1;
	
	CPM_Util.refreshComponentsToStorage(componentList);

	for ( i = 0, cLen = componentList.length; i < cLen; i++) {
		component = componentList[i];
		component.setPageGroupSequence(1);
		component.setColumn(1);

		if (typeof NewOrdersCPMComponent !== 'undefined' && component instanceof NewOrdersCPMComponent) {
			component.setSequence(97);
		} else if (typeof AllergyComponentCPM !== 'undefined' && component instanceof AllergyComponentCPM) {
			component.setSequence(0);
		} else if (typeof LabsCPMComponent !== 'undefined' && component instanceof LabsCPMComponent) {
			labsComponentIndex = i;
			component.setSequence(1);
		} else if (typeof VitalsCPMComponent !== 'undefined' && component instanceof VitalsCPMComponent) {
			vitalsComponentIndex = i;
			component.setSequence(2);
		} else if (typeof DiagramCPMComponent !== 'undefined' && component instanceof DiagramCPMComponent) {
			component.setSequence(96);
		} else if (typeof DocumentsCPMComponent !== 'undefined' && component instanceof DocumentsCPMComponent) {
			component.setSequence(4);
		} else if (typeof PhysicianImpressionsCPMComponent !== 'undefined' && component instanceof PhysicianImpressionsCPMComponent) {
			component.setSequence(98);
		} else if (typeof TreatAssessmentComponentCPM !== 'undefined' && component instanceof TreatAssessmentComponentCPM) {
			component.setSequence(96);
		} else {
			this.processOutsideComponent(component, i);
		}
	}	
	
	if(vitalsComponentIndex >= 0 && labsComponentIndex >= 0){
		componentList[vitalsComponentIndex].setSequence(2);
		componentList[vitalsComponentIndex].setPageGroupSequence(0);
		componentList[vitalsComponentIndex].setColumn(2);
		componentList[labsComponentIndex].setSequence(1);
		componentList[labsComponentIndex].setPageGroupSequence(0);
		componentList[labsComponentIndex].setColumn(1);
		}
};

/**
 * Retrieves the CPM Configuration
 * If the AJAX call returns with success, the controller will process the configuration and begin rendering
 */
CPMController.prototype.retrieveNodeConfiguration = function() {
	var self = this;
	var conceptCd = self.getConceptCd();
    var pathwayId = self.getPathwayId();

	if (!conceptCd) {
		throw new Error("Runtime Error: No concept mean set on CPMController.  Cannot retrieve node configuration.");
	}

	MP_Core.XmlStandardRequest(null, this.createCpmConfigRequest(pathwayId, conceptCd), function(reply) {
		var statusMessage = "";
		var response = null;
		var x = 0;
		var nodeId = 0;
		self.configureView();

		if (!reply) {
			statusMessage = "Error retrieving CPM Configuration";
		}

		if (reply.getStatus() === 'S') {
			response = reply.getResponse();
			if (!response) {
				throw new Error("Runtime Error: Undefined 'response' from CPMController method 'retrieveNodeConfiguration'");
			}

			self.processPathwayConfiguration(response);
			//Find One Treatment Node
			//Currently all that is supported by CPM
			var nodes = self.getNodeConfig();
			for (var x = nodes.length; x--;){
				if(nodes[x].INTENTION_CD_MEANING == "TREATMENTS"){
					nodeId = nodes[x].CP_NODE_ID;
					break;
				}
			}
			
			
			self.processNodeConfiguration(nodeId);
			
			if(nodes && nodes.length && nodes[0].NODE_NAME == "!CONCEPT ONLY!"){ 
				// since there is no pathway id associated with the concept we are calling prcessComponentLayout to assign the 
				// sequencing manually
				self.processComponentLayout();
			}
			self.render();
			return;

		} else if (reply.getStatus() === 'Z') {
			statusMessage = "No configuration for this result type was found";
		} else {
			statusMessage = "Error retrieving configuration";
		}

		$("#" + self.getContainerId()).html(statusMessage);
	});
};function CPMRenderStrategy(){}

CPMRenderStrategy.prototype = new RenderStrategy();
CPMRenderStrategy.prototype.constructor = CPMRenderStrategy;

CPMRenderStrategy.prototype.createComponentHeader = function(){
    //Create the header shell
    var header = $("<h2></h2>").addClass("cpm "+this.componentStyle.getHeaderClass());

    //Add the toggle control
    this.addComponentSection(header, this.createComponentToggleControl());

    //Add the title to the header
    this.addComponentSection(header, this.createComponentTitle());
    
    return header[0];
};

/**
 * Creates the component toggle control found in the header. This control handles expanding/collapsing
 * the component
 * @param {MPageComponent} component the component for which we are creating the toggle control
 * @return {Object} the DOM element for the component toggle control
 */
CPMRenderStrategy.prototype.createComponentToggleControl = function() {
    //If component is always expanded, we do not create the toggle control
    if(this.component.isAlwaysExpanded()) {
        return null;
    }
    return $("<div></div>").addClass("cpm-sec-hd-tgl").attr("title", this.i18nCore.HIDE_SECTION)[0];
};

/**
 * The CPM summary components do not use the accordion. Sets the supertype's function
 * to null.
 * @returns {null} null
 */
CPMRenderStrategy.prototype.createComponentAccordion = function() {
	return null;
};

CPMRenderStrategy.prototype.createComponentTitle = function(){
	var componentTitleContainer = $("<span></span>").addClass("cpm-header "+this.componentStyle.getTitle());

	//Create the component anchor
	this.addComponentSection(componentTitleContainer, this.createComponentAnchor());
	
	//Create the component loading section
	this.addComponentSection(componentTitleContainer, this.createComponentSubTitleSection());
	
	//Try adding the plus add control
	this.addComponentSection(componentTitleContainer, this.createPlusAddControl());
	
	//Create the header separator
	this.addComponentSection(componentTitleContainer, this.createHeaderSeparator());
	
	//Try adding the header dropdown menu
	this.addComponentSection(componentTitleContainer, this.createHeaderDropdown());
	
	return componentTitleContainer[0];
};

CPMRenderStrategy.prototype.createHeaderSeparator = function(){
	return "<span class='header-separator'></span>";
};var InteractionChecking = function () {
    var mcObj;
    var isDllSupported = true;
    /**
	 * Adds an interaction object to an existing array that is passed in.
	 * @param  {Array} aObj - The array that will contain the interaction objects.
	 * @param {Object} iObj - The interaction object that will be stored inside the array passed in.
	 * @param {Number} iIdx - The index for the interaction object.
	 * @param {Number} pIdx - The parent index of the interaction object.
	 */
    function AddInteraction(aObj, iObj, iIdx, pIdx) {
        try{
            var i = aObj.length;
            aObj[i] = {idx: iIdx, pIdx: pIdx, iObj: iObj};
        }
        catch (e) {
            throw new Error("ERROR in function AddInteraction(idx[" + iIdx + "],pIdx[" + pIdx + "]): " + e.message);
        }
    }
    /**
	 * Searches for a matching synonym_id in a passed in array and returns the array's index.
	 * @param   {Array} arr - The array that will contain synonym_id's to search for.
	 * @param   {Number} id - The id to search for in the Array that is passed in.
	 * @returns {Number}    - The index number of the array where a match was found, if not found returns -1.
	 */
    function findSynonymId(arr, id) {
        try{
            var l = arr.length;
            for (var i = 0; i < l; i++) {
                if (arr[i].synonym_id == id) {
                    return (i);
                }
            }
            return (-1);
        }
        catch (e) {
            throw new Error("ERROR in function findSynonymId(id[" + id + "]): " + e.message);
        }
    }
    
    /**
	 * Searches for a matching severity AND type in a passed in array and returns the array's index.
	 * @param   {Array}       arr - The array that will contain severity and type to search for.
	 * @param   {String} severity - The severity to search for in the Array that is passed in.
	 * @param   {String}     type - The type to search for in the Array that is passed in.
	 * @returns {Number}          - The index number of the array where a match was found, if not found returns -1.
	 */
    function findTypeCombo(arr, severity, type) {
        try{
            var l = arr.length;
            for (var i = 0; i < l; i++) {
                if (arr[i].SeverityLevel == severity && arr[i].InteractionType == type) {
                    return (i);
                }
            }
            return (-1);
        }
        catch (e) {
            throw new Error("ERROR in function findTypeCombo(severity[" + severity + "],type[" + type + "]): " + e.message);
        }
    }
    
	/**
	 * Adds an interaction object for each medication found to an existing array that is passed in.
	 * @param  {Array} aObj - The array that will contain the interaction objects.
	 * @param {Object}  ico - The interaction object that will be stored inside the array passed in, if not already in the medication group.
	 */
	function AddInteractionByMed(arr, ico) {
		try{
			var aLen = arr.length;
			var tLen;
			if (aLen == 0) {
				arr[aLen] = {
					synonym_name: ico.SubjectEntityName,
					synonym_id: ico.SubjectSynonymId,
					types: []
				};
				tLen = arr[aLen].types.length;
				arr[aLen].types[tLen] = {
					SeverityLevel: ico.SeverityLevel,
					InteractionType: ico.InteractionType
				};
			}
			else {
				var synIdx = findSynonymId(arr, ico.SubjectSynonymId);
				if (synIdx == -1) {
					arr[aLen] = {
						synonym_name: ico.SubjectEntityName,
						synonym_id: ico.SubjectSynonymId,
						types: []
					};
				}
				else {
					aLen = synIdx;
				}
				tLen = arr[aLen].types.length;
				var typeIdx = -1;
				if (tLen > 0) {
					typeIdx = findTypeCombo(arr[aLen].types, ico.SeverityLevel, ico.InteractionType);
				}
				if (typeIdx == -1) {
					arr[aLen].types[tLen] = {
						SeverityLevel: ico.SeverityLevel,
						InteractionType: ico.InteractionType
					};
				}
			}
		}
		catch (e) {
			throw new Error("ERROR in function AddInteractionByMed(): " + e.message);
		}
	}
	
    /** Format and return an array of interactions for the calling application.
      * @param   {Object}  iccObj - interaction check collection.
      * @returns {Object} myInteractions - 
            myInteractions Object that contains arrays of each type of Interaction...
                * Medications
                * DrugDrugInteractions
                * DrugAllergyInteractions
                * DrugFoodInteractions
                * DupTherapyInteractions
                * IVCompatibilityInteractions
                Each type of interaction will contain an iObj Object that has the following properties:
                    SubjectComponentName
					CausingComponentName
					CausingCatalogCd
					SubjectCatalogCd
					CausingSynonymId
					toString
					SubjectEntityCKI
					CausingEntityCKI
					OverrideReasonCd
					OverrideReasonDisp
					PreviousOverrideReasonCd
					PreviousOverrideReasonDisp
					CausingEntityUniqueString
					CausingEntityName
					CausingEntityId
					CausingEntityType
						[0] EntityUnknown
						[1] EntityOrder
						[2] EntityAllergy
						[3] EntityFood
					SubjectEntityUniqueString
					SubjectEntityName
					SubjectEntityId
					SubjectEntityType
						[0] EntityUnknown
						[1] EntityOrder
						[2] EntityAllergy
						[3] EntityFood
					SeverityDescription
					SeverityLevel
						[0] NoSeverity
						[1] MinorSeverity
						[2] ModerateSeverity
						[3] MajorSeverity
					InteractionDescription
					InteractionType
						[0] DrugDrugInteraction
						[1] DrugAllergyInteraction
						[2] DrugFoodInteraction
						[3] DuplicateTherapyInteraction 
						[4] IVCompatibilityInteraction
					TransactionUniqueId
					SubjectSynonymId
					SubjectSynonymId
					CategoryLevelType
					CausingEntityComponentCKI
					SubjectEntityComponentCKI
    */
    function GetInteractions(iccObj) {
        if (typeof iccObj.GetInteractionCheckAtEx == "undefined"){
			alert("The registered version of PVInteractionCheckingCom.dll does support Interaction Checking from this MPage.  Please contact your system administrator.");
			isDllSupported = false;
			return (null);
        }
        else{
			isDllSupported = true;
        }     
        var interactionType;
		var arrDrugDrug = {type: "Drug Drug Interaction"};
		var arrDrugAllergy = {type: "Drug Allergy Interaction"};
		var arrDrugFood = {type: "Drug Food Interaction"};
		var arrDupTherapy = {type: "Duplicate Therapy Interaction"};
		var arrIVCompatibility = {type: "IV Compatibility Interaction"};
		var arrMedications = [];
        try{
            var iccCnt = iccObj.GetInteractionCheckCount();
            if (iccCnt > 0) {
                var myInteractions = [];
                myInteractions.interactionCnt = 0;
                for (var j = 0; j < iccCnt; j++) {
                    var icObj = iccObj.GetInteractionCheckAtEx(j);
                    var giCnt = icObj.InteractionCollection.GetInteractionCount();
                    if (giCnt > 0) {
                        for (var k = 0; k < giCnt; k++) {
                            var iObj = icObj.InteractionCollection.GetInteractionAt(k);
                            switch(iObj.InteractionType){
								case 0:
									interactionType = arrDrugDrug;
									break;
								case 1:
									interactionType = arrDrugAllergy;
									break;
								case 2:
									interactionType = arrDrugFood;
									break;
								case 3:
									interactionType = arrDupTherapy;
									break;
								case 4:
									interactionType = arrIVCompatibility;
									break;
								default:
									logger.logJSError("Error in trying to set the interaction type.", "Interaction Checking", "inn_util_interaction_checking.js", "GetInteractions");
									break;
							}
                            AddInteraction(interactionType, iObj, k, j);
                            myInteractions.interactionCnt++;
                            AddInteractionByMed(arrMedications, iObj);
                        }
                    }
                }
                myInteractions.Medications = arrMedications;
                myInteractions.DrugDrugInteractions = arrDrugDrug;
                myInteractions.DrugAllergyInteractions = arrDrugAllergy;
                myInteractions.DrugFoodInteractions = arrDrugFood;
                myInteractions.DupTherapyInteractions = arrDupTherapy;
                myInteractions.IVCompatibilityInteractions = arrIVCompatibility;
                return (myInteractions);
            }
            else{
                return (null);
            }
        }
        catch (e) {
            throw new Error("ERROR in function GetInteractions(): " + e.message);
        }
    }
    return {
        /**
		 * Initializes the Interaction Checking variable by creating a Medication Collection object from the Discern Object Factory.
		 */
        init: function (){
            try{
                if (mcObj == null || mcObj == undefined) {
                    mcObj = window.external.DiscernObjectFactory("MEDICATIONCOLLECTION");
                }
                return (true);
            }
            catch (e) {
                throw new Error("ERROR in function init(): " + e.message);
            }
            
        },
        
        /**
		 * Gets the value for isDllSupported, so the caller can determine if checking interactions will be supported via PVInteractionCheckingCom.dll.
		 * @return  {Boolean} isDllSupported - The value of the variable isDllSupported will be returned.
		 */
        GetisDllSupported: function(){
			return (isDllSupported);
        },
        
        /**
		 * Removes a single medication object from the medication collection object. 
		 * @param  {Number} x - The index of the medication inside the medication collection that is to be removed.
		 */
        RemoveMedicationAt: function (x) {
            try{
                mcObj.RemoveMedicationAt(x);
            }
            catch (e) {
                throw new Error("ERROR in function RemoveMedicationAt(" + x + "): " + e.message);
            }
        },
        
        /**
		 * Clears or empties the Medication Collection Object.
		 */
        ClearMedicationCollection: function(){
            try{
                mcObj.Clear();
            }
            catch (e) {
                throw new Error("ERROR in function ClearMedicationCollection(): " + e.message);
            }
        },
        
        /**
		 * Adds a medication object to the Medication Collection.
		 * @param {Number} synonym_id    - The synonymn_id of the medication.
		 * @param {String} mnemonic      - The mnemonic of the medication.
		 * @param {String} order_details - The order details of the medication.
		 * @param {Number} venue_type    - The venue type of the medication.
		 */
        AddMedication: function(synonym_id, mnemonic, order_details, venue_type) {
            try{           
                if (mcObj == null || mcObj == undefined) {
                    this.init();
                }
                var mc_cnt = mcObj.GetMedicationCount();
                var medObj = window.external.DiscernObjectFactory("MEDICATIONOB");
                medObj.AddSynonym(synonym_id, mnemonic);
                medObj.UniqueIdentifier = mc_cnt.toString() + mnemonic + synonym_id.toString();
                medObj.mnemonic = mnemonic;
                medObj.OrderDetails = order_details;
                medObj.VenueType = venue_type;
                mcObj.AddMedication(medObj);
            }
            catch (e) {
                throw new Error("ERROR in function AddMedication(" + synonym_id + "," + mnemonic + "," + order_details + "," + venue_type + "): " + e.message);
            }
        },
        
        /**
		 * Returns the number of medications found inside the Medication COllection object.
		 */
        GetMedicationCnt: function (){
            try{
                var cnt = mcObj.GetMedicationCount();
                return (cnt);
            }
            catch (e) {
                throw new Error("ERROR in function GetMedicationCnt(): " + e.message);
            }

        },
        
        /**
		 * Checks for interactions between the medication collection and the patient profile and returns the collection to the caller.
		 * @param   {Number}   pid    - The person_id of the patient in which the interaction checking will be performed.
		 * @returns {Object}  iccObj - 
		 */
		CheckforInteractions: function (pid){
			var iccObj;
			try {
				var mc_cnt = mcObj.GetMedicationCount();
				if (mc_cnt > 0) {
					var pvicObj = window.external.DiscernObjectFactory("PVINTERACTIONCHECKING");
					iccObj = pvicObj.CheckMedicationsInteractions(mcObj, pid);
					var iccCnt = iccObj.GetInteractionCheckCount();
					if (iccCnt > 0) {
						return (GetInteractions(iccObj));
					}
				}
				else {
					return (null);
				}
			}
			catch (e) {
				throw new Error("ERROR in function CheckforInteractions(): " + e.message);
			}
		}
	};
}();/**
 * CPNodeView
 * This class is a subclass of MPageView.
 * Handles rendering the components.
 * @constructor
 */
function CPNodeView(){
    this.m_id = 0;
    this.m_customCSS = "";
    this.m_renderStrategy = null;
    this.m_containerId = "";
}

CPNodeView.prototype = new MPageView();
CPNodeView.prototype.constructor = CPNodeView;

/**
 *
 * @returns {number}
 */
CPNodeView.prototype.getId = function(){
    return this.m_id;
};

CPNodeView.prototype.setId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into CPNodeView method 'setId'");
    }
    this.m_id = id;
};

CPNodeView.prototype.setContainerId = function(id){
    this.m_containerId = id;
};

CPNodeView.prototype.getContainerId = function(){
    return this.m_containerId;
};

CPNodeView.prototype.getCustomCSS = function(){
    return this.m_customCSS;
};

CPNodeView.prototype.setCustomCSS = function(css){
    if (typeof css !== 'string'){
        throw new Error("Type Error: Non-string 'css' passed into CPNodeView method 'setCustomCSS'");
    }
    this.m_customCSS = css;
};

CPNodeView.prototype.getRenderStrategyConstructor = function(){
    return this.m_renderStrategy;
};

CPNodeView.prototype.setRenderStrategyConstructor = function(rsConstructor){
    if (typeof rsConstructor !== 'function'){
        throw new Error("Type Error: Non-constructor 'rsConstructor' passed into CPNodeView method 'setRenderStrategyConstructor'");
    }
    this.m_renderStrategy = rsConstructor;
};

CPNodeView.prototype.createNewRenderStrategy = function(){
    var renderStrategy = this.getRenderStrategyConstructor();
    if (renderStrategy){
        return new renderStrategy();
    } else {
        return new RenderStrategy();
    }
};

CPNodeView.prototype.resizeComponents = function(){
    var componentList = this.getComponents() || [];
    var component;
    var cLen = componentList.length;

    for (;cLen--;){
        component = componentList[cLen];
        if (component.isDisplayable()){
            component.resizeComponent();
        }
    }
};

CPNodeView.prototype.resizeView = function(){
    this.resizeComponents();
};

CPNodeView.prototype.initializeComponents = function(){
    var componentList = this.getComponents() || [];
    var component;
    var criterion = this.getCriterion();
    var cLen = componentList.length;
    var i;

    for (i = 0; i < cLen; i++){
        component = componentList[i];
        if (!component){
            continue;
        }
        //Set component's criterion
        component.initializeComponent(criterion);
        //component.loadUserPrefs();
        //Attempts to load display filters for component
        component.loadDisplayFilters();
        component.createMainMenu();
        component.preProcessing();
    }
};

//CPNodeView.prototype.storeViewComponents = function(componentList){
//    //Overriding this method so components aren't stored in the global namespace
//    return;
//};

CPNodeView.prototype.renderComponents = function(componentList){
    var container = this.getContainer();
    MPageView.prototype.renderComponents.call(this, componentList);

    if (container && container.length){
        container.addClass(this.getCustomCSS());
    }
};

CPNodeView.prototype.attachEvents = function(component){
    if (!component){
        return;
    }
    var i18nCore = i18n.discernabu;
    var componentRootNode = component.getRootComponentNode();
    var jqRootNode = $(componentRootNode);
    //var prefObj = component.getPreferencesObj() || {};
    //Ensure reference to object exists within component (in event getPreferencesObj returned null)
    //component.setPreferencesObj(prefObj);

    //Attaching click events to component expand/collapse toggle
    jqRootNode.find(".cpm-sec-hd-tgl").click(function(event){
        var isExpanded = 0;
        if (jqRootNode.hasClass("closed")){
            jqRootNode.removeClass("closed");
            this.innerHTML = "-";
            this.title = i18nCore.HIDE_SECTION;
            //isExpanded = 1;
        } else {
            jqRootNode.addClass("closed");
            this.innerHTML = "+";
            this.title = i18nCore.SHOW_SECTION;
        }
        //prefObj["EXPANDED"] = isExpanded;
        //component.savePreferences(false); //Synchronous for now
    });

};

CPNodeView.prototype.renderMPage = function(){
    var self = this;
    var componentList = this.getComponents() || [];
    var component;
    var resizeTimer = null;
    var cLen = componentList.length;
    var i;

    this.renderComponents(componentList);

    for (i = 0; i < cLen; i++){
        component = componentList[i];
        if (!component.isLoaded()){
            component.setLoaded(true);
            component.startComponentDataRetrieval();
        }
        //Attach header toggle
        this.attachEvents(component);
    }

    MP_Util.Doc.SetupExpandCollapse(this.getContainerId());

    //Attach resize event
    $(window).on("resize." + this.getId(), function(){
        if (resizeTimer){
            clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(function(){
            self.resizeView();
        }, 500);
    });
};

CPNodeView.prototype.getCriterion = function(){
    //Using this temporarily
    var js_criterion = JSON.parse(m_criterionJSON);
    return MP_Util.GetCriterion(js_criterion, CERN_static_content);
};

/**
 * Calls the cleanUp method on all its components.
 * This method will likely get called when the view is closed.
 */
CPNodeView.prototype.cleanComponents = function(){
    var componentList = this.getComponents() || [];
    var cLen = componentList.length;

    for (; cLen--;){
        componentList[cLen].cleanUp();
    }
};

CPNodeView.prototype.commitComponentChanges = function(flag){
    var componentList = this.getComponents() || [];
    var cLen = componentList.length;

    for (;cLen--;){
        componentList[cLen].commitChanges(flag);
    }
};

CPNodeView.prototype.destroyView = function(){
    this.cleanComponents();
    //Removes the view's resize event handler
    $(window).off("." + this.getId());
};

function CPMView(){

}

CPMView.prototype = new CPNodeView();
CPMView.prototype.constructor = CPMView;
/*globals RTMSTimer, DataRequestQueue*/

/**
 * @class
 * The DataRequest object is the base implementation of any type of data request and should be used to model specific data requests.  
 * It defines the functions and values that will be present for any type of data request regardless of the type.
 */
var DataRequest = function(){
	//A flag to indicate of the data request should be executed asynchronously
	this.m_asyncInd = true;
	//The timer timer which will be started at the beginning of the data request and stopped after the response handler function has returned
	this.m_loadTimer = null;
	//The name that is assigned to a particular data request, although not required it can be used by the consumer to distinguish between multiple data request objects
	this.m_requestName = "";
	//This indicates if the data request should skip the data request queue and be processed immediately.  This should only be used in the case of a high priority data request need
	this.m_skipQueueInd = false;
	//The response handler will be a function that gets executed once the data request has retrieved its data.  This callback is required for any data request object
	this.m_responseHandler = null;
	
	//Internal variables
	//The valid entry flag is used to verify that a data request has used the proper entry point for executing data request
	this.m_validEntry = false;
	//This indicator keeps track of the use of a DataRequestQueue thread.  If set to true a check will be made to ensure the thread is relinquished prior to executing the response handler
	this.m_relinquishNecessary = true;
};

/* Getters */
/**
 * Retrieves the asynchronous indicator which determines if the data request should be executed asynchronously.  The asynchronous indicator is defaulted to true.
 * @return {boolean} A flag which determines if the data request should be executed asynchronously or synchronously 
 */
DataRequest.prototype.getAsyncIndicator = function(){
	return this.m_asyncInd;
};

/**
 * Retrieves the timer that is used to time the data request call and the execution of the response handler function.
 * @return {RTMSTimer} The RTMSTimer object
 */
DataRequest.prototype.getLoadTimer = function(){
	return this.m_loadTimer;
};

/**
 * Retrieves the name associated to the data request object.  This is an optional field which can be used to identify a particular data request object.
 * @return {string} The name associated to this data request 
 */
DataRequest.prototype.getName = function(){
	return this.m_requestName;
};

/**
 * Retrieves the response handler for the data request.  The response handler is the function that will be executed once the data has been retrieved.
 * @return {function} The function which will be executed once the data has been returned from the data request 
 */
DataRequest.prototype.getResponseHandler = function(){
	return this.m_responseHandler;
};

/**
 * Retrieves the indicator used to determine if data request should skip the request queue.  This value defaults to false and should only be used when
 * the data being retrieved is crucial for performance concerns.  If the indicator is set to true, the data request will be executed immediately when 
 * DataRequest.performRequest is called.
 * @return {boolean} The indicator which determines if the data request is placed in the queue or is executed immediately
 */
DataRequest.prototype.getSkipQueueIndicator = function(){
	return this.m_skipQueueInd;
};



/* Setters */
/**
 * Sets the asynchronous indicator for the data request which determines if the data request should be executed asynchronously.  The asynchronous indicator 
 * is defaulted to true.  If this indicator is set to false, the data request will be executed synchronously effectively blocking all other processing.  
 * Please ensure you understand the performance impact your data request will have on the entire MPage if setting this flag to false.
 * @param {boolean} asyncInd A flag which determines if the data request should be executed asynchronously or synchronously
 * @return {DataRequest} A reference to the data request object for chaining purposes
 */
DataRequest.prototype.setAsyncIndicator = function(asyncInd){
	if(typeof asyncInd !== "boolean"){
		throw new Error("DataRequest.setAsyncIndicator: asyncInd parameter must be of type boolean");
	}
	//If the async indicator is set to false, we will need to skip the queue so this request doesn't get deferred to the queue
	if(asyncInd === false){
		this.setSkipQueueIndicator(true);
	}
	
	this.m_asyncInd = asyncInd;
	return this;
};

/**
 * Sets the load timer which will be used when executing the data request.  This timer is started just prior to executing the data request and is stopped just 
 * after calling the data handler function.  This effectively encapsulates the execution of the data request as well as the handling of the data returned 
 * from the request.
 * @param {RTMSTimer} loadTimer The name that will be associated to the timer object created for timing data request performance
 * @return {DataRequest} A reference to the data request object for chaining purposes
 */
DataRequest.prototype.setLoadTimer = function(loadTimer){
	if(!RTMSTimer.prototype.isPrototypeOf(loadTimer)){
		throw new Error("DataRequest.setLoadTimer: loadTimer parameter must be a RTMSTimer object");
	}
	this.m_loadTimer = loadTimer;
	return this;
};

/**
 * Sets the name associated to the data request.  This field is optional an can be used to identify one data request from another.
 * @param {string} requestName The name to associate to this data request 
 * @return {DataRequest} A reference to the data request object for chaining purposes
 */
DataRequest.prototype.setName = function(requestName){
	if(typeof requestName !== "string"){
		throw new Error("DataRequest.setRequestName: requestName parameter must be of type string and non blank");
	}
	this.m_requestName = requestName;
	return this;	
};

/**
 * Sets the response handler for the data request.  The response handler is the function that will be executed once the data has been retrieved.
 * This function will be called from the context of the data request object.  An implementation of a DataReply object will be passed to the response
 * handler function.
 * @param {function} responseHandler The function which will be executed once the data has been returned from the data request
 * @return {DataRequest} A reference to the data request object for chaining purposes
 */
DataRequest.prototype.setResponseHandler = function(responseHandler){
	if(typeof responseHandler !== "function"){
		throw new Error("DataRequest.setResponseHandler: responseHandler parameter must be a function");
	}
	this.m_responseHandler = responseHandler;
	return this;	
};

/**
 * Sets the indicator used to determine if data request should skip the request queue.  This value defaults to false and should only be used when
 * the data being retrieved is crucial for performance concerns.  If the indicator is set to true, the data request will be executed immediately when 
 * DataRequest.performRequest is called.
 * @param {boolean} skipQueueInd The indicator which determines if the data request is placed in the queue or is executed immediately
 * @return {DataRequest} A reference to the data request object for chaining purposes
 */
DataRequest.prototype.setSkipQueueIndicator = function(skipQueueInd){
	if(typeof skipQueueInd !== "boolean"){
		throw new Error("DataRequest.setSkipQueue: skipQueueInd parameter must be of type boolean");
	}
	//If we are skipping the queue we need to let the base object know we don't need to relinquish the thread
	this.m_relinquishNecessary = !skipQueueInd;
	this.m_skipQueueInd = skipQueueInd;
	return this;
};



/**
 * This function begins the process for executing a particular data request.  It is the entry point for starting all data request executions.
 * Based on the skip queue indicator, the request will either be executed immediately or placed in the DataRequestQueue.
 * @return null
 */
DataRequest.prototype.performRequest = function(){
	//Validate that the data request is utilizing the proper entry point
	this.m_validEntry = true;
	//See if we should be added to the queue or execute immediately
	if(this.m_skipQueueInd){
		//Skip the queue and execute this script immediately.
		this.execute();
	}
	else{
		//Add this script request to the data request queue and wait our turn
		DataRequestQueue.addRequest(this);
	}	
};

/**
 * This function will need to be implemented by any object which inherits from DataRequest.  Each implementation must ensure that the 
 * entry point of the data request is valid using the check commented below.  This means that the consumer of the DataRequest API has 
 * utilized the DataRequest.performRequest entry point rather than calling DataRequest.execute directly.  This check is necessary to 
 * ensure all data requests are subject to being placed within the DataRequestQueue.
 * @return null
 */
DataRequest.prototype.execute = function(){
	if(!this.m_validEntry){
		throw new Error("DataRequest.execute: The execute function should not be called directly.  PLease utilize the performRequest function for starting data requests");
	}
	throw new Error("DataRequest.execute has not been implemented");
};


/**
 * Performs the call to the data handler function after verifying that the data request has properly relinquished its thread.  This function 
 * has been made available such that implementations of the DataRequest can perform any necessary actions prior to calling that data handler function.
 * @param {DataReply} dataReply The DataReply object which contains the data returned in addition to an optional request name and status information.
 * @return null 
 */
DataRequest.prototype.handleDataResponse = function(dataReply){
	if(this.m_relinquishNecessary){
		throw new Error("DataRequest.handleDataResponse: This data request is attempting to handle a script response prior to relinquishing its thread.  PLease utilize the DataRequest.relinquishThread prior to executing the data handler");
		
	}
	if(typeof this.m_responseHandler === "function"){
		this.m_responseHandler(dataReply);
	}
};

/**
 * This function is used to relinquish the thread occupied during the execution of the data request.  Once that execution has completed this function 
 * should be called in order to allow queued data requests to begin execution. All DataRequest implementations should make a call to this function
 * after the data request has been completed.  This can be called prior to executing the data handler function.
 * should implement the exact functionality defined
 * @return null
 */
DataRequest.prototype.relinquishThread = function(){
	if(!this.m_skipQueueInd){
		DataRequestQueue.relinquishThread();
		this.m_relinquishNecessary = false;
	}
};
/**
 * @class
 * The DataReply object is the base implementation of any type of data reply object.  It defines the functions and
 * values that will be present for any type of data reply regardless of type.
 */
var DataReply = function(){
	this.m_replyName = "";
	this.m_responseData = null;
	this.m_status = null;
};

/**
 * Retrieves the name associated to the data reply.  This field is copied from the DataRequest that 
 * instantiated this data reply object.  This is an optional field. It can be used to associate a 
 * particular data reply to the original data request object.
 * @return {string} The name given to the data reply object
 */
DataReply.prototype.getName = function(){
	return this.m_replyName;
};

/**
 * Retrieves the data returned from the associated data request object.  This value is set by the associated 
 * data request object.  The data type will be dependent upon the specific implementation.
 * @return {object|string} The data returned from the data request execution.  This will most likely be a string
 * or a primitive object.  However, it will be dependent on the specific implementation.  
 */
DataReply.prototype.getResponse = function(){
	return this.m_responseData;
};

/**
 * Retrieves the status of the data request.  This value will be set by the data request object if it is able
 * to provide an interpretation of the status.  In cases where raw data is requested the data request object will
 * not be able to accurately interpret the status of the response other than implying data was retrieved.
 * @return {string} The status for the data request execution
 */
DataReply.prototype.getStatus = function(){
	return this.m_status;
};

/**
 * Sets the name that will be associated to the data reply.  This field is typically set from the DataRequest that 
 * instantiated this data reply object.  This is an optional field.  It can be used to associate a particular data 
 * reply to the original data request object.
 * @param {string} replyName The name to apply to the data reply object
 * @return {DataReply} A reference to the data reply object for chaining purposes
 */
DataReply.prototype.setName = function(replyName){
	if(typeof replyName !== "string"){
		throw new Error("DataReply.setName: replyName parameter must be of type string");
	}
	this.m_replyName = replyName;
	return this;
};

/**
 * Sets the data returned from the associated data request.  The data type will be dependent upon the specific 
 * implementation.  Thus, no specific type checks will be performed in this object.  Any data type validation
 * will need to be performed within the specific implementation of a DataReply object.
 * @param {object|string} responseData The data returned from the data request.  This will most likely be a 
 * string or a primitive object.  However, it will be dependent on the specific implementation. 
 * @return {DataReply} A reference to the data reply object for chaining purposes
 */
DataReply.prototype.setResponse = function(responseData){
	this.m_responseData = responseData;
	return this;
};

/**
 * Sets the status of the data request.  This value will be set by the data request object if it is able
 * to provide an interpretation of the status.  Each implementation of the DataReply object will need to
 * implement its own type checking based on the type of status being used.
 * @param {} status The status for the data request execution
 * @return {DataReply} A reference to the data reply object for chaining purposes
 */
DataReply.prototype.setStatus = function(status){
	this.m_status = status;
	return this;
};/*globals logger, DataRequest, XMLCCLREQUESTOBJECTPOINTER, ScriptReply, XMLCclRequest, CERN_Platform*/
/**
 * @class
 * The ScriptRequest is an implementation of a DataRequest object intended to execute CCL script requests.  
 * It will correctly handle script requests made from within and outside of a Millennium context.  The 
 * ScriptRequest object does not attempt to interpret the data being returned from the CCL script with the 
 * exception of the status. The data is passed back to the consumer via a ScriptReply object.
 */
var ScriptRequest = function(){
	//Accessible variables
	this.m_dataBlob = null;
	this.m_programName = "";
	this.m_parameterArray = null;
	this.m_rawDataInd = false;
};

/*
 * Inherit the properties and functions of the DataRequest object
 */
ScriptRequest.prototype = new DataRequest();
ScriptRequest.prototype.constructor = DataRequest;

/* Getters */
/**
 * Retrieves the data blob that will be sent to the CCL script upon execution.
 * @return {string} The data blob that will be sent to the CCL script upon execution. 
 */
ScriptRequest.prototype.getDataBlob = function(){
	return this.m_dataBlob;
};

/**
 * Retrieves the name of the CCL program that will be executed in the script request.  This is a required field.
 * @return {string} The name of the CCL program to execute 
 */
ScriptRequest.prototype.getProgramName = function(){
	return this.m_programName;
};

/**
 * Retrieves the parameter array which will be sent to the CCL program when executed within the script request.
 * @return {array} The array of parameters that will be sent to the CCL program 
 */
ScriptRequest.prototype.getParameterArray = function(){
	if(!this.m_parameterArray){
		this.m_parameterArray = [];
	}
	return this.m_parameterArray;
};

/**
 * Retrieves the raw data indicator which determines if raw data should be returned from the CCL program.  If 
 * set to true the script request object will not attempt to perform any parsing of the data.  If set to false
 * the script request will assume the data being returned is JSON data and will parse it.
 * @return {boolean} A boolean which identifies if raw data should be returned from the CCL program 
 */
ScriptRequest.prototype.getRawDataIndicator = function(){
	return this.m_rawDataInd;
};

/**
 * Sets the data blob that will be sent to the CCL script upon execution.  This data blob will be sent along with 
 * any parameters defined for the script request.
 * @param {string} dataBlob The data blob that will be sent to the CCL script upon execution.
 * @return {ScriptRequest} A reference to the script request object for chaining purposes
 */
ScriptRequest.prototype.setDataBlob = function(dataBlob){
	if(typeof dataBlob !== "string"){
		throw new Error("ScriptRequest.setDataBlob: dataBlob parameter must be of type string and non blank");
	}
	this.m_dataBlob = dataBlob;
	return this;
};

/**
 * Sets the name of the CCL program that will be executed in the script request.  This is a required field.  If
 * omitted an error will be thrown.
 * @param {string} programName The name of the CCL program to execute
 * @return {ScriptRequest} A reference to the script request object for chaining purposes
 */
ScriptRequest.prototype.setProgramName = function(programName){
	if(typeof programName !== "string" || !programName.length){
		throw new Error("ScriptRequest.setProgramName: programName parameter must be of type string and non blank");
	}
	this.m_programName = programName;
	return this;
};

/**
 * Sets the parameter array which will be sent to the CCL program when executed within the script request.
 * @param {array} parameterArray The array of parameters that will be sent to the CCL program
 * @return {ScriptRequest} A reference to the script request object for chaining purposes 
 */
ScriptRequest.prototype.setParameterArray = function(parameterArray){
	if(!(parameterArray instanceof Array)){
		throw new Error("ScriptRequest.setParameterArray: parameterArray parameter must be an array");
	}
	this.m_parameterArray = parameterArray;
	return this;
};

/**
 * Sets the raw data indicator which determines if raw data should be returned from the CCL program.  If 
 * set to true the script request object will not attempt to perform any parsing of the data.  If set to false
 * the script request will assume the data being returned is JSON data and will parse it.
 * @param {boolean} rawDataInd A boolean which identifies if raw data should be returned from the CCL program
 * @return {ScriptRequest} A reference to the script request object for chaining purposes 
 */
ScriptRequest.prototype.setRawDataIndicator = function(rawDataInd){
	if(typeof rawDataInd !== "boolean"){
		throw new Error("ScriptRequest.setRawDataIndicator: rawDataInd parameter must be of type boolean");
	}
	this.m_rawDataInd = rawDataInd;	
	return this;
};


/**
 * This function will log important execution information.  It will be called on behalf of the DataRequest API 
 * consumer prior executing the CCL program.
 * @return null
 */
ScriptRequest.prototype.logExecutionStartInfo = function(){
	logger.logMessage("Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n");
};

/**
 * This function will log important script completion information.  It will be called on behalf of the 
 * DataRequest API consumer after the CCL program has finished execution
 * @param {object} replyObj The reply object returned from the script call
 * @return null
 */
ScriptRequest.prototype.logCompletionInfo = function(replyObj){
	logger.logMessage("Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n" + 
					"readyState: " + replyObj.readyState + "\n" +
					"status: " + replyObj.status + "\n" +
					"Response: " + replyObj.responseText + "\n");
};

/**
 * This function will log important script error information.  It will be called on behalf of the 
 * DataRequest API consumer after the CCL program has finished execution
 * @param {object} replyObj The reply object returned from the script call
 * @return null
 */
ScriptRequest.prototype.logScriptExecutionError = function(replyObj){
	logger.logError("Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n" +
					"readyState: " + replyObj.readyState + "\n" +
					"status: " + replyObj.status + "\n" +
					"Response: " + replyObj.responseText + "\n");
};

/**
 * This function is used to generate an error message based on the replyObject
 * returned from the script call.
 * @param {object} replyObj The reply object returned from the script call
 * @return {string}
 */
ScriptRequest.prototype.createErrorMessage = function(replyObj){
	var errorMessage = "Discern Error:\nStatus: " + replyObj.status + "\nReply: " + replyObj.responseText + "\n";
	return errorMessage;
};

/**
 * This function releases any request references that may be held at a framework level.
 * @param {XMLHttpRequest|XMLCclRequest} The request object used to perform the script call
 * @return null
 */
ScriptRequest.prototype.releaseRequestReference = function(requestObj){
	//If this call was being made within a Millennium context
	//there is a object which keeps references to the script requests.  Not freeing those object
	//causes memory leaks.
	if(CERN_Platform.inMillenniumContext() && XMLCCLREQUESTOBJECTPOINTER){
		for (var id in XMLCCLREQUESTOBJECTPOINTER) {
			if (XMLCCLREQUESTOBJECTPOINTER.hasOwnProperty(id) && XMLCCLREQUESTOBJECTPOINTER[id] === requestObj) {
				delete XMLCCLREQUESTOBJECTPOINTER[id];
			}
		}	
	}
};

/**
 * This function is used to validate the required field needed for executing a CCL script.  If any of the required
 * fields are not present or set correctly an error will be thrown.  The ScriptRequest required fields
 * are the program name and the response handler.
 * @return null  
 */
ScriptRequest.prototype.validateScriptRequestFields = function(){
	if(!this.m_programName){
		throw new Error("ScriptRequest.startRequest: All ScriptRequest objects must contain a program name");
	}
	if(!this.m_responseHandler){
		throw new Error("ScriptRequest.startRequest: A response handler is required for ScriptRequest execution");
	}	
};

/**
 * This function is responsible for executing the script request. It will be called from within
 * the DataRequest APIs and should not be called by the DataRequest API consumer.  Direct calls to this 
 * function will result in an error being thrown.
 * @return null  
 */
ScriptRequest.prototype.execute = function(){
	if(!this.m_validEntry){
		throw new Error("ScriptRequest.execute: The execute function should not be called directly.  Please utilize the performRequest function for starting data requests");
	}
	
	//Grab the necessary fields for our ScriptRequest
	var dataBlob = this.getDataBlob();
	var loadTimer = this.getLoadTimer();
	var parameterArray = this.getParameterArray();
	var programName = this.getProgramName();
	
	//Validate the elements necessary for this request
	this.validateScriptRequestFields();
	
	//Start the load timer
	if(loadTimer){
		loadTimer.start();
	}
	
	//Determine if we need to create an XMLHttpRequest or an XMLCclRequest
	var request = null;
	if(CERN_Platform.inMillenniumContext()){
		request = new XMLCclRequest();
		request.onreadystatechange = this.generateStateChangeHandler();
		request.open("GET", programName, this.m_asyncInd);
		if(dataBlob){
			request.setBlobIn(dataBlob);
		}
		request.send(parameterArray.join(","));
	}
	else{
		request = new XMLHttpRequest();
		request.onreadystatechange = this.generateStateChangeHandler();
		var url = CERN_Platform.getScriptServletLocation();
		url += programName + "?parameters=" + encodeURIComponent(parameterArray.join(","));
		if(dataBlob){
			//TODO: Examine use of POST for blob processing
			url += "&blobIn=" + encodeURIComponent(dataBlob);
		}
		request.open("GET", url, this.m_asyncInd);
		if(dataBlob){
			request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		}
		request.send(null);
	}	
};

/**
 * This function generates the state change handler function utilized during the script request.  It will
 * take the response from the CCL script and populate a ScriptReply object.  Once populated, the ScriptReply
 * object will be passed back to the ScriptRequest via the response handler.
 * @return {function} The function to use on the state change events of a script request 
 */
ScriptRequest.prototype.generateStateChangeHandler = function(){
	var self = this;
	return function(){
		var loadTimer = self.getLoadTimer();
		var timersFailed = false;
		
		//Ignore all states except for 4
		if(this.readyState !== 4){
			return;	
		}
		else if(this.status !== 200){
			//Handle an execution error
			self.logScriptExecutionError(this);
			//Fail the timer since there was an error
			timersFailed = true;
			if(loadTimer) {
				loadTimer.fail();
			}
			
			//Relinquish the thread being held for this request and the request reference
			self.relinquishThread();
			self.releaseRequestReference(this);
			
			return;
		}
		//Relinquish the thread being held for this request
		self.relinquishThread();
		
		//Release the request reference.  If this call was being made within a Millennium context
		//there is a object which keeps references to the script requests.  Not freeing those object
		//causes memory leaks.
		self.releaseRequestReference(this);
		
		//Log some timing information 
		self.logCompletionInfo(this);
		
		//Process the response for this request
		try {
			var scriptReply = new ScriptReply();
			scriptReply.setName(self.getName());
			//See if the consumer is expecting raw data or not
			if(self.m_rawDataInd){
				scriptReply.setResponse(this.responseText);
				scriptReply.setStatus("");
			}
			else{
				var responseObj = JSON.parse(this.responseText).RECORD_DATA;
				var status = responseObj.STATUS_DATA.STATUS;
				scriptReply.setResponse(responseObj);
				scriptReply.setStatus(status);
				//Check for F status
				if("S|s|Z|z".indexOf(status) < 0){
					self.logScriptExecutionError(this);
					scriptReply.setError(self.createErrorMessage(this));
				}
			}
			//Execute the response handler function
			self.handleDataResponse(scriptReply);
		} 
		catch(err) {
			timersFailed = true;
			if(loadTimer) {
				loadTimer.fail();
			}
		} 
		finally {
			if(loadTimer && !timersFailed) {
				loadTimer.stop();
			}
		}
	};
};
/*globals DataReply*/
/**
 * @class
 * This ScriptReply object is an implementation of the base DataReply object used specifically for script requests.
 * It contains all of the properties and functions of the DataReply object in addition to an error message which can 
 * be passed to the ScriptRequest consumer. 
 */
var ScriptReply = function(){
	//Accessible variables
	this.m_error = "";
};

/*
 * Inherit the properties and functions of the DataReply object
 */
ScriptReply.prototype = new DataReply();
ScriptReply.prototype.constructor = DataReply;

/**
 * Retrieves the error message created during the execution of a script request.  This message is only populated
 * if there was an error executing the script or the script executed and there was an internal error.
 * @return {string} An error message populated by the script request object.  
 */
ScriptReply.prototype.getError = function(){
	return this.m_error;
};


/**
 * Sets the error message created during the execution of a script request.  If an error occurs when attempting
 * to execute the script or the script executes successfully but returns an error status.  In either case the
 * error message is generated on behalf of the consumer in order to provide as detailed of information as possible.
 * @param {string} An error message populated by the script request object.  
 * @return {ScriptReply} A reference to the script reply object for chaining purposes
 */
ScriptReply.prototype.setError = function(errorMessage){
	if(typeof errorMessage !== "string"){
		throw new Error("ScriptReply.setError: errorMessage parameter must be of type string");
	}
	this.m_error = errorMessage;
	return this;
};

/**
 * Sets the status of the script request.  This value will be set by the script request object if it is able
 * to provide an interpretation of the status.  In cases where raw data is requested the script request object will
 * not be able to accurately interpret the status of the response other than implying data was retrieved.
 * @param {string} status The status for the data request execution
 * @return {ScriptReply} A reference to the data reply object for chaining purposes
 */
ScriptReply.prototype.setStatus = function(status){
	if(typeof status !== "string"){
		throw new Error("ScriptReply.setStatus: status parameter must be of type string");
	}
	this.m_status = status;
	return this;
};/*globals ScriptReply*/

/**
 * @class
 * This ComponentScriptReply object is an extension of the ScriptReply object and is used specifically in
 * conjunction with ComponentScriptRequest objects.  It contains all of the properties and functions of the 
 * ScriptReply object in addition to a reference to the component utilized in the ComponentScriptRequest object.
 */
var ComponentScriptReply = function(){
	this.m_componentObj = null;
};

/*
 * Inherit the properties and functions of the ScriptReply object
 */
ComponentScriptReply.prototype = new ScriptReply();
ComponentScriptReply.prototype.constructor = ScriptReply;

ComponentScriptReply.prototype.getComponent = function(){
	return this.m_componentObj;
};

/**
 * Sets the MPageComponent object utilized in the ComponentScriptRequest object so the consumer will have access
 * to the component within the response handler function.
 * @param {MPageComponent} componentObj
 * @return {ComponentScriptReply} A reference to the component script reply object for chaining purposes
 */
ComponentScriptReply.prototype.setComponent = function(componentObj){
	if(!MPageComponent.prototype.isPrototypeOf(componentObj)){
		throw new Error("ComponentScriptReply.setComponent: componentObj parameter must be an instance of a MPageComponent");
	}
	this.m_componentObj = componentObj;
	return this;
};

/*globals ScriptRequest, ComponentScriptReply, logger, RTMSTimer*/

/**
 * @class
 * The ComponentScriptRequest is a specific implementation of a ScriptRequest object utilized for 
 * handling script calls for MPageComponent objects.  Its purpose is to provide general script handling functionality 
 * on behalf of an MPageComponent object.  It will automatically handle script responses with either a 'Z' or 'F' 
 * status and utilize the associated MPageComponent object to generate the correct visuals.  If an S status is 
 * returned the ComponentScriptRequest object will pass the script data back to the MPageComponent via the 
 * MPageComponent.renderComponent function or the ComponentScriptRequest.responseHandler function if provided.
 */
var ComponentScriptRequest = function(){
	//A reference to the component object which is associated with this ComponentScriptRequest
	this.m_componentObj = null;
	//The timer that will be used to time the render function of the component
	this.m_renderTimer = null;
};

/*
 * Inherit the properties and functions of the ScriptRequest object
 */
ComponentScriptRequest.prototype = new ScriptRequest();
ComponentScriptRequest.prototype.constructor = ScriptRequest;

/**
 * Retrieves the MPageComponent object associated with this component script request.
 * @return {MPageComponent} The MPageComponent object associated with this component script request
 */
ComponentScriptRequest.prototype.getComponent = function(){
	return this.m_componentObj;
};

/**
 * Retrieves the timer that is used to time the render function of the component.
 * @return {RTMSTimer} The RTMSTimer object
 */
ComponentScriptRequest.prototype.getRenderTimer = function(){
	return this.m_renderTimer;
};

/**
 * Sets the MPageComponent object that will be used when handling the script's data response.  If the status of 
 * the response is 'Z' or 'F' the component script request will render the correct visuals on behalf of the component.
 * If a 'S' status is returned the MPageComponent.renderComponent or the ComponentScriptRequest.responseHandler function
 * will be called passing in a ComponentScriptReply containing the script's response.  If raw data is requested from 
 * the consumer no interpretation of the data will take place.
 * @param {MPageComponent} componentObj
 * @return {ComponentScriptRequest} A reference to the component script request object for chaining purposes
 */
ComponentScriptRequest.prototype.setComponent = function(componentObj){
	if(!MPageComponent.prototype.isPrototypeOf(componentObj)){
		throw new Error("ComponentScriptRequest.setComponent: The componentObj parameter must be a MPageComponent object");
	}
	
	this.m_componentObj = componentObj;
	return this;
};

/**
 * Sets the render timer which will be used when executing the renderComponent function.  This timer is started just prior
 * to executing the render function and is stopped just it returns.  
 * @param {RTMSTimer} renderTimer The name that will be associated to the timer object created for timing the renderComponent function
 * @return {ComponentScriptRequest} A reference to the data request object for chaining purposes
 */
ComponentScriptRequest.prototype.setRenderTimer = function(renderTimer){
	if(!RTMSTimer.prototype.isPrototypeOf(renderTimer)){
		throw new Error("ComponentScriptRequest.setRenderTimer: renderTimer parameter must be a RTMSTimer object");
	}
	this.m_renderTimer = renderTimer;
	return this;
};

/**
 * This function is used to validate the required field needed for executing a CCL script.  If any of the required
 * fields are not present or set correctly an error will be thrown.  The ComponentScriptRequest required fields
 * are the program name and the component object.
 * @return null  
 */
ComponentScriptRequest.prototype.validateScriptRequestFields = function(){
	if(!this.m_programName){
		throw new Error("ComponentScriptRequest.startRequest: All ScriptRequest objects must contain a program name");
	}
	//Validate that a component object is present before executing the request
	if(!this.m_componentObj){
		throw new Error("ComponentScriptRequest.startRequest: All ComponentScriptRequest objects must contain an associated MPageComponent object");
	}
};

/**
 * This function will log important execution information.  It will be called on behalf of the DataRequest API 
 * consumer prior executing the CCL program.
 * @return null
 */
ComponentScriptRequest.prototype.logExecutionStartInfo = function(){
	logger.logMessage("Component Name: " + this.getComponent().getLabel() + "\n" +
					"Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n");
};

/**
 * This function will log important script completion information.  It will be called on behalf of the 
 * DataRequest API consumer after the CCL program has finished execution
 * @param {object} replyObj The reply object returned from the script call
 * @return null
 */
ComponentScriptRequest.prototype.logCompletionInfo = function(replyObj){
	logger.logMessage("Component Name: " + this.getComponent().getLabel() + "\n" +
					"Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n" + 
					"readyState: " + replyObj.readyState + "\n" +
					"status: " + replyObj.status + "\n" +
					"Response: " + replyObj.responseText + "\n");
};

/**
 * This function will log important script error information.  It will be called on behalf of the 
 * DataRequest API consumer after the CCL program has finished execution
 * @param {object} replyObj The reply object returned from the script call
 * @return null
 */
ComponentScriptRequest.prototype.logScriptExecutionError = function(replyObj){
	logger.logError("Component Name: " + this.getComponent().getLabel() + "\n" +
					"Request Name: " + this.getName() + "\n" +
					"Program Name: " + this.getProgramName() + "\n" + 
					"Parameter Array: " + this.getParameterArray() + "\n" +
					"Data Blob: " + this.getDataBlob() + "\n" +
					"readyState: " + replyObj.readyState + "\n" +
					"status: " + replyObj.status + "\n" +
					"Response: " + replyObj.responseText + "\n");
};

/**
 * This function generates the state change handler function utilized during the script request.  It will
 * take the response from the CCL script and determine the status of a scripts execution.  Upon a 'Z' status the
 * function will populate the 'No data found' messaging and render the same for the component.  Upon a 'F' status 
 * the function will populate the 'Error occurred' messaging and render the same for the component.  If the script 
 * call was a success and data is available for the component, a new ComponentScriptReply object will be populated.
 * Once the reply has been created the function will call either the response handler function if it has been 
 * populated or it will call the MPageComponent.finalizeComponent function.  Before returning, the function will 
 * call the post MPageComponent.postProcessing function to allow the component to handle and processing that 
 * needs to take place post render.
 * @return {function} The function to use on the state change events of a script request 
 */
ComponentScriptRequest.prototype.generateStateChangeHandler = function(){
	var self = this;
	
	return function(){
		var component = self.getComponent();
		var componentScriptReply = null;
		var loadTimer = self.getLoadTimer();
		var renderTimer = self.getRenderTimer();
		var requiresRawData = false;
		var responseHandler = null;
		var responseObj = null;
		var status = "";
		var timersFailed = false;
		
		//Ignore all states except for 4
		if(this.readyState !== 4){
			return;	
		}
		else if(this.status !== 200){
			//Handle an execution error
			self.logScriptExecutionError(this);
			component.finalizeComponent(component.generateScriptFailureHTML(), (component.isLineNumberIncluded() ? "(0)" : ""));
			//Fail the timer since there was an error
			timersFailed = true;
			if(loadTimer) {
				loadTimer.fail();
			}
			
			//Relinquish the thread being held for this request and the request reference
			self.relinquishThread();
			self.releaseRequestReference(this);
			
			return;
		}
		//Relinquish the thread being held for this request
		self.relinquishThread();
		
		//Release the request reference.  If this call was being made within a Millennium context
		//there is a object which keeps references to the script requests.  Not freeing those object
		//causes memory leaks.
		self.releaseRequestReference(this);
		
		//Log some timing information 
		self.logCompletionInfo(this);
		
		//Process the response for this request
		try {
			requiresRawData = self.getRawDataIndicator();
			if(!requiresRawData){
				//If we are looking for raw data then we cannot expect JSON as a response
				responseObj = JSON.parse(this.responseText).RECORD_DATA;
				status = responseObj.STATUS_DATA.STATUS;
			}
			
			//If a callback is defined we can skip the handling of the different status'
			responseHandler = self.getResponseHandler();
			
			if(typeof responseHandler === "function"){
				//If a responseHandler is defined that trumps the logic to handle the response for the componet.  Ideally the component
				//developer would utilize a standard ScriptRequest.
				componentScriptReply = new ComponentScriptReply();
				componentScriptReply.setComponent(component);
				componentScriptReply.setName(self.getName());
				componentScriptReply.setResponse(requiresRawData ? this.responseText : responseObj);
				componentScriptReply.setStatus(status);
				//Start the rendering timer
				if(renderTimer){
					renderTimer.start();
				}
				//The component has defined a callback to utilize instead of utilizing the functionality provided in this DataRequest implementation
				self.handleDataResponse(componentScriptReply);
			}
			else if(requiresRawData){
				//If the component requires raw data we cannot assume the data is JSON thus we can't check for the status
				componentScriptReply = new ComponentScriptReply();
				componentScriptReply.setComponent(component);
				componentScriptReply.setName(self.getName());
				componentScriptReply.setResponse(this.responseText);
				//Start the rendering timer
				if(renderTimer){
					renderTimer.start();
				}
				//The component has defined a callback to utilize instead of utilizing the functionality provided in this DataRequest implementation
				component.renderComponent(componentScriptReply);
			}
			else{
				if(status.toUpperCase() === "Z"){
					component.finalizeComponent(component.generateNoDataFoundHTML(), (component.isLineNumberIncluded() ? "(0)" : ""));
				}
				else if(status.toUpperCase() === "S"){
					//Update the subtitle to rendering
					component.updateSubLabel(i18n.discernabu.RENDERING_DATA + "...");
					//Start the rendering timer
					if(renderTimer){
						renderTimer.start();
					}
					//Call the generic component loading renderComponent function so the component can render its content.
					component.renderComponent(responseObj);
				}
				else{
					//All status's other than "S" and "Z" will be treated as a Failure status
					self.logScriptExecutionError(this);
					//Generate the error message from the request
					logger.logError(self.createErrorMessage(this));
					//Hander the error response on behalf of the component
					component.finalizeComponent(component.generateScriptFailureHTML(), (component.isLineNumberIncluded() ? "(0)" : ""));
				}
			}
		} 
		catch(err) {
			timersFailed = true;
			if(renderTimer) {
				renderTimer.fail();
			}
			if(loadTimer) {
				loadTimer.fail();
			}
			component.finalizeComponent(component.generateScriptFailureHTML(), (component.isLineNumberIncluded() ? "(0)" : ""));
		} 
		finally {
			if(renderTimer && !timersFailed) {
				renderTimer.stop();
			}
			if(loadTimer && !timersFailed) {
				loadTimer.stop();
			}
			//After the component has rendered call the postProcessing function to perform any additional actions
			component.postProcessing();
		}
	};
};/*globals DataRequest */

/**
 * @namespace
 * The DataRequestQueue is responsible for queuing up DataRequest instances.  It allows the consuming framework to 
 * limit the number of concurrent threads being processed.
 */
var DataRequestQueue = {
	m_threadPoolCount : 6,
	m_threadQueue : [],
	m_activeThreadsCnt: 0
};

/**
 * This function is utilized to alter the number of available threads within the consuming framework.  It is recommended that
 * this number be set prior to any thread executions.  However, there are no restrictions to altering this number at any time.
 * Once all threads are being consumed DataRequests are added to a queue in a first come first served basis.
 * @param {number} threadPoolCount The number of threads that the queue will allow at any one time.
 * @return null
 */
DataRequestQueue.setThreadPoolCount = function(threadPoolCount){
	if(typeof threadPoolCount !== "number" || threadPoolCount % 1 !== 0 || threadPoolCount <= 0){
		throw new Error("DataRequestQueue.setThreadPoolCount: threadPoolCount parameter should be of type number");
	}
	this.m_threadPoolCount = threadPoolCount;
};

/**
 * Adds a DataRequest object to the current queue of requests.  If there are no existing requests to be processed the newly
 * added request will be executed immediately.  If there are existing data requests they will be processed in a first come
 * first served bases. 
 * @param {DataRequest} requestObj The data request object to be processed once a thread is available
 * @return null
 */
DataRequestQueue.addRequest = function(requestObj){
	if(!(requestObj instanceof DataRequest)){
		throw new Error("DataRequestQueue.addRequest: Invalid request.  Request must be of data type DataRequest");
	}
	
	this.m_threadQueue.push(requestObj);
	//Check to see if we can execute the newly added request or not
	this.executeRequest();
};

/**
 * Attempts to execute the first data request that is on the front of the queue.  This function is called when a new 
 * DataRequest object is added to the queue as well as when one of the existing threads is relinquished by a previous
 * request.
 * @return null 
 */
DataRequestQueue.executeRequest = function(){
	var requestObj = null;
	//Compare active threads against threadPoolCount
	if(this.m_activeThreadsCnt < this.m_threadPoolCount){
		//A thread is available so execute the first DataRequest object if it exists
		requestObj = this.m_threadQueue.shift();
		if(requestObj){
			this.m_activeThreadsCnt++;
			requestObj.execute();
		}
	}
};

/**
 * This function is responsible for relinquishing a single thread and returning it back to the thread pool.  This 
 * should be called by all DataRequest implementations once the data request has completed.
 * @return null
 */
DataRequestQueue.relinquishThread = function(){
	if(this.m_activeThreadsCnt <= 0){
		//If we have an active thread count of 0 prior to relinquishing our thread we need to throw an error.
		throw new Error("DataRequestQueue.relinquishThread: thread pool invalid.  Too many threads relinquished.");
	}
	this.m_activeThreadsCnt--;
	//Start the next DataRequest on the queue if there is one
	this.executeRequest();
};

/*globals CERN_BrowserDevInd, hs*/
/*eslint-disable no-mixed-spaces-and-tabs*/

var CERN_DISCHARGE_DASHBOARD = function(){
	//Pseudo scoped variables to CERN_DISCHARGE_DASHBOARD

	var activeList = [];
	var appName = '$APP_AppName$';
	var begVal = 0;
	var callCnt = 0;
	var continueInd = 1;
	var criterion = null;
	var dcWidthCls = 30 / 4;
	var losWidthCls = 30 / 4;
	var nmWidthCls = 30 / 4;
	var patObj = null;
	var sortOrder = 0;
	var sortType = 0;
	var tabName;


	function resizePatientList(){
		var bodyHeight = $('body').height();
		var titleHeight = 41;
		var listSelectionHeight = 31;
		var headerRowHeight = $("#drdHdrRow").outerHeight(true);
		$('#drdPatTable1').css({ 'max-height': (bodyHeight - titleHeight - listSelectionHeight - headerRowHeight ) + 'px' });
	}

	/**
	 * Common function to retrieve data.
	 *
	 * @param {String} url    Script name
	 * @param {String} callback    function to be called once data is successfully retrieved.
	 * @param {String} params    Parameters to be passed along with script.
	 * @param {number} hdrInd    Header indicator.
	 * @returns {undefined} This function does not return a value
	 */
	function load(url, callback, params, hdrInd) {

		var xhr = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest(); //eslint-disable-line mp-camelcase

		function checkReady() {//check to see if request is ready
			if (xhr.readyState === 4) {// 4 = 'loaded'
				if (xhr.status === 200) {// 200 = OK
					callback(xhr.responseText, hdrInd);
					if (url === 'mp_get_disch_ind_json_cache') {
						callCnt = callCnt - 1;
						if (callCnt < 5) {
							continueInd = 1;
						}
					}
				}
				else {
					throw new Error(i18n.ERROR_RETREIVING_DATA);
				}
			}
		}

		callCnt = callCnt + 1;
		if (callCnt === 5) {
			continueInd = 0;
		}


		xhr.onreadystatechange = checkReady;
		if (CERN_BrowserDevInd) { //eslint-disable-line mp-camelcase
			var browserUrl = url + '?parameters=' + params;
			xhr.open('GET', browserUrl, true);
			xhr.send(null);
		}
		else {
			xhr.open('GET', url, true);
			xhr.send(params);
		}

	}

	/**
	 * function to load patient list.
	 * @returns {undefined} This function does not return a value
	 */
	function loadPatientList() {
		var patSec = _g('drdPat');
		patSec.innerHTML = '<span class=\'drd-pat-txt\'>' + i18n.LOADING_DATA + '...</span>';
		var patientList = _g('drdPatLists');

		patientList.onchange = function() {
			window.name = patientList.options[patientList.options.selectedIndex].value;
		};
		var listID = 0;
		if (window.name.length > 0) {
			listID = window.name;
			for (var i = 0; i < patientList.options.length; i++) {

				if (patientList.options[i].value === window.name) {
					patientList.options[i].selected = true;
				}
			}
		}
		else {
			listID = patientList.options[patientList.options.selectedIndex].value;
			window.name = listID;
		}

		var params = '^MINE^,' + criterion.provider_id + '.0,' + listID + '.0,^' + criterion.category_meaning + '^';
		load('mp_get_disch_avail_patients', loadPatients, params, 0);
	}

	/**
	 * function to display patient data.
	 *
	 * @param {String} availPatList        json output.
	 * @returns {undefined} This function does not return a value
	 */
	function loadPatients(availPatList) {
		var estDcdt = '';
		var jsonEval = JSON.parse(availPatList);
		var jsonObj = jsonEval.RECORD_DATA;
		var patientHdrHTML = '';
		var patientDataRows = [];
		var patLen = 0;
		var patSec = _g('drdPat');
		var params = '';
		var sHov = '';

		activeList = [];
		//Since the script is returning an bloated array due to the CCL expand functionality we have to trim the array
		patObj = jsonObj.PATIENTS = jsonObj.PATIENTS.splice(0, jsonObj.PATIENT_CNT);
		patLen = jsonObj.PATIENTS.length;

		if (patLen === 0) {
			patientHdrHTML = '<span class=\'pat-txt\'>' + i18n.NO_PATIENTS + '</span>';
			patSec.innerHTML = patientHdrHTML;
		}
		else {
			var widthClass = 70.0;
			var patientHdrArr = [ '<div id=\'drdPatSec\' class=\'drd-pat-sec\'><div id=\'drdTableHdr\' class=\'drd-table-hdr\'><table class=\'drd-pat-table\'><tr id=\'drdHdrRow\'  class=\'drd-pat-table-hdr\'><td class=\'drd-pat-col-hdr\' style=\'width: '
				, nmWidthCls
				, '%\'><span id=\'patName\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(0,1); return false;\'>'
				, i18n.PATIENT_NAME
				, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: '
				, losWidthCls
				, '%\'><span id=\'los\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(1, 2); return false;\'>'
				, i18n.LENGTH_OF_STAY
				, '<br/>(DD:HH:MM)</span></td><td id=\'eddHdr\' class=\'drd-pat-col-hdr\' style=\'width:'
				, dcWidthCls
				, '%;border-right:#E6E8F1 3px solid;\'><span id=\'edd\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(2,3); return false;\'>'
				, i18n.ESTIMATED_DISCHARGE_DATE
				, '</span></td><td class=\'drd-pat-col-hdr\' style= \'width: '
				, widthClass
				, '%\'><span>'
				, i18n.LOADING_DATA
				, '...</span></td></tr></table></div><div id=\'patContent\'></div>' ];

			patientHdrHTML = patientHdrArr.join('');
			patSec.innerHTML = patientHdrHTML;

			patientDataRows.push('<div id=\'drdPatTable1\' class=\'drd-pat-table1-hdr\'>');

			for (var i = 0; i < patLen; i++) {
				var patientItem = patObj[i];
				var patientId = patientItem.PERSON_ID;
				var encId = patientItem.ENCNTR_ID;
				var patDataSingleRow = [];
				var patDataSingleHTML = '';
				sHov = '<div class=\'hvr hover\'><dl><dt><span>' + i18n.NAME + ':</span></dt><dd><span>' + patientItem.PERSON_NAME + '</span></dd><dt><span>' + i18n.MRN + ':</span></dt><dd><span>' + patientItem.MRN + '</span></dd><dt><span>' + i18n.DOB + ':</span></dt><dd><span>' + formatDate(patientItem.DOB, 'shortDate2') + '</span></dd><dt><span>' + i18n.LOCATION + ':</span></dt><dd><span>' + patientItem.NU_ROOM_BED + '</span></dd></dl></div>';

				if (patientItem.EST_DC) {
					estDcdt = formatDate(patientItem.EST_DC, 'shortDate2');
				}
				else {
					estDcdt = '--';
				}

				//populate the patient demographic header result row for each patient in dashboard.
				params = '/PERSONID=' + patientId + ' /ENCNTRID=' + encId + ' /FIRSTTAB=^' + tabName + '^';
				var patientNameLink =  '<a class= \'drd-pat-link\' href=\'javascript:APPLINK(0,"' + appName + '","' + params + '");\'>' + patientItem.PERSON_NAME + '</a>';

				patDataSingleRow.push('<div id=\'drdDataTable', encId, '\' class =\'test\'><table class=\'drd-pat-table1\'><tr id=\'drdDataCols', encId, '\'><td class=\'drd-pat-name\' style=\'width: ', nmWidthCls, '%\'><dl class=\'drd-pat-info\'><dt><span>', i18n.NAME, '</span></dt><dd><span>', patientNameLink, '</span><br/><span class=\'drd-within\'>', patientItem.GENDER_AGE, '</span><br/><span class=\'drd-within\'>', patientItem.ROOM_BED, '</span></dd></dl><h4 class=\'drd-pat-det-hd\'><span>', i18n.PATIENT_INFO, '</span></h4>', sHov, '</td><td class=\'drd-pat-col-hdr\' style=\'width: ', losWidthCls, '%\'><span>', patientItem.LOS, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ', dcWidthCls, '%; border-right:3px solid #E6E8F1;\'><span>', estDcdt, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ' + widthClass + '%\'><span>', i18n.LOADING_DATA, '...</span></td></tr></table></div>');
				patDataSingleHTML = patDataSingleRow.join('');
				patientDataRows.push(patDataSingleHTML);
				var thisPatArr = [];
				var thisPatHTML = '';
				thisPatArr.push(patDataSingleHTML);
				thisPatHTML = thisPatArr.join('');

				var thisPat = {
					NAME: patientItem.PERSON_NAME,
					PERSON_ID: patientId,
					ENCNTR_ID: encId,
					DOB: patientItem.DOB,
					MRN: patientItem.MRN,
					NU_ROOM_BED: patientItem.NU_ROOM_BED,
					GENDER_AGE: patientItem.GENDER_AGE,
					ROOM_BED: patientItem.ROOM_BED,
					LOS: patientItem.LOS,
					LOS_SEQ: patientItem.LOS_SEQ,
					DISCHARGE_DATE: estDcdt,
					DX_STATUS_FLAG: 0,
					RES_STATUS_FLAG: 0,
					SOC_STATUS_FLAG: 0,
					DOC_STATUS_FLAG: 0,
					CM_STATUS_FLAG: 0,
					ACT_STATUS_FLAG: 0,
					MED_STATUS_FLAG: 0,
					PED_STATUS_FLAG: 0,
					FU_STATUS_FLAG: 0,
					ORD_STATUS_FLAG: 0,
					QM_STATUS_FLAG: 0,
					HTML: thisPatHTML
				};

				activeList.push(thisPat);
			}

			patientDataRows.push('</div></div>');
			var patContent = _g('patContent');
			if (patContent) {
				patContent.innerHTML = patientDataRows.join('');
			}
			CERN_DISCHARGE_DASHBOARD.secInit('drd-pat');
			CERN_DISCHARGE_DASHBOARD.highlightEvenRows();

			//Evaluate the height of the current viewing container and set the max height on the drdPatTable1
			resizePatientList();
			$('body').css('overflow-y', 'hidden');
			//Add window resize events to adjust as well
			$(window).resize(function() {
				resizePatientList();
			});
		}

		//Make the calls to get data for each patient
		if (patLen > 0) {
			begVal = 0;
			callCnt = 0;
			asynchThrottleControl();
		}
	}

	/**
	 *    Function to retrieve data recursively.
	 *    @returns {undefined} This function does not return a value
	 */
	function asynchThrottleControl() {
		var patCount = patObj.length;
		if (begVal < patCount) {
			if (continueInd > 0) {
				var patient = patObj[begVal];
				var params = '^MINE^,' + 'value(' + patient.PERSON_ID + '.0)' + ',' + 'value(' + patient.ENCNTR_ID + '.0)' + ',^' + criterion.category_meaning + '^,' + criterion.provider_id + '.0' + ',' + criterion.position_cd + '.0' + ',0.0,0.0';
				load('mp_get_disch_ind_json_cache', loadPatientStatusData, params, begVal);
				begVal = begVal + 1;
			}
			var funcName = function() {
				asynchThrottleControl();
			};
			setTimeout(funcName, 50);
		}
	}

	/**
	 *    Function to display patient status.
	 *
	 * @param {String} xhr        JSON reply
	 * @param {number} hdrInd    Header indicator
	 * @returns {undefined} This function does not return a value
	 */
	function loadPatientStatusData(xhr, hdrInd) {
		var jsonEval = JSON.parse(xhr);
		var jsonQual = jsonEval.RECORD_DATA.QUAL;

		for (var x = 0; x < jsonQual.length; x++) {

			var jsonObj = jsonQual[x];
			var jsComp = jsonObj.COMPONENTS;
			var diagnosisSeq = 0;
			var resultSeq = 0;
			var followupSeq = 0;
			var medReconcileSeq = 0;
			var documentSeq = 0;
			var socialSeq = 0;
			var activitySeq = 0;
			var careManagementSeq = 0;
			var patientEduSeq = 0;
			var orderSeq = 0;
			var qualityMeasureSeq = 0;
			var compDataRows = [];
			var compDataHTML = '';
			var statLen = jsComp.length;
			var dobDt = '';
			var widthClass = 0;
			if (statLen > 0) {
				widthClass = 69.5 / (statLen);
			}
			else {
				widthClass = 69.5;
			}
			if (hdrInd === 0) {
				loadColumnHeaders(jsComp);
			}

			var params = '/PERSONID=' + jsonObj.PERSON_ID + ' /ENCNTRID=' + jsonObj.ENCNTR_ID + ' /FIRSTTAB=^' + tabName + '^';
			var activeLen = activeList.length;
			for (var s = 0; s < activeLen; s++) {
				if (activeList[s].PERSON_ID === jsonObj.PERSON_ID && activeList[s].ENCNTR_ID === jsonObj.ENCNTR_ID) {
					if (activeList[s].DOB) {
						dobDt = formatDate(activeList[s].DOB, 'shortDate2');
					}
					else {
						dobDt = '^^';
					}
					var sHov = '<div class=\'hvr hover\'><dl><dt><span>' + i18n.NAME + ':</span></dt><dd><span>' + activeList[s].NAME + '</span></dd><dt><span>' + i18n.MRN + ':</span></dt><dd><span>' + activeList[s].MRN + '</span></dd><dt><span>' + i18n.DOB + ':</span></dt><dd><span>' + dobDt + '</span></dd><dt><span>' + i18n.LOCATION + ':</span></dt><dd><span>' + activeList[s].NU_ROOM_BED + '</span></dd></dl></div>';
					var numberOfcompents = jsComp.length;
					for (var y = 0; y < numberOfcompents; y++) {
						var estDtTmItem = jsComp[y];

						if (estDtTmItem.CONTENT_TYPE === 'disch-readiness') {
							if (estDtTmItem.ESTIMATED_DISCH_DATE) {
								activeList[s].DISCHARGE_DATE = formatDate(estDtTmItem.ESTIMATED_DISCH_DATE, 'shortDate2');
							}
							else {
								activeList[s].DISCHARGE_DATE = '--';
							}
						}
					}
					if (statLen > 0) {
						compDataRows.push('<table class=\'drd-pat-table1\' class =\'test\'><tr id=\'drdDataCols', jsonObj.ENCNTR_ID, '\'><td class=\'drd-pat-name\' style=\'width: ', nmWidthCls, '%\'><dl class=\'drd-pat-info\'><dt><span>Name</span></dt><dd><span><a class= \'drd-pat-link\' href=\'javascript:APPLINK(0,"', appName, '","', params, '");\'>', activeList[s].NAME, '</a></span><br/><span class=\'drd-within\'>', activeList[s].GENDER_AGE, '</span><br/><span class=\'drd-within\'>', activeList[s].ROOM_BED, '</span></dd></dl><h4 class=\'drd-pat-det-hd\'><span>Patient Info</span></h4>', sHov, '</td><td class=\'drd-pat-col-hdr\' style=\'width: ', losWidthCls, '%\'><span>', activeList[s].LOS, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ', dcWidthCls, '%; border-right:#E6E8F1 3px solid;\'><span>', activeList[s].DISCHARGE_DATE, '</span></td>');

						for (var j = 0; j < jsComp.length; j++) {
							var statHdrItem = jsComp[j];
							switch (statHdrItem.CONTENT_TYPE) {
								case 'diagnosis':
									diagnosisSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'follow-up':
									followupSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'pat-edu':
									patientEduSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'med-rec':
									medReconcileSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'orders':
									orderSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'documents':
									documentSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'activities':
									activitySeq = statHdrItem.STATUS_FLAG;
									break;
								case 'care-mgmt':
									careManagementSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'social':
									socialSeq = statHdrItem.STATUS_FLAG;
									break;
								case 'quality-meas':
									qualityMeasureSeq = statHdrItem.STATUS_FLAG;
									break;
							}

							//populate the 	data rows for each section in dashboard.
							if ('orders|diagnosis|pat-edu|follow-up|med-rec|documents|activities|social|care-mgmt|quality-meas'.indexOf(statHdrItem.CONTENT_TYPE) >= 0) {
								compDataRows.push('<td class=\'drd-pat-col-hdr\' style=\'width: ', widthClass, '%\'><span>', getDischargeStatus(statHdrItem.CONTENT_TYPE, statHdrItem.STATUS_FLAG), '</span></td>');
							}
						}

						for (var i = 0; i < jsComp.length; i++) {
							var hdrItem = jsComp[i];
							if (hdrItem.CONTENT_TYPE === 'results') {
								//If there is no result set flg to -1 so that the '--' is displayed
								if (hdrItem.STATUS_FLAG === 0 || hdrItem.STATUS_FLAG === 3) {
									resultSeq = -1;
								}
								else {
									resultSeq = hdrItem.RESULT_FLAG;
								}

								//Force the results section data into the last column
								compDataRows.push('<td class=\'drd-pat-col-hdr\' style=\'width: ', widthClass, '%\'><span>', getDischargeStatus(hdrItem.CONTENT_TYPE, resultSeq), '</span></td>');
							}
						}
					}
					else {
						compDataRows.push('<table class=\'drd-pat-table1\' class =\'test\'><tr id=\'drdDataCols', jsonObj.ENCNTR_ID, '\'><td class=\'drd-pat-name\' style=\'width: ', nmWidthCls, '%\'><dl class=\'drd-pat-info\'><dt><span>Name</span></dt><dd><span><a class= \'drd-pat-link\' href=\'javascript:APPLINK(0,"', appName, '","', params, '");\'>', activeList[s].NAME, '</a></span><br/><span class=\'drd-within\'>', activeList[s].GENDER_AGE, '</span><br/><span class=\'drd-within\'>', activeList[s].ROOM_BED, '</span></dd></dl><h4 class=\'drd-pat-det-hd\'><span>Patient Info</span></h4>', sHov, '</td><td class=\'drd-pat-col-hdr\' style=\'width: ', losWidthCls, '%\'><span>', activeList[s].LOS, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ', dcWidthCls, '%; border-right:#E6E8F1 3px solid;\'><span>', activeList[s].DISCHARGE_DATE, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ', widthClass, '%\'><span>', i18n.NO_RESULTS_FOUND, '</span></td>');
					}

					compDataRows.push('</tr></table>');
					compDataHTML = compDataRows.join('');
					var dataRowId = 'drdDataTable' + jsonObj.ENCNTR_ID;
					var dataRowDiv = _g(dataRowId);
					if (dataRowDiv) {
						dataRowDiv.innerHTML = compDataHTML;
					}

				}
			}

			for (var t = 0; t < activeLen; t++) {
				if (activeList[t].PERSON_ID === jsonObj.PERSON_ID && activeList[t].ENCNTR_ID === jsonObj.ENCNTR_ID) {
					activeList[t].DX_STATUS_FLAG = diagnosisSeq;
					activeList[t].RES_STATUS_FLAG = resultSeq;
					activeList[t].SOC_STATUS_FLAG = socialSeq;
					activeList[t].DOC_STATUS_FLAG = documentSeq;
					activeList[t].CM_STATUS_FLAG = careManagementSeq;
					activeList[t].ACT_STATUS_FLAG = activitySeq;
					activeList[t].MED_STATUS_FLAG = medReconcileSeq;
					activeList[t].PED_STATUS_FLAG = patientEduSeq;
					activeList[t].FU_STATUS_FLAG = followupSeq;
					activeList[t].ORD_STATUS_FLAG = orderSeq;
					activeList[t].QM_STATUS_FLAG = qualityMeasureSeq;
					activeList[t].HTML = compDataHTML;
				}
			}

		}// end for

		var patContent = _g('patContent');
		CERN_DISCHARGE_DASHBOARD.secInit('drd-pat', patContent);
		CERN_DISCHARGE_DASHBOARD.highlightEvenRows();
	}

	/**
	 *    Function to display component array.
	 * @param {Array} compAr    Array of components.
	 * @returns {undefined} This function does not return a value
	 */
	function loadColumnHeaders(compAr) {
		var columnCount = 2;
		var compHdrAr = [];
		var compHdrHTML = '';
		var type = 0;
		var parentHdrDiv = _g('drdTableHdr');
		var statHdrItem = null;
		var widthClass = 0;
		if (compAr.length > 0) {
			var colLen = compAr.length;
			widthClass = 69.5 / (colLen);
			compHdrAr.push('<table class=\'drd-pat-table\'><tr id=\'drdHdrRow\'  class=\'drd-pat-table-hdr\'><td class=\'drd-pat-col-hdr\' style=\'width: ' + nmWidthCls + '%\'><span id=\'patName\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(0,1); return false;\'>', i18n.PATIENT_NAME, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ' + losWidthCls + '%\'><span id=\'los\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(1, 2); return false;\'>', i18n.LENGTH_OF_STAY, '<br/>(DD:HH:MM)</span></td><td id=\'eddHdr\' class=\'drd-pat-col-hdr\' style=\'width: ' + dcWidthCls + '%;border-right:#E6E8F1 3px solid;\'><span id=\'edd\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(2,3); return false;\'>', i18n.ESTIMATED_DISCHARGE_DATE, '</span></td>');

			for (var l = 0; l < compAr.length; l++) {
				statHdrItem = compAr[l];
				switch (statHdrItem.CONTENT_TYPE) {
					case 'diagnosis':
						type = 5;
						break;
					case 'follow-up':
						type = 7;
						break;
					case 'pat-edu':
						type = 6;
						break;
					case 'med-rec':
						type = 8;
						break;
					case 'orders':
						type = 4;
						break;
					case 'documents':
						type = 9;
						break;
					case 'activities':
						type = 10;
						break;
					case 'care-mgmt':
						type = 12;
						break;
					case 'social':
						type = 11;
						break;
					case 'quality-meas':
						type = 14;
						break;
				}
				//Populate the header values for each data column
				if ('orders|diagnosis|pat-edu|follow-up|med-rec|documents|activities|social|care-mgmt|quality-meas'.indexOf(statHdrItem.CONTENT_TYPE) >= 0) {
					columnCount = columnCount + 1;
					compHdrAr.push('<td class=\'drd-pat-col-hdr\' style=\'width:', widthClass, '%\'><span id=\'drd', type, '\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(', columnCount, ',', type, '); return false;\'>', statHdrItem.NAME, '</span></td>');
				}
			}

			//Force the 'results' column to the end
			for (var i = 0; i < compAr.length; i++) {
				statHdrItem = compAr[i];
				if (statHdrItem.CONTENT_TYPE === 'results') {
					type = 13;

					//Force results section header into the last column
					columnCount = columnCount + 1;
					compHdrAr.push('<td class=\'drd-pat-col-hdr\' style=\'width:', widthClass, '%\'><span id=\'drd', type, '\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(', columnCount, ',', type, '); return false;\'>', statHdrItem.NAME, '</span></td>');
				}
			}
		}
		else {
			widthClass = 69.5;
			compHdrAr.push('<table class=\'drd-pat-table\'><tr id=\'drdHdrRow\'  class=\'drd-pat-table-hdr\'><td class=\'drd-pat-col-hdr\' style=\'width: ' + nmWidthCls + '%\'><span id=\'patName\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(0,1); return false;\'>', i18n.PATIENT_NAME, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width: ' + losWidthCls + '%\'><span id=\'los\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(1, 2); return false;\'>', i18n.LENGTH_OF_STAY, '<br/>(DD:HH:MM)</span></td><td id=\'eddHdr\' class=\'drd-pat-col-hdr\' style=\'width: ' + dcWidthCls + '%;border-right:#E6E8F1 3px solid;\'><span id=\'edd\' onclick=\'CERN_DISCHARGE_DASHBOARD.sortPatients(2,3); return false;\'>', i18n.ESTIMATED_DISCHARGE_DATE, '</span></td><td class=\'drd-pat-col-hdr\' style=\'width:', widthClass, '%\'><span>', i18n.NO_RESULTS_FOUND, '</span></td></tr></table>');
		}
		compHdrAr.push('</tr></table>');
		compHdrHTML = compHdrAr.join('');
		if (parentHdrDiv) {
			parentHdrDiv.innerHTML = compHdrHTML;
		}
	}

	/**
	 * Function to display discharge status
	 *
	 * @param {String} statName        Status name
	 * @param {number} flg            Status flag
	 * @returns {string} Rerturns the discharge status html
	 */
	function getDischargeStatus(statName, flg) {
		var statusIcon = '<span title=\'' + i18n.NOT_STARTED + '\' class=\'drd-not-started\'>&nbsp;</span>';
		if ('results'.indexOf(statName) >= 0) {
			statusIcon = getResultStatus(flg);
		}
		else {
			statusIcon = getStatus(flg);
		}

		return statusIcon;

	}

	/**
	 * function to retrieve the status
	 *
	 * @param {number} flg        status flag
	 * @returns {string} The html markup for the status flag
	 */
	function getStatus(flg) {
		if (flg === 0 || flg === 3) {
			return '<span title=\'' + i18n.NOT_STARTED + '\' class=\'drd-not-started\'>&nbsp;</span>';
		}
		else if (flg === 2 || flg === 4) {
			return '<span title=\'' + i18n.COMPLETED + '\' class=\'drd-completed\'>&nbsp;</span>';
		}
		else if (flg === 1 || flg === 5) {
			return '<span title=\'' + i18n.IN_PROGRESS + '\' class=\'drd-in-progress\'>&nbsp;</span>';
		}
		else {
			return '<span title=\'' + i18n.NOT_STARTED + '\' class=\'drd-not-started\'>&nbsp;</span>';
		}
	}

	/**
	 * Function to retrieve result status
	 * @param {Object} stat        Status
	 * @returns {string} The html markup for the result status indicator
	 */
	function getResultStatus(stat) {
		if (stat === 0) {//result
			return '<span title=\'' + i18n.COMPLETED + '\' class=\'drd-results-completed\'>&nbsp;</span>';
		}
		else if (stat === 1) { //crit result
			return '<span title=\'' + i18n.CRITICAL + '\' class=\'drd-results-critical\'>&nbsp;</span>';
		}
		else { //no result
			return '--';
		}
	}

	/**
	 * Function to format date
	 * @param {Object} dt    Date
	 * @param {String} mask  mask
	 * @returns {string} A formatted date time string based on the mask provided
	 */
	function formatDate(dt, mask) {
		if (dt) {
			var dateTime = new Date();
			dateTime.setISO8601(dt);
			if (mask) {
				return dateTime.format(mask);
			}
			else {
				return dateTime.format('longDateTime3');
			}
		}
		else {
			return '^^';
		}
	}

	return {
		/*
		 * Entry point for discharge readiness dashboard.
		 */
		RenderDischargeDashboard: function() {
			/*eslint-disable mp-camelcase*/
			MP_Util.LogInfo('In RenderDischargeDashboard()'); //eslint-disable-line new-cap
			var js_criterion = JSON.parse(MPAGE_REPLY_DATA); //eslint-disable-line no-undef
			var replyData = js_criterion.REPLY_DATA;
			criterion = {
				provider_id: replyData.PROVIDER_ID,
				static_content: replyData.FULL_FOLDER_PATH,
				position_cd: replyData.POSITION_CD,
				category_meaning: replyData.CATEGORY_MEAN,
				executable: replyData.APPLICATION_NAME,
				dashboard_title: replyData.DASHBOARD_TITLE,
				dashboard_page_title: replyData.DASHBOARD_PAGE_TITLE,
				patient_list_label: replyData.PATIENT_LIST_LABEL,
				loading_text: replyData.LOADING_TEXT,
				debug_ind: replyData.DEBUG_IND,
				tab_name: replyData.PC_TAB_NAME
			};
			/*eslint-enable mp-camelcase*/
			//The below regexp searches the tab name for the ASCii values and replaces them with the actual special character.
			tabName = criterion.tab_name.replace(/&#(\d+);/g, function(m, n) {
				return String.fromCharCode(n);
			});
			CERN_BrowserDevInd = (parseInt(criterion.debug_ind, 10) & 1) === 1; //eslint-disable-line no-undef, no-native-reassign, mp-camelcase
			var info = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest(); //eslint-disable-line mp-camelcase
			info.onreadystatechange = function() {
				if (this.readyState === 4 && this.status === 200) {
					MP_Util.LogScriptCallInfo(null, info, 'discharge-dashboard.js', 'RenderDischargeDashboard'); //eslint-disable-line new-cap
					var body = document.body;
					var dashboardInitialDisplay = [];
					var jsonEval = JSON.parse(this.responseText);
					var jsonObj = jsonEval.RECORD_DATA;
					var jsStatus = jsonObj.STATUS_DATA.STATUS;
					var patientListItem = null;

					dashboardInitialDisplay.push('<div class=\'pg-hd\'><span class=\'pg-title\'>', criterion.dashboard_page_title, '</span></div><div id=\'drdFilters\'><span class=\'drd-filter-lbl\'>', criterion.patient_list_label, '</span><select id=\'drdPatLists\'><option>', criterion.loading_text, '</option></select></div><div id=\'drdPat\'></div>');

					body.innerHTML += dashboardInitialDisplay.join('');
					var patientList = _g('drdPatLists');

					if (jsStatus === 'Z') {
						var txt = i18n.NO_LISTS_DEFINED;
						patientList.options[0] = new Option(txt, 0);
					}
					else if (jsStatus === 'S') {
						var patientListObj = jsonObj.QUAL;
						var patientListArray = [];
						var patientListLength = patientListObj.length;

						for (var i = 0; i < patientListLength; i++) {
							patientListItem = patientListObj[i];
							var patient = {
								NAME: patientListItem.NAME,
								ID: patientListItem.PATIENT_LIST_ID
							};
							patientListArray.push(patient);
							patientListItem = patientListArray[i];
							patientList.options[i] = new Option(patientListItem.NAME, patientListItem.ID);
						}

						loadPatientList();
						Util.addEvent(patientList, 'change', loadPatientList);
					}
					else {
						patientList.options[0] = new Option(i18n.ERROR_RETREIVING_DATA, 0);
					}

				}
				if (this.readyState === 4) {
					MP_Util.ReleaseRequestReference(this); //eslint-disable-line new-cap
				}
			};
			/*
			 * Retrieving the patient list.
			 */
			var params = '"mine",' + criterion.provider_id + '.0';
			if (CERN_BrowserDevInd) { //eslint-disable-line mp-camelcase
				var url = 'mp_drd_patient_list?parameters=' + params;
				info.open('GET', url, true);
				info.send(null);
			}
			else {
				info.open('GET', 'mp_drd_patient_list', true);
				info.send(params);
			}
		},
		/**
		 * Sort function.
		 * @param {integer} colNum  The column number
		 * @param {integer} typ     The sort type
		 * @returns {undefined} This function does not return a value
		 */
		sortPatients: function(colNum, typ) {
			var sortOrd = 0;

			//Name
			function sortByName(a, b) {
				var sortRes = 0;
				if (a.NAME.toUpperCase() < b.NAME.toUpperCase()) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}

			// Length of stay sort
			function sortByLos(a, b) {
				var sortRes = 0;
				if (a.LOS_SEQ < b.LOS_SEQ) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}

				return sortRes;
			}

			//Discharge Date
			function sortByDiscDt(a, b) {
				var sortRes = 0;
				if (a.DISCHARGE_DATE < b.DISCHARGE_DATE) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}

			//'orders':
			function sortByOrderStatus(a, b) {
				var sortRes = 0;
				if (a.ORD_STATUS_FLAG < b.ORD_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'diagnosis':
			function sortByDxStatus(a, b) {
				var sortRes = 0;
				if (a.DX_STATUS_FLAG < b.DX_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'pat-ed':
			function sortByPatEdStatus(a, b) {
				var sortRes = 0;
				if (a.PED_STATUS_FLAG < b.PED_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'follow-up':
			function sortByFuStatus(a, b) {
				var sortRes = 0;
				if (a.FU_STATUS_FLAG < b.FU_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'med-rec':
			function sortByMedStatus(a, b) {
				var sortRes = 0;
				if (a.MED_STATUS_FLAG <= b.MED_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'documents':
			function sortByDocStatus(a, b) {
				var sortRes = 0;
				if (a.DOC_STATUS_FLAG < b.DOC_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'activities':
			function sortByActivitiesStatus(a, b) {
				var sortRes = 0;
				if (a.ACT_STATUS_FLAG < b.ACT_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'social':
			function sortBySocialStatus(a, b) {
				var sortRes = 0;
				if (a.SOC_STATUS_FLAG < b.SOC_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'care-mgmt':
			function sortByCareMgmtStatus(a, b) {
				var sortRes = 0;
				if (a.CM_STATUS_FLAG < b.CM_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'results':
			function sortByResults(a, b) {
				var sortRes = 0;
				if (a.RES_STATUS_FLAG < b.RES_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}
			//'quality-meas':
			function sortByQM(a, b) {
				var sortRes = 0;
				if (a.QM_STATUS_FLAG <= b.QM_STATUS_FLAG) {
					sortRes = 1;
				}
				else {
					sortRes = -1;
				}
				if (sortOrd === 1) {
					sortRes = sortRes * -1;
				}
				return sortRes;
			}




			if (typ !== 0) {
				var spnPar = _g('drdHdrRow');
				var tdAr = Util.Style.g('drd-pat-col-hdr', spnPar, 'TD');
				for (var t = 0; t < tdAr.length; t++) {
					var td = tdAr[t];
					if (t === colNum) {
						if (!Util.Style.ccss(td, 'uline')) {
							Util.Style.acss(td, 'uline');
						}
					}
					else if (Util.Style.ccss(td, 'uline')) {
							Util.Style.rcss(td, 'uline');
					}
				}
			}
			if (typ === sortType) {
				sortOrd = (sortOrder + 1) % 2;
				sortOrder = sortOrd;
			}
			else if (typ === 0) {
				sortOrd = 1;
				sortOrder = 1;
			}
			sortOrder = sortOrd;
			sortType = typ;
			switch (typ) {
				case 1:
					activeList.sort(sortByName);
					break;
				case 2:
					activeList.sort(sortByLos);
					break;
				case 3:
					activeList.sort(sortByDiscDt);
					break;
				case 4:
					activeList.sort(sortByOrderStatus);
					break;
				case 5:
					activeList.sort(sortByDxStatus);
					break;
				case 6:
					activeList.sort(sortByPatEdStatus);
					break;
				case 7:
					activeList.sort(sortByFuStatus);
					break;
				case 8:
					activeList.sort(sortByMedStatus);
					break;
				case 9:
					activeList.sort(sortByDocStatus);
					break;
				case 10:
					activeList.sort(sortByActivitiesStatus);
					break;
				case 11:
					activeList.sort(sortBySocialStatus);
					break;
				case 12:
					activeList.sort(sortByCareMgmtStatus);
					break;
				case 13:
					activeList.sort(sortByResults);
					break;
				case 14:
					activeList.sort(sortByQM);
					break;
			}
			var jsActivePats = [];
			var activePats = '';
			var patContent = _g('patContent');
			var activeLen = activeList.length;

			jsActivePats.push('<div id=\'drdPatTable1\' class=\'drd-pat-table1-content\'>');

			//Load all the rest
			for (var a = 0; a < activeLen; a++) {
				jsActivePats.push('<div id=\'drdDataTable', activeList[a].ENCNTR_ID, '\' class=\'test\'>');
				jsActivePats.push(activeList[a].HTML);
				jsActivePats.push('</div>');
			}

			jsActivePats.push('</div></div>');
			activePats = jsActivePats.join('');

			if (patContent) {
				patContent.innerHTML = activePats;
				resizePatientList()
				CERN_DISCHARGE_DASHBOARD.secInit('drd-pat');
				CERN_DISCHARGE_DASHBOARD.highlightEvenRows();

			}
			else {
				var patSec = _g('drdPat');
				patSec.innerHTML = i18n.NO_PATIENTS;
			}

		},
		/**
		 * Function to add zebra stripe
		 * @returns {undefined} This function does not return a value
		 */
		highlightEvenRows: function() {
			var tRAr = Util.Style.g('test', document, 'DIV');
			var indexCnt = 0;
			for (var t = 0; t < tRAr.length; t++) {
				var tr = tRAr[t];
				if (!Util.Style.ccss(tr, 'hide')) {
					if (indexCnt % 2) {
						Util.Style.rcss(tr, 'test');
						Util.Style.acss(tr, 'even');
					}
					else {
						Util.Style.rcss(tr, 'test');
						Util.Style.acss(tr, 'odd');
					}
					indexCnt = indexCnt + 1;
				}
			}
		},
		secInit: function(pre) {
			var gen = Util.Style.g(pre + '-info');
			for (var i = 0, l = gen.length; i < l; i++) {
				var m = gen[i];
				if (m) {
					var nm = Util.gns(Util.gns(m));
					if (nm) {
						if (Util.Style.ccss(nm, 'hvr')) {
							hs(m, nm);
						}
					}
				}
			}
		}
	};

}();
/*eslint-enable no-mixed-spaces-and-tabs*/
/* Hover Mouse Over */
/* Hover Mouse Over */
function hmo(evt, n, comp){
    evt = evt || window.event;
    var s = n.style, p = getPosition(evt), vp = gvs(), so = gso(), left = p.x + 20, top = p.y + 20;
    n._ps = n.previousSibling;
    n.hmo = true;
    
    //Helper function to check if the hover's previous sibling (the one that initiates the hover) has been removed from the DOM.
    function checkHoverSourceExists() {
    	try {
	    	//If we're not hovering over the element anymore, then stop checking
	    	if(!n.hmo) {
	    		return;
	    	}
	    	//If the hover's anchor no longer exists, remove the hover and return
	    	if(!$(comp.getSectionContentNode()).find($(n._ps)).length) {
	    		$(n).remove();
	    		return;
	    	}
	    	//If we've made it this far, the hover anchor still exists and we are still hovering, so continue polling.
	    	setTimeout(checkHoverSourceExists, 1000);
    	} catch(exe) {
    		return;
    	}
    }
    
    function hover(){
        if (n.hmo === true) { //make sure the cursor has not moused out prior to displaying
        	//Make call to begin checking that the hover's parent has not been removed from the DOM
        	checkHoverSourceExists();
			if (comp) {
				if (comp.isEditMode()) {
					 clearTimeout(n.timer);
					return;
				}
			}
			
			s.display = "block";	
		    if(left + n.offsetWidth > vp[1] + so[1]) {
				left = left - 40 - n.offsetWidth;
				if(left < 0) {
					left = 0;
				}
			}

			if(top + n.offsetHeight > vp[0] + so[0]) {
				if(top - 40 - n.offsetHeight < so[0]) {
					if(left > 0) {
						top = 10 + so[0];
					}
				} else {
					top = top - 40 - n.offsetHeight;
				}
			}
			document.body.appendChild(n);	
            s.left = left + "px";
            s.top = top + "px";
            n.show = true;
        }
    }
    n.timer = setTimeout(hover, 500);
}
/* Hover Mouse Move */
function hmm(evt, n, comp){
	
    if (!n.show) {
        return;
    }
    
    if (comp) {
		if (comp.isEditMode()) {
			clearTimeout(n.timer);
			return;
		}
	}
    var s = n.style, p = getPosition(evt), vp = gvs(), so = gso(), left = p.x + 20, top = p.y + 20;
    
    if (left + n.offsetWidth > vp[1] + so[1]) {
        left = left - 40 - n.offsetWidth;
        if (left < 0) {
            left = 0;
        }
    }
    
    if (top + n.offsetHeight > vp[0] + so[0]) {
        if (top - 40 - n.offsetHeight < so[0]) {
            if (left > 0) {
                top = 10 + so[0];
            }
        }
        else {
            top = top - 40 - n.offsetHeight;
        }
    }
    evt = evt || window.event;
    s.top = top + "px";
    s.left = left + "px";
}

/* Hover Mouse Out*/
function hmt(evt, n, comp){
	if (comp) {
		if (comp.isEditMode()) {
			clearTimeout(n.timer);
			return;
		}
	}
    n.hmo = false;
    if (!n._ps) 
        n._ps = n.previousSibling;
    clearTimeout(n.timer);
    evt = evt || window.event;
    n.style.display = "";
    Util.ia(n, n._ps);
    n.show = false;
}

/* Hover Setup */
function hs(e, n, comp){
    var priorBgColor = e.style.backgroundColor;
    var priorBorderColor = e.style.borderColor;
	var editMode;
	if (n && n.tagName == "DIV") {
        e.onmouseenter = function(evt){
		if (comp) {
			 if (comp.isEditMode()) {
				return;
			}
		}	
			e.onmouseover = null;
			e.onmouseout = null;
			hmo(evt, n, comp);
        };
        e.onmouseover = function(evt){
		if (comp) {
			 if (comp.isEditMode()|| Util.Style.ccss(this, "row-selected")) {
				return;
			}
		}
			e.style.backgroundColor = "#FFFFCC";
            e.style.borderColor = "#CCCCCC";
            hmo(evt, n, comp);
        };
        e.onmousemove = function(evt){
		if (comp) {
			 if (comp.isEditMode()|| Util.Style.ccss(this, "row-selected")) {
				return;
			}
		}
			e.style.backgroundColor = "#FFFFCC";
            e.style.borderColor = "#CCCCCC";
            hmm(evt, n, comp);
        };
        e.onmouseout = function(evt){
            e.style.backgroundColor = priorBgColor;
            e.style.borderColor = priorBorderColor;
            hmt(evt, n, comp);
        };
        e.onmouseleave = function(evt){
            e.style.backgroundColor = priorBgColor;
            e.style.borderColor = priorBorderColor;
            e.onmouseover = null;
            e.onmouseout = null;
            hmt(evt, n, comp);
        };
        e.onmouseup = function(evt){
            if (comp) {
                if (!comp.isEditMode()) {
                    return;
                }
                
                e.style.backgroundColor = priorBgColor;
                e.style.borderColor = priorBorderColor;
                hmt(evt, n, comp);
            }
        };
        Util.Style.acss(n, "hover");
    }
}

////// Healthe library 
 /*extern window, document*/
 /**
  * @fileOverview
 
     <h1>Utility Methods</h1>
     <p>
     These are universal utility methods, designed for speed, size and agnostic browser support. There are several namespaces:
     </p>
     <dl>
         <dt>Util</dt>
         <dd>General Utility methods</dd>
         <dd>Included in util.core.js</dd>
         <dt>Util.EventCache</dt>
         <dd>Object for ensuring proper garbage collection.</dd>
         <dd>Included in util.core.js</dd>
         <dt>Util.Convert</dt>
         <dd>Conversion Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.convert.js is not included.</dd>
         <dt>Util.Cookie</dt>
         <dd>Cookie Management Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.cookie.js is not included.</dd>
         <dt>Util.Detect</dt>
         <dd>Detection Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.detect.js is not included.</dd>
         <dt>Util.i18n</dt>
         <dd>Internationalization (i18n) Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.i18n.js is not included.</dd>
         <dt>Util.Load</dt>
         <dd>DOM-Loaded event Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.load.js is not included.</dd>
         <dt>Util.Pos</dt>
         <dd>Positioning Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.pos.js is not included.</dd>
         <dt>Util.Style</dt>
         <dd>CSS Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.style.js is not included.</dd>
         <dt>Util.Timeout</dt>
         <dd>Session Management methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.timeout.js is not included.</dd>
     </dl>
     <h2>Notes</h2>
     <p>All modules are aggregated together by Maven into a single file, util.js.</p>
     <p>Validated with JSLint.</p>
  */
 
 /**
  * Returns an element based on the id provided, <code>null</code> if no element exists.
  * @param {String} i The id.
  * @return {Node} An element with the id specified, <code>null</code> if no such element exists.
  * @static
  * @global
  * @fullname Get Element By ID
  */
 function _g(i) {
     return document.getElementById(i);
 }
 
 /**
  * Returns all elements from within the specified context matching the tag name provided, <code>null</code> if no
  * elements exist.
  * @param {String} t The tag name.
  * @param {Node} [e] The element to search within. Defaults to the document body.
  * @return {array} An array of elements with the tag name specified, <code>null</code> if no elements exist.
  * @static
  * @global
  * @fullname Get Elements By Tag Name
  */
 function _gbt(t, e) {
     e = e || document;
     return e.getElementsByTagName(t);
 }
 
 /**
  * Utility methods
  * @namespace Util
  * @static
  * @global
  */
 var Util = function () {
 
     var _e = [], _d = document, _w = window;
 
     return {
         /**
          * The Event Cache makes it possible to ensure all events attached to the DOM or browser instances are
          * properly "flushed away" after the page is unloaded. This prevents memory leaks in some implementations.
          *
          * @property
          * @memberof Util
          * @name EventCache
          */
         EventCache : function () {
             var l = [];
             return {
 
                 /**
                  * Add an event to the Event Cache.
                  * @param {Node} o The element or object to which the event is attached.
                  * @param {String} e The event name, e.g. "click" or "mouseover".
                  * @param {Function} f The function attached.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name add
                  */
                 add : function (o, e, f) {
                     l.push(arguments);
                 },
 
                 /**
                  * Remove an event from the Event Cache.
                  * @param {Node} o The element or object to which the event is attached.
                  * @param {String} e The event name, e.g. "click" or "mouseover".
                  * @param {Function} f The function to detach.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name remove
                  */
                 remove : function (o, e, f) {
                     var n;
                     for (var i = l.length - 1; i >= 0; i = i - 1) {
                         if (o == l[i][0] && e == l[i][1] && f == l[i][2]) {
                             n = l[i];
                             if (n[0].removeEventListener) {
                                 n[0].removeEventListener(n[1], n[2], n[3]);
                             }
                             else if (n[0].detachEvent) {
                                 if (n[1].substring(0, 2) != "on") {
                                     n[1] = "on" + n[1];
                                 }
                                 n[0].detachEvent(n[1], n[0][e + f]);
                             }
                         }
                     }
                 },
 
                 /**
                  * Remove all events from the Cache.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name flush
                  */
                 flush : function () {
                     var e;
                     for (var i = l.length - 1; i >= 0; i = i - 1) {
                         var o = l[i];
                         if (o[0].removeEventListener) {
                             o[0].removeEventListener(o[1], o[2], o[3]);
                         }
                         e = o[1];
                         if (o[1].substring(0, 2) != "on") {
                             o[1] = "on" + o[1];
                         }
                         if (o[0].detachEvent) {
                             o[0].detachEvent(o[1], o[2]);
                             if (o[0][e + o[2]]) {
                                 o[0].detachEvent(o[1], o[0][e + o[2]]);
                             }
                         }
                     }
                 }
             };
         }(),
 
         /**
          * Creates an element within the document, without a parent, as if by <code>document.createElement</code>. This method
          * has better performance, as it caches instances of created objects and clones them, rather than manipulate the
          * document directly.
          * @param {String} t The tag name of the element to create.
          * @return {Node} A new element.
          *
          * @static
          * @function
          * @memberof Util
          * @name ce
          * @fullname Create Element
          */
         ce : function (t) {
             var a = _e[t];
             if (!a) {
                 a = _e[t] = _d.createElement(t);
             }
             if (!a) {
                 return null;
             }
             else {
                 return a.cloneNode(false);
             }
         },
 
         /**
          * Creates an element within the document, without a parent, as if by <code>document.createElement</code>. Any
          * given properites will then be set onto the newly created element. This method has better performance, as it
          * caches instances of created objects and clones them, rather than manipulate the document directly.
          * @param {String} t The tag name of the element to create.
          * @param {Object} [p] The properties to set onto the created element, (e.g. <code>{ "href" : "index.html", "name" : "theName"}</code>).
          * @return {Node} A new element.
          * 
          * @static
          * @function
          * @memberof Util
          * @name cep
          * @fullname Create Element with Properties
          */
         cep : function (t, p) {
             var e = this.ce(t);
             return this.mo(e, p);
         },
 
         /**
          * Merges two option objects.
          * @param {Object} o1 The option object to be modified.
          * @param {Object} o2 The option object containing properties to be copied.
          * @param {Boolean} d True if properties on o1 should be immutable, false otherwise.
          * @return {Object} An object containing properties.
          *
          * @static
          * @function
          * @memberof Util
          * @name mo
          * @fullname Merge Objects
          */
         mo : function (o1, o2, d) {
             o1 = o1 || {};
             o2 = o2 || {};
             var p;
             for (p in o2) {
                 if (p) {
                     o1[p] = (o1[p] === undefined) ? o2[p] : !d ? o2[p] : o1[p];
                 }
             }
             return o1;
         },
 
         /**
          * Deletes an element from the DOM.
          * @param {Node} e The element to delete.
          *
          * @static
          * @function
          * @memberof Util
          * @name de
          * @fullname Delete Element
          */
         de : function (e) {
             if (e) {
                 this.gp(e).removeChild(e);
             }
         },
 
         /**
          * Universal event-bubbling cancel method.
          * @param {event} e The event object, (not required in IE).
          *
          * @static
          * @function
          * @memberof Util
          * @name cancelBubble
          * @fullname Cancel Event Bubble
          */
         cancelBubble : function (e) {
             e = _w.event || e;
             if (!e) {
                 return;
             }
 
             if (e.stopPropagation) {
                 e.stopPropagation();
             }
             else {
                 e.cancelBubble = true;
             }
         },
 
         /**
          * Universal event default behavior prevention method.
          * @param {event} e The event object, (not required in IE).
          *
          * @static
          * @function
          * @memberof Util
          * @name preventDefault
          * @fullname Prevent Default Behavior
          */
         preventDefault : function (e) {
             e = _w.event || e;
 
             if (!e) {
                 return;
             }
 
             if (e.preventDefault) {
                 e.preventDefault();
             }
             else {
                 e.returnValue = false;
             }
         },
 
         /**
          * Returns the an element's offset values, traversing the tree for an accurate value.
          * @param {Node} e The element to evaluate.
          * @return {array} The offset left and offset top, in pixels, in the form of [left, top].
          *
          * @static
          * @function
          * @memberof Util
          * @name goff
          * @fullname Get Element Offset Values
          */
         goff : function (e) {
             var l = 0, t = 0;
             if (e.offsetParent) {
                 while (e.offsetParent) {
                     l += e.offsetLeft;
                     t += e.offsetTop;
                     e = e.offsetParent;
                 }
             }
             else if (e.x || e.y) {
                 l += e.x || 0;
                 t += e.y || 0;
             }
             return [l, t];
         },
 
         /**
          * Returns an accurate parent node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual parent node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gp
          * @fullname Get Parent
          */
         gp : function (e) {
             if (!e.parentNode) {
                 return e;
             }
             e = e.parentNode;
             while (e.nodeType === 3 && e.parentNode) {
                 e = e.parentNode;
             }
             return e;
         },
		 
 
         /**
          * Some browsers will return a Text Node, so this method returns an accurate child node.
          * @param {Node} e The element to evaluate.
          * @param {int} [i] The child node index, default is 0.
          * @return {Node} The actual child node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gc
          * @fullname Get Child Node
          */
         gc : function (e, i) {
             i = i || 0;
             var j = -1;
 
             if (!e.childNodes[i]) {
                 return null;
             }
 
             e = e.childNodes[0];
             while (e && j < i) {
                 if (e.nodeType === 1) {
                     j++;
                     if (j === i) {
                         break;
                     }
                 }
                 e = this.gns(e);
             }
             return e;
         },
 
         /**
          * For a given node, returns a list of children of NODETYPE 1, (Element).
          * @param {Node} e The node to evaluate.
          * @return {array} A collection of child nodes.
          *
          * @static
          * @function
          * @memberof Util
          * @name gcs
          * @fullname Get All Child Nodes
          */
         gcs : function (e) {
 
             var r = [], es = e.childNodes;
             for (var i = 0; i < es.length; i++) {
                 var x = es[i];
                 if (x.nodeType === 1) {
                     r.push(x);
                 }
             }
             return r;
         },
 
         /**
          * Returns an accurate next sibling node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual next sibling node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gns
          * @fullname Get Next True Sibling
          */
         gns : function (e) {
			if (!e) {
				return null;
			}
             var a = e.nextSibling;
             while (a && a.nodeType !== 1) {
                 a = a.nextSibling;
             }
             return a;
         },
 
         /**
          * Returns an accurate previous sibling node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual previous sibling node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gps
          * @fullname Get Previous True Sibling
          */
         gps : function (e) {
             var a = e.previousSibling;
             while (a && a.nodeType !== 1) {
                 a = a.previousSibling;
             }
             return a;
         },
 
         /**
          * Appends a child to the specified node.
          * @param {Node} e The element to append.
          * @param {Node} p The new parent node.
          * @return {Node} The appended element.
          *
          * @static
          * @function
          * @memberof Util
          * @name ac
          * @fullname Append Child
          */
         ac : function (e, p) {
             p.appendChild(e);
             return e;
         },
 
         /**
          * Insert a node after a specified node.
          * @param {Node} nn The new node to insert.
          * @param {Node} rn The reference node for insertion.
          *
          * @static
          * @function
          * @memberof Util
          * @name ia
          * @fullname Insert After
          */
         ia : function (nn, rn) {
             var p = Util.gp(rn), n = Util.gns(rn);
             if (n) {
                 p.insertBefore(nn, n);
             }
             else {
                 Util.ac(nn, p);
             }
         },
 
         /**
          * Adds a Javscript event to the given element with full browser compatiblity and plugs for any memory leaks.
          * @param {Node} o The object receiving the event.
          * @param {String} e The event name to attach.
          * @param {Function} f The function to run when the event is invoked.
          *
          * @static
          * @function
          * @memberof Util
          * @name addEvent
          * @fullname Add Javascript Event
          */
         addEvent : function (o, e, f) {
 
             function ae(obj, evt, fnc) {
                 if (!obj.myEvents) {
                     obj.myEvents = {};
                 }
 
                 if (!obj.myEvents[evt]) {
                     obj.myEvents[evt] = [];
                 }
 
                 var evts = obj.myEvents[evt];
                 evts[evts.length] = fnc;
             }
 
             function fe(obj, evt) {
 
                 if (!obj || !obj.myEvents || !obj.myEvents[evt]) {
                     return;
                 }
 
                 var evts = obj.myEvents[evt];
 
                 for (var i = 0, len = evts.length; i < len; i++) {
                     evts[i]();
                 }
             }
 
             if (o.addEventListener) {
                 o.addEventListener(e, f, false);
                 Util.EventCache.add(o, e, f);
             }
             else if (o.attachEvent) {
                 o["e" + e + f] = f;
                 o[e + f] = function () {
                     o["e" + e + f](window.event);
                 };
                 o.attachEvent("on" + e, o[e + f]);
                 Util.EventCache.add(o, e, f);
             }
             else {
                 ae(o, e, f);
                 o['on' + e] = function () {
                     fe(o, e);
                 };
             }
         },
 
         /**
          * Remove a Javscript event from the given element with full browser compatiblity and plugs for any memory leaks.
          * @param {Node} o The object honoring the event.
          * @param {String} e The event name.
          * @param {Function} f The function to remove.
          *
          * @static
          * @function
          * @memberof Util
          * @name removeEvent
          * @fullname Remove Javascript Event
          */
         removeEvent : function (o, e, f) {
             Util.EventCache.remove(o, e, f);
         },
 
         /**
         * Uses the native browser window object to create a new window.
         * <p>
         * <strong>NOTE:</strong> This method will utilize DOM methodology only <em>truly</em> supported by desktop
         * browsers. While some mobile browsers may allow this call, most will not. Use with caution, in specific use
         * cases.
         * </p>
         *
         * @param {String} u The url of the popup to open.
         * @param {String} n The name of the popup window.
         * @param {Object} [o The object params. If an object is not provided, the browser defaults will be used.
         * @param {String} [o.lb]  Include location bar, (default is true).
         * @param {String} [o.mb] Include menu bar, (default is true).
         * @param {String} [o.rz] Allow resize, (default is true).
         * @param {String} [o.scb] Include scrollbars, (default is true).
         * @param {String} [o.stb] Include status bar, (default is true).
         * @param {String} [o.tb] Include toolbar, (default is true).
         * @param {int} [o.w] The value for the width of the popup window.
         * @param {int} [o.h] The value for the height of the popup window.
         * @param {int} [o.tp] The value for top. (NOT SUPPORTED YET)
         * @param {int} [o.lft] The value for the left position of the popup. (NOT SUPPORTED YET)
         * @param {int} [o.sx] The screen x value. (NOT SUPPORTED YET)
         * @param {int} [o.sy] The screen y value. (NOT SUPPORTED YET)
         * @param {String} [o.dp] The value for the dependent popup property (yes or no). (NOT SUPPORTED YET)
         * @param {String} [o.dr] The value for the directories property (yes or no). (NOT SUPPORTED YET)
         * @param {String} [o.fs] The value for the fullscreen property (yes or no). (NOT SUPPORTED YET)
         * @return <code>True</code> if the window popup was successful, <code>false</code> otherwise or if the client
         * does not support popup windows.
         *
         * @static
         * @function
         * @memberof Util
         * @name popup
         * @fullname Popup New Window
         */
         popup : function (u, n, o) {
             if (!window.open) {
                 return false;
             }
 
             var d = {
                 w : screen.width,
                 h : screen.height,
                 rz : true,
                 mb : true,
                 scb : true,
                 stb : true,
                 tb : true,
                 lb : true,
                 tp : null,
                 lft : null,
                 sx : null,
                 sy : null,
                 dp : "no",
                 dr : "no",
                 fs : "no"
             };
 
             function f(n, v)
             {
                 if (!v) {
                     return "";
                 }
                 return n + '=' + v + ',';
             }
 
             function fs() {
                 o = o || {};
                 var p, n = {};
                 for (p in d) {
                     if (p) {
                         n[p] = o[p] !== undefined ? o[p] : d[p];
                     }
                 }
                 return n;
             }
 
             o = fs();
             var p = f("dependent", o.dp) + f("directories", o.dr) + f("fullscreen", o.fs) + f("location", o.lb ? 1 : 0) + f("menubar", o.mb) + f("resizable", o.rz ? 1 : 0) + f("scrollbars", o.scb ? 1 : 0) + f("status", o.stb ? 1 : 0) + f("toolbar", o.tb ? 1 : 0) + f("top", o.tp) + f("left", o.lft) + f("width", o.w) + f("height", o.h) + f("screenX", o.sx) + f("screenY", o.sy);
             p = p.substring(0, p.length - 1);
             var nw = window.open(u, n, p);
             window.blur();
 
             if (nw.focus) {
                 nw.focus();
             }
 
             return true;
         },
         Convert : {},
         Cookie : {},
         Detect : {},
         i18n : {},
         Load : {},
         Pos : {},
         Style : {},
         Timeout : {}
     };
 }();
 
 /**
  * Insert a node after a specified node.
  * @param {Node} nn The new node to insert.
  * @param {Node} rn The reference node for insertion.
  *
  * @deprecated
  * @static
  * @global
  */
 function insertAfter(nn, rn) {
     Util.ia(nn, rn);
 }

 Util.addEvent(window, 'unload', Util.EventCache.flush);

 /*extern _gbt, Util*/

 /**
 * @fileOverview
 *
 * <h1>CSS Utility module and namespace</h1>
 * <p>This module assists with managing CSS selectors and classnames.</p>
 * <h2>Usage</h2>
 * <p>Import this file <em>after</em> util.core.js.</p>
 */

 /**
 * Style Utility methods.
 * @namespace Util.Style
 * @global
 * @static
 */
 Util.Style = function() {

     return {
         /**
         * Indicates if an element has been applied with a single given CSS Classname.
         * @param {Node} e The element to evaluate.
         * @param {String} c The single CSS Classname to check.
         * @return {Boolean} True if the classname contains the given class, false otherwise.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name ccss
         * @fullname Contains CSS Class
         */
         ccss: function(e, c) {
             if (typeof (e.className) === 'undefined' || !e.className) {
                 return false;
             }
             var a = e.className.split(' ');
             for (var i = 0, b = a.length; i < b; i++) {
                 if (a[i] === c) {
                     return true;
                 }
             }
             return false;
         },

         /**
         * Adds a given CSS Classname to the given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to apply.
         * @return {Node} The element with the CSS Classname applied.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name acss
         * @fullname Add CSS Class
         */
         acss: function(e, c) {
             if (this.ccss(e, c)) {
                 return e;
             }
             e.className = (e.className ? e.className + ' ' : '') + c;
             return e;
         },

         /**
         * Removes a given CSS Classname from the given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to remove.
         * @return {Node} The element, with the CSS Classname removed.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name rcss
         * @fullname Remove CSS Class
         */
         rcss: function(e, c) {
             if (!this.ccss(e, c)) {
                 return e;
             }
             var a = e.className.split(' '), d = "";
             for (var i = 0, b = a.length; i < b; i++) {
                 var f = a[i];
                 if (f !== c) {
                     d += d.length > 0 ? (" " + f) : f;
                 }
             }
             e.className = d;
             return e;
         },

         /**
         * Toggles a given CSS Classname on a given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to toggle.
         * @return {Boolean} True if the element now contains the classname, false if it was removed.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name tcss
         * @fullname Toggle CSS Class
         */
         tcss: function(e, c) {
             if (this.ccss(e, c)) {
                 this.rcss(e, c);
                 return false;
             }
             else {
                 this.acss(e, c);
                 return true;
             }
         },

         /**
         * Clears any opacity setting back to whatever is defined in CSS.
         * @param {Node} e The element whose opacity setting should be reset.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name co
         * @fullname Clear Opacity
         */
         co: function(e) {
             e.style.MozOpacity = "";
             e.style.opacity = "";
             e.style.filter = "";
         },

         /**
         * Returns an array of elements with the designated classname.
         * @param {String} c The CSS classname.
         * @param {Node} [e] The parent element to search within, defaults to document.
         * @param {String} [t] The tagname to scope the results, defaults to all tags.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name g
         * @fullname Get Elements by Classname
         */
         g: function(c, e, t) {
             e = e || document;
             t = t || '*';
             var ns = [], es = _gbt(t, e), l = es.length;
             for (var i = 0, j = 0; i < l; i++) {
                 if (this.ccss(es[i], c)) {
                     ns[j] = es[i];
                     j++;
                 }
             }
             return ns;
         }
     };
 } ();
 
 Util.Pos = function () {

    return {
        /**
         * Returns the actual scrolled offset within the window.
         * @return {array} A Javascript array containing the distance scrolled within the window as [top distance, left distance].
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gso
         * @fullname Get Scrolled Offset
         */
        gso : function () {
            var d = document, b = d.body, w = window, e = d.documentElement, et = e.scrollTop, bt = b.scrollTop, el = e.scrollLeft, bl = b.scrollLeft;
            if (typeof w.pageYOffset === "number") {
                return [w.pageYOffset, w.pageXOffset];
            }
            if (typeof et === "number") {
                if (bt > et || bl > el) {
                    return [bt, bl];
                }
                return [et, el];
            }
            return [bt, bl];
        },

        /**
         * Returns an array of offset parameters for a given element.
         * @param {Node} e The element to evaluate. If null, undefined or invalid, zeroed offsets are returned.
         * @return {array} A Javascript array of the given element's offsets, relative to any scrolled distance within the window,
         * indexed as [top, left, height, width].  The array will be zeroed out if the element provided is invalid.
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name goo
         * @fullname Get Object Offsets
         */
        goo : function (e) {
            if (e) {
                return [e.offsetTop, e.offsetLeft, e.offsetHeight, e.offsetWidth];
            }
            return [0, 0, 0, 0];
        },

        /**
         * Returns the true position of a given object by parsing the offset tree.
         * @param {Node} e The DOM element.
         * @return {array} A Javascript array containing the "true" top and left of the given element indexed as [top, left].  The
         * array will be zeroed out if the element provided is invalid.
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gop
         * @fullname Get Object Position
         */
        gop : function (e) {
            var l = 0, t = 0;
            if (e.offsetParent)
            {
                l = e.offsetLeft;
                t = e.offsetTop;
                e = e.offsetParent;
                while (e)
                {
                    l += e.offsetLeft;
                    t += e.offsetTop;
                    e = e.offsetParent;
                }
            }
            return [t, l];
        },

        /**
         * Returns an array of size characteristics for the viewport.
         * @return {array} The size of the viewport as a Javascript array, indexed as [height, width].
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gvs
         * @fullname Get Viewport Size
         */
        gvs : function () {
            var n = window, d = document, b = d.body, e = d.documentElement;
             // the more standards compliant browsers (mozilla/netscape/opera/IE7) use window.innerWidth and window.innerHeight
            if (typeof n.innerWidth !== 'undefined') {
                return [n.innerHeight, n.innerWidth];
            }
            // IE6 in standards compliant mode (i.e. with a valid doctype as the first line in the document)
            else if (typeof e !== 'undefined' && typeof e.clientWidth !== 'undefined' && e.clientWidth !== 0) {
                return [e.clientHeight, e.clientWidth];
            }
            // older versions of IE
            else {
                return [b.clientHeight, b.clientWidth];
            }
        }
    };
}();

//////end healthe library

// The following functions were copied from Util.Core, a module within the Healthe Widget Library
// http://prototyping.healthe.cerner.corp/repo/release/site/com.cerner.healthe.navigator/healthe-widget-library/1.2/jsdoc/

function getPosition(e) {
    e = e || window.event;
    var cursor = { x: 0, y: 0 };
    if (e.pageX || e.pageY) {
        cursor.x = e.pageX;
        cursor.y = e.pageY;
    }
    else {
        var de = document.documentElement;
        var b = document.body;
        cursor.x = e.clientX +
                               (de.scrollLeft || b.scrollLeft) - (de.clientLeft || 0);
        cursor.y = e.clientY +
                               (de.scrollTop || b.scrollTop) - (de.clientTop || 0);
    }
    return cursor;
}

// The following functions were copied from Util.Style, a module within the Healthe Widget Library
// http://prototyping.healthe.cerner.corp/repo/release/site/com.cerner.healthe.navigator/healthe-widget-library/1.2/jsdoc/

function gvs() {
    var n = window, d = document, b = d.body, e = d.documentElement;
    // the more standards compliant browsers (mozilla/netscape/opera/IE7) use window.innerWidth and window.innerHeight
    if (typeof n.innerWidth !== 'undefined') {
        return [n.innerHeight, n.innerWidth];
    }
    // IE6 in standards compliant mode (i.e. with a valid doctype as the first line in the document)
    else if (typeof e !== 'undefined' && typeof e.clientWidth !== 'undefined' && e.clientWidth !== 0) {
        return [e.clientHeight, e.clientWidth];
    }
    // older versions of IE
    else {
        return [b.clientHeight, b.clientWidth];
    }
}

function gso() {
    var d = document, b = d.body, w = window, e = d.documentElement, et = e.scrollTop, bt = b.scrollTop, el = e.scrollLeft, bl = b.scrollLeft;
    if (typeof w.pageYOffset === "number") {
        return [w.pageYOffset, w.pageXOffset];
    }
    if (typeof et === "number") {
        if (bt > et || bl > el) {
            return [bt, bl];
        }
        return [et, el];
    }
    return [bt, bl];
}
/**
 * Project: mp_component_defs
 * Version 1.0.0
 * Released 7/6/2010
 * @author Greg Howdeshell
 */

Function.prototype.method = function(name, func) {
	this.prototype[name] = func;
	return this;
};

Function.method("inherits", function(Parent) {
	var d = {},
		p = (this.prototype = new Parent());
	this.method("uber", function uber(name) {
		if (!(name in d)) {
			d[name] = 0;
		}
		var f, r, t = d[name],
			v = Parent.prototype;
		if (t) {
			while (t) {
				v = v.constructor.prototype;
				t -= 1;
			}
			f = v[name];
		}
		else {
			f = p[name];
			if (f == this[name]) {
				f = v[name];
			}
		}
		d[name] += 1;
		r = f.apply(this, Array.prototype.slice.apply(arguments, [1]));
		d[name] -= 1;
		return r;
	});
	return this;
});

/**
 * Creates getters and setters for the class based on attributeName.
 *
 * Example:
 *
 * MyClass.createAttribute("Color", "blue");
 *
 * The call above will create this.getColor() and this.setColor(value).
 * A member variable mColor will also be created, with the default value of
 * "blue".
 *
 */
Function.prototype.createAttribute = function(attributeName, defaultValue) {
	this.prototype["m_" + attributeName] = defaultValue;

	this.prototype["get" + attributeName] = function() {
		return this["m_" + attributeName];
	};

	this.prototype["set" + attributeName] = function(value) {
		this["m_" + attributeName] = value;
	};

};

function MPageComponentInteractive() {
	this.m_DocPrivObj = null;
	this.m_DocPrivMask = 0;

	MPageComponentInteractive.method("setPrivObj", function(value) {
		this.m_DocPrivObj = value;
	});


	MPageComponentInteractive.method("getDocPrivObj", function() {
		return (this.m_DocPrivObj);
	});


	MPageComponentInteractive.method("setIsCompViewable", function(value) {
		this.m_isCompViewable = value;
	});


	MPageComponentInteractive.method("setIsCompAddable", function(value) {
		this.m_isCompAddable = value;
	});


	MPageComponentInteractive.method("setIsCompModifiable", function(value) {
		this.m_isCompModifiable = value;
	});


	MPageComponentInteractive.method("setIsCompUnchartable", function(value) {
		this.m_isCompUnchartable = value;
	});


	MPageComponentInteractive.method("setIsCompSignable", function(value) {
		this.m_isCompSignable = value;
	});


	MPageComponentInteractive.method("getCompPrivMask", function() {
		var VIEW_MASK = parseInt("1", 2);
		var ADD_MASK = parseInt("10", 2);
		var MODIFY_MASK = parseInt("100", 2);
		var UNCHART_MASK = parseInt("1000", 2);
		var SIGN_MASK = parseInt("10000", 2);
		var privMask = 0;
		privMask = ((this.m_isCompViewable) ? VIEW_MASK : 0) | //Add View Privs if true
			((this.m_isCompAddable) ? ADD_MASK : 0) | //Add Add Privs if true
			((this.m_isCompModifiable) ? MODIFY_MASK : 0) | //Add Mod Privs if true
			((this.m_isCompUnchartable) ? UNCHART_MASK : 0) | //Add Uchart Privs if true
			((this.m_isCompSignable) ? SIGN_MASK : 0);
		//Add Sign Privs if true

		return (privMask);
	});


	MPageComponentInteractive.method("getPrivFromArray", function(eventCd, array) {
		var i = array.length;
		while (i--) {
			if (eventCd == array[i].EVENT_CD) {
				return (true);
			}
		}
		return (false);
	});


	MPageComponentInteractive.method("isResultEventCodeSignable", function(eventCd) {
		if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
				.EVENT_PRIVILEGES.VIEW_RESULTS.GRANTED.EVENT_CODES)) {
			return (true);
		}
		else {
			return (false);
		}
	});


	MPageComponentInteractive.method("isResultEventCodeAddable", function(eventCd) {
		if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
				.EVENT_PRIVILEGES.ADD_DOCUMENTATION.GRANTED.EVENT_CODES)) {
			return (true);
		}
		else {
			return (false);
		}
	});


	MPageComponentInteractive.method("isResultEventCodeModifiable", function(eventCd) {
		if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
				.EVENT_PRIVILEGES.MODIFY_DOCUMENTATION.GRANTED.EVENT_CODES)) {
			return (true);
		}
		else {
			return (false);
		}
	});


	MPageComponentInteractive.method("isResultEventCodeUnchartable", function(eventCd) {
		if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
				.EVENT_PRIVILEGES.UNCHART_DOCUMENTATION.GRANTED.EVENT_CODES)) {
			return (true);
		}
		else {
			return (false);
		}
	});


	MPageComponentInteractive.method("isResultEventCodeSignable", function(eventCd) {
		if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
				.EVENT_PRIVILEGES.SIGN_DOCUMENTATION.GRANTED.EVENT_CODES)) {
			return (true);
		}
		else {
			return (false);
		}
	});


	MPageComponentInteractive.method("getEventCdPrivs", function(component, eventArr) {
		var self = this;
		var criterion = this.getCriterion();
		var paramEventCd = MP_Util.CreateParamArray(eventArr, 1);
		var paramPrivMask = this.getCompPrivMask();
		var sendAr = ["^MINE^", criterion.provider_id + ".0", paramEventCd, "0.0", paramPrivMask, criterion.ppr_cd + ".0"];
		var request = new MP_Core.ScriptRequest(this, "ENG:MPG.MPCINTERACTIVE - Get Doc prefs");
		request.setParameters(sendAr);
		request.setName("getCompPrivs");
		request.setProgramName("MP_GET_PRIVS_BY_CODE_JSON");
		request.setAsync(false);
		MP_Core.XMLCCLRequestCallBack(component, request, function(replyObj){
			self.processEventCdReply(replyObj);
		});
	});


	MPageComponentInteractive.method("processEventCdReply", function(reply) {
		this.m_DocPrivObj = reply;
	});

}

MPageComponentInteractive.inherits(MPageComponent);

/*
 * The MPage grouper provides a means in which to group MPageGroups together into an
 * array for results such as Blood Pressure where each group is a sequence of events.
 */
function MPageGrouper() {
	this.m_groups = null;
	MPageGrouper.method("setGroups", function(value) {
		this.m_groups = value;
	});


	MPageGrouper.method("getGroups", function() {
		return this.m_groups;
	});


	MPageGrouper.method("addGroup", function(value) {
		if (this.m_groups === null) {
			this.m_groups = [];
		}
		this.m_groups.push(value);
	});

}

MPageGrouper.inherits(MPageGroup);

function MPageGroup() {
	this.m_groupName = "";
	this.m_groupSeq = 0;
	this.m_groupId = 0;
	MPageGroup.method("setGroupId", function(value) {
		this.m_groupId = value;
	});


	MPageGroup.method("getGroupId", function() {
		return this.m_groupId;
	});


	MPageGroup.method("setGroupName", function(value) {
		this.m_groupName = value;
	});


	MPageGroup.method("getGroupName", function() {
		return this.m_groupName;
	});


	MPageGroup.method("setSequence", function(value) {
		this.m_groupSeq = value;
	});


	MPageGroup.method("getSequence", function() {
		return this.m_groupSeq;
	});

}

function MPageEventSetGroup() {
	this.m_eventSets = null;
	this.m_isSequenced = false;
	MPageEventSetGroup.method("isSequenced", function() {
		return this.m_isSequenced;
	});


	MPageEventSetGroup.method("setSequenced", function(value) {
		this.m_isSequenced = value;
	});


	MPageEventSetGroup.method("getEventSets", function() {
		return this.m_eventSets;
	});


	MPageEventSetGroup.method("setEventSets", function(value) {
		this.m_eventSets = value;
	});


	MPageEventSetGroup.method("addEventSet", function(value) {
		if (this.m_eventSets === null) {
			this.m_eventSets = [];
		}
		this.m_eventSets.push(value);
	});

}

MPageEventSetGroup.inherits(MPageGroup);

function MPageCatalogCodeGroup() {
	this.m_catalogCodes = null;
	this.m_isSequenced = false;
	MPageCatalogCodeGroup.method("isSequenced", function() {
		return this.m_isSequenced;
	});


	MPageCatalogCodeGroup.method("setSequenced", function(value) {
		this.m_isSequenced = value;
	});


	MPageCatalogCodeGroup.method("getCatalogCodes", function() {
		return this.m_catalogCodes;
	});


	MPageCatalogCodeGroup.method("setCatalogCodes", function(value) {
		this.m_catalogCodes = value;
	});


	MPageCatalogCodeGroup.method("addCatalogCode", function(value) {
		if (this.m_catalogCodes === null) {
			this.m_catalogCodes = [];
		}
		this.m_catalogCodes.push(value);
	});

}

MPageCatalogCodeGroup.inherits(MPageGroup);

function MPageEventCodeGroup() {
	this.m_eventCodes = null;
	this.m_isSequenced = false;
	MPageEventCodeGroup.method("isSequenced", function() {
		return this.m_isSequenced;
	});


	MPageEventCodeGroup.method("setSequenced", function(value) {
		this.m_isSequenced = value;
	});


	MPageEventCodeGroup.method("getEventCodes", function() {
		return this.m_eventCodes;
	});


	MPageEventCodeGroup.method("setEventCodes", function(value) {
		this.m_eventCodes = value;
	});


	MPageEventCodeGroup.method("addEventCode", function(value) {
		if (this.m_eventCodes === null) {
			this.m_eventCodes = [];
		}
		this.m_eventCodes.push(value);
	});

}

MPageEventCodeGroup.inherits(MPageGroup);

function MPageCodeValueGroup() {
	this.m_codes = null;
	MPageCodeValueGroup.method("getCodes", function() {
		return this.m_codes;
	});


	MPageCodeValueGroup.method("setCodes", function(value) {
		this.m_codes = value;
	});


	MPageCodeValueGroup.method("addCode", function(value) {
		if (this.m_codes === null) {
			this.m_codes = [];
		}
		this.m_codes.push(value);
	});

}

MPageCodeValueGroup.inherits(MPageGroup);

//The MPageSequenceGroup is a grouper of items such as filter means, event codes, event sets, etc.
function MPageSequenceGroup() {
	this.m_items = null;
	this.m_mapItems = null;
	this.m_isMultiType = false;

	MPageSequenceGroup.method("getItems", function() {
		return this.m_items;
	});


	MPageSequenceGroup.method("setItems", function(value) {
		this.m_items = value;
	});


	MPageSequenceGroup.method("addItem", function(value) {
		if (this.m_items === null) {
			this.m_items = [];
		}
		this.m_items.push(value);
	});


	MPageSequenceGroup.method("setMultiValue", function(value) {
		this.m_isMultiType = value;
	});


	MPageSequenceGroup.method("isMultiValue", function() {
		return (this.m_isMultiType);
	});


	MPageSequenceGroup.method("getMapItems", function() {
		return this.m_mapItems;
	});


	MPageSequenceGroup.method("setMapItems", function(value) {
		this.m_mapItems = value;
	});

}

MPageSequenceGroup.inherits(MPageGroup);

function MPageGroupValue() {
	this.m_description = "";
	this.m_id = 0.0;
	this.m_meaning = "";
	this.m_name = "";
	this.m_qualifierFlag = 0;
	this.m_sequence = 0;
	this.m_valSequence = 0;
	this.m_valTypeFlag = 0;
}

MPageGroupValue.prototype.getId = function() {
	return this.m_id;
};

MPageGroupValue.prototype.setId = function(id) {
	this.m_id = id;
};

MPageGroupValue.prototype.getName = function() {
	return this.m_name;
};

MPageGroupValue.prototype.setName = function(name) {
	this.m_name = name;
};

MPageGroupValue.prototype.getSequence = function() {
	return this.m_sequence;
};

MPageGroupValue.prototype.setSequence = function(sequence) {
	this.m_sequence = sequence;
};

MPageGroupValue.prototype.getDescription = function() {
	return this.m_description;
};

MPageGroupValue.prototype.setDescription = function(description) {
	this.m_description = description;
};

MPageGroupValue.prototype.getMeaning = function() {
	return this.m_meaning;
};

MPageGroupValue.prototype.setMeaning = function(meaning) {
	this.m_meaning = meaning;
};

MPageGroupValue.prototype.getValueSequence = function() {
	return this.m_valSequence;
};

MPageGroupValue.prototype.setValueSequence = function(valSequence) {
	this.m_valSequence = valSequence;
};

MPageGroupValue.prototype.getValueTypeFlag = function() {
	return this.m_valTypeFlag;
};

MPageGroupValue.prototype.setValueTypeFlag = function(valTypeFlag) {
	this.m_valTypeFlag = valTypeFlag;
};

MPageGroupValue.prototype.getQualifierFlag = function() {
	return this.m_qualifierFlag;
};

MPageGroupValue.prototype.setQualifierFlag = function(qualFlag) {
	this.m_qualifierFlag = qualFlag;
};


/*eslint-disable no-unused-vars*/
var CERN_COMPONENT_TYPE_SUMMARY = 1;
var CERN_COMPONENT_TYPE_WORKFLOW = 2;
/*eslint-enable no-unused-vars*/

function ComponentStyle() {
	this.m_nameSpace = "";
	this.m_id = "";
	this.m_className = "section";
	this.m_contentId = "";
	this.m_contentClass = "sec-content";
	this.m_headerClass = "sec-hd";
	this.m_headToggle = "sec-hd-tgl";
	this.m_secTitle = "sec-title";
	this.m_aLink = "";
	this.m_secTotal = "sec-total";
	this.m_info = "";
	this.m_subSecHeaderClass = "sub-sec-hd";
	this.m_subSecTitleClass = "sub-sec-title";
	this.m_subSecContentClass = "sub-sec-content";
	this.m_contentBodyClass = "content-body";
	this.m_searchBoxDiv = "search-box-div";
	this.m_subTitleDisp = "sub-title-disp";
	// If a component may be on a page multiple times, a unique identifier such as the component id will need to be set on the style
	// The unique identifier is only utilized on styles that are placeholders to be replaced at a later point.
	this.m_componentId = 0;
	this.m_color = "";
	//This is the component type which determines how it will be rendered in the View
	this.m_componentType = null;

	/**
	 * Initializes the component style with the provided namespace to utilize throughout the component.
	 * @param {Object} value
	 */
	ComponentStyle.method("initByNamespace", function(value) {
		this.m_nameSpace = value;
		this.m_id = value;
		this.m_className += (" " + value + "-sec");
		this.m_contentId = value + "Content";
		this.m_aLink = value + "Link";
		this.m_info = value + "-info";
	});


	ComponentStyle.method("getNameSpace", function() {
		return this.m_nameSpace;
	});


	ComponentStyle.method("getId", function() {
		return this.m_id + this.m_componentId;
	});


	ComponentStyle.method("getClassName", function() {
		return this.m_className;
	});


	ComponentStyle.method("getColor", function() {
		return this.m_color;
	});


	ComponentStyle.method("getContentId", function() {
		return this.m_contentId + this.m_componentId;
	});


	ComponentStyle.method("getContentBodyClass", function() {
		return this.m_contentBodyClass;
	});


	ComponentStyle.method("getContentClass", function() {
		return this.m_contentClass;
	});


	ComponentStyle.method("getHeaderClass", function() {
		return this.m_headerClass;
	});


	ComponentStyle.method("getHeaderToggle", function() {
		return this.m_headToggle;
	});


	ComponentStyle.method("getTitle", function() {
		return this.m_secTitle;
	});


	ComponentStyle.method("getLink", function() {
		return this.m_aLink;
	});


	ComponentStyle.method("getTotal", function() {
		return this.m_secTotal;
	});


	ComponentStyle.method("getInfo", function() {
		return this.m_info;
	});


	ComponentStyle.method("getSearchBoxDiv", function() {
		return this.m_searchBoxDiv;
	});


	ComponentStyle.method("getSubSecContentClass", function() {
		return this.m_subSecContentClass;
	});


	ComponentStyle.method("getSubSecContentClass", function() {
		return this.m_subSecContentClass;
	});


	ComponentStyle.method("getSubSecHeaderClass", function() {
		return this.m_subSecHeaderClass;
	});


	ComponentStyle.method("getSubSecTitleClass", function() {
		return this.m_subSecTitleClass;
	});


	ComponentStyle.method("getSubTitleDisp", function() {
		return this.m_subTitleDisp;
	});


	ComponentStyle.method("getComponentType", function() {
		return this.m_componentType;
	});


	ComponentStyle.method("setComponentId", function(value) {
		this.m_componentId = value;
	});


	ComponentStyle.method("setNameSpace", function(value) {
		this.m_nameSpace = value;
	});


	ComponentStyle.method("setId", function(value) {
		this.m_id = value;
	});


	ComponentStyle.method("setClassName", function(value) {
		this.m_className = value;
	});


	ComponentStyle.method("setColor", function(value) {
		this.m_color = value;
		this.setClassName(this.getClassName() + " " + value);
	});


	ComponentStyle.method("setContextId", function(value) {
		this.m_contentId = value;
	});


	ComponentStyle.method("setContentBodyClass", function(value) {
		this.m_contentBodyClass = value;
	});


	ComponentStyle.method("setContentClass", function(value) {
		this.m_contentClass = value;
	});


	ComponentStyle.method("setContextClass", function(value) {
		this.m_contentClass = value;
	});


	ComponentStyle.method("setHeaderClass", function(value) {
		this.m_headerClass = value;
	});


	ComponentStyle.method("setHeaderToggle", function(value) {
		this.m_headToggle = value;
	});


	ComponentStyle.method("setSearchBoxDiv", function(value) {
		this.m_searchBoxDiv = value;
	});


	ComponentStyle.method("setSubSecContentClass", function(value) {
		this.m_subSecContentClass = value;
	});


	ComponentStyle.method("setSubSecHeaderClass", function(value) {
		this.m_subSecHeaderClass = value;
	});


	ComponentStyle.method("setSubSecTitleClass", function(value) {
		this.m_subSecTitleClass = value;
	});


	ComponentStyle.method("setSubTitleDisp", function(value) {
		this.m_subTitleDisp = value;
	});


	ComponentStyle.method("setTitle", function(value) {
		this.m_secTitle = value;
	});


	ComponentStyle.method("setLink", function(value) {
		this.m_aLink = value;
	});


	ComponentStyle.method("setTotal", function(value) {
		this.m_secTotal = value;
	});


	ComponentStyle.method("setInfo", function(value) {
		this.m_info = value;
	});


	ComponentStyle.method("setComponentType", function(value) {
		this.m_componentType = value;
	});

}

/**
 * Sorts the MPage Components by group sequence, then by column, and lastly by row.
 * @param {MPageComponent} c1 Component one to compare against
 * @param {MPageComponent} c2 Component two to compare against
 * @return {Short} Returns the sequence in which the components should display.
 *
 * @author Greg Howdeshell
 */
function SortMPageComponentRows(c1, c2) {
	if (c1.getSequence() < c2.getSequence()) {
		return -1;
	}
	if (c1.getSequence() > c2.getSequence()) {
		return 1;
	}
	return 0;
}

function SortMPageComponentCols(c1, c2) {
	if (c1.getColumn() < c2.getColumn()) {
		return -1;
	}
	if (c1.getColumn() > c2.getColumn()) {
		return 1;
	}
	return SortMPageComponentRows(c1, c2);
}

function SortMPageComponents(c1, c2) {
	if (c1.getPageGroupSequence() < c2.getPageGroupSequence()) {
		return -1;
	}
	if (c1.getPageGroupSequence() > c2.getPageGroupSequence()) {
		return 1;
	}
	return SortMPageComponentCols(c1, c2);
}
/*
 The scope of an MPage object and Components are during rendering of the page.  However,
 once the page has been rendered these items are lost.  Because there is a need to refresh
 components, the components on a 'page' must be globally stored to allow for refreshing of data.
 */
var CERN_EventListener = null;
var CERN_MPageComponents = null;
//A global object which keeps a mapping of Report Means to the components which should be instantiated.
//Supporting functionality is located in the MP_Util namespace
var CERN_ObjectDefinitionMapping = {};
var CERN_BrowserDevInd = false;
var CERN_PersonalFav = null;
var CK_DATA = {};

var STR_PAD_LEFT = 1;
var STR_PAD_RIGHT = 2;
var STR_PAD_BOTH = 3;

/* If the browser does not define the addAll function for the Array */
if(!Array.prototype.addAll) {
	Array.prototype.addAll = function(v) {
		if(v && v.length > 0) {
			for(var x = 0, xl = v.length; x < xl; x++) {
				this.push(v[x]);
			}
		}
	};
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of Array.prototype.indexOf.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if(!Array.prototype.indexOf) {
	throw new Error('Browser version does not contain an implementation of Array.prototype.indexOf');
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of Function.prototype.bind.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if (!Function.prototype.bind) {
	throw new Error('Browser version does not contain an implementation of Function.prototype.bind');
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of document.getElementsByClassName.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if(!document.getElementsByClassName){
	throw new Error('Browser version does not contain an implementation of document.getElementsByClassName');
}

/*
 * this function overrides the browsers error handling functionality so we can display a user friendly
 * rather than the browsers technical dialog.
 * @param {string} message - The message associated to the error that has occurred
 * @param {string} file - The file where the error has occurred
 * @param {number} lineNumber - The line number the error was thrown from
 * @param {number} columnNumber - The column number in the file where the error originated
 * @param {Error} error - The error that was intercepted by the window.onerror.
 * 		This parameter is defined in IE11+ and as such, must be ignored if
 * 		it is not defined.
 * @return {boolean}
 */
window.onerror = function(message, file, lineNumber, columnNumber, error) {
	var errorModal = null;
	var refreshButton = null;
	var closeButton = null;
	var source = i18n.UNKNOWN;
	//Accessing callee/caller is seen as potentially dangerous, so wrap it
	//in a try/catch block
	try {
		if(error && error.stack) {
			source = error.stack;
		} else {
			source = arguments.callee.caller.toString();
		}
	} catch(err) {
		//Intentionally empty catch
	}
	logger.activate();
	logger.logError(
		i18n.UNEXPECTED_ERROR_CAUGHT + '<br />' +
		i18n.discernabu.JS_ERROR + ': ' + message + '<br />' +
		i18n.FILE + ': ' + file + '<br />' +
		i18n.LINE_NUMBER + ': ' + lineNumber + '<br />' +
		i18n.SOURCE + ': ' + source + '<br />'
	);

	//Throw the error when we are developing in a browser, otherwise show the modal to the user
	if(CERN_BrowserDevInd) {
		throw (new Error(i18n.UNEXPECTED_ERROR_CAUGHT + '<br />' + i18n.discernabu.JS_ERROR + ': ' + message + '<br />' + i18n.FILE + ': ' + file + '<br />' + i18n.LINE_NUMBER + ': ' + lineNumber));
	}
	else {
		//Create a modal dialog and ask the user if they would like to refresh or continue
		errorModal = MP_ModalDialog.retrieveModalDialogObject('errorModal');
		if(!errorModal) {
			errorModal = MP_Util.generateModalDialogBody('errorModal', 'error', i18n.PAGE_ERROR, i18n.PAGE_ERROR_ACTION);
			errorModal.setHeaderTitle(i18n.ERROR_OCCURED);
			//Create and add the refresh button
			refreshButton = new ModalButton('refreshButton');
			refreshButton.setText(i18n.REFRESH).setCloseOnClick(true);
			refreshButton.setOnClickFunction(function() {
				//Refresh the page
				CERN_Platform.refreshMPage();
			});


			errorModal.addFooterButton(refreshButton);
			//Create and add the close button
			closeButton = new ModalButton('closeButton');
			closeButton.setText(i18n.CLOSE).setCloseOnClick(true);
			errorModal.addFooterButton(closeButton);
		}
		MP_ModalDialog.updateModalDialogObject(errorModal);
		MP_ModalDialog.showModalDialog('errorModal');

		//Returning true supresses the error in FireFox and IE but allows it to propegate in Chrome
		return true;
	}
};

/**
 * Core utility methods
 * @namespace
 */
var MP_Core = function() {
	return {
		/**
		 * This function returns the normalcy class associated with the result
		 * @param result - is the MP_Core.Measurement object.
		 */
		GetNormalcyClass: function(result) {
			var normalcy = 'res-normal';
			var normalcyMeaning = result.getNormalcy();
			if (normalcyMeaning) {
				switch (normalcyMeaning.meaning) {
					case 'LOW':
						normalcy = 'res-low';
						break;
					case 'HIGH':
						normalcy = 'res-high';
						break;
					case 'ABNORMAL':
						normalcy = 'res-abnormal';
						break;
					case 'CRITICAL':
					case 'EXTREMEHIGH':
					case 'PANICHIGH':
					case 'EXTREMELOW':
					case 'PANICLOW':
					case 'VABNORMAL':
					case 'POSITIVE':
						normalcy = 'res-severe';
						break;
				}
			}
			return normalcy;
		},
		/**
		 * This function associates appropriate styles to the results.
		 * @param result - is the MP_Core.Measurement object.
		 * @param excludeUOM - This value indicates whether to add the Unit of measurement or not.
		 */
		GetNormalcyResultDisplay: function(result, excludeUOM) {
			var ar = ['<span class=\'', MP_Core.GetNormalcyClass(result), '\'><span class=\'res-ind\'>&nbsp;</span><span class=\'res-value\'>', MP_Core.GetEventViewerLink(result, MP_Util.Measurement.GetString(result, null, 'longDateTime2', excludeUOM)), '</span>', MP_Util.Measurement.GetModifiedIcon(result), '</span>'];
			return ar.join('');
		},
		/**
		 * This function links the result viewer to the respective results.
		 * @param result - is the MP_Core.Measurement object.
		 * @param sResultDisplay - This contains the  value that needs to be displayed.
		 */
		GetEventViewerLink: function(result, sResultDisplay) {
			var params = [result.getPersonId(), result.getEncntrId(), result.getEventId(), '"EVENT"'];
			var ar = ['<a onclick=\'MP_Util.LaunchClinNoteViewer(', params.join(','), '); return false;\' href=\'#\'>', sResultDisplay, '</a>'];
			return ar.join('');
		},
		/**
		 * The criterion object stores information about the request in context such as the patient/person, encounter/visit,
		 * provider/personnel, relationship etc.
		 */
		Criterion: function(jsCrit, static_content) {
			var m_patInfo = null;
			var m_prsnlInfo = null;
			var m_encntrOverride = [];

			this.person_id = jsCrit.PERSON_ID;
			this.encntr_id = (jsCrit.ENCNTRS.length > 0) ? jsCrit.ENCNTRS[0].ENCNTR_ID : 0;
			this.provider_id = jsCrit.PRSNL_ID;
			this.executable = jsCrit.EXECUTABLE;
			this.static_content = static_content;
			this.position_cd = jsCrit.POSITION_CD;
			this.ppr_cd = jsCrit.PPR_CD;
			this.debug_ind = jsCrit.DEBUG_IND;
			CERN_BrowserDevInd = ((parseInt(this.debug_ind, 10) & 0x01) === 1) ? true : false;
			this.help_file_local_ind = jsCrit.HELP_FILE_LOCAL_IND;
			this.category_mean = jsCrit.CATEGORY_MEAN;
			this.locale_id = ((parseInt(this.debug_ind, 10) & 0x02) === 2) ? 'en_us' : jsCrit.LOCALE_ID;
			this.logical_domain_id = (typeof jsCrit.LOGICAL_DOMAIN_ID !== 'undefined') ? jsCrit.LOGICAL_DOMAIN_ID : null;
			try{
				if(CERN_Platform.inMillenniumContext()){
					this.client_tz = jsCrit.CLIENT_TZ;
				}
				else{
					this.client_tz = MP_Timezone.getTzIndex();
				}
			}catch(err){
				logger.logWarn('Unable to set client time zone');
				this.client_tz = 0; //utc
			}

			//@deprecated as of 3.3.1 and should be removed as of greater than or equal to 3.4
			this.device_location = '';
			this.facility_cd = jsCrit.ENCNTR_LOCATION.FACILITY_CD;

			var encntrOR = jsCrit.ENCNTR_OVERRIDE;

			if(encntrOR) {
				for(var x = encntrOR.length; x--; ) {
					m_encntrOverride.push(encntrOR[x].ENCNTR_ID);
				}
			}
			else {
				m_encntrOverride.push(this.encntr_id);
			}

			this.setPatientInfo = function(value) {
				m_patInfo = value;
			};


			this.getPatientInfo = function() {
				return m_patInfo;
			};

			this.getPersonnelInfo = function() {
				if(!m_prsnlInfo) {
					m_prsnlInfo = new MP_Core.PersonnelInformation(this.provider_id, this.person_id);
				}
				return m_prsnlInfo;
			};

			/**
			 * @return List of encounters that are considered 'ACTIVE'.
			 * In the rare case that encounter override is needed, this will return the encounter neccessary to pass
			 * to a service for retrieval of data.
			 */
			this.getEncounterOverride = function() {
				return m_encntrOverride;
			};

			this.is_utc = jsCrit.IS_UTC;

		},
		PatientInformation: function() {
			var m_dob = null;
			var m_sex = null;
			var m_name = '';

			this.setSex = function(value) {
				m_sex = value;
			};
			this.getSex = function() {
				return m_sex;
			};
			this.setDOB = function(value) {
				m_dob = value;
			};
			this.getDOB = function() {
				return m_dob;
			};
			this.setName = function(value) {
				m_name = value;
			};
			this.getName = function() {
				return m_name;
			};
		},

		PeriopCases: function() {
			var m_case_id = null;
			var m_days = null;
			var m_hours = null;
			var m_mins = null;
			var m_cntdwn_desc_flag = null;

			this.setCaseID = function(value) {
				m_case_id = value;
			};
			this.getCaseID = function() {
				return m_case_id;
			};
			this.setDays = function(value) {
				m_days = value;
			};
			this.getDays = function() {
				return m_days;
			};
			this.setHours = function(value) {
				m_hours = value;
			};
			this.getHours = function() {
				return m_hours;
			};
			this.setMins = function(value) {
				m_mins = value;
			};
			this.getMins = function() {
				return m_mins;
			};
			this.setCntdwnDscFlg = function(value) {
				m_cntdwn_desc_flag = value;
			};
			this.getCntdwnDscFlg = function() {
				return m_cntdwn_desc_flag;
			};
		},

		ScriptRequest: function(component, loadTimerName) {
			var m_comp = component || null;
			var m_load = loadTimerName || '';
			var m_name = '';
			var m_programName = '';
			var m_params = null;
			var m_blobIn = null;
			var m_async = true;
			var m_responseHandler = null;
			var m_timer = null;
			var m_source = null;
			var m_execCallback = false;
			//Specify whether the consumer is expecting raw data
			var m_requiresRawData = false;

			this.setExecCallback = function(value) {
				m_execCallback = value;
			};

			this.getExecCallback = function(){
				return m_execCallback;
			};

			this.logCompletion = function(reply) {
				logger.logMessage('<b>Request Ended</b><br /><ul>' +
						'<li>program: ' + m_programName + '</li>' +
						'<li>end_time: ' + new Date() + '</li>' +
						'<li>status: ' + reply.status + '</li></ul>');
			};

			this.logStart = function() {
				logger.logMessage('<b>Request Started</b><br /><ul>' +
						'<li>program: ' + m_programName + '</li>' +
						'<li>start_time: ' + new Date() + '</li></ul>');
			};

			this.start = function() {
				MP_Core.XMLCCLRequestCallBack(this.m_comp, this);
			};

			this.notify = function() {
				//We only notify the manager if the request was started by the manager
				if(this.getSource() !== RequestManager.SOURCE) {
					return;
				}
				MP_RequestManager.notify();
			};

			this.getResponseHandler = function() {
				return m_responseHandler;
			};

			this.setResponseHandler = function(responseHandler) {
				m_responseHandler = responseHandler;
			};

			this.getTimer = function() {
				return m_timer;
			};

			this.setTimer = function(timer) {
				m_timer = timer;
			};

			this.getComponent = function() {
				return m_comp;
			};
			this.getLoadTimer = function() {
				return m_load;
			};
			this.setName = function(value) {
				m_name = value;
			};
			this.getName = function() {
				return m_name;
			};
			this.setProgramName = function(value) {
				m_programName = value;
			};
			this.getProgramName = function() {
				return m_programName;
			};
			this.setParameters = function(value) {
				m_params = value;
			};
			this.getParameters = function() {
				return m_params;
			};
			this.setRequestBlobIn = function(value) {
				m_blobIn = value;
			};
			this.getRequestBlobIn = function() {
				return m_blobIn;
			};
			this.setAsync = function(value) {
				m_async = value;
			};
			this.isAsync = function() {
				return m_async;
			};
			this.getSource = function() {
				return m_source;
			};
			this.setSource = function(source) {
				m_source = source;
			};
			this.getRequiresRawData = function(){
				return m_requiresRawData;
			};
			this.setRequiresRawData = function(requiresRaw){
				m_requiresRawData = requiresRaw;
			};
		},
		ScriptReply: function(component) {
			//used to syne a request to a reply
			var m_name = '';
			//by default every script reply is 'f'ailed unless otherwise noted
			var m_status = 'F';
			var m_err = '';
			var m_resp = null;
			var m_comp = component;

			this.setName = function(value) {
				m_name = value;
			};
			this.getName = function() {
				return m_name;
			};
			this.setStatus = function(value) {
				m_status = value;
			};
			this.getStatus = function() {
				return m_status;
			};
			this.setError = function(value) {
				m_err = value;
			};
			this.getError = function() {
				return m_err;
			};
			this.setResponse = function(value) {
				m_resp = value;
			};
			this.getResponse = function() {
				return m_resp;
			};
			this.getComponent = function() {
				return m_comp;
			};
		},
		PersonnelInformation: function(prsnlId, patientId) {
			var m_prsnlId = prsnlId;
			//if m_viewableEncntrs remains null, error in retrieval of viewable encntr
			var m_viewableEncntrs = null;
			//load valid encounter list from patcon wrapper
			var patConObj = null;
			try {
				patConObj = CERN_Platform.getDiscernObject('PVCONTXTMPAGE');
				logger.logDiscernInfo(null, 'PVCONTXTMPAGE', 'mp_core.js', 'PersonnelInformation');
				if (patConObj) {
					m_viewableEncntrs = patConObj.GetValidEncounters(patientId);
					logger.logDebug('Viewable Encounters: ' + m_viewableEncntrs);
				}
			}
			catch(e) {}
			finally {
				//release used memory
				patConObj = null;
			}

			this.getPersonnelId = function() {
				return m_prsnlId;
			};
			/**
			 * Returns the associated encounter that the provide has the ability to see
			 */
			this.getViewableEncounters = function() {
				return m_viewableEncntrs;
			};
		},
		/**
		 * Create and return shared resource (viewableEncntrs) for the "Viewable Encounters" for the provided patient person_id.
		 * If run within the context of win32 applications, the function will leverage PVCONTXTMPAGE and GetValidEncounters:
		 *   https://wiki.ucern.com/display/public/MPDEVWIKI/GetValidEncounters
		 * If run outside of win32 applications (MPages web service), this function will leverage request 3200310 (msvc_svr_get_clinctx).
		 *
		 * Consumers of this function should check the shared resource object that is returned to determine if data exists:
		 *   viewableEncntrsObj.isResourceAvailable() && viewableEncntrsObj.getResourceData()
		 *
		 * If those do not both evaluate to true, the consumer should then add a listener for "viewableEncntrInfoAvailable", which will be invoked when the shared resource data is available.
		 *
		 * @param patientId The person_id of the patient to retrieve viewable encounters
		 * @return {object} An object that contains the status of retrieving the viewable encounters, and a string of the comma separated viewable encounters (if available)
		 */
		GetViewableEncntrs: function(patientId) {
			/**
			 * Returns the associated encounter(s) that the currently authenticated provider has the ability to see, from PVCONTXTMPAGE.
			 * This logic will be consumed from win32 MPages where PVCONTXTMPAGE is available.
			 * @return {string} List of viewable encounters, comma separated
			 */
			function getViewableFromPvContxtMpage() {
				var patConObj = null;
				var m_viewableEncntrs = '';
				try {
					patConObj = window.external.DiscernObjectFactory('PVCONTXTMPAGE');
					logger.logDiscernInfo(null, 'PVCONTXTMPAGE', 'mp_core.js', 'getViewableFromPvContxtMpage');
					if (patConObj) {
						m_viewableEncntrs = patConObj.GetValidEncounters(patientId);
						logger.logDebug('Viewable Encounters obtained from PVCONTXTMPAGE: ' + m_viewableEncntrs);
					}
				}
				catch(e) {}
				finally {
					//release used memory
					patConObj = null;
				}
				return m_viewableEncntrs;
			}


			/**
			 * Make async call to retrieve viewable encounters from clinical context service, using the script mp_exec_std_request.
			 * The clinical context service (msvc_svr_get_clinctx, 3200310) will return the authorized (viewable) encounters for the patient in context:
			 *   Application Number: 3202004
			 *   Task Number: 3202004
			 *   Request Number: 3200310
			 * This logic will be consumed when PVCONTXTMPAGE is not available.
			 * @return {null}
			 */
			function retrieveEncntrsFromClinicalContext(){
				var request = new MP_Core.ScriptRequest();
				var programName = 'mp_exec_std_request';
				var jsonString = '{"REQUESTIN":{"PATIENT_ID":' + patientId + '.0,"LOAD":{"AUTH_ENCOUNTER":1}}}';
				var params = ['^MINE^', '~' + jsonString + '~', 3202004, 3202004, 3200310];
				request.setProgramName(programName);
				request.setParameters(params);
				request.setAsync(true);
				request.setExecCallback(true);
				MP_Core.XMLCCLRequestCallBack(null, request, handleContextFromService);
			}

			/**
			 * Callback to Handle the reply object from retrieveEncntrsFromClinicalContext()
			 * @param {object} MP_Core.ScriptReply object
			 * @return {null}
			 */
			function handleContextFromService(replyObj) {
				var m_viewableEncntrs = '';

				// Get the viewableEncntrs SharedResource
				var veResource = MP_Resources.getSharedResource('viewableEncntrs');

				if (replyObj.getStatus() === 'S') {
					try{
						var recordData = replyObj.getResponse();
						m_viewableEncntrs = $.map(recordData.AUTH_ENCOUNTER.AUTH_ENCOUNTERS, function(o) {
							return o['ENCOUNTER_ID'] + '.0';
						}).join(',');
						logger.logDebug('Viewable Encounters obtained from ClinicalContext service: ' + m_viewableEncntrs);
					}
					catch(err) {
						logger.logJSError(err, this, 'mp_core.js', 'GetViewableEncntrs');
					}
				}
				else {
					logger.logError('Unable to successfully retrieve Viewable Encounters from ClinicalContext service');
				}

				veResource.setIsAvailable(true);
				veResource.setIsBeingRetrieved(false);
				veResource.setResourceData(m_viewableEncntrs);

				//Fire event for all listeners
				CERN_EventListener.fireEvent(null, self, 'viewableEncntrInfoAvailable', veResource);
			}

			var self = this;
			var m_viewableEncntrs = '';

			// create the viewable encounters resource shared resource
			var veResource = MP_Resources.getSharedResource('viewableEncntrs');
			if (!veResource) {
				veResource = new SharedResource('viewableEncntrs');
				MP_Resources.addSharedResource('viewableEncntrs', veResource);
			}

			if(veResource.isResourceAvailable() && veResource.getResourceData()) {
				return veResource;
			}
			else {
				//Attempt to retrieve the viewable encounters from PVCONTXTMPAGE
				m_viewableEncntrs = getViewableFromPvContxtMpage();

				//If we obtained the viewable encounters from PVCONTXTMPAGE, set here, and return SR object
				if(m_viewableEncntrs){
					veResource.setResourceData(m_viewableEncntrs);
					veResource.setIsAvailable(true);
					return veResource;

				}
				else {
					//Check to see if the shared resource is currently retrieving data
					if(!veResource.isBeingRetrieved()){
						//Kick off the resource retrieval from ClinicalContext service
						veResource.setIsBeingRetrieved(true);
						retrieveEncntrsFromClinicalContext();
					}
					//Return the shared resource, which at this point should have isResourceAvailable() == false && getResourceData() == null
					return veResource;
				}
			}
		},
		/**
		 * @deprecated
		 * Creates and runs a request for a component based on the specified component, program, and parameter array.
		 * This function assumes the script call is being made for a component. This function populates a ScriptRequest
		 * object and passes it off to the XmlStandardRequest method, passing null for the callback.
		 * @param {MPageComponent} component  component object for which the script is being called.
		 * @param {String} program  the CCL program to be run.
		 * @param {Array} paramAr  the parameter array to be passed to the CCL program.
		 * @param {Boolean} async  whether the script call should be asynchronous or not. (Recommended that it
		 * be asynchronous).
		 */
		XMLCclRequestWrapper: function(component, program, paramAr, async) {
			var loadTimer = null;
			var renderTimer = null;
			var request = null;
			if(MPageComponent.prototype.isPrototypeOf(component)){
				//create a component script request
				request = new ComponentScriptRequest();
				request.setComponent(component);
				//Create the loadTimer and renderTimer
				loadTimer = new RTMSTimer(component.getComponentLoadTimerName(), component.getCriterion().category_mean);
				renderTimer = new RTMSTimer(component.getComponentRenderTimerName(), component.getCriterion().category_mean);
				request.setLoadTimer(loadTimer);
				request.setRenderTimer(renderTimer);
			}
			else{
				//Create a standard script request object
				request = new ScriptRequest();
			}
			request.setProgramName(program);
			request.setParameterArray(paramAr || []);
			request.setAsyncIndicator(typeof async === 'boolean' ? async : true);
			request.performRequest();
		},
		/**
		 * @deprecated
		 * As a means in which to provide the consumer to handle the response of the script request, this method
		 * provide an encapsulated means in which to call the XMLCCLRequest and return a ReplyObject with data
		 * about the response that can be utilized for evaluation.
		 * @param component  The component in which is executing the request
		 * @param oldRequestObj  A deprecated MP_Core.ScriptRequest Object containing the information about the script being executed
		 * @param funcCallBack  The function to execute once the execution of the request has been completed
		 */
		XMLCCLRequestCallBack: function(component, oldRequestObj, funcCallback) {
			MP_Core.XmlStandardRequest(component, oldRequestObj, funcCallback);
		},
		/**
		 * @deprecated
		 * This wraps the XML requests being made. This function is called by XMLCclRequestWrapper and XMLCCLRequestCallBack.
		 * Note that both component and callback are optional. However, if you want something to occur upon the script
		 * completing, one or the other must be provided.
		 * @param {MPageComponent} component . This parameter is an MPageComponent object. Specific methods will be called on this
		 * component to render it, but only if it is provided.
		 * @param {ScriptRequest} oldRequestObj   A deprecated MP_Core.ScriptRequest Object containing the information about the script being executed
		 * @param {Function} funcCallBack  the function to be called upon a request returning.
		 */
		XmlStandardRequest: function(component, oldRequestObj, funcCallback){
			var loadTimer = null;
			var renderTimer = null;
			var request = null;
			if(MPageComponent.prototype.isPrototypeOf(component)){
				//create a component script request
				request = new ComponentScriptRequest();
				request.setComponent(component);
				//Create the loadTimer and renderTimer
				loadTimer = new RTMSTimer(component.getComponentLoadTimerName(), component.getCriterion().category_mean);
				renderTimer = new RTMSTimer(component.getComponentRenderTimerName(), component.getCriterion().category_mean);
				request.setLoadTimer(loadTimer);
				request.setRenderTimer(renderTimer);
			}
			else{
				//Create a standard script request object
				request = new ScriptRequest();
				//Create the load timer
				loadTimer = new RTMSTimer(oldRequestObj.getLoadTimer());
				request.setLoadTimer(loadTimer);
			}
			//Copy over the remaining fields of the oldRequestObj
			request.setName(oldRequestObj.getName());
			request.setProgramName(oldRequestObj.getProgramName());
			request.setResponseHandler(funcCallback);
			request.setDataBlob(oldRequestObj.getRequestBlobIn() || '');
			request.setParameterArray(oldRequestObj.getParameters() || []);
			request.setAsyncIndicator(oldRequestObj.isAsync());
			request.setRawDataIndicator(oldRequestObj.getRequiresRawData());
			request.performRequest();
		},
		XMLCCLRequestThread: function(name, component, request) {
			var m_name = name;
			var m_comp = component;

			var m_request = request;
			m_request.setName(name);

			this.getName = function() {
				return m_name;
			};
			this.getComponent = function() {
				return m_comp;
			};
			this.getRequest = function() {
				return m_request;
			};
		},
		XMLCCLRequestThreadManager: function(callbackFunction, component, handleFinalize) {
			var m_threads = null;
			var m_replyAr = null;

			var m_isData = false;
			var m_isError = false;
			var x = 0;

			this.addThread = function(thread) {
				if (!m_threads) {
					m_threads = [];
				}
				m_threads.push(thread);
			};

			this.begin = function() {
				if (m_threads && m_threads.length > 0) {
					for ( x = m_threads.length; x--; ) {
						//start each xmlcclrequest
						var thread = m_threads[x];
						MP_Core.XMLCCLRequestCallBack(thread.getComponent(), thread.getRequest(), this.completeThread);
					}
				}
				else {
					if (handleFinalize) {
						var countText = (component.isLineNumberIncluded() ? '(0)' : '');
						component.finalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()), countText);
						//After the component has rendered call the postProcessing function to perform any additional actions
						component.postProcessing();
					}
					else {
						callbackFunction(null, component);
					}
				}
			};

			this.completeThread = function(reply) {
				if (!m_replyAr) {
					m_replyAr = [];
				}
				if (reply.getStatus() === 'S') {
					m_isData = true;
				}
				else if (reply.getStatus() === 'F') {
					m_isError = true;
				}

				m_replyAr.push(reply);
				if (m_replyAr.length === m_threads.length) {
					var countText = (component.isLineNumberIncluded() ? '(0)' : '');
					var errMsg = null;
					try {
						if (handleFinalize) {
							if (m_isError) {
								//handle error response
								errMsg = [];
								for (x = m_replyAr.length; x--; ) {
									var rep = m_replyAr[x];
									if (rep.getStatus() === 'F') {
										errMsg.push(rep.getError());
									}
								}
								component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join('<br />')), '');
							}
							else if (!m_isData) {
								//handle no data
								countText = (component.isLineNumberIncluded() ? '(0)' : '');
								component.finalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()), countText);
							}
							else {
								callbackFunction(m_replyAr, component);
							}
						}
						else {
							callbackFunction(m_replyAr, component);
						}
					}
					catch(err) {
						logger.logJSError(err, component, 'mp_core.js', 'XMLCCLRequestThreadManager');
						var i18nCore = i18n.discernabu;
						errMsg = ['<b>', i18nCore.JS_ERROR, '</b><br /><ul><li>', i18nCore.MESSAGE, ': ', err.message, '</li><li>', i18nCore.NAME, ': ', err.name, '</li><li>', i18nCore.NUMBER, ': ', (err.number & 0xFFFF), '</li><li>', i18nCore.DESCRIPTION, ': ', err.description, '</li></ul>'];
						component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join('')), '');
					}
					finally {
						if(component && typeof component.postProcessing !== 'undefined') {
							//After the component has rendered call the postProcessing function to perform any additional actions
							component.postProcessing();
						}
					}
				}
			};
		},
		MapObject: function(name, value) {
			this.name = name;
			this.value = value;
		},



		ReferenceRangeResult: function() {
			//results
			var m_valNLow = -1,
				m_valNHigh = -1,
				m_valCLow = -1,
				m_valCHigh = -1;
			//units of measure
			var m_uomNLow = null,
				m_uomNHigh = null,
				m_uomCLow = null,
				m_uomCHigh = null;
			this.init = function(refRange, codeArray) {
				var nf = MP_Util.GetNumericFormatter();
				m_valCLow = nf.format(refRange.CRITICAL_LOW.NUMBER);
				if (refRange.CRITICAL_LOW.UNIT_CD != '') { //eslint-disable-line eqeqeq
					m_uomCLow = MP_Util.GetValueFromArray(refRange.CRITICAL_LOW.UNIT_CD, codeArray);
				}
				m_valCHigh = nf.format(refRange.CRITICAL_HIGH.NUMBER);
				if (refRange.CRITICAL_HIGH.UNIT_CD != '') { //eslint-disable-line eqeqeq
					m_uomCHigh = MP_Util.GetValueFromArray(refRange.CRITICAL_HIGH.UNIT_CD, codeArray);
				}
				m_valNLow = nf.format(refRange.NORMAL_LOW.NUMBER);
				if (refRange.NORMAL_LOW.UNIT_CD != '') { //eslint-disable-line eqeqeq
					m_uomNLow = MP_Util.GetValueFromArray(refRange.NORMAL_LOW.UNIT_CD, codeArray);
				}
				m_valNHigh = nf.format(refRange.NORMAL_HIGH.NUMBER);
				if (refRange.NORMAL_HIGH.UNIT_CD != '') { //eslint-disable-line eqeqeq
					m_uomNHigh = MP_Util.GetValueFromArray(refRange.NORMAL_HIGH.UNIT_CD, codeArray);
				}
			};
			this.getNormalLow = function() {
				return m_valNLow;
			};
			this.getNormalHigh = function() {
				return m_valNHigh;
			};
			this.getNormalLowUOM = function() {
				return m_uomNLow;
			};
			this.getNormalHighUOM = function() {
				return m_uomNHigh;
			};
			this.getCriticalLow = function() {
				return m_valCLow;
			};
			this.getCriticalHigh = function() {
				return m_valCHigh;
			};
			this.getCriticalLowUOM = function() {
				return m_uomCLow;
			};
			this.getCriticalHighUOM = function() {
				return m_uomCHigh;
			};
			this.toNormalInlineString = function() {
				var low = (m_uomNLow) ? m_uomNLow.display : '';
				var high = (m_uomNHigh) ? m_uomNHigh.display : '';
				if (m_valNLow != 0 || m_valNHigh != 0) { //eslint-disable-line eqeqeq
					return (m_valNLow + '&nbsp;' + low + ' - ' + m_valNHigh + '&nbsp;' + high);
				}
				else {
					return '';
				}
			};
			this.toCriticalInlineString = function() {
				var low = (m_uomCLow) ? m_uomCLow.display : '';
				var high = (m_uomCHigh) ? m_uomCHigh.display : '';
				if (m_valCLow != 0 || m_valCHigh != 0) { //eslint-disable-line eqeqeq
					return (m_valCLow + '&nbsp;' + low + ' - ' + m_valCHigh + '&nbsp;' + high);
				}
				else {
					return '';
				}
			};
		},

		QuantityValue: function() {
			var m_val, m_precision;
			var m_uom = null;
			var m_refRange = null;
			var m_rawValue = 0;
			var m_hasModifier = false;
			this.init = function(result, codeArray) {
				var quantityValue = result.QUANTITY_VALUE;
				var referenceRange = result.REFERENCE_RANGE;
				for (var l = 0, ll = quantityValue.length; l < ll; l++) {
					var numRes = quantityValue[l].NUMBER;
					m_precision = quantityValue[l].PRECISION;
					if (!isNaN(numRes)) {
						m_val = MP_Util.Measurement.SetPrecision(numRes, m_precision);
						m_rawValue = numRes;
					}
					if (quantityValue[l].MODIFIER_CD != '') { //eslint-disable-line eqeqeq
						var modCode = MP_Util.GetValueFromArray(quantityValue[l].MODIFIER_CD, codeArray);
						if (modCode) {
							m_val = modCode.display + m_val;
							m_hasModifier = true;
						}
					}
					if (quantityValue[l].UNIT_CD != '') { //eslint-disable-line eqeqeq
						m_uom = MP_Util.GetValueFromArray(quantityValue[l].UNIT_CD, codeArray);
					}
					for (var m = 0, ml = referenceRange.length; m < ml; m++) {
						m_refRange = new MP_Core.ReferenceRangeResult();
						m_refRange.init(referenceRange[m], codeArray);
					}
				}
			};

			this.getValue = function() {
				return m_val;
			};
			this.getRawValue = function() {
				return m_rawValue;
			};
			this.getUOM = function() {
				return m_uom;
			};
			this.getRefRange = function() {
				return m_refRange;
			};
			this.getPrecision = function() {
				return m_precision;
			};
			this.toString = function() {
				if (m_uom) {
					return (m_val + ' ' + m_uom.display);
				}
				return m_val;
			};
			this.hasModifier = function() {
				return m_hasModifier;
			};
		},
		//measurement.init(meas.EVENT_ID, meas.PERSON_ID, meas.ENCNTR_ID, eventCode, dateTime, MP_Util.Measurement.GetObject(meas.MEASUREMENTS[k], codeArray));
		Measurement: function() {
			var m_eventId = 0.0;
			var m_personId = 0.0;
			var m_encntrId = 0.0;
			var m_eventCode = null;
			var m_dateTime = null;
			var m_updateDateTime = null;
			var m_result = null;
			var m_normalcy = null;
			var m_status = null;
			var m_comment = '';
			var m_comment_ind = 0;

			this.init = function(eventId, personId, encntrId, eventCode, dateTime, resultObj, updateDateTime) {
				m_eventId = eventId;
				m_personId = personId;
				m_encntrId = encntrId;
				m_eventCode = eventCode;
				m_dateTime = dateTime;
				m_result = resultObj;
				m_updateDateTime = updateDateTime;
			};

			this.initFromRec = function(measObj, codeArray) {
				var effectiveDateTime = new Date();
				var updateDateTime = new Date();
				m_eventId = measObj.EVENT_ID;
				m_personId = measObj.PATIENT_ID;
				m_encntrId = measObj.ENCOUNTER_ID;
				m_eventCode = MP_Util.GetValueFromArray(measObj.EVENT_CD, codeArray);
				effectiveDateTime.setISO8601(measObj.EFFECTIVE_DATE);
				m_dateTime = effectiveDateTime;
				m_result = MP_Util.Measurement.GetObject(measObj, codeArray);
				updateDateTime.setISO8601(measObj.UPDATE_DATE);
				m_updateDateTime = updateDateTime;
				m_normalcy = MP_Util.GetValueFromArray(measObj.NORMALCY_CD, codeArray);
				m_status = MP_Util.GetValueFromArray(measObj.STATUS_CD, codeArray);
				m_comment = measObj.COMMENT;
				m_comment_ind = measObj.HAS_COMMENTS_IND;
			};

			this.getEventId = function() {
				return m_eventId;
			};
			this.getPersonId = function() {
				return m_personId;
			};
			this.getEncntrId = function() {
				return m_encntrId;
			};
			this.getEventCode = function() {
				return m_eventCode;
			};
			this.getDateTime = function() {
				return m_dateTime;
			};
			this.getUpdateDateTime = function() {
				return m_updateDateTime;
			};
			this.getResult = function() {
				return m_result;
			};
			this.setNormalcy = function(value) {
				m_normalcy = value;
			};
			this.getNormalcy = function() {
				return m_normalcy;
			};
			this.setStatus = function(value) {
				m_status = value;
			};
			this.getStatus = function() {
				return m_status;
			};
			this.isModified = function() {
				if (m_status) {
					var mean = m_status.meaning;
					if (mean === 'MODIFIED' || mean === 'ALTERED') {
						return true;
					}
				}
				return false;
			};
			this.getComment = function() {
				return m_comment;
			};
			this.getCommentsIndicator = function(){
				return m_comment_ind;
			};
		},
		MenuItem: function() {
			var m_name = '';
			var m_desc = '';
			var m_id = 0.0;
			var m_meaning;
			var m_valSequence = 0;
			//This is used as the primary grouping value for IView bands
			var m_valTypeFlag = 0;
			//This is used to determine which is the band, section, or item

			this.setDescription = function(value) {
				m_desc = value;
			};
			this.getDescription = function() {
				return m_desc;
			};
			this.setName = function(value) {
				m_name = value;
			};
			this.getName = function() {
				return m_name;
			};
			this.setId = function(value) {
				m_id = value;
			};
			this.getId = function() {
				return m_id;
			};
			this.setMeaning = function(value) {
				m_meaning = value;
			};
			this.getMeaning = function() {
				return m_meaning;
			};
			this.setValSequence = function(value) {
				m_valSequence = value;
			};
			this.getValSequence = function() {
				return m_valSequence;
			};
			this.setValTypeFlag = function(value) {
				m_valTypeFlag = value;
			};
			this.getValTypeFlag = function() {
				return m_valTypeFlag;
			};
		},
		CriterionFilters: function(criterion) {
			var m_criterion = criterion;
			var m_evalAr = [];

			this.addFilter = function(type, value) {
				m_evalAr.push(new MP_Core.MapObject(type, value));
			};
			this.checkFilters = function() {
				var patInfo = m_criterion.getPatientInfo();
				for (var x = m_evalAr.length; x--; ) {
					var filter = m_evalAr[x];
					var dob = null;
					switch (filter.name) {
						case MP_Core.CriterionFilters.SEX_MEANING:
							var sex = patInfo.getSex();
							if (sex) {
								if (filter.value == sex.meaning) { //eslint-disable-line eqeqeq
									continue;
								}
							}
							return false;
						case MP_Core.CriterionFilters.DOB_OLDER_THAN:
							dob = patInfo.getDOB();
							if (dob) {
								if (dob <= filter.value) {
									continue;
								}
							}
							return false;
						case MP_Core.CriterionFilters.DOB_YOUNGER_THAN:
							dob = patInfo.getDOB();
							if (dob) {
								if (dob >= filter.value) {
									continue;
								}
							}
							return false;
						default:
							alert('Unhandled criterion filter');
							return false;
					}
				}
				return true;
			};
		},
		CreateSimpleError: function(component, sMessage) {
			var errMsg = [];
			var i18nCore = i18n.discernabu;
			var countText = (component.isLineNumberIncluded() ? '(0)' : '');
			errMsg.push('<b>', i18nCore.DISCERN_ERROR, '</b><br /><ul><li>', sMessage, '</li></ul>');
			component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join('')), countText);
			//After the component has rendered call the postProcessing function to perform any additional actions
			component.postProcessing();
		},
		/**
		 * Generates the HTMl for informational messages that will be displayed to the user.  The msgType parameter will be used to determine
		 * the correct styling for the message applied. If the message type cannot be mapped to a supported message or the field is left blank, the
		 * default styling will be applied.  If custom styling should be applied for the message the customClass parameter can be used to override
		 * any of the default properties of the standard messaging styles.
		 * @param {string} msgType This must be a string that represents the type of message being created.  The currently supported message types are error,
		 * warning, information and busy.  If your message type does not match one of those listed, the default styling will be applied.  This parameter can also be
		 * left blank to utilize the default styling.
		 * @param {string} msgText This will be the first line of the message and will potentially be styled based on the message type being used.
		 * @param {string} msdDetails This will be the text immediately following the msgText line.  This text will not be stylized.
		 * @param {string} customClass This is the optional custom class that can be added to the message container which will allow for custom styling of the message
		 * information.
		 * @return {string} The HTML markup of the information message to display to the user.
		 */
		 generateUserMessageHTML: function(msgType, msgText, msgDetails, customClass) {
			var msgHTML = '';

			//check the messageType to make sure it is a string
			if(typeof msgType !== 'string'){
				logger.logError('generateUserMessageHTML only accepts msgType parameters of string');
				return '';
			}

			//Determine which HTML string to use based on the type
			switch(msgType.toLowerCase()) {
				case 'error':
					//generate the error HTML
					msgHTML = '<div class=\'error-container ' + (customClass || '') + '\'><span class=\'error-text message-info-text\'>' + (msgText || '') + '</span>' + (msgDetails || '') + '</div>';
					break;
				case 'warning':
					//generate the warning HTML
					msgHTML = '<div class=\'warning-container ' + (customClass || '') + '\'><span class=\'message-info-text\'>' + (msgText || '') + '</span>' + (msgDetails || '') + '</div>';
					break;
				case 'information':
					//generate the information HTML
					msgHTML = '<div class=\'information-container ' + (customClass || '') + '\'><span class=\'message-info-text\'>' + (msgText || '') + '</span>' + (msgDetails || '') + '</div>';
					break;
				case 'busy':
					//generate the busy HTML
					msgHTML = '<div class=\'busy-container ' + (customClass || '') + '\'><span class=\'message-info-text\'>' + (msgText || '') + '</span>' + (msgDetails || '') + '</div>';
					break;
				default:
					msgHTML = '<div class=\'default-container ' + (customClass || '') + '\'><span class=\'message-info-text\'>' + (msgText || '') + '</span>' + (msgDetails || '') + '</div>';
					break;
			}
			return msgHTML;
		}
	};
}();
//Constants for CriterionFilter items
MP_Core.CriterionFilters.SEX_MEANING = 1;
MP_Core.CriterionFilters.DOB_OLDER_THAN = 2;
MP_Core.CriterionFilters.DOB_YOUNGER_THAN = 3;

MP_Core.AppUserPreferenceManager = function() {
	var m_criterion = null;
	var m_prefIdent = '';
	var m_jsonObject = null;

	return {
		/**
		 * Allows for the initialization of the manager to store what criterion and preference identifier to
		 * utilize for retrieval of preferences
		 * @param {Object} criterion
		 * @param {Object} preferenceIdentifier
		 */
		Initialize: function(criterion, preferenceIdentifier) {
			m_criterion = criterion;
			m_prefIdent = preferenceIdentifier;
			m_jsonObject = null;
		},
		SetPreferences: function(prefString) {
			var jsonEval = JSON.parse(prefString);
			m_jsonObject = jsonEval;
		},
		LoadPreferences: function() {
			if (!m_criterion) {
				logger.logError('Validation Failed: the AppUserPreferenceManager must be initialized prior to usage.');
				return;
			}
			//If preferences have already been loaded just return
			if (m_jsonObject) {
				return;
			}

			var prefRequest = new ScriptRequest();
			prefRequest.setProgramName('MP_GET_USER_PREFS');
			prefRequest.setParameterArray(['^mine^', m_criterion.provider_id + '.0', '^' + m_prefIdent + '^']);
			prefRequest.setAsyncIndicator(false);
			prefRequest.setResponseHandler(function(scriptReply){
				var status = scriptReply.getStatus();
				var prefsResponse = scriptReply.getResponse();
				if(status === 'Z'){
							return;
						}
				else if(status === 'S'){
					m_jsonObject = JSON.parse(prefsResponse.PREF_STRING);
				}
				else {
					logger.logError(scriptReply.getError());
				}
			});
			prefRequest.performRequest();
		},
		/**
		 * GetPreferences will return the users preferences for the application currently logged into.
		 */
		GetPreferences: function() {
			if (!m_criterion) {
				return null;
			}
			if (!m_jsonObject) {
				this.LoadPreferences();
			}

			return m_jsonObject;
		},
		SavePreferences: function(reload) {
			var body = document.body;
			var groups = Util.Style.g('col-group', body, 'div');
			var grpId = 0;
			var colId = 0;
			var rowId = 0;
			var compId = 0;

			var jsonObject = {};
			jsonObject.user_prefs = {};
			var userPrefs = jsonObject.user_prefs;
			userPrefs.page_prefs = {};
			var pagePrefs = userPrefs.page_prefs;
			pagePrefs.components = [];
			var components = pagePrefs.components;

			//alert("groups.length: " + groups.length)
			for (var x = 0, xl = groups.length; x < xl; x++) {
				//TODO: be aware that when the organizer level component can be moved, this x+1 will need to be modified
				grpId = x + 1;
				//get liquid layout
				var liqLay = Util.Style.g('col-outer1', groups[x], 'div');
				if (liqLay.length > 0) {
					//get each child column
					var cols = Util.gcs(liqLay[0]);
					for (var y = 0, yl = cols.length; y < yl; y++) {
						colId = y + 1;
						var rows = Util.gcs(cols[y]);
						for (var z = 0, zl = rows.length; z < zl; z++) {
							var component = {};
							rowId = z + 1;
							compId = jQuery(rows[z]).attr('id');
							var compObj = MP_Util.GetCompObjByStyleId(compId);
							component.id = compObj.getComponentId();
							component.group_seq = grpId;
							component.col_seq = colId;
							component.row_seq = rowId;
							component.preferencesObj = compObj.getPreferencesObj();
							//Since we are updating the toggle status for all components we will need to make sure all required
							//components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
							//Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
							//and not allow the user to toggle that component even though they should be able to.
							component.toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();
							component.grouperFilterLabel = compObj.getGrouperFilterLabel();
							component.grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
							component.grouperFilterCriteria = compObj.getGrouperFilterCriteria();
							component.grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
							component.selectedTimeFrame = compObj.getSelectedTimeFrame();
							component.selectedDataGroup = compObj.getSelectedDataGroup();
							if (jQuery(rows[z]).hasClass('closed')) {
								component.expanded = false;
							}
							else {
								component.expanded = true;
							}
							components.push(component);
						}
					}
				}
			}
			WritePreferences(jsonObject);

			if (reload !== undefined && reload === false) {
				return;
			}

			CERN_Platform.refreshMPage();
		},
		ClearCompPreferences: function(componentId) {
			var compObj = MP_Util.GetCompObjById(componentId);
			var prefObj = m_jsonObject;
			var filterArr = null;

			if (prefObj != null) { //eslint-disable-line eqeqeq
				var strEval = JSON.parse(JSON.stringify(prefObj));
				var strObj = strEval.user_prefs.page_prefs.components;
				for (var x = strObj.length; x--; ) {
					if (strEval && strObj[x].id === componentId) {
						strObj[x].grouperFilterLabel = '';
						strObj[x].grouperFilterCatLabel = '';
						strObj[x].grouperFilterCriteria = filterArr;
						strObj[x].grouperFilterCatalogCodes = filterArr;

						strObj[x].selectedTimeFrame = '';
						strObj[x].selectedDataGroup = '';
					}
				}
				compObj.setLookbackUnits(compObj.getBrLookbackUnits());
				compObj.setLookbackUnitTypeFlag(compObj.getBrLookbackUnitTypeFlag());
				compObj.setGrouperFilterLabel('');
				compObj.setGrouperFilterCatLabel('');
				compObj.setGrouperFilterCriteria(filterArr);
				compObj.setGrouperFilterCatalogCodes(filterArr);
				compObj.setSelectedTimeFrame('');
				compObj.setSelectedDataGroup('');
				compObj.setPreferencesObj(null);
				m_jsonObject = strEval;
				WritePreferences(m_jsonObject);

				//Use the component's render strategy to update the view after clearing settings
				var renderStrategy = compObj.getRenderStrategy();
				if(renderStrategy) {
					var uniqueComponentId = renderStrategy.getComponentId();
					var componentLookbackMenu = $('#lookbackContainer' + uniqueComponentId);
					if(componentLookbackMenu.length) {
						componentLookbackMenu.replaceWith(renderStrategy.createComponentLookback());
					}

					var componentFilterMenu = $('#filterDropDownMenu' + uniqueComponentId);
					if(componentFilterMenu.length) {
						componentFilterMenu.replaceWith(renderStrategy.createComponentFilter());
					}
				}

				$(compObj.getSectionContentNode()).empty();
				compObj.startComponentDataRetrieval();
			}
		},
		UpdatePrefsIdentifier: function(prefIdentifier) {
			if (prefIdentifier && typeof prefIdentifier === 'string') {
				m_prefIdent = prefIdentifier;
			}
		},
		//Updates the component preferences from the components array passed into the function
		UpdateAllCompPreferences: function(componentArr, changePos, saveAsync) {
			var compId = 0;
			var compPrefs = null;
			var compPrefsCnt = 0;
			var compPrefsMap = {};
			var component = null;
			var componentDiv = null;
			var columnDiv = null;

			var namespace = '';
			var newPrefsInd = false;
			var prefObj = null;
			var prefIndx = 0;
			var tempObj = {};
			var x = 0;

			//If saveAsync is anything other then true set it to false
			if(!saveAsync){
				saveAsync = false;
			}

			//Check the componentArr and make sure is is populated
			if (!componentArr || !componentArr.length) {
				return;
			}

			//Create the prefs object if it doesnt already exist
			prefObj = m_jsonObject || {
				user_prefs: {
					page_prefs: {
						components: []
					}
				}
			};

			//Check to make sure the structure exists so we can populate it
			prefObj.user_prefs = prefObj.user_prefs || {
				page_prefs: {
					components: []
				}
			};

			prefObj.user_prefs.page_prefs = prefObj.user_prefs.page_prefs || {
				components: []
			};

			prefObj.user_prefs.page_prefs.components = prefObj.user_prefs.page_prefs.components || [];
			compPrefs = prefObj.user_prefs.page_prefs.components;

			//Create a component map so we do not have to loop through the array for each component
			compPrefsCnt = compPrefs.length;
			for ( x = compPrefsCnt; x--; ) {
				compPrefsMap[compPrefs[x].id] = x;
			}

			//Loop through all of the components and update their preferences in the preferences object.
			compPrefsCnt = componentArr.length;
			for ( x = compPrefsCnt; x--; ) {
				component = componentArr[x];
				//Check to see if there is an existing preferences object
				if ( typeof compPrefsMap[component.getComponentId()] !== 'undefined') {
					//Update exiting component preferences
					prefIndx = compPrefsMap[component.getComponentId()];
					tempObj = compPrefs[prefIndx];
					newPrefsInd = false;
				}
				else {
					tempObj = {};
					newPrefsInd = true;
				}
				//Save the components basic settings
				tempObj.id = component.getComponentId();
				tempObj.group_seq = component.getPageGroupSequence();
				tempObj.col_seq = component.getColumn();
				tempObj.row_seq = component.getSequence();
				tempObj.preferencesObj = component.getPreferencesObj();
				//Since we are updating the toggle status for all components we will need to make sure all required
				//components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
				//Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
				//and not allow the user to toggle that component even though they should be able to.
				tempObj.toggleStatus = (component.getToggleStatus() === 2) ? 1 : component.getToggleStatus();
				tempObj.expanded = component.isExpanded();
				//Update the infoButton information
				tempObj.IsInfoButtonEnabled = component.isInfoButtonEnabled();

				if (component.getGrouperFilterLabel()) {
					tempObj.grouperFilterLabel = component.getGrouperFilterLabel();
				}
				if (component.getGrouperFilterCriteria()) {
					tempObj.grouperFilterCriteria = component.getGrouperFilterCriteria();
				}
				if (component.getGrouperFilterCatLabel()) {
					tempObj.grouperFilterCatLabel = component.getGrouperFilterCatLabel();
				}
				if (component.getGrouperFilterCatalogCodes()) {
					tempObj.grouperFilterCatalogCodes = component.getGrouperFilterCatalogCodes();
				}

				if (component.getSelectedTimeFrame()) {
					tempObj.selectedTimeFrame = component.getSelectedTimeFrame();
				}
				if (component.getSelectedDataGroup()) {
					tempObj.selectedDataGroup = component.getSelectedDataGroup();
				}

				//Push the new preferences object into the array
				if (newPrefsInd) {
					compPrefs.push(tempObj);
					//Update the mapping with the new element info
					compPrefsMap[tempObj.id] = compPrefs.length - 1;
				}
			}

			//If the changePos flag has been set we will need to update the positions of all components without blowing away existing
			// preferences.
			if (changePos) {
				for ( x = compPrefsCnt; x--; ) {
					component = componentArr[x];
					namespace = component.getStyles().getNameSpace();
					compId = component.getComponentId();
					//Get component div, if the component is added to contextual view get their ghosted version.
					if(component.isAddedToContextualView()){
						componentDiv = $('#' + namespace + compId + 'PlaceholderView');
					}else{
						componentDiv = $('#' + namespace + compId);
					}
					if (componentDiv.length) {
						//Get the preferences object
						prefIndx = compPrefsMap[component.getComponentId()];
						tempObj = compPrefs[prefIndx];
						//Get the parent of that component container and find out which index it is located at and use that as the sequence.
						columnDiv = componentDiv.parent();
						tempObj.col_seq = columnDiv.index() + 1;
						tempObj.row_seq = componentDiv.index();
						//Save the new column and sequence back into the component
						component.setColumn(tempObj.col_seq);
						component.setSequence(tempObj.row_seq);
					}
				}
			}

			//Save the preferences back to the preferences object.
			m_jsonObject = prefObj;
			WritePreferences(m_jsonObject, saveAsync);
		},
		UpdateSingleCompPreferences: function(componentObject, saveAsync){
			MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences([componentObject],false,saveAsync);
		},
		SaveCompPreferences: function(componentId, theme, expCol, changePos, infoButton) {
			var compObj = MP_Util.GetCompObjById(componentId);
			var prefObj = m_jsonObject;
			var noMatch = true;
			if (prefObj != null && !changePos) { //eslint-disable-line eqeqeq
				var strEval = JSON.parse(JSON.stringify(prefObj));
				var strObj = strEval.user_prefs.page_prefs.components;

				for (var x = strObj.length; x--; ) {
					if (strEval && strObj[x].id === componentId) {
						noMatch = false;
						if (theme) {
							strObj[x].compThemeColor = theme;
						}
						if (expCol) {
							if (expCol == '1') { //eslint-disable-line eqeqeq
								strObj[x].expanded = true;
							}
							else {
								strObj[x].expanded = false;
							}
						}

						if (infoButton) {
							if(infoButton == '1') {//eslint-disable-line eqeqeq
								strObj[x].IsInfoButtonEnabled = 1;
							}
							else {
								strObj[x].IsInfoButtonEnabled = 0;
							}
						}

						if (compObj.getGrouperFilterLabel()) {
							strObj[x].grouperFilterLabel = compObj.getGrouperFilterLabel();
						}
						if (compObj.getGrouperFilterCatLabel()) {
							strObj[x].grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
						}
						if (compObj.getGrouperFilterCriteria()) {
							strObj[x].grouperFilterCriteria = compObj.getGrouperFilterCriteria();
						}
						if (compObj.getGrouperFilterCatalogCodes() || compObj.getGrouperFilterCatalogCodes() === null) {
							strObj[x].grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
						}
						else {
							strObj[x].grouperFilterCatalogCodes = [];
						}

						if (compObj.getSelectedTimeFrame()) {
							strObj[x].selectedTimeFrame = compObj.getSelectedTimeFrame();
						}
						if (compObj.getSelectedDataGroup()) {
							strObj[x].selectedDataGroup = compObj.getSelectedDataGroup();
						}
						//Save the components toggle status and the column and sequence information
						//Since we are updating the toggle status for all components we will need to make sure all required
						//components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
						//Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
						//and not allow the user to toggle that component even though they should be able to.
						strObj[x].toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();
						strObj[x].col_seq = compObj.getColumn();
						strObj[x].row_seq = compObj.getSequence();
						strObj[x].preferencesObj = compObj.getPreferencesObj();
					}
				}

				if (noMatch) {//single comp change but comp doesn't have user prefs
					var tempObj = {};
					tempObj.id = componentId;
					tempObj.group_seq = compObj.getPageGroupSequence();
					tempObj.col_seq = compObj.getColumn();
					tempObj.row_seq = compObj.getSequence();
					tempObj.preferencesObj = compObj.getPreferencesObj();
					tempObj.compThemeColor = theme;

					if (compObj.getGrouperFilterLabel()) {
						tempObj.grouperFilterLabel = compObj.getGrouperFilterLabel();
					}
					if (compObj.getGrouperFilterCriteria()) {
						tempObj.grouperFilterCriteria = compObj.getGrouperFilterCriteria();
					}
					if (compObj.getGrouperFilterCatLabel()) {
						tempObj.grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
					}
					if (compObj.getGrouperFilterCatalogCodes()) {
						tempObj.grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
					}

					if (compObj.getSelectedTimeFrame()) {
						tempObj.selectedTimeFrame = compObj.getSelectedTimeFrame();
					}
					if (compObj.getSelectedDataGroup()) {
						tempObj.selectedDataGroup = compObj.getSelectedDataGroup();
					}
					//Save the components toggle status
					//Since we are updating the toggle status for all components we will need to make sure all required
					//components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
					//Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
					//and not allow the user to toggle that component even though they should be able to.
					tempObj.toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();

					tempObj.expanded = compObj.isExpanded();
					strObj.push(tempObj);
				}
				m_jsonObject = strEval;
				WritePreferences(m_jsonObject);
			}
			else {
				var body = document.body;
				var groups = Util.Style.g('col-group', body, 'div');
				var grpId = 0;
				var colId = 0;
				var rowId = 0;
				var compId = 0;

				var jsonObject = {};
				jsonObject.user_prefs = {};
				var userPrefs = jsonObject.user_prefs;
				userPrefs.page_prefs = {};
				var pagePrefs = userPrefs.page_prefs;
				pagePrefs.components = [];
				var components = pagePrefs.components;

				for (var x = 0, xl = groups.length; x < xl; x++) {
					//TODO: be aware that when the organizer level component can be moved, this x+1 will need to be modified
					grpId = x + 1;
					//get liquid layout
					var liqLay = Util.Style.g('col-outer1', groups[x], 'div');
					if (liqLay.length > 0) {
						//get each child column
						var cols = Util.gcs(liqLay[0]);
						for (var y = 0, yl = cols.length; y < yl; y++) {
							colId = y + 1;
							var rows = Util.gcs(cols[y]);
							for (var z = 0, zl = rows.length; z < zl; z++) {
								var component = {};
								rowId = z + 1;
								compId = jQuery(rows[z]).attr('id');
								compObj = MP_Util.GetCompObjByStyleId(compId);
								//Ensure that the component object was successfully retrieved
								if(!compObj) {
									continue;
								}
								component.id = compObj.getComponentId();

								if (compObj.getColumn() !== 99) {
									component.group_seq = 1;
									component.col_seq = colId;
									component.row_seq = rowId;
								}
								else {
									component.group_seq = 0;
									component.col_seq = 99;
									component.row_seq = rowId;
								}
								if (compObj.getCompColor()) {
									component.compThemeColor = compObj.getCompColor();
								}
								//Save the components toggle status
								//Since we are updating the toggle status for all components we will need to make sure all required
								//components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
								//Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
								//and not allow the user to toggle that component even though they should be able to.
								component.toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();
								compObj.setColumn(component.col_seq);
								compObj.setSequence(component.row_seq);
								//added preferences to component
								component.preferencesObj = compObj.getPreferencesObj();
								component.grouperFilterLabel = compObj.getGrouperFilterLabel();
								component.grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
								component.grouperFilterCriteria = compObj.getGrouperFilterCriteria();

								component.grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();

								component.selectedTimeFrame = compObj.getSelectedTimeFrame();
								component.selectedDataGroup = compObj.getSelectedDataGroup();
								if (jQuery(rows[z]).hasClass('closed')) {
									component.expanded = false;
								}
								else {
									component.expanded = true;
								}
								if(compObj.hasInfoButton()) {
									if(infoButton) {
										component.IsInfoButtonEnabled = 1;
									}
									else {
										component.IsInfoButtonEnabled = 0;
									}
								}
								components.push(component);
							}
						}
					}
				}
				// get the selected components' settings from above and compare with prefObj by parsing it.
				// matched components get updated and other components ignored.
				// copy the updated new prefs to m_jsonObject
				// save prefs JSON using WritePreferences(m_jsonObject)

				if(prefObj){	//check for preference object; if found go for update; else don'nt update
					strObj = prefObj.user_prefs.page_prefs.components;
					for (x = strObj.length; x--;) {
						for (y = components.length; y--;) {
							if (strObj[x].id === components[y].id) {
								strObj[x] = components[y]; //update only matched component's preferences
								break;
							}
						}
					}
					m_jsonObject = prefObj;
					WritePreferences(m_jsonObject); //write new prefs to database.
				}
				else {
					 WritePreferences(jsonObject);
					 m_jsonObject = jsonObject; //update the m_jsonObject(global).
				}
			}
		},
		ClearPreferences: function() {
			WritePreferences(null);
			CERN_Platform.refreshMPage();
		},
		/**
		 * Returns the json object associated to the primary div id of the component.  It is assumed LoadPreferences has been called prior to
		 * execution
		 * @param {Object} id
		 */
		GetComponentById: function(id) {
			if (m_jsonObject) {
				var components = m_jsonObject.user_prefs.page_prefs.components;
				if(!components){
					//preferences have been passed by the driver script and loadPreferences was avoided, return null to avoid an error
					return null;
				}
				for (var x = components.length; x--; ) {
					var component = components[x];
					if (component.id == id) { //eslint-disable-line eqeqeq
						return component;
					}
				}
			}
			return null;
		}
	};

	function WritePreferences(jsonObject, saveAsync) {
		var prefs = (jsonObject != null) ? JSON.stringify(jsonObject) : ''; //eslint-disable-line eqeqeq

		//Create the script request and perform it
		var prefRequest = new ScriptRequest();
		prefRequest.setProgramName('MP_MAINTAIN_USER_PREFS');
		prefRequest.setParameterArray(['^mine^', m_criterion.provider_id + '.0', '^' + m_prefIdent + '^', '~' + prefs + '~']);
		prefRequest.setAsyncIndicator(saveAsync || false);
		prefRequest.setResponseHandler(function(scriptReply){
			var status = scriptReply.getStatus();

			if(status === 'Z'){
					m_jsonObject = null;
				}
			else if(status === 'S'){
					m_jsonObject = jsonObject;
					}
				else {
				logger.logError(scriptReply.getError());
			}
		});
		prefRequest.performRequest();
	}
}();

/**
 * @namespace
 */
var MP_Util = function() {
	var m_df = null;
	var m_nf = null;
	var m_codeSets = [];
	return {
		addComponentsToGlobalStorage: function(components) {
			//If you try to add nothing, just return
			if(!components || !components.length) {
				return;
			}
			//If for some reason the global component storage is null, new it up
			if(CERN_MPageComponents === null) {
				CERN_MPageComponents = [];
			}
			//Store this view's components in the global component list
			for(var x = 0, xl = components.length; x < xl; x++) {
				if(components[x]) {
					CERN_MPageComponents.push(components[x]);
				}
			}
		},
		GetComponentArray: function(components) {
			var grpAr = [];
			var colAr = [];
			var rowAr = [];
			var curCol = -1;
			var curGrp = -1;

			//first layout the group/columns/rows of components
			if (components != null) { //eslint-disable-line eqeqeq
				components.sort(SortMPageComponents);

				for (var x = 0, xl = components.length; x < xl; x++) {
					var component = components[x];

					if (component.isDisplayable()) {//based on filter logic, only display if criteria is met
						var compGrp = component.getPageGroupSequence();
						var compCol = component.getColumn();

						if (compGrp != curGrp) { //eslint-disable-line eqeqeq
							curCol = -1;
							colAr = [];
							grpAr.push(colAr);
							curGrp = compGrp;
						}

						if (compCol != curCol) { //eslint-disable-line eqeqeq
							rowAr = [];
							colAr.push(rowAr);
							curCol = compCol;
						}
						rowAr.push(component);
					}
				}
			}
			return grpAr;
		},
		/**
		 * Helper utility to retrieve the <code>Criterion</code> Object generated from the provide JSON
		 * @param js_criterion  The JSON associated to the criterion data that is to be loaded
		 * @param static_content  The <code>String</code> location in which the static content resides
		 */
		GetCriterion: function(js_criterion, static_content) {
			logger.logDebug('Criterion: ' + JSON.stringify(js_criterion));
			var jsCrit = js_criterion.CRITERION;
			var criterion = new MP_Core.Criterion(jsCrit, static_content);
			var codeArray = MP_Util.LoadCodeListJSON(jsCrit.CODES);
			var jsPatInfo = jsCrit.PERSON_INFO;
			var patInfo = new MP_Core.PatientInformation();
			patInfo.setName(jsPatInfo.PERSON_NAME);
			patInfo.setSex(MP_Util.GetValueFromArray(jsPatInfo.SEX_CD, codeArray));
			if (jsPatInfo.DOB != '') { //eslint-disable-line eqeqeq
				var dt = new Date();
				dt.setISO8601(jsPatInfo.DOB);
				patInfo.setDOB(dt);
			}
			criterion.setPatientInfo(patInfo);
			return criterion;
		},
		/**
		 * Calculates the within time from the provide date and time.
		 * @param dateTime  The <code>Date</code> Object in which to calculate the within time
		 * @return <code>String</code> representing the time that has passed from the provided date and time
		 */
		CalcWithinTime: function(dateTime) {
			return (GetDateDiffString(dateTime, null, null, true));
		},
		/**
		 * Calculates the age of a patient from a given point in time.  If the point in time is not provided, the current date/time is
		 * utilized
		 * @param birthDt  The <code>Date</code> Object in which to calculate the age of the patient
		 * @param fromDate  The <code>Date</code> Object in which to calculate the age of the patient from.  This is useful in
		 * cases
		 * where the patient is deceased and the date utilized is the deceased date.
		 * @return <code>String</code> representing the age of the patient
		 */
		CalcAge: function(birthDt, fromDate) {
			//If from Date is null (not passed in) then set to current Date
			fromDate = (fromDate) ? fromDate : new Date();
			return (GetDateDiffString(birthDt, fromDate, 1, false));
		},
		/**
		 * Display the date and time based on the configuration of the component
		 * @param component  The component in which holds the configuration for the date formatting
		 * @param date  The date in which to properly format
		 * @return <code>String</code> representing the date and time of the date provided
		 */
		DisplayDateByOption: function(component, date) {
			var df = MP_Util.GetDateFormatter();
			switch (component.getDateFormat()) {
				case 1:
					return (df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR));
				case 2:
					return (df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR));
				case 3:
					return (MP_Util.CalcWithinTime(date));
				case 4:
					//Display No Date.  Additional logic will need to be applied to hide column.
					return ('&nbsp');
				default:
					return df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
			}
		},
		LaunchMenu: function(menuId, componentId) {
			var menu = _g(menuId);
			MP_Util.closeMenuInit(menu, componentId);
			if (menu != null) {  //eslint-disable-line eqeqeq
				if (Util.Style.ccss(menu, 'menu-hide')) {
					_g(componentId).style.zIndex = 2;
					Util.Style.rcss(menu, 'menu-hide');
				}
				else {
					_g(componentId).style.zIndex = 1;
					Util.Style.acss(menu, 'menu-hide');
				}
			}
		},
		LaunchCompFilterSelection: function(compId, eventSetIndex, applyFilterInd) {
			var component = MP_Util.GetCompObjById(compId);
			var i18nCore = i18n.discernabu;
			var style = component.getStyles();
			var ns = style.getNameSpace();
			var mnuDisplay;
			if(eventSetIndex === -1) {
			 mnuDisplay = i18nCore.FACILITY_DEFINED_VIEW;
			}
			else {
				if (ns === 'ohx' || ns === 'ohx2') {
					 mnuDisplay = component.getGrouperCatLabel(eventSetIndex).toString();
				}
				else {
					mnuDisplay = component.getGrouperLabel(eventSetIndex).toString();
				}
			}
			var dispVar = i18nCore.FACILITY_DEFINED_VIEW;
			var styleId = style.getId();
			var loc = component.getCriterion().static_content;
			var mnuId = styleId + 'TypeMenu';
			var z = 0;

			if (ns === 'ohx' || ns === 'ohx2') {
				var catCodeList = component.getGrouperCatalogCodes(eventSetIndex);
			}
			else {
				var eventSetList = component.getGrouperCriteria(eventSetIndex);
			}

			//Set component prefs variables with filter settings
			if (ns === 'ohx' || ns === 'ohx2') {
				component.setGrouperFilterCatLabel(mnuDisplay);
			}
			else {
				component.setGrouperFilterLabel(mnuDisplay);
			}
			if (mnuDisplay !== dispVar) {

				if (ns === 'ohx' || ns === 'ohx2') {
					component.setGrouperFilterCatalogCodes(catCodeList);
				}
				else {
					component.setGrouperFilterCriteria(eventSetList);
				}

			}
			else {
				component.setGrouperFilterCriteria(null);
				component.setGrouperFilterCatalogCodes(null);
			}

			//Find Filter Applied msg span and replace it only if the Facility defined view is not selected
			var filterAppliedSpan = _g('cf' + compId + 'msg');
			if (filterAppliedSpan) {
				// Remove the old span element
				Util.de(filterAppliedSpan);
			}
			if (mnuDisplay !== dispVar) {
				var newFilterAppliedSpan = Util.ce('span');
				var filterAppliedArr = ['<span id=\'cf', compId, 'msg\' class=\'filter-applied-msg\' title=\'', mnuDisplay, '\'>', i18nCore.FILTER_APPLIED, '</span>'];
				newFilterAppliedSpan.innerHTML = filterAppliedArr.join('');
				var lbDropDownDiv = _g('lbMnuDisplay' + compId);
				Util.ia(newFilterAppliedSpan, lbDropDownDiv);
			}
			else {
				var newFilterAppliedSpan = Util.ce('span');
				var filterAppliedArr = ['<span id=\'cf', compId, 'msg\' class=\'filter-applied-msg\' title=\'\'></span>'];
				newFilterAppliedSpan.innerHTML = filterAppliedArr.join('');
				var lbDropDownDiv = _g('lbMnuDisplay' + compId);
				Util.ia(newFilterAppliedSpan, lbDropDownDiv);
			}

			//Find the content div
			var contentDiv = _g('Accordion' + compId + 'ContentDiv');
			contentDiv.innerHTML = '';

			//Create the new content div innerHTML with the select list
			var contentDivArr = [];
			contentDivArr.push('<div id=\'cf', mnuId, '\' class=\'acc-mnu\'>');
			contentDivArr.push('<span id=\'cflabel', compId, '\' onclick=\'MP_Util.LaunchMenu("', mnuId, '", "', styleId, '");\'>', i18nCore.FILTER_LABEL, mnuDisplay, '<a id=\'compFilterDrop', compId, '\'><img src=\'', loc, '/images/3943_16.gif\'></a></span>');
			contentDivArr.push('<div class=\'cvClassFilterSpan lb-mnu-selectWindow lb-menu2 menu-hide\' id=\'', mnuId, '\'><div class=\'acc-mnu-contentbox\'>');
			contentDivArr.push('<div><span id=\'cf', styleId, '\' class=\'cf-mnu\' onclick=\'MP_Util.LaunchCompFilterSelection(', compId, ',-1,1);\'>', i18nCore.FACILITY_DEFINED_VIEW, '</span></div>');

			var groupLen = component.m_grouper_arr.length;
			for ( z = 0; z < groupLen; z++) {
				if (component.getGrouperLabel(z)) {
					var esIndex = z;
					contentDivArr.push('<div><span id=\'cf', styleId, z, '\' class=\'cf-mnu\' onclick=\'MP_Util.LaunchCompFilterSelection(', compId, ',', esIndex, ',1);\'>', component.getGrouperLabel(z).toString(), '</span></div>');
				}
				if (component.getGrouperCatLabel(z)) {
					var esIndex = z;
					contentDivArr.push('<div><span id=\'cf', styleId, z, '\' class=\'cf-mnu\' onclick=\'MP_Util.LaunchCompFilterSelection(', compId, ',', esIndex, ',1);\'>', component.getGrouperCatLabel(z).toString(), '</span></div>');
				}
			}
			contentDivArr.push('</div></div></div>');
			contentDiv.innerHTML = contentDivArr.join('');

			if (applyFilterInd === 1) {
				if (mnuDisplay === i18nCore.FACILITY_DEFINED_VIEW) {
					component.startComponentDataRetrieval();
				}
				else {

					if (ns === 'ohx' || ns === 'ohx2') {
						component.FilterRefresh(mnuDisplay, catCodeList);
					}
					else {
						component.FilterRefresh(mnuDisplay, eventSetList);
					}

				}
			}
		},
		closeMenuInit: function(inMenu, compId) {
			var menuId;
			var docMenuId = compId + 'Menu';
			var lbMenuId = compId + 'Mnu';
			var cfMenuId = compId + 'TypeMenu';

			var menuLeave = function(e) {
				if (!e) {
					var e = window.event;
				}
				var relTarg = e.relatedTarget || e.toElement;
				if (e.relatedTarget.id == inMenu.id) {  //eslint-disable-line eqeqeq
					Util.Style.acss(inMenu, 'menu-hide');
				}
				e.stopPropagation();
				Util.cancelBubble(e);
			};
			if (inMenu.id == docMenuId || inMenu.id == lbMenuId || inMenu.id == cfMenuId) { //eslint-disable-line eqeqeq
				menuId = compId;
			}
			if (!e)
				var e = window.event;
			if (window.attachEvent) {
				Util.addEvent(inMenu, 'mouseleave', function() {
					Util.Style.acss(inMenu, 'menu-hide');
					_g(menuId).style.zIndex = 1;
				});
			}
			else {
				Util.addEvent(inMenu, 'mouseout', menuLeave);
			}
		},
		/**
		 * Provides the ability to construct the text that is to be placed after the label of the Component.
		 * Each component defines whether or not the number of items within the component should be displayed
		 * in the title of the component.  This is a requirements decision and will have to be answered upon creation
		 * of the component.  In addition, the lookback units and scope have been moved to the
		 * subtitle text line and are no longer necessary in the title text.
		 *
		 * The requirement is for each component to define whether or not the contract exists to display a number of items
		 * within the component header.  The reason for this contract is when 'no results found' is displayed, the count of zero
		 * must be displayed to indicate to the user if there are items within the component.  As for components who do not display
		 * a count, the user will still have to manually open the component to determine whether or not data exists.
		 *
		 * TODO: The future thought is that in the case of 'no results found' or 'error retrieving data', an additional indicator
		 * will be added to the component in some manner to indicate the status.  This is important with components such as Laboratory
		 * and Vitals for examples where the count of items is not displayed within the title text.
		 *
		 * @param component The {@see MPageComponent} in which to add the title text within.
		 * @param nbr The count of the list items displayed within the component
		 * @param optionalText Optional text to allow each consumer to place text within the header of the component.
		 */
		CreateTitleText: function(component, nbr, optionalText) {
			var ar = [];
			if (component.isLineNumberIncluded()) {
				ar.push('(', nbr, ')');
			}
			if (optionalText && optionalText !== '') {
				ar.push(' ', optionalText);
			}
			return ar.join('');
		},
		/**
		 * A helper utility to determine if a content body should be considered scrollable
		 * @param component  The component in which is being evaluated
		 * @param nbr  The number of items in which to consider scrolling enabled
		 */
		GetContentClass: function(component, nbr) {
			if (component.isScrollingEnabled()) {
				var scrollNbr = component.getScrollNumber();
				if (nbr > scrollNbr && scrollNbr > 0) {
					return 'content-body scrollable';
				}
			}
			return 'content-body';
		},
		/**
		 * CreateTimer will create a SLA timer and start the timer prior to returning.
		 * @param {String} timerName The timer name to start
		 * @param {String} subTimerName The subtimer name to start
		 * @param {String} metaData1
		 * @param {String} metaData2
		 * @param {String} metaData3
		 */
		CreateTimer: function(timerName, subTimerName, metaData1, metaData2, metaData3) {
			var rtmsTimer = new RTMSTimer(timerName, subTimerName).
				addMetaData('rtms.legacy.metadata.1', metaData1 || null).
				addMetaData('rtms.legacy.metadata.2', metaData2 || null).
				addMetaData('rtms.legacy.metadata.3', metaData3 || null);
			rtmsTimer.start();
			return rtmsTimer;
		},
		/**
		 * Retrieves the code values for a given code set
		 * @param {number} codeSet The code set in which to retrieve
		 * @param {boolean} async A boolean value indicating if the script call should be asynchronous.
		 * @return A list of code from the code set
		 */
		GetCodeSet: function(codeSet, async) {
			var codes = [];
			var codeSetRequest = new ScriptRequest();
			codeSetRequest.setProgramName('MP_GET_CODESET');
			codeSetRequest.setParameterArray(['^MINE^', codeSet + '.0']);
			codeSetRequest.setAsyncIndicator(async);
			codeSetRequest.setResponseHandler(function(dataReply){
				var codeSetObj = dataReply.getResponse();
				if(dataReply.getStatus() === 'S'){
					codes = MP_Util.LoadCodeListJSON(codeSetObj.CODES);
					}
			});
			codeSetRequest.performRequest();
			return codes;
		},
		/**
		 * Retrieves the code values for a given code set asynchronously and returns the
		 * source codes. If the codes are in the Shared Resource then the query to MP_GET_CODESET
		 * is not made
		 *
		 * @param {number} codeSet The code set in which to retrieve
		 * @param {Function} Callback function called when the code set values are retrieved
		 */

		 GetCodeSetAsync: function(codeSet, callbackFn) {
			try {
				var codes = [];
				var resourceName = 'CODESET_' + codeSet + '.0';
				//Check for the codes in Shared Resource
				var codeSetToken = MP_Resources.getSharedResource(resourceName);
				if (codeSetToken && codeSetToken.isResourceAvailable()) {
					callbackFn(codeSetToken.getResourceData());
				}
				else {
					var codeSetRequest = new ScriptRequest();
					codeSetRequest.setProgramName('MP_GET_CODESET');
					codeSetRequest.setParameterArray(['^MINE^', codeSet + '.0']);
					codeSetRequest.setAsyncIndicator(true);
					codeSetRequest.setResponseHandler(function(dataReply) {
						var codeSetObj = dataReply.getResponse();
						if (codeSetObj && dataReply.getStatus() === 'S') {
							codes = codeSetObj.CODES;
							codeSetToken = new SharedResource(resourceName);
							if (codeSetToken) {
								codeSetToken.setResourceData(codes);
								codeSetToken.setIsAvailable(true);
								MP_Resources.addSharedResource(resourceName, codeSetToken);
							}
							callbackFn(codes);
						}
						else if (dataReply.getStatus() === 'Z') {
							logger.logError('No source codes retrieved, Code Set: ' + codeSet);
						}
						else {
							logger.logError('There was an error retrieving source codes, Code Set: ' + codeSet);
						}
					});
					codeSetRequest.performRequest();
				}
			}
			catch(err) {
				logger.logJSError(err, null, 'mp_core.js', 'GetCodeSetAsync');
			}
		},

		/**
		 * Will return a code object from the mapped list by the cdf_meaning
		 * @param mapCodes  The map of code values to search
		 * @param meaning  The cdf_meaning of the code value to search
		 * @return The code object associated to the cdf_meaning provides.  Else null
		 */
		GetCodeByMeaning: function(mapCodes, meaning) {
			for (var x = mapCodes.length; x--; ) {
				var code = mapCodes[x].value;
				if (code.meaning == meaning)  //eslint-disable-line eqeqeq
					return code;
			}
			return null;
		},
		GetCodeValueByMeaning: function(meaning, codeSet) {
			var codeValue = 0;
			var list = m_codeSets[codeSet];
			if (!list) {
				list = m_codeSets[codeSet] = MP_Util.GetCodeSet(codeSet, false);
			}
			if (list && list.length > 0) {
				for (var x = list.length; x--; ) {
					var code = list[x].value;
					if (code.meaning === meaning) {
						return code;
					}
				}
			}
			return null;
		},
		/**
		 * Will search for a value within the provided mapped array and return the value associated to the name/value pair
		 * @param mapItems  The mapped array of items to search through
		 * @param item  The item in which to search
		 * @return The value from the name/value pair
		 */
		GetItemFromMapArray: function(mapItems, item) {
			for (var x = 0; x < mapItems.length; x++) {
				if (mapItems[x].name == item)  //eslint-disable-line eqeqeq
					return mapItems[x].value;
			}
		},
		/**
		 * Add an item to the array of items associated to the map key
		 * @param mapItems  The map array to search within
		 * @param key  The primary key that will be searching for within the map array
		 * @param value  The object that is to be added to the map array
		 */
		AddItemToMapArray: function(mapItems, key, value) {
			var ar = MP_Util.GetItemFromMapArray(mapItems, key);
			if (!ar) {
				ar = [];
				mapItems.push(new MP_Core.MapObject(key, ar));
			}
			ar.push(value);
		},

		CreateClinNoteLink: function(patient_id, encntr_id, event_id, display, docViewerType, pevent_id) {
			var docType = (docViewerType && docViewerType > '') ? docViewerType : 'STANDARD';
			var doclink = '';
			if (event_id > 0) {
				var ar = [];
				ar.push(patient_id, encntr_id, event_id, '"' + docType + '"', pevent_id);
				doclink = '<a onclick=\'javascript:MP_Util.LaunchClinNoteViewer(' + ar.join(',') + '); return false;\' href=\'#\'>' + display + '</a>';
			}
			else {
				doclink = display;
			}
			return (doclink);
		},

		/**
		 * Sorting by Collation Sequence: The sortBySequence function will return a flag either -1,0, or 1 according to the SEQUENCE field
		 *
		 * @param {item a, item b} a,b are two items whose SEQUENCE field will be compared to each other
		 * @returns {integer} 0 if SEQUENCE is equal, 1 if item a's SEQUENCE is greater than item B's SEQUENCE, -1 if
		 * less
		 */
		 SortBySequence: function(a, b) {
			try {
				var aSeq = a.SEQUENCE;
				var bSeq = b.SEQUENCE;

				// If the sequence is not defined then the value is either 0 or nothing, it would take the alternate route
				if (a.SEQUENCE) {
					if (aSeq > bSeq) {
						return 1;
					}
					else {
						if (aSeq < bSeq) {
							return -1;
						}
						return 0;
					}
				}
			}
			catch(err) {
				MP_Util.LogJSError(err, this, 'mp_core.js', 'sortBySequence');
			}
		},

		/**
		 * Retrieves a document for viewing via the MPages RTF viewer
		 * @param {Object} eventId The parent or child event id for retrieval
		 * @param {Object} docViewerType
		 * 0: Parent Event Id retrieval of child event blobs
		 * 1: Event Id blob retrieval
		 * 2: Long text retrieval
		 * 3: Micro Detail retrieval
		 * 4: Anatomic Pathology retrieval
		 */
		LaunchClinNoteViewer: function(patient_id, encntr_id, event_id, docViewerType, pevent_id) {
			var x = 0;
			var m_dPersonId = parseFloat(patient_id);
			var m_dEncntrId = parseFloat(encntr_id);
			var m_dPeventId = parseFloat(pevent_id);
			var viewerObj = window.external.DiscernObjectFactory('PVVIEWERMPAGE');
			logger.logDiscernInfo(null, 'PVVIEWERMPAGE', 'mp_core.js', 'LaunchClinNoteViewer');
			try {
				switch (docViewerType) {
					case 'AP':
						viewerObj.CreateAPViewer();
						viewerObj.AppendAPEvent(event_id, m_dPeventId);
						viewerObj.LaunchAPViewer();
						break;
					case 'DOC':
						viewerObj.CreateDocViewer(m_dPersonId);
						if (MP_Util.IsArray(event_id)) {
							for (var x = event_id.length; x--; ) {
								viewerObj.AppendDocEvent(event_id[x]);
							}
						}
						else {
							viewerObj.AppendDocEvent(event_id);
						}
						viewerObj.LaunchDocViewer();
						break;
					case 'EVENT':
						viewerObj.CreateEventViewer(m_dPersonId);
						if (MP_Util.IsArray(event_id)) {
							for (var x = event_id.length; x--; ) {
								viewerObj.AppendEvent(event_id[x]);
							}
						}
						else {
							viewerObj.AppendEvent(event_id);
						}
						viewerObj.LaunchEventViewer();
						break;
					case 'MICRO':
						viewerObj.CreateMicroViewer(m_dPersonId);
						if (MP_Util.IsArray(event_id)) {
							for (var x = event_id.length; x--; ) {
								viewerObj.AppendMicroEvent(event_id[x]);
							}
						}
						else {
							viewerObj.AppendMicroEvent(event_id);
						}
						viewerObj.LaunchMicroViewer();
						break;
					case 'GRP':
						viewerObj.CreateGroupViewer();
						if (MP_Util.IsArray(event_id)) {
							for (var x = event_id.length; x--; ) {
								viewerObj.AppendGroupEvent(event_id[x]);
							}
						}
						else {
							viewerObj.AppendGroupEvent(event_id);
						}
						viewerObj.LaunchGroupViewer();
						break;
					case 'PROC':
						viewerObj.CreateProcViewer(m_dPersonId);
						if (MP_Util.IsArray(event_id)) {
							for (var x = event_id.length; x--; ) {
								viewerObj.AppendProcEvent(event_id[x]);
							}
						}
						else {
							viewerObj.AppendProcEvent(event_id);
						}
						viewerObj.LaunchProcViewer();
						break;
					case 'HLA':
						viewerObj.CreateAndLaunchHLAViewer(m_dPersonId, event_id);
						break;
					case 'NR':
						viewerObj.LaunchRemindersViewer(event_id);
						break;
					case 'STANDARD':
						alert(i18n.discernabu.CAN_NOT_VIEW_RESULTS);
						break;
				}
			}
			catch (err) {
				logger.logJSError(err, null, 'mp_core.js', 'LaunchClinNoteViewer');
				alert(i18n.discernabu.CAN_NOT_VIEW_RESULTS + '  ' + i18n.CONTACT_ADMINISTRATOR);
			}
		},
		IsArray: function(input) {
			return ( typeof (input) === 'object' && ( input instanceof Array));
		},
		IsString: function(input) {
			return ( typeof (input) === 'string');
		},
		HandleNoDataResponse: function(nameSpace) {
			var i18nCore = i18n.discernabu;
			return ('<h3 class=\'info-hd\'><span class=\'res-normal\'>' + i18nCore.NO_RESULTS_FOUND + '</span></h3><span class=\'res-none\'>' + i18nCore.NO_RESULTS_FOUND + '</span>');
		},
		HandleErrorResponse: function(nameSpace, errorMessage) {
			var ar = [];
			var i18nCore = i18n.discernabu;
			//Create the HTML that will be returned to the component
			var ns = (nameSpace && nameSpace.length > 0) ? nameSpace + '-' : '';
			ar.push('<h3 class=\'info-hd\'><span class=\'res-normal\'>', i18nCore.ERROR_RETREIVING_DATA, '</span></h3>');
			ar.push('<dl class=\'', ns, 'info error-message error-text\'><dd><span>', i18nCore.ERROR_RETREIVING_DATA, '</span></dd></dl>');
			//log the error out to the JSLogger
			if (errorMessage && errorMessage.length) {
				logger.logError(i18n.COMPONENTS + ': ' + nameSpace + '<br />' + errorMessage);
			}
			return ar.join('');
		},
		GetValueFromArray: function(name, array) {
			if (array != null) {  //eslint-disable-line eqeqeq
				for (var x = 0, xi = array.length; x < xi; x++) {
					if (array[x].name == name) {  //eslint-disable-line eqeqeq
						return (array[x].value);
					}
				}
			}
			return (null);
		},

		GetCompObjById: function(id) {
			var comps = CERN_MPageComponents;
			var cLen = comps.length;
			for (var i = cLen; i--; ) {
				var comp = comps[i];
				if (comp.m_componentId === id) {
					return comp;
				}
			}
			return (null);
		},
		GetCompObjByStyleId: function(id) {
			var cLen = CERN_MPageComponents.length;
			for (var i = cLen; i--; ) {
				var comp = CERN_MPageComponents[i];
				var styles = comp.getStyles();
				if (styles.getId() === id) {
					return comp;
				}
			}
			return (null);
		},
		LoadCodeListJSON: function(parentElement) {
			var codeArray = new Array();
			var codeElement = null;
			if (parentElement != null) {  //eslint-disable-line eqeqeq
				for (var x = 0; x < parentElement.length; x++) {
					var codeObject = new Object();
					codeElement = parentElement[x];
					codeObject.codeValue = codeElement.CODE;
					codeObject.display = codeElement.DISPLAY;
					codeObject.description = codeElement.DESCRIPTION;
					codeObject.codeSet = codeElement.CODE_SET;
					codeObject.sequence = codeElement.SEQUENCE;
					codeObject.meaning = codeElement.MEANING;
					var mapObj = new MP_Core.MapObject(codeObject.codeValue, codeObject);
					codeArray.push(mapObj);
				}
			}
			return (codeArray);
		},
		LoadPersonelListJSON: function(parentElement) {
			var personnelArray = [];
			var codeElement;
			if (parentElement != null) {  //eslint-disable-line eqeqeq
				for (var x = 0; x < parentElement.length; x++) {
					var prsnlObj = {};
					codeElement = parentElement[x];
					prsnlObj.id = codeElement.ID;
					//If available retrieve the beg and end date and time for a prsnl name
					if (codeElement.BEG_EFFECTIVE_DT_TM) {
						prsnlObj.beg_dt_tm = codeElement.BEG_EFFECTIVE_DT_TM;
						//create the string object for comparisons purposes
						prsnlObj.beg_dt_tm_string = /[0-9]+-[0-9]+-[0-9]+/.exec(codeElement.BEG_EFFECTIVE_DT_TM) + 'T' + /[0-9]+:[0-9]+:[0-9]+/.exec(codeElement.BEG_EFFECTIVE_DT_TM) + 'Z';
					}
					if (codeElement.END_EFFECTIVE_DT_TM) {
						prsnlObj.end_dt_tm = codeElement.END_EFFECTIVE_DT_TM;
						//create the string object for comparisons purposes
						prsnlObj.end_dt_tm_string = /[0-9]+-[0-9]+-[0-9]+/.exec(codeElement.END_EFFECTIVE_DT_TM) + 'T' + /[0-9]+:[0-9]+:[0-9]+/.exec(codeElement.END_EFFECTIVE_DT_TM) + 'Z';
					}
					prsnlObj.fullName = codeElement.PROVIDER_NAME.NAME_FULL;
					prsnlObj.firstName = codeElement.PROVIDER_NAME.NAME_FIRST;
					prsnlObj.middleName = codeElement.PROVIDER_NAME.NAME_MIDDLE;
					prsnlObj.lastName = codeElement.PROVIDER_NAME.NAME_LAST;
					prsnlObj.userName = codeElement.PROVIDER_NAME.USERNAME;
					prsnlObj.initials = codeElement.PROVIDER_NAME.INITIALS;
					prsnlObj.title = codeElement.PROVIDER_NAME.TITLE;
					var mapObj = new MP_Core.MapObject(prsnlObj.id, prsnlObj);
					personnelArray[x] = mapObj;
				}
			}
			return (personnelArray);
		},
		LoadPhoneListJSON: function(parentElement) {
			var phoneArray = [];
			var codeElement = null;
			var phoneLen = 0;
			if (parentElement) {
				for (var x = parentElement.length; x--;) {
					var phoneObj = {};
					codeElement = parentElement[x];
					phoneObj.personId = codeElement.PERSON_ID;
					//fill in each phone for this person id
					phoneLen = codeElement.PHONES.length;
					phoneObj.phones = [];
					for (var y = 0; y < phoneLen; y++) {
						var phoneListing = {};
						phoneListing.phoneNum = codeElement.PHONES[y].PHONE_NUM;
						phoneListing.phoneType = codeElement.PHONES[y].PHONE_TYPE;
						phoneObj.phones.push(phoneListing);
					}
					var mapObj = new MP_Core.MapObject(phoneObj.personId, phoneObj);
					phoneArray[x] = mapObj;
				}
			}
			return (phoneArray);
		},
		WriteToFile: function(sText) {
			try {
				var ForAppending = 8;
				var TriStateFalse = 0;
				var fso = new ActiveXObject('Scripting.FileSystemObject');
				var newFile = fso.OpenTextFile('c:\\temp\\test.txt', ForAppending, true, TriStateFalse);
				newFile.write(sText);
				newFile.close();
			}
			catch (err) {
				var strErr = 'Error:';
				strErr += '\nNumber:' + err.number;
				strErr += '\nDescription:' + err.description;
				document.write(strErr);
			}
		},

		/**
		 *  Javascript string pad
		 *  @see http://www.webtoolkit.info/
		 **/
		pad: function(str, len, pad, dir) {
			if ( typeof (len) === 'undefined') {
				var len = 0;
			}
			if ( typeof (pad) === 'undefined') {
				var pad = ' ';
			}
			if ( typeof (dir) === 'undefined') {
				var dir = STR_PAD_RIGHT;
			}

			if (len + 1 >= str.length) {

				switch (dir) {

					case STR_PAD_LEFT:
						str = Array(len + 1 - str.length).join(pad) + str;
						break;

					case STR_PAD_BOTH:
						var padlen = 0;
						var right = Math.ceil(( padlen = len - str.length) / 2);
						var left = padlen - right;
						str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
						break;

					default:
						str = str + Array(len + 1 - str.length).join(pad);
						break;

				} // switch
			}
			return str;
		},

		/**
		 * Launches graph in a modal window viewable in the Powerchart framework
		 * @param {number} eventCd The event code to retrieve results for
		 * @param {number} compId The numberical id of the component to lookup
		 * @param {number} groupId The groupId to pass into the graphing utility
		 */
		GraphResults: function(eventCd, compID, groupID) {
			var component = MP_Util.GetCompObjById(compID);
			var encntrOption = '';
			var i18nCore = i18n.discernabu;
			var lookBackText = '';
			var lookBackType = (component.getLookbackUnitTypeFlag()) ? component.getLookbackUnitTypeFlag() : '2';
			var lookBackUnits = (component.getLookbackUnits()) ? component.getLookbackUnits() : '365';
			var parameters = '';
			var replaceText = '';
			var subTitleText = '';
			var scope = component.getScope();
			var criterion = component.getCriterion();

			if (scope > 0) {
				switch(lookBackType) {
					case 1:
						replaceText = i18nCore.LAST_N_HOURS.replace('{0}', lookBackUnits);
						break;

					case 2:
						replaceText = i18nCore.LAST_N_DAYS.replace('{0}', lookBackUnits);
						break;

					case 3:
						replaceText = i18nCore.LAST_N_WEEKS.replace('{0}', lookBackUnits);
						break;

					case 4:
						replaceText = i18nCore.LAST_N_MONTHS.replace('{0}', lookBackUnits);
						break;

					case 5:
						replaceText = i18nCore.LAST_N_YEARS.replace('{0}', lookBackUnits);
						break;

					default:
						replaceText = i18nCore.LAST_N_DAYS.replace('{0}', lookBackUnits);
						break;
				}

				switch(scope) {
					case 1:
						lookBackText = i18nCore.ALL_N_VISITS.replace('{0}', replaceText);
						encntrOption = '0.0';
						break;
					case 2:
						lookBackText = i18nCore.SELECTED_N_VISIT.replace('{0}', replaceText);
						encntrOption = criterion.encntr_id + '.0';
						break;
				}
			}
			else{
				logger.logError('No scope defined for component ' + component.getLabel());
				return;
			}


			//Mobile Reach - To Launch Graph viewer
			if(!CERN_Platform.inMillenniumContext()) {
				parameters = '^MINE^,' + criterion.person_id + '.0,' + encntrOption + ',' + eventCd + '.0,^' + criterion.static_content + '/discrete-graphing^,' + groupID + '.0,' + criterion.provider_id + '.0,' + criterion.position_cd + '.0,' + criterion.ppr_cd + '.0,' + lookBackUnits + ',' + lookBackType + ',200,^' + lookBackText + '^,^^,^^,^^,1';
				MD_reachViewerDialog.LaunchReachGraphViewer(parameters);
			}
			else{
				var wParams = 'left=0,top=0,width=1200,height=700,toolbar=no';
				parameters = '^MINE^,' + criterion.person_id + '.0,' + encntrOption + ',' + eventCd + '.0,^' + criterion.static_content + '\\discrete-graphing^,' + groupID + '.0,' + criterion.provider_id + '.0,' + criterion.position_cd + '.0,' + criterion.ppr_cd + '.0,' + lookBackUnits + ',' + lookBackType + ',200,^' + lookBackText + '^';
				var graphCall = 'CCLLINK(\'mp_retrieve_graph_results\', \'' + parameters + '\',1)';
				logger.logCCLNewSessionWindowInfo(null, graphCall, 'mp_core.js', 'GraphResults');
				CCLNEWSESSIONWINDOW(graphCall, '_self', wParams, 0, 1);
			}

			Util.preventDefault();
		},
		ReleaseRequestReference: function(reqObj) {
			if(CERN_Platform.inMillenniumContext() && XMLCCLREQUESTOBJECTPOINTER) {
				for (var id in XMLCCLREQUESTOBJECTPOINTER) {
					if(XMLCCLREQUESTOBJECTPOINTER[id] === reqObj) {
						delete(XMLCCLREQUESTOBJECTPOINTER[id]);
					}
				}
			}
		},
		/**
		 * Message box similar to alert or confirm with customizable options.
		 * @param msg {string} String message or html to display in message box
		 * @param title {string}  Title of the message box
		 * @param btnTrueText {string}  Text value of the true option button, will default to 'OK' if omitted.
		 * @param btnFalseText {string}  Text value of the false option button.  No false button will be created if omitted.
		 * @param falseBtnFocus {boolean}  Sets the default focus to the false button.
		 * @param cb {object}  Callback function to fire on true button click.
		 */
		AlertConfirm: function(msg, title, btnTrueText, btnFalseText, falseBtnFocus, cb) {
			var btnTrue = '<button id=\'acTrueButton\' data-val=\'1\'>' + ((btnTrueText) ? btnTrueText : i18n.discernabu.CONFIRM_OK) + '</button>';
			var btnFalse = '';
			if (btnFalseText) {
				btnFalse = '<button id=\'acFalseButton\' data-val=\'0\'>' + btnFalseText + '</button>';
			}
			if (!title) {
				title = '&nbsp;';
			}

			var closeBox = function() {
				var btnVal = parseInt(this.getAttribute('data-val'), 10);
				$('.modal-div').remove();
				$('.modal-dialog').remove();
				$('html').css('overflow', 'auto');
				//reset overflow
				if (btnVal && typeof cb === 'function') {
					cb();
				}
			};
			var modalDiv = Util.cep('div', {
				'className': 'modal-div'
			});
			var dialog = Util.cep('div', {
				'className': 'modal-dialog'
			});

			dialog.innerHTML = '<div class=\'modal-dialog-hd\'>' + title + '</div>' + '<div class=\'modal-dialog-content\'>' + msg + '</div>' + '<div class=\'modal-dialog-ft\'><div class=\'modal-dialog-btns\'>' + btnTrue + btnFalse + '</div></div>';

			var docBody = document.body;
			Util.ac(modalDiv, docBody);
			Util.ac(dialog, docBody);

			Util.addEvent(_g('acTrueButton'), 'click', closeBox);
			if (btnFalseText) {
				Util.addEvent(_g('acFalseButton'), 'click', closeBox);
			}

			if (falseBtnFocus && btnFalseText) {
				_g('acFalseButton').focus();
			}
			else {
				_g('acTrueButton').focus();
			}

			$('html').css('overflow', 'hidden');
			//disable page scrolling when modal is enabled
			$(modalDiv).height($(document).height());
		},

		CreateAutoSuggestBoxHtml: function(component, elementId) {
			var searchBoxHTML = [];
			var txtBoxId = '';
			var compNs = component.getStyles().getNameSpace();
			var compId = component.getComponentId();
			if (elementId) {
				txtBoxId = compNs + elementId + compId;
			}
			else {
				txtBoxId = compNs + 'ContentCtrl' + compId;
			}

			searchBoxHTML.push('<div class=\'search-box-div\'><form name=\'contentForm\' onSubmit=\'return false\'><input type=\'text\' id=\'', txtBoxId, '\'', ' class=\'search-box\'></form></div>');
			return searchBoxHTML.join('');
		},
		AddAutoSuggestControl: function(component, queryHandler, selectionHandler, selectDisplayHandler, itemId) {
			new AutoSuggestControl(component, queryHandler, selectionHandler, selectDisplayHandler, itemId);
		},
		RetrieveAutoSuggestSearchBox: function(component) {
			var componentNamespace = component.getStyles().getNameSpace();
			var componentId = component.getComponentId();
			return _g(componentNamespace + 'ContentCtrl' + componentId);
		},
		CreateParamArray: function(ar, type) {
			var returnVal = (type === 1) ? '0.0' : '0';
			if (ar && ar.length > 0) {
				if (ar.length > 1) {
					if (type === 1) {
						returnVal = 'value(' + ar.join('.0,') + '.0)';
					}
					else {
						returnVal = 'value(' + ar.join(',') + ')';
					}
				}
				else {
					returnVal = (type === 1) ? ar[0] + '.0' : ar[0];
				}
			}
			return returnVal;
		},
		/**
		 * This method is used to overlay the content of a component with a transparent DIV and also show the loading icon (spinner) in the center of that container.
		 * @param {String} resultContainerId The id of the element which should be covered by the spinner.
		 * @param {number} skipOffsetFlag Pass a 1 to not use the offset and instead set the margin-top
		 * @param {String} spinnerId Spinner div Id that is used to reference the spinner
		 * @return null
		 */
		LoadSpinner: function(resultContainerID, skipOffsetFlag, spinnerId) {
			if (resultContainerID && typeof resultContainerID === 'string') {
				var resultContainer = $('#' + resultContainerID);
				var contentHeight = resultContainer.height();
				var styleProp = '';

				if (skipOffsetFlag) {
					styleProp = 'height: ' + contentHeight + 'px; margin-top: -' + contentHeight + 'px;';
				}
				else {
					var offset = resultContainer.offsetParent();
					var loadingIconTop = offset.height() - contentHeight;
					styleProp = 'height: ' + contentHeight + 'px; top: ' + loadingIconTop + 'px;';
				}

				if (spinnerId) {
					resultContainer.append('<div id=\'' + spinnerId + '\' class=\'loading-screen\' style=\'' + styleProp + '\'><div class=\'loading-spinner\'>&nbsp;</div></div>');
				}
				else {
					resultContainer.append('<div class=\'loading-screen\' style=\'' + styleProp + '\'><div class=\'loading-spinner\'>&nbsp;</div></div>');
				}
			}
		},
		/**
		 * Will get the date formatter associate to the locale loaded by the driver
		 * @return The date formatter to utilize for the loaded locale
		 */
		GetDateFormatter: function() {
			if (!m_df) {
				m_df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			}
			return m_df;
		},
		/**
		 * Will get the numeric formatter associate to the locale loaded by the driver
		 * @return The numeric formatter to utilize for the loaded locale
		 */
		GetNumericFormatter: function() {
			if (!m_nf) {
				m_nf = new mp_formatter.NumericFormatter(MPAGE_LOCALE);
			}
			return m_nf;
		},
		/**
		 * To display a ModalDialog with the output of the reportName script.
		 * The driver script will be called to get the details of the report and if the response is success,
		 * the response text will be displayed in the body of the dialog.
                 * If there is any failure in the response, an error dialog will be displayed with error message and
		 * on closing the dialog report modal dialog will be displayed with text "No data found" in the body.
		 * On click of print button will open a print dialog to perform the printing.
		 * @param reportName {String} name of the report to be executed.
		 * @param person_id {String} personId Person id of the patient in string format with '.0' on the end.
		 * @param encounter_id {int} encounterId Encounter id of the patient in string format with '.0' on the end.
		 * @return null
		 */
		PrintReport: function(reportName, personId, encounterId) {
			var convertRTFtoHTML = 1;
			var reportContents = '';
			/**
			 * This function will create and iFrame and populate it with the results of
			 * the report.  Once that is done it executes the print functionality
			 */
			function printReportOutput(){
				try {
					var iframeObj = document.createElement('iframe');
					iframeObj.setAttribute('display', 'none');
					document.body.appendChild(iframeObj);

					var printWindow = iframeObj.contentWindow;
					var docObject = printWindow ? printWindow.document : null;
					if (docObject) {
						docObject.write(reportContents);
						docObject.close();
						printWindow.focus();
						printWindow.print();
					}
				}
				catch(err){
					logger.logJSError(err, null, 'mpage-core.js', 'PrintReport');
				}
				finally {
					$(iframeObj).remove();
				}
			}

			//Retrieve the print report modalDialog object
			var printDialog = MP_ModalDialog.retrieveModalDialogObject('printDialog');
			if(!printDialog){
				printDialog = new ModalDialog('printDialog');
				printDialog.setHeaderTitle('&nbsp;');
				MP_ModalDialog.addModalDialogObject(printDialog);

				//Create the cancel button
				var cancelButton = new ModalButton('cancelButton');
				cancelButton.setText(i18n.discernabu.CONFIRM_CANCEL);
				cancelButton.setCloseOnClick(true);
				printDialog.addFooterButton(cancelButton);

				//Create the print button
				var printButton = new ModalButton('printButton');
				printButton.setText(i18n.PRINT);
				printButton.setCloseOnClick(false);
				printButton.setOnClickFunction(printReportOutput);
				printDialog.addFooterButton(printButton);
			}

			//Show the modal dialog before we make the synchronous request
			MP_ModalDialog.showModalDialog('printDialog');

			//Create a script request to get the results from the print report
			var reportRequest = new ScriptRequest();
			reportRequest.setName('Print Report Script Request');
			reportRequest.setProgramName('pwx_rpt_driver_to_mpage');
			reportRequest.setParameterArray(['^MINE^', '^' + reportName + '^', personId, encounterId, convertRTFtoHTML]);
			reportRequest.setRawDataIndicator(true);
			reportRequest.setResponseHandler(function(replyObj){
				//Reset the cursor to default
				$('body').css('cursor', 'default');
				//Get the reply from the script
				reportContents = replyObj.getResponse();
				//Update the contents of the modal dialog with the reply from the script request or the No Data Found i18n
				printDialog.setBodyHTML(reportContents || i18n.NO_DATA_FOUND);
			});
			reportRequest.performRequest();

			// Show the cursor as busy, this indicates the system is processing the request.
			// It will be reset to default when success/failed response is returned.
			$('body').css('cursor', 'wait');
		},
		CalculatePrecision: function(valRes) {
			var precision = 0;
			var str = (MP_Util.IsString(valRes)) ? valRes : valRes.toString();
			var decLoc = str.search(/\.(\d)/);
			if (decLoc !== -1) {
				var strSize = str.length;
				precision = strSize - decLoc - 1;
			}
			return precision;
		},
		/**
		 * Will create a date/time in the format neccessary for passing as a prompt parameter
		 */
		CreateDateParameter: function(date) {
			var day = date.getDate();
			var month = '';
			var rest = date.format('yyyy HH:MM:ss');
			switch (date.getMonth()) {
				case (0):
					month = 'JAN';
					break;
				case (1):
					month = 'FEB';
					break;
				case (2):
					month = 'MAR';
					break;
				case (3):
					month = 'APR';
					break;
				case (4):
					month = 'MAY';
					break;
				case (5):
					month = 'JUN';
					break;
				case (6):
					month = 'JUL';
					break;
				case (7):
					month = 'AUG';
					break;
				case (8):
					month = 'SEP';
					break;
				case (9):
					month = 'OCT';
					break;
				case (10):
					month = 'NOV';
					break;
				case (11):
					month = 'DEC';
					break;
				default:
					alert('unknown month');
			}
			return (day + '-' + month + '-' + rest);
		},
		/**
		 * @deprecated Use logger.logDebug(debug) instead.
		 * This method will log a debug message.
		 * @param {string} debugString - The debug string to be logged.
		 */
		LogDebug: function(debugString) {
			logger.logDebug(debugString);
		},
		/**
		 * @deprecated Use logger.logWarning(warning) instead.
		 * This method will log a warning.
		 * @param {string} warnString - The warning string to be logged.
		 */
		LogWarn: function(warnString) {
			logger.logWarning(warnString);
		},
		/**
		 * @deprecated Use logger.logMessage(message) instead.
		 * This method will log a message.
		 * @param {string} infoString - The message string to be logged.
		 */
		LogInfo: function(infoString) {
			logger.logMessage(infoString);
		},
		/**
		 * @deprecated Use logger.logError(error) instead.
		 * This method will log an error.
		 * @param {string} errorString - The error string to be logged.
		 */
		LogError: function(errorString) {
			logger.logError(errorString);
		},
		/**
		 * @deprecated Use logger.logScriptCallInfo(...) instead.
		 * @param {MPageComponent} component - The component for which the info is being logged.
		 * @param {ScriptRequest} request - The script request that was made.
		 * @param {string} file - The JS file from which the script call was made.
		 * @param {string} funcName - The function from which the script call was made.
		 */
		LogScriptCallInfo: function(component, request, file, funcName) {
			logger.logScriptCallInfo(component, request, file, funcName);
		},
		/**
		 * @deprecated Use logger.logScriptCallError(...) instead.
		 * @param {MPageComponent} component - The component for which the error is being logged.
		 * @param {ScriptRequest} request - The script request that was made.
		 * @param {string} file - The JS file from which the script call was made.
		 * @param {string} funcName - The function from which the call was made.
		 */
		LogScriptCallError: function(component, request, file, funcName) {
			logger.logScriptCallError(component, request, file, funcName);
		},
		/**
		 * @deprecated Use logger.logJSError(...) instead.
		 * @param {Error} err - The error that occurred.
		 * @param {MPageComponent} component - The component in which the error originated.
		 * @param {string} file - The JS file from which the JavaScript error originated.
		 * @param {string} funcName - The function from which the JavaScript error originated.
		 */
		LogJSError: function(err, component, file, funcName) {
			logger.logJSError(err, component, file, funcName);
		},
		/**
		 * @deprecated Use logger.logDiscernInfo(...) instead.
		 * @param {MPageComponent} component - The component from which the information is being logged.
		 * @param {string} objectName - The name of the object for which information is being logged.
		 * @param {string} file - The JS file from which the information is being logged.
		 * @param {string} funcName - The function from which the information is being logged.
		 */
		LogDiscernInfo: function(component, objectName, file, funcName) {
			logger.logDiscernInfo(component, objectName, file, funcName);
		},
		/**
		 * @deprecated Use logger.logMPagesEventInfo(...) instead.
		 * @param {MPageComponent} component - The component from which the information is being logged.
		 * @param {string} eventName - The name of the event that occurred.
		 * @param {string} params - The parameters associated to the MPages event.
		 * @param {string} file - The JS file from which the information is being logged.
		 * @param {string} funcName - The function from which the information is being logged.
		 */
		LogMpagesEventInfo: function(component, eventName, params, file, funcName) {
			logger.logMPagesEventInfo(component, eventName, params, file, funcName);
		},
		/**
		 * @deprecated Use logger.logCCLNewSessionWindowInfo(...) instead.
		 * @param {MPageComponent} component - The component from which the information is being logged.
		 * @param {string} params - The parameters associated to the CCLNEWSESSIONWINDOW.
		 * @param {string} file - The JS file from which the information is being logged.
		 * @param {string} funcName - The function from which the information is being logged.
		 */
		LogCclNewSessionWindowInfo: function(component, params, file, funcName) {
			logger.logCCLNewSessionWindowInfo(component, params, file, funcName);
		},
		/**
		 * @deprecated Use logger.logTimerInfo(...) instead.
		 * @param {string} timerName - The name of the timer.
		 * @param {string} subTimerName - The sub timer name.
		 * @param {string} timerType - The type of timer.
		 * @param {string} file - The JS file from which the information is being logged.
		 * @param {string} funcName - The function from which the information is being logged.
		 */
		LogTimerInfo: function(timerName, subTimerName, timerType, file, funcName) {
			logger.logTimerInfo(timerName, subTimerName, timerType, file, funcName);
		},
		AddCookieProperty: function(compId, propName, propValue) {
			var cookie = CK_DATA[compId];
			if (!cookie) {
				cookie = {};
			}
			cookie[propName] = propValue;
			CK_DATA[compId] = cookie;
		},
		GetCookieProperty: function(compId, propName) {
			var cookie = CK_DATA[compId];
			if (cookie && cookie[propName]) {
				return cookie[propName];
			}
			else {
				return null;
			}
		},
		WriteCookie: function() {
			var cookieJarJSON = JSON.stringify(CK_DATA);
			document.cookie = 'CookieJar=' + cookieJarJSON + ';';
		},
		RetrieveCookie: function() {
			var cookies = document.cookie;
			var match = cookies.match(/CookieJar=({[^;]+})(;|\b|$)/);
			if (match && match[1]) {
				CK_DATA = JSON.parse(match[1]);
			}
		},
		/**
		 * This function is used to generate the HTML content for a modal dialog that is intended to display an informational message to the user.
		 * If the modal dialog with the id of modalId does not already exist it will be created, but will not be added to the modal dialog collection
		 * in MP_ModalDialog.
		 * @param {string} modalId The id of an existing modal dialog or the id that will be given to the modal dialog that will be created.
		 * @param {string} messageType The type of message that will be created.  Different styling will be applied to different message types.  A default
		 * value of "" is a valid value for this parameter.
		 * @param {string} line1 This first line of the informational message.  This line could potentially be stylized based on the messageType.
		 * @param {string} line2 This is the second line of the information message.  It will not be styled based on the messageType
		 * @return {ModalDialog}  The updated or newly create ModalDialog object.
		 */
		generateModalDialogBody: function(modalId, messageType, line1, line2){
			var modal = null;
			var modalHTML = '';

			//Check to see if this modal dialog already exists.  If not go ahead and create it.
			modal = MP_ModalDialog.retrieveModalDialogObject(modalId);
			if(!modal){
				modal = new ModalDialog(modalId);
			}
			//Apply the proper margins for User informational messages
			modal.setLeftMarginPercentage(35).setRightMarginPercentage(35).setTopMarginPercentage(20).setIsBodySizeFixed(false).setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);

			//Generate the proper HTML string based on the type passed into the function
			modalHTML = MP_Core.generateUserMessageHTML(messageType,line1,line2);

			//Apply the new message to the modal
			if(modal.isActive()){
				modal.setBodyHTML(modalHTML);
			}
			else{
				modal.setBodyDataFunction(function(modalObj){
					modalObj.setBodyHTML(modalHTML);
				});
			}
			return modal;
		},
		/**
		 * Creates a mapping between a string identifier and an object definition.  The object definition is only mapped
		 * when the objectDefinition parameter is an actual object and an existing object does not exist for that
		 * identifier.
		 * @param {string} mappingId : An id associated to the specific object definition that will be mapped.  This id is case
		 * insensitive.
		 * @param {function} objectDefinition : A reference to the definition of the object being mapped
		 * @return {boolean} True if the object mapping was added successfully, false otherwise.
		 */
		setObjectDefinitionMapping : function(mappingId, objectDefinition) {
			//Make sure the mappingID is a string
			if(typeof mappingId !== 'string'){
				return false;
			}
			mappingId = mappingId.toUpperCase();

			//Check to see if there is an existing mapping for that ID
			if( typeof CERN_ObjectDefinitionMapping[mappingId] !== 'undefined') {
				logger.logMessage('Object mapping already exists for ' + mappingId + '\nPlease select a different id or use the MP_Util.updateObjectDefinitionMApping function');
				return false;
			}
			//Make sure we are mapping an object definition which would be a function
			if( typeof objectDefinition === 'function' ) {
				CERN_ObjectDefinitionMapping[mappingId] = objectDefinition;
				return true;
			}
			return false;
		},
		/**
		 * Retrieves the object mapped to a specific mappingId if it is defined in the CERN_ObjectDefinitionMapping object
		 * @param {string} mappingId : The id mapped to a specific object in the CERN_ObjectDefintionMapping object.   This id is case
		 * insensitive.
		 * @return {function} The object definition mapped to the mappingId passed into the function.
		 */
		getObjectDefinitionMapping : function(mappingId) {
			//Make sure the mappingID is a string
			if(typeof mappingId !== 'string'){
				return null;
			}
			mappingId = mappingId.toUpperCase();
			//Attempt to retrieve the object definition
			if( typeof CERN_ObjectDefinitionMapping[mappingId] === 'undefined') {
				return null;
			}
			return CERN_ObjectDefinitionMapping[mappingId];
		},
		/**
		 * Updates the object definition mapped to the identifier passed into the function.  If no object is mapped to the
		 * identifier then no updates are made to the CERN_ObjectDefinitionMapping object.
		 * @param {string} mappingId : An id associated to the specific object definition that will be mapped.  This id is case
		 * insensitive.
		 * @param {function} objectDefinition : A reference to the definition of the object being mapped
		 * @return {boolean} True if the object mapping was updated successfully, false otherwise.
		 */
		updateObjectDefinitionMapping : function(mappingId, objectDefinition) {
			//Make sure the mappingID is a string
			if(typeof mappingId !== 'string'){
				return null;
			}
			mappingId = mappingId.toUpperCase();
			//Make sure an object definition already exists for this mappingId
			if( typeof CERN_ObjectDefinitionMapping[mappingId] === 'undefined') {
				logger.logMessage('Object mapping does not exists for ' + mappingId);
				return false;
			}
			//Make sure we are mapping an object definition which would be a function
			if( typeof objectDefinition === 'function' ) {
				CERN_ObjectDefinitionMapping[mappingId] = objectDefinition;
				return true;
			}
			return false;
		},
		/**
		 * Removes the object definition mapped to the identifier passed into the function.
		 * @param {string} mappingId : An id associated to the specific object definition that will be removed.  This id is case
		 * insensitive.
		 * @return {boolean} True if the object mapping was removed successfully, false otherwise.
		 */
		removeObjectDefinitionMapping : function(mappingId) {
			//Make sure the mappingID is a string
			if(typeof mappingId !== 'string'){
				return null;
			}
			mappingId = mappingId.toUpperCase();
			//Make sure the object definition exists before we attempt to delete it
			if( typeof CERN_ObjectDefinitionMapping[mappingId] === 'undefined') {
				logger.logMessage('Object mapping does not exists for ' + mappingId);
				return false;
			}
			return delete CERN_ObjectDefinitionMapping[mappingId];
		},
		/*
		 * This function stringifies the passed in object, surrounds fields which end in _dt_tm with "\/Date()\/"
		 * and adds .0 to all fields which end in _id or _cd. Also, if any fields are passed in .0 will be added for those fields as well
		 *
		 * @param {object} object which needs to be stringified
		 *
		 * @param {number} skip fields ending in _id/_cd flag - If set to 1, .0 will not be added to the fields ending in _id and _cd
		 *
		 * @param {number} skip date flag - If set to 1, value of fields ending in _dt_tm will not be surrounded with "\/Date()\/"
		 *
		 * @param {string} field names for which .0 should be added(apart from fields which end in _id/_cd). Any number of fields can be passed in
		 *
		 * @param {boolean} pass true if the dates are in UTC format
		 *
		 * @return {string} JSON string which can be passed to back-end
		 *
		 * Usage - call enhancedStringify(obj, 1, 1, "application_ctx")
		 *
		 *    Above function call will stringify the passed in object - obj, add .0 for all fields ending in _id or cd
		 *    and surround dt_tm fields with Date() and also add .0 for application_ctx field
		 */
		enhancedStringify: function(obj, skipIDAndCDFields, skipDates, isUTC , additionalFields) {

			var replacedJSONStr, findString, regExpObject;

			var dateAndIdReplacer = function(key, value) {

				if (typeof key === 'string') {

					var upperCaseKey = key.toUpperCase();
					var replacedDateValue;

					// Do not surround date fields with Date() if skipDates flag is set to 1
					if (skipDates !== 1 && typeof value === 'string' && value !== '' && upperCaseKey.indexOf('_DT_TM') > -1) {
						if(isUTC) {
							replacedDateValue = 'XXX_REPLACE_DT_START_XXX' + value.replace('Z', '+00:00XXX_REPLACE_DT_END_XXX');
						} else {
							replacedDateValue = 'XXX_REPLACE_DT_START_XXX' + value + 'XXX_REPLACE_DT_END_XXX';
						}
						return replacedDateValue;
					}
					if ((skipIDAndCDFields !== 1) && (typeof value === 'number') && (upperCaseKey.indexOf('_ID') > -1 || upperCaseKey.indexOf('_CD') > -1)) {
						return value + 0.99;
					}
				}

				return value;
			};

			replacedJSONStr = JSON.stringify(obj, dateAndIdReplacer).replace(/\.99/g, '.0').replace(/XXX_REPLACE_DT_START_XXX/g, '\\/Date(').replace(/XXX_REPLACE_DT_END_XXX/g, ')\\/');

			// If there are any other fields passed in, iterate over them and add .0 to those values
			if (additionalFields && additionalFields.length) {
				for (var i = additionalFields.length; i--;) {
					// Create a regular expression which captures the field along with it's value
					findString = '("' + additionalFields[i] + '"' + ':' + '\\d' + '+)';
					regExpObject = new RegExp(findString, 'gi');

					replacedJSONStr = replacedJSONStr.replace(regExpObject, '$&.0');
				}
			}

			return replacedJSONStr;
		}
	};
	/**
	 * Calculates difference between two dates given and returns string with appropriate units
	 * If no endDate is given it is assumed the endDate is the current date/time
	 *
	 * @param beginDate  Begin <code>Date</code> for Calculation
	 * @param endDate  End <code>Date</code> for Calculation
	 * @param mathFlag  <code>Integer</code> Flag to determine if Math.Ceil or Math.Floor is used defaults to Math.floor 1 =
	 * Floor, 0 = Ceil
	 * @param abbreviateFlag  <code>Boolean</code> to determine if shortened versions of Month,Year,Weeks,Days should be used
	 * such as in the case of a within string
	 */
	function GetDateDiffString(beginDate, endDate, mathFlag, abbreviateFlag) {
		var i18nCore = i18n.discernabu;
		var timeDiff = 0;
		var returnVal = '';
		//Set endDate to current time if it's not passed in
		endDate = (!endDate) ? new Date() : endDate;
		mathFlag = (!mathFlag) ? 0 : mathFlag;
		var one_minute = 1000 * 60;
		var one_hour = one_minute * 60;
		var one_day = one_hour * 24;
		var one_week = one_day * 7;

		var valMinutes = 0;
		var valHours = 0;
		var valDays = 0;
		var valWeeks = 0;
		var valMonths = 0;
		var valYears = 0;
		//time diff in milliseconds
		timeDiff = (endDate.getTime() - beginDate.getTime());

		//Choose if ceiling or floor should be applied
		var mathFunc = null;
		var comparisonFunc = null;
		if (mathFlag == 0) {  //eslint-disable-line eqeqeq
			mathFunc = function(val) {
				return Math.ceil(val);
			};
			comparisonFunc = function(lowerVal, upperVal) {
				return (lowerVal <= upperVal);
			};
		}
		else {
			mathFunc = function(val) {
				return Math.floor(val);
			};
			comparisonFunc = function(lowerVal, upperVal) {
				return (lowerVal < upperVal);
			};
		}

		var calcMonths = function() {
			var removeCurYr = 0;
			var removeCurMon = 0;
			var yearDiff = 0;
			var monthDiff = 0;
			var dayDiff = endDate.getDate();
			if (endDate.getMonth() > beginDate.getMonth()) {
				monthDiff = endDate.getMonth() - beginDate.getMonth();
				if (endDate.getDate() < beginDate.getDate()) {
					removeCurMon = 1;
				}
			}
			else if (endDate.getMonth() < beginDate.getMonth()) {
				monthDiff = 12 - beginDate.getMonth() + endDate.getMonth();
				removeCurYr = 1;
				if (endDate.getDate() < beginDate.getDate()) {
					removeCurMon = 1;
				}
			}
			else if (endDate.getDate() < beginDate.getDate()) {
				removeCurYr = 1;
				monthDiff = 11;
			}

			if (endDate.getDate() >= beginDate.getDate()) {
				dayDiff = endDate.getDate() - beginDate.getDate();
			}

			yearDiff = (endDate.getFullYear() - beginDate.getFullYear()) - removeCurYr;
			//days are divided by 32 to ensure the number will always be less than zero
			monthDiff += (yearDiff * 12) + (dayDiff / 32) - removeCurMon;

			return monthDiff;
		};

		valMinutes = mathFunc(timeDiff / one_minute);
		valHours = mathFunc(timeDiff / one_hour);
		valDays = mathFunc(timeDiff / one_day);
		valWeeks = mathFunc(timeDiff / one_week);
		valMonths = calcMonths();
		valMonths = mathFunc(valMonths);
		valYears = mathFunc(valMonths / 12);

		if (comparisonFunc(valHours, 2))//Less than 2 hours, display number of minutes. Use abbreviation of "mins".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_MINS.replace('{0}', valMinutes)) : (i18nCore.X_MINUTES.replace('{0}', valMinutes));
		else if (comparisonFunc(valDays, 2))//Less than 2 days, display number of hours. Use abbreviation of "hrs".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_HOURS.replace('{0}', valHours)) : (i18nCore.X_HOURS.replace('{0}', valHours));
		else if (comparisonFunc(valWeeks, 2))//Less than 2 weeks, display number of days. Use "days".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_DAYS.replace('{0}', valDays)) : (i18nCore.X_DAYS.replace('{0}', valDays));
		else if (comparisonFunc(valMonths, 2))//Less than 2 months, display number of weeks. Use abbreviation of "wks".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_WEEKS.replace('{0}', valWeeks)) : (i18nCore.X_WEEKS.replace('{0}', valWeeks));
		else if (comparisonFunc(valYears, 2))//Less than 2 years, display number of months. Use abbreviation of "mos".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_MONTHS.replace('{0}', valMonths)) : (i18nCore.X_MONTHS.replace('{0}', valMonths));
		else//Over 2 years, display number of years.  Use abbreviation of "yrs".
			returnVal = abbreviateFlag ? (i18nCore.WITHIN_YEARS.replace('{0}', valYears)) : (i18nCore.X_YEARS.replace('{0}', valYears));

		return (returnVal);
	}

}();

/**
 * @namespace
 */
MP_Util.Doc = function() {
	var isExpandedAll = false;
	var openAccordion = '';
    var compMenuTimeout = null;
	var compMenuDelay = 250;

	return {
		SetupExpandCollapse: function(categoryMeaning) {
			var i18nCore = i18n.discernabu;
			//set up expand collapse for all components
			var body = null;
			var toggleArray = null;
			if(categoryMeaning){
				body = _g(categoryMeaning);
				toggleArray = Util.Style.g('sec-hd-tgl', body, 'span');
			}
			else{
				toggleArray = Util.Style.g('sec-hd-tgl');
			}
			for (var k = 0; k < toggleArray.length; k++) {
				Util.addEvent(toggleArray[k], 'click', MP_Util.Doc.ExpandCollapse);
				var checkClosed = Util.gp(Util.gp(toggleArray[k]));
				if (Util.Style.ccss(checkClosed, 'closed')) {
					toggleArray[k].innerHTML = '+';
					toggleArray[k].title = i18nCore.SHOW_SECTION;
				}
			}
		},
		SetupCompFilters: function(compArray) {
			var comp = null;
			var compArrayLen = compArray.length;
			var hasFilters = false;
			for (var x = 0; x < compArrayLen; x++) {
				comp = compArray[x];
				hasFilters = false;
				for (var y = 0; y < 10; y++) {
					if (comp.getGrouperLabel(y) || comp.getGrouperCatLabel(y)) {
						hasFilters = true;
						break;
					}
				}
				comp.setCompFilters(hasFilters);
				if (comp.hasCompFilters() && comp.isDisplayable()) {
					comp.renderAccordion(comp);
				}
			}
		},
		/**
		 * Create Component Menus
		 * @param {mpComps} mpage components for current view
		 * @param {bool} disablePrsnl boolean to disable personalize section
		 * @param
		 */
		CreateCompMenus: function(mpComps, disablePrsnl) {
	            var setupCustCompMenu = function(curComp, compId, fullId, ns) {
	                curComp.createMainMenu();
	                var compMenu = curComp.getMenu();
	                if (compMenu) {
	                    var themeSelectorId = 'themeSelector' + compId;
	                    var themeSelector = new ThemeSelector(themeSelectorId, compId, fullId, ns);
	                    //
	                    // Put the theme selector at the top of the (currently empty) component menu
	                    //
	                    compMenu.addMenuItem(themeSelector);

	                    var defaultExpandedSelection = new MenuSelection('defaultExpandedSelection' + compId);
	                    defaultExpandedSelection.setLabel(i18n.discernabu.DEFAULT_EXPANDED);
	                    defaultExpandedSelection.setIsSelected(curComp.isExpanded() == 1);  //eslint-disable-line eqeqeq
	                    defaultExpandedSelection.setCloseOnClick(false);
	                    defaultExpandedSelection.setClickFunction(function() {
	                        var isFinalStateExpanded = !curComp.isExpanded();

	                        curComp.setExpandCollapseState(isFinalStateExpanded);
	                        curComp.setExpanded(isFinalStateExpanded ? 1 : 0);

	                        MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(curComp, true);
	                    });
	                    compMenu.addMenuItem(defaultExpandedSelection);

	                    MP_MenuManager.updateMenuObject(compMenu);
	                    var secId = fullId.replace('mainCompMenu', '');
	                    Util.addEvent(_g('mainCompMenu' + secId), 'click', function() {
	                        MP_MenuManager.showMenu(this.id);
	                    });
	                }
	            };

			var setupCompMenu = function(componentId, fullId, isExp, infoInd, infoState) {
				if (_g(fullId)) {
					var optMenu = _g('moreOptMenu' + componentId);
					if (!optMenu) {
						optMenu = Util.cep('div', {
							className: 'opts-menu-content menu-hide',
							id: 'moreOptMenu' + componentId
						});
						var i18nCore = i18n.discernabu;
						var defExpClass = '';
						var infoBtnMsg = i18nCore.INFO_BUTTON;
						var infoClass = '';

						if (isExp) {
							defExpClass = 'opts-menu-def-exp';
						}

						if (infoState) {
							infoClass = 'opts-menu-info-en';
						}

						var optMenuHtml = '<div class="opts-actions-sec" id="optsMenuActions' + componentId + '"></div>';

						if (!disablePrsnl) {
							if (infoInd) {
								optMenuHtml += '<div class="opts-personalize-sec" id="optsMenupersonalize' + componentId + '"><div class="opts-menu-item opts-def-theme" id="optsDefTheme' + componentId + '">' + i18nCore.COLOR_THEME + '</div><div class="opts-menu-item opts-def-state" id="optsDefState' + componentId + '">' + i18nCore.DEFAULT_EXPANDED + '<span class="' + defExpClass + '">&nbsp;</span></div><div class="opts-menu-item opts-personalize-sec-divider" id="optsInfoState' + componentId + '">' + infoBtnMsg + '<span class="' + infoClass + '">&nbsp;</span></div></div>';
							}
							else {
								optMenuHtml += '<div class="opts-personalize-sec" id="optsMenupersonalize' + componentId + '"><div class="opts-menu-item opts-def-theme" id="optsDefTheme' + componentId + '">' + i18nCore.COLOR_THEME + '</div><div class="opts-menu-item opts-def-state" id="optsDefState' + componentId + '">' + i18nCore.DEFAULT_EXPANDED + '<span class="' + defExpClass + '">&nbsp;</span></div></div>';
							}
						}

						optMenu.innerHTML = optMenuHtml;

						Util.ac(optMenu, document.body);
					}
					InitCompOptMenu(optMenu, componentId, false);

					var themeTimeout = null;
					var themeOut = function(e) {
						if (!e) {
							e = window.event;
						}
						var relTarg = e.relatedTarget || e.toElement;
						if (relTarg) {
							themeTimeout = window.setTimeout(function() {
								if (_g('optMenuConfig' + componentId)) {
									Util.Style.acss(_g('optMenuConfig' + componentId), 'menu-hide');
								}
							}, compMenuDelay);
						}
						else {
							if (_g('optMenuConfig' + componentId)) {
								Util.Style.acss(_g('optMenuConfig' + componentId), 'menu-hide');
							}
							return;
						}
					};
					var secId = fullId.replace('mainCompMenu', '');
					Util.addEvent(_g('mainCompMenu' + secId), 'click', function() {
						OpenCompOptMenu(optMenu, secId);
					});

					if (!disablePrsnl) {
						var optDefThemeMenuItem = _g('optsDefTheme' + componentId);

						// when entering the "Color Theme" menu  item...
						// we launch the color theme menu + clear the "close menu" timer
						Util.addEvent(optDefThemeMenuItem, 'mouseenter', function() {
							window.clearTimeout(themeTimeout);
							var configMenu = _g('optMenuConfig' + componentId);
							if (!configMenu) {
								launchThemeMenu(componentId, fullId, secId, this);
							}
							else {
								if (Util.Style.ccss(configMenu, 'menu-hide')) {
									OpenCompOptMenu(configMenu, fullId, this);
								}
							}
						});
						// When entering the component menu container...
						// if we aren't moving into the "Color Theme" menu item, trigger the "close menu" timer
						Util.addEvent(optMenu,'mouseenter', function(e) {
							if (!e) {
								e = window.event;
							}
							var target = e.target || e.srcElement;
							if (!Util.Style.ccss(target, 'opts-def-theme')) {
								themeOut(e);
							}
						});
						// When leaving the "Color Theme" menu item...
						// if we aren't moving into the component menu container or moving into the color themes menu, trigger the "close menu" timer
						Util.addEvent(optDefThemeMenuItem,'mouseleave', function(e) {
							if (!e) {
								e = window.event;
							}
							window.clearTimeout(themeTimeout);
							var relTarg = e.relatedTarget || e.toElement;
							if (relTarg && !Util.Style.ccss(relTarg, 'opts-menu-content') && !Util.Style.ccss(relTarg, 'opts-menu-config-content')) {
								themeOut(e);
							}
						});
						Util.addEvent(_g('optsDefState' + componentId), 'click', function() {
							launchSetState(componentId, this);
						});

						if (infoInd) {
							Util.addEvent(_g('optsInfoState' + componentId), 'click', function() {
								launchInfoSetState(componentId, this);
							});
						}
					}
				}
			};
			var mns = mpComps;
			var mLen = mns.length;
			for (var i = 0; i < mLen; i++) {
				var curComp = mns[i];
				var ns = curComp.m_styles.m_nameSpace;
				var compId = curComp.m_styles.m_componentId;
				var fullId = 'mainCompMenu' + ns + compId;
				var isExp = curComp.isExpanded();
				var infoInd = curComp.hasInfoButton();
				var infoState = curComp.isInfoButtonEnabled();
	                if (ns !== 'cust') {
	                    setupCompMenu(compId, fullId, isExp, infoInd, infoState);
	                }
	                else {
	                    setupCustCompMenu(curComp, compId, fullId, ns);
	                }
	            }
		},
		/**
		 * Hide all Component Menus
		 */
		HideAllCompMenus: function() {
			var mnus = Util.Style.g('opts-menu-content', null, 'div');
			var mnLen = mnus.length;
			for (var m = mnLen; m--; ) {
				if (!Util.Style.ccss(mnus[m], 'menu-hide')) {
					Util.Style.acss(mnus[m], 'menu-hide');
				}
			}
		},
		GetComments: function(par, personnelArray) {
			var com = '',
				recDate = '';
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			for (var j = 0, m = par.COMMENTS.length; j < m; j++) {
				if (personnelArray.length != null) {  //eslint-disable-line eqeqeq
					if (par.COMMENTS[j].RECORDED_DT_TM != '') {  //eslint-disable-line eqeqeq
						recDate = df.formatISO8601(par.COMMENTS[j].RECORDED_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
					if (j > 0) {
						com += '<br />';
					}
					if (par.COMMENTS[j].RECORDED_BY > 0) {
						com += recDate + ' - ' + MP_Util.GetValueFromArray(par.COMMENTS[j].RECORDED_BY, personnelArray).fullName + '<br />' + par.COMMENTS[j].COMMENT_TEXT;
					}
					else {
						com += recDate + '<br />' + par.COMMENTS[j].COMMENT_TEXT;
					}
				}
			}
			return com;
		},
		FinalizeComponent: function(contentHTML, component, countText) {
			var styles = component.getStyles();

			//replace count text
			var rootComponentNode = component.getRootComponentNode();
			//There are certain circumstances where a components DOM element will have been removed.
			//ie. selecting a view from the viewpoint drop down and then selecting another.
			if (rootComponentNode) {
				var totalCount = Util.Style.g('sec-total', rootComponentNode, 'span');
				if(countText){
					//Make sure the count text is not hidden.
					$(totalCount).removeClass('hidden');
					totalCount[0].innerHTML = countText;
				}
				else{
					//If there is no count text to show then hide the element so it doesn't take up space.
					$(totalCount).addClass('hidden');
				}

				//replace content with HTML
				var node = component.getSectionContentNode();
				node.innerHTML = contentHTML;

				//init hovers
				MP_Util.Doc.InitHovers(styles.getInfo(), node, component);

				//init subsection toggles
				MP_Util.Doc.InitSubToggles(node, 'sub-sec-hd-tgl');

				//init scrolling
				//Wrap in timeout to momentarly break the JS processing up and allow the browswer to render.
				setTimeout(function() {
					MP_Util.Doc.InitScrolling(Util.Style.g('scrollable', node, 'div'), component.getScrollNumber(), '1.6');
				}, 0);

				//Check to see if the component has an error message displayed
				var errorElement = $(rootComponentNode).find('.error-message');
				if (errorElement.length) {
					//Add an error icon to the component title
					$(rootComponentNode).find('.sec-title>span:first-child').addClass('error-icon-component');
					//Ensure the bottom border on the error message is red and the padding is consistent
					$(errorElement).css('border', '1px solid #C00').css('padding', '2px 4px');
					//Fire and event to inform any listener that the component has errored
					CERN_EventListener.fireEvent(component, component, EventListener.EVENT_ERROR_UPDATE, {
								'error': true
							});
				}
				else{
					//Remove the error icon in the component title
					$(rootComponentNode).find('.sec-title>span:first-child').removeClass('error-icon-component');
					//Fire and event to inform any listener that the component has not errored
					CERN_EventListener.fireEvent(component, component, EventListener.EVENT_ERROR_UPDATE, {
								'error': false
							});
				}

				//Add the Gap Check Indicators to the component based on the bedrock settings
				if (component.getGapCheckRequiredInd()) {
					var disclaimerContainer = null;
					var disclaimerBannerObj = null;
					disclaimerContainer = $(rootComponentNode).find('.disclaimer-text');
					if (!disclaimerContainer.length) {
						disclaimerBannerObj = component.createComponentDisclaimerContainer();
						var disclaimerMessageHTML = disclaimerBannerObj.render();
						//Add a class to Alert Banner to differentiate it from other banners added to the component
						disclaimerContainer = $(disclaimerMessageHTML).addClass('disclaimer-text');
						var contentNodeHeader = $(rootComponentNode).find('H2')[0];
						$(contentNodeHeader).after(disclaimerContainer);
						//attach event to the close button
						disclaimerBannerObj.attachEvents();
					}
					component.updateComponentRequiredIndicator();
				}
			}

			//notify the aggregate timer that the component has finished loading
			component.notifyAggregateTimer();
		},
		/**
		 * Formats the content to the appropriate height and enables scrolling
		 * @param {node} content : The content to be formatted
		 * @param {int} num : The approximate number of items to display face up
		 * @param {float} ht : The total line height of an item
		 */
		InitScrolling: function(content, num, ht) {
			for (var k = 0; k < content.length; k++) {
				MP_Util.Doc.InitSectionScrolling(content[k], num, ht);
			}
		},
		/**
		 * Formats the section to the appropriate height and enables scrolling
		 * @param {node} sec : The section to be formatted
		 * @param {int} num : The approximate number of items to display face up
		 * @param {float} ht : The total line height of an item
		 */
		InitSectionScrolling: function(sec, num, ht) {
			var th = num * ht;
			var totalHeight = th + 'em';

			sec.style.maxHeight = totalHeight;
			sec.style.overflowY = 'auto';
			sec.style.overflowX = 'hidden';
		},
		InitHovers: function(trg, par, component) {
			var gen = Util.Style.g(trg, par, 'DL');

			for (var i = 0, l = gen.length; i < l; i++) {
				var m = gen[i];
				if (m) {
					var nm = Util.gns(Util.gns(m));
					if (nm) {
						if (Util.Style.ccss(nm, 'hvr')) {
							hs(m, nm, component);
						}
					}
				}
			}
		},
		InitSubToggles: function(par, tog) {
			var i18nCore = i18n.discernabu;
			var toggleArray = Util.Style.g(tog, par, 'span');
			for (var k = 0; k < toggleArray.length; k++) {
				Util.addEvent(toggleArray[k], 'click', MP_Util.Doc.ExpandCollapse);
				var checkClosed = Util.gp(Util.gp(toggleArray[k]));
				if (Util.Style.ccss(checkClosed, 'closed')) {
					toggleArray[k].innerHTML = '+';
					toggleArray[k].title = i18nCore.SHOW_SECTION;
				}
			}
		},


		/**
		 * Adds the title to the page.
		 * @param {String} title The title of the page to display
		 * @param {Object} bodyTag The body tag associated to the HTML document
		 * @param {Boolean} debugInd Indicator denoting if the mpage should run in debug mode.
		 * @param {Boolean} custInd Indicator denoting if the 'customize' option should be made available to the user for the given layout
		 * @param {String} helpFile The string name of the help file to associate to the page.
		 * @param {String} helpURL The String name of the help file URL to associate to the page.
		 * @param {Object} criterion The object associated to the criterion data
		 * @param {String} categoryMeaning The String name of the MPages View
		 */
		AddPageTitle: function(title, bodyTag, debugInd, custInd, anchorArray, helpFile, helpURL, criterion, categoryMeaning) {
			var i18nCore = i18n.discernabu;
			var ar = [];
			var imgSource = criterion.static_content + '/images/3865_16.gif';
			if (categoryMeaning) {
				title = '';
				bodyTag = _g(categoryMeaning);
				bodyTag.innerHTML = '';
			}
			else {
				if (bodyTag) {
					bodyTag = document.body;
				}
			}
			ar.push('<div class=\'pg-hd\'>');
			ar.push('<h1><span class=\'pg-title\'>', title, '</span></h1><span id=\'pageCtrl', criterion.category_mean, '\' class=\'page-ctrl\'>');

			//'as of' date is always to the far left of items
			if (categoryMeaning) {
				var df = MP_Util.GetDateFormatter();
				ar.push('<span class=\'other-anchors\'>', i18nCore.AS_OF_TIME.replace('{0}', df.format(new Date(), mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS)), '</span>');
			}
			if (anchorArray) {
				for (var x = 0, xl = anchorArray.length; x < xl; x++) {
					ar.push('<span class=\'other-anchors\'>' + anchorArray[x] + '</span>');
				}
			}

			if (custInd || categoryMeaning) {//customizable single view or in a view point
				var pageMenuId = 'pageMenu' + criterion.category_mean;
				ar.push('<span id=\'', pageMenuId, '\' class=\'page-menu\'>&nbsp;</span>');
			}
			ar.push('</span></div>');
			bodyTag.innerHTML += ar.join('');
			return;
		},
		/**
		 * Launches the help file in a new modal window
		 * @param {String} HelpURL The String name of the help file  to associate to the page.
		 */
		LaunchHelpWindow: function(helpURL) {
			var wParams = 'left=0,top=0,width=1200,height=700,toolbar=no';
			logger.logCCLNewSessionWindowInfo(null, helpURL, 'mp_core.js', 'LaunchHelpWindow');
			CCLNEWSESSIONWINDOW(helpURL, '_self', wParams, 0, 1);
			Util.preventDefault();
		},
		/**
		 * @deprecated - This function is no longer valid and should not be used
		 */
		AddCustomizeLink: function(criterion) {
			var i18nCore = i18n.discernabu;
			var custNode = _g('custView' + criterion.category_mean);
			if (custNode) {
				//The code below has been removed since the customize option is no longer in use.  Work still needs to be done
				//To remove this function from all locations where AddCustomLink is called.
				logger.logWarn('AddCustomizeLink is a deprecated function and should not be utilized');
			}
		},
		ExpandCollapse: function() {
			var i18nCore = i18n.discernabu;
			var gpp = Util.gp(Util.gp(this));
			if (Util.Style.ccss(gpp, 'closed')) {
				Util.Style.rcss(gpp, 'closed');
				this.innerHTML = '-';
				this.title = i18nCore.HIDE_SECTION;
			}
			else {
				Util.Style.acss(gpp, 'closed');
				this.innerHTML = '+';
				this.title = i18nCore.SHOW_SECTION;
			}
		},
		HideHovers: function() {
			var hovers = Util.Style.g('hover', document.body, 'DIV');
			for (var i = hovers.length; i--; ) {
				if (Util.gp(hovers[i]).nodeName == 'BODY') {  //eslint-disable-line eqeqeq
					hovers[i].style.display = 'none';
					Util.de(hovers[i]);
				}
			}
		},
		ReplaceSubTitleText: function(component, text) {
			var lookbackDisplay = $('#lookbackDisplay' + component.getStyles().getId());
			if(lookbackDisplay.length) {
				lookbackDisplay.html(text);
			}
		},
		ReInitSubTitleText: function(component) {
			if (component.getScope() > 0) {
				var lookbackDisplay = $('#lookbackDisplay' + component.getStyles().getId());
				if(lookbackDisplay.length) {
					lookbackDisplay.html(CreateSubTitleText(component));
				}
			}
		},
		/*Copyright (c) 2006-2010 Paranoid Ferret Productions.  All rights reserved.

		 Developed by: Paranoid Ferret Productions
		 http://www.paranoidferret.com

		 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
		 CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
		 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
		 WITH THE SOFTWARE.*/

		RunAccordion: function(index) {
			var titleAr = [];
			var nID = 'Accordion' + index + 'Content';
			var TimeToSlide = 100.0;
			var titleDiv = _g('Accordion' + index + 'Title');
			var containerDiv = _g('AccordionContainer' + index);
			var component = MP_Util.GetCompObjById(index);
			var location = component.getCriterion().static_content;

			//Adjust the pull tab image
			if (Util.Style.ccss(titleDiv, 'Expanded')) {
				Util.Style.rcss(titleDiv, 'Expanded');
				Util.Style.rcss(containerDiv, 'Expanded');
			}
			else {
				Util.Style.acss(titleDiv, 'Expanded');
				Util.Style.acss(containerDiv, 'Expanded');
			}

			if (openAccordion == nID) { //eslint-disable-line eqeqeq
				nID = '';
			}

			setTimeout('MP_Util.Doc.Animate(' + new Date().getTime() + ',' + TimeToSlide + ',\'' + openAccordion + '\',\'' + nID + '\',' + index + ')', 33);
			openAccordion = nID;
		},
		Animate: function(lastTick, timeLeft, closingId, openingId, compID) {
			var TimeToSlide = timeLeft;
			var curTick = new Date().getTime();
			var elapsedTicks = curTick - lastTick;
			var ContentHeight = 275.0;

			var opening = (openingId == '') ? null : _g(openingId);  //eslint-disable-line eqeqeq
			var closing = (closingId == '') ? null : _g(closingId);  //eslint-disable-line eqeqeq

			if (timeLeft <= elapsedTicks) {
				if (opening) {
					opening.style.display = 'block';
					opening.style.height = ContentHeight + 'px';
				}

				if (closing) {
					closing.style.display = 'none';
					closing.style.height = '0px';
					var filterListAr = Util.Style.g('acc-filter-list-item' + compID);
					var filtersSelected = MP_Util.Doc.GetSelected(filterListAr);
					//Loop through and get all the values, which are the event sets, and then refresh the component
				}
				return;
			}

			timeLeft -= elapsedTicks;
			var newClosedHeight = Math.round((timeLeft / TimeToSlide) * ContentHeight);

			if (opening) {
				if (opening.style.display != 'block') {  //eslint-disable-line eqeqeq
					opening.style.display = 'block';
					opening.style.height = (ContentHeight - newClosedHeight) + 'px';
				}
			}
			if (closing) {
				closing.style.height = newClosedHeight + 'px';
			}

			setTimeout('MP_Util.Doc.Animate(' + curTick + ',' + timeLeft + ',\'' + closingId + '\',\'' + openingId + '\',' + compID + ')', 33);
		},
		GetSelected: function(opt) {
			var selected = [];
			var index = 0;
			var optLen = opt.length;
			for (var intLoop = 0; intLoop < optLen; intLoop++) {
				if (opt[intLoop].selected) {
					index = selected.length;
					selected[index] = {};
					selected[index].value = opt[intLoop].value;
					selected[index].index = intLoop;
				}
			}
			return selected;
		},
		/* Reset Layout functionality*/
		ResetLayoutSettings: function(mPageObj) {
				var componentSettings = mPageObj.getViewSettings().BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for Component Settings
				var components = mPageObj.getComponents();
				var tempComp = null;
				var tempCompSettings = {};
				var x = 0;
				//Create a map so we dont have to search the componentSettings more than once
				var componentMap = {};
				for(x = componentSettings.length; x--; ){
					componentMap[componentSettings[x].R_MN] = componentSettings[x]; //R_MN is shorthand for Report Mean
				}

				//Grab the settings from the componentMap and reset the sequence and row to what is originally defined in bedrock
				for(x = components.length; x--; ){
					 tempComp = components[x];
					 tempCompSettings  = componentMap[tempComp.getReportMean()];
					 components[x].setSequence(tempCompSettings.R_SQ); //R_SQ is shorthand for Row Sequence
					 components[x].setColumn(tempCompSettings.C_SQ); //C_SQ is shorthand for Row Sequence
				}

				var criterion = mPageObj.getCriterion();
				//Show the cursor as busy
				$('body').css('cursor', 'wait');
				//This call is used to update all of the component's settings before refreshing the page.
				MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(components);

				//Refresh the Page or Viewpoint
				CERN_Platform.refreshMPage();
		}
	};


	function launchThemeMenu(componentId, fullId, secId, that) {
		var i18nCore = i18n.discernabu;
		var optMenu = _g('optMenuConfig' + componentId);
		if (!optMenu) {
			optMenu = Util.cep('div', {
				'className': 'opts-menu-config-content menu-hide',
				'id': 'optMenuConfig' + componentId
			});
			var optMenuJsHTML = [];
			optMenuJsHTML.push('<div title = \'', i18nCore.COLOR_STANDARD, '\' class=\'opts-menu-config-item opt-config-mnu-lightgrey\' data-color=\'lightgrey\' id=\'optConfigMnuLightGrey', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_BROWN, '\' class=\'opts-menu-config-item opt-config-mnu-brown\' data-color=\'brown\' id=\'optConfigMnuBrown', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_CERNER_BLUE, '\' class=\'opts-menu-config-item opt-config-mnu-cernerblue\' data-color=\'cernerblue\' id=\'optConfigMnuCernerBlue', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_DARK_GREEN, '\' class=\'opts-menu-config-item opt-config-mnu-darkgreen\' data-color=\'darkgreen\' id=\'optConfigMnuDarkGreen', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_GREEN, '\' class=\'opts-menu-config-item opt-config-mnu-green\' data-color=\'green\' id=\'optConfigMnuGreen', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_GREY, '\' class=\'opts-menu-config-item opt-config-mnu-grey\' data-color=\'grey\' id=\'optConfigMnuGrey', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_LIGHT_BLUE, '\' class=\'opts-menu-config-item opt-config-mnu-lightblue\' data-color=\'lightblue\' id=\'optConfigMnuLightBlue', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_NAVY, '\' class=\'opts-menu-config-item opt-config-mnu-navy\' data-color=\'navy\' id=\'optConfigMnuNavy', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_ORANGE, '\' class=\'opts-menu-config-item opt-config-mnu-orange\' data-color=\'orange\' id=\'optConfigMnuOrange', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_PINK, '\' class=\'opts-menu-config-item opt-config-mnu-pink\' data-color=\'pink\' id=\'optConfigMnuPink', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_PURPLE, '\' class=\'opts-menu-config-item opt-config-mnu-purple\' data-color=\'purple\' id=\'optConfigMnuPurple', componentId, '\'></div>', '<div title = \'', i18nCore.COLOR_YELLOW, '\' class=\'opts-menu-config-item opt-config-mnu-yellow\' data-color=\'yellow\' id=\'optConfigMnuYellow', componentId, '\'></div>');

			optMenu.innerHTML = optMenuJsHTML.join('');

			Util.ac(optMenu, document.body);
			//actual contents of the menu are appended to body and positioned in launchOptMenu

			Util.addEvent(_g('optMenuConfig' + componentId), 'click', function(e) {
				var target = e.target || e.srcElement;
				var color = target.getAttribute('data-color');
				changeThemeColor(componentId, color, secId);
			});

			InitCompOptMenu(optMenu, componentId, true);
		}

		OpenCompOptMenu(optMenu, fullId, that);
	}

	function changeThemeColor(componentId, color, styleId) {
		var section = _g(styleId);
		if (section) {
			var colorString = 'brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow';
			//a color is found in the class name so replace it with ""
			if (colorString.indexOf(color) >= 0) {
				var colorRegExp = /brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow/;
				section.className = section.className.replace(colorRegExp, '');
			}

			//add the new color so it changes for the user
			Util.Style.acss(section, color);
			var component = MP_Util.GetCompObjById(componentId);
			component.setCompColor(color);
			//add the color to the component properties
			setTimeout(function() {
				MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, color, null, false);
			}, 0);
		}
	}

	function launchSetState(componentId, defStateEl) {
		var component = MP_Util.GetCompObjById(componentId);
		var curExpColState = component.isExpanded();
		component.setExpandCollapseState(!curExpColState);
		var checkSpan = _gbt('span', defStateEl)[0];

		if (!curExpColState) {
			if (checkSpan) {
				Util.Style.acss(checkSpan, 'opts-menu-def-exp');
			}
			setTimeout(function() {
				MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, '', '1', false);
			}, 0);
		}
		else {
			if (checkSpan) {
				Util.Style.rcss(checkSpan, 'opts-menu-def-exp');
			}
			setTimeout(function() {
				MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, '', '0', false);
			}, 0);
		}
	}

	function launchInfoSetState(componentId, infoStateEl) {
		//false = Disabled, true = Enabled
		var i18nCore = i18n.discernabu;
		var component = MP_Util.GetCompObjById(componentId);
		var curInfoState = component.isInfoButtonEnabled();
		var checkSpan = _gbt('span', infoStateEl)[0];
		//component.setIsInfoButtonEnabled(!curInfoState);
		if (curInfoState) {
			component.setIsInfoButtonEnabled(0);
		}
		else {
			component.setIsInfoButtonEnabled(1);
		}

		if (!curInfoState) { //Currently disabled, turning to enabled
			if (checkSpan) {
				Util.Style.acss(checkSpan, 'opts-menu-info-en');
				//Call the component function to show info button and allow click event
				component.showInfoButton(component,true);
				setTimeout(function() {
				MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, '', '', false,'1');
			}, 0);
			}
		}
		else {
			if (checkSpan) {
				Util.Style.rcss(checkSpan, 'opts-menu-info-en');
				//Call the component function to remove info button
				component.showInfoButton(component,false);
				setTimeout(function() {
				MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, '', '', false,'0');
			}, 0);
			}
		}
	}

	function InitPageOptMenu(inMenu, componentId, isSubMenu) {
		var closeMenu = function(e) {
			if (!e) {
				e = window.event;
			}

			var resetPageMenu = function() {
				var pageMenu = _g(componentId);
				if (Util.Style.ccss(pageMenu, 'page-menu-open')) {
					Util.Style.rcss(pageMenu, 'page-menu-open');
				}
			};
			var relTarg = e.relatedTarget || e.toElement;
			var mainMenu = _g('moreOptMenu' + componentId);

			if (isSubMenu) {
				var target = e.target || e.srcElement;
			}
			if (relTarg) {
				if (!Util.Style.ccss(relTarg, 'opts-menu-layout-content')) {
					if (mainMenu) {
						Util.Style.acss(mainMenu, 'menu-hide');
						resetPageMenu();
					}
					if (isSubMenu) {
						if (Util.Style.ccss(target, 'opts-menu-layout-content') && !Util.Style.ccss(relTarg, 'opts-menu-content')) {
							if (_g('moreOptMenu' + componentId)) {
								Util.Style.acss(_g('moreOptMenu' + componentId), 'menu-hide');
							}
						}
					}
					if (_g('optMenuConfig' + componentId)) {
						Util.Style.acss(_g('optMenuConfig' + componentId), 'menu-hide');
					}
				}
			}
			else {
				if (mainMenu) {
					Util.Style.acss(mainMenu, 'menu-hide');
					resetPageMenu();
				}
			}
			Util.cancelBubble(e);
		};
		$(inMenu).mouseleave(closeMenu);
	}

	function InitCompOptMenu(inMenu, componentId, isSubMenu) {
		var closeMenu = function(e) {
			if (!e) {
				e = window.event;
			}
			var relTarg = e.relatedTarget || e.toElement;
			var mainMenu = _g('moreOptMenu' + componentId);
			if (isSubMenu) {
				var target = e.target || e.srcElement;
			}
			if (relTarg) {
				if (!Util.Style.ccss(relTarg, 'opts-menu-config-content')) {
					compMenuTimeout = window.setTimeout(function() {
						if (mainMenu) {
							if (!Util.Style.ccss(relTarg, 'opts-menu-content')) {
								Util.Style.acss(mainMenu, 'menu-hide');
							}
						}
						if (isSubMenu) {
							Util.Style.acss(inMenu, 'menu-hide');
							if (Util.Style.ccss(target, 'opts-menu-content') && !Util.Style.ccss(relTarg, 'opts-menu-content')) {
								if (_g('moreOptMenu' + componentId)) {
									Util.Style.acss(_g('moreOptMenu' + componentId), 'menu-hide');
								}
							}
						}
						if (_g('optMenuConfig' + componentId)) {
							Util.Style.acss(_g('optMenuConfig' + componentId), 'menu-hide');
						}
					}, compMenuDelay);

				}
			}
			else {
				if (mainMenu) {
					Util.Style.acss(mainMenu, 'menu-hide');
				}
			}
			Util.cancelBubble(e);
		};
		$(inMenu).mouseleave(closeMenu);
		$(inMenu).mouseenter(function() {
			window.clearTimeout(compMenuTimeout);
		});
	}

	/**
	 * Open the options menu within the new order entry component
	 * @param {node} menu : The menu node
	 * @param {string} sectionId : The html id of the section containing the menu
	 */
	function OpenCompOptMenu(menu, sectionId, that) {
		var verticalOffset = 30;
		if (Util.Style.ccss(menu, 'menu-hide')) {
			Util.preventDefault();
			Util.Style.rcss(menu, 'menu-hide');

			if (that) {
				var ofs = Util.goff(that);
				var moreMenu = Util.gns(that);
				var thisWidth = that.offsetWidth;
				var divOfs = menu.offsetWidth;

				var vpOfs = ofs[0] - divOfs;
				if (vpOfs > 0) {
					menu.style.left = (vpOfs - 2) + 'px';
					//  Util.Style.acss(mpDiv, 'hml-mpd-lt');
				}
				else {
					menu.style.left = (ofs[0] + thisWidth + 6) + 'px';
					//  Util.Style.acss(mpDiv, 'hml-mpd-rt');

				}
				menu.style.top = (ofs[1] - 5) + 'px';
			}
			else {
				var menuId = '#mainCompMenu' + sectionId;
				var menuElement = $(menuId);
				if (menuElement.length) {
					//Component menu logic
					menu.style.left = ($(menuElement).offset().left - 125) + 'px';
					menu.style.top = ($(menuElement).offset().top + 18) + 'px';
				}
				else {
					//Page level menu logic
					var vp = gvs();
					var sec = _g(sectionId);
					var ofs = Util.goff(sec);
					menu.style.left = (ofs[0] + sec.offsetWidth - menu.offsetWidth) + 'px';
					menu.style.top = (ofs[1] + verticalOffset) + 'px';
				}
			}
		}
		else {
			Util.Style.acss(menu, 'menu-hide');
		}
	}


	function GetComponentArray(components) {
		var grpAr = [];
		var colAr = [];
		var rowAr = [];
		var curCol = -1;
		var curGrp = -1;

		var sHTML = [];

		//first layout the group/columns/rows of components
		if (components != null) {  //eslint-disable-line eqeqeq
			components.sort(SortMPageComponents);

			for (var x = 0, xl = components.length; x < xl; x++) {
				var component = components[x];
				if (CERN_MPageComponents == null)  //eslint-disable-line eqeqeq
					CERN_MPageComponents = [];
				CERN_MPageComponents.push(component);

				if (component.isDisplayable()) {//based on filter logic, only display if criteria is met
					var compGrp = component.getPageGroupSequence();
					var compCol = component.getColumn();

					if (compGrp != curGrp) {  //eslint-disable-line eqeqeq
						curCol = -1;
						colAr = [];
						grpAr.push(colAr);
						curGrp = compGrp;
					}

					if (compCol != curCol) {  //eslint-disable-line eqeqeq
						rowAr = [];
						colAr.push(rowAr);
						curCol = compCol;
					}
					rowAr.push(component);
				}
			}
		}
		return grpAr;
	}

	function CreateSubTitleText(component) {
		var i18nCore = i18n.discernabu;
		var subTitleText = '';
		var scope = component.getScope();
		var lookbackDays = component.getLookbackDays();
		var lookbackUnits = (lookbackDays > 0) ? lookbackDays : component.getLookbackUnits();
		var lookbackFlag = (lookbackDays > 0) ? 2 : component.getLookbackUnitTypeFlag();

		if (scope > 0) {
			if (lookbackFlag > 0 && lookbackUnits > 0) {
				var replaceText = '';
				switch(lookbackFlag) {
					case 1:
						replaceText = i18nCore.LAST_N_HOURS.replace('{0}', lookbackUnits);
						break;
					case 2:
						replaceText = i18nCore.LAST_N_DAYS.replace('{0}', lookbackUnits);
						break;
					case 3:
						replaceText = i18nCore.LAST_N_WEEKS.replace('{0}', lookbackUnits);
						break;
					case 4:
						replaceText = i18nCore.LAST_N_MONTHS.replace('{0}', lookbackUnits);
						break;
					case 5:
						replaceText = i18nCore.LAST_N_YEARS.replace('{0}', lookbackUnits);
						break;
				}

				switch(scope) {
					case 1:
						subTitleText = i18nCore.ALL_N_VISITS.replace('{0}', replaceText);
						break;
					case 2:
						subTitleText = i18nCore.SELECTED_N_VISIT.replace('{0}', replaceText);
						break;
				}

			}
			else {
				switch(scope) {
					case 1:
						subTitleText = i18nCore.All_VISITS;
						break;
					case 2:
						subTitleText = i18nCore.SELECTED_VISIT;
						break;
				}
			}
		}
		return subTitleText;
	}
}();

/**
 * @namespace
 */
MP_Util.Measurement = function() {
	var m_nf = null;
	return {
		GetString: function(result, codeArray, dateMask, excludeUOM) {
			var obj = ( result instanceof MP_Core.Measurement) ? result.getResult() : MP_Util.Measurement.GetObject(result, codeArray);
			if ( obj instanceof MP_Core.QuantityValue) {
				if (excludeUOM) {
					return obj.getValue();
				}
				return obj.toString();
			}
			else if ( obj instanceof Date) {
				return obj.format(dateMask);
			}
			return obj;
		},
		GetObject: function(result, codeArray) {
			switch (result.CLASSIFICATION.toUpperCase()) {
				case 'QUANTITY_VALUE':
					return GetQuantityValue(result, codeArray);
				case 'STRING_VALUE':
					return (GetStringValue(result));
				case 'DATE_VALUE':
					//we are currently not returning any date_value results. a common method shall be implemented if/when necessary
					return (GetDateValue(result));
				case 'CODIFIED_VALUES':
				case 'CODE_VALUE':
					return (GetCodedResult(result));
				case 'ENCAPSULATED_VALUE':
					return (GetEncapsulatedValue(result));
			}
		},
		/**
		 * @param {Object} num Numeric to format
		 * @param {Object} dec Number of decimal places to retain.
		 * @deprecated Use mp_formatter.NumericFormatter.
		 */
		SetPrecision: function(num, dec) {
			var nf = MP_Util.GetNumericFormatter();
			//'^' to not comma seperate values, and '.' for defining the precision
			return nf.format(num, '^.' + dec);
		},
		GetModifiedIcon: function(result) {
			return (result.isModified()) ? '<span class=\'res-modified\'>&nbsp;</span>' : '';
		},
		GetNormalcyClass: function(oMeasurement) {
			var normalcy = 'res-normal';
			var nc = oMeasurement.getNormalcy();
			if (nc != null) {  //eslint-disable-line eqeqeq
				var normalcyMeaning = nc.meaning;
				if (normalcyMeaning != null) {  //eslint-disable-line eqeqeq
					if (normalcyMeaning === 'LOW') {
						normalcy = 'res-low';
					}
					else if (normalcyMeaning === 'HIGH') {
						normalcy = 'res-high';
					}
					else if (normalcyMeaning === 'CRITICAL' || normalcyMeaning === 'EXTREMEHIGH' || normalcyMeaning === 'PANICHIGH' || normalcyMeaning === 'EXTREMELOW' || normalcyMeaning === 'PANICLOW' || normalcyMeaning === 'VABNORMAL' || normalcyMeaning === 'POSITIVE') {
						normalcy = 'res-severe';
					}
					else if (normalcyMeaning === 'ABNORMAL') {
						normalcy = 'res-abnormal';
					}
				}
			}
			return normalcy;
		},
		GetNormalcyResultDisplay: function(oMeasurement, excludeUOM) {
			var ar = ['<span class=\'', MP_Util.Measurement.GetNormalcyClass(oMeasurement), '\'><span class=\'res-ind\'>&nbsp;</span><span class=\'res-value\'>', GetEventViewerLink(oMeasurement, MP_Util.Measurement.GetString(oMeasurement, null, 'longDateTime2', excludeUOM)), '</span>', MP_Util.Measurement.GetModifiedIcon(oMeasurement), '</span>'];
			return ar.join('');
		}
	};
	function GetEventViewerLink(oMeasurement, sResultDisplay) {
		var params = [oMeasurement.getPersonId(), oMeasurement.getEncntrId(), oMeasurement.getEventId(), '"EVENT"'];
		var ar = ['<a onclick=\'MP_Util.LaunchClinNoteViewer(', params.join(','), '); return false;\' href=\'#\'>', sResultDisplay, '</a>'];
		return ar.join('');
	}

	function GetEncapsulatedValue(result) {
		var ar = [];
		var encap = result.ENCAPSULATED_VALUE;
		if (encap && encap.length > 0) {
			for (var n = 0, nl = encap.length; n < nl; n++) {
				var txt = encap[n].TEXT_PLAIN;
				if (txt != null && txt.length > 0)  //eslint-disable-line eqeqeq
					ar.push(txt);
			}
		}
		return ar.join('');
	}

	function GetQuantityValue(result, codeArray) {
		var qv = new MP_Core.QuantityValue();
		qv.init(result, codeArray);
		return qv;
	}

	function GetDateValue(result) {
		for (var x = 0, xl = result.DATE_VALUE.length; x < xl; x++) {
			var date = result.DATE_VALUE[x];
			if (date.DATE != '') {  //eslint-disable-line eqeqeq
				var dateTime = new Date();
				dateTime.setISO8601(date.DATE);
				return dateTime;
			}
		}
		return null;
	}

	function GetCodedResult(result) {
		var cdValue = result.CODE_VALUE;
		var ar = [];
		for (var n = 0, nl = cdValue.length; n < nl; n++) {
			var values = cdValue[n].VALUES;
			for (var p = 0, pl = values.length; p < pl; p++) {
				ar.push(values[p].SOURCE_STRING);
			}
			var sOther = cdValue[n].OTHER_RESPONSE;
			if (sOther != '')  //eslint-disable-line eqeqeq
				ar.push(sOther);
		}
		return ar.join(', ');
	}

	function GetStringValue(result) {
		var strValue = result.STRING_VALUE;
		var ar = [];
		for (var n = 0, nl = strValue.length; n < nl; n++) {
			ar.push(strValue[n].VALUE);
		}
		return ar.join(', ');
	}

}();


/* Listener Event Class */
/*
* Copyright (c) 2007 	Josh Davis ( http://joshdavis.wordpress.com )
*
* Licensed under the MIT License ( http://www.opensource.org/licenses/mit-license.php ) as follows:
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

/**
 * Create a new instance of Event.
 *
 * @classDescription	This class creates a new Event.
 * @return {Object}	Returns a new Event object.
 * @constructor
 */
function EventListener() {
	this.events = [];
	this.builtinEvts = [];
}

/**
 * Gets the index of the given action for the element
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @return {Number} Returns an integer.
 */
EventListener.prototype.getActionIdx = function(obj, evt, action, binding) {
	if (obj && evt) {

		var curel = this.events[obj][evt];
		if (curel) {
			var len = curel.length;
			for (var i = len - 1; i >= 0; i--) {
				if (curel[i].action == action && curel[i].binding == binding) { //eslint-disable-line eqeqeq
					return i;
				}
			}
		}
		else {
			return -1;
		}
	}
	return -1;
};

/**
 * Adds a listener
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @return {null} Returns null.
 */
EventListener.prototype.addListener = function(obj, evt, action, binding) {
	if (this.events[obj]) {
		if (this.events[obj][evt]) {
			if (this.getActionIdx(obj, evt, action, binding) == -1) { //eslint-disable-line eqeqeq
				var curevt = this.events[obj][evt];
				curevt[curevt.length] = {
					action: action,
					binding: binding
				};
			}
		}
		else {
			this.events[obj][evt] = [];
			this.events[obj][evt][0] = {
				action: action,
				binding: binding
			};
		}
	}
	else {
		this.events[obj] = [];
		this.events[obj][evt] = [];
		this.events[obj][evt][0] = {
			action: action,
			binding: binding
		};
	}
};

/**
 * Removes a listener
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @return {null} Returns null.
 */
EventListener.prototype.removeListener = function(obj, evt, action, binding) {
	if (this.events[obj]) {
		if (this.events[obj][evt]) {
			var idx = this.getActionIdx(obj, evt, action, binding);
			if (idx >= 0) {
				this.events[obj][evt].splice(idx, 1);
			}
		}
	}
};
/**
 * Removes all listeners for a given object with given binding
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {Object} binding The object to scope the action to.
 * @return {null} Returns null.
 */
EventListener.prototype.removeAllListeners = function(obj, binding) {
	if (this.events[obj]) {
		for (var el = this.events[obj].length; el--; ) {
			if (this.events[obj][el]) {
				for (var ev = this.events[obj][el].length; ev--; ) {
					if (this.events[obj][el][ev].binding == binding) { //eslint-disable-line eqeqeq
						this.events[obj][el].splice(ev, 1);
					}
				}
			}
		}
	}
};

/**
 * Fires an event
 *
 * @memberOf Event
 * @param e A builtin event passthrough
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Object} args The argument attached to the event.
 * @return {null} Returns null.
 */
EventListener.prototype.fireEvent = function(e, obj, evt, args) {
	if (!e) {
		e = window.event;
	}

	if (obj && this.events) {
		var evtel = this.events[obj];
		if (evtel) {
			var curel = evtel[evt];
			if (curel) {
				for (var act = curel.length; act--; ) {
					var action = curel[act].action;
					if (curel[act].binding) {
						action = action.bind(curel[act].binding);
					}
					action(e, args);
				}
			}
		}
	}
};
CERN_EventListener = new EventListener();

//Constants for event Listener
EventListener.EVENT_CLINICAL_EVENT = 1;
EventListener.EVENT_ORDER_ACTION = 2;
EventListener.EVENT_ADD_DOC = 3;
EventListener.EVENT_PREGNANCY_EVENT = 4;
EventListener.EVENT_COMP_CUSTOMIZE = 5;
EventListener.EVENT_COUNT_UPDATE = 6;
EventListener.EVENT_CRITICAL_UPDATE = 7;
EventListener.EVENT_ERROR_UPDATE = 8;
EventListener.EVENT_SCRATCHPAD_COUNT_UPDATE = 9;
EventListener.EVENT_SCRATCHPAD_UPDATES_COMPONENT = 10;
EventListener.EVENT_SCRATCHPAD_REMOVED_ORDER_ACTION = 11;
EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION = 12;
EventListener.EVENT_REMOVE_PERSONAL_FAV_FOLDER = 13;
EventListener.EVENT_QOC_VIEW_VENUE_CHANGED = 14;
EventListener.EVENT_SCROLL = 15;
EventListener.EVENT_NAVIGATOR_ERR = 16;
EventListener.EVENT_CONDITIONS_UPDATE = 17;
EventListener.HEALTH_PLANS_RETRIEVED = 18;
EventListener.EVENT_DIAGNOSIS_ADDED = 19;
//Satisfier Event for Gap Check
EventListener.EVENT_SATISFIER_UPDATE = 20;
//Event for the action in contextual view.
EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW = 21;
/*global Util, RTMSTimer, ComponentScriptRequest, ActiveXObject*/
if(typeof MPage === "undefined") {
	MPage = {
		ActiveComponents: [],
		Properties: {
			mine: "mine",
			personId: 0.0,
			encounter: 0.0,
			userId: 0.0,
			pprCd: 0.0,
			posCd: 0.0
		},
		Event: { //Not defined in the standard thus far, so not implemented
			/*eslint-disable no-unused-vars*/
			registerEvent: function(event, listener, component) {
				return null;
			},
			triggerEvent: function(event) {
				return null;
			},
			removeEvent: function(event, listener) {
				return null;
			}
			/*eslint-enable no-unused-vars*/
		},
		namespace: function(name) {
			var parts = name.split(".");
			var result = window;
			while(parts.length) {
				var part = parts.shift();
				result = result[part] = result[part] || {};
			}
			return result;
		},
		/**
		 * registerUnloadEvent function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		registerUnloadEvent: function() {
			Util.addEvent(window, "beforeunload", MPage.fireUnload);
		},
		/**
		 * registerResizeEvent function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		registerResizeEvent: function() {
			Util.addEvent(window, "resize", MPage.fireResize);
		},
		/**
		 * fireResize function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		fireResize: function() {
			var compContainer = null;
			var tempComp;
			var x;

			for(x = MPage.ActiveComponents.length; x--; ) {
				tempComp = MPage.ActiveComponents[x];
				compContainer = tempComp.getTarget();
				tempComp.resize($(compContainer).width(), $(compContainer).height());
			}
		},
		/**
		 * fireUnload function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		fireUnload: function() {
			var x;
			for(x = MPage.ActiveComponents.length; x--; ) {
				MPage.ActiveComponents[x].unload();
			}
		},
		addCustomComp: function(compObj) {
			MPage.ActiveComponents.push(compObj);
		},
		getCustomComp: function(compId) {
			var tempComp;
			var x;

			for(x = MPage.ActiveComponents.length; x--; ) {
				tempComp = MPage.ActiveComponents[x];
				if(tempComp.getOption("id") === compId) {
					return tempComp;
				}
			}
			return null;
		}
	};
}

MPage.Component = function() {
	this.baseclassSpecVersion = 1.1;
	this.componentMinimumSpecVersion = 1.0;
};

/* Initialize the component internal variables prior to loading data or rendering.
 * The component should NOT attempt to render during the init() subroutine as the DOM element may not exist.
 */
MPage.Component.prototype.init = function() {
	//Leave empty so component developers can override if necessary
};

/**
 * This function is for convenience. It returns the component menu for the
 * custom component. It is a workflow style menu regardless of whether the
 * component is workflow or summary and can be manipulated with the menu
 * API.
 * @returns {Menu} Component menu
 */
MPage.Component.prototype.getMenu = function() {
    var parentComp = this.getOption("parentComp");

    if (parentComp !== "undefined") {
        return parentComp.getMenu();
    }
    return "undefined";
};

MPage.Component.prototype.refresh = function() {
	var parentComp = null;
	var target = null;
	//Clear the existing target DOM element
	target = this.getTarget();
	if(target) {
		$(target).html("");
	}

	//Get the parent component and refresh from the MPageComponent
	parentComp = this.getOption("parentComp");
	if(parentComp) {
		parentComp.reloadCustomComp();
	}
};

MPage.Component.prototype.generate = function(target, callback, options) {
	var attr = null;
	var combined = null;
	var funcCallback = null;

	//Get the target if it is not already defined. (Should already be set)
	if(!target) {
		target = this.getTarget();
	}

	//Create a callback if not already defined.  (Should already be set)
	if(!callback) {
		funcCallback = function(component) {
			component.render();
		};
	}
	else {
		funcCallback = function(component) {
			component.render();
			callback(component);
		};
	}

	//If options are available, combine them with the existing options
	if(options) {
		combined = this.options;
		for(attr in options) {
			//The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.
			if(options.hasOwnProperty(attr)) {
				combined[attr] = options[attr];
			}
		}
		this.options = combined;
	}

	//Initialize the component
	this.init();
	//
	//Custom components for workflow views are created, by default, with no menu items
	//in the component menu. Test here to see if any menu items were added in the init
	//method and disable the component menu if they were not added.
	//
	if (this.getMenu().getMenuItemArray() == null || this.getMenu().getMenuItemArray().length == 0) {
		//Disable the menu for this component and unbind all click events
		$("#" + this.getMenu().getAnchorElementId())
			.addClass("opts-menu-empty")
			.unbind("click");
	}
	//Load the data for the component
	this.loadData(funcCallback);
	return this;
};

MPage.Component.prototype.loadData = function(callback) {
	//Prepare the callback for the loadCcl call
	var component = this;
	var funcCallback;
	funcCallback = function(response) {
		component.data = response;
		callback(component);
	};

	//Check dataType
	if(this.cclDataType === "undefined") {
		this.cclDataType = "JSON";
	}

	//Call the cclProgram and run it with cclParams
	if(this.cclProgram && this.cclParams && this.cclParams.length > 0) {
		this.loadCCL(this.cclProgram, this.cclParams, funcCallback, this.cclDataType);
	}
	else {
		callback(component);
	}
};

/**
 * It redirects parameters to function loadCCL, which cleans up CCL parameters and initiates a CCL call.
 * @param {string} cclProgram CCL program name
 * @param {Array} cclParams CCL program parameters
 * @param {Function} callback Call back function that handles CCL reply
 * @param {string} dataType Indicate data type of the CCL reply: "XML", "JSON", "TEXT".
 * @returns {undefined} Undefined
 */
MPage.Component.prototype.loadCcl = function(cclProgram, cclParams, callback, dataType) {
	this.loadCCL(cclProgram, cclParams, callback, dataType);
};

/**
 * It ensures all parameters are in correct formats and then initiate a CCL call. Call back function will handle CCL reply data once it's retrieved.
 * @param {string} cclProgram CCL program name
 * @param {Array} cclParams CCL program parameters
 * @param {Function} callback Call back function that handles CCL reply
 * @param {string} dataType Indicate data type of the CCL reply: "XML", "JSON", "TEXT". Data of JSON type will be parsed into JSON object before calling the callback function.
 * @returns {undefined} Undefined
 */
MPage.Component.prototype.loadCCL = function(cclProgram, cclParams, callback, dataType) {
	var self = this;
	var paramStringArr = [];

	//Ensure all parameters are in correct formats
	for(var x = 0; x < cclParams.length; x++) {
		if(typeof cclParams[x] === "string") {
			if(/^value *\(.*\) *$/.test(cclParams[x])) {
				//handle value arrays like 'value(12345.0,4567.0)'
				paramStringArr.push(cclParams[x]);
			}
			else if(!/^('.*'|".*"|\^.*\^)$/.test(cclParams[x])) {
				//check if the string is encapsulated in '',"", or ^^, otherwise put it inside ^^
				paramStringArr.push("^" + cclParams[x] + "^");
			}
			else {
				paramStringArr.push(cclParams[x]);
			}
		}
		else if(typeof cclParams[x] === "number" && cclParams[x] % 1 === 0) {
			paramStringArr.push(cclParams[x] + ".0");
		}
		else {
			paramStringArr.push(cclParams[x]);
		}
	}

	//Retrieve the parent component so the ComponentScriptRequest will successfully log the timer information
	var parentComponent = this.getOption("parentComp");

	//Create a String time stamp using the current date/time and a random number to make sure the Stop checkpoint only matches its own Start checkpoint.
	//The random number guarantees the checkpoints are matched correctly, even in the unlikely scenario
	//where multiple custom components with the same namespace and parameters are triggered at the exact same time.
	var timeStampID = (new Date()).getTime() + "" + Math.random();

	var loadTimer = new RTMSTimer(parentComponent.getComponentLoadTimerName(), parentComponent.getCriterion().category_mean);
	loadTimer.addMetaData("rtms.legacy.metadata.1", parentComponent.getComponentNamespace());
	loadTimer.addMetaData("rtms.legacy.metadata.2", parentComponent.getComponentOptionsObjectName());
	loadTimer.addMetaData("rtms.legacy.metadata.3", timeStampID);

	var renderTimer = new RTMSTimer(parentComponent.getComponentRenderTimerName(), parentComponent.getCriterion().category_mean);
	renderTimer.addMetaData("rtms.legacy.metadata.1", parentComponent.getComponentNamespace());
	renderTimer.addMetaData("rtms.legacy.metadata.2", parentComponent.getComponentOptionsObjectName());

	var request = new ComponentScriptRequest();
	request.setComponent(parentComponent);
	request.setProgramName(cclProgram);
	request.setParameterArray(paramStringArr);
	request.setRawDataIndicator(true);
	request.setLoadTimer(loadTimer);
	request.setRenderTimer(renderTimer);
	request.setResponseHandler(function(replyObj) {
		var parser = null;
		var responseData = replyObj.getResponse();
		var xmlDoc = null;

		if(responseData) {
			try {
				//Need to interpret the data here and set into this.data
				switch(dataType) {
					case "XML":
						if(window.ActiveXObject) {
							//for IE
							xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
							xmlDoc.async = "false";
							xmlDoc.loadXML(responseData);
						}
						else {
							//for Mozilla, Chrome and Safari
							parser = new DOMParser();
							xmlDoc = parser.parseFromString(responseData, "text/xml");
						}

						callback.call(self, xmlDoc);
						break;
					case "TEXT":
						callback.call(self, responseData);
						break;
					case "JSON":
						callback.call(self, JSON.parse(responseData));
						break;
					default:
						callback.call(self, JSON.parse(responseData));
						break;
				}
			}
			catch(err) {
				logger.logJSError(err, parentComponent, "mp_custom_component_core.js", "loadCCL");
				throw err;
			}
		}
		else {
			logger.logError("Script " + cclProgram + " did not return any data");
			throw new Error("Script " + cclProgram + " did not return any data");
		}
	});

	request.performRequest();
};

/*default implementation of this which is only responsible for TEXT data*/
MPage.Component.prototype.render = function() {
	var target;
	if(typeof this.data === "string") {
		target = this.getTarget();
		target.innerHTML = this.data;
	}
};

MPage.Component.prototype.getOption = function(name) {
	if(this.options && typeof this.options[name] !== "undefined") {
		return this.options[name];
	}
	else {
		return "undefined";
	}
};


MPage.Component.prototype.setOption = function(name, value) {
	if(!this.options) {
		this.options = {};
	}
	this.options[name] = value;
};

MPage.Component.prototype.getProperty = function(name) {
	if(this.properties && typeof this.properties[name] !== "undefined") {
		return this.properties[name];
	}
	else {
		return "undefined";
	}
};


MPage.Component.prototype.setProperty = function(name, value) {
	if(this.properties) {
		this.properties[name] = value;
	}
	else {
		this.properties = {};
		this.properties[name] = value;
	}

	//Take special action depending on the property
	if("headerTitle|headerSubTitle|headerShowHideState|userPreferences".indexOf(name) >= 0) {
		var parentComp = this.getOption("parentComp");
		/*eslint-disable default-case*/
		switch(name) {
			case "headerTitle":
				parentComp.updateLabel(value);
				break;
			case "headerSubTitle":
				parentComp.updateSubLabel(value);
				break;
			case "headerShowHideState":
				parentComp.setExpandCollapseState(value);
				break;
            case "userPreferences":
				try {
					parentComp.setPreferencesObj(value);
					parentComp.savePreferences(true); // save asynchronously
				}
				catch (err) {
					logger.logJSError(err, parentComp, "mp_custom_component_core.js", "savePreferences");
				}
                break;
		}
		/*eslint-enable default-case*/
	}

	return this;
};

MPage.Component.prototype.getTarget = function() {
	var target = null;
	if(this.options && this.options.target) {
		target = this.options.target;
	}
	return target;
};

MPage.Component.prototype.setTarget = function(target) {
	if(this.options) {
		this.options.target = target;
	}
	else {
		this.options = {};
		this.options.target = target;
	}
};

/*eslint-disable no-unused-vars*/
MPage.Component.prototype.resize = function(width, height) {
	return null;
};
/*eslint-enable no-unused-vars*/

MPage.Component.prototype.unload = function() {
	return null;
};

MPage.Component.prototype.getComponentUid = function() {
	return this.getOption("id");
};

MPage.Component.prototype.throwNewError = function(description, err) {
	var error = err || new Error(description);
	logger.logError("Error occurred in a custom component: " + description);
	logger.logJSError(error, null, "mp_custom_component_core.js", "MPage.Component.prototype.throwNewError");
	throw error;
};
/**
 * The below methods define the SharedConditionResource, a child of SharedResource to be used to create
 * a shared condition list
 */
SharedConditionResource.prototype = new SharedResource();
SharedConditionResource.prototype.constructor = SharedConditionResource;

/**
 * @constructor
 * @this {SharedConditionResource}
 * @param {String} resourceName.  The desired name of this instance of SharedConditionResource.
 */
function SharedConditionResource(resourceName) {
    SharedResource.call(this, resourceName);
    this.m_condPrivsRetrieved = false;
    this.m_nkpNomenclatures = [];
    this.m_cernerNKPNomenclature = 0.0;
    this.m_hasChronicProbs = false;
    //condPrivObj contains processed information about privileges and NKP details
    this.m_condPrivObj = {
        canViewNKP:false,
        canUpdtNKP:false,
        canModifyChronic:false,
        canModifyThisVisit:false,
        canAddChronicFreeText:false,
        nkpNomenclatures: [],
        cernerNKPNomenclature: 0.0,
        hasChronicProbs: false
    };
    //metaObj holds the raw metadata returned from the list reply
    this.m_metaObj = {};
}

/*
 * Getters and Setters for the privilege information
 */
SharedConditionResource.prototype.getCondPrivsRetrieved = function(){
    return (this.m_condPrivsRetrieved);
};

SharedConditionResource.prototype.setCondPrivsRetrieved = function(val){
    this.m_condPrivsRetrieved = this.booleanTranslation(val);
};

SharedConditionResource.prototype.getCondPrivsObj = function(){
    return (this.m_condPrivObj);
};

SharedConditionResource.prototype.setViewNKPPriv = function(val){
    this.m_condPrivObj.canViewNKP = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setUpdtNKPPriv = function(val){
    this.m_condPrivObj.canUpdtNKP = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setModifyChronicPriv = function(val){
    this.m_condPrivObj.canModifyChronic = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setModifyThisVisitPriv = function(val){
    this.m_condPrivObj.canModifyThisVisit = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setChronicFreeTextPriv = function(val){
    this.m_condPrivObj.canAddChronicFreeText = this.booleanTranslation(val);
};


/**
 * Getters and setters for NKP information
 */
SharedConditionResource.prototype.setNKPNomenclatures = function(nomenclatureArr){
	var nomenclatures = [];
	var nomenCnt = nomenclatureArr.length;
	var i = 0;
	var nomenclature;
	var nomenclatureId;
	if (nomenCnt){
		for (i = 0; i < nomenCnt; i++){
			nomenclature = nomenclatureArr[i];
			nomenclatureId = 0;
			if (nomenclature){
				nomenclatureId = nomenclature.ID;
			}
			if (nomenclatureId){
				nomenclatures.push(parseInt(nomenclatureId, 10));
			}
		}
	}
	this.m_condPrivObj.nkpNomenclatures = nomenclatures;
};

SharedConditionResource.prototype.getNKPNomenclatures = function(){
	return this.m_condPrivObj.nkpNomenclatures;
};
SharedConditionResource.prototype.setCernerNKPNomenclature = function(val){
	this.m_condPrivObj.cernerNKPNomenclature = parseInt(val, 10);
};
SharedConditionResource.prototype.getCernerNKPNomenclature = function(){
	return this.m_condPrivObj.cernerNKPNomenclature;
};
SharedConditionResource.prototype.setHasChronicProbs = function(val){
	this.m_condPrivObj.hasChronicProbs = this.booleanTranslation(val);
};
SharedConditionResource.prototype.getHasChronicProbs = function(){
	return this.m_condPrivObj.hasChronicProbs;
};
/**
 *Setter and Getter for the Meta object 
 */
SharedConditionResource.prototype.getMetaObj = function(){
    return (this.m_metaObj);
};

SharedConditionResource.prototype.setMetaObj = function(val){
    this.m_metaObj = val;
};
/*
 * Take in a value and return a boolean
 */
SharedConditionResource.prototype.booleanTranslation = function(value){
    if(value === true || value === false){
        return (value);
    }else if(value === "1" || value > 0){
        return (true);
    }else{
        return (false);
    }
}

/*
 * Overwriting parent retrieveSharedResourceData to use condition entity for data retrieval
 */
SharedConditionResource.prototype.retrieveSharedResourceData = function(){
	var Condition = MPageEntity.entities.Condition;
	var probDxUtils = MPageEntity.getProbDxUtils();
	var self = this;
	var criterion = JSON.parse(m_criterionJSON).CRITERION;	
	if(!this.getCondPrivsRetrieved()){
        Condition.meta.userId = criterion.PRSNL_ID;
        Condition.meta.pprCd = criterion.PPR_CD;
	}
	var listCriteria = {personId: criterion.PERSON_ID, encounterId: criterion.ENCNTRS[0].ENCNTR_ID};
	try{
		if(this.isBeingRetrieved()){
			return;
		}
		this.setIsBeingRetrieved(true);
		Condition.list(listCriteria, function(conditions, respStr){
            self.setResourceData(conditions);
            self.setIsAvailable(true);
            self.setIsBeingRetrieved(false);
            if(respStr != null){
                var metaObj = JSON.parse(respStr).RECORD_DATA.META;
                if(metaObj){
                	self.setMetaObj(metaObj);
                    self.setViewNKPPriv(metaObj.CANVIEWNKP);
                    self.setUpdtNKPPriv(metaObj.CANUPDTNKP);
                    self.setModifyChronicPriv(metaObj.CANMODIFYCHRONIC);
                    self.setModifyThisVisitPriv(metaObj.CANMODIFYTHISVISIT);
                    self.setChronicFreeTextPriv(metaObj.CANADDCHRONICFREETEXT);
                    self.setNKPNomenclatures(metaObj.NKPNOMENS);
                    self.setCernerNKPNomenclature(metaObj.CERNERNKPNOMENID);
                    self.setHasChronicProbs(metaObj.HASCHRONICPROBS);
                    self.setCondPrivsRetrieved(true);
                }
            }
            self.notifyResourceConsumers();
            //Refresh the win32 problems and diagnoses component. 
			if (!probDxUtils) {
				logger.logError("Unable to create the PROBDXUTILS COM object");
				return;
			}
            probDxUtils.RefreshDiagnosisCollection(criterion.PERSON_ID, criterion.ENCNTRS[0].ENCNTR_ID);
			probDxUtils.RefreshProblemCollection(criterion.PERSON_ID);	
		});
	}
	catch(err){
		this.setIsBeingRetrieved(false);
		if(logger){
			logger.logJSError(err, null, "mp_shared_condition_resource.js", "retrieveSharedResourceData");
		}
	}
};

/**
 * Initializes the shared resource and adds it to the 
 * @return {SharedConditionResource} The shared condition resource that was initialized or used by the consumer
 */
SharedConditionResource.getSharedResource = function(callback, consumer){
	var consumer = consumer || {};
	var sharedConditionResource = MP_Resources.getSharedResource('shared-condition-resource');
	if (!sharedConditionResource){
		sharedConditionResource = new SharedConditionResource('shared-condition-resource');
		sharedConditionResource.setEventListenerFlag(EventListener.EVENT_CONDITIONS_UPDATE);
		sharedConditionResource.setEventListenerObject(consumer);
		MP_Resources.addSharedResource('shared-condition-resource', sharedConditionResource);
	}
	var wrappedCallback = function(){
		callback(sharedConditionResource.getResourceData(), sharedConditionResource.getCondPrivsObj(), sharedConditionResource.getMetaObj());
	};
	if (sharedConditionResource.isResourceAvailable()){
		wrappedCallback();
	}
	else{
		sharedConditionResource.retrieveSharedResourceData();
	}
	CERN_EventListener.addListener(consumer, EventListener.EVENT_CONDITIONS_UPDATE, wrappedCallback, consumer);
	return sharedConditionResource;
};
/*
 * mp_shared_resources.js
 * @author Steven Lewis
 *
 * A collection of functions and objects used to manage shared resources between multiple MPages and Components.
 */

/**
 * Creates an instance of SharedResource object
 * @constructor
 * @this {SharedResource}
 * @param {String} resourceName The desired name of this instance of SharedResource.  Will be used to reference this SharedResource object.
 */
function SharedResource(resourceName) {
	/** @private */
	var name = resourceName;
	/** @private */
	var cclProgram = null;
	/** @private */
	var cclParams = [];
	/** @private */
	var isAvailable = false;
	/** @private */
	var isBeingRetrieved = false;
	/** @private */
	var resourceData = null;
	/** @private */
	var eventListenerFlag = null;
	/** @private */
	var eventListenerObject = null;

	/**
	 * Get the name of the SharedResource
	 * @return {String} The name of the SharedResource
	 */
	this.getName = function() {
		return name;
	};

	/**
	 * Set the name of the SharedResource
	 * @param {String} resourceName The name to be given to the SharedResource
	 */
	this.setName = function(resourceName) {
		name = resourceName;
	};

	/**
	 * Get the ccl program of the SharedResource
	 * @return {String} The name of the ccl program which retrieves the data for this SharedResouce
	 */
	this.getCclProgram = function() {
		return cclProgram;
	};

	/**
	 * Set the ccl program of the SharedResource
	 * @param {string} cclProgram The name of the ccl program used to retrieve the data for the SharedResource
	 */
	this.setCclProgram = function(cclProgramName) {
		cclProgram = cclProgramName;
	};

	/**
	 * Get the ccl parameters for the script used to retrieve the data for the SharedResource
	 * @return {Array} The parameter array used when call the cclProgram
	 */
	this.getCclParams = function() {
		return cclParams;
	};

	/**
	 * Set the ccl parameters for the script used to retrieve the data for the SharedResource
	 * @param {Array} paramArray An array of mixed type parameters which will be sent to the cclProgram
	 */
	this.setCclParams = function(paramArray) {
		cclParams = paramArray;
	};

	/**
	 * Get the isAvailable indicator of the SharedResource
	 * @return {Boolean} A boolean which tells if the shared resource is available or not
	 */
	this.isResourceAvailable = function() {
		return isAvailable;
	};

	/**
	 * Set the isAvailable indicator of the SharedResource
	 * @param {Boolean} isAvailableInd An indicator which tells if the shared resource data is available for consumption
	 */
	this.setIsAvailable = function(isAvailableInd) {
		isAvailable = (isAvailableInd) ? true : false;
	};

	/**
	 * Get the isBeingRetrieved indicator of the SharedResource
	 * @return {Boolean} A boolean indicating whether the shared resource is currently being retrieved
	 */
	this.isBeingRetrieved = function() {
		return isBeingRetrieved;
	};

	/**
	 * Set the isBeingRetrieved indicator of the SharedResource
	 * @param {Boolean} retrieving An indicator which tells if the shared resource is currently being retrieved
	 */
	this.setIsBeingRetrieved = function(retrieving) {
		isBeingRetrieved = (retrieving) ? true : false;
	};

	/**
	 * Get the  of the SharedResource
	 * @return {Object} An object which is the actual shared resource.  The type of object is dependent upon what set the resourceData element and should be
	 * known to all consumers of that particular SharedResource.
	 */
	this.getResourceData = function() {
		return resourceData;
	};

	/**
	 * Set the resourceData of the SharedResource
	 * @param {Object} data The data object which is the resource being shared.
	 */
	this.setResourceData = function(data) {
		resourceData = data;
	};

	/**
	 * Get the eventListenerFlag of the SharedResource
	 * @return {Number} An integer which represents the type of event to fire when the shared resource data is available.
	 */
	this.getEventListenerFlag = function() {
		return eventListenerFlag;
	};

	/**
	 * Set the eventListenerFlag of the SharedResource
	 * @param {Number} event An integer which represents the type of event to fire when the shared resource data is available.
	 */
	this.setEventListenerFlag = function(event) {
		eventListenerFlag = event;
	};

	/**
	 * Get the eventListenerObject of the SharedResource
	 * @return {Object} An integer which represents the type of event to fire when the shared resource data is available.
	 */
	this.getEventListenerObject = function() {
		return eventListenerObject;
	};

	/**
	 * Set the eventListenerObject of the SharedResource
	 * @param {Object} object An integer which represents the type of event to fire when the shared resource data is available.
	 */
	this.setEventListenerObject = function(object) {
		eventListenerObject = object;
	};

}

/* Additional helper functions */

/**
 * Fire the event associated to this SharedResource to notify all of the consumers that the data is available.
 * @return {Boolean} An indicator telling if the event was fired successfully
 */
SharedResource.prototype.notifyResourceConsumers = function(removedInd, orderId) {
	try {
		//Get the parameters to fire the event
		var eventFlag = this.getEventListenerFlag();
		var eventObj = this.getEventListenerObject();
		var resourceData = this.getResourceData();

		//Fire the event based on the eventListenerObject and eventListenerFlag
		CERN_EventListener.fireEvent(null, eventObj, eventFlag, resourceData);
		//Log debugging data
		logger.logMessage("Firing Shared Resource Event<br />" +
			"Resource Name: " + this.getName() + "<br />" +
			"Resource Data: " + JSON.stringify(resourceData) + "<br />");

		//send an event to any order profile instances that need to be updated
		if(removedInd) {
			CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION, orderId);
		}
		else {
			if(resourceData.scratchpadObjArr && resourceData.scratchpadObjArr.length > 0) {
				var spArrLen = resourceData.scratchpadObjArr.length;
				//grab the most recently added order
				var curOrder = resourceData.scratchpadObjArr[spArrLen - 1];
				if(curOrder.addedFrom === "OrderProfile" && orderId) {
					//order is an order action from order profile, fire an event to any other OP component in the viewpoint
					CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION, curOrder);
				}
			}
		}
		return true;
	}
	catch(err) {
		//Log error information and return
		logger.logJSError(err, null, "mp_shared_resources.js", "notifyResourceConsumers");
		return false;
	}
};

/**
 * Retrieves the shared resource data from the script specified in the SharedResource and notifies consumers when the data is available.
 */
SharedResource.prototype.retrieveSharedResourceData = function() {
	var sharedResource = this;

	//If the resource is already being retrieved just return.
	if(this.isBeingRetrieved()) {
		return;
	}

	//Set the isBeingRetrieved flag
	this.setIsBeingRetrieved(true);
	//Create and execute the script request
	var resourceRequest = new ScriptRequest();
	resourceRequest.setName("Shared Resources Data Retrieval");
	resourceRequest.setProgramName(this.getCclProgram());
	resourceRequest.setParameterArray(this.getCclParams());
	resourceRequest.setRawDataIndicator(true);
	resourceRequest.setResponseHandler(function(scriptReply) {
		sharedResource.setResourceData(scriptReply.getResponse());
		sharedResource.setIsAvailable(true);
		sharedResource.setIsBeingRetrieved(false);
		sharedResource.notifyResourceConsumers();
	});
	resourceRequest.performRequest();
};

/**
 * A global object that contains all of the shared resources for MPages.  Also contains helper functions that can be used when dealing with SharedResource Objects.
 * @namespace
 */
var MP_Resources = function() {
	/** @private */
	var sharedResources = {};

	return {
		/**
		 * Retrieves the SharedResource object if it is available.
		 * @param {String} resourceName The name of the SharedResource to retrieve
		 * @returns {SharedResource} If the shared resource is available it will be returned, otherwise null.
		 */
		getSharedResource: function(resourceName) {
			return(sharedResources[resourceName]) ? sharedResources[resourceName] : null;
		},
		/**
		 * Sets the data currently stored in the SharedResource.  There are no checks on the resourceData parameter other than  a check for 'undefined'
		 * @param {String} resourceName The name of the SharedResource to update
		 * @param {Object} resourceData The data object to update into the SharedResource object.
		 * @return {Boolean} True if the SharedResource was updated successfully, false otherwise.
		 */
		setSharedResourceData: function(resourceName, resourceData) {
			var resource = null;

			//Make sure the data passed in isn't undefined.  Undefined is the only unacceptable data.
			if(typeof resourceData === "undefined") {
				logger.logMessage("SharedResource update data is undefined.  " + resourceName + "  will not be updated.");
				return false;
			}

			//Retrieve and update the resource if it is available and not being retrieved.
			resource = MP_Resources.getSharedResource(resourceName);
			if(resource) {
				if(!resource.isBeingRetrieved()) {
					resource.setResourceData(resourceData);
					return true;
				}
				else {
					logger.logMessage("SharedResource " + resourceName + " is currently being retrieved and cannot be updated.");
					return false;
				}
			}
			else {
				logger.logMessage("SharedResource " + resourceName + " does not currently exist");
				return false;
			}
		},
		/**
		 * Add a shared resource to the available resources if it hadnt already been added.  If wanting to update a SharedResource object use the
		 * MP_Resources.setSharedResourceData() function.
		 * @param {String} resourceName The name of the SharedResource to to add
		 * @param {SharedResource} sharedResourceObj The SharedResource object to store for future use
		 * @return {Boolean} True if the resource was added, false otherwise.
		 */
		addSharedResource: function(resourceName, sharedResourceObj) {
			if(!sharedResources[resourceName]) {
				sharedResources[resourceName] = sharedResourceObj;
				return true;
			}
			else {
				//Log an error because we are trying to overwrite an existing shared resource
				logger.logError("Attempting to overwrite an existing shared resource: " + resourceName);
				return false;
			}
		},
		/**
		 * Creates a new SharedResource object for use by components and mpages and adds it to the collection
		 * @param {String} resourceName The name to give to the SharedResource
		 * @param {Object} consumerObj The object which is creating the SharedResource.  This is used when notifying resource consumers which have to have the same Object definition.
		 * @param {String} cclProgram The name of the script used to retrieve the shared resource data
		 * @param {Array} cclParams An array of parameters to send to the cclProgram script
		 * @param {Number} notifyEventFlag The Event flag to fire when the data is available for consumers
		 */
		createSharedResourceObj: function(resourceName, consumerObj, cclProgram, cclParams, notifyEventFlag) {

			//If no shared resource name is given there will be no way to reference it later on.
			if(!resourceName) {
				logger.logError("Cannot create a SharedResource object without a name.");
				return null;
			}

			//Create the object with the parameters passed in.  Null parameters are acceptable because not all fields of the Shared Resource are required.
			var sharedResource = new SharedResource(resourceName);
			sharedResource.setEventListenerObject(consumerObj);
			sharedResource.setEventListenerFlag(notifyEventFlag);
			sharedResource.setCclProgram(cclProgram);
			sharedResource.setCclParams(cclParams);

			//Add the SharedResource object to the collection
			sharedResources[resourceName] = sharedResource;

			return sharedResource;
		}
	};
}();
/*globals ICUDashboardMPage, CommonOrdersMPage, ReachSummaryMPage, CalculatorsSummaryMPage, ViewBuilderMPage, ViewBuilderQOC, ViewBuilderWorkflow, PregnancyWorkflow, WorkflowRenderStrategy, SummaryRenderStrategy, CERN_DEMO_BANNER_O1, CERN_COMPONENT_TYPE_SUMMARY, CERN_COMPONENT_TYPE_WORKFLOW, MPAGE_LC, m_localeObjectName, m_bedrockMpage, m_mpageSettingsJSON*/

if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) { //test for MSIE x.x;
	var ieVersion = new Number(RegExp.$1); // capture x.x portion and store as a number
}
else {
	var ieVersion = 0;
}

//Grab the original width and height of the window container so that we can compare the size when a window.resize event is fired.
//This is mostly needed due to an IE8 bug where window.resize is fired when adding to the DOM causes scroll bars to appear.
var prevWindowHeight = $(window).innerHeight();
var prevWindowWidth = $(window).innerWidth();

/**
 * This function is used to validate that the window has actually been resized.  There are certain instances where the window.resize
 * event will fire without the window actually being resized.  This mostly occurs in IE8 when adding to the DOM produces scroll bars.
 * If either the height or the width of the window has changes this function will return true.  If both the height and width remain
 * unchanged this function will return false.
 *  @return {boolean} True if the window has been resized, false otherwise.
 */
function validateWindowResize(){
	var newWindowHeight = $(window).innerHeight();
	var newWindowWidth = $(window).innerWidth();
	
	if (newWindowHeight !== prevWindowHeight || newWindowWidth !== prevWindowWidth) {
		prevWindowHeight = newWindowHeight;
		prevWindowWidth = newWindowWidth;
		return true;
	}
	return false;
}

/**
 * Create a new instance of an MPageView or WorkflowView object based on a category mean.
 * @param {String} categoryMean The category mean of the MPageView to initialize
 * @param {String} viewTypeMean The code value meaning of the view type
 * @return {MPageView|WorkfowView} An object which is either an MPageView/WorkflowView object or an extension of that.
 */
function createViewObject(categoryMean, viewTypeMean) {
    try{
        if (!categoryMean || typeof categoryMean !== "string"){
            logger.logError("categoryMean parameter must be a string and not null");
            return null;
        }
        
        //Determine the type of MPage object to create based on the category mean of a predefined view
        switch(categoryMean) {
            case "MP_ICU_DASHBOARD":
                return new ICUDashboardMPage();
            case "MP_COMMON_ORDERS_V4":
                // It uses the dummy mpage to ensure the deprecated QOC V4 doesn't blow up
                var dummyPage = new DummyMPage();
                dummyPage.setCategoryMean(categoryMean);
                return dummyPage;
            case "MP_REACH_V5":
                return new ReachSummaryMPage(); 
            case "MP_CALC_SUMMARY":
                return new CalculatorsSummaryMPage(categoryMean);
        }
        
        //Default the view definition to generic MPageView
        var ViewDef = MPageView;
        //determine the view definition of a ViewBuilder using the view type mean
        if(/^VB_.*/.test(categoryMean)){
            ViewDef = MP_Util.getObjectDefinitionMapping(viewTypeMean);
            //if the view type is not found, use the generic ViewBuilderMPage
            if(!ViewDef){
                ViewDef = ViewBuilderMPage;
            }
        }

        //create the view and set the category mean
        var viewObj = new ViewDef();
        viewObj.setCategoryMean(categoryMean);
        return viewObj;
    }
    catch(err){
        if (err.type === "not_defined") {
            logger.logError("No object type defined for " + categoryMean + ": " + err.message);
        }
        else{
            logger.logJSError(err, null, "mpage-driver.js", "createViewObject");
        }
        return null;
    }
}

/**
 * A function that loads and renders a single component on a blank html page. This function is called from the MP_COMPONENT_DRIVER CCL script.
 * @param {String} compSettingsJSON : The JSON string containing the settings and information necessary to load the component.
 * @return {undefined} This function does not return a value
 */
function renderSingleComponent(compSettingsJSON) {
	populateMPageLocale();

	var componentSettings = parseComponentSettingsJSON(compSettingsJSON);
	var criterion = createPageCriterion("");
	var CompDef = MP_Util.getObjectDefinitionMapping(componentSettings.F_MN);
	var compObj = new CompDef(criterion);
	var compNS = compObj.getStyles().getNameSpace();
	var container = document.getElementById("mainContainer");
	var compType = (componentSettings.F_MN.substring(0, 2).toUpperCase() === "WF") ? CERN_COMPONENT_TYPE_WORKFLOW : CERN_COMPONENT_TYPE_SUMMARY;


	//set the component type in case it needs to be retrieved later
	compObj.getStyles().setComponentType(compType);

	compObj.initializeComponent(criterion);
	MP_Core.AppUserPreferenceManager.Initialize(criterion, CERN_driver_mean);
	MP_Core.AppUserPreferenceManager.GetPreferences(); // For loading the component user preferences.
	compObj.loadComponentSettings(componentSettings);

	//Set a render strategy according to the component type
	if (compType === CERN_COMPONENT_TYPE_WORKFLOW) {
		compObj.setAlwaysExpanded(true);
		compObj.setRenderStrategy(new WorkflowRenderStrategy());
		container.className = "wf";
	}
	else {
		//Target component is a summary type. Set render strategy and remove workflow class from the container div.
		compObj.setRenderStrategy(new SummaryRenderStrategy());
		container.className = "";
	}

	//Create the view container and append set the height as window's height.
	var viewContainer = $("<div></div>").addClass("vwp-views").attr("id", "vwpBody").height($(window).height());
	
	// Append the component basic html to view container.
	viewContainer.append(compObj.getRenderStrategy().createComponentShell());
	
	//Append the view container to main container.
	$(container).append(viewContainer);
	
	//Add the resize event listener
	$(window).resize(function () {
	
		//Check to ensure a resize is actually necessary.  If not then just return.
		if (!validateWindowResize()) {
			return;
		}
		viewContainer.height($(window).height());
		compObj.resizeComponent();
	});
	
	compObj.setRootComponentNode(document.getElementById(compNS + compObj.getComponentId()));
	compObj.setSectionContentNode(document.getElementById(compNS + "Content" + compObj.getComponentId()));
	compObj.retrieveComponentData();

	//hide the component menu if there are no items or if the menu has not been initialized
	var compMenu = compObj.getMenu();
	if(!compMenu || !compMenu.getMenuItemArray() || !compMenu.getMenuItemArray().length){
		document.getElementById("mainCompMenu" + compNS + compObj.getComponentId()).style.display = "none";
	}
}

/**
 * This function is used to generate the Criterion object for use in various locations within the MPages Architecture.  This object is generated
 * from the global m_criterionJSON string.
 * @param {Object} categoryMean The category mean of the MPage being loaded
 * @return {Criterion} The Criterion object generated from the m_criteironJSON object
 */
function createPageCriterion(categoryMean) {
	var parsedCriterion = CERN_Platform.getCriterion();
	var criterion = MP_Util.GetCriterion(parsedCriterion, CERN_static_content);
	criterion.category_mean = categoryMean;
	return criterion;
}

/**
 * A function used to launch the discharge process from various locations throughout the MPages Architecture
 * @param {number} encntrID The encounter ID which will be used when discharging the patient
 * @param {number} personID The ID of the person being discharged
 * @param {number} userID The ID of the user discharging the patient
 * @return {undefined} This function does not return a value
 */
function OpenDischargeProcess(encntrID, personID, userID) {
	var dpObject = {};
	dpObject = window.external.DiscernObjectFactory("DISCHARGEPROCESS");
	dpObject.person_id = personID;
	dpObject.encounter_id = encntrID;
	dpObject.user_id = userID;
	dpObject.LaunchDischargeDialog();
}

/**
 * This function is used to attempt to parse the component settings JSON string and return the resulting object
 * @param {String} compSettingsJSON : The JSON string containing the component settings
 * @return {Object} : The structure object containing the necessary settings for rendering the component
 */
function parseComponentSettingsJSON(compSettingsJSON) {
	try {
		//Check if the JSON string exists
		if (typeof compSettingsJSON !== "undefined") {
			var settingsObj = JSON.parse(compSettingsJSON).CS;
			if (typeof settingsObj !== "undefined") {
				return settingsObj;
			}
			else {
				//The JSON string supplied does not contain the proper settings for the component.
				throw new Error(i18n.discernabu.mpageDriver.INCORRECT_JSON_STRING);
			}
		}
		else {
			throw new Error(i18n.discernabu.mpageDriver.NO_JSON_STRING);
		}
	}
	catch (err) {
		logger.logJSError(err, null, "mpage-driver.js", "parseComponentSettingsJSON");
		throw err;
	}
}

/**
 * This function is used to attempt to parse the m_mpageSettingsJSON global and store it in the m_bedrockMpage global for future use.
 * @return {undefined} This function does not return a value
 */
function parseMPageSettingsJSON() {
	try {
		//Check to see if the settings JSON string exists
		if (typeof m_mpageSettingsJSON !== "undefined") {
			m_bedrockMpage = JSON.parse(m_mpageSettingsJSON).MP_SETTINGS;
		}
		else {
			//m_mpageSettingsJSON is a global define by MP_UNIFIED_DRIVER and if that is not available then an incorrect driver is being used
			throw new Error(i18n.discernabu.mpageDriver.INCORRECT_DRIVER);
		}

		//clean up the global JSON string to free up memory because it won't be used anywhere any more.
		m_mpageSettingsJSON = null;
	}
	catch (err) {
		logger.logJSError(err, null, "mpage-driver.js", "parseMPageSettingsJSON");
		throw err;
	}
}

/**
 * This function will be used to prepare the MPAGE_LOCALE global parameter for consumption in other area within the MPages Architecture
 * @return {undefined} This function does not return a value
 */
function populateMPageLocale() {
	try {
		MPAGE_LOCALE = m_localeObjectName ? new mp_formatter.Locale(MPAGE_LC[m_localeObjectName]) : new mp_formatter.Locale(MPAGE_LC.en_US);
		var locale = CERN_Platform.getCriterion().CRITERION.LOCALE_ID;
		$.datepicker.setDefaults($.datepicker.regional[locale]);
	}
	catch (err) {
		logger.logJSError(err, null, "mpage-driver.js", "populateMPageLocale");
		throw err;
	}
}
/**
 * @class
 * This MP_EventAudit object is the main entry point of the Mpage Audit API for MPages.
 * It creates the JSON object that will be passed to the CCL wrapper that calls the CCLAUDIT script.
 * This API will also allow for multiple audit events to be submit at the same time.
 */

var MP_EventAudit = function(){
	this.auditevents = {};
	this.auditevents.EVENTS = {};
	this.auditevents.EVENTS.EVENT = [];
	this.m_iAuditMode = 0;
	this.m_sAuditEventName = "";
	this.m_sAuditEventType = "";
	this.m_sAuditParticipantType = "";
	this.m_sAuditParticipantRoleCd = "";
	this.m_sAuditParticipantIDType = "";
	this.m_sAuditDataLifeCycle = "";
	this.m_dAuditParticipantID = 0.0;
	this.m_sAuditParticipantName = "";
	this.m_iAuditOutcomeInd = 4;
};
/**
 * Sets the Audit Mode value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditMode
 * @param {number} modeValue The audit mode
 * Possible Values: 0 - one-part, 1 - open multi-part, 2 - continue multi-part, 3 - close multi-part, 4 - close multi-part no entry
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditMode = function(modeValue) {
	if ( typeof modeValue !== "number" || modeValue < 0 || modeValue > 4) {
        throw new Error("EventAudit: Invalid Audit Mode");
    }
	this.m_iAuditMode = modeValue;
};

/**
 * Retrieves the audit mode
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditMode
 * @return {number} m_iAuditMode The Audit Mode value
 */
MP_EventAudit.prototype.getAuditMode = function() {
	return this.m_iAuditMode;
};

/**
 * Sets the Event Name value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditEventName
 * @param {string} auditEventName The audit event name
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditEventName = function(auditEventName) {
	this.m_sAuditEventName = auditEventName;
};

/**
 * Retrieves the audit event name
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEventName
 * @return {string} m_sAuditEventName The Audit Event Name value
 */
MP_EventAudit.prototype.getAuditEventName = function() {
	return this.m_sAuditEventName;
};

/**
 * Sets the Event Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditEventType
 * @param {string} auditEventType The audit event type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditEventType = function(auditEventType) {
	this.m_sAuditEventType = auditEventType;
};

/**
 * Retrieves the audit event type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEventType
 * @return {string} m_sAuditEventType The Audit Event Type value
 */
MP_EventAudit.prototype.getAuditEventType = function() {
	return this.m_sAuditEventType;
};

/**
 * Sets the Participant Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantType
 * @param {string} auditParticipantType The audit Participant Type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantType = function(auditParticipantType) {
	this.m_sAuditParticipantType = auditParticipantType;
};

/**
 * Retrieves the audit Participant Type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantType
 * @return {string} m_sAuditParticipantType The Audit Participant Type value
 */
MP_EventAudit.prototype.getAuditParticipantType = function() {
	return this.m_sAuditParticipantType;
};

/**
 * Sets the Participant Role Code value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantRoleCd
 * @param {string} auditParticipantRoleCd The audit Participant Role Code
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantRoleCd = function(auditParticipantRoleCd) {
	this.m_sAuditParticipantRoleCd = auditParticipantRoleCd;
};

/**
 * Retrieves the audit Participant Role Code
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantRoleCd
 * @return {string} m_sAuditParticipantRoleCd The Audit Participant Role Code value
 */
MP_EventAudit.prototype.getAuditParticipantRoleCd = function() {
	return this.m_sAuditParticipantRoleCd;
};

/**
 * Sets the Participant ID Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantIDType
 * @param {string} auditParticipantIDType The audit Participant ID Type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantIDType = function(auditParticipantIDType){
	this.m_sAuditParticipantIDType = auditParticipantIDType;
};

/**
 * Retrieves the audit Participant ID Type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantIDType
 * @return {string} m_sAuditParticipantIDType The Audit Participant ID Type value
 */
MP_EventAudit.prototype.getAuditParticipantIDType = function() {
	return this.m_sAuditParticipantIDType;
};

/**
 * Sets the Data Life Cycle value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditDataLifeCycle
 * @param {string} auditDataLifeCycle The audit Data Life Cycle
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditDataLifeCycle = function(auditDataLifeCycle) {
	this.m_sAuditDataLifeCycle = auditDataLifeCycle;
};

/**
 * Retrieves the audit Data Life Cycle
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditDataLifeCycle
 * @return {string} m_sAuditDataLifeCycle The Audit DataLife Cycle value
 */
MP_EventAudit.prototype.getAuditDataLifeCycle = function() {
	return this.m_sAuditDataLifeCycle;
};

/**
 * Sets the Participant ID value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantID
 * @param {double} auditParticipantID The audit Participant ID
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantID = function(auditParticipantID) {
	this.m_dAuditParticipantID = auditParticipantID;
};

/**
 * Retrieves the audit Participant ID
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantID
 * @return {double} m_dAuditParticipantID The Audit Participant ID value
 */
MP_EventAudit.prototype.getAuditParticipantID = function() {
	return this.m_dAuditParticipantID;
};

/**
 * Sets the Participant Name value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantName
 * @param {string} auditParticipantName The audit Participant Name
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantName = function(auditParticipantName) {
	this.m_sAuditParticipantName = auditParticipantName;
	var OutcomeInd = auditParticipantName.substring(7,8);
	this.m_iAuditOutcomeInd = parseInt(OutcomeInd);
};

/**
 * Retrieves the audit Participant Name
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantName
 * @return {string} m_sAuditParticipantName The Audit Participant Name value
 */
MP_EventAudit.prototype.getAuditParticipantName = function() {
	return this.m_sAuditParticipantName;
};

/**
 * Sets the Outcome_Ind value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditOutcomeInd
 * @param {number} setAuditOutcomeInd The audit Outcome_Ind
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditOutcomeInd = function(auditOutcomeInd) {
	this.m_iAuditOutcomeInd = auditOutcomeInd;
};

/**
 * Retrieves the audit Outcome_Ind value
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditOutcomeInd
 * @return {number} m_iAuditOutcomeind The Audit Outcome_Ind value
 */
MP_EventAudit.prototype.getAuditOutcomeInd = function() {
	return this.m_iAuditOutcomeInd;
};

/**
 * Return the JSON string representation of the MP_EventAudit.auditevents object
 *
 * @function
 * @memberof MP_EventAudit
 * @name toJSON
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.toJSON = function() {
		return JSON.stringify(this.auditevents);
};

/**
 * Add a new audit event to the auditevents object.
 *
 * @function
 * @memberof MP_EventAudit
 * @name addAuditEvent
 *  @return {undefined} Nothing
 */
MP_EventAudit.prototype.addAuditEvent = function(){
	var tAEvent = {};
	tAEvent.AUDIT_MODE = this.m_iAuditMode || 0;
	tAEvent.EVENT_NAME = this.m_sAuditEventName || "";
	tAEvent.EVENT_TYPE = this.m_sAuditEventType || "";
	tAEvent.PARTICIPANT_TYPE = this.m_sAuditParticipantType || "";
	tAEvent.PARTICIPANT_ROLE_CD = this.m_sAuditParticipantRoleCd || "";
	tAEvent.PARTICIPANT_ID_TYPE = this.m_sAuditParticipantIDType || "";
	tAEvent.DATA_LIFE_CYCLE = this.m_sAuditDataLifeCycle || "";
	tAEvent.PARTICIPANT_ID = this.m_dAuditParticipantID || 0.0;
	tAEvent.PARTICIPANT_NAME = this.m_sAuditParticipantName || "";
	tAEvent.OUTCOME_IND = this.m_iAuditOutcomeInd;
	this.auditevents.EVENTS.EVENT.push(tAEvent);
};

/**
 * Return the collection of audit event objects
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEvents
 * @return {object} The audit events as JSON
 */
MP_EventAudit.prototype.getAuditEvents = function() {
	var arrObject = this.toJSON();
	return arrObject;
};

/**
 * Reset the collection of audit event objects
 *
 * @function
 * @memberof MP_EventAudit
 * @name resetAuditEvents
 */
MP_EventAudit.prototype.resetAuditEvents = function() {
	this.auditevents.EVENTS.EVENT = [];
};

/**
 * Submit array of Audit Events through the call to mp_submit_audit_events.prg
 *
 * @static
 * @function
 * @memberof MP_EventAudit
 * @name submit
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.submit = function() {
	try {
		if(this.auditevents.EVENTS.EVENT && this.auditevents.EVENTS.EVENT.length === 0){
			logger.logJSError("The Audit Events array submitted for processing is empty.");
			throw new Error("EVENTAUDIT: Audit Events array is empty.");
		} else {
			//Call the toJson method to stringify the auditevents object
			var aeObj = this.toJSON();
			//Create instance of script request api
			var request = new ScriptRequest();
			var programName = "mp_submit_audit_events";
			var params = ['^MINE^', '^' + aeObj + '^'];
			request.setProgramName(programName);
			request.setParameterArray(params);
			request.setAsyncIndicator(false);
			request.setResponseHandler(function(replyObj) {
				if (replyObj.getStatus() === "S") {
					logger.logDebug("All events have been successfully submitted.");
					
				} else {
					logger.logJSError("An error occurred during the submission of events.");
					throw new Error("EVENTAUDIT: Error submitting events.");
				}
			});
			request.performRequest();
			
			//Clear audit events after successful submission
			this.resetAuditEvents();
		}
	} catch(e){
		logger.logJSError("Error encountered trying to submit audit events: <br />Message: " + e.description + "<br />Name: " + e.name + "<br />Number: " + e.number);
	}
};
/*
	Blackbird - Open Source JavaScript Logging Utility
	Author: G Scott Olson
	Web: http://blackbirdjs.googlecode.com/
	     http://www.gscottolson.com/blackbirdjs/
	Version: 1.0

	The MIT License - Copyright (c) 2008 Blackbird Project
*/
( function() {
	var NAMESPACE = 'log';
	var IE6_POSITION_FIXED = true; // enable IE6 {position:fixed}
	
	var bbird;
	var outputList;
	var cache = [];
	var loggingActive;
	var state = getState();
	var classes = {};
	var profiler = {};
	var IDs = {
		blackbird: 'blackbird',
		checkbox: 'bbVis',
		filters: 'bbFilters',
		controls: 'bbControls',
		size: 'bbSize'
	}
	var messageTypes = { //order of these properties imply render order of filter controls
		debug: true,
		info: true,
		warn: true,
		error: true,
		profile: true
	};
	
	function isLoggingActive(){
		return (state.active || loggingActive) ? true : false;
	}
	
	function generateMarkup() { //build markup
		var spans = [];
		for ( type in messageTypes ) {
			spans.push( [ '<span class="', type, '" type="', type, '"></span>'].join( '' ) );
		}

		var newNode = document.createElement( 'DIV' );
		newNode.id = IDs.blackbird;
		newNode.style.display = 'none';
		newNode.innerHTML = [
			'<div class="header">',
				'<div class="left">',
					'<div id="', IDs.filters, '" class="filters" title="click to filter by message type">', spans.join( '' ), '</div>',
				'</div>',
				'<div class="right">',
					'<div id="', IDs.controls, '" class="controls">',
						'<span id="', IDs.size ,'" title="contract" op="resize"></span>',
						'<span class="clear" title="clear" op="clear"></span>',
						'<span class="close" title="close" op="close"></span>',
					'</div>',
				'</div>',
			'</div>',
			'<div class="main">',
				'<div class="left"></div><div class="mainBody">',
					'<ol>', cache.join( '' ), '</ol>',
				'</div><div class="right"></div>',
			'</div>'/*,
			'<div class="footer">',
				'<div class="left"><label for="', IDs.checkbox, '"><input type="checkbox" id="', IDs.checkbox, '" />Visible on page load</label></div>',
				'<div class="right"></div>',
			'</div>'*/
		].join( '' );
		return newNode;
	}

	function backgroundImage() { //(IE6 only) change <BODY> tag's background to resolve {position:fixed} support
		var bodyTag = document.getElementsByTagName( 'BODY' )[ 0 ];
		
		if ( bodyTag.currentStyle && IE6_POSITION_FIXED ) {
			if (bodyTag.currentStyle.backgroundImage == 'none' ) {
				bodyTag.style.backgroundImage = 'url(about:blank)';
			}
			if (bodyTag.currentStyle.backgroundAttachment == 'scroll' ) {
				bodyTag.style.backgroundAttachment = 'fixed';
			}
		}
	}

	function addMessage( type, content ) { //adds a message to the output list
		content = ( content.constructor == Array ) ? content.join( '' ) : content;
		if ( outputList ) {
			var newMsg = document.createElement( 'LI' );
			newMsg.className = type;
			newMsg.innerHTML = [ '<span class="icon"></span>', content ].join( '' );
			outputList.appendChild( newMsg );
			scrollToBottom();
		} else {
			cache.push( [ '<li class="', type, '"><span class="icon"></span>', content, '</li>' ].join( '' ) );
		}
	}
	
	function clear() { //clear list output
		outputList.innerHTML = '';
	}
	
	function clickControl( evt ) {
		if ( !evt ) evt = window.event;
		var el = ( evt.target ) ? evt.target : evt.srcElement;

		if ( el.tagName == 'SPAN' ) {
			switch ( el.getAttributeNode( 'op' ).nodeValue ) {
				case 'resize': resize(); break;
				case 'clear':  clear();  break;
				case 'close':  hide();   break;
			}
		}
	}
	
	function clickFilter( evt ) { //show/hide a specific message type
		if ( !evt ) evt = window.event;
		var span = ( evt.target ) ? evt.target : evt.srcElement;

		if ( span && span.tagName == 'SPAN' ) {

			var type = span.getAttributeNode( 'type' ).nodeValue;

			if ( evt.altKey ) {
				var filters = document.getElementById( IDs.filters ).getElementsByTagName( 'SPAN' );

				var active = 0;
				for ( entry in messageTypes ) {
					if ( messageTypes[ entry ] ) active++;
				}
				var oneActiveFilter = ( active == 1 && messageTypes[ type ] );

				for ( var i = 0; filters[ i ]; i++ ) {
					var spanType = filters[ i ].getAttributeNode( 'type' ).nodeValue;

					filters[ i ].className = ( oneActiveFilter || ( spanType == type ) ) ? spanType : spanType + 'Disabled';
					messageTypes[ spanType ] = oneActiveFilter || ( spanType == type );
				}
			}
			else {
				messageTypes[ type ] = ! messageTypes[ type ];
				span.className = ( messageTypes[ type ] ) ? type : type + 'Disabled';
			}

			//build outputList's class from messageTypes object
			var disabledTypes = [];
			for ( type in messageTypes ) {
				if ( ! messageTypes[ type ] ) disabledTypes.push( type );
			}
			disabledTypes.push( '' );
			outputList.className = disabledTypes.join( 'Hidden ' );

			scrollToBottom();
		}
	}

	function clickVis( evt ) {
		if ( !evt ) evt = window.event;
		var el = ( evt.target ) ? evt.target : evt.srcElement;

		state.load = el.checked;
		setState();
	}
	
	
	function scrollToBottom() { //scroll list output to the bottom
		outputList.scrollTop = outputList.scrollHeight;
	}
	
	function isVisible() { //determine the visibility
		return ( bbird.style.display == 'block' );
	}

	function hide() { 
	  bbird.style.display = 'none';
	}
			
	function show() {
		var body = document.getElementsByTagName( 'BODY' )[ 0 ];
		body.removeChild( bbird );
		body.appendChild( bbird );
		bbird.style.display = 'block';
	}
	
	//sets the position
	function reposition( position ) {
		if ( position === undefined || position == null ) {
			position = ( state && state.pos === null ) ? 1 : ( state.pos + 1 ) % 4; //set to initial position ('topRight') or move to next position
		}
				
		switch ( position ) {
			case 0: classes[ 0 ] = 'bbTopLeft'; break;
			case 1: classes[ 0 ] = 'bbTopRight'; break;
			case 2: classes[ 0 ] = 'bbBottomLeft'; break;
			case 3: classes[ 0 ] = 'bbBottomRight'; break;
		}
		state.pos = position;
		setState();
	}

	function resize( size ) {
		if ( size === undefined || size === null ) {
			size = ( state && state.size == null ) ? 1 : ( state.size + 1 ) % 2;
	  	}

		classes[ 1 ] = ( size === 0 ) ? 'bbSmall' : 'bbLarge'

		var span = document.getElementById( IDs.size );
		span.title = ( size === 1 ) ? 'small' : 'large';
		span.className = span.title;	  

		state.size = size;
		setState();
		scrollToBottom();
	}

	function setLogging(){
		state.active = true;
		state.load = true;
		state.size = 1;
		setState();
	}

	function stopLogging() {
		state.active = false;
		state.load = false;
		state.size = 1;
		setState();
	}
	
	function setState() {
		var props = [];
		for ( entry in state ) {
			var value = ( state[ entry ] && state[ entry ].constructor === String ) ? '"' + state[ entry ] + '"' : state[ entry ]; 
			props.push( entry + ':' + value );
		}
		props = props.join( ',' );
		
		var expiration = new Date();
		expiration.setDate( expiration.getDate() + 14 );
		document.cookie = [ 'blackbird={', props, '};'].join( '' );

		var newClass = [];
		for ( word in classes ) {
			newClass.push( classes[ word ] );
		}
		//Check to see if the blackbird has been rendered before setting the className
		if(bbird) {
			bbird.className = newClass.join(' ');
		}
	}
	
	function getState() {
		var re = new RegExp( /blackbird=({[^;]+})(;|\b|$)/ );
		var match = re.exec( document.cookie );
		return ( match && match[ 1 ] ) ? eval( '(' + match[ 1 ] + ')' ) : { pos:null, size:null, load:null, active:null };
	}
	
	//event handler for 'keyup' event for window
	function readKey( evt ) {
		if ( !evt ) evt = window.event;
		var code = 113; //F2 key
					
		if ( evt && evt.keyCode == code ) {
					
			var visible = isVisible();
					
			if ( visible && evt.shiftKey && evt.altKey ) clear();
			else if	 (visible && evt.shiftKey ) reposition();
			else if ( !evt.shiftKey && !evt.altKey ) {
			  if(isLoggingActive()){
			    ( visible ) ? hide() : show();
			  }
			}
		}
	}

	//event management ( thanks John Resig )
	function addEvent( obj, type, fn ) {
		var obj = ( obj.constructor === String ) ? document.getElementById( obj ) : obj;
		if ( obj.attachEvent ) {
			obj[ 'e' + type + fn ] = fn;
			obj[ type + fn ] = function(){ obj[ 'e' + type + fn ]( window.event ) };
			obj.attachEvent( 'on' + type, obj[ type + fn ] );
		} else obj.addEventListener( type, fn, false );
	}
	function removeEvent( obj, type, fn ) {
		var obj = ( obj.constructor === String ) ? document.getElementById( obj ) : obj;		
		if ( obj.detachEvent ) {
			if (obj[ type + fn ] != undefined)
            {
				obj.detachEvent( 'on' + type, obj[ type + fn ] );
			}
			obj[ type + fn ] = null;
	  } else {
		obj.removeEventListener( type, fn, false );
	  }
	}
	
	window[ NAMESPACE ] = {
		toggle:
			function() { if(isLoggingActive()){( isVisible() ) ? hide() : show(); }},
		resize:
			function() { resize(); },
		clear:
			function() { clear(); },
		move:
			function() { reposition(); },
		debug: 
			function( msg ) { if(isLoggingActive()){addMessage( 'debug', msg ); }},
		warn:
			function( msg ) { if(isLoggingActive()){addMessage( 'warn', msg ); }},
		info:
			function( msg ) { if(isLoggingActive()){addMessage( 'info', msg ); }},
		error: 
			function( msg ) { if(isLoggingActive()){addMessage( 'error', msg ); }},
		activateLogging:
			function(){
				//Set the state.active to true
				setLogging();
			},
		disableLogging:
			function(){
				stopLogging();
			},
		profile: 
			function( label ) {
				var currentTime = new Date(); //record the current time when profile() is executed
				
				if ( label == undefined || label == '' ) {
					addMessage( 'error', '<b>ERROR:</b> Please specify a label for your profile statement' );
				}
				else if ( profiler[ label ] ) {
					addMessage( 'profile', [ label, ': ', currentTime - profiler[ label ],	'ms' ].join( '' ) );
					delete profiler[ label ];
				}
				else {
					profiler[ label ] = currentTime;
					addMessage( 'profile', label );
				}
				return currentTime;
			},
		isBlackBirdActive:
			function() {
				return isLoggingActive();
			}
	}

	addEvent( window, 'load', 
		/* initialize Blackbird when the page loads */
		function() {
			var body = document.getElementsByTagName( 'BODY' )[ 0 ];
			bbird = body.appendChild( generateMarkup() );
			outputList = bbird.getElementsByTagName( 'OL' )[ 0 ];
		
			backgroundImage();
		
			//add events
			//addEvent( IDs.checkbox, 'click', clickVis );
			addEvent( IDs.filters, 'click', clickFilter );
			addEvent( IDs.controls, 'click', clickControl );
			addEvent( document, 'keyup', readKey);

			resize( state.size );
			reposition( state.pos );
			if ( state.load ) {
				show();
				//document.getElementById( IDs.checkbox ).checked = true; 
			}

			scrollToBottom();

			window[ NAMESPACE ].init = function() {
				show();
				window[ NAMESPACE ].error( [ '<b>', NAMESPACE, '</b> can only be initialized once' ] );
			}

			addEvent( window, 'unload', function() {
				//removeEvent( IDs.checkbox, 'click', clickVis );
				removeEvent( IDs.filters, 'click', clickFilter );
				removeEvent( IDs.controls, 'click', clickControl );
				removeEvent( document, 'keyup', readKey );
			});
			
			if(state.active){
				//Prevent logging from occuring next reload
				loggingActive = true;
				state.active = false;
				state.load = false;
				state.size = 1;
				setState();
			}
		});
})();/**
 * @class
 * This is the base Logger interface. It exposes the methods necessary for logging
 * but leaves specific implementation up to concrete implementations of a Logger.
 * @constructor
 */
function Logger() {
	this.m_activated = false;
	this.m_lineBreak = "";
}

/**
 * Returns a true/false value determining whether the Logger is currently active or not.
 * @returns {boolean}
 */
Logger.prototype.isActivated = function() {
	return this.m_activated;
};

/**
 * Sets whether the Logger is currently active or not.
 * @param {boolean} activated - Whether the Logger is currently activated or not.
 * @returns {undefined}
 */
Logger.prototype.setIsActivated = function(activated) {
	this.m_activated = activated;
};

/**
 * Sets the string to utilize for line breaks in the logging messages
 * @param {String} lineBreak String to utilize for line breaks
 * @returns {undefined}
 */
Logger.prototype.setLineBreak = function(lineBreak) {
	this.m_lineBreak = lineBreak;
};

/**
 * Returns the string to utilize for line breaks in the logging messages
 * @returns {String} String to utilize for line breaks
 */
Logger.prototype.getLineBreak = function() {
	return this.m_lineBreak;
};

/**
 * This method will activate the logger. It sets the enabled state of the logger to true then stores the state in the
 * cookie.
 * @param {boolean} refreshCookie - Whether the document cookie should be updated.
 */
Logger.prototype.activate = function () {
	if(this.isActivated()) {
		return;
	}
	//Make the call to update the logger prototype with actual logging function definitions
	if(this.isLoggingAvailable()) {
		this.addLoggingDefinitionsToPrototype();
	}
	this.setIsActivated(true);
};

/**
 * This method will add the necessary logging method implementations on the fly. This method will be implemented
 * by the sub-classes of the Logger.
 */
Logger.prototype.addLoggingDefinitionsToPrototype = function() {
	return;
};

/**
 * Determines if logging is available. This is an interface method and should be implemented by sub-classes of the
 * Logger class.
 * @returns {boolean}
 */
Logger.prototype.isLoggingAvailable = function () {
	return false;
};


/**
 * Logs a message. This is an interface method and should be implemented by sub-classes of the
 * Logger class.
 * @param {string} message - The message to be logged.
 */
Logger.prototype.logMessage = function (message) {
	return false;
};

/**
 * Logs a debug message. This is an interface method and should be implemented by sub-classes of the
 * Logger class.
 * @param {string} debug - The debug message to be logged.
 */
Logger.prototype.logDebug = function (debug) {
	return false;
};

/**
 * Logs a warning. This is an interface method and should be implemented by sub-classes of the
 * Logger class.
 * @param {string} warning - The warning to be logged.
 */
Logger.prototype.logWarning = function (warning) {
	return false;
};

/**
 * Logs an error. This is an interface method and should be implemented by sub-classes of the
 * Logger class.
 * @param {string} error - The error to be logged.
 */
Logger.prototype.logError = function (error) {
	return false;
};

/**
 * Logs script call information.
 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
 * @param {ScriptRequest} request - The script request that was made.
 * @param {string} file - The JS file from which the script call was made.
 * @param {string} funcName - The name of the function.
 */
Logger.prototype.logScriptCallInfo = function (component, request, file, funcName) {
	return false;
};

/**
 * Logs a script call error.
 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
 * @param {ScriptRequest} request - The script request that was made.
 * @param {string} file - The JS file from which the script call was made.
 * @param {string} funcName - The name of the function.
 */
Logger.prototype.logScriptCallError = function (component, request, file, funcName) {
	return false;
};

/**
 * Logs a JavaScript error.
 * @param {Error} err - The error that occurred.
 * @param {MPageComponent} component - The component in which the error originated.
 * @param {string} file - The JS file from which the JavaScript error originated.
 * @param {string} funcName - The function from which the JavaScript error originated.
 */
Logger.prototype.logJSError = function (err, component, file, funcName) {
	return false;
};

/**
 * Logs Discern Information.
 * @param {MPageComponent} component - The component from which the information is being logged.
 * @param {string} objectName - The name of the object for which information is being logged.
 * @param {string} file - The JS file from which the information is being logged.
 * @param {string} funcName - The function from which the information is being logged.
 */
Logger.prototype.logDiscernInfo = function (component, objectName, file, funcName) {
	return false;
};

/**
 * Logs MPages event information.
 * @param {MPageComponent} component - The component from which the information is being logged.
 * @param {string} eventName - The name of the event that occurred.
 * @param {string} params - The parameters associated to the MPages event.
 * @param {string} file - The JS file from which the information is being logged.
 * @param {string} funcName - The function from which the information is being logged.
 */
Logger.prototype.logMPagesEventInfo = function (component, eventName, params, file, funcName) {
	return false;
};

/**
 * Logs CCLNEWSESSIONWINDOW information.
 * @param {MPageComponent} component - The component from which the information is being logged.
 * @param {string} params - The parameters associated to the CCLNEWSESSIONWINDOW.
 * @param {string} file - The JS file from which the information is being logged.
 * @param {string} funcName - The function from which the information is being logged.
 */
Logger.prototype.logCCLNewSessionWindowInfo = function (component, params, file, funcName) {
	return false;
};

/**
 * Logs timer information.
 * @param {string} timerName - The name of the timer.
 * @param {string} subTimerName - The sub timer name.
 * @param {string} timerType - The type of timer.
 * @param {string} file - The JS file from which the information is being logged.
 * @param {string} funcName - The function from which the information is being logged.
 */
Logger.prototype.logTimerInfo = function (timerName, subTimerName, timerType, file, funcName) {
	return false;
};

/**
 * Creates a single log message based on array of strings seperated by line breaks
 * @param  {Array<String>} messages Array of strings to display in logger
 * @returns {undefined}
 */
Logger.prototype.logMessages = function (messages) {
	if (!(messages instanceof Array)){
		throw new Error("Logger.prototype.logMessages only accepts array arguments");
	}
	var fullMessageString = this.joinMessagesWithBreaks(messages);
	this.logMessage(fullMessageString);
};

/**
 * Logs an error containing all the passed messages seperated by line breaks
 * @param  {Array<String>}  messages Array of strings to display in logger
 * @returns {undefined}
 */
Logger.prototype.logErrors = function(messages) {
	if (!(messages instanceof Array)){
		throw new Error("Logger.prototype.logErrors only accepts array arguments");
	}
	var fullMessageString = this.joinMessagesWithBreaks(messages);
	this.logError(fullMessageString);
};

/**
 * Creates a single log message based on array of strings seperated by line breaks
 * @param  {Array<String>} messages Array of strings to display in logger
 * @returns {String} String containing messages seperated by line breaks
 */
Logger.prototype.joinMessagesWithBreaks = function (messages) {
	if (!(messages instanceof Array)){
		throw new Error("Logger.prototype.joinMessagesWithBreaks only accepts array arguments");
	}
	var lineBreak = this.getLineBreak();
	return messages.join(lineBreak);
};
/**
 * @class
 * This class is a sub-class of Logger and implements the interface methods. This implementation will
 * log all messages via Blackbird. This class serves as a wrapper (adaptor) which allows a cleaner interface
 * with Blackbird.
 * @constructor
 */
function BlackBirdLogger() {
	this.setLineBreak("<br />");
}
BlackBirdLogger.prototype = new Logger();
BlackBirdLogger.prototype.constructor = Logger;

BlackBirdLogger.prototype.addLoggingDefinitionsToPrototype = function() {
	/**
	 * Logs a message out to the Blackbird logger.
	 * @param {string} message - The message to be logged.
	 */
	BlackBirdLogger.prototype.logMessage = function (message) {
		log.info(message);
	};

	/**
	 * Logs a debug message out to the Blackbird logger.
	 * @param {string} debug - The debug message to be logged.
	 */
	BlackBirdLogger.prototype.logDebug = function (debug) {
		log.debug(debug);
	};

	/**
	 * Logs a warning out to the Blackbird logger.
	 * @param {string} warning - The warning to be logged.
	 */
	BlackBirdLogger.prototype.logWarning = function (warning) {
		log.warn(warning);
	};

	/**
	 * Logs an error out to the Blackbird logger.
	 * @param {string} error - The error to be logged.
	 */
	BlackBirdLogger.prototype.logError = function (error) {
		log.error(error);
	};

	/**
	 * Logs script call information.
	 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
	 * @param {ScriptRequest} request - The script request that was made.
	 * @param {string} file - The JS file from which the script call was made.
	 * @param {string} funcName - The name of the function.
	 */
	BlackBirdLogger.prototype.logScriptCallInfo = function (component, request, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />Script: ", request.url, "<br />Request: ", request.requestText, "<br />Reply: ", request.responseText].join(""));
	};

	/**
	 * Logs a script call error.
	 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
	 * @param {ScriptRequest} request - The script request that was made.
	 * @param {string} file - The JS file from which the script call was made.
	 * @param {string} funcName - The name of the function.
	 */
	BlackBirdLogger.prototype.logScriptCallError = function (component, request, file, funcName) {
		this.logError(["Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />Script: ", request.url, "<br />Request: ", request.requestText, "<br />Reply: ", request.responseText, "<br />Status: ", request.status].join(""));
	};

	/**
	 * Logs a JavaScript error.
	 * @param {Error} err - The error that occurred.
	 * @param {MPageComponent} component - The component in which the error originated.
	 * @param {string} file - The JS file from which the JavaScript error originated.
	 * @param {string} funcName - The function from which the JavaScript error originated.
	 */
	BlackBirdLogger.prototype.logJSError = function (err, component, file, funcName) {
		this.logError(["Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />JS Error", "<br />Message: ", err.message, "<br />Name: ", err.name, "<br />Number: ", (err.number & 0xFFFF), "<br />Description: ", err.description].join(""));
	};

	/**
	 * Logs Discern Information
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} objectName - The name of the object for which information is being logged.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	BlackBirdLogger.prototype.logDiscernInfo = function (component, objectName, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />Discern Object: ", objectName].join(""));
	};

	/**
	 * Logs MPages event information.
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} eventName - The name of the event that occurred.
	 * @param {string} params - The parameters associated to the MPages event.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	BlackBirdLogger.prototype.logMPagesEventInfo = function (component, eventName, params, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />MPAGES_EVENT: ", eventName, "<br />Params: ", params].join(""));
	};

	/**
	 * Logs CCLNEWSESSIONWINDOW information.
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} params - The parameters associated to the CCLNEWSESSIONWINDOW.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	BlackBirdLogger.prototype.logCCLNewSessionWindowInfo = function (component, params, file, funcName) {
		this.logDebug(["CCLNEWSESSIONWINDOW Creation", "Component: ", ( component ? component.getLabel() : ""), "<br />ID: ", ( component ? component.getComponentId() : ""), "<br />File: ", file, "<br />Function: ", funcName, "<br />Params: ", params].join(""));
	};

	/**
	 * Logs timer information.
	 * @param {string} timerName - The name of the timer.
	 * @param {string} subTimerName - The sub timer name.
	 * @param {string} timerType - The type of timer.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	BlackBirdLogger.prototype.logTimerInfo = function (timerName, subTimerName, timerType, file, funcName) {
		this.logDebug(["Timer Name: ", timerName, "<br />Subtime Name:  ", subTimerName, "<br />Timer Type: ", timerType, "<br />File: ", file, "<br />Function: ", funcName].join(""));
	};
};

/**
 * Overrides the base activate method. This will call the base activate method then make the call to the
 * Blackbird logger object to activate it as well.
 * @param {boolean} refreshCookie - Whether the document cookie should be updated.
 */
BlackBirdLogger.prototype.activate = function () {
	Logger.prototype.activate.call(this);
	//Make the call to the actual Blackbird object to activate it
	log.activateLogging();
};

/**
 * Determines if Blackbird logging is available.
 * @returns {boolean}
 */
BlackBirdLogger.prototype.isLoggingAvailable = function () {
	return (typeof log == "object");
};
/**
 * @class
 * This class is a sub-class of Logger and implements the interface methods. This implementation will log
 * all messages to the native console via console.log(...).
 * @constructor
 */
function ConsoleLogger() {
	if(typeof console.debug === "undefined") {
		console.debug = console.log;
	}
	this.setLineBreak("\n");
}
ConsoleLogger.prototype = new Logger();
ConsoleLogger.prototype.constructor = Logger;

ConsoleLogger.prototype.addLoggingDefinitionsToPrototype = function() {
	/**
	 * Logs a message out to the native console.
	 * @param {string} message - The message to be logged.
	 */
	ConsoleLogger.prototype.logMessage = function(message) {
		console.log(message);
	};
	/**
	 * Logs a debug message out to the native console. Note that Internet Explorer does not have console.debug, so a
	 * check is performed to see if console.debug is defined. If not, console.debug is set to console.log.
	 * @param {string} debug - The debug message to be logged.
	 */
	ConsoleLogger.prototype.logDebug = function(debug) {
		console.debug(debug);
	};
	/**
	 * Logs a warning out to the native console.
	 * @param {string} warning - The warning to be logged.
	 */
	ConsoleLogger.prototype.logWarning = function(warning) {
		console.warn(warning);
	};
	/**
	 * Logs an error out to the native console.
	 * @param {string} error - The error to be logged.
	 */
	ConsoleLogger.prototype.logError = function(error) {
		console.error(error);
	};
	/**
	 * Logs script call information.
	 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
	 * @param {ScriptRequest} request - The script request that was made.
	 * @param {string} file - The JS file from which the script call was made.
	 * @param {string} funcName - The name of the function.
	 */
	ConsoleLogger.prototype.logScriptCallInfo = function (component, request, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nScript: ", request.url, "\nRequest: ", request.requestText, "\nReply: ", request.responseText].join(""));
	};
	/**
	 * Logs a script call error.
	 * @param {MPageComponent} component - The MPageComponent for which the script call info was made (if any).
	 * @param {ScriptRequest} request - The script request that was made.
	 * @param {string} file - The JS file from which the script call was made.
	 * @param {string} funcName - The name of the function.
	 */
	ConsoleLogger.prototype.logScriptCallError = function (component, request, file, funcName) {
		this.logError(["Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nScript: ", request.url, "\nRequest: ", request.requestText, "\nReply: ", request.responseText, "\nStatus: ", request.status].join(""));
	};
	/**
	 * Logs a JavaScript error.
	 * @param {Error} err - The error that occurred.
	 * @param {MPageComponent} component - The component in which the error originated.
	 * @param {string} file - The JS file from which the JavaScript error originated.
	 * @param {string} funcName - The function from which the JavaScript error originated.
	 */
	ConsoleLogger.prototype.logJSError = function (err, component, file, funcName) {
		this.logError(["Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nJS Error", "\nMessage: ", err.message, "\nName: ", err.name, "\nNumber: ", (err.number & 0xFFFF), "\nDescription: ", err.description].join(""));
	};
	/**
	 * Logs Discern Information
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} objectName - The name of the object for which information is being logged.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	ConsoleLogger.prototype.logDiscernInfo = function (component, objectName, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nDiscern Object: ", objectName].join(""));
	};
	/**
	 * Logs MPages event information.
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} eventName - The name of the event that occurred.
	 * @param {string} params - The parameters associated to the MPages event.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	ConsoleLogger.prototype.logMPagesEventInfo = function (component, eventName, params, file, funcName) {
		this.logDebug(["Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nMPAGES_EVENT: ", eventName, "\nParams: ", params].join(""));
	};
	/**
	 * Logs CCLNEWSESSIONWINDOW information.
	 * @param {MPageComponent} component - The component from which the information is being logged.
	 * @param {string} params - The parameters associated to the CCLNEWSESSIONWINDOW.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	ConsoleLogger.prototype.logCCLNewSessionWindowInfo = function (component, params, file, funcName) {
		this.logDebug(["CCLNEWSESSIONWINDOW Creation", "Component: ", ( component ? component.getLabel() : ""), "\nID: ", ( component ? component.getComponentId() : ""), "\nFile: ", file, "\nFunction: ", funcName, "\nParams: ", params].join(""));
	};
	/**
	 * Logs timer information.
	 * @param {string} timerName - The name of the timer.
	 * @param {string} subTimerName - The sub timer name.
	 * @param {string} timerType - The type of timer.
	 * @param {string} file - The JS file from which the information is being logged.
	 * @param {string} funcName - The function from which the information is being logged.
	 */
	ConsoleLogger.prototype.logTimerInfo = function (timerName, subTimerName, timerType, file, funcName) {
		this.logDebug(["Timer Name: ", timerName, "\nSubtime Name:  ", subTimerName, "\nTimer Type: ", timerType, "\nFile: ", file, "\nFunction: ", funcName].join(""));
	};
};

/**
 * Determines if logging is available. This performs the check to see if the native console object exists.
 * @returns {boolean}
 */
ConsoleLogger.prototype.isLoggingAvailable = function () {
	return (typeof console === "object");
};
/**
 * Determine which type of logger to provide at a global level. If in the context of Millennium, use
 * BlackbirdLogger, otherwise use the ConsoleLogger.
 * @type {BlackBirdLogger | ConsoleLogger}
 */
window["logger"] = (CERN_Platform.inMillenniumContext()) ? new BlackBirdLogger() : new ConsoleLogger();
(function(){
	var cookie = document.cookie;
	if (!cookie) {
		return;
	}
	var loggerSettingsRegex = new RegExp(/logger=({[^;]+})(;|\b|$)/);
	var loggerSettings = loggerSettingsRegex.exec(cookie);
	if (!loggerSettings || !loggerSettings.length) {
		return;
	}
	loggerSettings = JSON.parse(loggerSettings[1]);
	var wasEnabled = loggerSettings.enabled;
	if (wasEnabled === "true") {
		window.logger.activate();
	}
	//Force the logger cookie to be disabled.
	document.cookie = 'logger={"enabled":"false"}';
})();


/**
 * Listen for the CTRL+\ keypress and toggle the active state of the current Logger.
 * @param {Event} evt - The JavaScript keypress event that was triggered.
 */
document.onkeypress = function(evt){
	if (!evt) {
		evt = window.event;
	}
	if(evt.ctrlKey==1 && evt.keyCode == 28){
		window.logger.activate();
		document.cookie = 'logger={"enabled":"true"}';
	}
};
/**
 * A collection of functions which can be used to save and delete tagged results.
 * @constructor
 */
var TaggingHandler = function(){
	
	//The user id which will be used when tagging and querying for tagged results
	this.m_userId = 0.0;
	
	//The encounter id to use when tagging and querying for tagged results
	this.m_encounterId = 0.0;
	
	//The patient id to use when tagging and querying for tagged results
	this.m_patientId = 0.0;
	
	//The person position code to use when tagging and querying for tagged results
	this.m_pprCode = 0.0;		
	
	//A flag used to determine if tagging is available or not
	this.m_taggingAvailable = false;
	
	//This field will hold the actual contents for the Tagged Results Utility menu
	this.m_taggedResultsContent = "";
	
	//The element id for the icon of the utilities menu
	this.m_taggingMenuEleId = "";
};

/* Checkers */

/**
 * Checks to see if tagging is available
 * @return {boolean} True if tagging is available, false otherwise 
 */
TaggingHandler.prototype.isTaggingAvailable = function(){
	return this.m_taggingAvailable;
};

/* Getters */

/**
 * Retrieves the id of the encounter that will be used when tagging a result or querying for tagged results
 * @return {number} The id of the current encounter
 */
TaggingHandler.prototype.getEncounterId = function(){
	return this.m_encounterId;
};

/**
 * Gets the id of the patient that will be used when handling tagging queries.
 * @return {number} The id of the patient.
 */
TaggingHandler.prototype.getPatientId = function() {
	return this.m_patientId;
};

/**
 * Get the PPR code that will be used when tagging a result
 * @return {number} the PPR code
 */
TaggingHandler.prototype.getPPRCode = function() {
	return this.m_pprCode;
};

/**
 * Retrieves the contents of the tagged results container
 * @return {string} The HTML markup for the tagged results container
 */
TaggingHandler.prototype.getTaggedResultsContent = function(){
	return this.m_taggedResultsContent;
};

/**
 * Gets the id of the tagged results menu element
 * @return {String} elementId The id of the tagged results menu element
 */
TaggingHandler.prototype.getTaggingMenuElementId = function(elementId){
	return this.m_taggingMenuEleId;
};


/**
 * Retrieves the id of the user that will be used when tagging a result or querying for tagged results
 * @return {number} The id of the user who tagged the result
 */
TaggingHandler.prototype.getUserId = function(){
	return this.m_userId;
};


/* Setters */

/**
 * Sets the id of the encounter to use for this tagging and querying for tagged results.  This should be the id of the encounter 
 * currently being viewed by the user and not the encounter when the result was documented.
 * @param {number} encounterId The id of the encounter currently being viewed
 * @return {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setEncounterId = function(encounterId){
	if(typeof encounterId == "number"){
		this.m_encounterId = encounterId;
	}
	return this;
};

/**
 * Sets the patient id to use for tagging. This should be the patient id as returned in the criterion.
 * @param {number} patientId the id of the patient.
 * @return {TaggingHandler} returns self.
 */
TaggingHandler.prototype.setPatientId = function(patientId) {
	if(typeof patientId !== "number") {
		throw new Error("Called setPatientId on TaggingHandler with non number type for patientId parameter");
	}
	this.m_patientId = patientId;
	return this;
};

/**
 * Sets the PPR code to use for tagging. This should be the ppr code as returned in the criterion.
 * @param {number} pprCode the ppr code.
 * @return {TaggingHandler} returns self.
 */
TaggingHandler.prototype.setPPRCode = function(pprCode) {
	if(typeof pprCode !== "number") {
		throw new Error("Called setPPRCode on TaggingHandler with non number type for pprCode parameter");
	}
	this.m_pprCode = pprCode;
	return this;
};

/**
 * Sets the contents of the tagged results list
 * @param {String} taggedContents The contents that will be shown in the tagged results container
 * @return {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggedResultsContent = function(taggedContents){
	if(typeof taggedContents == "string"){
		this.m_taggingResultsContent = taggedContents;
	}
	return this;
};

/**
 * Sets the id of the tagged results menu element
 * @param {String} elementId The id of the tagged results menu element
 * @return {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggingMenuElementId = function(elementId){
	if(typeof elementId == "string"){
		this.m_taggingMenuEleId = elementId;
	}
	return this;
};

/**
 * Sets the flag which indicates if tagging is available or not
 * @param {taggingAvailable} taggingAvailable The flag used to determine if tagging is available or not
 * @return {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggingAvailable = function(taggingAvailable){
	if(typeof taggingAvailable == "boolean"){
		this.m_taggingAvailable = taggingAvailable;
	}
	return this;
};

/**
 * Sets the id of the user tagging the result.
 * @param {number} userId The id of the user tagging the result
 * @return {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setUserId = function(userId){
	if(typeof userId == "number"){
		this.m_userId = userId;
	}
	return this;
};

/* Actions */
/**
 * Initializes the tagging utility within the viewpoint framework.  This includes settings the user and encounter id which are used later when tagging and querying results
 * and creating the UtilitiesMenu for the user interface. 
 * @param {string} utilIconElementId The HTML id for the icon that will be used for the viewpoint utility
 * @param {Criterion} criterion The criterion object used to extract the user id and encounter id
 */
TaggingHandler.prototype.initTaggingUtility = function(utilIconElementId, criterion){
	var self = this;
	var rti18n = i18n.discernabu.mpageResultTagging;
	var vwpHeaderHeight = 38;
	//Save off the userId and encounter Id for future use
	this.setUserId(criterion.provider_id);
	this.setPatientId(criterion.person_id);
	this.setEncounterId(criterion.encntr_id);
	this.setPPRCode(criterion.ppr_cd);
	
	//Update the taggingAvailable indicator so components know that they can tag results
	this.setTaggingAvailable(true);
	this.setTaggingMenuElementId(utilIconElementId);
	
	//Add the necessary click event to the utilities menu
	var taggingIcon = $("#" + utilIconElementId);
	if(taggingIcon.length){
		$(taggingIcon).addClass("tagging-util-icon").attr("title", rti18n.TAGGED_ITEMS);
	}
	
	//Get the tagging util anchor
	var taggingUtilAnchor = taggingIcon.parent();
	if(taggingUtilAnchor.length){
		//Create the UtilitiesMenu and attach click events
		var taggingMenu = new UtilitiesMenu("resultTagging");
		taggingMenu.setLabel(rti18n.TAGGED_ITEMS + "<span id='taggingRemoveAll' class='tagging-remove-all'>" + rti18n.REMOVE_ALL + "</span>");
		taggingMenu.setWidth(400);
		//Determine the maxHeight for the contents
		taggingMenu.setAnchorElementId($(taggingUtilAnchor).attr("id"));
		taggingMenu.setAnchorActiveClass("vwp-util-active");
		taggingMenu.setAnchorConnectionCorner(["bottom", "right"]);
		taggingMenu.setContentConnectionCorner(["top", "right"]);
		taggingMenu.setUtilitiesContentCreationFunction(function(){ return self.queryTaggedResults();});
		MP_MenuManager.addMenuObject(taggingMenu);
		
		//Add the click event to the viewpoint Utilities control
		$(taggingUtilAnchor).click(function(){
			if(taggingMenu.isVisible()){
				MP_MenuManager.closeMenuStack();
			}
			else{
				taggingMenu.setMaxHeight($("#vwpBody").height() - vwpHeaderHeight);
				MP_MenuManager.showMenu("resultTagging");
			}
		});
	}
	
	//Kick off a script call to populate the Result Tagging menu after a timeout to allow the components to load first
	setTimeout(function(){
		self.queryTaggedResults();
	}, 3000);
};

/**
 * Performs a call to the CCL script MP_DELETE_TAGGED_RESULTS with the ids of all of the tagged results to delete.  The MP_DELETE_TAGGED_RESULTS script
 * calls the same service as MP_QUERY_TAGGED_RESULTS and returns the contents in order to keep the contents in the Tagged Results utilities menu updated.
 * @param {[number]} deleteList. A JSON list of tagged entities to be removed. The format MUST be as follows: [{"contentType":"EMR_MEANING", "entityId" : "ENTITY_ID},{},...,{}]
 * where EMR_MEANING is the emr meaning that will be looked up in codeset 32000 and ENTITY_ID is the tagged entity id.
 */
TaggingHandler.prototype.deleteTaggedResults = function(deleteList){
	var self = this;
	try{
		//Verify the User Id is populated
		var userId = this.getUserId();
		if(!userId){
			throw new Error("Cannot delete a tag result without the User Id populated");
		}
		//Verify the Patient Id is populated
		var patientId = this.getPatientId();
		if(!patientId) {
			throw new Error("Cannot retrieve tagged results without the patient id populated");
		}
		//Verify the Encounter Id is populated
		var encounterId = this.getEncounterId();
		if(!encounterId){
			throw new Error("Cannot delete a tag result without the Encounter Id populated");
		}
		//Verify the ppr code. This value is only used for the query which is also called after deletion
		var pprCode = this.getPPRCode();
		if(!pprCode) {
			throw new Error("Cannot delete a tagged result without the user PPR code populated");
		}
		
		//If there is nothing to delete, just return.
		if(!deleteList.DELETE_TAG.TAG_LIST) {
			return;
		}
		
		//If we have tags to delete, perform the request. Must use tilde to prevent browser development from breaking.
		var params = ["^MINE^", userId + ".0", patientId + ".0", encounterId + ".0", pprCode + ".0", "~"+JSON.stringify(deleteList)+"~"];
		var deleteTagsRequest = new MP_Core.ScriptRequest();
		deleteTagsRequest.setName("removeTaggedResult");
		deleteTagsRequest.setProgramName("MP_DELETE_TAGGED_RESULTS");
		deleteTagsRequest.setParameters(params);
		deleteTagsRequest.setAsync(true);
		MP_Core.XMLCCLRequestCallBack(null, deleteTagsRequest, function(scriptReply){self.taggingCallback(scriptReply);});
	}
	catch(error){
		MP_Util.LogJSError(error, null, "TaggingHandler.js", "deleteTaggedResults");
	}
};

/**
 * Attempts to save tagged results via the MP_SAVE_TAGGED_RESULTS ccl script. It expects a list of TaggedResult objects. For each of the
 * provided TaggedResult objects, the necessary fields are validated. If they are not provided, an exception is thrown.
 * @param {Array<TaggedResult>} A list of TaggedResult objects to be saved. This must be a 
 * @param {boolean} longXHTMLFormatInd An indicator which determines if the request to the Query Tag transaction should return the log form XHTML.  Defaults to false.
 */
TaggingHandler.prototype.saveTaggedResults = function(taggedResults, longXHTMLFormatInd) {
	var self = this;
	
	//Helper function to check the necessary tag fields
	function checkTagField(tagField, errorMessage) {
		if(!tagField) {
			throw new Error(errorMessage);
		}
	}
	
	try {
		if(!Array.prototype.isPrototypeOf(taggedResults)) {
			throw new Error("Called saveTaggedResults on TaggingHandler with non Array type for taggedResults parameter");
		}
		//If there are no items to tag, just return
		if(!taggedResults.length) {
			return;
		}
		var userId = this.getUserId();
		if(!userId) {
			throw new Error("Cannot tag a result without the User Id populated");
		}
		//Verify the Encounter Id is populated
		var encounterId = this.getEncounterId();
		if(!encounterId){
			throw new Error("Cannot tag a result without the Encounter Id populated");
		}
		// //Define the record structure required by mp_save_tagged_results
		var saveTagJSON = {
			"SAVE_TAGS" : {
				"TAG_LIST" : []
			}
		};
		//Grab a reference to the list that we're storing the tags in
		var saveTagListJSON = saveTagJSON.SAVE_TAGS.TAG_LIST;
		//Loop through the tag items and add create their corresponding JSON object
		for(var i = 0; i < taggedResults.length; i++) {
			var tag = taggedResults[i];
			//Verify the EMR Type id is populated
			var emrType = tag.getEMRType();
			checkTagField(emrType, "Cannot tag a result without the EMR Type populated");
			//Verify the Entity Id is populated
			var tagEntityId = tag.getTagEntityId();
			checkTagField(tagEntityId, "Cannot tag a result without the Tag Entity Id populated");
			//Verify the Tag Date Time is populated
			var tagDateTime = tag.getTagDateTime();
			checkTagField(tagDateTime, "Cannot tag a result without the Tag Date Time populated");
			//Get the tagged text.  No need to verify since it is optional
			var taggedText = tag.getTagText();		
			//Verify the Categorization XML is populated
			var categorizationXML = tag.getCategorizationXML();
			checkTagField(categorizationXML, "Cannot tag a result without the Categorization XML populated");
			//Push an individual JSON(ified) version of the tagging object into the list to be saved
			saveTagListJSON.push({
				EMR_TYPE: emrType,
				TAG_ENTITY_ID: tagEntityId + ".0",
				TAG_DT_TM: tagDateTime,
				TAG_TEXT: taggedText,
				CATEGORIZATION_XML: categorizationXML,
				FORMAT_CD: "XHTML"
			});
		}
		//If we have tags to delete, perform the request. Must use tilde to prevent browser development from breaking.
		var params = ["^MINE^", userId + ".0", encounterId + ".0","~"+JSON.stringify(saveTagJSON)+"~"];
		var saveTagsRequest = new MP_Core.ScriptRequest();
		saveTagsRequest.setName("saveTaggedResult");
		saveTagsRequest.setProgramName("MP_SAVE_TAGGED_RESULTS");
		saveTagsRequest.setParameters(params);
		saveTagsRequest.setAsync(true);
		MP_Core.XMLCCLRequestCallBack(null, saveTagsRequest, function(scriptReply){self.taggingCallback(scriptReply);});
	} catch(err) {
		MP_Util.LogJSError(err, null, "TaggingHandler.js", "saveTaggedResults");
	}
};

/**
 * Attempts to save a list of tagged result based on the TaggedResult object list passed into the function.  Before making the call to the MP_SAVE_TAGGED_RESULTS CCL 
 * script, all of the required fields are validated.  If all of the required fields are not valid then no call is made.  The MP_SAVE_TAGGED_RESULTS script
 * calls the same service as MP_QUERY_TAGGED_RESULTS and returns the contents in order to keep the contents in the Tagged Results utilities menu updated.
 * @param {TaggedResult} taggedResult A list of a TaggedResult object which contains all of the necessary information for tagging a result.
 * @param {boolean} longXHTMLFormatInd An indicator which determines if the request to the Query Tag transaction should return the log form XHTML.  Defaults to false.
 */
TaggingHandler.prototype.saveTaggedResult = function(taggedResult, longXHTMLFormatInd){
	this.saveTaggedResults([taggedResult], longXHTMLFormatInd);
};

/**
 * Performs a CCL script call to MP_QUERY_TAGGED_RESULTS which returns the HTMl markup for all of the currently tagged results. 
 * @param {boolean} longXHTMLFormatInd An indicator which determines if the request to the Query Tag transaction should return the log form XHTML.  Defaults to false.
 */
TaggingHandler.prototype.queryTaggedResults = function(longXHTMLFormatInd){
	var self = this;
	try{
		//Gather the necessary parameters and make the script call to tag the result
		//Verify the User Id is populated
		var userId = this.getUserId();
		if(!userId){
			throw new Error("Cannot retrieve tagged results without the User Id populated");
		}
		//Verify the Patient Id is populated
		var patientId = this.getPatientId();
		if(!patientId) {
			throw new Error("Cannot retrieve tagged results without the patient id populated");
		}
		//Verify the Encounter Id is populated
		var encounterId = this.getEncounterId();
		if(!encounterId){
			throw new Error("Cannot retrieve tagged results without the Encounter Id populated");
		}
		//Verify the ppr code
		var pprCode = this.getPPRCode();
		if(!pprCode) {
			throw new Error("Cannot retrieve tagged results without the PPR Code populated");
		}
		
		//Create the param array to send to the CCL Script
		var params = ["^MINE^", userId + ".0", patientId+".0",encounterId + ".0", pprCode + ".0"];
		var tagRequest = new MP_Core.ScriptRequest();
		tagRequest.setName("queryTaggedResult");
		tagRequest.setProgramName("MP_QUERY_TAGGED_RESULTS");
		tagRequest.setParameters(params);
		tagRequest.setAsync(true);
		MP_Core.XMLCCLRequestCallBack(null, tagRequest, function(reply){self.taggingCallback(reply);});
		
		//If the menu is open show the loading indicator
		return "<div class='tagging-loading'>&nbsp;</div>";
	}
	catch(error){
		MP_Util.LogJSError(error, null, "TaggingHandler.js", "queryTaggedResults");
	}
};

/**
 * This is the callback function for all of the script calls handled within the MP_TaggingHandler.  It is used to update the contents of 
 * the user interface such that it stays up to date for all tagging actions taking place. 
 * @param {ScriptReply} scriptReply
 */
TaggingHandler.prototype.taggingCallback = function(scriptReply){
	var menu = MP_MenuManager.getMenuObject("resultTagging");
	var self = this;
	var replyData = scriptReply.getResponse();
	var rti18n = i18n.discernabu.mpageResultTagging;
	var status = scriptReply.getStatus();
	var taggedContents = "";
	//Add the necessary click event to the utilities menu
	var taggingIcon = $("#" + this.getTaggingMenuElementId());
	
	//Tagging selector info
	var categoryClass = ".ddcategory";
	var individualResultSelector = ".ddemrcontentitem";
	var groupResultSelector = ".ddcategorytitle";
	var deleteIconSelector = ".tagging-delete";
	//Create a template for the delete icon, so we can create new ones on the fly.
	var deleteTemplate = TemplateBuilder.buildTemplate('<div class="tagging-delete" dd:settype="${setType}" dd:contenttype="${contentType}" dd:entityid="${entityId}"></div>');
	//Check the status of the script reply
	switch(status){
		case "S":
			if(taggingIcon.length){
				$(taggingIcon).addClass("tagging-util-icon-active");
			}
			//Add the click event to the remove all option
			if(menu && menu.isVisible()){
				var menuElement = $("#menuContentresultTagging");
				//Unbind the result tagging events. There is a race condition in which multiple events can be bound, causing the event to fire 
				//twice.
				menuElement.unbind(".resultTagging");
				//Hover over individual result
				menuElement.on("mouseenter.resultTagging", individualResultSelector, function(event){
					var item = $(event.currentTarget);
					//Append a delete button to the element. Go ahead and give it the content type and entity id so we can do trivial operations
					//when the icon is clicked.
					item.append(deleteTemplate.render({
						setType: "SINGLE_RESULT",
						contentType: item.attr("dd:contenttype"),
						entityId: item.attr("dd:entityid")
					}));
					event.stopPropagation();
				});
				//Mouse out of an individual result
				menuElement.on("mouseleave.resultTagging", individualResultSelector, function(event){				
					var item = $(event.currentTarget);
					item.find(deleteIconSelector).remove();
					event.stopPropagation();
				});
				//Mouse over a grouping of results
				menuElement.on("mouseenter.resultTagging", groupResultSelector, function(event){
					var item = $(event.currentTarget);
					//Append a delete icon to the category header, allowing us to delete the group of results
					item.append(deleteTemplate.render({setType: "RESULT_GROUP", contentType: "", entityId: ""}));
					event.stopPropagation();
				});
				//Mouse leave a grouping of results
				menuElement.on("mouseleave.resultTagging", groupResultSelector, function(event){
					$(event.currentTarget).find(deleteIconSelector).remove();
					event.stopPropagation();
				});
				//Click on a delete icon
				menuElement.on("click.resultTagging", deleteIconSelector, function(event){
					var item = $(event.currentTarget);
					var type = item.attr("dd:settype");
					var deleteList = {"DELETE_TAG" : {"TAG_LIST" : []}};
					//If this is a single result, we only push the one item into the array to be removed.
					if(type === "SINGLE_RESULT") {
						//Push the tagged info into a JSON object
						deleteList.DELETE_TAG.TAG_LIST.push({"contentType" : item.attr("dd:contenttype"), "entityId" : item.attr("dd:entityid") + ".0"});
					} else if(type === "RESULT_GROUP") {
						//Must find all ddemrcontentitems that belong to this grouping and push their tagging information
						//into the array to be deleted
						item.parents(categoryClass).find(individualResultSelector).each(function(index, element){
							element = $(element);
							deleteList.DELETE_TAG.TAG_LIST.push({"contentType" : element.attr("dd:contenttype"), "entityId" : element.attr("dd:entityid") + ".0"});
						});
					}
					//Make the call to delete the tagged results
					self.deleteTaggedResults(deleteList);
					event.stopPropagation();
				});
			
				var menuContent = $("#" + menu.getContentElementId() + " .utilities-menu-custom-content");
				//Show and create the click action for the Remove All link
				$("#menuContentresultTagging").find("#taggingRemoveAll").css("display", "inline").click(function(){
					//Show the confirm dialog and add the click event
					var removeDialog = menuContent.find(".tagging-remove-dialog");
					removeDialog.css("display", "block");
					removeDialog.find("#taggingRemoveAllCancel").click(function(){
						removeDialog.css("display", "none");
					});
					removeDialog.find("#taggingRemoveAllRemove").click(function(){
						var deleteList = {"DELETE_TAG" : {"TAG_LIST" : []}};
						//Grab all of the results
						menuContent.find(".ddemrcontentitem").each(function(index, element){
							element = $(element);
							//Push the tag information to be deleted into a JSON structure to be sent off to mp_delete_tagged_results
							deleteList.DELETE_TAG.TAG_LIST.push({"contentType" : element.attr("dd:contenttype"), "entityId" : element.attr("dd:entityid") + ".0"});
						});						
						//Perform the call to remove the tags
						self.deleteTaggedResults(deleteList);
						//Close the dialog
						MP_MenuManager.closeMenuStack();
					});
				});
			}
			//Save tagged result only returns the newly created tag id so we should try to update the HTML
			if(scriptReply.getName() !== "saveTaggedResult"){
				taggedContents += "<div class='tagging-remove-dialog'><div><span class='tagging-remove-warn'>&nbsp;</span><span>" + rti18n.REMOVE_ALL_TAGS + "</span></div><div><input id='taggingRemoveAllCancel' class='tagging-remove-button' type='button' value='" + i18n.CANCEL +"' /><input id='taggingRemoveAllRemove' class='tagging-remove-button' type='button' value='" + rti18n.REMOVE +"' /></div></div>";
				taggedContents += replyData.XHTML_TEXT;
			}
			break;
		case "F":
			var requestName = scriptReply.getName();
			var errorMessage = "";
			var errorTitle = "";
			var errorModal = MP_ModalDialog.retrieveModalDialogObject("resultTaggingErrorModal");
			if (!errorModal) {
				errorModal = new ModalDialog("resultTaggingErrorModal");
				//Create and add the close button
				var closeButton = new ModalButton("closeButton");
				closeButton.setText(i18n.discernabu.CONFIRM_OK).setCloseOnClick(true);
				errorModal.addFooterButton(closeButton);
				MP_ModalDialog.addModalDialogObject(errorModal);
			}
			if(requestName === "queryTaggedResult"){
				errorMessage = rti18n.QUERY_ERROR_MESSAGE;
				errorTitle = rti18n.QUERY_ERROR_TITLE;
			}
			else if(requestName === "saveTaggedResult"){
				errorMessage = rti18n.SAVE_ERROR_MESSAGE;
				errorTitle = rti18n.SAVE_ERROR_TITLE;
			}
			else if(requestName === "removeTaggedResult"){
				errorMessage = rti18n.REMOVE_ERROR_MESSAGE;
				errorTitle = rti18n.REMOVE_ERROR_TITLE;
			}
			errorModal = MP_Util.generateModalDialogBody("resultTaggingErrorModal", "error", errorMessage, i18n.discernabu.mpageResultTagging.ERROR_ACTION);
			errorModal.setHeaderTitle(errorTitle);
			MP_ModalDialog.updateModalDialogObject(errorModal);
			MP_ModalDialog.showModalDialog("resultTaggingErrorModal");
			//Update the Utilities Menu
			if(taggingIcon.length){
				$(taggingIcon).removeClass("tagging-util-icon-active");
			}
			if(menu && menu.isVisible()){
				$("#menuContentresultTagging").find("#taggingRemoveAll").css("display", "");
				taggedContents = "<p class='tagging-no-tags'>" + rti18n.NO_TAGGED_ITEMS_FOUND + "</p>";
			}
			break;
		case "Z":
			//Update the Utilities Menu
			if(taggingIcon.length){
				$(taggingIcon).removeClass("tagging-util-icon-active");
			}
			if(menu && menu.isVisible()){
				$("#menuContentresultTagging").find("#taggingRemoveAll").css("display", "");
				taggedContents = "<p class='tagging-no-tags'>" + rti18n.NO_TAGGED_ITEMS_FOUND + "</p>";
			}
			break;
	}	
	//Extract the updated HTML from the reply and save it for the next time the user opens the utility
	this.setTaggedResultsContent(taggedContents);
	
	//Check to see if the menu is open and update the contents if it is
	if(menu && menu.isVisible()){
		$("#" + menu.getContentElementId() + " .utilities-menu-custom-content").html(taggedContents);
	}
};

var MP_TaggingHandler = new TaggingHandler();
/**
 * The TaggedResult class is used as a base class for all types of tagged results.  For each type of result that can be tagged
 * a new implementation of the TaggedResult needs to be created and the EMR Type and Categorization XML set for that particular 
 * implementation.
 * @constructor
 */
var TaggedResult = function(){
	//The EMR Type Code correlates to the CDF_MEANING for a value in code set 32000 and should not be modified
	this.m_emrType = '';
	//This is the id used to look up the tagged item in the table associated with the EMR Type Code
	this.m_tagEntityId = 0.0;
	//This is the date and time when the result was last updated
	this.m_tagDateTime = '';
	//This is an optional parameter used when tagging text from a document
	this.m_tagText = '';
	//The categorization array will be used to dynamically create the categorization XML.  
	//This categorization XML is used by the Dynamic Documentation team to categorize tagged results
	this.m_categorizationArray = null;
	//The categorization XML created from the categorizationArray
	this.m_categorizationXML = '';
};

/* Getters */

/**
 * Retrieves the categorization array used to create the categorization xml markup for this TaggedResult.  
 * @return {string} The categorization XML associated with a specific type of TaggedResult
 */
TaggedResult.prototype.getCategorizationArray = function(){
	if(!this.m_categorizationArray){
		this.m_categorizationArray = [];
	}
	return this.m_categorizationArray;
};

/**
 * Retrieves the categorization xml markup for this TaggedResult.  The categorization XML is created when the caegorizationArray is
 * set.  
 * @return {string} The categorization XML associated with a specific type of TaggedResult
 */
TaggedResult.prototype.getCategorizationXML = function(){
	return this.m_categorizationXML;
};

/**
 * Retrieves the EMR Type set for this TaggedResult.  This will typically be set by the object inheriting from the TaggedResult
 * base class.
 * @return {string} The EMR Type that is associated with this TaggedResult 
 */
TaggedResult.prototype.getEMRType = function(){
	return this.m_emrType;
};

/**
 * Retrieves the last updated date and time associated with the TaggedResult.  The date and time will be in iso8601 format (YYYY-MM-DDTHH:MM:SSZ)
 * @return {string} The iso8601 representation of the last updated date and time set for the tagger result.
 */
TaggedResult.prototype.getTagDateTime = function(){
	return this.m_tagDateTime;
};

/**
 * Retrieves the tagged results's entity id.  This entity id differs based on the type of result being tagged.  For instance if tagging a Clinical Event this
 * entity id would hold the Event Id of that Clinical Event.
 * @return {number} The entity id associated with this TaggedResult
 */
TaggedResult.prototype.getTagEntityId = function(){
	return this.m_tagEntityId;
};

/**
 * Retreives the text that has been selected by the user for this TaggedResult.  This field is optional and only applies in certain scenarios.
 * @return {string} The text selected by the user for this TaggedResult
 */
TaggedResult.prototype.getTagText = function(){
	return this.m_tagText;
};



/* Setters */

/**
 * Sets the categorization array for this TaggedResult.  This array is used to create the cateogrization xml for this
 * particular tagged result.
 * @param {[string]} categorizationArray An array of strings which represents categories and sub categories.  For each element past the first, 
 * a new sub category will be created.
 * @return {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setCategorizationArray = function(categorizationArray){
	if(categorizationArray && categorizationArray.length){
		//Store the array as a separate reference
		this.m_categorizationArray = categorizationArray.slice(0);
		
		//Examine the contents and create the categorizationXML
		var catLength = categorizationArray.length;
		var lastIndex = catLength - 1;
		var catInject = "{0}";
		for(var x = 0; x < catLength; x++){
			if(x < lastIndex){
				catInject = catInject.replace('{0}', "<category display='" + categorizationArray[x] + "'>{0}</category>");
			}
			else{
				catInject = catInject.replace('{0}', "<category display='" + categorizationArray[x] + "' />");
			}
		}
		this.m_categorizationXML = "<?xml version='1.0' encoding='UTF-8'?><category-data xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='categorization.xsd'>" + catInject + "</category-data>";
	}
	return this;
};


/**
 * Sets the EMR Type for this TaggedResult.  The EMR Type is used to indicate which table the TaggedResult's information can be found on.  This fields is typically
 * set by the object inheriting from the TaggedResult and shouldn't be manually set by developers.  This field correlates to a CDF_MEANING of a event code in event
 * set 32000.
 * @param {string} emrType The CDF_MEANING of the EMR Type that is associated with object inheriting from TaggedResult
 * @return {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setEMRType = function(emrType){
	if(typeof emrType == "string"){
		this.m_emrType = emrType;
	}
	return this;
};

/**
 * Sets the date and time for the result being tagged.  This Date should be the last updated date for the result and should be in the iso8601 format sent from the back end.
 * @param {Date | string} tagDateTime If a string, just set it. If a date, then convert it to the desired format and set it.
 * @return {TaggedResult} The TaggedResult object calling this function so chaining can be used.
 */
TaggedResult.prototype.setTagDateTime = function(tagDateTime){
	//Just a little helper function to formate date values to add leading 0s (if necessary)
	function formatDateValue(value) {
		return value < 10 ? "0" + value : value;
	}
	if(typeof tagDateTime == "string"){
		this.m_tagDateTime = tagDateTime;
	} else if(Date.prototype.isPrototypeOf(tagDateTime)) {
		var currentMonth = formatDateValue(tagDateTime.getMonth()+1);
		var currentDate = formatDateValue(tagDateTime.getDate());
		var currentHours = formatDateValue(tagDateTime.getHours());
		var currentMinutes = formatDateValue(tagDateTime.getMinutes());
		var currentSeconds = formatDateValue(tagDateTime.getSeconds());
		//Format the date to the required format.
		this.m_tagDateTime = tagDateTime.getFullYear() + "-" + currentMonth + "-" + currentDate + "T" + currentHours + ":" + currentMinutes + ":" + currentSeconds + "Z";
	} else {
		throw new Error("Called setTagDateTime with non string or Date type for tagDateTime parameter");
	}
	return this;
};

/**
 * Sets the entity id for this TaggedResult.  This id will be based on the type of TaggedResult being used.  For instance if tagging a Clinical Event the 
 * entity id will be an Event Id.
 * @param {number} tagEntityId The entity id associated with the type of result being tagged
 * @return {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setTagEntityId = function(tagEntityId){
	if(typeof tagEntityId == "number"){
		this.m_tagEntityId = tagEntityId;
	}
	return this;
};

/**
 * Sets the text to be used for the TaggedResult.  This field is optional and is only used in certain types of tags
 * @param {string} tagText The text selected for this tagged result
 * @return {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setTagText = function(tagText){
	if(typeof tagText == "string"){
		this.m_tagText = tagText;
	}
	return this;
};

/**
 * The TextControl class. This API allows simple creation of input controls and handles all necessary interactions
 * such as required state, invalid state, etc.
 * @constructor
 */
function TextControl() {
	this.m_currentValue = "";
	this.m_delegateId = "";
	this.m_disabled = false;
	this.m_extensions = null;
	this.m_id = "";
	this.m_label = "";
	this.m_labelPosition = TextControl.label_position.TOP;
	this.m_placeholderText = "";
	this.m_requiredInd = false;
	this.m_strictWhitespace = false;
	this.m_valid = true;
	this.m_validator = null;

	//Element cache
	this.m_$extensionElement = null;
	this.m_$inputElement = null;
	this.m_$inputGroupElement = null;
	this.m_$stageElement = null;
	this.m_$validationElement = null;

	//Dimensions
	this.m_width = null;
	this.m_predefinedWidth = TextControl.width.MEDIUM;
	this.m_labelWidth = null;

	//Callbacks
	this.m_onChangeCallback = null;
	this.m_onValidChangeCallback = null;
}

/**
 * A registry for keeping track of global information related to TextControl objects.
 * @type {{m_controlMapping: {}, m_delegateMapping: {}}}
 */
TextControl.Registry = {
	"m_controlMapping" : {},
	"m_delegateMapping" : {}
};

/**
 * Registers a TextControl object into the control mapping. The control mapping is a mapping of TextControl ids to the
 * instance of the same object.
 * @param {TextControl} control - The TextControl being registered to the system.
 */
TextControl.Registry.registerControl = function(control){
	if(TextControl.Registry.m_controlMapping[control.getId()]) {
		logger.logWarning("TextControl.Registry.registerControl: attempting to register control with non-unique id " + control.getId());
	}
	TextControl.Registry.m_controlMapping[control.getId()] = control;
};

/**
 * Retrieves a TextControl instance from the registry that matches the specified id.
 * @param {String} id - The id of the TextControl being retrieved.
 * @returns {TextControl|null} The TextControl registered with the specified id, or null if no TextControl object
 * was found.
 */
TextControl.Registry.getControlById = function(id) {
	return TextControl.Registry.m_controlMapping[id] || null;
};

/**
 * An enumeration for the label position of a TextControl.
 * @type {{LEFT: number, TOP: number}}
 */
TextControl.label_position = {
	"LEFT" : 0,
	"TOP" : 1
};

/**
 * An enumeration for predefined text control widths.
 * @type {{SMALL: string, MEDIUM: string, LARGE: string, SUPER: string, FILL: string}}
 */
TextControl.width = {
	"SMALL": "te-small",
	"MEDIUM": "te-medium",
	"LARGE" : "te-large",
	"SUPER" : "te-super",
	"FILL" : "te-fill"
};

/**
 * Retrieves the current value of the TextControl. This is the value currently in the input element.
 * @returns {string} The current value of the TextControl.
 */
TextControl.prototype.getCurrentValue = function() {
	return this.m_currentValue;
};

/**
 * Sets the current value that is in the input element.
 * @param {String} value - The value currently in the input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setCurrentValue = function(value) {
	if(typeof value !== "string") {
		throw new Error("TextControl.prototype.setCurrentValue expects a string.");
	}
	//If the element has been rendered, update the value.
	this.getInputElement().val(value);
	this.m_currentValue = value;
	//Update the state since the value has changed
	this.updateState();
	return this;
};

/**
 * Sets the delegate id for the TextControl. The delegate id is the id of the element to which the event
 * delegates will be attached.
 * @param {String} delegateId - The id of the element to which the event delegates will be attached.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setDelegateId = function(delegateId) {
	if(typeof delegateId !== "string") {
		throw new Error("TextControl.prototype.setDelegateId expects a string");
	}
	this.m_delegateId = delegateId;
	return this;
};

/**
 * Retrieves whether the TextControl object is disabled or not.
 * @returns {boolean} Whether the TextControl is disabled or not.
 */
TextControl.prototype.isDisabled = function() {
	return this.m_disabled;
};

/**
 * Sets the disabled state of the TextControl. True is disabled, false is not disabled (or enabled).
 * @param {Boolean} disabled - The disabled state of the TextControl.
 */
TextControl.prototype.setDisabled = function(disabled) {
	if(typeof disabled !== "boolean") {
		throw new Error("TextControl.prototype.setDisabled expects a boolean.");
	}
	this.m_disabled = disabled;
	//If the control has been rendered, go ahead and update the disabled state.
	this.getInputElement().prop("disabled", disabled);
	return this;
};

/**
 * Retrieves the list of TextControlExtension associated with this TextControl. This defaults to an empty array.
 * @returns {Array<TextControlExtension>} The list of TextControlExtension objects.
 */
TextControl.prototype.getExtensions = function() {
	if(!this.m_extensions) {
		this.m_extensions = [];
	}
	return this.m_extensions;
};

/**
 * Adds a TextControlExtension to the TextControl.
 * @param {TextControlExtension} extension - The TextControlExtension to be added.
 */
TextControl.prototype.addExtension = function(extension) {
	if(!TextControlExtension.prototype.isPrototypeOf(extension)) {
		throw new Error("TextControl.prototype.addExtension expects a TextControlExtension object");
	}
	extension.setOwnerControl(this);
	this.getExtensions().push(extension);
	return this;
};

/**
 * Retrieves the unique id for the TextControl.
 * @returns {string} The unique id for the TextControl.
 */
TextControl.prototype.getId = function() {
	return this.m_id;
};

/**
 * Sets the unique id for the TextControl.
 * @param {String} id - The unique id for the TextControl.
 */
TextControl.prototype.setId = function(id) {
	if(typeof id !== "string") {
		throw new Error("TextControl.prototype.setId expects a string.");
	}
	this.m_id = id;
	return this;
};

/**
 * Retrieves the label for the input.
 * @returns {string} The label for the input.
 */
TextControl.prototype.getLabel = function() {
	return this.m_label;
};

/**
 * Sets the label to be displayed with the input.
 * @param {String} label - The label to be displayed with the input.
 */
TextControl.prototype.setLabel = function(label) {
	if(typeof label !== "string") {
		throw new Error("TextControl.prototype.setLabel expects a string.");
	}
	this.m_label = label;
	return this;
};

/**
 * Retrieves the enumeration for the input label position.
 * @returns {number} The enumerated location for the input label position.
 */
TextControl.prototype.getLabelPosition = function() {
	return this.m_labelPosition;
};

/**
 * Sets the label position for the input.
 * @param {Number} labelPosition - The position for the input.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setLabelPosition = function(labelPosition) {
	if(typeof labelPosition !== "number") {
		throw new Error("TextControl.prototype.setLabelPosition expects a number.");
	}
	this.m_labelPosition = labelPosition;
	return this;
};

/**
 * Retrieves the placeholder text for the TextControl.
 * @returns {string} The placeholder text for the input.
 */
TextControl.prototype.getPlaceholderText = function() {
	return this.m_placeholderText;
};

/**
 * Sets the placeholder text for the TextControl. This is the text that appears in the element when no value is
 * present.
 * @param {String} placeholderText - The placeholder text for the TextControl.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setPlaceholderText = function(placeholderText) {
	if(typeof placeholderText !== "string") {
		throw new Error("TextControl.prototype.setPlaceholderText expects a string.");
	}
	this.m_placeholderText = placeholderText;
	this.getInputElement().attr("placeholder", placeholderText);
	return this;
};

/**
 * Retrieves whether the text control is required or not.
 * @returns {boolean} Whether the text control is required or not.
 */
TextControl.prototype.isRequired = function() {
	return this.m_requiredInd;
};

/**
 * Sets whether the text control is required or not.
 * @param {Boolean} required - Whether the text control is required or not.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setRequired = function(required) {
	if(typeof required !== "boolean") {
		throw new Error("TextControl.prototype.setRequired expects a boolean.");
	}
	this.m_requiredInd = required;
	//Update the UI
	var $labelElement = this.getStageElement().children(".te-label");
	var $requiredInd = $labelElement.children(".te-required-ind");
	var $input = this.getInputElement();
	if(required) {
		$labelElement.addClass("te-required-label");
		//Make sure we do not append multiple required indicators
		if(!$requiredInd.length) {
			$labelElement.prepend("<span class='te-required-ind'>*</span>");
		}
		//Ensure the actual input element is updated if it is empty
		if(this.isEmpty()) {
			$input.addClass("te-required");
		}
	} else {
		$labelElement.removeClass("te-required-label");
		$requiredInd.remove();
		$input.removeClass("te-required");
	}
	return this;
};

/**
 * A quick helper function to determine if the control is considered empty.
 * @returns {Boolean} A boolean indicating if the control is empty.
 */
TextControl.prototype.isEmpty = function() {
	var currentValue = this.m_currentValue;
	return this.m_strictWhitespace ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
};

/**
 * Retrieves whether the TextControl is strict about whitespace.
 * @returns {boolean} Whether the TextControl is strict about whitespace.
 */
TextControl.prototype.isStrictWhitespace = function() {
	return this.m_strictWhitespace;
};

/**
 * Sets whether the TextControl is strict about whitespace.
 * @param {Boolean} strictWhitespace - Whether the TextControl is strict about whitespace.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setStrictWhitespace = function(strictWhitespace) {
	if(typeof strictWhitespace !== "boolean") {
		throw new Error("TextControl.prototype.setIsStrictWhitespace expects a boolean.");
	}
	this.m_strictWhitespace = strictWhitespace;
	return this;
};

/**
 * Retrieves whether the TextControl is considered valid or not.
 * @returns {boolean}
 */
TextControl.prototype.isValid = function() {
	return this.m_valid;
};

/**
 * Sets the validator object for the TextControl. This is a validator instance that will be used to validate
 * the value of the input element of the TextControl. If no validator is provided, it is assumed the
 * TextControl is always valid.
 * @param {InputValidator} validator - A validator instance that will perform a validation function on the
 * value of the TextControl input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setValidator = function(validator) {
	if(!InputValidator.prototype.isPrototypeOf(validator)) {
		throw new Error("TextControl.prototype.setValidator expects an InputValidator object.");
	}
	this.m_validator = validator;
	return this;
};

/**
 * Retrieves the extensions wrapper element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The extensions wrapper element.
 */
TextControl.prototype.getExtensionElement = function() {
	if(!this.m_$extensionElement) {
		this.m_$extensionElement = $("#" + this.getId() + "Extensions");
	}
	return this.m_$extensionElement;
};

/**
 * @private
 * Sets the extension wrapper. This is the element that encapsulates all of the TextControl HTML.
 * This function is private and should not be called externally.
 * @param {jQuery} extensionElement - The extension wrapper element in which all extensions are encapsulated.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setExtensionElement = function(extensionElement) {
	if(typeof extensionElement !== "object") {
		throw new Error("TextControl.prototype.setExtensionElement expects a jQuery object.");
	}
	this.m_$extensionElement = extensionElement;
	return this;
};

/**
 * Retrieves the input element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The input element.
 */
TextControl.prototype.getInputElement = function() {
	if(!this.m_$inputElement || !this.m_$inputElement.length) {
		this.m_$inputElement = $("#" + this.getId());
	}
	return this.m_$inputElement;
};

/**
 * @private
 * Sets the input element. This is the actual input control element (<input>)
 * @param {jQuery} inputElement - The input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setInputElement = function(inputElement) {
	if(typeof inputElement !== "object") {
		throw new Error("TextControl.prototype.setInputElement expects a jQuery object.");
	}
	this.m_$inputElement = inputElement;
	return this;
};

/**
 * Retrieves the input group element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The input group element.
 */
TextControl.prototype.getInputGroupElement = function() {
	if(!this.m_$inputGroupElement || !this.m_$inputGroupElement.length) {
		this.m_$inputGroupElement = $("#" + this.m_id + "InputGroup");
	}
	return this.m_$inputGroupElement;
};

/**
 * @private
 * Sets the input group element.
 * @param {jQuery} inputGroupElement - The input group element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setInputGroupElement = function(inputGroupElement) {
	if(typeof inputGroupElement !== "object") {
		throw new Error("TextControl.prototype.setInputGroupElement expects a jQuery object.");
	}
	this.m_$inputGroupElement = inputGroupElement;
	return this;
};

/**
 * Retrieves the stage element. This is the element that encapsulates all of the TextControl HTML. If the element
 * is null, it will be queried from the DOM.
 * @returns {jQuery} The stage wrapper element.
 */
TextControl.prototype.getStageElement = function() {
	if(!this.m_$stageElement || !this.m_$stageElement.length) {
		this.m_$stageElement = $("#" + this.getId() + "Stage");
	}
	return this.m_$stageElement;
};

/**
 * @private
 * Sets the stage element. This is the element that encapsulates all of the TextControl HTML.
 * @param {jQuery} stageElement - The stage (or wrapper) element in which all of the TextControl elements are
 * encapsulated.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setStageElement = function(stageElement) {
	if(typeof stageElement !== "object") {
		throw new Error("TextControl.prototype.setStageElement expects a jQuery object.");
	}
	this.m_$stageElement = stageElement;
	return this;
};

/**
 * Retrieves the validation element.
 * @returns {jQuery} The validation element.
 */
TextControl.prototype.getValidationElement = function() {
	if(!this.m_$validationElement || !this.m_$validationElement.length) {
		this.m_$validationElement = $("#" + this.getId() + "Validation");
	}
	return this.m_$validationElement;
};

/**
 * @proviate
 * Sets the validation element. This is the element that encapsulates the validation message (if any).
 * @param {jQuery} validationElement - The validation element in which the validation message will be shown.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setValidationElement = function(validationElement) {
	if(typeof validationElement !== "object") {
		throw new Error("TextControl.prototype.setValidationElement expects a jQuery object.");
	}
	this.m_$validationElement = validationElement;
	return this;
};

/**
 * Sets the width of the <input> element in pixels.
 * @param {Number} width - The width of the <input> element in pixels.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setWidthInPixels = function(width) {
	if(!CERN_Validate.number.isPositive(width)) {
		throw new Error("TextControl.prototype.setWidthInPixels expects a number > 0");
	}
	this.m_width = width;
	if(this.getInputElement().length) {
		this.getInputElement()[0].style.width = width + "px";
	}
	return this;
};

/**
 * Sets a predefined width class for the <input> element.
 * @param {String} predefinedWidth - The class to apply to the <input> element which has
 * width styling.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setPredefinedWidth = function(predefinedWidth) {
	if(!CERN_Validate.string.isString(predefinedWidth)) {
		throw new Error("TextControl.prototype.setPredefinedWidth expects a string.");
	}
	var previousPredefinedWidth = this.m_predefinedWidth;
	this.m_predefinedWidth = predefinedWidth;
	var $input = this.getInputElement();
	var $inputGroup = this.getInputGroupElement();
	var $stageElement = this.getStageElement();

	//Remove the previous pre-defined width stylings.
	$input.removeClass(previousPredefinedWidth);
	$inputGroup.removeClass(previousPredefinedWidth);
	$stageElement.removeClass(previousPredefinedWidth);
	//Fill must be handled with special care
	if(predefinedWidth === TextControl.width.FILL) {
		$stageElement.addClass(TextControl.width.FILL);
		$stageElement.removeClass("te-label-left");
		$stageElement.addClass("te-label-top");
	}
	//Now update the necessary elements with the new predefined widths.
	$input.addClass(predefinedWidth);
	$inputGroup.addClass(predefinedWidth);
	return this;
};

/**
 * Sets the width of the label in pixels.
 * @param {Number} labelWidth - The width of the label in pixels. This value must be greater than 0.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setLabelWidthInPixels = function(labelWidth) {
	if(!CERN_Validate.number.isPositive(labelWidth)) {
		throw new Error("TextControl.prototype.setLabelWidthInPixels expects a number > 0.");
	}
	this.m_labelWidth = labelWidth;
	return this;
};

/**
 * Sets the callback function that is called when the content of the input element changes.
 * @param {Function} onChangeCallback - The callback function to be called when the content of the input element
 * changes. The callback function must specify a content parameter as such:
 * ex: control.setOnChangeCallback(function(content){ ... });
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setOnChangeCallback = function(onChangeCallback) {
	if(typeof onChangeCallback !== "function") {
		throw new Error("TextControl.prototype.setOnChangeCallback expects a function");
	}
	this.m_onChangeCallback = onChangeCallback;
	return this;
};

/**
 * Sets the callback function that is called when the state of the TextControl changes from valid to invalid or
 * invalid to valid.
 * @param {Function} onValidChangeCallback - The callback function to be called when the state of the TextControl
 * changes from valid to invalid or invalid to valid. The callback function must specify a parameter as such:
 * ex: control.setOnValidChangeCallback(function(isValid){ ... });
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setOnValidChangeCallback = function(onValidChangeCallback) {
	if(typeof onValidChangeCallback !== "function") {
		throw new Error("TextControl.prototype.setOnValidChangeCallback expects a function");
	}
	this.m_onValidChangeCallback = onValidChangeCallback;
	return this;
};

/**
 * @private
 * This attaches a delegate to the element with the specified delegate id. This will ensure that controls rendered
 * via the renderRaw function still have events attached.
 */
TextControl.prototype.attachDelegate = function() {
	if(!this.m_delegateId) {
		throw new Error("TextControl.prototype.attachDelegate requires a delegate id be provided via TextControl.prototype.setDelegateId(...)");
	}
	//If a delegate has already been attached to the element with the specified delegate id.
	if(TextControl.Registry.m_delegateMapping[this.m_delegateId]) {
		logger.logMessage("TextControl.prototype.attachDelegate: " + this.m_delegateId + " already has events bound.");
		return;
	}
	//Attach the keyup delegate.
	$("#" + this.m_delegateId).on("keyup", ".te-textbox, .te-textarea", function(event){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		control.onUpdate(this.value);
	});
	//Attach the blur delegate.
	$("#" + this.m_delegateId).on("blur", ".te-textbox, .te-textarea", function(){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		control.onBlur();
	});
	//Attach the paste delegate.
	$("#" + this.m_delegateId).on("paste", ".te-textbox, .te-textarea", function(){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		var pasteSource = this;
		setTimeout(function(){
			control.onUpdate(pasteSource.value);
		}, 100);
	});
	//The element with the delegate id now has the delegate attached. Remember this to prevent attaching multiple
	//delegate to the same element.
	TextControl.Registry.m_delegateMapping[this.m_delegateId] = true;
};

/**
 * @private
 * Renders the set of extensions associated to the TextControl. Does nothing if there are no extensions.
 */
TextControl.prototype.renderExtensions = function() {
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	for(var i = 0; i < extensionCount; i++) {
		extensions[i].render();
	}
};

/**
 * Handles updating the UI state of the TextControl.
 */
TextControl.prototype.updateState = function() {
	var currentValue = this.getCurrentValue();
	var isValid = this.checkValid();
	this.m_valid = isValid;
	//If the control is strict about whitespace, it will consider nothing but whitespace as empty.
	var isEmpty = this.isStrictWhitespace() ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
	//Handle validity
	if(isValid) {
		this.getInputElement().removeClass("te-invalid");
		this.getValidationElement().hide();
	}
	//Handle required status
	if(this.isRequired() && isEmpty) {
		this.getInputElement().addClass("te-required");
	} else if(this.isRequired() && !isEmpty) {
		this.getInputElement().removeClass("te-required");
	}
};

/**
 * Validates the TextControl. If there is a validator, use that for validation, otherwise assume
 * the TextControl is valid.
 * @returns {Boolean} whether the TextControl is in a valid state or not.
 */
TextControl.prototype.checkValid = function() {
	if(this.m_validator) {
		return this.m_validator.validate(this.getCurrentValue());
	} else {
		return true;
	}
};

/**
 * Handles the input update. This function is called on the keyup event of the text entry field.
 * @param {String} currentValue - The current value in the TextControl UI (input)
 */
TextControl.prototype.onUpdate = function(currentValue) {
	var wasValid = this.m_valid;
	this.setCurrentValue(currentValue);
	this.updateState();
	this.updateExtensions();
	//Notify that the content has changed.
	if(this.m_onChangeCallback) {
		this.m_onChangeCallback(currentValue);
	}
	//Notify of a valid state change.
	if(wasValid !== this.m_valid && this.m_onValidChangeCallback) {
		this.m_onValidChangeCallback(this.m_valid);
	}
	//Call a post update function in case controls need to do some extra logic after updating.
	this.postUpdate();
};

/**
 * Handles the blur event for the text control. Currently this will show the validation element (if there is one).
 */
TextControl.prototype.onBlur = function() {
	if (!this.m_valid) {
		this.getValidationElement().show();
		this.getInputElement().addClass("te-invalid");
	}
};

/**
 * A base function that is always called at the end of the onUpdate function. The base TextControl
 * object does not implement this function, but some sub-classes of TextControl may need to perform
 * additional operations after update.
 */
TextControl.prototype.postUpdate = function() {
};

/**
 * Runs through the list of extensions associated with the TextControl and calls the onUpdate function,
 * passing this instance of the TextControl so the extension can handle the update appropriately.
 */
TextControl.prototype.updateExtensions = function() {
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	for(var i = 0; i < extensionCount; i++) {
		extensions[i].onUpdate();
	}
};

/**
 * @private
 * Performs necessary validation prior to rendering the text control.
 * @param {Boolean} renderRaw - If rendering as raw HTML.
 */
TextControl.prototype.preRenderValidate = function(renderRaw) {
	//An id is required for a unique DOM existence.
	if(!this.m_id) {
		throw new Error("TextControl requires a unique id to render");
	}
	//If rendering raw, you must provide a delegate id.
	if(renderRaw && !this.m_delegateId) {
		throw new Error("TextControl requires a delegate id when calling TextControl.prototype.renderRaw");
	}
};

/**
 * @private
 * This function renders the entire control as an HTML string. This function should only be called from
 * TextControl.prototype.render and TextControl.prototype.renderRaw.
 * @returns {string} The entire text control rendered as an HTML string.
 */
TextControl.prototype.renderHtml = function() {
	//Start the control off with the correct valid state.
	this.m_valid = this.checkValid();
	//Start rendering
	var label = this.m_label;
	var labelPosition = this.m_labelPosition;
	var labelClasses = ["te-label"];
	var stageClasses = ["te-stage"];
	var inputGroupClasses = ["te-input-group", this.m_predefinedWidth];
	var labelHtml = "";
	var labelInnerHtml = "";
	var labelText = label;
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	var controlId = this.m_id;

	//If the control uses the fill style, some special care must be taken for other elements as well.
	if(this.m_predefinedWidth === TextControl.width.FILL) {
		//If fill is specified, the label position is forced above.
		labelPosition = TextControl.label_position.TOP;
		stageClasses.push("te-fill");
	}

	if(label) {
		var labelStyle = "";
		if(this.m_labelWidth) {
			labelStyle = "style='width:" + this.m_labelWidth + "px;'";
		}
		if(labelPosition === TextControl.label_position.LEFT) {
			stageClasses.push("te-label-left");
			labelText += ":&nbsp;";
		} else {
			stageClasses.push("te-label-top");
		}
		if(this.m_requiredInd) {
			labelClasses.push("te-required-label");
			labelInnerHtml += "<span class='te-required-ind'>*</span>";
		}
		labelHtml = "<div class='"+labelClasses.join(" ")+"' "+labelStyle+">";
		labelInnerHtml += "<span class='te-label-text'>"+labelText+"</span>";
		labelHtml += labelInnerHtml;
		labelHtml += "</div>";
	}
	var html = "<div id='"+controlId+"Stage' class='" + stageClasses.join(" ") + "'>";
	html += labelHtml;
	html += "<div id='"+controlId+"InputGroup' class='" + inputGroupClasses.join(" ") + "'>";
	html += this.renderInputElementRaw();
	//Render any extensions as raw html as well.
	if (extensionCount) {
		html += "<div id='" + controlId + "Extensions' class='te-extensions'>";
		//Render any extensions
		for (var i = 0; i < extensionCount; i++) {
			html += extensions[i].renderRaw();
		}
		html += "</div>";
	}
	//Validation
	if (this.m_validator) {
		html += "<div id='" + controlId + "Validation' class='te-validation' style='display: none;'>";
		html += this.m_validator.getValidationMessage() || "";
		html += "</div>";
	}
	html += "</div></div>";
	return html;
};

/**
 * Renders as a jQuery element and attaches all necessary events.
 * @returns {*|jQuery|HTMLElement}
 */
TextControl.prototype.render = function() {
	//Validate prior to rendering. This is not rendering raw, so pass false indicating as such.
	this.preRenderValidate(false);
	var self = this;
	//Resuse the renderHtml function to generate the entire control markup.
	var $element = $(this.renderHtml());
	var controlId = this.getId();

	//Cache the most commonly used elements
	this.setInputElement($element.find("#" + controlId));
	this.setInputGroupElement($element.find("#" + controlId + "InputGroup"));
	this.setStageElement($element.find("#" + controlId + "Stage"));
	this.setExtensionElement($element.find("#" + controlId + "Extensions"));
	this.setValidationElement($element.find("#" + controlId + "Validation"));

	//Attach all necessary events to the input element.
	this.getInputElement().on("keyup", function(event){
		self.onUpdate(this.value);
	}).on("blur", function(){
		self.onBlur();
	}).on("paste", function(){
		var pasteSource = this;
		setTimeout(function(){
			self.onUpdate(pasteSource.value);
		}, 100);
	});
	return $element;
};

/**
 * Renders the TextControl as a raw HTML string. This will produce flat HTML. Thus, a delegate must
 * be applied to a parent element to this TextControl element.
 * @returns {string} The TextControl object rendered as flat HTML.
 */
TextControl.prototype.renderRaw = function() {
	//Perform rendering validation, passing true to indicate raw HTML
	this.preRenderValidate(true);
	//Register the control to the system so it can be found later
	TextControl.Registry.registerControl(this);
	//Attach the delegates
	this.attachDelegate();
	//Make the call to render tha plain HTML
	return this.renderHtml();
};

/**
 * @private
 * Renders the actual input element as a raw HTML string. This is the <input> tag of the entire
 * TextControl.
 * @returns {string} The <input> tag for the TextControl, rendered as an HTML string.
 */
TextControl.prototype.renderInputElementRaw = function() {
	var currentValue = this.m_currentValue;
	var isValid = this.m_valid;
	var isEmpty = this.isEmpty();
	var disabled = this.m_disabled ? " disabled" : "";
	var placeholder = this.m_placeholderText ? " placeholder='" + this.m_placeholderText + "'" : "";
	var inputClasses = ["te-textbox"];
	var defaultValue = currentValue ? (" value='" + currentValue + "'") : "";
	var style = "style='";
	style += this.m_width ? ("width:" + this.m_width + "px;") : "";
	style += "'";
	if(!isValid) {
		inputClasses.push("te-invalid");
	}
	if(this.m_requiredInd && isEmpty) {
		inputClasses.push("te-required");
	}
	inputClasses.push(this.m_predefinedWidth);
	return "<input id='" + this.m_id + "' class='" + inputClasses.join(" ") + "' type='text'" + defaultValue + placeholder + style + disabled + ">";
};

/**
 * The TextAreaControl class.
 * This overrides the base TextControl class, extending it to provide text area support.
 * @constructor
 */
function TextAreaControl() {
	this.m_height = null;
	this.m_isResizeable = false;
	this.m_rows = 1;
}

TextAreaControl.prototype = new TextControl();
TextAreaControl.prototype.constructor = TextControl;

/**
 * Sets the height of the <textarea> element in pixels. This value can be null if the
 * developer has not explicitly provided a height. In such a case, the <textarea> element will
 * be styled natively via the "rows" attribute which defaults to 1.
 * @param {Number} height - The height of the <textarea> element in pixels.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextAreaControl.prototype.setHeightInPixels = function(height) {
	if(!CERN_Validate.number.isPositive(height)) {
		throw new Error("TextAreaControl.prototype.setHeightInPixels expects a number > 0.");
	}
	this.m_height = height;
	//If the text area has already been rendered, go ahead and update the element.
	if(this.getInputElement().length) {
		this.getInputElement()[0].style.height = height + "px";
	}
	return this;
};

/**
 * Sets whether the <textarea> element is allowed to be resized.
 * @param {Boolean} isResizeable - True if the <textarea> element is resizeable, otherwise false.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextAreaControl.prototype.setIsResizeable = function(isResizeable) {
	if(typeof isResizeable !== "boolean") {
		throw new Error("TextAreaControl.prototype.setIsResizeable expects a boolean.");
	}
	this.m_isResizeable = isResizeable;
	var $inputElement = this.getInputElement();
	//If the text area has already been rendered, go ahead and update the element.
	if(isResizeable) {
		$inputElement.removeClass("te-no-resize");
	} else {
		$inputElement.addClass("te-no-resize");
	}
	return this;
};

/**
 * Sets the number of rows for the text area. This refers to the native "rows" attribute
 * on the <textarea> element. For example: <textarea rows="1"></textarea>
 * @param {Number} rows - The number of native rows for the <textarea> element.
 * @returns {TextAreaControl} returns self to allows chaining.
 */
TextAreaControl.prototype.setHeightInRows = function(rows) {
	if(!CERN_Validate.number.isGreaterThanOrEqualTo(1)) {
		throw new Error("TextAreaControl.prototype.setHeightInRows expects an integer >= 1");
	}
	this.m_rows = rows;
	//If the text area has already been rendered, go ahead and update the element.
	this.getInputElement().attr("rows", rows);
	return this;
};

/**
 * @private
 * Overrides the base renderInputElementRaw function. The TextAreaControl uses a <textarea> element rather than an
 * <input> element.
 * @returns {String} The <textarea> element for the TextAreaControl rendered as an HTML string.
 */
TextAreaControl.prototype.renderInputElementRaw = function() {
	var currentValue = this.m_currentValue;
	var isValid = this.m_valid;
	var isEmpty = this.m_strictWhitespace ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
	var disabled = this.m_disabled ? " disabled" : "";
	var rows = this.m_rows;
	var placeholder = this.m_placeholderText ? " placeholder='" + this.m_placeholderText + "'" : "";
	var inputClasses = ["te-textarea"];
	inputClasses.push(this.m_predefinedWidth);
	var style = "style='";
	style += this.m_width ? ("width:" + this.m_width + "px;") : "";
	style += this.m_height ? ("height:" + this.m_height + "px;") : "";
	style += "'";
	if(!isValid) {
		inputClasses.push("te-invalid");
	}
	if(this.m_requiredInd && isEmpty) {
		inputClasses.push("te-required");
	}
	if(!this.m_isResizeable) {
		inputClasses.push("te-no-resize");
	}
	return "<textarea id='" + this.m_id + "' class='" + inputClasses.join(" ") + "' rows='" + rows + "' type='text'" + placeholder + style + disabled + ">" + currentValue + "</textarea>";
};
/**
 * The AutosizeTextAreaControl class.
 * This class extends the TextAreaControl and allows the text area to automatically
 * grow based on a min and max height.
 * @constructor
 */
function AutosizeTextAreaControl() {
	this.m_maxHeight = Number.MAX_VALUE;
	this.m_minHeight = 24;
	return this;
}

AutosizeTextAreaControl.prototype = new TextAreaControl();
AutosizeTextAreaControl.prototype.constructor = TextAreaControl;

/**
 * Sets the minimum height of the text area control.
 * @param {Number} minHeight - The minimum height of the text area element. This number must
 * be positive.
 * @returns {AutosizeTextAreaControl} Returns self to allow chaining.
 */
AutosizeTextAreaControl.prototype.setMinHeightInPixels = function(minHeight) {
	if(!CERN_Validate.number.isPositive(minHeight)) {
		throw new Error("AutosizeTextAreaControl.prototype.setMinHeightInPixels expects a number > 0.");
	}
	if(minHeight > this.m_maxHeight) {
		throw new Error("AutosizeTextAreaControl.prototype.setMinHeightInPixels: the min value must be less than or equal to the max value.");
	}
	this.m_minHeight = minHeight;
	return this;
};

/**
 * Sets the maximum height of the text area control.
 * @param {Number} maxHeight - The maximum height of the text area element. This number
 * must be positive.
 * @returns {AutosizeTextAreaControl} Returns self to allow chaining.
 */
AutosizeTextAreaControl.prototype.setMaxHeightInPixels = function(maxHeight) {
	if(!CERN_Validate.number.isPositive(maxHeight)) {
		throw new Error("TextAreaControl.prototype.setMaxHeight: expecting a value greater than 0");
	}
	if(maxHeight < this.m_minHeight) {
		throw new Error("TextAreaControl.prototype.setMaxHeight: the max value must be greater than or equal to the min value");
	}
	this.m_maxHeight = maxHeight;
	return this;
};

/**
 * Overrides the base postUpdate function. This simply calls the handleAutoGrow to ensure that when the control has
 * finished updating, the size of the control will be updated correctly.
 */
AutosizeTextAreaControl.prototype.postUpdate = function() {
	this.handleAutoGrow();
};

/**
 * An exposed resize function for developers to forcefully resize the control. Right now this simply calls
 * handleAutoGrow. This is useful if the developer has chosen to render the control as raw html and wants to ensure
 * the height is adjusted correctly post-render.
 */
AutosizeTextAreaControl.prototype.resize = function() {
	this.handleAutoGrow();
};

/**
 * This handles the height adjustment of the control. This works by forcing the height of the text area to equal
 * the scroll-height of the area. This occurs up to a maximum height at which point the overflow of the text area is
 * shown and we force the height to the max height. We must also account for Internet Explorer changing the width of the
 * text area when overflow is shown/hidden.
 */
AutosizeTextAreaControl.prototype.handleAutoGrow = function() {
	var $input = this.getInputElement();
	//This can occur if the element does not truly exist on the DOM.
	if(!$input.length) {
		return;
	}
	var rawInput = $input[0];
	var previousWidth = rawInput.offsetWidth;
	var currentWidth = null;
	var scrollHeight;
	rawInput.style.height = 'auto';
	scrollHeight = rawInput.scrollHeight;
	//Adjust the size of the text area.
	if(scrollHeight <= this.m_maxHeight) {
		rawInput.style.height = Math.max(this.m_minHeight,scrollHeight) + "px";
	} else {
		rawInput.style.height = this.m_maxHeight + "px";
	}
	//Determine if the scrollbar needs to be visible or not.
	if(scrollHeight > this.m_maxHeight) {
		$input.css({"overflow-y" : "auto"});
	} else {
		$input.css({"overflow-y" : "hidden"});
	}
	currentWidth = rawInput.offsetWidth;
	//In some browsers (IE), altering the overflow can alter the width.
	if(previousWidth !== currentWidth) {
		rawInput.style.width = previousWidth + "px";
	}
};
/**
 * The base TextControlExtension interface.
 * This class represents the interface for creating extensions for a TextControl object.
 * @constructor
 */
function TextControlExtension() {
	this.m_ownerControl = null;
}

/**
 * The base onUpdate function. This function should be implemented by subclasses. This function
 * is called when the TextControl updates (on user input).
 */
TextControlExtension.prototype.onUpdate = function () {
};

/**
 * This function renders the extension as raw HTML. This function should be implemented by subclasses.
 * @returns {String} The markup rendered as an HTML string.
 */
TextControlExtension.prototype.renderRaw = function() {
	return "";
};

/**
 * Sets the TextControl that owns this extension. This is called when you use the TextControl.prototype.addExtension
 * function.
 * @param {TextControl} control - The owner of this extension.
 * @returns {TextControlExtension} Returns self to allow chaining.
 */
TextControlExtension.prototype.setOwnerControl = function(control) {
	if(!TextControl.prototype.isPrototypeOf(control)) {
		throw new Error("TextControlExtension.prototype.setOwnerControl expects an object of type TextControl.");
	}
	this.m_ownerControl = control;
	return this;
};

/**
 * The CharacterLimitExtension class.
 * This class extends the TextControlExtension interface. This extension provides the ability to display a character
 * limit beneath the input. You can specify the character limit and whether the extension will automatically truncate
 * the text.
 * @returns {CharacterLimitExtension} Returns self to allow chaining.
 * @constructor
 */
function CharacterLimitExtension() {
	this.m_autoTruncate = false;
	this.m_characterLimit = Number.MAX_VALUE;
	this.m_$charRemaining = null;
	return this;
}

CharacterLimitExtension.prototype = new TextControlExtension();
CharacterLimitExtension.prototype.constructor = TextControlExtension;

/**
 * Sets whether the extension will automatically truncate the text in the input when the character limit is reached.
 * @param {Boolean} autoTruncate - A boolean indicating whether the extension will automatically truncate the text.
 * @returns {CharacterLimitExtension} Returns self to allow chaining.
 */
CharacterLimitExtension.prototype.setAutoTruncate = function (autoTruncate) {
	if(typeof autoTruncate !== "boolean") {
		throw new Error("CharacterLimitExtension.prototype.setAutoTruncate expects a boolean.");
	}
	this.m_autoTruncate = autoTruncate;
	return this;
};

/**
 * Sets the character limit of the extension. This is the number of characters within the input element.
 * @param {Number} characterLimit - The character limit of the extension. This must be a number greater than 0.
 * @returns {CharacterLimitExtension} Returns self.
 */
CharacterLimitExtension.prototype.setCharacterLimit = function (characterLimit) {
	if(!CERN_Validate.number.isPositive(characterLimit)) {
		throw new Error("CharacterLimitExtension.prototype.setCharacterLimit expects a number > 0.");
	}
	if(!CERN_Validate.number.isInteger(characterLimit)) {
		throw new Error("CharacterLimitExtension.prototype.setCharacterLimit only accepts integers.");
	}
	this.m_characterLimit = characterLimit;
	return this;
};

/**
 * Retrieves the character limit jQuery element.
 * @returns {jQuery} The jQuery character remaining element.
 */
CharacterLimitExtension.prototype.getCharRemainingElement = function() {
	if(!this.m_$charRemaining || !this.m_$charRemaining.length) {
		this.m_$charRemaining = $("#" + this.m_ownerControl.getId() + "CharRemaining");
	}
	return this.m_$charRemaining;
};

/**
 * Overrides the onUpdate function. This will obtain the current value from the owner
 * control and check to see if the input value exceeds the character limit. If the limit is exceeded, the visual will
 * update to indicate as such. Otherwise, the remaining character count is updated.
 */
CharacterLimitExtension.prototype.onUpdate = function () {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var $charRemaining = this.getCharRemainingElement();
	//If the character limit has been reached.
	if(remainingCharacters < 0) {
		$charRemaining.addClass("te-char-limit-reached");
		//If we are over the limit and auto-truncate is enabled, process the input
		if (this.m_autoTruncate) {
			control.setCurrentValue(currentValue.substring(0, this.m_characterLimit));
			control.updateState();
		}
	} else {
		$charRemaining.removeClass("te-char-limit-reached");
	}
	//Update the character count message.
	$charRemaining.html(this.getCharRemainingMessage());
};

/**
 * Retrieves a string indicating how many characters remaining or how many characters over.
 * @returns {string} A string indicating how many characters remaining or how many characters over.
 */
CharacterLimitExtension.prototype.getCharRemainingMessage = function() {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var message = Math.max(0, remainingCharacters) + "&nbsp;characters left";
	//If auto-truncating, you can never dip below 0.
	if(this.m_autoTruncate) {
		remainingCharacters = 0;
	}
	//If below 0, change the message to indicate how many you are over.
	if(remainingCharacters < 0) {
		message = Math.abs(remainingCharacters) + "&nbsp;over";
	}
	return message;
};

/**
 * Renders the extension as raw HTML.
 * @returns {string} The extension rendered as raw html.
 */
CharacterLimitExtension.prototype.renderRaw = function() {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var extensionClasses = ["te-char-remaining"];
	if(remainingCharacters < 0) {
		extensionClasses.push("te-char-limit-reached");
	}
	var charLimitHtml = "<div class='te-char-limit'>";
	charLimitHtml += "<span id='"+control.getId()+"CharRemaining' class='"+extensionClasses.join(" ")+"'>" + this.getCharRemainingMessage() + "</span>";
	charLimitHtml += "</div>";
	return charLimitHtml;
};
/**
 * The InputValidator interface.
 * This interface defines the behavior of an input validator. The interface
 * is expected to be inherited to provide real implementation.
 * @constructor
 */
function InputValidator(){
}

/**
 * The base validate function. It returns true. This function should be overridden by
 * sub-classes of the InputValidator.
 * @param {String} value - The input value.
 * @returns {boolean} A boolean indicating if the value is valid or not.
 */
InputValidator.prototype.validate = function(value) {
	return true;
};

/**
 * The base getValidationMessage function. It returns an empty string. This function should be overridden by a subclass
 * of the InputValidator interface.
 * @returns {string} A message indicating the requirements for the validator to equate to true.
 */
InputValidator.prototype.getValidationMessage = function() {
	return "";
};

/**
 * The NumericValidator class.
 * This subclass of InputValidator requires the input be a number.
 * @returns {NumericValidator} Returns self to allow chaining.
 * @constructor
 */
function NumericValidator(){
	return this;
}

NumericValidator.prototype = new InputValidator();
NumericValidator.prototype.constructor = InputValidator;

/**
 * Overrides the base getValidationMessage function. It returns a message indicating that input must be of numeric
 * format in order for the validator to equate to true.
 * @returns {string} The validation message.
 */
NumericValidator.prototype.getValidationMessage = function() {
	return "A number is required";
};

/**
 * Overrides the base validate function. It uses the CERN_Validate utility to ensure that the input value is of numeric
 * format.
 * @param {String} value - The input value to be validated.
 * @returns {boolean} A boolean indicating if the provided input value is valid or not.
 */
NumericValidator.prototype.validate = function(value) {
	return CERN_Validate.string.isNumeric(value);
};

/**
 * The NumericRangeValidator class.
 * This subclass of NumericValidator (and subsequently InputValidator) requires the input be a number between a
 * specified range.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 * @constructor
 */
function NumericRangeValidator(){
	this.m_inclusive = false;
	this.m_minValue = -Number.MAX_VALUE;
	this.m_maxValue = Number.MAX_VALUE;
	return this;
}
NumericRangeValidator.prototype = new NumericValidator();
NumericRangeValidator.prototype.constructor = NumericValidator;

/**
 * Overrides the base getValidationMessage function. It returns a message indicating that the input must be of numeric
 * format and within a specified range in order for the validator to equate to true.
 * @returns {string}
 */
NumericRangeValidator.prototype.getValidationMessage = function() {
	return "A number between " + this.m_minValue + " and " + this.m_maxValue + " is required";
};

/**
 * Sets whether the numeric range provided is inclusive or not (exclusive).
 * @param {Boolean} inclusive - A boolean indicating if the numeric range is inclusive or not.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setIsInclusive = function(inclusive) {
	if(typeof inclusive !== "boolean") {
		throw new Error("NumericRangeValidator.prototype.setIsInclusive expects a boolean.");
	}
	this.m_inclusive = inclusive;
	return this;
};

/**
 * Sets the minimum value of the accepted range of inputs.
 * @param {Number} minValue - The minimum value of the accepted range of inputs.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setMinValue = function(minValue) {
	if(!CERN_Validate.number.isNumber(minValue)) {
		throw new Error("NumericRangeValidator.prototype.setMinValue expects a number.");
	}
	if(minValue > this.m_maxValue) {
		throw new Error("NumericRangeValidator.prototype.setMinValue - min value cannot be greater than max value.");
	}
	this.m_minValue = minValue;
	return this;
};

/**
 * Sets the maximum value of the accepted range of inputs.
 * @param {Number} maxValue - The maximum value of the accepted range of inputs.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setMaxValue = function(maxValue) {
	if(!CERN_Validate.number.isNumber(maxValue)) {
		throw new Error("NumericRangeValidator.prototype.setMaxValue expects a number.");
	}
	if(maxValue < this.m_minValue) {
		throw new Error("NumericRangeValidator.prototype.setMaxValue - max value cannot be less than the min value.");
	}
	this.m_maxValue = maxValue;
	return this;
};

/**
 * Overrides the base validate function. The first uses the validate function from the inherited NumericValidator
 * class to ensure the value is even of numeric format. If so, the value is parsed and checked once more to ensure
 * the parsed value is indeed a number. If this is true, check if the value is within the specified range using the
 * inclusive flag.
 * @param {String} value - The input value to be validated.
 * @returns {boolean} A boolean indicating if the provided input value is valid.
 */
NumericRangeValidator.prototype.validate = function(value) {
	//Only bother validating this control if it passes the NumericValidator.
	if(NumericValidator.prototype.validate.call(this, value)) {
		var numericValue = parseFloat(value);
		//If for some reason the parsed value is not a number
		if(!CERN_Validate.number.isNumber(numericValue)) {
			return false;
		}
		return CERN_Validate.number.isWithinRange(numericValue, this.m_minValue, this.m_maxValue, this.m_inclusive);
	} else {
		return false;
	}
};

/*globals CapabilityTimer, CERN_BrowserDevInd, CERN_driver_mean, CERN_Platform, MP_Util, MPageUI, ViewpointViewSelection*/

/**
 * The ViewContainer object is used to store all of the identifying and settings information for each view to be shown within a viewpoint.
 * The viewpoint will use there objects to keep track of the different views contained within itself.  Each ViewContainer will be responsible for
 * the view within, thus the Viewpoint object will interact and manage the ViewContainer objects and the ViewContainer objects will be responsible
 * for creating, managing and interacting with the contained view.
 * @constructor
 * @param {string} viewCategoryMean The category mean for the view associated with this view container.
 */
var ViewContainer = function(viewCategoryMean) {
	//The id given to this ViewContainer object and the view contained within this object
	this.m_viewId = viewCategoryMean;
	//The sequence of this view within the viewpoint tabs
	this.m_sequence = null;
	//The category mean associated with the view object contained within this object
	this.m_categoryMean = "";
	//The category id associated with the view object contained within this object
	this.m_categoryId = 0.0;
	//An indicator which determines if the contained view object is one that the user has selected from the viewpoint drop down
	this.m_userDefinedInd = false;
	//An indicator which determines if the contained view is to be shown as a face up tab or not
	this.m_shownInd = false;
	//An indicator which determines if the view contained within this object is a selectable item in the viewpoint drop down
	this.m_menuItemInd = false;
	//The name associated to the view within this object
	this.m_viewName = "";
	//The name associated to the view within this object with ascii replacements for special characters
	this.m_asciiViewName = "";
	//The name associated to the view within this object with literal special characters
	this.m_literalViewName = "";
	//The view object associated with the tab in the viewpoint
	this.m_viewObj = null;
	//The layout type of view contained within this object: 0 - Summary view , 1 - workflow view, 3 - QOC view, 4 - Worklist view, 5 - Dashboard view.
	this.m_layoutType = 0;
	//The type of view contained within this object: "SUM_*" - Summary view, "WF_*" - Workflow view, "QOC_*" - QOC
	this.m_viewType = "SUM_STD";
	//The date object which was created the last time the view was refreshed
	this.m_lastRefreshDate = null;
	//This flag determines if the view needs to automatically resize when it is selected again
	this.m_resizeOnActivation = false;
	//This flag determines if the view has been previously activated or not.
	this.m_previouslyActivatedInd = false;
	//This flag determines if a view is displayable or not.  Default value is null so we can set the flag once and only once
	this.m_isDisplayable = null;
	//This flag to decide the view is dynamic view or not.
	this.m_dynamicViewInd = false;
};

/**
 * Checks to see if this ViewContainer object has been previously activated (contains HTML is the DOM container)
 * @return {boolean} A boolean indicating if the ViewContainer has been previously activated.
 */
ViewContainer.prototype.previouslyActivated = function() {
	return this.m_previouslyActivatedInd;
};
/**
 * Checks to see if the view associated with the ViewContainer should be resize upon activation.
 * @return {boolean} A boolean indicating if the view should be resized or not
 */
ViewContainer.prototype.resizeOnActivation = function() {
	return this.m_resizeOnActivation;
};

/**
 * This function is used to determine if the view is displayable based on the context of where the MPage is being loaded.
 * For instance summary views are not displayable in the web.
 * @return {boolean} Returns true if the contained view is displayable, false otherwise.
 **/
ViewContainer.prototype.isDisplayable = function() {
	//See if we have already determined if the view is displayable or not
	if(this.m_isDisplayable === null){
		//Only Workflow views, Organizer Worklists and Quality Dashboards are displayable in Browser
		if (!/(^PO_.*|^PRO_.*|^DASH_.*|^WF_.*)/.test(this.m_viewType) && !CERN_Platform.inMillenniumContext() && !CERN_BrowserDevInd) {
			this.m_isDisplayable = false;
		}
		else{
			this.m_isDisplayable = true;
		}
	}

	return this.m_isDisplayable;
};

/**
 * Get the Bedrock Wizard category id of the view contained within the ViewContainer object
 * @return {string} The Bedrock Wizard category id of the view contained within the ViewContainer object
 */
ViewContainer.prototype.getCategoryId = function() {
	return this.m_categoryId;
};
/**
 * Get the Bedrock Wizard category mean of the view contained within the ViewContainer object
 * @return {string} The Bedrock Wizard category mean of the view contained within the ViewContainer object
 */
ViewContainer.prototype.getCategoryMean = function() {
	return this.m_categoryMean;
};
/**
 * Get the id associated to the ViewContainer object and also the View contained within
 * @return {string} The id associated to the ViewContainer object and also the View contained within
 */
ViewContainer.prototype.getId = function() {
	return this.m_viewId;
};
/**
 * Get the date object that was created the last time the View contained within the ViewContainer object was refreshed
 * @return {date} The date object that was created the last time the View contained within the ViewContainer object was refreshed
 */
ViewContainer.prototype.getLastRefreshDate = function() {
	return this.m_lastRefreshDate;
};
/**
 * Get the menu item indicator of the view object contained within this ViewContainer object
 * @return {boolean} The menu item indicator of the view object contained within this ViewContainer object
 */
ViewContainer.prototype.getMenuItemInd = function() {
	return this.m_menuItemInd;
};
/**
 * Get the dynamic view indicator of the view object contained within this ViewContainer object
 * @return {boolean} The dynamic view indicator of the view object contained within this ViewContainer object
 */
ViewContainer.prototype.getDynamicViewInd = function() {
	return this.m_dynamicViewInd;
};
/**
 * Get the sequence of the view object contained within this ViewContainer object
 * @return {number} The sequence of the view object contained within this ViewContainer object
 */
ViewContainer.prototype.getSequence = function() {
	return this.m_sequence;
};
/**
 * Get the shown indicator of the view object contained within this ViewContainer object
 * @return {boolean} The shown indicator of the view object contained within this ViewContainer object
 */
ViewContainer.prototype.getShownInd = function() {
	return this.m_shownInd;
};
/**
 * Get the user defined indicator of the view object contained within this ViewContainer object
 * @return {boolean} The user defined indicator of the view object contained within this ViewContainer object
 */
ViewContainer.prototype.getUserDefinedInd = function() {
	return this.m_userDefinedInd;
};
/**
 * Get the name of the view object contained within this ViewContainer object
 * @return {string} The name of the view contained within this object
 */
ViewContainer.prototype.getViewName = function() {
	return this.m_viewName;
};
/**
 * Get the name of the view object contained within this ViewContainer object with all special characters escaped with ASCII equivalents
 * @return {string} The name of the view contained within this object
 */
ViewContainer.prototype.getAsciiViewName = function() {
	return this.m_asciiViewName;
};
/**
 * Get the name of the view object contained within this ViewContainer object with all ASCII characters converted to literal characters
 * @return {string} The name of the view contained within this object
 */
ViewContainer.prototype.getLiteralViewName = function() {
	return this.m_literalViewName;
};
/**
 * Get the view object contained within this ViewContainer object
 * @return {Object} The view object contained within this object
 */
ViewContainer.prototype.getViewObject = function() {
	return this.m_viewObj;
};
/**
 * Get the view type associated with the object contained within this ViewContainer object
 * @return {string} The type of the view contained within this object
 */
ViewContainer.prototype.getViewType = function() {
	return this.m_viewType;
};

/**
 * Get the layout type of view associated with the object contained within this ViewContainer object
 * @return {number} The layout type of the view contained within this object
 */
ViewContainer.prototype.getLayoutType = function() {
	return this.m_layoutType;
};

/** Setters **/

/**
 * Sets the id associated with this ViewContainer object and the view object contained within
 * @param {string} viewId The id associated with this ViewContainer object and the view object contained within
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setId = function(viewId) {
	if (viewId && typeof viewId === "string") {
		this.m_viewId = viewId;
	}
	return this;
};
/**
 * Sets the sequence used to sort the Views within the viewpoint
 * @param {number} sequence The sequence used to sort the Views within the viewpoint
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setSequence = function(sequence) {
	if (sequence !== null && typeof sequence === "number") {
		this.m_sequence = sequence;
	}
	return this;
};
/**
 * Sets the Bedrock Wizard category id associated with the contained view object
 * @param {number} categoryId The Bedrock wizard category id associated with the contained view object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setCategoryId = function(categoryId) {
	if (categoryId && typeof categoryId === "number") {
		this.m_categoryId = categoryId;
	}
	return this;
};
/**
 * Sets the Bedrock Wizard category mean associated with the contained view object
 * @param {string} categoryMean The Bedrock wizard category mean associated with the contained view object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setCategoryMean = function(categoryMean) {
	if (categoryMean && typeof categoryMean === "string") {
		this.m_categoryMean = categoryMean;
	}
	return this;
};
/**
 * Sets the indicator which determines if this view is one selected from the viewpoint drop down menu
 * @param {boolean} userDefinedInd The indicator which determines if this view is one selected from the viewpoint drop down menu
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setUserDefinedInd = function(userDefinedInd) {
	if (typeof userDefinedInd === "boolean") {
		this.m_userDefinedInd = userDefinedInd;
	}
	return this;
};
/**
 * Sets the shown indicator which determines if the view contained within this object should be shown as a selectable tab within the viewpoint
 * @param {boolean} shownInd The shown indicator which determines if the view contained within this object should be shown as a selectable tab within the viewpoint
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setShownInd = function(shownInd) {
	if (typeof shownInd === "boolean") {
		this.m_shownInd = shownInd;
	}
	return this;
};
/**
 * Sets the date object created duringof the last refresh for the View contained within thie ViewContainer object
 * @param {date} lastRefreshDate  The date object of the last refresh for the View contained within thie ViewContainer object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setLastRefreshDate = function(lastRefreshDate) {
	if (lastRefreshDate instanceof Date) {
		this.m_lastRefreshDate = lastRefreshDate;
	}
	return this;
};
/**
 * Sets the menu item indicator which determines if the view object should be available as a selectable item from the viewpoint drop down
 * @param {boolean} menuItemInd  The menu item indicator which determines if the view object should be available as a selectable item from the viewpoint drop down
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setMenuItemInd = function(menuItemInd) {
	if (typeof menuItemInd === "boolean") {
		this.m_menuItemInd = menuItemInd;
	}
	return this;
};
/**
 * Sets the dynamic view indicator which determines the container is dynamically created or not
 * @param {boolean} dynamicViewInd The dynamic view indicator
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setDynamicViewInd = function(dynamicViewInd) {
	if (typeof dynamicViewInd === "boolean") {
		this.m_dynamicViewInd = dynamicViewInd;
	}
	return this;
};
/**
 * Sets the indicator which determines if this ViewContainer has been previously activated.  This flag will be used to
 * determine if the view associated with the ViewContainer has been rendered and is part of the DOM.
 * @param {boolean} activatedInd The indicator which determines if this ViewContainer has been previously activated
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setPreviouslyActivatedInd = function(activatedInd) {
	if (typeof activatedInd === "boolean") {
		this.m_previouslyActivatedInd = activatedInd;
	}
	return this;
};
/**
 * Sets the flag which indicates if the view associated with the view container needs to resize when it is activated.
 * @param {boolean} resizeInd The flag which indicates if the view object should be resized or not
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setResizeOnActivation = function(resizeInd) {
	if (typeof resizeInd === "boolean") {
		this.m_resizeOnActivation = resizeInd;
	}
	return this;
};
/**
 * Sets the name of the view object contained within this object.
 * @param {string} viewName The name of the view object contained within this object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setViewName = function(viewName) {
	var tempObj = null;
	if (viewName && typeof viewName === "string") {
		this.m_viewName = viewName;
		this.m_asciiViewName = viewName;
		//Force jQuery to interpret the View Name as HTML so it will convert the ASCII codes to characters
		tempObj = $("<div>").html(viewName);
		//Cleanup the few remaining special characters and set the view name
		this.m_literalViewName = tempObj.html().replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">");
	}
	return this;
};
/**
 * Sets the view object to be used when the viewpoint tab is selected to be shown.
 * @param {object} viewObj The view object to be used when the viewpoint tab is selected to be shown.
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setViewObject = function(viewObj) {
	if (viewObj && !$.isArray(viewObj) && typeof viewObj === "object") {
		this.m_viewObj = viewObj;
	}
	return this;
};
/**
 * Sets the view object type associated to the view contained within this object
 * @param {string} viewType The view object type associated to the view contained within this object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setViewType = function(viewType) {
	if (viewType && typeof viewType === "string") {
		this.m_viewType = viewType;
	}
	return this;
};

/**
 * Sets the layout type associated to the view contained within this object
 * @param {number} layoutType- The layout type associated to the view contained within this object
 * @return {ViewContainer} The ViewContainer object calling the function so chaining can be used
 */
ViewContainer.prototype.setLayoutType = function(layoutType) {
	if (layoutType && typeof layoutType === "number") {
		this.m_layoutType = layoutType;
	}
	return this;
};


/**
 * The viewpoint object will contain all of the necessary information needed to initialize, interact with and render an MPages Viewpoint.
 * Each view that is set to be displayed within the viewpoint will be stored within a ViewContainer, which will house all of the necessary
 * information to render that view and all of the contents within.
 * @constructor
 * @param {string} viewpointId The id associated with this viewpoint
 */
function Viewpoint(viewpointId) {

	//A flag which determines if the chart search functionality should be shown or not
	this.m_chartSearchInd = false;

	//A flag which determines if the tagging functionality should be available or not
	this.m_taggingInd = false;

	//A flag which determines if the depart process functionality should be shown or not
	this.m_departProcessInd = false;

	//The view that is currently being shown in the viewpoint
	this.m_currentViewId = null;

	//View ID of the view loaded and shown during the initial page load
	this.m_initialViewId = null;

	//The array of Views which are available within the Viewpoint.  These views can be of any type as long as the initialization is handled correctly
	//when the view is being shown on the screen
	this.m_viewContainerArray = [];

	//The unique id associated with this instance of the Viewpoint object
	this.m_viewpointId = viewpointId;

	//The name given to the viewpoint
	this.m_viewpointName = "";

	//The settings associated with this viewpoint
	this.m_viewpointSettings = null;

	//The criterion object to use when creating Views
	this.m_criterionObj = null;

	//A flag which determines if IPASS will be shown or not
	this.m_ipassInd = false;

	//A flag which determines if care team selector will be shown or not
	this.m_careTeamSelector = false;

	//This menu item is used to toggle touch mode in the viewPointBodyObj
	this.m_touchMenuItem = null;
	
	// tab controller object to maintain one tab control per view point
	this.m_tabControllerObj = null;
}

/** Adders **/
/**
 * Adds a view container to the end of the view container array.  There will be one and only one view container per view set to display in the viewpoint.
 * @param {ViewContainer} viewContainer The view container object to add to the viewpoint
 * @return {boolean} True if the ViewContainer object was added successfully, false otherwise
 */
Viewpoint.prototype.addViewContainerObject = function(viewContainer) {
	if (viewContainer && viewContainer instanceof ViewContainer) {
		this.m_viewContainerArray.push(viewContainer);
		return true;
	}
	return false;
};
/** Getters **/

/**
 * Retrieve the flag which determines if the chart search functionality should be shown or not.
 * @return {boolean} A flag which indicates if the chart search functionality should be shown or not
 */
Viewpoint.prototype.getChartSearchInd = function() {
	return this.m_chartSearchInd;
};
/**
 * Retrieve the flag which determines if the tagging functionality should be available or not.
 * @return {boolean} A flag which indicates if the tagging functionality should be available or not
 */
Viewpoint.prototype.getTaggingInd = function() {
	return this.m_taggingInd;
};
/**
 * Retrieve the criterion object created for use in the viewpoint.
 * @return {object} The criterion object used in the viewpoint
 */
Viewpoint.prototype.getCriterionObject = function() {
	return this.m_criterionObj;
};
/**
 * Retrieve the id of the view which is currently being shown in the viewpoint
 * @return {string} The id of the view which is currently being shown in the viewpoint
 */
Viewpoint.prototype.getCurrentViewId = function() {
	return this.m_currentViewId;
};
/**
 * Retrieve the flag which determines if the depart process functionality should be shown or not.
 * @return {boolean} A flag which indicates if the depart process functionality should be shown or not
 */
Viewpoint.prototype.getDepartProcessInd = function() {
	return this.m_departProcessInd;
};
/**
 * Retrieve the id associated to this instance of the Viewpoint object.
 * @return {string} The id associated to the Viewpoint object
 */
Viewpoint.prototype.getId = function() {
	return this.m_viewpointId;
};

/**
 * Retrieve the id of the view loaded and shown during the initial page load
 * @return {string} View ID of the view loaded and shown during the initial page load
 */
Viewpoint.prototype.getInitialViewId = function() {
	return this.m_initialViewId;
};

/**
 * Retrieve the name associated to the viewpoint.
 * @return {string} The name associated to the viewpoint
 */
Viewpoint.prototype.getName = function() {
	return this.m_viewpointName;
};
/**
 * Retrieve the settings object used to render the viewpoint and all of its views
 * @return {object} The settings object used to render the viewpoint and all of its views
 */
Viewpoint.prototype.getSettingsObj = function() {
	return this.m_viewpointSettings;
};

/**
 * Retrieve the touch menu item if it has been created for this viewpoint.
 * @return {MenuSelection} The menu item created for toggling touch mode on and off
 **/
Viewpoint.prototype.getTouchMenuItem = function() {
	return this.m_touchMenuItem;
};

/**
 * Retrieves the array of ViewContainer objects that are available within this Viewpoint instance.
 * @return {array} The array of ViewContainer objects that are available within this Viewpoint instance.
 */
Viewpoint.prototype.getViewContainerArray = function() {
	return this.m_viewContainerArray;
};
/**
 * Retrieve the Show IPASS flag set in bedrock
 * @return {boolean} A flag which indicates if IPASS should be shown or not
 */
Viewpoint.prototype.getShowIPASS = function() {
	return this.m_ipassInd;

};
/**
 * Retrieve the Care Team flag set in bedrock
 * @return {boolean} A flag which indicates if care team selector should be shown or not
 */
Viewpoint.prototype.getCareTeamSelector = function() {
	return this.m_careTeamSelector;
};
/** Setters **/

/**
 * Set the flag which indicates if the chart search functionality should be shown in the viewpoint.
 * @param {boolean} chartSearchInd A flag which indicates if the chart search functionality should be shown in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setChartSearchInd = function(chartSearchInd) {
	if (typeof chartSearchInd === "boolean") {
		this.m_chartSearchInd = chartSearchInd;
	}
	return this;
};
/**
 * Set the flag which indicates if the tagging functionality should be available in the viewpoint.
 * @param {boolean} taggingInd A flag which indicates if the tagging functionality should be available in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setTaggingInd = function(taggingInd) {
	if (typeof taggingInd === "boolean") {
		this.m_taggingInd = taggingInd;
	}
	return this;
};
/**
 * Set the criterion object created for use in the viewpoint
 * @param {object} criterionObj The criterion object created for use in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setCriterionObject = function(criterionObj) {
	if (criterionObj && typeof criterionObj === "object") {
		this.m_criterionObj = criterionObj;
	}
	return this;
};
/**
 * Set the id of the view which is currently being shown in the viewpoint.
 * @param {string} viewId The id of the view which is currently being shown in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setCurrentViewId = function(viewId) {
	if (viewId && typeof viewId === "string") {
		this.m_currentViewId = viewId;
	}
	return this;
};
/**
 * Set the flag which indicates if the depart process functionality should be shown in the viewpoint.
 * @param {boolean} departInd A flag which indicates if the depart process functionality should be shown in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setDepartProcessInd = function(departInd) {
	if (typeof departInd === "boolean") {
		this.m_departProcessInd = departInd;
	}
	return this;
};
/**
 * Set the id which will be associated to a specific instance of the Viewpoint object
 * @param {string} viewpointId The id to be associated with the Viewpoint object
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setId = function(viewpointId) {
	if (viewpointId && typeof viewpointId === "string") {
		this.m_viewpointId = viewpointId;
	}
	return this;
};

/**
 * Set the id of the view loaded and shown during the initial page load
 * @param {string} viewId View ID of the view loaded and shown during the initial page load
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setInitialViewId = function(viewId) {
	if (viewId && typeof viewId === "string") {
		this.m_initialViewId = viewId;
	}
	return this;
};

/**
 * Set the name of the viewpoint
 * @param {string} viewpointName the name to associate to the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setName = function(viewpointName) {
	if (viewpointName && typeof viewpointName === "string") {
		this.m_viewpointName = viewpointName;
	}
	return this;
};

/**
 * Sets the settings object of this Viewpoint.  This settings object contains all of the information needed to render the viewpoint and is returned from the mp_viewpoint_driver script.
 * @param {object} settingsObj The settings object used in this Viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setSettingsObj = function(settingsObj) {
	if (settingsObj && typeof settingsObj === "object") {
		this.m_viewpointSettings = settingsObj;
	}
	return this;
};
/**
 * Set the flag which indicates if IPASS should be shown in the viewpoint.
 * @param {boolean} ipassInd A flag which indicates if the IPASS should be shown in the viewpoint
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setShowIPASS = function(ipassInd) {
	if (typeof ipassInd === "boolean") {
		this.m_ipassInd = ipassInd;
	}
	return this;
};
/**
 * Set the flag which indicates if the care team selector should be shown in IPASS
 * @param {boolean} careTeamSelectorInd A flag which indicates if the are team selector should be shown in IPASS
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setShowCareTeamSelector = function(careTeamSelectorInd) {
	if (typeof careTeamSelectorInd === "boolean") {
		this.m_careTeamSelector = careTeamSelectorInd;

		// Use shared resource to save the care team enabled preference
		var careTeamSelectorResource = new SharedResource("isCareTeamEnabled");
		if (careTeamSelectorResource) {
			careTeamSelectorResource.setResourceData(careTeamSelectorInd);
			careTeamSelectorResource.setIsAvailable(true);
			MP_Resources.addSharedResource("isCareTeamEnabled", careTeamSelectorResource);
		}
	}
	return this;
};


/**
 * Sets the menu item that is used to toggle touch mode on and off for the viewpoint
 * @param {MenuSelection} menuItem The menu item that will be added to the page level menu.
 * @return {undefined} This function does not return a value
 **/
Viewpoint.prototype.setTouchMenuItem = function(menuItem) {
	if (typeof menuItem !== "object" || !(menuItem instanceof MenuSelection)) {
		throw new Error("Viewpoint.setTouchMenuItem only accepts objects of type MenuSelection");
	}
	this.m_touchMenuItem = menuItem;
};

/**
 * Sets the array of views that are available within this Viewpoint object.  Each ViewContainer is used to handle the initialization and rendering of one view
 * within a viewpoint.  This array may or may not be populated with any values, but it must be an array.
 * @param {array} viewArray The array of Views that should be available within this Viewpoint instance.
 * @return {Viewpoint} The Viewpoint object calling the function so chaining can be used
 */
Viewpoint.prototype.setViewContainerArray = function(viewArray) {
	//Accept empty arrays as well as populated
	if ($.isArray(viewArray)) {
		this.m_viewContainerArray = viewArray;
	}
	return this;
};

/**
 * This function is used to apply the user preferences that are related to the overall viewpoint
 * @return {undefined} This function does not return a value
 **/
Viewpoint.prototype.applyUserPreferences = function() {
	var capTimer = null;
	var viewpointSettings = this.getSettingsObj();
	var userPrefs = viewpointSettings.USER_PREFS || null;

	if (!userPrefs) {
		logger.logDebug("No viewpoint user preferences defined for this user");
		return;
	}

	//Attempt to parse the user prefs since they are returned in JSON format from the driver
	try {
		userPrefs = JSON.parse(userPrefs);
	}
	catch (err) {
		logger.logJSError(err, null, "mpage-viewpoint.js", "applyUserPreferences");
		return;
	}

	//Apply the touch mode user preferences and log a CAP timer for tracking purposes
	if (userPrefs.touchMode) {
		if (CERN_Platform.inMillenniumContext()) {
			CERN_Platform.setTouchModeEnabled(userPrefs.touchMode.millenniumInd);
			capTimer = new CapabilityTimer("CAP:MPG Touch Mode Enabled - Millennium", this.getId());
			capTimer.addMetaData("rtms.legacy.metadata.1", userPrefs.touchMode.millenniumInd.toString());
			capTimer.capture();
		}
		else{
			CERN_Platform.setTouchModeEnabled(userPrefs.touchMode.webInd);
			capTimer = new CapabilityTimer("CAP:MPG Touch Mode Enabled - Web", this.getId());
			capTimer.addMetaData("rtms.legacy.metadata.1", userPrefs.touchMode.webInd.toString());
			capTimer.capture();
		}
	}
};

/**
 * A collection of function which are used to create the viewpoint controls and user interface.  The MP_Viewpoint
 * namespace keeps a copy of the viewpoint that is being shown to the user.  This object is private to this
 * namespace and should not be altered.  All interactions with the viewpoint will be handled by the fuctions
 * contained within this namespace.
 * @namespace
 */
var MP_Viewpoint = function() {
	/* @private */
	var viewpointObject = null;
	var vwpi18n = i18n.discernabu.mpageViewpoint;

	/**
	 * @private
	 * Creates the chart search utility and controls that toggling of the user interface dialog
	 * function.
	 * @return {HTMLElement} The full HTML contents of the viewpoint drop down menu and all of the associated interactions.
	 */
	function createChartSearchUtility() {
		var chartSearch = null;
		var vwpUtilContainer = null;

		//Callback function used when launching the chart search modal window
		function csCallback(url) {
			try {
				if (url) {
					/*eslint-disable new-cap*/
					var fwObj = window.external.DiscernObjectFactory("PVFRAMEWORKLINK");
					fwObj.SetPopupStringProp("REPORT_NAME", "<url>" + url);
					fwObj.SetPopupDoubleProp("WIDTH", 1200);
					fwObj.SetPopupDoubleProp("HEIGHT", 700);
					fwObj.SetPopupBoolProp("SHOW_BUTTONS", 0);
					fwObj.LaunchPopup();
					/*eslint-enable new-cap*/
				}
				else {
					logger.logError("Error retriving URL from search");
				}
			}
			catch (err) {
				logger.logError(i18n.discernabu.CODE_LEVEL);
				logger.logError("Error creating PVFRAMEWORKLINK window <br />Message: " + err.description + "<br />Name: " + err.name + "<br />Number: " + (err.number & 65535) + "<br />Description: " + err.description);
			}
		}

		//This function is used to toggle the chart search popup and also create it if opening it for the first time
		function toggleChartSearchDialog() {
			var criterion = null;
			var csDialog = null;
			var csIcon = null;
			var csParams = null;
			var csTitle = null;
			var searchBar = null;
			var seperator = null;

			//Update the classes on the viewpoint utility
			csIcon = $("#chartSearch");
			if($(csIcon).hasClass("vwp-chart-search-active")) {
				//Deactivate the chart search dialog
				csIcon.removeClass("vwp-chart-search-active");

				//Hide any of the suggestion drop down dialogs
				$(".token-input-dropdown-facebook").addClass("hidden");

				//Hide the chart search dialog
				$("#vwpChartSearchDialog").addClass("hidden");
			}
			else {
				//Activate the chart search dialog
				//Show the chart search icon as active
				csIcon.addClass("vwp-chart-search-active");

				//If the dialog is already created show it and return.
				csDialog = $("#vwpChartSearchDialog");
				if (csDialog.length) {
					//Hide the chart search dialog
					$(csDialog).removeClass("hidden");
					return;
				}

				//Create the chart search dialog
				csDialog = $("<div></div>")
					.addClass("vwp-chart-search-dialog")
					.attr("id", "vwpChartSearchDialog");

				//Create the header title
				csTitle = $("<div></div>")
					.addClass("vwp-chart-search-header")
					.html(vwpi18n.CHART_SEARCH);
				$(csDialog)
					.append(csTitle);

				//Add the title/body separator
				seperator = $("<div></div>")
					.addClass("vwp-chart-search-separator");
				$(csDialog)
					.append(seperator);

				//Add the search bar container
				searchBar = $("<div><div id='chartSearchInputBox'></div></div>")
					.addClass("vwp-chart-search-bar");
				$(csDialog)
					.append(searchBar);

				//Show the menu to the user
				$(document.body)
					.append(csDialog);

				//Show the chart search box
				criterion = viewpointObject.getCriterionObject();
				if (criterion) {
					csParams = {
						patientId: criterion.person_id,
						userId: criterion.provider_id,
						callback: csCallback
					};

					//Attempt to imbed the chart search box
					try {
						ChartSearchInput.embed("chartSearchInputBox", csParams);
					}
					catch (err) {
						logger.logError("Error calling Chart Search embed <br />Message: " + err.description + "<br />Name: " + err.name + "<br />Number: " + (err.number & 65535) + "<br />Description: " + err.description);
					}
				}

				//Update some of the css classes on the chart search
				$("#cs-find")
					.css("padding", "4px")
					.click(toggleChartSearchDialog);
				$("#chart-search-input .autocomplete-input")
					.css("width", "100%");
			}
		}

		//Add the chart search icon
		chartSearch = $("<div></div>")
			.attr({
				id: "chartSearch",
				title: vwpi18n.CHART_SEARCH
			})
			.addClass("vwp-chart-search")
			.append($("<span>&nbsp;</span>")
				.addClass("vwp-chart-search-icon"));

		//Add the functionality to render the chart search view when the icon is clicked
		chartSearch.click(toggleChartSearchDialog);

		//If the viewpoint utilities are available shift them left to account for chart search
		vwpUtilContainer = $("#vwpUtilities");
		if (vwpUtilContainer.length) {
			$(vwpUtilContainer)
				.css("right", "90px");
		}

		return chartSearch;
	}

	/**
	 * @private
	 * Creates the page menu placeholder for View menu options
	 * @return {HTMLElement} The full HTML contents of the viewpoint page menu and all of the associated interactions.
	 */
	function createPageMenu() {
		return $("<div id='pageMenu'>&nbsp;</div>").addClass("vwp-page-menu");
	}

	/**
	 * @private
	 * Function to insert a tab next to the current tab
	 * @param {ViewContainer} viewContainer The ViewContainer object which contains all of the information needed to create the tab container HTML
	 * @returns {undefined} does not return anything.
	 */	
	function insertTab(viewContainer) {
		//Determine if this tab is displayable or not
		if (!viewContainer.isDisplayable()) {
			return;
		}		
		var tab = null;
		//creating tab object which would be inserted to tabControl
		tab = {
			id: viewContainer.getId(),
			label: viewContainer.getAsciiViewName(),
			title: viewContainer.getAsciiViewName()
		};
		//gets tabControl object to insert the tab to next to the current tab.
		MP_Viewpoint.getTabControlObject().insertTab(tab);
	}	
	
	/**
	 * Function to calculate the tab control width and apply to it.
	 * @returns {undefined} does not return anything.
	 */	
	function applyTabControlWidth() {
		var tabControls = $("#vwpTabControls");
		//calculate tab control width and call the finalize method the finalize the tab control api
		var widthToReduce = 0;
		//get all the siblings of the tab control containers and reduce to the width to calculate the tab control width
		var tabControlSiblings = tabControls.siblings();
		for (var count = 0; count < tabControlSiblings.length; count++) {
			widthToReduce += $(tabControlSiblings[count]).outerWidth(true);
		}
		//accounting for the IPass Ill severity width if it is not available while calculating the tab control width
		if (!$("#vwpIllSevInd").width()) {
			//taking the maximum text width since it is being calculated in the callback function
			widthToReduce += 80;
		}
		tabControls.width($("#vwpControls").width() - widthToReduce);
	}

	
	/**
	 * @private
	 * Function to create tab control from MPageUI API AddTabControl.
	 * @returns {HTMLElement} The HTML contents of the tab Control
	 */	
	function createTabControl() {
		var tabControlContent = null;
		var criterion = viewpointObject.getCriterionObject();
		var tabControl = new MPageUI.ViewpointTabControl();
		var defaultTabId = MP_Viewpoint.getInitialViewId();
		//set can close option true to have the tabs closable
		tabControl.setCanCloseTabs(true);
		//set can sort option true to have the ability to sort tabs
		//Setup drag and drop if we are within Millennium or the CERN_BrowserDevInd flag is set
		if (CERN_Platform.inMillenniumContext() || CERN_BrowserDevInd) {
			tabControl.setCanSortTabs(true);
			tabControl.setOnSortCallback(function() {
				MP_Viewpoint.saveViewpointSettings();
				new CapabilityTimer("CAP:MPG Viewpoint Views Sort", criterion.category_mean).capture();
			});
		}
		//set the callback functions
		tabControl.setOnSelectCallback(function(tab) {
			MP_Viewpoint.activateView(tab.id);
		});
		//add a new tab for select view page on add tab callback
		tabControl.setOnAddTabCallback(function() {
			//add view selection tab to the tabControl
			tabControl.addTab(createViewSelectionTab(), true);
			//create a container for view selection page and activate
			MP_Viewpoint.createViewSelectionContainer();
		});
		//saving viewpoint setting on close callback
		tabControl.setOnCloseCallback(function(tab) {
			var tabs = MP_Viewpoint.getTabControlObject().getTabs();
			var totalTabs = tabs.length;
			//check if there are no more tabs, then add view selection tab so it will activate the view selection page.
			if(totalTabs === 0) {
				//add view selection tab to the tabControl
				tabControl.addTab(createViewSelectionTab(), true);
				//create a container for view selection page and activate
				MP_Viewpoint.createViewSelectionContainer();
			}
			//set the shownInd to false and change the sequence for closing tab
			var viewContainer = MP_Viewpoint.getViewContainerById(tab.id);	
			if(viewContainer) {
				viewContainer.setSequence(99);
				viewContainer.setShownInd(false);
				MP_Viewpoint.saveViewpointSettings();
				var viewContainerArr = viewpointObject.getViewContainerArray();
				var totalViews = viewContainerArr.length;
				//reduces the select view from total view if it is available 
				for (var x = 0; x < totalViews; x++) {
					if (viewContainerArr[x].getId() === "SELECT_VIEW") {
						totalViews--;
						break;
					}
				}
				var facedUpViewsInfo = tabControl.getTabs().length + " out of " + totalViews;
				var capTimer = new CapabilityTimer("CAP:MPG Remove View From Viewpoint", viewpointObject.getName());
				capTimer.addMetaData("view.name", viewContainer.m_viewName + "(" + viewContainer.m_categoryMean + ")");
				capTimer.addMetaData("viewpoint.faceUpViews.count", facedUpViewsInfo);
				capTimer.capture();
			}
		});
		//set the default tab if it is available 
		if(defaultTabId) {
			tabControl.setDefaultTab(defaultTabId);
		}
		//call render function to render the tab control
		tabControlContent = tabControl.render();
		//store tab control object
		viewpointObject.m_tabControllerObj = tabControl;
		return tabControlContent;
	}
		
	/**
	 * @private
	 * Function to create a view selection tab.
	 * @returns {object} view selection tab.
	 */		
	function createViewSelectionTab() {
		var tab = {
			id: "SELECT_VIEW",
			label: vwpi18n.NEW_VIEW,
			title: vwpi18n.NEW_VIEW
		};
		return tab;
	}

	/**
	 * @private
	 * Function to find the default tab id.
	 * @returns {object} view selection tab.
	 */		
	function findDefaultViewId() {
		var defaultViewId = null;
		var viewContainer = null;
		var viewpointSettings = null;
		var defaultViewCatMean = null;
		var criterion = viewpointObject.getCriterionObject();
		var viewContainerArr = viewpointObject.getViewContainerArray();
		var viewCount = viewContainerArr.length;

		//Determine which view to activate first
		//Check for a session level cookie property
		defaultViewId = MP_Util.GetCookieProperty("viewpoint", "viewCatMean|" + viewpointObject.getId() + "|" + criterion.person_id + "|" + criterion.encntr_id);
		viewContainer = MP_Viewpoint.getViewContainerById(defaultViewId);
		viewpointSettings = viewpointObject.getSettingsObj();
		//Get the default view that will be rendered. It's determined by mp_unified_driver.
		//The actual view that will be rendered may change due to session cache or the view not being displayable
		defaultViewCatMean = viewpointSettings.ACTIVE_VIEW_CAT_MEAN;

		if (!viewContainer) {
			//That view no longer exists in the viewpoint use the encounter default if available
			if (viewpointSettings && defaultViewCatMean) {
				viewContainer = MP_Viewpoint.getViewContainerById(defaultViewCatMean);
				defaultViewId = viewContainer.getId();
			}
			//Use the first view listed as a default if the encounter default is not available
			if (!viewContainer && viewContainerArr[0]) {
				viewContainer = viewContainerArr[0];
				defaultViewId = viewContainer.getId();
			}
		}

		//Determine if the defaulted view is displayable or not.  If not find the first view that is displayable
		if (viewContainer && !viewContainer.isDisplayable()) {
			logger.logWarning("View " + viewContainer.getCategoryMean() + " is not displayable");
			viewContainer = null;
			for (var x = 0; x < viewCount; x++) {
				if (viewContainerArr[x].isDisplayable()) {
					viewContainer = viewContainerArr[x];
					defaultViewId = viewContainer.getId();
					logger.logWarning("Falling back to " + viewContainer.getCategoryMean());
					break;
				}
			}
		}
		return defaultViewId;
	}

	/**
	 * @private
	 * Function to add tab to tab control
	 * @param {ViewContainer} viewContainer The ViewContainer object which contains all of the information needed to create the tab container HTML
	 * @param {boolean} activateTab - to decide whether to activate tab or not
	 * @returns {undefined} does not return anything.
	 */	
	function addTab(viewContainer, activateTab) {
		//Determine if this tab is displayable or not
		if (!viewContainer.isDisplayable()) {
			return;
		}
		var tab = null;
		//creating tab object which would be added to tabControl
		tab = {
			id: viewContainer.getId(),
			label: viewContainer.getAsciiViewName(),
			title: viewContainer.getAsciiViewName()
		};
		//gets tabControl object and adds a tab to tabControl
		MP_Viewpoint.getTabControlObject().addTab(tab, activateTab);
	}	

	/**
	 * @private
	 * Creates the viewpoint utilities html container and initializes the viewpoint utilites
	 * @return {undefined} This function does not return a value
	 */
	function createUtilitesBar() {
		var criterion = viewpointObject.getCriterionObject();
		
		//If we are not in the context of a patient chart we should not be adding any utilities
		if(!CERN_Platform.inPatientChartContext()){
			return;
		}
		
		//Add the viewpoint utilities container
		var utilities = $("<div class='vwp-util-container' id='vwpUtilities'></div>");
		$("#vwpControls").append(utilities);

		//Initialize each of the Utilities
		//Initialize the ScratchPad Utility if powerchart context is available
		if (CERN_Platform.inMillenniumContext() || CERN_BrowserDevInd) {
			MP_ScratchPadMgr.init();
		}

		//Initialize the I-PASS Utility
		if (viewpointObject.getShowIPASS()) {
			var isDepartProcessEnabled = CERN_Platform.inMillenniumContext() && viewpointObject.getDepartProcessInd();
			//Create the utilities container for the Comments Dialog
			utilities.append("<div class='vwp-util vwp-util-ipass' id='vwpIPass'><div class='vwp-util-icon' id='vwpIPassIcon'>&nbsp;</div><div class='vwp-ill-sev-ind' id='vwpIllSevInd'></div></div>");
			//Adds a separator on the right if other utilities are enabled.
			if (viewpointObject.getTaggingInd() || viewpointObject.getChartSearchInd() || isDepartProcessEnabled) {
				$("#vwpIPass")
					.addClass("vwp-ipass-right-seperator");
			}
			CERN_IPASS_O1.initIPassComponent("vwpIPassIcon", viewpointObject.getCareTeamSelector());
		}

		//Initialize the Tagging Utility
		if (viewpointObject.getTaggingInd()) {
			$(utilities).append("<div class='vwp-util' id='vwpTagging'><div class='vwp-util-icon' id='vwpTaggingIcon'>&nbsp;</div></div>");
			MP_TaggingHandler.initTaggingUtility("vwpTaggingIcon", criterion);
		}

		//Add the depart process if active
		if (CERN_Platform.inMillenniumContext() && viewpointObject.getDepartProcessInd()) {
			//Create the utilities container for the Depart Process Dialog
			$(utilities)
				.append($("<div class='vwp-util'><div class='vwp-util-icon vwp-depart-process-icon' id='vwpDepartProcess' title='" + i18n.CLICK_TO_GO_TO_DISCHARGE_PROCESS + "'>&nbsp;</div></div>")
					.click(function() {
						var dpObject = {};
						/*eslint-disable mp-camelcase*/
						dpObject = window.external.DiscernObjectFactory("DISCHARGEPROCESS");
						dpObject.person_id = criterion.person_id;
						dpObject.encounter_id = criterion.encntr_id;
						dpObject.user_id = criterion.provider_id;
						/*eslint-enable mp-camelcase*/
						dpObject.LaunchDischargeDialog();
					}));
			//Get the div container for Viewpoint utility icons and add an entry for this modal
		}
	}

	/**
	 * @private
	 * There are certain instances where the view names for an MPage are not defined.  In this situation a
	 * hardcoded view name is used.  This function can be used to retrieve that default name if one is not
	 * available
	 * @param {string}	categoryMean The Bedrock Wizard category mean of the view we need a name for
	 * @return {string} The default name for the view with the specified category mean.
	 */
	function getDefaultViewName(categoryMean) {

		if (!categoryMean) {
			return;
		}
		/*eslint-disable consistent-return*/
		switch (categoryMean) {
			case "MP_ICU_DASHBOARD":
				return i18n.discernabu.ICU_DASHBOARD;
			case "MP_COMMON_ORDERS_V4":
				return i18n.COMMON_ORDERS;
			default:
				return "MPages View";
		}
		/*eslint-enable consistent-return*/
	}

	/**
	 * @private
	 * Updates the 'As Of' display in the viewpoint controls with the last refresh date of the view
	 * @param {Date} viewContainer A date element which was created when the page was being rendered
	 * @return {undefined} This function does not return a value
	 */
	function updateAsOfDisplay(viewContainer) {
		var dateFormatter = null;
		var dateObj = null;
		var dateString = "";
		var tabControlObj = MP_Viewpoint.getTabControlObject();

		if (viewContainer) {
			//Get the last refresh date and format the display
			dateObj = viewContainer.getLastRefreshDate();
			if (dateObj) {
				dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
				dateString = dateFormatter.format(dateObj, mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS);				
				var tab = null;
				//creating tab object which would be added to tabControl
				tab = {
					id: viewContainer.getId(),
					label: viewContainer.getAsciiViewName(),
					title: viewContainer.getLiteralViewName() + " - " + i18n.discernabu.AS_OF_TIME.replace("{0}", dateString)
				};

				//Update the as of display in the tab hover
				if(tabControlObj.tabExists(tab.id)) {
					tabControlObj.updateTitle(tab);
				}
			}
		}
	}

	/**
	 * @private
	 * Writes the viewpoint preferences to the database.
	 * @param {object} prefsObj The object which is used to contain all of the viewpoint preferences
	 * @param {boolean} asyncInd An indicator which determines if the settings should be saved asynchronously or not
	 * @return {undefined} This function does not return a value
	 */
	function writeViewpointPreferences(prefsObj, asyncInd) {
		var criterion = viewpointObject.getCriterionObject();

		var prefsRequest = new ScriptRequest();
		prefsRequest.setName("Viewpoint Preferences Save");
		prefsRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
		prefsRequest.setParameterArray(["^mine^", criterion.provider_id + ".0", "^VWP|" + viewpointObject.getId().substring(0, 28) + "^", "~" + JSON.stringify(prefsObj) + "~"]);
		prefsRequest.setAsyncIndicator(asyncInd);
		prefsRequest.setResponseHandler(function(scriptReply) {
			var status = scriptReply.getStatus();

			if (status === "S") {
				logger.logMessage("Viewpoint settings saved successfully");
			}
			else {
				logger.logWarning("Viewpoint settings not saved successfully");
			}
		});
		prefsRequest.performRequest();
	}

	return {
		loadTouchMenuItem: function() {
			var touchMenuItem = null;
			var userPrefs = null;
			var viewpointSettings = null;

			//Check to see if the menu item already exists
			touchMenuItem = viewpointObject.getTouchMenuItem();
			if (touchMenuItem) {
				//If it already exists it can be shared across all menus so just return it
				return touchMenuItem;
			}

			//Create the touch menu item since it doesnt exist
			touchMenuItem = new MenuSelection("touchModeToggle");
			touchMenuItem.setLabel(i18n.TOUCH_MODE);
			touchMenuItem.setCloseOnClick(false);
			viewpointObject.setTouchMenuItem(touchMenuItem);

			//Load the touch settings and create the MenuSelection that controls it
			viewpointSettings = viewpointObject.getSettingsObj();

			//Initialize the settings if they are not already defined
			if (!viewpointSettings.USER_PREFS) {
				userPrefs = {
					touchMode: {
						millenniumInd: false,
						webInd: false
					}
				};
			}
			else {
				userPrefs = JSON.parse(viewpointSettings.USER_PREFS);
			}

			touchMenuItem.setIsSelected(CERN_Platform.inMillenniumContext() ? userPrefs.touchMode.millenniumInd : userPrefs.touchMode.webInd);
			/*eslint-disable no-unused-vars*/
			touchMenuItem.setClickFunction(function(event) {
				/*eslint-enable no-unused-vars*/
				var selected = touchMenuItem.isSelected();
				//Update the user prefences object
				if (CERN_Platform.inMillenniumContext()) {
					userPrefs.touchMode.millenniumInd = selected;
				}
				else {
					userPrefs.touchMode.webInd = selected;
				}

				//Update the viewpoint settings with the new user preferences
				viewpointSettings.USER_PREFS = JSON.stringify(userPrefs);
				viewpointObject.setSettingsObj(viewpointSettings);
				MP_Viewpoint.saveViewpointSettings(false);

				//Show the cursor as busy
				$("body").css("cursor", "wait");
		
				// Refresh page 
				CERN_Platform.refreshMPage();
			});

			return touchMenuItem;
		},

		/**
		 * This function is used to active a view tab within the viewpoint.  It will first deactivate the previously active tab and then activate this new tab.
		 * Once that is complete a call to render the newly selected view is made.
		 * @param {string} newViewId The id of the view which is being activated.
		 * @return {undefined} This function does not return a value
		 */
		activateView: function(newViewId) {
			var criterion = viewpointObject.getCriterionObject();
			var pageMenu = null;
			var viewBodyElement = null;
			var viewId = "";

			//Get the current view id
			viewId = viewpointObject.getCurrentViewId();

			//Check to see if the view is already being shown
			if (viewId === newViewId) {
				return;
			}

			//deactivate current view if available
			if (viewId) {

				//Grab the current offset of the previous view and set it to local variable;
				var oldViewContainer = MP_Viewpoint.getViewContainerById(viewId);
				var oldViewObj = oldViewContainer.getViewObject();
	
				// skip the user preference when the view is a dummy view. 
				if(! (oldViewObj instanceof DummyMPage)){
					//Get the current user preferences for the view we are de-activiating
					oldViewObj.setUserPreferences(MP_Core.AppUserPreferenceManager.GetPreferences());
					
					//Only attempt to save the offset position if the MPageView is being shown within a valid context
					if(oldViewObj.isContextValid()){
						oldViewObj.saveOffsetPosition();
					}
				}
				//Hide the current view body
				viewBodyElement = $("#" + viewId);
				$(viewBodyElement).addClass("hidden");
			}

			//Set the newly active view id
			viewpointObject.setCurrentViewId(newViewId);

			//Update the preference Identifier so the correct preferences are saved for the correct tab
			MP_Core.AppUserPreferenceManager.UpdatePrefsIdentifier(newViewId);

			//Clear all open menus being shown on the page
			MP_Util.Doc.HideAllCompMenus();

			//Remove the id associated with the page menu and update it to the new view id
			pageMenu = viewId ? $("#pageMenu" + viewId) : $("#pageMenu");
			$(pageMenu).attr("id", "pageMenu" + newViewId).unbind("click");


			//Close any open menus
			MP_MenuManager.closeMenuStack(true);

			//Render the newly selected view
			setTimeout(function() {
				MP_Viewpoint.renderView(newViewId);
			}, 0);
			//Save the activated view to the cookie
			MP_Util.AddCookieProperty("viewpoint", "viewCatMean|" + viewpointObject.getId() + "|" + criterion.person_id + "|" + criterion.encntr_id, newViewId);
			MP_Util.WriteCookie();
		},
		/**
		 * Creates a Viewpoint utility option which will be shown to the user.  This function only creates the
		 * visual portion of the functionality.  The calling function will be in charge of click events and additional functionality.
		 * @param {ModalDialog} modalObj The modal dialog object to associate to a viewpoint utility.
		 * @return {undefined} This function does not return a value
		 */
		addModalDialogUtility: function(modalObj) {
			var iconElement = null;

			if(modalObj instanceof ModalDialog) {
				if($("#" + modalObj.getIconElementId()).length > 0) {
					logger.logError("MP_ModalDialog.addModalDialogObject: Modal dialog " + modalObj.getId() + " already added");
					return;
				}

				//Get the div container for Viewpoint utility icons and add an entry for this modal
				iconElement = $("<div></div>")
					.attr({
						id: modalObj.getIconElementId(),
						title: modalObj.getIconHoverText()
					})
					.addClass(modalObj.getIconClass())
					.html(modalObj.getIconText() || "&nbsp;");
				if (modalObj.isIconActive()) {
					$(iconElement)
						.addClass("vwp-util-icon")
						.click(function() {
							MP_ModalDialog.showModalDialog(modalObj.getId());
						});
				}
				$("#vwpUtilities").append(iconElement);
			}
			return;
		},
		/**
		 * Retrieves the active view ID from the Viewpoint.
		 * @return {String} the currently active view ID string.
		 */
		getActiveViewId: function() {
			return viewpointObject.getCurrentViewId();
		},
		/**
		 * Retrieve the id of the view loaded and shown during the initial page load
		 * @return {string} View ID of the view loaded and shown during the initial page load
		 */
		getInitialViewId: function() {
			//the viewpoint object should already exist when this function is called because it will be only called inside viewpoint MPages
			//However, checking whether viewpointObject is initialized will make this function more robust.
			if (viewpointObject) {
				return viewpointObject.getInitialViewId();
			}
			else {
				return null;
			}
		},
		/**
		 * Retrieves the ViewContainer object from the Viewpoint which has the same id as the viewId passed in.
		 * @param {string} viewId The id of the ViewContainer to retrieve from the Viewpoint.
		 * @return {ViewContainer} The view container if it was found, otherwise null
		 */
		getViewContainerById: function(viewId) {
			var containerArr = null;
			var x = 0;

			//Iterate through the array and locate the necessary ViewContainer
			containerArr = viewpointObject.getViewContainerArray();
			for (x = containerArr.length; x--; ) {
				if (containerArr[x].getId() === viewId) {
					return containerArr[x];
				}
			}
			return null;
		},
		/**
		 * Create the Viewpoint object and initialize it with all of the necessary settings, create ViewContainer objects for each view that will be part
		 * of the viewpoint and create the criterion object for future use.
		 * @return {boolean} True if the initialization was successful, false otherwise
		 */
		initializeViewpoint: function() {
			var viewContainer = null;
			var viewCount = 0;
			var viewName = "";
			var viewObj = null;
			var viewpointSettings = null;
			var x = 0;

			//Retrieve the viewpoint settings
			try {
				viewpointSettings = JSON.parse(m_viewpointJSON).VP_INFO;
			}
			catch (jsonParseError) {
				logger.logError(vwpi18n.ERROR_PARSING);
				return false;
			}

			//Retreive the cookie settings
			MP_Util.RetrieveCookie();

			//Create the viewpoint object and store the settings
			viewpointObject = new Viewpoint(viewpointSettings.VIEWPOINT_NAME_KEY);
			viewpointObject.setSettingsObj(viewpointSettings)
				.setName(viewpointSettings.VIEWPOINT_NAME)
				.setChartSearchInd(viewpointSettings.CS_ENABLED === "1" ? true : false);
		
			//Check to see if the depart process should be shown or not
			viewpointObject.setDepartProcessInd(viewpointSettings.DP_ENABLED === "1" ? true : false);

			//Check if tagging should be enabled
			viewpointObject.setTaggingInd(viewpointSettings.TAGGING_ENABLED === "1" ? true : false);

			//Check if IPASS should be enabled
			viewpointObject.setShowIPASS(viewpointSettings.IPASS_ENABLED === "1" ? true : false);

			//Check if Care team selector should be enabled
			viewpointObject.setShowCareTeamSelector(viewpointSettings.CARE_TEAM_ENABLED === "1" ? true : false);

			//Create the ViewContainer objects which will house the views shown within this viewpoint
			viewCount = viewpointSettings.VIEWS.length;
			for (x = 0; x < viewCount; x++) {
				viewObj = viewpointSettings.VIEWS[x];
				viewName = viewObj.VIEW_NAME ? viewObj.VIEW_NAME : getDefaultViewName(viewObj.VIEW_CAT_MEAN);
				viewContainer = new ViewContainer(viewObj.VIEW_CAT_MEAN);
				viewContainer.setViewName(viewName)
					.setCategoryId(viewObj.VIEW_CAT_ID)
					.setCategoryMean(viewObj.VIEW_CAT_MEAN)
					.setSequence(viewObj.VIEW_SEQUENCE)
					.setUserDefinedInd(viewObj.USER_DEFINED_IND ? true : false)
					.setShownInd(viewObj.SHOWN_IND ? true : false)
					.setMenuItemInd(viewObj.MENU_ITEM ? true : false)
					.setViewType(viewObj.VIEW_TYPE_MEAN)
					.setLayoutType(viewObj.VIEW_TYPE);
				//Add the newly created object to the array of ViewContainer objects
				viewpointObject.addViewContainerObject(viewContainer);
			}

			//Create and store the criterion object for future use
			viewpointObject.setCriterionObject(MP_Util.GetCriterion(CERN_Platform.getCriterion(), CERN_static_content));

			//Apply any updates necessary based on user preferences
			viewpointObject.applyUserPreferences();
			return true;
		},
		/**
		 * Initializes the viewpoint settings, renders the viewpoint controls and activates the default view within the viewpoint.  This function
		 * is called onLoad when the page is loaded into the browser.
		 * @return {undefined} This function does not return a value
		 */
		launchViewpoint: function() {
			var timerRenderViewpoint = null;
			try {
				timerRenderViewpoint = MP_Util.CreateTimer("ENG:MPG.ViewpointDriver- renderViewpoint", CERN_driver_mean);
				//Attempt to parse the bedrock settings of the default MPage before we get started
				parseMPageSettingsJSON();
				//Create the global MPAGE_LOCALE object
				populateMPageLocale();
				//Initialize and render the viewpoint
				if (MP_Viewpoint.initializeViewpoint()) {
					MP_Viewpoint.renderViewpoint();
				}
			}
			catch (err) {
				if (timerRenderViewpoint) {
					timerRenderViewpoint.Abort();
					timerRenderViewpoint = null;
				}
				logger.logJSError(err, null, "mpage-viewpoint.js", "launchViewpoint");
				throw err;
			}
			finally {
				if (timerRenderViewpoint) {
					timerRenderViewpoint.Stop();
				}
			}
		},
		/**
		 * Renders the View with the same id as the viewId parameter passed into the function.  If the view body has been rendered previously it will just be shown to the user.
		 * If it has not been created the view body will be created and the View will be rendered. inside of it
		 * @param {string} viewId The id of the View to render within the view body.
		 * @return {undefined} This function does not return a value
		 */
		renderView: function(viewId) {
			var pageMenu = null;
			var viewBody = null;
			var viewContainer = null;
			var viewObject = null;
			var mean = "";
			var viewType = "";

			try {
				//Get the ViewContainer associated with this view
				viewContainer = MP_Viewpoint.getViewContainerById(viewId);
				
				//Determine if this ViewContainer has been previously activated (contains DOM elements)
				if (!viewContainer.previouslyActivated()) {
					//check whether the user is switching to this view from another view, and start whether to start the loading switched view timer.
					if (viewId !== MP_Viewpoint.getInitialViewId()) {
						//start the timer for loading the switched view. Stopping the timer is handled by the view, so viewpoint doesn't need to worry about it.
						//start the proper USR timer to measure the entire page load
						var switchLoadTimer = new RTMSTimer("USR:MPG.VIEWPOINT load switch view", viewId);
						switchLoadTimer.start();
					}

					//Create the body container
					viewBody = $("<div></div>")
						.addClass("vwp-body-container")
						.attr("id", viewId);
					//append the body container to the correct location
					$("#vwpBody").append(viewBody);
					mean = viewContainer.getCategoryMean();
					viewType = viewContainer.getViewType();
					//Get view object for the container
					viewObject = viewContainer.getViewObject();
					if(!viewObject){
						//Create view object
						viewObject = createViewObject(mean, viewType);
					}
					if (viewObject) {
						//Store view object
						viewContainer.setViewObject(viewObject);

						//Update the last refresh date for the view
						viewContainer.setLastRefreshDate(new Date());
						//Update the As Of display with the last refresh date
						updateAsOfDisplay(viewContainer);

						//Call the Generic MPagesView loading functions						
						viewObject.initializeView();
						viewObject.loadViewSettings();
						viewObject.preProcessing();
						viewObject.initializeComponents();
						viewObject.renderView();
						viewObject.postProcessing();
					}
					//Set the flag which indicates that this view has been previously rendered
					viewContainer.setPreviouslyActivatedInd(true);
				}
				else {
					viewBody = $("#" + viewId);
					//Show the view since it is already rendered
					$(viewBody).removeClass("hidden");

					//Update the As Of display with the last refresh date
					updateAsOfDisplay(viewContainer);

					viewObject = viewContainer.getViewObject();

					// skip user preference, page menu and resize when the view is a dummy view
					if(viewObject instanceof DummyMPage) {
						return;
					}

					//Update the preference Identifier so the correct preferences are saved for the correct tab
					MP_Core.AppUserPreferenceManager.UpdatePrefsIdentifier(viewId);
					//Set the preferences object of this view
					MP_Core.AppUserPreferenceManager.SetPreferences(JSON.stringify(viewObject.getUserPreferences()));

					//Reset the click event on the page menu
					$("#pageMenu" + viewId).click(function() {
						MP_MenuManager.showMenu("pageMenu" + viewId);
					});
					
					//Verify that the view is being shown with a valid context.
					if(viewObject.isContextValid()){
						//Call post processing for the page to handle any cleanup that needs to take place.
						viewObject.postProcessing();
						viewObject.applyOffsetPosition();
						
						//Call the resize functionality if there has been a resize event that occurred since the view was previously rendered
						if (viewContainer.resizeOnActivation()) {
							viewObject.resizeView();
							viewContainer.setResizeOnActivation(false);
						}
					}
				}
			}
			catch (err) {
				logger.logJSError(err, null, "mpage-viewpoint.js", "renderView");
				throw err;
			}
		},

		/**
		 * Retrieve patient demographics fields from the MP_GET_PATIENT_DEMO script response and renders the demo banner
		 * @param  {Object} scriptReply A response from the MP_GET_PATIENT_DEMO script
		 * @param  {Object} demoBanner An instance  of DemoBanner
		 * @param  {Object} demoBannerHtml the Jquery object for the demobanner DOM element
		 * @return {undefined} this function does not return a value
		 */
		processPatientDemoData: function(scriptReply, demoBanner, demoBannerHtml){
			var timer = null;
			var locDesc = "";
			var finNbr = "";
			var mrnNbr = "";
			var demoReply = scriptReply.getResponse();

			// immediately, display error messages for Location, MRN and FIN if the script call was unsuccessful
			if(scriptReply.getStatus() === "F" || !demoReply){
				locDesc = i18n.discernabu.ERROR_RETREIVING_DATA;
				finNbr = i18n.discernabu.ERROR_RETREIVING_DATA;
				mrnNbr = i18n.discernabu.ERROR_RETREIVING_DATA;

				//add the fields to the demoBanner
				demoBanner.addIdentifierField(i18n.MRN, [mrnNbr]);
				demoBanner.addIdentifierField(i18n.FIN, [finNbr]);
				demoBanner.setLocation(locDesc);

				//Update the DOM for demobanner after the fields are added
				demoBannerHtml.replaceWith(demoBanner.render());

				return;
			}
		    
			try {
				var locObj = null;
				var nurseObj = null;
				var roomObj = null;
				var bedObj = null;
				var enCodeArray = [];
				var aliasObj;
				var codeArray = MP_Util.LoadCodeListJSON(demoReply.CODES);

				//start timer for rendering the demoBanner
				timer = new RTMSTimer("ENG:MPG.DEMO_BANNER.O2 - render demoBanner");
				timer.start();

				var encntrInfo = demoReply.DEMOGRAPHICS.ENCOUNTER_INFO;
				var encntrInfoLength  = encntrInfo.length; 

				//retrieve location, MRN and FIN only if at least one encounter is found
				if(encntrInfoLength){
					//get values corresponding to the different codes for the encounter
					locObj = MP_Util.GetValueFromArray(encntrInfo[0].LOC_FACILITY_CD, codeArray);
					nurseObj = MP_Util.GetValueFromArray(encntrInfo[0].LOC_NURSE_UNIT_CD, codeArray);
					roomObj = MP_Util.GetValueFromArray(encntrInfo[0].LOC_ROOM_CD, codeArray);
					bedObj = MP_Util.GetValueFromArray(encntrInfo[0].LOC_BED_CD, codeArray);

					var encntrInfoAliasLength = encntrInfo[0].ALIAS.length;

					//check alias type code values for MRN and FIN NBR
					for (var i = 0;  i < encntrInfoAliasLength; i++) {
						enCodeArray[i] = MP_Util.GetValueFromArray(encntrInfo[0].ALIAS[i].ALIAS_TYPE_CD, codeArray);

						if (enCodeArray[i].meaning === "FIN NBR") {
							finNbr = encntrInfo[0].ALIAS[i].FORMATTED_ALIAS;
						}
						else if (enCodeArray[i].meaning === "MRN") {
							mrnNbr = encntrInfo[0].ALIAS[i].FORMATTED_ALIAS; 
						}
					}
				}

				// if no patient encounter was found or the encounter does not have mrn, search from patient alias data
				if (mrnNbr === "") {
					var aliasArray = demoReply.DEMOGRAPHICS.PATIENT_INFO.ALIAS;
					var aliasArrayLength = aliasArray.length;

					for (var l = 0; l < aliasArrayLength; l++) {
						aliasObj = MP_Util.GetValueFromArray(aliasArray[l].ALIAS_TYPE_CD, codeArray);

						if (aliasObj.meaning == "MRN") {
							mrnNbr = aliasArray[l].FORMATTED_ALIAS;
						}
					}
				}

				//give mrn and finNbr default value if no value was found in the script response
				mrnNbr = mrnNbr || "--";
				finNbr = finNbr || "--";

				var delimiter = "; ";

				//build the string value for the location field
				if (locObj && locObj.description){
	  				locDesc += (locObj.description)? locObj.description: "";
	  			}

	  			if(nurseObj && nurseObj.description){
	  				locDesc += (locDesc)? delimiter: "";
	  				locDesc += nurseObj.description;
	  			}

	  			if(roomObj && roomObj.description){
	  				locDesc += (locDesc)? delimiter: "";
	  				locDesc += roomObj.description;
	  			}

	  			if(bedObj && bedObj.description){
	  				locDesc += (locDesc)? delimiter: "";
	  				locDesc += bedObj.description;
	  			}

	  			//add the additional fields to the demoBanner
				demoBanner.addIdentifierField(i18n.MRN, [mrnNbr]);
				demoBanner.addIdentifierField(i18n.FIN, [finNbr]);
				//If empty, the demographics banner will not show a location
				demoBanner.setLocation(locDesc);

				//Update the DOM for demobanner after all fields are added
				demoBannerHtml.replaceWith(demoBanner.render());

				//stop timer
				if(timer) {
					timer.stop();
				}
			}
			catch(err) {
				logger.logJSError(err, null, "mpage-viewpoint.js", "processPatientDemoData");
				
				if(timer) {
					timer.Abort();
					timer = null;
				}
			}
	  	},

		/**
		 * Get patient demographics fields from the view point criterion object
		 * Also call MP_GET_PATIENT_DEMO script to get additional patient demographics data
		 * @return {Object} the demo banner Jquery object
		 */
		getDemoBanner: function() {
			var demographicsBanner = new MPageUI.DemoBanner();
			var demoBannerHtml = null;

			var patInfo = null;
			var nameFull = "";
			var sexObj = null;
			var sexDisp = "";
			var dateFormatter = null;
			var birthDtTm = null;
			var birthDate = "";

			var criterion = viewpointObject.getCriterionObject();

			//stop creating the demoBanner the patient id is not found
			if(!criterion.person_id){
				return null;
			}

			patInfo = criterion.getPatientInfo();
			nameFull = patInfo.getName();
			demographicsBanner.setName(nameFull);

			//the default value for gender is --
			sexObj = patInfo.getSex();
			sexDisp = (sexObj && sexObj.display)? sexObj.display : "--";
			demographicsBanner.setGender(sexDisp);

			birthDtTm  = patInfo.getDOB();
			if(birthDtTm){
				dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
				birthDate = dateFormatter.format(birthDtTm, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR);
			}

			//the default value for birthDate is --
			birthDate = birthDate || "--";
			demographicsBanner.setDOB(birthDate);

			//generate the html for the demoBanner
			demoBannerHtml = $(demographicsBanner.render());

			//call MP_GET_PATIENT_DEMO  to get any fields not found from  the criterion object
			var sendAr = ["^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0"];
			var demoRequest = new ScriptRequest();
			demoRequest.setProgramName("MP_GET_PATIENT_DEMO");
			demoRequest.setParameterArray(sendAr);
			demoRequest.setResponseHandler(function(reply){
				MP_Viewpoint.processPatientDemoData(reply, demographicsBanner, demoBannerHtml);
			});

			demoRequest.performRequest();

			return demoBannerHtml;
		},

		/**
		 * Renders the overall structure of the viewpoint, the tabs for each view, the drop down view selection menu and the page menu.
		 * @return {undefined} This function does not return a value
		 */
		renderViewpoint: function() {
			var defaultViewCatMean = null;
			var demoBanner = null;
			var demoBannerHeight = 0;
			var inPatientChartContext = CERN_Platform.inPatientChartContext();
			var resizeTimer = null;
			var thresholdPadding = 2;
			var viewpointSettings = null;
			var vwpContainer = null;
			var viewContainer = null;
			var viewContainerArr = null;
			var vwpControls = null;
			var viewCount = 0;
			var vwpView = null;
			var x = 0;
			var tabControlContainer = null;
			var defaultViewId = null;
			var tabControlObject = null;
		

			function resizeContainers() {
				if (resizeTimer) {
					clearTimeout(resizeTimer);
				}
				resizeTimer = setTimeout(function() {
					//Check to ensure a resize is actually necessary.  If not then just return.
					if (!validateWindowResize()) {
						return;
					}

					//Close all open menus
					MP_MenuManager.closeMenuStack();
					vwpView.height($(window).height() - demoBannerHeight - $("#vwpControls").outerHeight(true) - thresholdPadding);

					try {
						//Call the resize functionality of the currently active view
						viewContainer = MP_Viewpoint.getViewContainerById(viewpointObject.getCurrentViewId());

						//Mark all other previously opened views need to fire the resize upon activation
						viewContainerArr = viewpointObject.getViewContainerArray();
						for (x = viewContainerArr.length; x--; ) {
							//If the view associated with this ViewContainer has been previously activated we need to mark it for resize when activated again
							if (viewContainerArr[x].previouslyActivated() && viewContainer !== viewContainerArr[x]) {
								viewContainerArr[x].setResizeOnActivation(true);
							}
						}

						//Set a timeout and then call the resize functionality
						setTimeout(function() {
							viewContainer.getViewObject()
								.resizeView();
							viewContainer.setResizeOnActivation(false);
							applyTabControlWidth();
							MP_Viewpoint.getTabControlObject().resize(); 
						}, 0);
					}
					catch (err) {
						logger.logError(err, null, "mpage-viewpoint.js", "resizeContainers");
					}
				}, 100);
			}

			//Create the overall container which will span 100% width and 100% height and set to overflow: none
			vwpContainer = $("<div></div>").addClass("vwp-container");

			//Append the content to the body of the document
			$(document.body).append(vwpContainer);

			//This fixes a problem with double scrollbars showing up on browser resizes
			$(document.body).css("overflow-y", "hidden");

			//create demographics banner if outside of PowerChart and showing a patient chart context
			if(!CERN_Platform.inMillenniumContext()  && inPatientChartContext) { 
				demoBanner = MP_Viewpoint.getDemoBanner();
				vwpContainer.append(demoBanner);
				//cache the height of the demo banner for later use when resizing a view
				demoBannerHeight = demoBanner ? demoBanner.outerHeight(true) : 0;
			}

			//Create the viewpoint controls container and append it to the viewpoint container
			vwpControls = $("<div></div>")
				.addClass("vwp-controls")
				.attr("id", "vwpControls");
			vwpContainer.append(vwpControls);
			//create a container for tab controller
			tabControlContainer = $("<div></div>")
				.addClass("vwp-tab-container")
				.attr("id", "vwpTabControls");
			vwpControls.append(tabControlContainer);
			
			//Create all of the tabs that will be shown face up
			viewContainerArr = viewpointObject.getViewContainerArray();
			viewCount = viewContainerArr.length;
			if (!viewCount) {
				/*eslint-disable no-alert*/
				alert(vwpi18n.NO_VIEWS_DEFINED);
				/*eslint-enable no-alert*/
				return;
			}
			//gets the default view id
			defaultViewId = findDefaultViewId();
			//the ID of the view that will actually be rendered during the initial page load
			viewpointObject.setInitialViewId(defaultViewId);
			viewpointSettings = viewpointObject.getSettingsObj();
			//Get the default view that will be rendered. It's determined by mp_unified_driver.
			//The actual view that will be rendered may change due to session cache or the view not being displayable
			defaultViewCatMean = viewpointSettings.ACTIVE_VIEW_CAT_MEAN;
			//When the viewpoint is going to load a different view than originally planned in mp_unified_driver
			if (defaultViewId !== defaultViewCatMean) {
				logger.logMessage("Viewpoint is going to load a different view than originally planned in mp_unified_driver: load " + defaultViewId + " intead of " + defaultViewCatMean);
				//abort the original USR timer that measure the entire page load
				var originalLoadTimer = new RTMSTimer("USR:MPG.MP_UNIFIED_DRIVER load entire page", defaultViewCatMean);
				originalLoadTimer.fail();

				//start the proper USR timer to measure the entire page load
				//The new timer is going to lose the portion of time spent on loading the static content and initializing the viewpoint
				var updatedLoadTimer = new RTMSTimer("USR:MPG.MP_UNIFIED_DRIVER load entire page", defaultViewId);
				updatedLoadTimer.start();
			}
			
			//create Tab Control and append it to tab control container
			tabControlContainer.append(createTabControl());
			for (x = 0; x < viewCount; x++) {
				viewContainer = viewContainerArr[x];
				if(viewContainer.getShownInd()){
					addTab(viewContainer, false);
				}	
			}
			//get the tabControl object 
			tabControlObject = MP_Viewpoint.getTabControlObject();
			//check if there are no tabs to display, then add the default view to display.
			if (tabControlObject.getTabs().length === 0) {
				viewContainer = MP_Viewpoint.getViewContainerById(defaultViewId);
				addTab(viewContainer, true);
			}
			//Add the Page Menu
			vwpControls.append(createPageMenu());

			//Add the viewpoint Utilities bar and initialize all of the utilities
			createUtilitesBar();

			//Add the Chart Search container if needed for this viewpoint
			if (viewpointObject.getChartSearchInd() && inPatientChartContext) {
				vwpControls.append(createChartSearchUtility());
			}
			
			//Create the view container and append it to the viewpoint container
			vwpView = $("<div></div>")
				.addClass("vwp-views")
				.attr("id", "vwpBody");

			vwpContainer.append(vwpView);
			vwpView.height($(window).height() - 
				demoBannerHeight -
				$("#vwpControls").outerHeight(true) - 
				thresholdPadding);

			//Add the resize event listener
			$(window).resize(resizeContainers);

			//calculate tab control width and call the finalize method the finalize the tab control api
			applyTabControlWidth();
			tabControlObject.finalize();
		},
		/**
		 * This function collects the settings from the viewpoint such as the tab order and the menu item selected and stores that information to the database.
		 * @param {boolean} asyncInd An indicator which determines if the settings should be saved asynchronously or not
		 * @return {undefined} This function does not return a value
		 */
		saveViewpointSettings: function(asyncInd) {
			/*eslint-disable mp-camelcase*/
			var count = 0;
			var currentSettings = viewpointObject.getSettingsObj();
			var saveAsync = true;
			var settingsObj = {};
			var viewObj = null;
			var tab = null;
			var tabArr = [];
			var updateSequences = CERN_Platform.inMillenniumContext() || CERN_BrowserDevInd;
			var viewContainer = null;
			var viewContainerArr = null;
			var viewSettingsArr = null;
			var tabControlObject = MP_Viewpoint.getTabControlObject();
			var x = 0;

			//Create the settings object that will be stored as the users preference string
			settingsObj = {
				vwp_user_prefs: {
					cnt: 0,
					views: [],
					user_prefs: currentSettings.USER_PREFS || null
				}
			};
			viewSettingsArr = settingsObj.vwp_user_prefs.views;


			//Grab the tabs array from tab control
			if(tabControlObject){
				tabArr = tabControlObject.getTabs();
			}
			count = tabArr.length;
			for (x = 0; x < count; x++) {
				tab = tabArr[x];
				viewContainer = MP_Viewpoint.getViewContainerById(tab.id);
				
				//Only if we are in Millennium or in Browser developing do we need to update the tab sequences
				if (updateSequences) {
					viewContainer.setSequence(x);
				}
			}

			//Loop through each of the viewContainers and update its settings
			viewContainerArr = viewpointObject.getViewContainerArray();
			count = viewContainerArr.length;
			for (x = 0; x < count; x++) {
				viewContainer = viewContainerArr[x];
				var viewId = viewContainer.getId();				
				if (!viewContainer.m_dynamicViewInd) {
					//Create the settings json for the view Container
					viewObj = {
						view_sequence: viewContainer.getSequence(),
						view_cat_mean: viewContainer.getCategoryMean(),
						view_cat_id_string: viewContainer.getCategoryId() + ".0",
						view_cat_id: 1234.5678, //This value will be overwritten on the backend when parsed
						user_defined_ind: viewContainer.getUserDefinedInd() ? 1 : 0,
						shown_ind: viewContainer.getShownInd() ? 1 : 0,
						menu_item: viewContainer.getMenuItemInd() ? 1 : 0
					};
					viewSettingsArr.push(viewObj);
				}
			}

			settingsObj.vwp_user_prefs.cnt = viewSettingsArr.length;

			//Determine if the settings should be saved async or not
			if (typeof asyncInd === "boolean") {
				saveAsync = asyncInd;
			}
			writeViewpointPreferences(settingsObj, saveAsync);
			/*eslint-enable mp-camelcase*/
		},

		/**
		* This function creates the container for view selection page, creates and initializes ViewpointViewSelection object
		* And add view selection container to the view point
		* @returns {undefined} does not return anything
		*/
		createViewSelectionContainer: function() {
			var viewSelectionContainer = null;
			var viewSelectionObject = null;
			var selectView = "SELECT_VIEW";
			viewSelectionContainer = MP_Viewpoint.getViewContainerById(selectView);

			if (!viewSelectionContainer) {
				viewSelectionContainer = new ViewContainer(selectView);
				viewSelectionContainer.setViewName(vwpi18n.NEW_VIEW)
					.setCategoryId(selectView)
					.setCategoryMean(selectView)
					.setUserDefinedInd(false)
					.setShownInd(true)
					.setMenuItemInd(false)
					.setViewType(selectView)
					.setDynamicViewInd(true);

				// Creates the 	ViewpointViewSelection object and initialize it with the view container Array
				viewSelectionObject = new ViewpointViewSelection(viewSelectionContainer.getCategoryMean());
				viewSelectionObject.initializeView(viewpointObject.getViewContainerArray());
				viewSelectionContainer.setViewObject(viewSelectionObject);
				viewpointObject.addViewContainerObject(viewSelectionContainer);
			}
		},

		/**
		* Function to return the viewpoint object
		* @returns {Object} viewpointObject - view point object.
		*/
		getViewpointObject: function() {
			return viewpointObject;
		},
		
		/**
		* Function to get tab control object
		* @returns {Object} m_tabControllerObj - tab control object.
		*/
		getTabControlObject: function() {
			return viewpointObject.m_tabControllerObj;
		},
		
		/**
		* This function is to add the view container tab, checks if the container has tab already if not it creates the tab
		* And adds the tab in the end of existing view tabs list.
 		* @param {string} viewId - viewId of the container
 		* @returns {undefined} does not return anything
		*/
		addViewContainerTab: function(viewId) {
			var viewContainer = null;
			var tabControl = MP_Viewpoint.getTabControlObject();
			viewContainer = MP_Viewpoint.getViewContainerById(viewId);
			var totalViews = viewpointObject.getViewContainerArray().length-1;
			if (!viewContainer) {
				return;
			}
			if (tabControl && tabControl.tabExists(viewId)) {
				//if tab already exists, select the tab to activate it
				tabControl.selectTab(viewId);
			} else {
				viewContainer.setShownInd(true);
				//adds the tab at the end, activates new tab and resizes the tab control.
				addTab(viewContainer, true);
				//saves the view point setting after adding the new tab.
				MP_Viewpoint.saveViewpointSettings();
				//capture capability timer 
				var facedUpViewsInfo = tabControl.getTabs().length + " out of " + totalViews;
				var capTimer = new CapabilityTimer("CAP:MPG Add View To Viewpoint", viewpointObject.getName());
				capTimer.addMetaData("view.name", viewContainer.m_viewName + "(" + viewContainer.m_categoryMean + ")");
				capTimer.addMetaData("viewpoint.faceUpViews.count", facedUpViewsInfo);
				capTimer.capture();
			}
		},
		
		/**
		* Function to add dynamic tab
		* @param {ViewContainer} viewContainer The ViewContainer object which contains all of the information needed to create the tab container HTML
		* @param {boolean} addNextToCurrentTab - to decide the dynamic tab should be added next to current tab or not(if not it adds at the end) 
		* @returns {undefined} does not return anything
		*/
		addDynamicTab: function(viewContainer, addNextToCurrentTab) {
			//add view container to viewpoint if it does not exists
			var viewContainerObj = MP_Viewpoint.getViewContainerById(viewContainer.getCategoryMean());
			if (!viewContainerObj) {
				viewpointObject.addViewContainerObject(viewContainer);
			}
			//set the view as dynamic view.
			viewContainer.setDynamicViewInd(true);
			//inserts the tab next to the current tab
			if (addNextToCurrentTab) {
				insertTab(viewContainer);
			} else {
				//adds the tab at the end.
				addTab(viewContainer, true);
			}
		}

	};
}();
MPage_Core_User_Prefs = {};
/**
 * This singleton encapsulates all utility methods for storing and retrieving session specific and persistent data items.
 * @namespace UserPrefManager
 * @static
 * @global
 */
MPage_Core_User_Prefs.UserPrefManager = function() {
    var cache = null;
    var generatePrefKey = function(key){
        return "MPAGESPREF_" + key;
    };
    return {
        /**
         * Method for retrieving both session specific and persistent stored items by key
         * @param {String} key identifier for the stored item
         * @param {Boolean} dataIsPersisted (optional) indicator set to true if the stored item is persisted
         * @param {integer} userId identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be retrieved asynchronously
         * @param {function} callback (optional) indicator set to true if preferences should be retrieved asynchronously
         *
         * @return {String} String containing the value realted to the key
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name GetPreference
         */
        GetPreference: function(key, dataIsPersisted, userId, async, callback) {
            if (dataIsPersisted) {
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_GET_USER_PREFS");
                prefRequest.setParameterArray(["^mine^", userId + ".0", "^" + generatePrefKey(key) + "^"]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    var status = scriptReply.getStatus();
                    var prefsResponse = scriptReply.getResponse();
                    if(status === "Z" || status === "S"){
                        if(callback && typeof callback === "function"){
                            callback(prefsResponse.PREF_STRING);
                        }
                        else{
                            return prefsResponse.PREF_STRING;
                        }
                    }
                    else {
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if(this.cache.hasOwnProperty(key)){
                if(callback && typeof callback === "function"){
                    callback(this.cache[key]);
                }
            }
        },
        /**
         * Method for saving both session specific and persistent stored items by key
         * @param {String} key  identifier for the stored item
         * @param {String} value data for the stored item
         * @param {Boolean} persistData (optional) indicator set to true if the stored item is persisted
         * @param {integer} userid identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be saved asynchronously
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "_FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name SavePreference
         */
        SavePreference: function(key, value, persistData, userid, async) {
            if (persistData) {
                //Ajax Request to store
                //Create the script request and perform it
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
                prefRequest.setParameterArray(["^mine^", userid + ".0", "^" + generatePrefKey(key) + "^", "@" + value.toString().length + ":" + value + "@"]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    if(scriptReply.getStatus() === "F"){
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if ( typeof key !== "undefined" && typeof value !== "undefined"){
                    this.cache[prefKey] = value;
            }
        },
         /**
         * Method for clearing both session specific and persistent stored items by key
         * @param {String} key  identifier for the stored item
         * @param {Boolean} dataIsPersisted (optional) indicator set to true if the stored item is persisted
         * @param {integer} userid identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be saved asynchronously
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "_FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name ClearPreference
         */
        ClearPreference: function(key, dataIsPersisted, userid, async) {
            if (dataIsPersisted) {
                var criterion = CERN_Platform.getCriterion();
                //Create the script request and perform it
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
                prefRequest.setParameterArray(["^mine^", criterion.provider_id + ".0", "^" + generatePrefKey(key) + "^", "^^"]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    if(scriptReply.getStatus() === "F"){
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if(this.cache.hasOwnProperty(prefKey)){
                delete this.cache[prefKey];
            }
        }
    };
}();
/* globals MenuSeparator*/

/**
 * The RenderStrategy base object
 * This object replaces the old CreateCompDiv function. This object facilitates the
 * creation of component html structure. This base RenderStrategy performs all
 * common html generation between summaries.
 * @constructor
 * @author Will Reynolds
 */
function RenderStrategy() {
	this.component = null;
	this.componentId = null;
	this.componentNamespace = null;
	this.componentStyle = null;
	this.i18nCore = i18n.discernabu;
}

RenderStrategy.prototype.getLookbackMenuId = function() {
	return 'lookback-menu' + this.componentId;
};

RenderStrategy.prototype.getFilterMenuId = function() {
	return 'filter-menu' + this.componentId;
};

/**
 * This function gets the component we are rendering
 * @returns {MPageComponent} the component we are rendering
 */
RenderStrategy.prototype.getComponentToRender = function() {
	return this.component;
};

/**
 * This function sets the component to render
 * @param {MPageComponent} component The component we are going to render
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentToRender = function(component) {
	if(component && MPageComponent.prototype.isPrototypeOf(component)) {
		this.component = component;
		this.setComponentStyle(component.getStyles());
		this.setComponentNamespace(component.getStyles().getNameSpace());
		this.setComponentId(component.getStyles().getId());
	}
};

/**
 * Gets the id of the component we are rendering
 * @returns {String} the id of the component we are rendering
 */
RenderStrategy.prototype.getComponentId = function() {
	return this.componentId;
};

/**
 * Sets the id of the component we are rendering
 * @param {String} id The id of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentId = function(id) {
	if(id && typeof id === 'string') {
		this.componentId = id;
	}
};

/**
 * Gets the style of the component we are rendering
 * @returns {ComponentStyle} the style of the component we are rendering
 */
RenderStrategy.prototype.getComponentStyle = function() {
	return this.componentStyle;
};

/**
 * Sets the style of the component we are rendering
 * @param {ComponentStyle} style The style of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentStyle = function(style) {
	if(style && ComponentStyle.prototype.isPrototypeOf(style)) {
		this.componentStyle = style;
	}
};

/**
 * Gets the namespace of the component we are rendering
 * @returns {String} the namespace of the component we are rendering
 */
RenderStrategy.prototype.getComponentNamespace = function() {
	return this.componentNamespace;
};

/**
 * Sets the namespace of the component we are rendering
 * @param {String} namespace The namespace of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentNamespace = function(namespace) {
	if(namespace && typeof namespace === 'string') {
		this.componentNamespace = namespace;
	}
};

/**
 * This function handles creation of the main component container
 * @param {MPageComponent} component the component for which we are creating the container
 * @returns {Object} The DOM element for the component div container (contains all component html)
 */
RenderStrategy.prototype.createComponentContainer = function() {
	var container = $('<div></div>').attr('id', this.componentId).addClass(this.componentStyle.getClassName());
	//Handle if the component is closed
	if(!this.component.isExpanded() && !this.component.isAlwaysExpanded()) {
		$(container).addClass('closed');
	}
	return container[ 0 ];
};

/**
 * Handles creation of the + add control in the component header
 * @param {MPageComponent} component the component for which we are creating the + add control
 * @returns {Object} creates the plus-add control for the component
 */
RenderStrategy.prototype.createPlusAddControl = function() {

	if(!this.component.isPlusAddEnabled()) {
		return null;
	}
	var component = this.component;

	//Create the plus add html structure
	var plusAddControl = $('<a></a>').attr({ id: this.componentNamespace + 'Add', href: '#' }).addClass('add-plus');
	var plusAddIcon = $('<span></span>').addClass('add-icon').html('&nbsp;');
	var plusAddText = $('<span></span>').addClass('add-text').html(this.i18nCore.ADD);

	//Append the structure
	plusAddControl.append(plusAddIcon);
	plusAddControl.append(plusAddText);

	//Assign click events to the plus add
	/* WARNING: This logic does not make sense and is a defect.  The existing implementation uses an iViewAdd
	 * false value to indicate that the IView functions should be utilized.
	 */
	if(this.component.isIViewAdd() === false) {
		plusAddControl.click(function() {
			component.openIView();
		});
	}
	else {
		plusAddControl.click(function() {
			component.openTab();
		});
	}
	return plusAddControl[ 0 ];
};

/**
 * Creates the component loading section of the component (added in the header)
 * @param {MPageComponent} component the component for which we are creating the loading section
 * @returns {Object} The DOM element for the component loading section
 */
RenderStrategy.prototype.createComponentSubTitleSection = function() {
	return $('<span></span>').addClass(this.componentStyle.getTotal()).html(this.i18nCore.LOADING_DATA + '...')[ 0 ];
};

/**
 * Creates the component filter applied section
 * @returns {Object} The DOM element for the component filter applied section
 */
RenderStrategy.prototype.createFilterAppliedSection = function() {
	var uniqueComponentId = this.getComponentId();
	var rComponent = this.component;
	var facilityDefinedDisplay = this.i18nCore.FACILITY_DEFINED_VIEW;
	var filterAppliedText = '';
	var filterHoverTitle = '';
	if(rComponent.getGrouperFilterCriteria() && rComponent.getGrouperFilterLabel() !== facilityDefinedDisplay) {
		filterAppliedText = this.i18nCore.FILTER_APPLIED;
		filterHoverTitle = rComponent.getGrouperFilterLabel().toString();
	}
	if(rComponent.getGrouperFilterCatalogCodes() && rComponent.getGrouperFilterCatLabel() !== facilityDefinedDisplay) {
		filterAppliedText = this.i18nCore.FILTER_APPLIED;
		filterHoverTitle = rComponent.getGrouperFilterCatLabel().toString();
	}
	return $('<span></span>').addClass('filter-applied-message').attr({
		'id': 'filterAppliedMessage' + uniqueComponentId,
		'title': filterHoverTitle
	}).html(filterAppliedText)[ 0 ];
};

/**
 * Creates the component title section for a component
 * @param {MPageComponent} component the component for which we are creating the title (either just the label or an
 *     anchor)
 * @returns {Object} The DOM element for the component title
 */
RenderStrategy.prototype.createComponentTitle = function() {
	var componentTitleContainer = $('<span></span>').addClass(this.componentStyle.getTitle());

	//Create the component anchor
	this.addComponentSection(componentTitleContainer, this.createComponentAnchor());

	//Create the component loading section
	this.addComponentSection(componentTitleContainer, this.createComponentSubTitleSection());

	//Try adding the plus add control
	this.addComponentSection(componentTitleContainer, this.createPlusAddControl());

	//Try adding the header dropdown menu
	this.addComponentSection(componentTitleContainer, this.createHeaderDropdown());

	return componentTitleContainer[ 0 ];
};

/**
 * Creates the basic component header
 * @param {MPageComponent} component the component for which we are creating the header
 * @returns {Object} A DOM element for the component header
 */
RenderStrategy.prototype.createComponentHeader = function() {
	//Create the header shell
	var header = $('<h2></h2>').addClass(this.componentStyle.getHeaderClass());

	//Add the title to the header
	this.addComponentSection(header, this.createComponentTitle());

	return header[ 0 ];
};

/**
 * Creates the component lookback menu. They are vastly different between
 * summary and workflow views and are located in different areas, so we just
 * return nothing in the base class
 * @returns {null} This function returns null
 */
RenderStrategy.prototype.createComponentLookback = function() {
	return null;
};

/**
 * Creates the component options control found in the header.
 * the component
 * @param {MPageComponent} component the component for which we are creating menu option control
 * @returns {Object} the DOM element for the component options menu
 */
RenderStrategy.prototype.createComponentOptionsMenu = function() {
	return $('<span></span>').addClass('opts-menu menu-hide').attr('id', 'mainCompMenu' + this.componentId).html('&nbsp')[ 0 ];
};

/**
 * Creates the header drop down controls
 * @param {Object} appendTo the DOM element we are appending the menu to (should be header)
 * @param {MPageComponent} component the component we are using to build the menu
 * @returns {Array<Object>} the DOM elements for the component header drop-down menu
 */
RenderStrategy.prototype.createHeaderDropdown = function() {
	var component = this.component;
	var headerMenuItem = null;
	var iViewItems = this.component.getIViewMenuItems();
	var menu = null;
	var menuItems = this.component.getMenuItems();
	var uniqueComponentId = this.getComponentId();
	var x = 0;
	var xl = 0;
	var item;

	// Disable the drop down arrow for the time being, if the MPage opened outside of PowerChart.
	if(!CERN_Platform.inMillenniumContext() || ((!menuItems || !menuItems.length) && (!iViewItems || !iViewItems.length))) {
		return null;
	}

	//Create the header menu
	var headerMenu = new Menu('headerMenu' + uniqueComponentId);
	headerMenu.setTypeClass('header-dropdown-menu');
	headerMenu.setLabel('Header Menu');
	headerMenu.setAnchorElementId('headerMenu' + uniqueComponentId);
	headerMenu.setAnchorConnectionCorner([ 'bottom', 'left' ]);
	headerMenu.setContentConnectionCorner([ 'top', 'left' ]);
	headerMenu.setIsRootMenu(true);

	//Helper function to launch menu and prevent closure
	function launchMenuSelection(itemId) {
		return function() {
			component.openDropDown(itemId);
		};
	}

	//Helper function to launch an IView Menu selection and prevent closure
	function launchIViewMenuSelection(sBandName, sSectionName, sItemName) {
		return function() {
			var criterion = component.getCriterion();
			var launchIViewApp = CERN_Platform.getDiscernObject('TASKDOC');
			if(launchIViewApp) {
				launchIViewApp.LaunchIView(sBandName, sSectionName, sItemName, criterion.person_id, criterion.encntr_id); //eslint-disable-line new-cap
			}
		};
	}

	menu = $('<a></a>').attr('id', 'headerMenu' + uniqueComponentId).addClass('drop-Down');
	var menuDropDownIcon = $('<span></span>').addClass('drop-down-ctrl');
	menu.append(menuDropDownIcon);
	$(menuDropDownIcon).click(function() {
		if(!headerMenu.isActive()) {
			MP_MenuManager.showMenu('headerMenu' + uniqueComponentId);
		}
		else {
			MP_MenuManager.closeMenuStack(true);
		}
	});

	//Create the regular menu items
	if(menuItems && menuItems.length) {
		for(x = 0, xl = menuItems.length; x < xl; x++) {
			item = menuItems[ x ];

			//Create a menu item and add it to the header menu
			headerMenuItem = new MenuSelection('headerMenuItem' + uniqueComponentId + '-' + x);
			headerMenuItem.setCloseOnClick(true);
			headerMenuItem.setLabel(item.getDescription());
			headerMenuItem.setClickFunction(launchMenuSelection(item.getId()));
			headerMenu.addMenuItem(headerMenuItem);
		}
	}
	//Create the IView Menu Items
	if(iViewItems && iViewItems.length) {
		if(menuItems && menuItems.length) {
			headerMenu.addMenuItem(new MenuSeparator('headerMenuSeparator' + uniqueComponentId));
		}
		var sDisplayName;
		var sBandName;
		var sSectionName;
		var sItemName;
		//Iterate over each Band and associate IView Sections and Items
		for(x = 0, xl = iViewItems.length; x < xl; x++) {
			item = iViewItems[ x ];
			var itemValTypeFlag = item.getValTypeFlag();
			//If this IView item is a Band
			if(itemValTypeFlag === 1) {
				sDisplayName = item.getDescription();
				sBandName = sDisplayName.toLowerCase();
				sDisplayName = sDisplayName.replace(/'/g, '');
				sSectionName = '';
				sItemName = '';
				//Iterate back over the items, finding Sections and Items belonging to the Band
				for(var y = 0, yl = iViewItems.length; y < yl; y++) {
					var secItem = iViewItems[ y ];
					//If the values returned by getValueSequence match, the secItem belongs to the Band
					//If valTypeFlag = 2, the secItem is an IView Section. If valTypeFlag = 3, the secItem is an IView
					// Item
					if(secItem.getValSequence() === item.getValSequence()) {
						if(secItem.getValTypeFlag() === 2) {
							sSectionName = secItem.getDescription();
						}
						else if(secItem.getValTypeFlag() === 3) {
							sItemName = secItem.getDescription();
						}
					}
				}

				headerMenuItem = new MenuSelection('iViewHeaderMenuItem' + uniqueComponentId + '-' + x);
				headerMenuItem.setCloseOnClick(true);
				headerMenuItem.setLabel(sDisplayName);
				headerMenuItem.setClickFunction(launchIViewMenuSelection(sBandName, sSectionName, sItemName));
				headerMenu.addMenuItem(headerMenuItem);
			}
		}
	}

	MP_MenuManager.updateMenuObject(headerMenu);

	return menu;
};

/**
 * Creates the component anchor
 * @param {MPageComponent} component the component we are using to build an anchor
 * @returns {Object} the DOM element for the component title text: either an anchor or just plain label
 */
RenderStrategy.prototype.createComponentAnchor = function() {
	var tabLink = this.component.getLink();
	var componentTitle = $('<span class=\'comp-title\'></span>');
	if(!tabLink || !CERN_Platform.inMillenniumContext()) {
		componentTitle.html(this.component.getLabel());
		return componentTitle;
	}
	else {
		var linkTitle = this.i18nCore.GO_TO_TAB.replace('{0}', tabLink);
		linkTitle = linkTitle.replace(/'/g, '&#39');
		var sAnchor = $('<a id=' + this.componentStyle.getLink() + ' title=\'' + linkTitle.replace(/'/g, '&#96') + '\' href=\'#\'>' + this.component.getLabel() + '</a>');
		sAnchor.click(function() {
			//Calls the onTitleClick function which specifies the tab to navigate to on click.
			//The header link can now be overwritten at the component level with component.setLink.
			this.component.onTitleClick();
		}.bind(this));
		componentTitle.html(sAnchor);
		return componentTitle;
	}
};

/**
 * Creates the component body (or content) section
 * @param {MPageComponent} component the component for which we are building the body
 * @returns {Object} the DOM element for the component content section (body)
 */
RenderStrategy.prototype.createComponentBody = function() {
	var sectionContent = $('<div></div>').attr('id', this.componentStyle.getContentId()).addClass(this.componentStyle.getContentClass());
	return sectionContent[ 0 ];
};

/**
 * Creates the component DIV structure. This used to be done via CreateCompDiv
 * @param {MPageComponent} component the component for which we are creating the DIV
 * @returns {Object} the entire component shell, formerly built by CreateCompDiv
 */
RenderStrategy.prototype.createComponentShell = function() {
	//Store the component that we're working on, so we don't have to keep passing it?
	//this.setComponent(component);
	//Attempt to create and add all of the component sections
	try {
		if(!this.component || !MPageComponent.prototype.isPrototypeOf(this.component)) {
			throw new Error('Passed something other than MPageComponent to createComponentShell');
		}

		//Create the base component container
		var container = this.createComponentContainer();
		//Add component header
		this.addComponentSection(container, this.createComponentHeader());
		//Add the component-sub header (if there is one)
		this.addComponentSection(container, this.createComponentSubHeader());
		//Add the component accordion (if there is one)
		this.addComponentSection(container, this.createComponentAccordion());
		//Add component body
		this.addComponentSection(container, this.createComponentBody());
		//Add component footer
		this.addComponentSection(container, this.createComponentFooter());
		//Return the generated component container
		return container;
	}
	catch(err) {
		logger.logJSError(err, null, 'render_strategy.js', 'createComponentShell');
		return null;
	}
};

RenderStrategy.prototype.createComponentSubHeader = function() {
	return null;
};

/**
 * Utility function to help append component sections. componentSection can either be an array of
 * DOM elements, or just a single item
 * @param {Object} container the element we are appending componentSection to
 * @param {Object} componentSection the content we are adding to the container element
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.addComponentSection = function(container, componentSection) {
	var section = $(componentSection);
	if(container && $(container).length && section && section.length) {
		section.each(function(index, element) {
			$(element).appendTo(container);
		});
	}
};

/**
 * This function creates a component filter (found in the accordion)
 * @returns {Object} An HTMl DOM element for the component filter
 */
RenderStrategy.prototype.createComponentFilter = function() {
	var rComponent = this.getComponentToRender();
	var uniqueComponentId = this.getComponentId();
	var self = this;
	var namespace = this.componentNamespace;
	var facilityDefinedDisplay = this.i18nCore.FACILITY_DEFINED_VIEW;
	var selectedFilterDisplay = facilityDefinedDisplay;
	var esIndex;

	function createFilterMenuItem(eventSetIndex, label) {
		var menuItem = new MenuSelection('filterMenuItem' + uniqueComponentId + '-' + eventSetIndex);
		menuItem.setLabel(label);
		menuItem.setCloseOnClick(true);
		menuItem.setClickFunction(handleFilterClick(menuItem, eventSetIndex, label));
		if(label === selectedFilterDisplay) {
			menuItem.setIsSelected(true);
		}
		return menuItem;
	}

	function updateFilterAppliedSection(filterHoverTitle) {
		var filterAppliedSection = $('#filterAppliedMessage' + uniqueComponentId);
		filterAppliedSection.attr('title', filterHoverTitle);
		filterAppliedSection.html((filterHoverTitle === facilityDefinedDisplay) ? '' : self.i18nCore.FILTER_APPLIED);
	}

	function handleFilterClick(selectedMenuItem, eventSetIndex, label) {
		return function() {
			if(selectedMenuItem.isSelected()) {
				return;
			}
			var codeList = null;
			var catCodeList = null;
			var eventSetList = null;

			var menuItems = filterMenu.getMenuItemArray();
			for(var i = 0; i < menuItems.length; i++) {
				menuItems[ i ].setIsSelected(false);
			}
			selectedMenuItem.setIsSelected(true);


			//Replace the text of the menu to reflect the selected filter
			$('#selectedFilter' + uniqueComponentId).html(label);
			updateFilterAppliedSection(label);

			//Handle the grouper filter/category depending on the namespace
			if(namespace === 'ohx' || namespace === 'ohx2') {
				catCodeList = rComponent.getGrouperCatalogCodes(eventSetIndex);
				rComponent.setGrouperFilterCatLabel(label);
				rComponent.setGrouperFilterCatalogCodes(catCodeList);
				codeList = catCodeList;
			}
			else {
				eventSetList = rComponent.getGrouperCriteria(eventSetIndex);
				rComponent.setGrouperFilterLabel(label);
				rComponent.setGrouperFilterCriteria(eventSetList);
				codeList = eventSetList;
			}
			//If this is the facility defined display, reset both to null and handle component refresh, otherwise call
			// the filter refresh
			if(label === facilityDefinedDisplay) {
				rComponent.setGrouperFilterCriteria(null);
				rComponent.setGrouperFilterCatalogCodes(null);
				//Tell the component to fetch its data again
				rComponent.startComponentDataRetrieval();
			}
			else {
				rComponent.FilterRefresh(label, codeList); //eslint-disable-line new-cap
			}
		};
	}

	rComponent.sortGrouperArrayByLabel();

	if(rComponent.getGrouperFilterCriteria()) {
		selectedFilterDisplay = rComponent.getGrouperFilterLabel();
	}
	if(rComponent.getGrouperFilterCatalogCodes()) {
		selectedFilterDisplay = rComponent.getGrouperFilterCatLabel();
	}

	//Create the drop-down for component filter
	var filterDropDownMenu = $('<div></div>').addClass('acc-mnu').attr('id', 'filterDropDownMenu' + uniqueComponentId);

	var filterLabel = $('<span></span>').addClass('filter-label').html(this.i18nCore.FILTER_LABEL);
	var selectedFilterText = $('<span></span>').addClass('selected-filter').attr('id', 'selectedFilter' + uniqueComponentId).html(selectedFilterDisplay);
	var filterDropDownArrow = $('<div></div>').addClass('filter-arrow').attr('id', 'filterMenu' + uniqueComponentId);


	//Append the dom elements to create the menu structure
	filterDropDownMenu.append(filterLabel);
	filterDropDownMenu.append(selectedFilterText);
	filterDropDownMenu.append(filterDropDownArrow);

	var filterMenu = new Menu('filterMenu' + uniqueComponentId);
	filterMenu.setTypeClass('filter-menu');
	filterMenu.setAnchorElementId('filterMenu' + uniqueComponentId);
	filterMenu.setAnchorConnectionCorner([ 'bottom', 'left' ]);
	filterMenu.setContentConnectionCorner([ 'top', 'left' ]);
	filterMenu.setIsRootMenu(true);

	//Add the facility defined display item into the filter menu
	filterMenu.addMenuItem(createFilterMenuItem('', facilityDefinedDisplay));

	//Append the additional filters to the menu content box
	var groupLength = rComponent.m_grouper_arr.length;
	for(var z = 0, c = 0; c < groupLength && z < 10; z++) {
		if(rComponent.getGrouperLabel(z)) {
			c++;
			esIndex = z;
			filterMenu.addMenuItem(createFilterMenuItem(esIndex, rComponent.getGrouperLabel(z)));
		}
		if(rComponent.getGrouperCatLabel(z)) {
			c++;
			esIndex = z;
			filterMenu.addMenuItem(createFilterMenuItem(esIndex, rComponent.getGrouperCatLabel(z)));
		}
	}
	//Handle clicking the drop-down arrow to toggle the menu content-box
	filterDropDownArrow.click(function() {
		if(!filterMenu.isActive()) {
			MP_MenuManager.showMenu('filterMenu' + uniqueComponentId);
		}
		else {
			MP_MenuManager.closeMenuStack(true);
		}
	});
	MP_MenuManager.updateMenuObject(filterMenu);
	return filterDropDownMenu;
};

/**
 * This function creates the component accordion and renders any necessary
 * elements within.
 * @returns {Object} The DOM element representing the component accordion
 */
RenderStrategy.prototype.createComponentAccordion = function() {
	var rComponent = this.getComponentToRender();
	var mnuCompId = rComponent.getComponentId();
	var uniqueComponentId = this.getComponentId();

	//Check if the component has any grouper filters
	function hasFilters() {
		for(var y = 0; y < 10; y++) {
			//If we find any groups, return true
			if(rComponent.getGrouperLabel(y) || rComponent.getGrouperCatLabel(y)) {
				return true;
			}
		}
		//We have reached the end, and have found no groups, then return false
		return false;
	}

	//If we have no filters, return nothing
	if(!hasFilters()) {
		return null;
	}

	//Create the accordion container
	var accordionContainer = $('<div></div>').addClass('accordion-container').attr('id', 'AccordionContainer' + mnuCompId);
	var accordionContent = $('<div></div>').addClass('accordion-content').attr('id', 'Accordion' + mnuCompId + 'Content');
	var accordionContentDiv = $('<div></div>').addClass('acc-content-div').attr('id', 'accordion-content-div-' + uniqueComponentId);
	var accordionTitle = $('<div></div>').addClass('accordion-title').attr('id', 'Accordion' + mnuCompId + 'Title');

	//Call to create the component filter
	// accordionContentDiv.append(this.createComponentFilter());
	this.addComponentSection(accordionContentDiv, rComponent.createAccordionContent());
	this.addComponentSection(accordionContentDiv, rComponent.createAccordionControls());

	accordionTitle.click(function() {
		MP_Util.Doc.RunAccordion(mnuCompId); //eslint-disable-line new-cap
	}); //eslint-disable-line new-cap

	//Create the structure by appending the elements created above
	accordionContainer.append(accordionContent);
	accordionContainer.append(accordionTitle);

	accordionContent.append(accordionContentDiv);

	return accordionContainer;
};

/**
 * Creates the component footer (if available), otherwise returns false
 * @param {MPageComponent} component the component for which we are creating the footer
 * @returns {Object} If the component has a footer, returns the DOM element for the footer, otherwise
 * returns false.
 */
RenderStrategy.prototype.createComponentFooter = function() {
	var footerText = this.component.getFooterText();
	if(footerText && footerText !== '') {
		return $('<div></div>').addClass('sec-footer').html(footerText)[ 0 ];
	}
	return null;
};
/**
 * A static helper class for performing resultRangeSelection operations
 * @constructor
 */
function ResultRangeSelectionUtility() {

}

/**
 * Enumeration items for ResultRangeDirection.
 * Direction for result range, BACKWARD for lookback in the result range and FORWARD for lookahead in the result range
 */

ResultRangeSelectionUtility.direction = {
	BACKWARD: 0,
	FORWARD: 1
};

/**
 * ResultRangeSelection type for custom items
 * A custom type has a value 6. It is a special lookback option that doesn't refer to a time frame.
 */
ResultRangeSelectionUtility.CustomType = 6;

/**
 * This function determines if the component should refresh
 * @param {MPageComponent} component Component that we're determining if it should refresh
 * @param {ResultRangeSelection} resultRangeSelection ResultRangeSelection we're comparing with the component's current
 *     resultRangeSelection to determine if refresh is necessary
 * @returns {Boolean} True if the component needs to refresh, false otherwise
 */
ResultRangeSelectionUtility.shouldComponentRefresh = function(component, resultRangeSelection) {
	return (component.getLookbackUnits() !== resultRangeSelection.getUnits() || component.getLookbackUnitTypeFlag() !== resultRangeSelection.getType());
};

/**
 * Refreshes a component with a new resultRangeSelection
 * @param {MPageComponent} component Component we're refreshing
 * @param {ResultRangeSelection} resultRangeSelection ResultRangeSelection item that is clicked
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection = function(component, resultRangeSelection) {
	component.setLookbackUnits(resultRangeSelection.getUnits());
	component.setLookbackUnitTypeFlag(resultRangeSelection.getType());
	component.setResultRangeDirection(resultRangeSelection.getDirection());

	$(component.getSectionContentNode()).empty();

	var rootComponentNode = component.getRootComponentNode();
	$(rootComponentNode).find('.sec-total').html(i18n.LOADING_DATA + '...');
	//Notifies whoever is listening that we need to remove the count
	CERN_EventListener.fireEvent(component, component, EventListener.EVENT_COUNT_UPDATE, {
		'count': null
	});

	//Tell the component to fetch its data again
	component.startComponentDataRetrieval();

};

/**
 * Gets a display text based on the scope
 * @param {Number} scope 1 for All Visits - Across all encoutners or 2 for Selected Visit - a specific single encounter.
 * @returns {String} a display text based upon the scope passed in
 */
ResultRangeSelectionUtility.getScopeString = function(scope) {
	switch(scope) {
		case 1:
			return i18n.discernabu.All_VISITS;
		case 2:
			return i18n.discernabu.SELECTED_VISIT;
		default:
			return '';
	}
};

/**
 * Gets a display text based on the resultRangeSelectionType and resultRangeSelectionUnits for custom
 * ResultRangeSelection. if display text has resultRangeSelectionUnits>0(e.g. LAST 50 REPORTS) input
 * resultRangeSelectionType should be in LAST {0} REPORTS if resultRangeSelectionUnits are 0, provided string will be
 * displayed as it is.
 * @param {String} resultRangeSelectionType ResultRangeSelection display string for a component (LATEST, LAST {0}
 *     REPORTS, any custom string)
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units for a component
 * @returns {String} the display text based on the resultRangeSelection type and units
 */
ResultRangeSelectionUtility.getCustomDisplayString = function(resultRangeSelectionType, resultRangeSelectionUnits) {
	if(resultRangeSelectionUnits > 0) {
		return resultRangeSelectionType.replace('{0}', resultRangeSelectionUnits);
	}
	else {
		return resultRangeSelectionType;
	}
};
/**
 * Gets a display text based on the resultRangeSelectionType and resultRangeSelectionUnits
 * @param {Number} resultRangeSelectionType ResultRangeSelection type for a component (months, days, etc)
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units for a component
 * @returns {String} the display text based on the resultRangeSelection type and units
 */
ResultRangeSelectionUtility.getDisplayString = function(resultRangeSelectionType, resultRangeSelectionUnits) {
	switch(resultRangeSelectionType) {
		case 1:
			return i18n.discernabu.LAST_N_HOURS.replace('{0}', resultRangeSelectionUnits);
		case 2:
			return i18n.discernabu.LAST_N_DAYS.replace('{0}', resultRangeSelectionUnits);
		case 3:
			return i18n.discernabu.LAST_N_WEEKS.replace('{0}', resultRangeSelectionUnits);
		case 4:
			return i18n.discernabu.LAST_N_MONTHS.replace('{0}', resultRangeSelectionUnits);
		case 5:
			return i18n.discernabu.LAST_N_YEARS.replace('{0}', resultRangeSelectionUnits);
		default:
			return i18n.discernabu.LAST_N_DAYS.replace('{0}', resultRangeSelectionUnits);
	}
};

/**
 * Gets a full display text based on the scope, resultRangeSelection type, and resultRangeSelection units
 * @param {Number} scope 1 for All Visits - Across all encoutners or 2 for Selected Visit - a specific single
 *     encounter.
 * @param {Number} resultRangeSelectionType ResultRangeSelection type of the component
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units of the component
 * @returns {String} the full display text of the component resultRangeSelection based on scope, resultRangeSelection
 *     type, and resultRangeSelection units
 */
ResultRangeSelectionUtility.getFullDisplayString = function(scope, resultRangeSelectionType, resultRangeSelectionUnits) {
	var resultRangeSelectionText = '';
	var i18nCore = i18n.discernabu;
	if(resultRangeSelectionType > 0 && resultRangeSelectionUnits > 0) {
		resultRangeSelectionText = ResultRangeSelectionUtility.getDisplayString(resultRangeSelectionType, resultRangeSelectionUnits);
		switch(scope) {
			case 1:
				resultRangeSelectionText = i18nCore.ALL_N_VISITS.replace('{0}', resultRangeSelectionText);
				break;
			case 2:
				resultRangeSelectionText = i18nCore.SELECTED_N_VISIT.replace('{0}', resultRangeSelectionText);
				break;
		}
	}
	else {
		resultRangeSelectionText = ResultRangeSelectionUtility.getScopeString(scope);
	}
	return resultRangeSelectionText;
};


/**
 * Gets a full display text based for provided resultRangeSelectionItem
 * @param {ResultRangeSelection} resultRangeSelectionItem Items for which display text is needed
 * @returns {String} the display text of the component
 */
ResultRangeSelectionUtility.getDisplayText = function(resultRangeSelectionItem) {
	var lookbackType = resultRangeSelectionItem.getType();
	var lookbackValue = resultRangeSelectionItem.getUnits();
	var scope = resultRangeSelectionItem.getScope();
	if(lookbackType === ResultRangeSelectionUtility.CustomType) {
		return ResultRangeSelectionUtility.getCustomDisplayString(resultRangeSelectionItem.getDisplay(), lookbackValue);
	}
	else {
		// it's something else
		if(lookbackValue > 0 && lookbackType > 0) {
			return ResultRangeSelectionUtility.getDisplayString(lookbackType, lookbackValue);
		}
		else {
			return ResultRangeSelectionUtility.getScopeString(scope);
		}
	}
};

/**
 * This function creates custom ResultRangeSelection and adds it to the
 * look back menu items of the provided component. Function should be called from
 * the preProcessing function of the component so that when component is rendered, newly added
 * custom ResultRangeSelection will be displayed. While rendering of ResultRangeSelection,
 * result range direction will be set in component and can be accessed via getResultRangeDirection()
 * of the component. This function handles the display part of the the ResultRangeSelection and
 * then by using getLookbackUnits(), getLookbackUnitTypeFlag() and getResultRangeDirection() you can
 * retrieve required information in retrieveComponentData function of the component.
 *
 * @param {MPageComponent} component Component on which custom result range selection item needs to be added
 * @param {ResultRangeSelection} customResultRangeSelectionItem Custom ResultRangeSelection item which needs to be added
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelectionUtility.addCustomResultRangeSelectionItem = function(component, customResultRangeSelectionItem) {
	var resultRangeSelectionItems = component.getLookbackMenuItems() || [];
	var resultRangeSlectionItem = null;
	customResultRangeSelectionItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(customResultRangeSelectionItem));
	if(resultRangeSelectionItems.length) {
		// Take the default and push it to the front and then add customResultRangeSelectionItem item
		resultRangeSelectionItems.unshift(resultRangeSelectionItems.pop());
		resultRangeSelectionItems.push(customResultRangeSelectionItem);
	}
	else {
		resultRangeSlectionItem = new ResultRangeSelection();
		// No lookback options defined so we need to act like there are
		if(component.getBrLookbackUnits() === 0 && component.getBrLookbackUnitTypeFlag() === 0) {
			// If neither the br lookback units or type are selected we are
			// looking across all of the current encounter or across all encounters
			resultRangeSlectionItem.setUnits(0);
			resultRangeSlectionItem.setScope(component.getScope());
			resultRangeSlectionItem.setType(component.getScope());
		}
		else {
			resultRangeSlectionItem.setUnits(component.getBrLookbackUnits());
			resultRangeSlectionItem.setScope(component.getScope());
			resultRangeSlectionItem.setType(component.getBrLookbackUnitTypeFlag());
		}
		resultRangeSlectionItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(resultRangeSlectionItem));
		resultRangeSelectionItems.push(resultRangeSlectionItem, customResultRangeSelectionItem);
	}
	// Replace the existing menu item list with the new one
	component.setLookbackMenuItems(resultRangeSelectionItems);
};


/**
 * A container object for component reresultRangeSlectionItemeSelection items
 * Following points should be considered while creating custom ResultRangeSelection objects
 * type of the custom object should be 6 (ResultRangeSelectionUtility.CustomType)
 * units can be number >= 0
 * display if you want to include units in the display string such as LAST 50 NOTES,
 * in this case display should be in format LAST {0} NOTES and provide units using setUnits. It will replace
 * {0} with provided units.Notice here,if you want to add multiplier any where in the string you just need to
 * provide string consisting of {0} in place of count. If you want to display your string as it is(without any change
 * or replacement), provide set display with string you want and set units as 0.It is assumed here that provided string
 * is already internationalized. Scope would be generally the scope of the component Direction can
 * 0(ResultRangeSelectionUtility.direction.BACKWARD) for lookback and 1(ResultRangeSelectionUtility.direction.FORWARD)
 * for lookahead
 * @returns {undefined} This function does not return a value
 */
function ResultRangeSelection() {
	this.type = null;
	this.units = null;
	this.display = '';
	this.scope = null;
	this.direction = 0;
}

/**
 * Gets the resultRangeSelection unit type for the resultRangeSelection item
 * @returns {Number} the resultRangeSelection unit type flag
 */
ResultRangeSelection.prototype.getType = function() {
	return this.type;
};

/**
 * Sets the resultRangeSelection unit type for the resultRangeSelection item
 * @param {Number} type ResultRangeSelection unit type
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setType = function(type) {
	this.type = type;
};

/**
 * Gets the resultRangeSelection units for the resultRangeSelection item
 * @returns {Number} the resultRangeSelection units for the resultRangeSelection item
 */
ResultRangeSelection.prototype.getUnits = function() {
	return this.units;
};

/**
 * Sets the resultRangeSelection units for the resultRangeSelection item if the value is greater than or equal to zero
 * @param {Number} units ResultRangeSelection units for the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setUnits = function(units) {
	if(units >= 0) {
		this.units = units;
	}
};

/**
 * Gets the display for the resultRangeSelection item
 * @returns {String} the display for the resultRangeSelection item
 */
ResultRangeSelection.prototype.getDisplay = function() {
	return this.display;
};

/**
 * Sets the display for the resultRangeSelection item
 * @param {String} display Display for the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setDisplay = function(display) {
	this.display = display;
};

/**
 * Gets the scope of the resultRangeSelection item
 * @returns {Number} the scope of the resultRangeSelection item
 */
ResultRangeSelection.prototype.getScope = function() {
	return this.scope;
};

/**
 * Sets the scope of the resultRangeSelection item
 * @param {Number} scope Scope of the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setScope = function(scope) {
	this.scope = scope;
};

/**
 * Gets the direction of the resultRangeSelection item
 * @returns {Number} the direction of the resultRangeSelection item
 */
ResultRangeSelection.prototype.getDirection = function() {
	return this.direction;
};

/**
 * Sets the direction of the resultRangeSelection item
 * @param {Number} direction Direction of the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setDirection = function(direction) {
	this.direction = direction;
};
/**
 * The SummaryRenderStrategy object
 * This object is used to create standard summary component html structures. It inherits from the base
 * RenderStrategy object. Please see that artifact for available methods to override.
 * @constructor
 * @author Will Reynolds
 */
function SummaryRenderStrategy(){}

SummaryRenderStrategy.prototype = new RenderStrategy();
SummaryRenderStrategy.prototype.constructor = RenderStrategy;

/**
 * Overrides the RenderStrategy createComponentHeader method to add additional summary specific content to the header
 * Note that some controls appear to be added in the wrong order, but this is necessary, as the component
 * styling requires that they be added in this order.
 * @return {Object} the DOM element for the component header. 
 */
SummaryRenderStrategy.prototype.createComponentHeader = function() {
	//Create the header shell
	var header = $("<h2></h2>").addClass(this.componentStyle.getHeaderClass());
	
	//Add the toggle control
	this.addComponentSection(header, this.createComponentToggleControl());
	
	//Add the component options menu (color / default expanded / etc)
	this.addComponentSection(header, this.createComponentOptionsMenu());
	
	//Add the title to the header
	this.addComponentSection(header, this.createComponentTitle());
	
	return header[0];
};

/**
 * Overrides the RenderStrategy method for creating the component sub-header. Note
 * that this method uses the createComponentLookback function, as the component's lookback
 * exists in the sub-header in summary pages.
 * @returns {Object} The DOM object representing the component's sub-header.
 */
SummaryRenderStrategy.prototype.createComponentSubHeader = function() {
	var rComponent = this.component;
	var scope = rComponent.getScope();
	var uniqueComponentId = this.getComponentId();
	//If the scope is 3, we have a custom component subheader, otherwise, we add the lookback menu
	if(scope === 3) {
		return rComponent.getScopeHTML();
	} else if(scope > 0) {
		//Create html elements
		var subHeaderMenu = $("<div></div>").attr("id", "lb" + uniqueComponentId + "Mnu");
		var subHeader = $("<div></div>").addClass("sub-title-disp").attr("id", "stt" + uniqueComponentId);
		subHeaderMenu.append(subHeader);
		subHeader.append(this.createComponentLookback());
		return subHeaderMenu;
	}
};

/**
 * Creates the component toggle control found in the header. This control handles expanding/collapsing
 * the component
 * @param {MPageComponent} component the component for which we are creating the toggle control
 * @return {Object} the DOM element for the component toggle control 
 */
SummaryRenderStrategy.prototype.createComponentToggleControl = function() {
	//If component is always expanded, we do not create the toggle control
	if(this.component.isAlwaysExpanded()) {
		return null;
	}
	return $("<span></span>").addClass(this.componentStyle.getHeaderToggle()).attr("title", this.i18nCore.HIDE_SECTION)[0];
};

/**
 * Creates the component options control found in the header.
 * the component
 * @param {MPageComponent} component the component for which we are creating menu option control
 * @return {Object} the DOM element for the component options menu
 */
SummaryRenderStrategy.prototype.createComponentOptionsMenu = function() {
	return $("<span></span>").addClass("opts-menu menu-hide").attr("id", "mainCompMenu" + this.componentId).html("&nbsp")[0];
};

/**
 * This function overrides the RenderStrategy method for creating the component lookback controls.
 * @returns {Object} the DOM object representing the component's lookback controls
 */
SummaryRenderStrategy.prototype.createComponentLookback = function() {
	var rComponent = this.component;
	var lookbackItems = rComponent.getLookbackMenuItems();
	var uniqueComponentId = this.getComponentId();
	var scope = rComponent.getScope();
	var staticContentLocation = rComponent.getCriterion().static_content;
	var foundDefault = false;
	
	//Helper function to handle clicking a lookback item in the lookback menu
	function handleLookbackClick(menuItem, lookbackItem) {
		return function() {
			if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItem)) {
				return;
			}
			//Uncheck all menu items
			var menuItems = lookbackMenu.getMenuItemArray();
			for(var i = 0; i < menuItems.length; i++) {
				menuItems[i].setIsSelected(false);
			}
			//Check the menu item you selected
			menuItem.setIsSelected(true);
			//Make the call to refresh the component with the new lookback
			ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItem);
			//Toggle the lookback display
			$("#lookbackDisplay" + uniqueComponentId).html(lookbackItem.getDisplay());
		};
	}
	
	var lookbackDays = rComponent.getLookbackDays();
	var lookbackUnits = (lookbackDays > 0) ? lookbackDays : rComponent.getLookbackUnits();
	var lookbackFlag = (lookbackDays > 0) ? 2 : rComponent.getLookbackUnitTypeFlag();
	
	var lookbackDisplayText = ResultRangeSelectionUtility.getFullDisplayString(scope, lookbackFlag, lookbackUnits);
	
	var lookbackContainer = $("<div></div>").attr("id", "lookbackContainer" + uniqueComponentId);
	lookbackContainer.append($("<span></span>").attr("id", "lookbackDisplay" + uniqueComponentId).html(lookbackDisplayText));
	//If we have no lookback items, just add the filter applied section and return what we have
	if(!lookbackItems || !lookbackItems.length) {
		lookbackContainer.append(this.createFilterAppliedSection());
		return lookbackContainer;
	}
	
	//Create the lookback menu
	var lookbackMenu = new Menu("lookbackMenu" + uniqueComponentId);
	lookbackMenu.setAnchorElementId("lookbackMenu" + uniqueComponentId);
	lookbackMenu.setAnchorConnectionCorner(["bottom", "left"]);
	lookbackMenu.setContentConnectionCorner(["top", "left"]);
	lookbackMenu.setIsRootMenu(true);
	
	//Iterate over the lookback menu items and create menu items for them
	var numberOfLookbackItems = lookbackItems.length;
	for(var x = 0; x < numberOfLookbackItems; x++) {
		var lookbackItem = lookbackItems[x];
		var lookbackMenuSelector = new MenuSelection("lookbackMenuItem" + uniqueComponentId + "-" + x);
		lookbackMenuSelector.setCloseOnClick(true);
		//If this lookback item is the default, set it to selected
		if(!foundDefault && lookbackItem.getUnits() === lookbackUnits && lookbackItem.getType() === lookbackFlag) {
			foundDefault = true;
			lookbackMenuSelector.setIsSelected(true);
		}
		lookbackMenuSelector.setLabel(lookbackItem.getDisplay());
		lookbackMenuSelector.setClickFunction(handleLookbackClick(lookbackMenuSelector, lookbackItem));
		lookbackMenu.addMenuItem(lookbackMenuSelector);
	}
	MP_MenuManager.updateMenuObject(lookbackMenu);	
	var lookbackDropDown = $("<a></a>").append($("<img>").attr({"id" : "lookbackMenu" + uniqueComponentId,"src" : staticContentLocation + "/images/3943_16.gif"}));
	lookbackDropDown.click(function(){
		if(!lookbackMenu.isActive()) {
			MP_MenuManager.showMenu("lookbackMenu" + uniqueComponentId);		
		} else {
			MP_MenuManager.closeMenuStack(true);
		}
	});
	lookbackDropDown.appendTo(lookbackContainer);
	lookbackContainer.append(this.createFilterAppliedSection());
	return lookbackContainer;
};
//Temporary hack to add the dir=ltr attribute to the html element
$('html').attr('dir', 'ltr');
/**
 * ViewpointViewSelection Object
 * @constructor
 * @param {string} categoryMean - categoryMean
 */
function ViewpointViewSelection(categoryMean) {
	this.m_viewId = categoryMean;
	this.m_availableViews = [];
}

ViewpointViewSelection.prototype = new MPageView();
ViewpointViewSelection.prototype.constructor = MPageView;

/**
 * Get the view id associated to the ViewpointViewSelection object
 * @returns {string} The view id associated to the ViewpointViewSelection object
 */
ViewpointViewSelection.prototype.getViewId = function() {
	return this.m_viewId;
};

/**
 * Sets the view id associated with this ViewpointViewSelection object
 * @param {string} viewId The id associated with this ViewpointViewSelection object
 * @returns {ViewpointViewSelection} The ViewpointViewSelection object calling the function so chaining can be used.
 */
ViewpointViewSelection.prototype.setViewId = function(viewId) {
	if (viewId && typeof viewId === "string") {
		this.m_viewId = viewId;
	}
	return this;
};

/**
 * Retrieves the array of available views within this ViewpointViewSelection instance.
 * @returns {array} The array of available views within this ViewpointViewSelection instance.
 */
ViewpointViewSelection.prototype.getAvailableViews = function() {
	return this.m_availableViews;
};

/**
 * Sets the array of views that are available within this ViewpointViewSelection object.
 * @param {array} viewArray The array of Views that should be available within this ViewpointViewSelection instance.
 * @returns {ViewpointViewSelection} The Viewpoint object calling the function so chaining can be used
 */
ViewpointViewSelection.prototype.setAvailableViews = function(viewArray) {
	//Accept empty arrays as well as populated
	if ($.isArray(viewArray)) {
		this.m_availableViews = viewArray;
	}
	return this;
};

/**
 * initializes the view with the available list of views
 * @param {Array} availableViews - from the view point container
 * @returns {void}
 */
ViewpointViewSelection.prototype.initializeView = function(availableViews) {
	if (availableViews) {
		this.setAvailableViews(availableViews);
	}
};

/**
 *  The function is to render Viewpoint view selection page, creates the page content form the list of available views
 *  Iterates thorough the available views, creates the view element, differentiates the view display by view type and binds the click event for each view.
 *  @returns {void}
 */
ViewpointViewSelection.prototype.renderView = function() {
	var vwpi18n = i18n.discernabu.mpageViewpoint;
	var container = $("#" + this.getViewId());
	var views = this.getAvailableViews();
	var viewCount = views.length;
	var viewName = null;
	var viewType = null;
	var viewBody = null;
	var viewTypeElement = null;
	var viewNameElement = null;
	var pageContent = $("<div></div>").addClass("vwp-sel-vw-content");
	var titleContent = $("<div>" + vwpi18n.SELECT_VIEW_TITLE + "</div>").addClass("vwp-sel-vw-title");
	pageContent.append(titleContent);
	//sort the views to display the view in alphabetical order
	views.sort(function(a, b) {
		var aName = (a.getViewName()).toUpperCase();
		var bName = (b.getViewName()).toUpperCase();
		if (aName < bName) {
			return -1;
		}
		if (aName > bName) {
			return 1;
		}
		return 0;
	});
	for (var x = 0; x < viewCount; x++) {
		var view = views[x];
		var viewId = view.getId();
		if (viewId !== "SELECT_VIEW") {
			viewName = view.getViewName();
			viewType = this.getCSSByType(view.getLayoutType(), view.getCategoryMean());
			viewBody = $("<div></div>").addClass("vwp-sel-vw-item").attr("id", "selectView" + viewId).bind("click", this.createViewClickFunction(viewId));
			viewTypeElement = $("<span></span>").addClass("vwp-sel-vw-type").addClass(viewType);
			viewBody.append(viewTypeElement);
			viewNameElement = $("<span>" + viewName + "</span>").addClass("vwp-sel-vw-name");
			viewBody.append(viewNameElement);
			pageContent.append(viewBody);
		}
	}
	container.append(pageContent);
};

/**
 * Creates the function for view click, The function removes the SELECT_VIEW(New View)tab
 * And activates the view.
 * @param {string} viewObjId - view ID
 * @returns {Function} - returns function for handling view click
 */
ViewpointViewSelection.prototype.createViewClickFunction = function(viewObjId) {
	return function() {
		var tabControl = MP_Viewpoint.getViewpointObject().m_tabControllerObj;
		if (tabControl) {
			//call remove tab and pass true to not to activate previous active tab
			tabControl.removeTab("SELECT_VIEW", true);
			//add the tab that is clicked and activate the view
			MP_Viewpoint.addViewContainerTab(viewObjId);
		}
	};
};

/**
 * Function to get different CSS class by the type of view
 * @param {number} layoutType - layout type of view
 * @param {string} categoryMean - category of view
 * @returns {string} - returns CSS class based on view type
 */
ViewpointViewSelection.prototype.getCSSByType = function(layoutType, categoryMean) {

	//get css class for the predefined(canned)views using the category Mean.
	switch(categoryMean) {
	case "MP_ICU_DASHBOARD":
		return "dashboard";
	case "MP_COMMON_ORDERS_V4":
		return "qoc";
	case "MP_REACH_V5":
		return "sum";
	case "MP_CALC_SUMMARY":
		return "sum";
	}
	//all other views use the layout type to get the css class
	switch (layoutType) {
	case 0:
		return "sum";
	case 1:
		return "wf";
	case 3:
		return "qoc";
	case 4:
		return "worklist";
	case 5:
		return "dashboard";
	default:
		return "";
	}
};


//Below functions override MPageView functions, which can be implemented on the need.

/**
 * Function to initialize the components if needed
 * @returns {void}
 */
ViewpointViewSelection.prototype.initializeComponents = function() {
};

/**
 * Loads and stores the settings from the preferences model
 * @returns {void}
 */
ViewpointViewSelection.prototype.loadViewSettings = function() {
};

/**
 *This function will be used by Select View Page instances to handle any pre-processing that needs to take place prior
 * to initializing
 * @returns {void}
 */
ViewpointViewSelection.prototype.preProcessing = function() {
};

/**
 *This function will be used by Select View Page instances to handle any post-processing that needs to take place post
 * rendering
 * @returns {void}
 */
ViewpointViewSelection.prototype.postProcessing = function() {
};

/**
 * This function is used to handle the window.resize events that are fired when the browser window is resized
 * @returns {void}
 */
ViewpointViewSelection.prototype.resizeView = function() {
};
/*global RenderStrategy, ResultRangeSelectionUtility, ResultRangeSelection, CapabilityTimer */
/**
 * The WorkflowRenderStrategy object
 * This object is used to create workflow component html structures. It inherits from the base
 * RenderStrategy object. Please see that artifact for available methods to override.
 * @constructor
 * @author Will Reynolds
 */
function WorkflowRenderStrategy() {

}

WorkflowRenderStrategy.prototype = new RenderStrategy();
WorkflowRenderStrategy.prototype.constructor = RenderStrategy;

/**
 * Overrides the RenderStrategy method for creating the component header.
 * This function creates the base header, and adds the lookback section.
 * @returns {Object} The DOM object representing the component header
 */
WorkflowRenderStrategy.prototype.createComponentHeader = function() {
	//override the RenderStrategy method to add Requried Indicator besides the component label
	var header = $("<h2></h2>").addClass(this.componentStyle.getHeaderClass());
	if (this.component.getGapCheckRequiredInd()) {
		this.addComponentSection(header, this.createComponentRequiredIndicator());
	}
	this.addComponentSection(header, this.createComponentTitle());
	var componentHeaderElementsContainer = $("<div></div>").addClass("header-elements-container");
	//Add the component options menu (color / default expanded / etc)
	this.addComponentSection(componentHeaderElementsContainer, this.createComponentOptionsMenu());
	//Add the component refresh button
	this.addComponentSection(componentHeaderElementsContainer, this.createComponentRefreshButton());
	//Add the control that would enable the SplitView in the current Workflow View.
	this.addComponentSection(componentHeaderElementsContainer, this.createComponentContextualViewControl());
	//Add toggle buttons (for switching views and other purposes)
	this.addComponentSection(componentHeaderElementsContainer, this.createHeaderToggles());
	this.addComponentSection(componentHeaderElementsContainer, this.createComponentLookback());

	this.addComponentSection(header, componentHeaderElementsContainer);
	return header[0];
};

/**
 * This function creates the Required Indicator controls for Gap check functionality
 * @returns {jQuery Object or HTML string} jQuery object or HTML string of the required Indicator.
 */
WorkflowRenderStrategy.prototype.createComponentRequiredIndicator = function () {
	var requiredIndContainer = null;
	var component = this.component;
	var componentId = component.getComponentId();
	var prefObj = component.getPreferencesObj() || {};
	var isPrefObjSet = (typeof prefObj.REQUIRED!=="undefined") ? prefObj.REQUIRED:0;
	var spanClass = isPrefObjSet ? "component-required-ind" : "component-required-ind hidden";
	component.setPreferencesObj(prefObj);
	requiredIndContainer = $("<span class='" + spanClass + "'></span>").attr("id", "reqInd" + componentId).html("&nbsp;");
	var componentRequiredHandler = function () {
		// disable clicks
		requiredIndContainer.off("click");
		// re-enable clicks
		requiredIndContainer.click(componentRequiredHandler);
		requiredIndContainer.addClass('hidden');
		var contentNode = component.getRootComponentNode();
		if(contentNode){
			var disclaimerContainer = $(contentNode).find('.disclaimer-text');
			disclaimerContainer.show();
			prefObj.REQUIRED = 0;
			component.setPreferencesObj(prefObj);
			component.savePreferences(true);
		}
	};
	requiredIndContainer.click(componentRequiredHandler);
	return requiredIndContainer[0];
};

/**
 * This function handles the workflow component's section toggles.
 * @return {jQuery Object or HTML string} jQuery object or HTML string of the toggles' container.
 */
WorkflowRenderStrategy.prototype.createHeaderToggles = function() {
	return this.component.createHeaderToggles();
};

/**
 * This function handles the workflow sub-header logic.
 * @returns {Object} if the component has a scope of 3, it returns the component's
 * scope html, otherwise returns null.
 */
WorkflowRenderStrategy.prototype.createComponentSubHeader = function() {
	var rComponent = this.component;
	return (rComponent.getScope() === 3) ? rComponent.getScopeHTML() : null;
};

/**
 * This function overrides the RenderStrategy method for creating the component lookback
 * controls.
 * @returns {Object} The DOM object representing the component's lookback controls.
 */
WorkflowRenderStrategy.prototype.createComponentLookback = function() {
	var extraLookbackMenu = null;
	var rComponent = this.getComponentToRender();
	var uniqueComponentId = this.getComponentId();
	var hasSelectedMoreOption = false;
	var scope = rComponent.getScope();
	var maxItemsFaceUp = 3;
	var lookbackItems = rComponent.getLookbackMenuItems();
	var lookbackItem;
	var x = 0;

	//Helper function to handle showing/hiding the extra lookback options
	function toggleExtraOptions() {
		if(!extraLookbackMenu.isActive()) {
			MP_MenuManager.showMenu("extraLookbackMenu" + uniqueComponentId);
		}
		else {
			MP_MenuManager.closeMenuStack(true);
		}
	}

	//Helper function to handle when the user clicks one of the face-up lookback buttons
	function handleLookbackClick(lookbackItem) {
		return function() {
			if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItem)) {
				return;
			}
			ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItem);
			$("#lookbackContainer" + uniqueComponentId).find(".lookback-button-active").removeClass("lookback-button-active");
			$(this).addClass("lookback-button-active");
		};
	}

	//Helper function to handle when the user clicks one of the extra lookback options
	function handleExtraLookbackClick(lookbackItem, extraLookbackMenuItem) {
		return function() {
			if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItem)) {
				return;
			}
			ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItem);

			//Store off the values of the lookback item you clicked into the extra button, that way you can click it
			extraLookbackMenuItem.setDisplay(lookbackItem.getDisplay());
			extraLookbackMenuItem.setUnits(lookbackItem.getUnits());
			extraLookbackMenuItem.setType(lookbackItem.getType());

			//If we haven't previously selected a "More" option, then we need to unbind the click event for showing the extra options
			//and bind the click event for handling the lookback
			if(!hasSelectedMoreOption) {
				$("#lookbackMoreOptions" + uniqueComponentId).unbind("click", toggleExtraOptions);
				$("#lookbackMoreOptions" + uniqueComponentId).click(handleLookbackClick(extraLookbackMenuItem));
				hasSelectedMoreOption = true;
			}
			$("#lookbackContainer" + uniqueComponentId).find(".lookback-button-active").removeClass("lookback-button-active");
			$("#lookbackMoreOptions" + uniqueComponentId).html(lookbackItem.getDisplay()).addClass("lookback-button-active");
		};
	}

	//Create a lookback button element
	function createLookbackMenuItemElement(lookbackItem) {
		return $("<div></div>").addClass("lookback-button").html(lookbackItem.getDisplay());
	}

	//Create the container to house the lookback items
	var lookbackContainer = $("<div></div>").attr("id", "lookbackContainer" + uniqueComponentId).addClass("lookback-container");
	//If there are no lookback items, then we just have the default one
	if(!lookbackItems || !lookbackItems.length) {
		var lookbackDays = rComponent.getLookbackDays();
		var lookbackUnits = (lookbackDays > 0) ? lookbackDays : rComponent.getLookbackUnits();
		var lookbackFlag = (lookbackDays > 0) ? 2 : rComponent.getLookbackUnitTypeFlag();

		lookbackContainer.append($("<div></div>").addClass("lookback-spec-period").attr("id", "lookbackDisplay" + uniqueComponentId).html(ResultRangeSelectionUtility.getFullDisplayString(scope, lookbackFlag, lookbackUnits)));
		return lookbackContainer;
	}
	//Make a copy of the array, so we don't alter the original
	lookbackItems = lookbackItems.slice(0);
	//Get the number of lookback items (should always be at least 1)
	var numberOfLookbackItems = lookbackItems.length;
	//Move the default item to the front of the array, so we can perform more trivial operations
	lookbackItems.unshift(lookbackItems.pop());

	//If the default lookback item is either "All encounters - Specified time period" or "Current encounter - Specified time period", we add some text
	if(lookbackItems[0].getType() !== 0) {
		//For 'All encounters - Specified time period', do not display the static "All Visits" text
		if(scope !== 1) {
			lookbackContainer.append($("<div></div>").addClass("lookback-spec-period").attr("id", "lookbackDisplay" + uniqueComponentId).html(ResultRangeSelectionUtility.getScopeString(scope) + ":"));
		}
	}

	//Determine the loop control (number of items to add face up)
	var numberItems = Math.min(maxItemsFaceUp, numberOfLookbackItems);

	//Add the face-up menu items
	for(x = 0; x < numberItems; x++) {
		//Create a lookback item container with necessary lookback information (see the LookbackItem class)
		lookbackItem = lookbackItems[x];
		var lookbackMenuItem = createLookbackMenuItemElement(lookbackItem);
		//Determine the styling for the lookback item
		lookbackMenuItem.addClass((x === 0) ? "lookback-button-active" : "lookback-button-no-left-border lookback-button-inactive");
		lookbackMenuItem.click(handleLookbackClick(lookbackItem));
		lookbackContainer.append(lookbackMenuItem);
	}
	//There are menu items that must be placed in the "more" drop-down
	if(numberOfLookbackItems > maxItemsFaceUp) {

		//Create the lookback menu
		extraLookbackMenu = new Menu("extraLookbackMenu" + uniqueComponentId);
		extraLookbackMenu.setTypeClass("more-lookback-menu");
		extraLookbackMenu.setAnchorElementId("extraLookbackMenu" + uniqueComponentId);
		extraLookbackMenu.setAnchorConnectionCorner(["bottom", "right"]);
		extraLookbackMenu.setContentConnectionCorner(["top", "right"]);
		extraLookbackMenu.setIsRootMenu(true);

		//Create the placeholder "More" lookback item.
		var extraLookbackMenuItem = new ResultRangeSelection();
		extraLookbackMenuItem.setDisplay(this.i18nCore.MORE);
		var extraLookbackMenuItemElement = createLookbackMenuItemElement(extraLookbackMenuItem).attr("id", "lookbackMoreOptions" + uniqueComponentId).addClass("lookback-button-no-left-border lookback-button-more");
		extraLookbackMenuItemElement.on("click", toggleExtraOptions);

		var extraLookbackDropDown = $("<div></div>").addClass("lookback-button lookback-button-arrow lookback-button-no-left-border").attr("id", "extraLookbackMenu" + uniqueComponentId);
		var extraLookbackArrow = $("<span></span>").addClass("wrkflw-selectArrow");
		 
		extraLookbackArrow.click(function(){
			toggleExtraOptions();
		});

		extraLookbackDropDown.append(extraLookbackArrow); 
		lookbackContainer.append(extraLookbackMenuItemElement);
		lookbackContainer.append(extraLookbackDropDown);
		for(x = maxItemsFaceUp; x < numberOfLookbackItems; x++) {
			//Use the lookback utility to create a lookback item
			lookbackItem = lookbackItems[x];

			//Create a standard menu selection for the "More" lookback menu
			var extraLookbackMenuSelector = new MenuSelection("extraLookbackMenuItem" + uniqueComponentId + "-" + x);
			extraLookbackMenuSelector.setCloseOnClick(true);
			extraLookbackMenuSelector.setLabel(lookbackItem.getDisplay());
			extraLookbackMenuSelector.setClickFunction(handleExtraLookbackClick(lookbackItem, extraLookbackMenuItem));
			extraLookbackMenu.addMenuItem(extraLookbackMenuSelector);
		}
		//Add the extra lookback menu
		MP_MenuManager.updateMenuObject(extraLookbackMenu);
	}
	return lookbackContainer;
};

/**
 * The workflow components no longer use the accordion so we will return null
 * @returns {null} null
 */
WorkflowRenderStrategy.prototype.createComponentAccordion = function() {
	return null;
};
/**
 * Creates the component contextual view control based on the whether the component is allowed to be shown.
 * @return {String} The mark up for Contextual View control
 */
WorkflowRenderStrategy.prototype.createComponentContextualViewControl = function(){		
	var component = this.getComponentToRender();
	var compId = component.getComponentId();
	var contextualViewControl = component.createComponentContextualViewControl();		
	if(contextualViewControl){		
		if(component.isAddedToContextualView()){
			contextualViewControl.setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);	
		}else{
			contextualViewControl.setIcon(MPageUI.ICONS.ICON_MOVE_RIGHT);	
		}
		component.setContextualViewControl(contextualViewControl);			
		return "<div class = 'hdr-contextual-view-control-container' id = '" + compId + "ContextualViewControl'>" + contextualViewControl.render() + "</div>";		
	}	
	return "";
};

/**
 * Creates the component refresh button control found in the header of the
 * Workflow component
 * @return {Object} the DOM element for the component refresh button
 */
WorkflowRenderStrategy.prototype.createComponentRefreshButton = function() {
	var compObj = this.getComponentToRender();
	var self = this;
	var refreshButtonContainer = null;
	var spanClass = compObj.isRefreshEnabled() ? "component-refresh-button" : "component-refresh-button-dthr";

	refreshButtonContainer = $("<span class='" + spanClass + "'></span>")
		.attr("id", "mainCompRefresh" + compObj.getComponentId())
		.attr("title", compObj.getAsOfDateString())
		.html("&nbsp;");

	if (compObj.isRefreshEnabled()) {
		var componentRefreshHandler = function() {
			// disable clicks
			refreshButtonContainer.off("click");
			// re-enable clicks one second from now
			setTimeout(function() {
				refreshButtonContainer.click(componentRefreshHandler);
			}, 1000);

			var refreshCapTimer = new CapabilityTimer("CAP:MPG Component Refresh", compObj.getCriterion().category_mean);
			refreshCapTimer.addMetaData("rtms.legacy.metadata.1", compObj.getReportMean());
			refreshCapTimer.capture();

			var rootComponentNode = compObj.getRootComponentNode();
			if(rootComponentNode) {
				var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
				//Make sure the loading text is not hidden.
				$(totalCount).removeClass("hidden");
				totalCount[0].innerHTML = self.i18nCore.LOADING_DATA + "...";
			}
			compObj.refreshComponent();
			compObj.updateComponentAsOfDisplay();
		};
		refreshButtonContainer.click(componentRefreshHandler);
	}
	return refreshButtonContainer;
};
/**
 * Polyfill for Object.keys so we can start using it in
 * IE8. This will help when we transition to IE10, since that 
 * method will yield better performance.
 */

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnPropertyMet = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnPropertyMet.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnPropertyMet.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}


MPageOO = {

	/**
	* Allows inheriting two classes without having to call the constructor.
	* Can be replaced with Object.create() once we go over supporting IE10+.
	*/
	inherits: function (clazz, parent) {
		var Dummy = function() {};
		Dummy.prototype = parent.prototype;
		clazz.prototype = new Dummy();
		
		// static methods
		var methods = Object.keys(parent);
		for (var i=methods.length;i--;) {
		    var m = methods[i];
		    clazz[m] = parent[m];
		}
	},

	attribute: function(clazz, name) {

		clazz.prototype["set" + name] = function(value) {
			this["m_"+name] = value;
		};

		clazz.prototype["get" + name] = function() {
			return this["m_" + name];
		};
	}
};
/**
 * The Component Table class
 * @author Will Reynolds
 * @constructor
 */
function ComponentTable() {
	this.activeRows = null;
	this.bodyTag = "div";
	this.columns = null;
	this.columnMap = null;
	this.columnTag = "dd";
	this.cssTemplate = "list-as-table";
	this.currentlySortedBy = null;
	this.currentlySortedColumn = null;
	this.customClass = "";
	this.extensions = null;
	this.groupedBy = "";
	this.groupMap = null;
	this.groupSequence = null;
	this.groupTemplate = null;
	this.headerEnabled = true;
	this.namespace = "";
	this.noResultsString = i18n.NO_RESULTS_FOUND;
	this.rows = null;
	this.rowMap = null;
	this.rowTag = "dl";
	this.sequence = null;
	this.showGroupCount = false;
	this.sortable = false;
	this.zebraStripe = true;
	this.rowHash = {name: "", value: ""};
}

/**
 * Get the active rows from the table (i.e. the rows that qualify for all filters applied to the table)
 * @return {Array} the active rows in the table
 */
ComponentTable.prototype.getActiveRows = function () {
    if (!this.activeRows) {
        this.activeRows = [];
    }
    return  this.activeRows;
};

/**
 * Sets the rows that are active on the table (used when filtering)
 * @param activeRows the rows that are active in the table (i.e. rows that pass through filtering)
 */
ComponentTable.prototype.setActiveRows = function (activeRows) {
    if (!(activeRows instanceof Array)) {
        throw new Error("Called setActiveRows on ComponentTable with non Array type for activeRows parameter");
    }
    this.activeRows = activeRows;
    return this;
};

/**
 * Adds a column to the table
 * @param column The column you wish to add to the table
 */
ComponentTable.prototype.addColumn = function (column) {
    //If an attempt is made to add something other than a TableColumn
    if (!TableColumn.prototype.isPrototypeOf(column)) {
        throw new Error("Called addColumn on ComponentTable with non TableColumn type for column parameter");
    }
    //If a column already exists with this id
    if (this.hasColumn(column.getColumnId())) {
        throw new Error("Column with id: " + column.getColumnId() + " already exists in the ComponentTable with namespace: " + this.namespace);
    }
    if (column.getIsSortable()) {
        this.sortable = true;
    }
    this.getColumnSequence().push(column.getColumnId());
    this.getColumns().push(column);
    this.getColumnMap()[column.getColumnId()] = column;
};

/**
 * Gets a list of all columns from the table
 * @return {Array<TableColumn>} the list of columns
 */
ComponentTable.prototype.getColumns = function () {
    if (!this.columns) {
        this.columns = [];
    }
    return this.columns;
};

ComponentTable.prototype.getColumnMap = function () {
    if (!this.columnMap) {
        this.columnMap = {};
    }
    return this.columnMap;
};

/**
 * Gets a column at the specified index
 * @param index the index of the column
 * @return {TableColumn} the column at index
 */
ComponentTable.prototype.getColumnAtIndex = function (index) {
    if (index < 0 || index >= this.getColumns().length) {
        throw new Error("Index out of bounds when calling getColumnAtIndex on ComponentTable. Used index: " + index);
    }
    return this.getColumns()[index];
};

/**
 * Gets a column from the table by Id
 * @param columnId the Id of the column you wish to obtain
 * @return {TableColumn} the column as obtained by the Id, an exception is thrown if the column
 * does not exist
 */
ComponentTable.prototype.getColumnById = function (columnId) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method getColumnById, TableColumn with columnId: " + columnId + " does not exist");
    }
    return this.getColumnMap()[columnId];
};

/**
 * Checks to see if a column exists
 * @param columnId the column you're checking for
 */
ComponentTable.prototype.hasColumn = function (columnId) {
    return (typeof this.getColumnMap()[columnId] !== "undefined" && this.getColumnMap()[columnId] !== null);
};

/**
 * Gets the appropriate column tag that is applied to the table
 * @return {string} the name of the column tag for the table
 */
ComponentTable.prototype.getColumnTag = function() {
	return this.columnTag;
};

/**
 * Applies the appropriate column tag to the table
 * @param columnTag
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setColumnTag = function(columnTag) {
	if ( typeof columnTag !== "string") {
		throw new Error("Called setColumnTag on ComponentTable with non string type for columnTag parameter");
	}
	this.columnTag = columnTag;
	return this;
};

/**
 * Gets the appropriate CSS template that is applied to the table
 * @return {string} the name of the CSS Template to be applied to the root of the table
 */
ComponentTable.prototype.getCSSTemplate = function() {
	return this.cssTemplate;
};

/**
 * Applies the appropriate CSS template to the ComponentTable
 * @param cssTemplate : the name of the CSS Template to be applied to the root of the table.
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCSSTemplate = function(cssTemplate) {
	if ( typeof cssTemplate !== "string") {
		throw new Error("Called setCSSTemplate on ComponentTable with non string type for cssTemplate parameter");
	}
	this.cssTemplate = cssTemplate;
	return this;
};

/**
 * Applies the appropriate body tag to the table
 * @param bodyTag: tag that needs to be applied for body of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setBodyTag = function(bodyTag) {
	if ( typeof bodyTag !== "string") {
		throw new Error("Called setBodyTag on ComponentTable with non string type for bodyTag parameter");
	}
	this.bodyTag = bodyTag;
	return this;
};

/**
 * Gets appropriate body tag that is applied to the table
 * @return {String} returns bodyTag that needs to be applied to ComponentTable
 */
ComponentTable.prototype.getBodyTag = function() {
	return this.bodyTag;
};

/**
 * Custom no results found string
 * @param noResultsString: tag that needs to be applied for body of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setNoresultsString = function(noResultsString) {
	if ( typeof noResultsString !== "string") {
		throw new Error("Called setNoresultsFound on ComponentTable with non string type for noResultsString parameter");
	}
	this.noResultsString = noResultsString;
	return this;
};

/**
 * Gets noResultsString that is applied to the table
 * @return {String} returns noResultsString that needs to be applied to ComponentTable
 */
ComponentTable.prototype.getNoResultsString = function() {
	return this.noResultsString;
};


/**
 * Gets appropriate row tag that is applied to the table
 * @return {String} returns tag that needs to be applied for each row of the ComponentTable
 */
ComponentTable.prototype.getRowTag = function() {
	return this.rowTag;
};

/**
 * Applies the appropriate row tag to the table
 * @param rowTag :  tag that needs to be applied for each row of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setRowTag = function(rowTag) {
	if ( typeof rowTag !== "string") {
		throw new Error("Called setRowTag on ComponentTable with non string type for rowTag parameter");
	}
	this.rowTag = rowTag;
	return this;
};

/**
 * Adds a hash for data attribute on the row
 * @param {String} attributeName: name of a data attribute applied for each row of the ComponentTable
 * @param {String} attributeValue: member from the result data that will be mapped as a value
 */
ComponentTable.prototype.setDataAttributeOnRow = function(attrName, attrValue){
	if (!attrName || !attrValue || typeof attrName !== "string" || typeof attrValue !== "string") {
		throw new Error("Called setDataAttributeOnRow on ComponentTable with non string type for attrName and attrValue parameter");
	}
	this.rowHash.name = attrName;
	this.rowHash.value = attrValue;
};

/**
 * Returns a row hash object
 * @returns {Object} returns a rowHash object
 */
ComponentTable.prototype.getDataAttributeOnRow = function(){
	return this.rowHash; 
};

/**
 * Returns the row satisfying the data attribute name and value specified
 * @param {String} Member from the result data that is added as a data attribute name
 * @param {String/Integer} Specific value which is essentially a key for finding a row   
 * @return {Object} returns a row object
 */
ComponentTable.prototype.getRowByHash = function(name, value){
	// Loop through the active rows
	var rowObj = null;
	var activeRowsLen = this.getActiveRows().length; 
	for(var i = 0; i < activeRowsLen ; i++){
		rowObj = this.getActiveRows()[i];
		if(rowObj.resultData[name] === value){
			return rowObj;
		}
	}
};

/**
 * Allows sorting a column in a specified direction
 * @param columnId the column to be sorted
 * @param direction the direction to sort
 */
ComponentTable.prototype.sortByColumnInDirection = function (columnId, direction) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method toggleColumnSort, TableColumn with columnId: " + columnId + " does not exist" +
            "\nOptions are: " + this.getColumnSequence().join(","));
    }
    if (!TableColumn.isValidSortDirection(direction)) {
        throw new Error("Called sortByColumnInDirection on ComponentTable with invalid sort direction. " +
            "Use enumeration TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    var column = this.getColumnMap()[columnId];
    if (!column.getIsSortable()) {
        return;
    }
    //Get a sort function based on the data type, column, and sort direction
    var sortFunction = ColumnSortFactory.getSortFunction(column, direction);
    this.currentlySortedBy = sortFunction;
    //Update the columns and their indicators
    this.updateSortIndicators(column, direction);

    //Perform the sort on the table rows
    this.getRows().sort(sortFunction);
    this.getActiveRows().sort(sortFunction);
    this.sortGroups(sortFunction);

    //Refresh the table body
    this.refresh();
};

/**
 * Toggles the sorting of the column specified by columnId. I.e. if the column is sorted ascending, it will
 * sort descending and vice versa.
 * @param columnId the column to be sorted. If columnId is not valid, an exception is thrown.
 */
ComponentTable.prototype.toggleColumnSort = function (columnId) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method toggleColumnSort, TableColumn with columnId: " + columnId + " does not exist." +
            "\nOptions are: " + this.getColumnSequence().join(","));
    }
    //Get the column by id
    var column = this.getColumnMap()[columnId];
    if (!column.getIsSortable()) {
        return;
    }
    //Get and invert the sort direction, otherwise default to ascending
    var sortDirection = (column.getColumnSortDirection() !== TableColumn.SORT.NONE ? (-1 * column.getColumnSortDirection()) : column.getDefaultSort());
    this.sortByColumnInDirection(columnId, sortDirection);
};

/**
 * Updates the sort indicators for a column.
 * @param column the column we're updating.
 * @param direction the direction the column is now sorted in.
 */
ComponentTable.prototype.updateSortIndicators = function (column, direction) {
    var ns = this.namespace;
    var sortedColumn = this.getCurrentlySortedColumn();
    //Update the previous column
    if (sortedColumn) {
        $("#" + ns + "columnHeader" + sortedColumn.getColumnId()).removeClass(this.getSortClass(sortedColumn.getColumnSortDirection()));
        sortedColumn.setColumnSortDirection(TableColumn.SORT.NONE);
    }
    $("#" + ns + "columnHeader" + column.getColumnId()).addClass(this.getSortClass(direction));
    column.setColumnSortDirection(direction);
    this.currentlySortedColumn = column;
};

/**
 * Gets a css class based on the passed in sort direction (ascending or descending)
 * @param sortDirection the direction for which we are obtaining a css class
 * @return {string} a css class string based on the sort direction
 * sortDirection = -1 (TableColumn.SORT.ASCENDING) returns sort-asc
 * sortDirection = 1 (TableColumn.SORT.DESCENDING) returns sort-desc
 */
ComponentTable.prototype.getSortClass = function (sortDirection) {
    switch (sortDirection) {
        case TableColumn.SORT.ASCENDING:
            return "sort-asc";
        case TableColumn.SORT.DESCENDING:
            return "sort-desc";
        default:
            return "";
    }
};

/**
 * Gets the function that is currently sorting the table. Null if no sorting is applied.
 * @return {Function} the function that is currently sorting the table.
 */
ComponentTable.prototype.getCurrentlySortedBy = function () {
    return this.currentlySortedBy;
};

/**
 * Sets the function that is currently sorting the table.
 * @param currentlySortedBy the function currently being used to sort the table.
 */
ComponentTable.prototype.setCurrentlySortedBy = function (currentlySortedBy) {
    if (typeof currentlySortedBy !== "function") {
        throw new Error("Called setCurrentlySortedBy on ComponentTable with non function type for currentlySortedBy parameter");
    }
    this.currentlySortedBy = currentlySortedBy;
    return this;
};

/**
 * Gets which column the table is currently sorted by
 * @return {TableColumn} the column the table is currently sorted by
 */
ComponentTable.prototype.getCurrentlySortedColumn = function () {
    return this.currentlySortedColumn;
};

/**
 * Sets which column the table is currently sorted by
 * @param currentlySortedColumn the column that the table is currently sorted by
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCurrentlySortedColumn = function (currentlySortedColumn) {
    if (!TableColumn.prototype.isPrototypeOf(currentlySortedColumn)) {
        throw new Error("Called setCurrentlySortedColumn on ComponentTable with non TableColumn type for currentlySortedColumn parameter");
    }
    this.currentlySortedColumn = currentlySortedColumn;
    return this;
};

/**
 * Gets the custom class that is applied to the table (used for customized styling)
 * @return {string} the name of the custom class to be applied to the root of the table
 */
ComponentTable.prototype.getCustomClass = function () {
    return this.customClass;
};

/**
 * Applies a css class to the root of the table for customized styling options
 * @param customClass
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCustomClass = function (customClass) {
    if (typeof customClass !== "string") {
        throw new Error("Called setCustomClass on ComponentTable with non string type for customClass parameter");
    }
    this.customClass = customClass;
    return this;
};

/**
 * Adds an extension for the component table. They act as smaller modules that can help the table perform additional
 * operations
 * @param extension the extension that is to be added to the table
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.addExtension = function (extension) {
    if (!TableExtension.prototype.isPrototypeOf(extension)) {
        throw new Error("Called addExtension on ComponentTable with non TableExtension type for extension parameter");
    }
    this.getExtensions().push(extension);
    return this;
};

/**
 * Gets a list of table extensions
 * @return {Array} the list of table extensions
 */
ComponentTable.prototype.getExtensions = function () {
    if (!this.extensions) {
        this.extensions = [];
    }
    return this.extensions;
};

/**
 * Groups the table by a key. The key should be a field in the results JSON.
 * @param key the field used to determine grouping. This key should be a field in the results JSON.
 * @param template the template used to render the grouping. This template determines what is shown
 * @param showCount whether the groups should show the counts
 * in the group subsection.
 */
ComponentTable.prototype.quickGroup = function (key, template, showCount) {
    this.groupedBy = key;
    this.groupTemplate = TemplateBuilder.buildTemplate(template);
    this.showGroupCount = showCount;
    var tableRows = this.getRows();
    var numberOfRows = tableRows.length;
    //If the data hasn't been bound, we stop here
    if (!numberOfRows) {
        return;
    }
    this.groupSequence = [];
    this.groupMap = {};
    //Iterate through the rows and add them to their respective groups
    for (var i = 0; i < numberOfRows; i++) {
        this.addRowToGroup(key, tableRows[i], showCount);
    }
};

/**
 *
 * @param groupKey the key we're qualifying the group on
 * @param row the row to be added to a group
 * @param showCount whether or not to show the counts for groups
 */
ComponentTable.prototype.addRowToGroup = function (groupKey, row, showCount) {
    var rowData = row.getResultData();
    var rowKey = (rowData[groupKey] || "UNKNOWN").replace(/[\s]/gi, "_").replace(/[\W]/gi, "").toUpperCase();
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    if (!gMap[rowKey]) {
        gMap[rowKey] = new TableGroup().setKey(groupKey).setValue(rowKey).setDisplay(this.groupTemplate.render(rowData)).setGroupId(rowKey).setShowCount(showCount);
        gSequence.push(rowKey);
    }
    gMap[rowKey].addRow(row);
};

/**
 * Checks if grouping is applied
 * @return {boolean}
 */
ComponentTable.prototype.isGroupingApplied = function () {
    return (this.getGroupSequence().length > 0);
};

/**
 * Adds a single group to the table
 * @param group the group to be added
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.addGroup = function (group) {
    if (!TableGroup.prototype.isPrototypeOf(group)) {
        throw new Error("Called addGroup on ComponentTable with non TableGroup type for group parameter");
    }
    if (this.hasGroup(group.getGroupId())) {
        throw new Error("In addGroup on ComponentTable, TableGroup with id: " + group.getGroupId() + " already exists");
    }
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    //If sorting is applied when we add the group, honor that sorting
    if (this.currentlySortedBy) {
        group.getRows().sort(this.currentlySortedBy);
    }
    gSequence.push(group.getGroupId());
    gMap[group.getGroupId()] = group;
    return this;
};

/**
 * Applies a set of groups to the table
 * @param groups a set of groups to be added to the table
 */
ComponentTable.prototype.applyGroups = function (groups) {
    if (!(groups instanceof Array)) {
        throw new Error("Called applyGroups on ComponentTable with non Array type for groups parameter");
    }
    this.clearGroups();
    //Iterate over the provided groups and add them to the table
    for (var i = 0; i < groups.length; i++) {
        this.addGroup(groups[i]);
    }
};

/**
 * Sorts the table groups (if there are any) by the provided sort function
 * @param sortFunction the function to use to sort the groups
 */
ComponentTable.prototype.sortGroups = function (sortFunction) {
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    var numberOfGroups = gSequence.length;
    for (var i = 0; i < numberOfGroups; i++) {
        gMap[gSequence[i]].getRows().sort(sortFunction);
    }
};

/**
 * Checks to see if a group with groupId exists in the Component Table
 * @param groupId the id of the TableGroup we're checking for
 * @return {boolean}
 */
ComponentTable.prototype.hasGroup = function (groupId) {
    return (typeof this.getGroupMap()[groupId] !== "undefined" && this.getGroupMap()[groupId] !== null);
};

/**
 * Obtains a table group based on the groupId
 * @param groupId the id of the group to be obtained
 * @return {TableGroup} a TableGroup based on the groupId passed in
 */
ComponentTable.prototype.getGroupById = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method getGroupById, TableGroup with groupId: " + groupId + " does not exist");
    }
    return this.getGroupMap()[groupId];
};

/**
 * Gets the group map for the ComponentTable
 * @return {Map<String, TableGroup>} the groupMap that maps group ids to their TableGroup object
 */
ComponentTable.prototype.getGroupMap = function () {
    if (!this.groupMap) {
        this.groupMap = {};
    }
    return this.groupMap;
};

/**
 * Gets the group sequence for the ComponentTable
 * @return {Array<String>} a list of group ids that forms the sequence of groups for the table
 */
ComponentTable.prototype.getGroupSequence = function () {
    if (!this.groupSequence) {
        this.groupSequence = [];
    }
    return this.groupSequence;
};

/**
 * Opens a TableGroup with the specified groupId
 * @param groupId the id of the group to be opened
 */
ComponentTable.prototype.openGroup = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method toggleGroup, TableGroup with groupId: " + groupId + " does not exist");
    }
    var tableGroup = this.getGroupMap()[groupId];
    var groupContainer = $("#" + this.namespace + "\\:" + tableGroup.getGroupId());
    //If it's already expanded, just return
    if (tableGroup.isExpanded()) {
        return;
    }
    tableGroup.setIsExpanded(true);
    groupContainer.removeClass("closed");
    groupContainer.find(".sub-sec-hd-tgl").attr("title", i18n.discernabu.HIDE_SECTION).html("-");
};

/**
 *
 * @param groupIds
 */
ComponentTable.prototype.openGroups = function (groupIds) {
    if (!(groupIds instanceof Array)) {
        throw new Error("Called openGroups on ComponentTable with non Array type for groups parameter");
    }
    //Iterate over the provided group ids and open the groups
    for (var i = 0; i < groupIds.length; i++) {
        this.openGroup(groupIds[i]);
    }
};

/**
 * Closes a group based on a group id
 * @param groupId
 */
ComponentTable.prototype.collapseGroup = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method toggleGroup, TableGroup with groupId: " + groupId + " does not exist");
    }
    var tableGroup = this.getGroupMap()[groupId];
    var groupContainer = $("#" + this.namespace + "\\:" + tableGroup.getGroupId());
    //If it's already collapsed, just return
    if (!tableGroup.isExpanded()) {
        return;
    }
    tableGroup.setIsExpanded(false);
    groupContainer.addClass("closed");
    groupContainer.find(".sub-sec-hd-tgl").attr("title", i18n.discernabu.SHOW_SECTION).html("+");
};

/**
 * Collapses a set of groups.
 * @param groupIds the ids of the groups to be collapsed.
 */
ComponentTable.prototype.collapseGroups = function (groupIds) {
    if (!(groupIds instanceof Array)) {
        throw new Error("Called closeGroups on ComponentTable with non Array type for groups parameter");
    }
    //Iterate over the group ids, attempting to close them
    for (var i = 0; i < groupIds.length; i++) {
        this.collapseGroup(groupIds[i]);
    }
};

/**
 * Toggles a table group with the specified groupId
 * @param groupId the id of the group to be toggled
 */
ComponentTable.prototype.toggleGroup = function (groupId) {
    var group = this.getGroupById(groupId);
    if (group.isExpanded()) {
        this.collapseGroup(groupId);
    } else {
        this.openGroup(groupId);
    }
};

/**
 * Clears the grouping information on the table
 */
ComponentTable.prototype.clearGroups = function () {
    this.groupSequence = [];
    this.groupMap = {};
    this.groupedBy = "";
};

/**
 * Handles rendering a group
 * @param group the group being rendered
 * @return {string} an html string built from the group
 */
ComponentTable.prototype.renderGroup = function (group) {
    var headId = this.namespace + ":" + group.getGroupId();
    var headToggleTitle = group.isExpanded() ? i18n.discernabu.HIDE_SECTION : i18n.discernabu.SHOW_SECTION;
    var headToggleContent = group.isExpanded() ? "-" : "+";
    var headToggleClass = group.isExpanded() ? "" : "closed";
    var groupCollapsibility = group.getCanCollapse() ? "can-collapse " : "";
    var countHtml = group.getShowCount() ? "<span class='sub-sec-total'>&nbsp;(" + group.getRows().length + ")</span>" : "";
    var toggleHtml = group.getCanCollapse() ? ("<span class='sub-sec-hd-tgl' title='"+headToggleTitle + "'>"+ headToggleContent +"</span>") : "";
    var hideHeader = group.getHideHeader() ? "hidden" : "";
    return "<div id='" + headId + "' class='" + headToggleClass + "'><h3 id='" + headId + ":header" + "' class='sub-sec-hd " + groupCollapsibility + hideHeader + "'>" + toggleHtml + "<span class='sub-sec-title'><" + this.getRowTag() + "><" + this.getColumnTag() + "><span class='sub-sec-display'>" + group.getDisplay() + "</span>" + countHtml + "</" + this.getColumnTag() + "></" + this.getRowTag() + "></span></h3>" +
        "<div id='" + headId + ":content' class='sub-sec-content'>" +
        (group.getRows().length ? this.renderRows(group.getRows(), group.getGroupId()) : this.renderNoResults()) +
        "</div>" +
        "</div>";
};

/**
 * Check to see if the header is enabled.
 * @return {boolean} flag determining if the table header is enabled.
 */
ComponentTable.prototype.isHeaderEnabled = function() {
    return this.headerEnabled;
};

/**
 * Sets whether the table header is enabled (will be rendered)
 * @param headerEnabled boolean flag determining if the table header is enabled.
 */
ComponentTable.prototype.setIsHeaderEnabled = function(headerEnabled) {
    if(typeof headerEnabled !== "boolean") {
        throw new Error("Called setIsHeaderEnabled on ComponentTable with non boolean type for headerEnabled parameter");
    }
    this.headerEnabled = headerEnabled;
    return this;
};

/**
 * Returns the namespace of the table
 * @return {string} the namespace of the table
 */
ComponentTable.prototype.getNamespace = function () {
    return this.namespace;
};

/**
 * Initialize the namespace of the component. This is necessary to distinguish tables in the DOM
 * @param namespace the namespace of the table. It is recommended to use component.getStyles().getId()
 */
ComponentTable.prototype.setNamespace = function (namespace) {
    if (typeof namespace !== "string") {
        throw new Error("Called setNamespace on ComponentTable with non string type for namespace parameter");
    }
    this.namespace = namespace;
    return this;
};

/**
 * Adds a row to the table
 * @param row the row to add to the table
 */
ComponentTable.prototype.addRow = function (row) {
    if (!TableRow.prototype.isPrototypeOf(row)) {
        throw new Error("Called addRow on ComponentTable with non TableRow type for row parameter");
    }
    this.getRows().push(row);
    return this;
};

/**
 * Gets the rows from the table
 * @return {Array} the rows in the table
 */
ComponentTable.prototype.getRows = function () {
    if (!this.rows) {
        this.rows = [];
    }
    return this.rows;
};

/**
 * Gets the row by id
 * @param rowId the id of the row to be obtained
 * @return {TableRow} the row with the specified id
 */
ComponentTable.prototype.getRowById = function (rowId) {
    if (!this.hasRow(rowId)) {
        throw new Error("In ComponentTable method getRowById, TableRow with rowId: " + rowId + " does not exist");
    }
    return this.getRowMap()[rowId];
};

/**
 * Gets the mapping of rowIds to TableRow objects.
 * @return {Map<String, TableRow>} the mapping of string rowIds to TableRow objects.
 */
ComponentTable.prototype.getRowMap = function() {
    if(!this.rowMap) {
        this.rowMap = {};
    }
    return this.rowMap;
};

/**
 * Checks to see if a row exists
 * @param rowId the id of the row you are checking for
 * @return {boolean} true if the row exists, false otherwise
 */
ComponentTable.prototype.hasRow = function (rowId) {
    return (typeof this.getRowMap()[rowId] !== "undefined" && this.getRowMap()[rowId] !== null);
};

/**
 * Gets the column sequence
 * @return {Array} an array of IDs telling the order in which columns are to be rendered
 */
ComponentTable.prototype.getColumnSequence = function () {
    if(!this.sequence) {
        this.sequence = [];
    }
    return this.sequence;
};

/**
 * Gets whether the table should zebra stripe
 * @return {boolean} true if the table should zebra-stripe, false otherwise
 */
ComponentTable.prototype.getZebraStripe = function () {
    return this.zebraStripe;
};

/**
 * Set whether the table should use zebra-striping
 * @param zebraStripe true if the table should zebra stripe, false otherwise
 */
ComponentTable.prototype.setZebraStripe = function (zebraStripe) {
    if (typeof zebraStripe === "boolean") {
        this.zebraStripe = zebraStripe;
    }
    return this;
};

/**
 * Gets the zebra stripe class based on the index
 * @param index the index for a row
 * @return {string} "even" if the index is even, "odd" if the index is odd
 */
ComponentTable.prototype.getStripeClass = function (index) {
	if(!this.zebraStripe){
		return "";
	}
    return (index % 2 === 0) ? "odd" : "even";
};

/**
 * Creates an html string for the table
 * @return {string} the html string for the table body
 */
ComponentTable.prototype.render = function () {
    var groupingClass = this.isGroupingApplied() ? " grouping-applied" : "";
	var contentBodyClass = groupingClass!=="" || this.getActiveRows().length > 0?"content-body":"";     
    var customClass = this.getCustomClass() ? " " + this.getCustomClass() : "";
    var cssTemplate = this.getCSSTemplate() ? " " + this.getCSSTemplate() : "";
	var endBodyTag = this.getBodyTag() ? "</" + this.getBodyTag() + ">" : "";
	var startBodyTag = this.getBodyTag() ? "<" + this.getBodyTag() + ">" : "";
	 var bodyHTML = "<div id='" + this.namespace + "table' class='component-table" + cssTemplate + customClass + groupingClass + "'>" +
        (this.isHeaderEnabled() ? this.renderHeader() : "") +
        "<div  id='" + this.namespace + "tableBody" + "' class='"+ contentBodyClass +"'>" + startBodyTag + this.renderBody() + endBodyTag + "</div></div>";
    return bodyHTML;
};

/**
 * Refreshes the table body (usually done after sorting). If there are groups it will handle re-rendering each individual
 * group, otherwise it will just render the rows.
 */
ComponentTable.prototype.refresh = function () {
    var tableRoot = $("#" + this.namespace + "table");
    var startBodyTag = this.getBodyTag() ? "<" + this.getBodyTag() + ">" : "";
    var endBodyTag = this.getBodyTag() ? "</" + this.getBodyTag() + ">" : "";
    if(!tableRoot || !tableRoot.length) {
        return;
    }
    //If grouping is applied, add the grouping applied class to the root, otherwise remove it
    if(this.isGroupingApplied()) {
        tableRoot.addClass("grouping-applied");
    } else {
        tableRoot.removeClass("grouping-applied");
    }
    var tableBody = $("#" + this.namespace + "tableBody");
    //If the table body isn't found, we can't refresh
    if (!tableBody || !tableBody.length) {
        return;
    }
    tableBody[0].innerHTML = startBodyTag + this.renderBody() + endBodyTag;
    //There is a chance that sizings have changed, so we call the update method
    this.updateAfterResize();
};

/**
 * Renders the table header
 * @return {string} an html string representing the table's header
 */
ComponentTable.prototype.renderHeader = function () {
    var ns = this.namespace;
    var gSequence = this.getGroupSequence();
    var numberOfGroups = gSequence.length;
    if(this.getActiveRows().length > 0 || numberOfGroups > 0){
    	var headerWrapper = "<" + this.getBodyTag() + " id='" + ns + "headerWrapper" + "' class='content-hdr'>";
    	var headerHTML = "<" + this.getRowTag() + " id='" + ns + "header" + "' class='" + (this.sortable ? "sort-control" : "") + " hdr'>";
    	 var columnSequence = this.getColumnSequence();
    var numberColumns =columnSequence.length;
    var headerItemClass = "";
    var column = null;
    var style = "";
    for (var i = 0; i < numberColumns; i++) {
    	headerItemClass = "header-item";
		column = this.getColumnMap()[columnSequence[i]];
		style = column.getWidth() ? " style='width:" + column.getWidth() + "px;'" : "";
		headerItemClass += (column.getCustomClass() ? (" " + column.getCustomClass()) : "");
		headerItemClass += (column.getIsSortable() ? " sort-option" : "");
		if (column.getColumnSortDirection() !== TableColumn.SORT.NONE) {
			headerItemClass += (" " + this.getSortClass(column.getColumnSortDirection()));
		}
		headerHTML += ("<" + this.getColumnTag() + " id='" + ns + "columnHeader" + column.getColumnId() + "' class='" + headerItemClass + "'" + style + ">" + "<span id='" + ns + "headerItemDisplay" + column.getColumnId() + "' class='header-item-display'>" + column.getColumnDisplay() + "</span>" + "</" + this.getColumnTag() + ">");
	}
	return headerWrapper + headerHTML + "</" + this.getRowTag() + "></" + this.getBodyTag() + ">";
    }
    else{
    	return "";
    }
    
};


/**
 * Builds up an html string for the table body. If no grouping is applied, it just renders the active rows. Otherwise
 * it will render each group
 * @return {string} the html string for the table body
 */
ComponentTable.prototype.renderBody = function () {
	var tableBodyHTML = "";	//open table
	//If no grouping is applied, simply render the table rows
	var gMap = this.getGroupMap();
	var gSequence = this.getGroupSequence();
	var numberOfGroups = gSequence.length;
	if (!gSequence.length) {
		if (this.getActiveRows().length > 0) {
			$("#" + this.namespace + "tableBody").addClass('content-body');
			return this.renderRows(this.getActiveRows(), null);
		} else {
			//When refreshed and no data found then remove the content-body class and show No results found message. Only happens after the component is loaded.
			$("#" + this.namespace + "tableBody").removeClass('content-body');
			return this.renderNoResults();
		}
	} else {
		for (var i = 0; i < numberOfGroups; i++) {
			tableBodyHTML += this.renderGroup(gMap[gSequence[i]]);
		}
	}
	return tableBodyHTML;
		//close table
};

/**
 *
 * @param rows
 * @param groupId
 * @return {string}
 */
ComponentTable.prototype.renderRows = function (rows, groupId) {
    var rowsHtml = "";
    var columnSequence = this.getColumnSequence();
    var numberColumns = columnSequence.length;
    var style = "";
    groupId = groupId ? (":" + groupId) : "";
    var cellId = "";
    for (var i = 0; i < rows.length; i++) {
        var row = rows[i];
        var rowClass = "result-info " + this.getStripeClass(i);
        var rowId = this.namespace + groupId  + ":" + row.getId();
        var rowDataAttrName = row.getRowAttributeHash().attrName;
        var rowDataAttrValue = row.getResultData()[row.getRowAttributeHash().attrValue];
        if(rowDataAttrName && rowDataAttrValue){
           	rowsHtml += "<" + this.getRowTag() + " id='" + rowId + "' class='" + rowClass + "' "+rowDataAttrName+"="+rowDataAttrValue+">";
        }
        else{
        	rowsHtml += "<" + this.getRowTag() + " id='" + rowId + "' class='" + rowClass + "'>";	
        }
       	for (var j = 0; j < numberColumns; j++) {
            var column = this.getColumnMap()[columnSequence[j]];
            var tableCellClass = "table-cell " + column.getCustomClass();
            var columnID = column.getColumnId();
            style = column.getWidth() ? " style='width:" + column.getWidth() + "px;'" : "";
            cellId = this.namespace + groupId + ":" + row.getId() + ":" + columnID;
            rowsHtml += "<" + this.getColumnTag() + " id='" + cellId + "' class='" + tableCellClass + "'" + style + ">";		//open table-cell
            rowsHtml += (column.getRenderTemplate().render(row.getResultData()) || "<span>&nbsp;</span>");
            rowsHtml += "</" + this.getColumnTag() + ">";		//close table-cell
        }
        rowsHtml += "</" + this.getRowTag() + ">";
    }
    return rowsHtml;
};

/**
 * Helper function to render the standard no results found html
 * @return {string} html string for no results found
 */
ComponentTable.prototype.renderNoResults = function () {
    return "<span class='res-none'>" + this.getNoResultsString() + "</span>";
};

/**
 * Finalizes the table (i.e., must be called after it has rendered). It attaches the click delegate
 * for the table header for sorting. It also finalizes any extensions for the table.
 */
ComponentTable.prototype.finalize = function () {
    var self = this;
    var extensionsList = this.getExtensions();
    var numberOfExtensions = extensionsList.length;

    //Initialize click events for the sort options
    var header = $("#" + this.namespace + "header").on("click", ".sort-option", function (event) {
        var id = $(this).attr("id");
        var prefixLength = (self.namespace + "columnHeader").length;
        var columnID = id.substring(prefixLength, id.length);
        self.toggleColumnSort(columnID);
    });

    //Remove the current click events
    $("#" + this.namespace + "tableBody").find(".sub-sec-hd-tgl").each(function () {
        Util.removeEvent(this, "click", MP_Util.Doc.ExpandCollapse);
    });

	//Attach a delegate for the group toggle
    $("#" + this.namespace + "tableBody").on("click", ".sub-sec-hd.can-collapse", function (event) {
    	self.toggleGroup(TableGroup.parseGroupId($(this).attr("id")));
    	self.updateAfterResize();
    });
    
    //Finalize all extensions
    for (var i = 0; i < numberOfExtensions; i++) {
        extensionsList[i].finalize(this);
    }
};

/**
 * Function to update the table after a resize event. It checks to see if scrolling is applied, and if so
 * it shifts the header over to compensate for the scrollbar in the table body.
 */
ComponentTable.prototype.updateAfterResize = function () {
    var tableBody = $("#" + this.namespace + "tableBody");
    if (!tableBody || !tableBody.length) {
        return;
    }
    //Scrolling is applied
    if (tableBody[0].scrollHeight > tableBody.outerHeight()) {
        $("#" + this.namespace + "header").addClass("shifted");
    } else {
        $("#" + this.namespace + "header").removeClass("shifted");
    }
};

/**
 * Binds JSON data to the table, setting up all necessary objects for render
 * @param data the data being bound to the table
 */
ComponentTable.prototype.bindData = function (data) {
    //Attempting to bind result data with no columns defined. This does not make sense.
    if (!this.getColumnSequence().length) {
        throw new Error("Called bindData on ComponentTable with no columns defined.");
    }
    if (typeof data !== "object" || !(data instanceof Array)) {
        throw new Error("Called bindData on ComponentTable with non object Array type for data parameter. Please pass an Array of json results");
    }
    this.clearData();
    var dataLength = data.length;
    var tableRows = this.getRows();
    var rMap = this.getRowMap();
    if(dataLength > 0){
		for (var i = 0; i < dataLength; i++) {
			var dataItem = data[i];
			var tableRow = new TableRow().setId("row" + i).setResultData(dataItem);
			// Sets attribute on row if the consumer has set one
			if(this.getDataAttributeOnRow().name && this.getDataAttributeOnRow().value){
				tableRow.setRowAttributeHash(this.getDataAttributeOnRow().name, this.getDataAttributeOnRow().value);
			}
			tableRows.push(tableRow);
			//Store the row in a map by id, so we can access it later via a DOM id
			rMap[tableRow.getId()] = tableRow;

			//If grouping has been applied (prior to binding), push the rows into groups
			if (this.groupedBy) {
				this.addRowToGroup(this.groupedBy, tableRow, this.showGroupCount);
			}
		}
		this.activeRows = tableRows;
		//If for some reason the user called a sort function before binding any data
		if (this.currentlySortedBy) {
			this.getActiveRows().sort(this.currentlySortedBy);
			tableRows.sort(this.currentlySortedBy);
			this.sortGroups(this.currentlySortedBy);
		}
	
    }else{
    	this.activeRows = [];
    }
    
    return this;
};

/**
 * Clears out the table-level data (not groups)
 */
ComponentTable.prototype.clearData = function () {
    this.rows = [];
    this.rowMap = {};
    this.activeRows = [];
};

/**
 * A factory class that produces row sorting functions
 * @constructor
 */
function ColumnSortFactory() {
}

/**
 * Gets a sort function based on a column and the specified sort direction
 * @param column the column we're sorting
 * @param sortDirection the direction to sort (ascending or descending)
 * @return {Function} a sorting function
 */
ColumnSortFactory.getSortFunction = function (column, sortDirection) {
    if (!TableColumn.isValidSortDirection(sortDirection)) {
        throw new Error("Called ColumnSortFactory.getSortFunction with invalid sort direction. " +
            "Use enumeration TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    return function (rowA, rowB) {
        var resultDataA = rowA.getResultData();
        var resultDataB = rowB.getResultData();
        var rowAVal = resultDataA[column.getPrimarySortField()];
        var rowBVal = resultDataB[column.getPrimarySortField()];
        var comparison = ColumnSortFactory.compare(rowAVal, rowBVal);
        //If the comparison on the primary sort fields isn't 0 (not equal), return this value
        if (comparison !== 0) {
            return sortDirection * comparison;
        }
        //If the primary sort fields are equal, attempt to use any secondary sort fields
        var secondarySortFields = column.getSecondarySortFields();
        for (var i = 0; i < secondarySortFields.length; i++) {
            rowAVal = resultDataA[secondarySortFields[i].FIELD];
            rowBVal = resultDataB[secondarySortFields[i].FIELD];
            comparison = ColumnSortFactory.compare(rowAVal, rowBVal);
            if (comparison !== 0) {
                return secondarySortFields[i].DIRECTION * comparison;
            }
        }
        //If we've made it this far, all fields are equal, so return 0
        return 0;
    };
};

/**
 * Helper function to compare two values.
 * @param a the first value to compare
 * @param b the second value to compare
 * @return {number} a comparison value 1, -1, or 0, where 0 means equality
 */
ColumnSortFactory.compare = function (a, b) {
    try {
        //Perform special logic for setting up sort values for comparison
        if (typeof a === "number" || typeof b === "number") {
            a = a || 0;
            b = b || 0;
        } else if (typeof a === "string" || typeof b === "string") {
            a = (a || "").toUpperCase();
            b = (b || "").toUpperCase();
        }
        return ((a > b) ? -1 : (a < b ? 1 : 0));
    } catch (exe) {
        MP_Util.LogError("Called ColumnSortFactory.compare(a,b) with an invalid value for a or b");
        return 0;
    }
};
/**
 * Utility class for retrieving data from a table
 * @constructor
 */
function ComponentTableDataRetriever(){}

/**
 * Retrieves a result json object based on an element.
 * @param table the table we're getting the data from.
 * @param element the element for which we're obtaining the associated result json.
 * @return {JSON Object} the result obtained from the table.
 */
ComponentTableDataRetriever.getResultFromTable = function(table, element) {
    var identifiers = $(element).attr("id").split(":");
    //If grouping is applied, we go through the group to find the row data
    if(table.isGroupingApplied()) {
        return table.getGroupById(identifiers[1]).getRowById(identifiers[2]).getResultData();
    } else {
        return table.getRowById(identifiers[1]).getResultData();
    }
};

/**
 * Retrieves the column id from an element in a component table.
 * @param table the table object.
 * @param element the element we're grabbing the column id from.
 * @return {string} the id of the column as obtained from the element
 */
ComponentTableDataRetriever.getColumnIdFromElement = function(table, element) {
    if(!ComponentTable.prototype.isPrototypeOf(table)) {
        throw new Error("Called getColumnIdFromElement on ComponentTableDataRetriever with non ComponentTable type for table parameter");
    }
    var identifiers = $(element).attr("id").split(":");
    if(table.isGroupingApplied()) {
        return (identifiers.length > 4) ? (identifiers.slice(3).join(':')) : (identifiers[3]);
    } else {
        return (identifiers.length > 3) ? (identifiers.slice(2).join(':')) : identifiers[2];
    }
};
/**
 * The Flowsheet Table class
 * @author Nandini Parimi
 * @constructor
 */
function FlowsheetTable() {
	this.nameSpace = "";
	this.labelColumnTable = new ComponentTable();
	this.labelColumnTable.setRowTag("tr");
	this.labelColumnTable.setColumnTag("td");
	this.labelColumnTable.setBodyTag("table");
	this.setLabelTableCustomClass("fs-label-table");
	this.resultsTable = new ComponentTable();
	this.resultsTable.setRowTag("tr");
	this.resultsTable.setColumnTag("td");
	this.resultsTable.setBodyTag("table");
	this.setResultTableCustomClass("fs-results-table");
	this.setCSSTemplate("flowsheet-table");
	this.labelColumnTableBodyElement = null;
	this.labelColumnTableElement = null;
	this.resultsTableBodyElement = null;
	this.resultsTableElement = null;
	this.headerTableElement = null;
	this.outerScrollDiv = null;
	this.innerScrollContent = null;
	this.m_scrollController = null;
	//the disclaimer text when results are capped
	this.m_disclaimer = null;
	this.sidePanelWidth = 0;
}

/**
 * Set the disclaimer that will display when results are capped
 * @param {string} disclaimerText Text to display as footnote
 */
FlowsheetTable.prototype.setDisclaimer = function(disclaimerText){
	this.m_disclaimer = disclaimerText;
};

/**
 * Get the disclaimer  that will display when results are capped
 * @return {string} disclaimerText Text to display as footnote
 */
FlowsheetTable.prototype.getDisclaimer = function(){
	return this.m_disclaimer;
};

/**
 * Creates an html string for the table.This function makes a call to the render method for both the label and result component tables
 * @return {string} the html string for the entire flowsheet table structure
 */
FlowsheetTable.prototype.render = function() {
	var bodyHTML = "<div id = '" + this.nameSpace + "flowsheetContainer' class='flowsheet-container'>"+ this.labelColumnTable.render() + this.resultsTable.render();
	
	//Appending a vertical scroll when the number of result rows is more than the viewable pane.
	bodyHTML += "<div id = '" + this.nameSpace + "flowsheetScroll' class='flowsheet-vertical-scroll flowsheet-vertical-scroll-hidden'>" + "<span id='" + this.nameSpace + "flowsheetScrollContent' class='flowsheet-scroll-content'>&nbsp;</span></div>";
	
	//Create result cap message
	if(this.m_disclaimer){
		bodyHTML += "<div id='"+ this.nameSpace+"Disclaimer' class='flowsheet-disclaimer'>"+ this.m_disclaimer +"</div>";
	}

	bodyHTML+="</div>";
	return bodyHTML;
};

/**
 * Makes a call to the Finalize function in the component table for the labelColumnTable and resultsTable.
 *
 */
FlowsheetTable.prototype.finalize = function() {

	var self = this;
	this.labelColumnTable.finalize();
	this.resultsTable.finalize();

	//Attach scroll events to the scroller that will scroll the label and the results table.
	this.m_scrollController = this.m_scrollController || $("#" + this.nameSpace + "flowsheetScroll");
	self.m_scrollController.scroll(function(event) {
		
		self.scrollTables(event);
	});

};

/**
 This function is called each time the vertical scroll bar is used.
 This function scrolls the results table and label table whenever the vertical scrollbar is used.
 * @param event - Scroll Event.
 * @param self - Flowsheet Table.
 */
FlowsheetTable.prototype.scrollTables = function(event) {
	//Check to see if the scroller is visible and that the tables have been created
	var scrollerTop = 0;
	if (this.m_scrollController.hasClass("flowsheet-vertical-scroll")) {
		scrollerTop = this.m_scrollController.scrollTop();
		if (event.type === "mousewheel") {
			var delta = event.originalEvent.wheelDeltaY || event.originalEvent.wheelDelta;
			scrollerTop -= delta;
			this.m_scrollController.scrollTop(scrollerTop);
		}
		//Apply the correct scrolling to the table bodies
		this.labelColumnTableBodyElement = this.labelColumnTableBodyElement || $("#" + this.labelColumnTable.getNamespace() + "tableBody");
		this.resultsTableBodyElement = this.resultsTableBodyElement || $("#" + this.resultsTable.getNamespace() + "tableBody");
		this.labelColumnTableBodyElement.scrollTop(scrollerTop);
		this.resultsTableBodyElement.scrollTop(scrollerTop);
	}

};

/**
 * Creates an html string for the table
 * @return {string} the html string for the table body
 */
FlowsheetTable.prototype.bindData = function(data) {

	this.labelColumnTable.bindData(data);
	this.resultsTable.bindData(data);

};

/**
 * Loops through the columns and adds appropriate columns to the result table.
 *
 */
FlowsheetTable.prototype.addResultColumn = function(column) {

	this.resultsTable.addColumn(column);

};

/**
 * Loops through the columns and adds appropriate columns to the label tables.
 *
 */
FlowsheetTable.prototype.addLabelColumn = function(column) {

	this.labelColumnTable.addColumn(column);

};

/**
 * Applies the appropriate CSS template to the label and result tables
 * @param cssTemplate
 *
 */
FlowsheetTable.prototype.setCSSTemplate = function(cssTemplate) {

	this.labelColumnTable.setCSSTemplate(cssTemplate);
	this.resultsTable.setCSSTemplate(cssTemplate);

};

/**
 Applies appropriate custom class to the label table
 * @param customClass - carries appropriate custom class to be applied to the tables.
 */
FlowsheetTable.prototype.setLabelTableCustomClass = function(customClass) {
	this.labelColumnTable.setCustomClass(customClass);
};

/**
 Applies appropriate custom class to the result tables
 * @param customClass - carries appropriate custom class to be applied to the tables.
 */

FlowsheetTable.prototype.setResultTableCustomClass = function(customClass) {
	this.resultsTable.setCustomClass(customClass);
};

/**
 * Makes a call to the setNamespace function in the component table for the labelColumnTable and resultsTable.
 * @param namespace the namespace of the table.
 */
FlowsheetTable.prototype.setNamespace = function(nameSpace) {
	if ( typeof nameSpace !== "string") {
		throw new Error("Called setNamespace on ComponentTable with non string type for namespace parameter");
	}
	this.nameSpace = nameSpace;

	//assigning unique namespace to label and result tables.
	this.labelColumnTable.setNamespace(nameSpace + "labelTable");
	this.resultsTable.setNamespace(nameSpace + "resultsTable");
	return this;
};

/*
 * Sets the side panel width value which is used for calculations in the updateAfterResize function
 */
FlowsheetTable.prototype.setSidePanelWidth = function(sidePanelWidth) {
	this.sidePanelWidth = sidePanelWidth;
};

/**
 * Function to update the table after a resize event.
 */
FlowsheetTable.prototype.updateAfterResize = function() {

	//updating the css properties to display the scroll bar appropriately.
	this.labelColumnTableBodyElement = this.labelColumnTableBodyElement || $("#" + this.labelColumnTable.getNamespace() + "tableBody");
	this.labelColumnTableElement = this.labelColumnTableElement || $("#" + this.labelColumnTable.getNamespace() + "table");
	this.resultsTableBodyElement = this.resultsTableBodyElement || $("#" + this.resultsTable.getNamespace() + "tableBody");
	this.resultsTableElement = this.resultsTableElement || $("#" + this.resultsTable.getNamespace() + "table");
	this.headerTableElement = this.headerTableElement || $("#" + this.resultsTable.getNamespace() + "headerWrapper");
	this.outerScrollDiv = this.outerScrollDiv || $("#" + this.nameSpace + "flowsheetScroll");
	this.innerScrollContent = this.innerScrollContent || $("#" + this.nameSpace + "flowsheetScrollContent");
	var headerHeight = this.headerTableElement.height();
	var miscHeight = 20;
	var container = $("#vwpBody");
	var viewHeight = $(container).height();
	var compDOMObj = $("#" + this.nameSpace);
	if (!compDOMObj.length) {
		return;
	}
	var contentBodyObj = $(compDOMObj).find(".content-body");
	var secContent = $(compDOMObj).find(".sec-content");

	//set the max-height for the content tables of resultsTable and labelTable
	if (contentBodyObj.length) {
		//Get the overall component height

		//Get the height of section header
		var sectionHeight = $(compDOMObj).find(".sec-hd").outerHeight();
		//Get the height of the content-body
		var contentBodyHeight = contentBodyObj.height();

		var disclaimerHeight = 0;

		if(this.m_disclaimer){
			disclaimerHeight = $('#'+this.nameSpace+"Disclaimer").outerHeight();
		}

		//Calculate the estimated max height of the components content-body element
		var calcHeight = (viewHeight - (sectionHeight + headerHeight + miscHeight + disclaimerHeight)) + "px";
		//apply the max-height settings for label table and result table
		$(contentBodyObj).css("max-height", calcHeight).css("overflow-y", "hidden");
	}

	var resultTableMarginOffset = 2;
	var resultTableMaxWidth = secContent.width() - this.labelColumnTableElement.width() - resultTableMarginOffset - this.sidePanelWidth;
	//set result table to cover the whole viewing area
	this.resultsTableElement.css({
		"width" : resultTableMaxWidth
	});

	var self= this;
	var resultHeaderWidth = this.headerTableElement[0].scrollWidth;
	this.resultsTableBodyElement.css({
		"width" : self.headerTableElement[0].scrollWidth + "px"
	});
	
	var resultTableHeight = this.resultsTableBodyElement[0].scrollHeight;
	var resultTableMaxheight = this.resultsTableBodyElement.css("max-height");
	var adjustableHeight = parseInt(resultTableMaxheight, 10);
	var scrollBarThickness = 18;
	//Adding a scroll bar if the number of results is more than the viewable pane.

	//parseInt function is used to compare just the numerical part of the height and ignore the "px"
	if (adjustableHeight < resultTableHeight) {
		this.outerScrollDiv.removeClass("flowsheet-vertical-scroll-hidden");
		this.innerScrollContent.css("height", resultTableHeight);
		
		//Result table will be adjusted to resultHeaderWidth after the rezie update function. 
		//So whether the scroll bar exists can be found out by comparing the following variables. 
		if (resultTableMaxWidth < this.headerTableElement[0].scrollWidth) {
			this.resultsTableElement.css("height", adjustableHeight + headerHeight);
			//taking scroll bar height into account
			this.labelColumnTableElement.css("height", adjustableHeight + headerHeight - scrollBarThickness);
			//taking scroll bar height into account
			this.outerScrollDiv.css("height", adjustableHeight - scrollBarThickness);

			$(contentBodyObj).css("max-height", adjustableHeight - scrollBarThickness);
		}else{
			this.labelColumnTableElement.css("height", adjustableHeight + headerHeight);
			this.outerScrollDiv.css("height", adjustableHeight);
		}
	} else if (!(this.outerScrollDiv.hasClass("flowsheet-vertical-scroll-hidden"))) {
		this.outerScrollDiv.addClass("flowsheet-vertical-scroll-hidden");
		this.resultsTableElement.css("height", "100%");
		this.labelColumnTableElement.css("height", "100%");
	}
};

/**
 * Function to add extensions like "Hover" and "Click" to the flowsheet table.
 * @param extension - The extension to be added to a component table
 * @param tableFlag - This flag indicates which table to add the 
 * 			extension to 1 = labelColumnTable, 2 = resultsTable, null/nothing = both tables
 */
FlowsheetTable.prototype.addExtension = function(extension, tableFlag) {
	//Setting each td of a table cell as the target for the hover.
	if (HoverExtension.prototype.isPrototypeOf(extension)) {
		if (extension.target !== "td.table-cell") {
			extension.setTarget("td.table-cell");
		}
	}
	
	switch(tableFlag) {
	case 1:
		this.labelColumnTable.addExtension(extension);
		break;
	case 2:
		this.resultsTable.addExtension(extension);
		break;
	default:
		this.labelColumnTable.addExtension(extension);
		this.resultsTable.addExtension(extension);
	}
	
};
/**
 * The MPageTooltip class. This is used for dynamic hovers.
 * @return {MPageTooltip} returns self
 * @constructor
 * @author Will Reynolds
 */
function MPageTooltip() {
    this.anchor = null;                 //The element the tooltip is anchored to
    this.content = null;                //The content of the tooltip
    this.flipfit = true;                //Whether the tooltip should flip fit (fit on screen)
    this.height = 0;                    //The height of the tooltip content in the DOM
    this.offsetX = 20;                  //The X offset from the mouse position
    this.offsetY = 20;                  //The Y offset from the mouse position
    this.showDelay = 500;               //How long the tooltip should wait to show (in milliseconds)
    this.tolerance = 5;                 //How much extra space around the edge of the window before we flip
    this.stillHovered = false;          //Whether the mouse is still hovered over the anchor for this tooltip
    this.width = 0;                     //The width of the tooltip content in the DOM
    this.x = 0;                         //The x position of the tooltip content in the DOM (coincides with css 'left')
    this.y = 0;                         //The y position of the tooltip content in the DOM (coincides with css 'top')
    return this;
}

/**
 * Get the anchor that the tooltip is tied to
 * @return {Html Element}
 */
MPageTooltip.prototype.getAnchor = function () {
    return this.anchor;
};

/**
 * Set the anchor that the tooltip is tied to
 * @param anchor the DOM anchor that this tooltip is tied to
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setAnchor = function (anchor) {
    this.anchor = anchor;
    return this;
};

/**
 * Gets the content of the tooltip (the actual tooltip in the DOM)
 * @return {jQuery DOM Element} the jQuery DOM element of the tooltip
 */
MPageTooltip.prototype.getContent = function () {
    return this.content;
};

/**
 * Sets the content of the tooltip.
 * @param content the content to be placed inside the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setContent = function (content) {
    this.content = $("<div class='mpage-tooltip'>").html(content).hide();
    return this;
};

/**
 * Gets whether the tooltip should flip to fit inside the screen space
 * @return {boolean} whether the tooltip should flip to fit inside the screen space
 */
MPageTooltip.prototype.shouldFlipfit = function () {
    return this.flipfit;
};

/**
 * Sets whether the tooltip should flip to fit inside the screen space
 * @param flipfit a boolean flag for whether the tooltip should flipfit
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setShouldFlipfit = function (flipfit) {
    if (typeof flipfit !== "boolean") {
        throw new Error("Called setShouldFlipfit on DiscernTooltip with non boolean type for flipfit parameter");
    }
    this.flipfit = flipfit;
    return this;
};

/**
 * Gets the height of the tooltip content in the DOM
 * @return {number} the height of the tooltip content in the DOM
 */
MPageTooltip.prototype.getHeight = function() {
    return this.height;
};

/**
 * Sets the height of the tooltip content in the DOM (this does not change the height of the tooltip, it is simply a means
 * of storing off the height of the tooltip content once it has been appended to the DOM).
 * @param height the height of the tooltip content in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setHeight = function(height) {
    if(typeof height !== "number") {
        throw new Error("Called setHeight on MPageTooltip with non number type for height parameter");
    }
    this.height = height;
    return this;
};

/**
 * Gets the x offset value for the tooltip. This is how far in the x direction the tooltip should be shown from the mouse
 * when hovering.
 * @return {number} the x offset value for the tooltip
 */
MPageTooltip.prototype.getOffsetX = function() {
    return this.offsetX;
};

/**
 * Sets the x offset value for the tooltip. This is how far in the x direction the tooltip should be shown from the mouse
 * when hovering.
 * @param offsetX the x offset value for the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setOffsetX = function(offsetX) {
    if(typeof offsetX !== "number") {
        throw new Error("Called setOffsetX on MPageTooltip with non number type for offsetX parameter");
    }
    this.offsetX = offsetX;
    return this;
};

/**
 * Gets the y offset value for the tooltip. This is how far in the y direction the tooltip should be shown from the mouse
 * when hovering.
 * @return {number} the y offset value for the tooltip
 */
MPageTooltip.prototype.getOffsetY = function() {
    return this.offsetY;
};

/**
 * Sets the y offset value for the tooltip. This is how far in the y direction the tooltip should be shown from the mouse
 * when hovering.
 * @param offsetY the y offset value for the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setOffsetY = function(offsetY) {
    if(typeof offsetY !== "number") {
        throw new Error("Called setOffsetY on MPageTooltip with non number type for offsetY parameter");
    }
    this.offsetY = offsetY;
    return this;
};

/**
 * Gets the delay value for the tooltip. This is how long the tooltip waits before appearing after the show
 * method has been called
 * @return {number} the delay for the tooltip in milliseconds.
 */
MPageTooltip.prototype.getShowDelay = function () {
    return this.showDelay;
};

/**
 * Sets the delay value for the tooltip. This is how long the tooltip waits before appearing after the show
 * method has been called
 * @param showDelay how long the tooltip should wait before appearing after the show method is called (in milliseconds)
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setShowDelay = function (showDelay) {
    if (typeof showDelay !== "number") {
        throw new Error("Called setShowDelay on DiscernTooltip with non number type for showDelay parameter");
    }
    if (showDelay < 0) {
        throw new Error("Called setShowDelay on DiscernTooltip with negative value, showDelay must be > 0");
    }
    this.showDelay = showDelay;
    return this;
};

/**
 * Gets a boolean flag determining whether the mouse is still hovered over the anchor.
 * @return {boolean} whether the mouse is still hovered over the tooltip's anchor.
 */
MPageTooltip.prototype.isStillHovered = function () {
    return this.stillHovered;
};

/**
 * Sets a boolean flag determining whether the mouse is still hovered over the anchor.
 * @param stillHovered the boolean flag for whether the mouse is still hovered over the anchor
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setIsStillHovered = function (stillHovered) {
    if (typeof stillHovered !== "boolean") {
        throw new Error("Called setIsStillHovered on DiscernTooltip with non boolean type for stillHovered parameter");
    }
    this.stillHovered = stillHovered;
    return this;
};


/**
 * Gets the tolerance for the tooltip (how much space around the window before flipping)
 * @return {number} contract the window size by this amount in pixels when determining tooltip flipping
 */
MPageTooltip.prototype.getTolerance = function() {
    return this.tolerance;
};

/**
 * Sets the tolerance of the tooltip (how much space to contract around the window before flipping)
 * @param tolerance how many pixels we contract the window size when determining tooltip flipping
 */
MPageTooltip.prototype.setTolerance = function(tolerance) {
    if(typeof tolerance !== "number") {
        throw new Error("Called setTolerance on MPageTooltip with non number type for tolerance parameter");
    }
    this.tolerance = tolerance;
};

/**
 * Gets the width of the tooltip content in the DOM
 * @return {number} the width of the tooltip content in the DOM
 */
MPageTooltip.prototype.getWidth = function () {
    return this.width;
};

/**
 * Sets the width of the tooltip content in the DOM (this does not change the width of the tooltip, it is simply a means
 * of storing off the width of the tooltip content once it has been appended to the DOM).
 * @param width the width of the tooltip content in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setWidth = function (width) {
    if(typeof width !== "number") {
        throw new Error("Called setWidth on MPageTooltip with non number type for width parameter");
    }
    this.width = width;
    return this;
};

/**
 * Gets the x position of the tooltip in the DOM.
 * @return {number} the x position of the tooltip in the DOM.
 */
MPageTooltip.prototype.getX = function () {
    return this.x;
};

/**
 * Sets the x position of the tooltip in the DOM (this does not change the x position of the tooltip, it is simply a means
 * of storing off the x position for internal use).
 * @param x the x position of the tooltip in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setX = function (x) {
    if(typeof x !== "number") {
        throw new Error("Called setX on MPageTooltip with non number type for x parameter");
    }
    this.x = x;
    return this;
};

/**
 * Gets the y position of the tooltip in the DOM.
 * @return {number} the y position of the tooltip in the DOM.
 */
MPageTooltip.prototype.getY = function () {
    return this.y;
};

/**
 * Sets the y position of the tooltip in the DOM (this does not change the y position of the tooltip, it is simply a means
 * of storing off the y position for internal use).
 * @param y the y position of the tooltip in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setY = function (y) {
    if(typeof y !== "number") {
        throw new Error("Called setY on MPageTooltip with non number type for y parameter");
    }
    this.y = y;
    return this;
};

/**
 * Actually shows the MPageTooltip after it has been set up. It will wait the allotted delay time, then if the
 * mouse is still hovered, will append the tooltip content to the DOM. When the mouse leaves the anchor, the tooltip
 * is removed from the DOM.
 */
MPageTooltip.prototype.show = function () {
    var self = this;
    this.stillHovered = true;

    //Bind the mouseleave event to the anchor
    $(this.getAnchor()).on("mouseleave.discernTooltip", function (event) {
        self.setIsStillHovered(false);
        //If there is content, remove it from the DOM
        if (self.getContent()) {
            self.getContent().remove();
        }
        //Unbind any events with the tooltip namespace (so we don't clutter the dom with events)
        $(self.getAnchor()).unbind(".discernTooltip");
    });

    //Wait the allotted time before showing the tooltip
    setTimeout(function () {
        //At this point, the hover will be shown, so we'll poll to see if the anchor ever disappears
        self.checkAnchorStillExists();
        //If we have moused out, we quit here
        if (!self.isStillHovered()) {
            return;
        }
        //Append the tooltip content to the DOM
        $(document.body).append(self.getContent());
        //Store of the dimensions of the tooltip
        self.setHeight(self.getContent().height());
        self.setWidth(self.getContent().width());
        //Initialize the position
        self.getContent().css({
            "left": self.calculatePosition(self.x, $(window).width()-self.getTolerance(), self.width, self.getOffsetX()),
            "top": self.calculatePosition(self.y, $(window).height()-self.getTolerance(), self.height, self.getOffsetY())
        });
        self.content.show();
        //Bind the mouse move event with the discernTooltip namespace
        $(self.getAnchor()).on("mousemove.discernTooltip", function (event) {
            //If no longer hovered, just returned
            if (!self.isStillHovered()) {
                return;
            }
            //Store off the position values
            self.setX(event.pageX).setY(event.pageY);
            //Calculate the position for the tooltip
            self.content.css("left", self.calculatePosition(event.pageX, $(window).width()-self.getTolerance(), self.width, self.getOffsetX()));
            self.content.css("top", self.calculatePosition(event.pageY, $(window).height()-self.getTolerance(), self.height, self.getOffsetY()));
        });
    }, this.getShowDelay());
};

/**
 * Calculates the position for the tooltip
 * @param mouseValue the position of the mouse (x or y)
 * @param windowValue the width or height of the window
 * @param tooltipValue the width or height of the tooltip
 * @param paramOffset the x or y offset of the tooltip
 * @return {number} the calculated position for the tooltip (an x or y value)
 */
MPageTooltip.prototype.calculatePosition = function (mouseValue, windowValue, tooltipValue, paramOffset) {
    //If we're using the flipfit functionality
    if (this.shouldFlipfit() && mouseValue + paramOffset > (windowValue - tooltipValue)) {
        var positionVal = mouseValue - tooltipValue - paramOffset;
        if (positionVal < 0) {
            positionVal = ((windowValue) / 2) - (tooltipValue / 2);
        }
        return positionVal;
    }
    //Otherwise, just return the mouse position + offset
    return mouseValue + paramOffset;
};

/**
 * Helper function to check that the hover's anchor still exists on the DOM. If at any point the anchor ceases to
 * exist, the tooltip will be removed.
 */
MPageTooltip.prototype.checkAnchorStillExists = function () {
    var self = this;
    function checkHoverAnchor(){
        try {
            //If the anchor has been removed from the DOM, remove the tooltip and return
            if (!$(document.body).find(self.getAnchor()).length) {
                self.getContent().remove();
                self.setIsStillHovered(false);
                return;
            }
            //If no longer hovered, return
            if (!self.isStillHovered()) {
                return;
            }
            //At this point, we are still hovering, so continue polling
            setTimeout(checkHoverAnchor, 5000);
        } catch (exe) {
            return;
        }
    }
    checkHoverAnchor();
};
/**
 * Simple request manager object to handle interaction of script requests
 * @constructor
 * @author Will Reynolds
 */
function RequestManager() {
    this.maxPool = 0;
    this.requestCount = 0;
    this.requestQueue = null;
}

RequestManager.SOURCE = "MP_RequestManager";

/**
 * Performs a ScriptRequest object. If there is no available slots for running a request, the request is pushed onto
 * a queue and will run when space is available.
 * @param request the request to be performed. If the request is synchronous it will block execution and start
 * the request immediately. Thus it is recommended that you use asynchronous calls.
 */
RequestManager.prototype.performRequest = function (request) {
	//If the request is synchronous, start it immediately to avoid queueing. 
	if(!request.isAsync()) {
		request.start();
		return;
	}
    if (this.requestCount < this.maxPool) {
        request.setSource(RequestManager.SOURCE);
        this.requestCount++;
        request.start();
    } else {
        this.getRequestQueue().push(request);
    }
};

/**
 * Notification that a request has completed. If there are requests on the queue, the next available request will
 * be run.
 */
RequestManager.prototype.notify = function () {
    this.requestCount--;
    if(this.requestCount < 0) {
        throw new Error("Request count fell below 0.");
    }
    //If there are no pending requests, just return
    if (!this.getRequestQueue().length) {
        return;
    }
    //There are requests at this point, grab the next one
    var request = this.requestQueue.shift();
    if (!request) {
        return;
    }
    //Perform the request
    this.performRequest(request);
};

/**
 * Gets the max thread pool of the manager.
 * @return {number} the max thread pool.
 */
RequestManager.prototype.getMaxPool = function () {
    return this.maxPool;
};

/**
 * Sets the max thread pool for the request manager. It must be a number greater than 0.
 * @param maxPool the max request pool. Must be a number greater than 0.
 * @return {RequestManager} returns self.
 */
RequestManager.prototype.setMaxPool = function (maxPool) {
    if (typeof maxPool !== "number") {
        throw new Error("Called setMaxPool on RequestManager with non number type for maxPool parameter");
    }
    if (maxPool <= 0) {
        throw new Error("Called setMaxPool on RequestManager with an invalid max pool. Must be > 0");
    }
    this.maxPool = maxPool;
    return this;
};

/**
 * Gets the request queue for the RequestManager.
 * @return {Queue<ScriptRequest>} a queue of ScriptRequest objects.
 */
RequestManager.prototype.getRequestQueue = function () {
    if (!this.requestQueue) {
        this.requestQueue = [];
    }
    return this.requestQueue;
};

/**
 * Sets the request queue for the RequestManager.
 * @param requestQueue the queue to hold ScriptRequest objects.
 * @return {RequestManager} returns self.
 */
RequestManager.prototype.setRequestQueue = function (requestQueue) {
    if (!(requestQueue instanceof Array)) {
        throw new Error("Called setRequestQueue on RequestManager with non array type for requestQueue parameter");
    }
    this.requestQueue = requestQueue;
    return this;
};

/**
 * Create a global instance of the request manager and set the max thread pool to 6
 * @type {RequestManager}
 */
var MP_RequestManager = new RequestManager();
MP_RequestManager.setMaxPool(6);

/**
 * Response handler interface
 * @constructor
 * @author Will Reynolds
 */
function ResponseHandler() {
}

/**
 * Handles a request response. It will determine if the response should be handled as a success or failure depending
 * on the response code. It filters out responses that are not a completed request (status 4).
 * @param response the response.
 */
ResponseHandler.prototype.handleResponse = function (response) {
    //If the request response is not completed, ignore it
    if (response.readyState !== 4) {
        return;
    }
    //Determine if the request was successful or not
    if (response.status === 200) {
        this.handleSuccess(response);
    } else {
        this.handleError(response);
        throw new Error(response.responseText);
    }
};

/**
 * Interface method for handling a successful request
 * @param response the response returned
 */
ResponseHandler.prototype.handleSuccess = function (response) {
    throw new Error("handleSuccess not implemented in a ResponseHandler");
};

/**
 * Interface method for handling a failed request
 * @param response the response returned
 */
ResponseHandler.prototype.handleError = function (response) {
    throw new Error("handleError not implemented in a ResponseHandler");
};

/**
 * A customizable response handler that utilizes callbacks for processing success and failure.
 * @constructor
 * @author Will Reynolds
 */
function CustomResponseHandler() {
    this.successHandler = null;
    this.errorHandler = null;
}

CustomResponseHandler.prototype = new ResponseHandler();
CustomResponseHandler.prototype.constructor = ResponseHandler;

/**
 * Called upon a successful request. If there is a success callback, it is used.
 * @param response the response returned by the request.
 */
CustomResponseHandler.prototype.handleSuccess = function (response) {
    if (this.successHandler) {
        this.successHandler(response);
    }
};

/**
 * Called upon a failed request. If there is a failure callback, it is used.
 * @param response the response returned by the request.
 */
CustomResponseHandler.prototype.handleError = function (response) {
    if (this.errorHandler) {
        this.errorHandler(response);
    }
};

/**
 * Sets the success callback handler.
 * @param handler the callback handler.
 */
CustomResponseHandler.prototype.setSuccessHandler = function (handler) {
    if (typeof handler !== "function") {
        throw new Error("Called setSuccessHandler on ResponseHandler with non function type for handler parameter");
    }
    this.successHandler = handler;
};

/**
 * Sets the error callback handler.
 * @param handler the callback handler.
 */
CustomResponseHandler.prototype.setErrorHandler = function (handler) {
    if (typeof handler !== "function") {
        throw new Error("Called setFailureHandler on ResponseHandler with non function type for handler parameter");
    }
    this.errorHandler = handler;
};

/**
 * A RequestTimer object to wrap the slatimer logic.
 * @return {RequestTimer} returns self.
 * @constructor
 * @author Will Reynolds
 */
function RequestTimer() {
    this.timerName = null;
    this.subTimerName = null;
    this.metaData1 = null;
    this.metaData2 = null;
    this.metaData3 = null;
    this.slaTimer = null;
    return this;
}

/**
 * Set the primary name of the timer.
 * @param timerName the name of the timer.
 * @return {RequestTimer} returns self.
 */
RequestTimer.prototype.setTimerName = function(timerName) {
    this.timerName = timerName;
    return this;
};

/**
 * Set the sub name of the timer.
 * @param subTimerName the timer sub-name.
 * @return {RequestTimer} returns self.
 */
RequestTimer.prototype.setSubTimerName = function(subTimerName) {
    this.subTimerName = subTimerName;
    return this;
};

/**
 * Sets the first metadata for the timer.
 * @param metaData1 the first metadata for the timer.
 * @return {RequestTimer} returns self.
 */
RequestTimer.prototype.setMetaData1 = function(metaData1) {
    this.metaData1 = metaData1;
    return this;
};

/**
 * Sets the second metadata for the timer.
 * @param metaData2 the second metadata for the timer.
 * @return {RequestTimer} returns self.
 */
RequestTimer.prototype.setMetaData2 = function(metaData2) {
    this.metaData2 = metaData2;
    return this;
};

/**
 * Sets the third metadata for the timer.
 * @param metaData3 the third metadata for the timer.
 * @return {RequestTimer} returns self.
 */
RequestTimer.prototype.setMetaData3 = function(metaData3) {
    this.metaData3 = metaData3;
    return this;
};

/**
 * Starts the timer running. This calls the MP_Util method to create the timer object, which also
 * starts the timer.
 */
RequestTimer.prototype.start = function() {
    MP_Util.LogInfo("<b>Timer Started</b><br /><ul>" +
        "<li>timer_name: " + this.timerName +"</li></ul>");
    this.slaTimer = MP_Util.CreateTimer(this.timerName, this.subTimerName, this.metaData1, this.metaData2, this.metaData3);
};

/**
 * Attempts to stop the slatimer (if it exists), otherwise it will simply return.
 */
RequestTimer.prototype.stop = function() {
    if(!this.slaTimer) {
        return;
    }
    MP_Util.LogInfo("<b>Timer Stopped</b><br /><ul>" +
        "<li>timer_name: " + this.timerName +"</li></ul>");
    this.slaTimer.Stop();
};

/**
 * Attempts to abort the slatimer (if it exists), otherwise it will simply return.
 */
RequestTimer.prototype.abort = function() {
    if(!this.slaTimer) {
        return;
    }
    MP_Util.LogInfo("<b>Timer Aborted</b><br /><ul>" +
        "<li>timer_name: " + this.timerName +"</li></ul>");
    this.slaTimer.Abort();
    this.slaTimer = null;
};
/**
 * SidePanel.js
 * @author Karoline Checkett
 *
 * SidePanel class
 * ============================================================================
 *
 * Creates generic rectangular area to display whatever is necessary for a particular component.
 * The size and ability to turn on/off hover functionality can be adjusted. If the hover is on, 
 * an expand bar will show up upon hover (if more info needs to be shown in the panel). Once clicked,
 * the panel will expand and show a collapse bar. A scroll bar will appear if more info is still outside
 * the viewable area. Click outside the panel or on the collapse bar to collapse the panel back to normal.
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new SidePanel object
 * 
 * @name SidePanel
 * @namespace
 */
SidePanel = function() {
	this.m_uniqueId = null;
	this.m_panelId = null;
	this.m_containerElementId = null;

	// The consuming artifact can set this to be one of the values in the
	// expandOption enumerated types
	// at the bottom of this class. The current choices are non-expanding (NONE)
	// and expand-down (EXPAND_DOWN).
	this.m_expandOption = this.expandOption.NONE;

	// This variable is for when the expand option is set to NONE. Then this
	// variable should be set to true if
	// scrolling is wanted (if there isn't enough space on the screen) or false
	// if scrolling is not wanted.
	this.m_fullPanelScrollOn = true;

	// This variable will be used to validate any heights or widths that are
	// passed in
	this.m_regexHeightWidth = /^(\d+((px)|%){1})$/;

	// set a default side-panel size just in case the parent doesn't set them
	this.m_height = "175px";
	this.m_width = "100%";
	this.m_maxHeight = null;
	this.m_minHeight = "175px";
	this.m_previousMinHeight = null;

	// additional functions for the events on the panel
	this.m_mouseEnterFunc = null;
	this.m_mouseLeaveFunc = null;
	this.m_onExpandFunc = null;
	this.m_onCollapseFunc = null;
	//this.m_focusOutFunc = null;

	// hold cached DOM objects for panel parts
	this.m_parentContainer = null;
	this.m_sidePanelObj = null;
	this.m_sidePanelContents = null;
	this.m_sidePanelBodyContents = null;
	this.m_scrollContainer = null;
	this.m_expCollapseIconObj = null;
	this.m_expCollapseBarObj = null;
	this.m_sidePanelHeader = null;
	this.m_headerTitleObj = null;
	this.m_subtitleObj = null;
	this.m_closeButton = null;
	this.m_closeFunction = null;
	this.m_cornerCloseButton = null;
	this.m_cornerCloseFunction = null;
	this.m_usingUpdatedPanel = false;
	this.m_applyBodyContentsPadding = false;
};

// ------------------------------------------------------------------------
// Getters and Setters
// ------------------------------------------------------------------------
/**
 * Returns the unique id for the side panel
 * 
 * @returns {string|number} the unique id for the side panel
 */
SidePanel.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets the unique id for the side panel
 * 
 * @param {string|number}
 *            uniqueId The unique id for the side panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setUniqueId = function(uniqueId) {
	if (!uniqueId || (typeof uniqueId !== "string" && typeof uniqueId !== "number")) {
		logger.logError("Parameter uniqueId must be of type string or number for the SidePanel.setUniqueId function.");
		return;
	}

	this.m_uniqueId = uniqueId;
	this.m_panelId = 'sidePanel' + uniqueId;
	return this;
};

/**
 * Returns the container element id for the side panel
 * 
 * @returns {string} the container element id for the side panel
 */
SidePanel.prototype.getContainerElementId = function() {
	return this.m_containerElementId;
};

/**
 * Sets the container element id for the side panel
 * 
 * @param {string}
 *            containerElementId The container element id for the side panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setContainerElementId = function(containerElementId) {
	if (!containerElementId || typeof containerElementId !== "string") {
		logger.logError("Parameter containerElementId must be of type string for the SidePanel.setContainerElementId function.");
		return;
	}

	this.m_containerElementId = containerElementId;
	return this;
};

/**
 * Returns the function for the expand option chosen
 * 
 * @returns {SidePanel.expandOption} the option set for expanding the panel
 */
SidePanel.prototype.getExpandOption = function() {
	return this.m_expandOption;
};

/**
 * Sets the type of expand option chosen (NONE or EXPAND_DOWN)
 * 
 * @param {SidePanel.expandOption}
 *            expandOption The option set for expanding the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setExpandOption = function(expandOption) {
	var valid = false;

	// ensure passed expandOption is one of the below types
	for (key in this.expandOption) {
		var func = this.expandOption[key];
		if (expandOption === func) {
			valid = true;
			break;
		}
	}

	// if not valid option, throw error
	if (!valid) {
		logger.logError("Parameter expandOption must be of type SidePanel.expandOption for the SidePanel.setExpandOption function.");
		return;
	}

	this.m_expandOption = expandOption;
	return this;
};

/**
 * Returns true or false which ever was set for turning on full-panel scrolling.
 * Only relevant when the expandOption is set to NONE.
 * 
 * @returns {boolean} whether full panel scrolling is on or not
 */
SidePanel.prototype.getFullPanelScrollOn = function() {
	return this.m_fullPanelScrollOn;
};

/**
 * Sets true or false for turning on full-panel scrolling. Only relevant when
 * the expandOption is set to NONE.
 * 
 * @param {boolean}
 *            scrollOn Whether full panel scrolling is on or not
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setFullPanelScrollOn = function(scrollOn) {
	if (typeof scrollOn !== "boolean") {
		logger.logError("Parameter scrollOn must be of type boolean for the SidePanel.setFullPanelScrollOn function.");
		return;
	}
	this.m_fullPanelScrollOn = scrollOn;
	return this;
};

/**
 * Returns the set width for the side panel.
 * 
 * @returns {string} the current value for width
 */
SidePanel.prototype.getWidth = function() {
	return this.m_width;
};

/**
 * Sets the width for the side panel.
 * 
 * @param {string}
 *            newWidth The new value for width in string format with "###px" or
 *            "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setWidth = function(newWidth) {
	if (!this.m_regexHeightWidth.test(newWidth)) {
		logger.logError("Parameter newWidth must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setWidth function.");
		return;
	}

	this.m_width = newWidth;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			width : this.m_width
		});
	}
	return this;
};

/**
 * Returns the set height for the side panel.
 * 
 * @returns {string} the current value for height
 */
SidePanel.prototype.getHeight = function() {
	return this.m_height;
};

/**
 * Sets the height for the side panel.
 * 
 * @param {string}
 *            newHeight The new value for height in string format with "###px"
 *            or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setHeight = function(newHeight) {
	if (!this.m_regexHeightWidth.test(newHeight)) {
		logger.logError("Parameter newHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setHeight function.");
		return;
	}

	this.m_height = newHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			height : this.m_height
		});
	}
	return this;
};

/**
 * Returns the set max height for the side panel.
 * 
 * @returns {string} the current value for max height
 */
SidePanel.prototype.getMaxHeight = function() {
	return this.m_maxHeight;
};

/**
 * Sets the max height for the side panel.
 * 
 * @param {string}
 *            newMaxHeight The new value for max height in string format with
 *            "###px" or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setMaxHeight = function(newMaxHeight) {
	if (!this.m_regexHeightWidth.test(newMaxHeight)) {
		logger.logError("Parameter newMaxHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setMaxHeight function.");
		return;
	}

	this.m_maxHeight = newMaxHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			"max-height" : this.m_maxHeight
		});
	}
	return this;
};

/**
 * Returns the set min height for the side panel.
 * 
 * @returns {string} the current value for min height
 */
SidePanel.prototype.getMinHeight = function() {
	return this.m_minHeight;
};

/**
 * Sets the min height for the side panel.
 * 
 * @param {string}
 *            newMinHeight The new value for min height in string format with
 *            "###px" or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setMinHeight = function(newMinHeight) {
	if (!this.m_regexHeightWidth.test(newMinHeight)) {
		logger.logError("Parameter newMinHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setMinHeight function.");
		return;
	}

	this.m_minHeight = newMinHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			"min-height" : this.m_minHeight
		});
	}
	return this;
};

/**
 * Returns the users function chosen to be executed after expanding the side
 * panel
 * 
 * @returns {function} the function for expanding the panel
 */
SidePanel.prototype.getOnExpandFunction = function() {
	return this.m_onExpandFunc;
};

/**
 * Sets the users function to be executed after expanding the side panel
 * 
 * @param {function}
 *            func The function to execute after expanding the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setOnExpandFunction = function(func) {
	if (typeof func !== "function") {
		logger.logError("Parameter func must be of type function for the SidePanel.setOnExpandFunction.");
		return;
	}

	this.m_onExpandFunc = func;
	return this;
};

/**
 * Returns the users function chosen to be executed after collapsing the side
 * panel
 * 
 * @returns {function} the function for collapsing the panel
 */
SidePanel.prototype.getOnCollapseFunction = function() {
	return this.m_onCollapseFunc;
};

/**
 * Sets the users function to be executed after collapsing the side panel
 * 
 * @param {function}
 *            func The function to execute after collapsing the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setOnCollapseFunction = function(func) {
	if (typeof func !== "function") {
		logger.logError("Parameter func must be of type function for the SidePanel.setOnCollapseFunction.");
		return;
	}

	this.m_onCollapseFunc = func;
	return this;
};

/**
 * Returns the users function chosen to be executed after the side panel loses
 * focus
 * 
 * @returns {function} the function for the side panel losing focus
 */
/*SidePanel.prototype.getFocusOutFunction = function() {
	return this.m_focusOutFunc;
};*/

/**
 * Sets the users function to be executed after the side panel loses focus
 * 
 * @param {function}
 *            func The function to execute after the side panel loses focus
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
/*SidePanel.prototype.setFocusOutFunction = function(func) {
	if (typeof func !== "function") {
		throw new Error(
				"Parameter func must be of type function for the SidePanel.setFocusOutFunction.");
	}

	this.m_focusOutFunc = func;
	return this;
};*/

// ------------------------------------------------------------------------
// Main Functions
// ------------------------------------------------------------------------
/**
 * Renders the base HTML for an empty side-panel. Set height and width before
 * calling this if you want to use an empty panel.
 */
SidePanel.prototype.renderSidePanel = function() {
	// check if side-panel has been rendered, if so do nothing
	if (this.m_sidePanelContents) {
		return;
	}

	if (!this.m_containerElementId) {
		logger.logError("Container element id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}

	this.m_parentContainer = $("#" + this.m_containerElementId);
	if (!this.m_parentContainer.length) {
		logger.logError("Container element object for side panel not found to use in the SidePanel.renderSidePanel function.");
		return;
	}

	if (!this.m_uniqueId) {
		logger.logError("Unique id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}
	var uniqueId = this.m_uniqueId;
	var panelDivHTML = "<div id='"
			+ this.m_panelId
			+ "' class='side-panel'><div id='closeButton"
			+ uniqueId
			+ "' class='sp-close-btn'>&nbsp;</div><div id='sidePanelContents"
			+ uniqueId
			+ "' class='sp-all-contents'>&nbsp;</div><div id='sidePanelExpandCollapse"
			+ uniqueId
			+ "' class='sp-expand-collapse hidden'><div id='sidePanelExpandCollapseIcon"
			+ uniqueId + "'>&nbsp;</div></div></div>";
	this.m_parentContainer.html(panelDivHTML);

	// query to populate reusable DOM objects
	this.m_sidePanelObj = $("#" + this.m_panelId);
	this.m_sidePanelContents = $("#sidePanelContents" + uniqueId);
	this.m_sidePanelBodyContents = $("#sidePanelContents" + uniqueId); //set this one to be the same for passivity
	this.m_closeButton = $("#closeButton" + uniqueId);

	// adjust panel to desired height and width, the setters adjust the css
	this.setHeight(this.m_height);
	this.setWidth(this.m_width);
	if (this.m_minHeight) {
		this.m_sidePanelObj.css("min-height", this.m_minHeight);
	}
	this.m_closeButton.hide();
};

/**
 * Renders the inner HTML in the side-panel
 * 
 * @param {string|jQuery}
 *            contents A string or jQuery object with the contents for the
 *            side-panel
 */
SidePanel.prototype.setContents = function(contents) {
	// check if side-panel has been rendered, if not call renderSidePanel
	if (!this.m_sidePanelContents) {
		this.renderSidePanel();
	}

	// render panel contents based on type passed in
	if (typeof contents === "string" && contents.length) {
		// use .html to clean up any event listeners from previous content
		this.m_sidePanelContents.html(contents);
	} else if (contents instanceof jQuery) {
		// clean up event listeners and clear content
		this.m_sidePanelContents.empty();
		// append new content
		this.m_sidePanelContents.append(contents);
	} else {
		logger.logError("Parameter contents must be of type string or jQuery Object for the SidePanel.setContents function.");
		return;
	}

	this.m_scrollContainer = $("#sidePanelScrollContainer" + this.m_uniqueId);

	// if an expand option was chosen, call that function
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		if (!this.m_maxHeight) {
			logger.logError("Max height must be set for use in SidePanel.setContents when an expand option is used.");
			return;
		}
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight); 
		this.m_expandOption.call(this);
	} else {
		// when default or none, set height to auto so it shows all content
		this.m_sidePanelObj.css("height", "auto");
		// still need to handle resize, unless pref turned off
		if (this.m_fullPanelScrollOn) {
			if (!this.m_maxHeight) {
				logger.logError("Max height must be set for use in SidePanel.setContents when full panel scrolling is turned on.");
				return;
			}
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/*********************** Functions for the pre-built side panel *********************************/
/**
 * Renders the base HTML for a side panel with a pre-built header. Set height and width before
 * calling this if you want to use an empty panel.
 */
SidePanel.prototype.renderPreBuiltSidePanel = function() {
	// check if side-panel has been rendered, if so do nothing
	if (this.m_sidePanelContents) {
		return;
	}

	if (!this.m_containerElementId) {
		logger.logError("Container element id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}

	this.m_parentContainer = $("#" + this.m_containerElementId);
	if (!this.m_parentContainer.length) {
		logger.logError("Container element object for side panel not found to use in the SidePanel.renderSidePanel function.");
		return;
	} 

	if (!this.m_uniqueId) {
		logger.logError("Unique id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}
	
	this.m_usingUpdatedPanel = true; //this flag will be used in pre-existing functions to allow for passivity


	var uniqueId = this.m_uniqueId;
	var panelDivHTML = "<div id='" + this.m_panelId + "' class='side-panel'>"
		+ "<div id='sidePanelContents" + uniqueId + "'>"
		+ "<div id='sidePanelHeader" + uniqueId + "' class='sp-header2'>"
		+ "<div id='sidePanelActionBar" + uniqueId + "' class='sp-action-bar'>"
		+ "<div id='sidePanelActions" + uniqueId + "' class='sp-actions'>&nbsp;</div><div id='cornerCloseButton" + uniqueId + "' class='sp-close-btn2'>&nbsp;</div>"
		+ "</div><div id='sidePanelHeaderText" + uniqueId + "' class='sp-header-text'>&nbsp;</div>"
		+ "<div id='sidePanelSubtitle" + uniqueId + "' class='sp-subtitle secondary-text'>&nbsp;</div><div id='sidePanelAlertBanner" + uniqueId + "' class='sp-alert-banner'>&nbsp;</div>"
		+ "</div><div class='sp-separator2'>&nbsp;</div><div id='sidePanelBodyContents" + uniqueId + "' class=''>&nbsp;</div>"
		+ "</div><div id='sidePanelExpandCollapse" + uniqueId + "' class='sp-expand-collapse2 hidden'><div id='sidePanelExpandCollapseIcon" + uniqueId + "' class='sp-expand'>&nbsp;</div></div>"
		+ "</div>";
	this.m_parentContainer.html(panelDivHTML);

	// query to populate reusable DOM objects
	this.m_sidePanelObj = $("#" + this.m_panelId);
	this.m_sidePanelBodyContents = $("#sidePanelBodyContents" + uniqueId);
	this.m_sidePanelContents = $("#sidePanelContents" + uniqueId);
	this.m_sidePanelHeader = $("#sidePanelHeader" + uniqueId);
	this.m_cornerCloseButton = $("#cornerCloseButton" + uniqueId);
	this.m_headerTitleObj = $("#sidePanelHeaderText" + uniqueId);
	this.m_subtitleObj = $("#sidePanelSubtitle" + uniqueId);
	this.m_sidePanelActionsObj = $("#sidePanelActions" + uniqueId);
	this.m_sidePanelAlertBanner = $("#sidePanelAlertBanner" + uniqueId);

	// adjust panel to desired height and width, the setters adjust the css
	this.setHeight(this.m_height);
	this.setWidth(this.m_width);
	if (this.m_minHeight) {
		this.m_sidePanelObj.css("min-height", this.m_minHeight);
	}
	this.m_cornerCloseButton.hide();
	this.m_subtitleObj.addClass("hidden");
	this.m_sidePanelAlertBanner.addClass("hidden");
};

/**
 * Sets the title text in the side panel
 * 
 * @param {string}
 *            titleString A string with the text for the side-panel header
 */
SidePanel.prototype.setTitleText = function(titleString) {
	if (!this.m_headerTitleObj) {
		logger.logError("Side panel title object cannot be found.");
		return;
	}
	
	this.m_headerTitleObj.text(titleString);
};

/**
 * Sets the sub title text in the side panel as a plain string
 * 
 * @param {string}
 *            subtitleString A string with the text for the side-panel subtitle
 */
SidePanel.prototype.setSubtitleText = function(subtitleString) {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}
	
	this.m_subtitleObj.text(subtitleString);
	this.m_subtitleObj.removeClass("hidden");
};

/**
 * Sets the sub title text in the side panel as an HTML string
 * 
 * @param {string}
 *            subtitleHTML An HTML string with the html build for the side-panel subtitle
 */
SidePanel.prototype.setSubtitleAsHTML = function(subtitleHTML) {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}
	
	this.m_subtitleObj.html(subtitleHTML);
	this.m_subtitleObj.removeClass("hidden");
};

/**
 * Hides the sub title text in the side panel
 * 
 */
SidePanel.prototype.removeSubtitle = function() {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}

	this.m_subtitleObj.addClass("hidden");
};

/**
 * Sets the action items in the side panel as an HTML string
 * 
 * @param {string}
 *            actionHTML An HTML string with the html build for the side-panel actions
 */
SidePanel.prototype.setActionsAsHTML = function(actionHTML) {
	if (!this.m_sidePanelActionsObj) {
		logger.logError("Side panel action bar object cannot be found.");
		return;
	}
	
	this.m_sidePanelActionsObj.html(actionHTML);
};

/**
 * Sets the alert banner in the side panel as an HTML string
 * 
 * @param {string}
 *            bannerHTML An HTML string with the html build for the side-panel alert banner
 */
SidePanel.prototype.setAlertBannerAsHTML = function(bannerHTML) {
	if (!this.m_sidePanelAlertBanner) {
		logger.logError("Side panel alert banner object cannot be found.");
		return;
	}
	
	this.m_sidePanelAlertBanner.html(bannerHTML);
	this.m_sidePanelAlertBanner.removeClass("hidden");
	this.m_sidePanelObj.addClass("sp-alert-banner-showing");
};

/**
 * Hides the alert banner in the side panel
 * 
 */
SidePanel.prototype.removeAlertBanner = function() {
	if (!this.m_sidePanelAlertBanner) {
		logger.logError("Side panel alert banner object cannot be found.");
		return;
	}

	this.m_sidePanelAlertBanner.addClass("hidden");
	this.m_sidePanelObj.removeClass("sp-alert-banner-showing");
};

/**
 * Option to display the corner close side-panel button
 */
SidePanel.prototype.showCornerCloseButton = function() {
	if(!this.m_cornerCloseButton) {
		logger.logError("Corner close button is not defined");
		return;
	}		
	this.m_cornerCloseButton.removeAttr('style'); //clears out the inline style and displays the button
};

/**
 * Returns the function to be executed when the corner close button is clicked
 * 
 * @returns {SidePanel.m_cornerCloseFunction} the function to close the side panel
 */
SidePanel.prototype.getCornerCloseFunction = function() {
	return this.m_cornerCloseFunction;
};

/**
 * Sets the close function
 * 
 * @param {closeFunction}
 *            closeFunction The function which is executed when we click on the corner close button 
 */
SidePanel.prototype.setCornerCloseFunction = function(closeFunction) {
	if(closeFunction instanceof Function) {
		this.m_cornerCloseFunction = closeFunction;
	} else {
		logger.logError("Corner close function must be of type 'Function'.");
		return;
	}
};

/**
 * Shows or hides the expand bar based on need to show more of side panel body
 */
SidePanel.prototype.showHideExpandBar = function() {
	if (this.m_usingUpdatedPanel && this.m_sidePanelObj[0].offsetHeight) {
		var sidePanelBody = document.getElementById("sidePanelBodyContents" + this.m_uniqueId);
		var visibleSidePanelHeight = this.m_sidePanelObj[0].offsetHeight;
		var titleHeight = this.m_sidePanelHeader[0].offsetHeight;
		var visibleBodyHeight = 0;
		
		if (titleHeight < visibleSidePanelHeight) {
			visibleBodyHeight = visibleSidePanelHeight - titleHeight;
		} else {
			this.m_expCollapseBarObj.removeClass("hidden");
		}
		
		if (visibleBodyHeight && sidePanelBody.scrollHeight > visibleBodyHeight) {
			this.m_expCollapseBarObj.removeClass("hidden");
		} else if (visibleBodyHeight && visibleBodyHeight >= sidePanelBody.scrollHeight) {
			this.m_expCollapseBarObj.addClass("hidden");
		}
	}
};

/**
 * Returns the value of whether or not padding should be removed from the sp-body-contents-padding div
 * 
 * @return {Boolean} whether the padding in side panel body contents should be removed
 */
SidePanel.prototype.getApplyBodyContentsPadding = function() {
	return this.m_applyBodyContentsPadding;
};

/**
 * Sets the variable that removes the body contents padding
 *
 * @param {string}
 *            this.m_applyBodyContentsPadding A boolean flag to turn the padding in the side panel on or off
 *
 * @return {Undefined}
 */
SidePanel.prototype.setApplyBodyContentsPadding = function(applyBodyContentsPadding) {
	if(typeof(applyBodyContentsPadding) === "boolean") {
		this.m_applyBodyContentsPadding = applyBodyContentsPadding;
	} else {
		logger.logError("applyBodyContentsPadding must be of type 'Boolean'.");
		return;
	}
};


/*********************** END OF Functions for the pre-built side panel *********************************/

/**
 * Calls the appropriate function to handle resizing the panel based on which
 * type of panel it is.
 * 
 * @param {string}
 *            maxHeight A string to represent the maximum height available for
 *            the side panel to expand in string format with "###px" or "###%"
 *            as the format
 */
SidePanel.prototype.resizePanel = function(maxHeight) {
	if (!this.m_regexHeightWidth.test(maxHeight)) {
		logger.logError("Parameter maxHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.resizePanel function.");
		return;
	}

	this.m_maxHeight = maxHeight;

	// Call resize function based on which type of panel is built
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		
		this.showHideExpandBar();
		
		this.collapseSidePanel();
	} else {
		// when default or none, still need to handle resize, unless pref turned
		// off
		if (this.m_fullPanelScrollOn) {
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/**
 * This will be called if expand is turned off for the panel and full panel
 * scroll is turned on. This function will put a scroll bar on the panel if its
 * contents exceed the height of the window view.
 */
SidePanel.prototype.fullPanelScroll = function() {
	if (!this.m_scrollContainer.length) {
		logger.logError("Scroll container object for side panel not found for use in SidePanel.fullPanelScroll.");
		return;
	}
	if (!this.m_maxHeight) {
		logger.logError("Max height for side panel not set for use in SidePanel.fullPanelScroll.");
		return;
	}

	// Reset any previous max-height to allow panel to expand again
	if (this.m_scrollContainer.css("max-height") !== "none") {
		this.m_scrollContainer.css("max-height", "none");
	}
	
	var titleHeight = null;
	
	// set up for scrolling the panel if contents exceed panel height
	if (this.m_usingUpdatedPanel) {
		var bodyContentHeight = this.m_sidePanelBodyContents[0].offsetHeight;
		titleHeight = this.m_sidePanelContents.height() - bodyContentHeight;
	} else {
		var contentHeight = this.m_sidePanelContents[0].offsetHeight;
		titleHeight = contentHeight - this.m_scrollContainer.height();
	}

	// Set height to auto so it will expand to show contents
	this.m_sidePanelObj.css({
		"height" : "auto"
	});
	// Incrementing scrollMaxHeight to prevent issues when the content is the
	// same height as the max (its finicky)
	var scrollMaxHeight = (this.m_sidePanelObj.height() - titleHeight) + 1;

	// To enable the scroll bar, set the max-height. Need px here for other
	// check below to be number
	this.m_scrollContainer.css("max-height", scrollMaxHeight + "px");
	
	if (scrollMaxHeight === this.m_scrollContainer.height()) {
		this.m_scrollContainer.addClass("sp-add-scroll");
	} else {
		this.m_scrollContainer.removeClass("sp-add-scroll");
	}

};

/**
 * Register the following events: 1. side-panel mouse enter/leave 2. Side Panel
 * focus-out
 */
SidePanel.prototype.expandDownListeners = function() {
	// If the side panel object is not found, do nothing
	if (this.m_sidePanelObj === null) {
		return;
	}

	var uniqueId = this.m_uniqueId;
	var self = this;
	var expCollapseBarId = "#sidePanelExpandCollapse" + uniqueId;

	// Register the mouse enter event for side-panel to show the expand/collapse
	// bar.
	this.m_expCollapseIconObj = $("#sidePanelExpandCollapseIcon" + uniqueId);
	this.m_expCollapseBarObj = $(expCollapseBarId);
	var scrollContainer = null;
	var ppId = "#" + this.m_panelId;
	
	//remove all event handlers from sidePanelObj
	this.m_sidePanelObj.off();
	
	//only if the panel is not expanded, call showHideExpandBar
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		this.showHideExpandBar();
	}
	
	// When the user hovers over the side-panel, if the content exceeds the
	// height of the side-panel,
	// an expand/collapse control is presented.
	if (!this.m_usingUpdatedPanel) {
		this.m_sidePanelObj.on("mouseenter", function() {
			// if the exp/coll bar is visible, do not carry on this code
			if (!self.m_expCollapseBarObj.hasClass("hidden")) {
				return;
			}

			// Have to requery this DOM object because it could be different than
			// before (i.e. exp/clps options within content)
			scrollContainer = $("#sidePanelScrollContainer" + uniqueId);

			// If the side-panel info is overflowed or has a scroll bar, show the
			// expand icon
			if ((this.scrollHeight > this.offsetHeight) || scrollContainer.hasClass("sp-add-scroll")) {
				self.m_expCollapseIconObj.addClass("sp-expand").removeClass("sp-collapse");
				// make the section visible.
				self.m_expCollapseBarObj.removeClass("hidden");
			}

			if (self.m_mouseEnterFunc) {
				self.m_mouseEnterFunc();
			}
		});

		// Register the mouse leave event for side-panel to hide the expand/collapse
		// bar.
		this.m_sidePanelObj.on("mouseleave", function() {

			if (self.m_expCollapseIconObj.hasClass("sp-expand")) {
				// Hide the section.
				self.m_expCollapseBarObj.addClass("hidden");
			}

			if (self.m_mouseLeaveFunc) {
				self.m_mouseLeaveFunc();
			}
		});
	}

	this.m_sidePanelObj.on("click", expCollapseBarId, function(event) {
		self.expandCollapseSidePanel();
	});

	// Set the tabindex to -1 so clicking outside the component causes focusout
	// to get triggered.
	/*this.m_sidePanelObj.attr("tabindex", -1);
	this.m_sidePanelObj.on("focusout", function(event) {
		var toElem = event.relatedTarget;
		if (!($(toElem).closest(self.m_sidePanelObj).length)) {
			self.collapseSidePanel();
	
			if (self.m_focusOutFunc) {
				self.m_focusOutFunc();
			}
		}
	});*/
	
	//If the side panel is already expanded, call expandSidePanel to get a scroll bar if needed
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		this.expandSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse bar in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page. Reset the above on collapse.
 */
SidePanel.prototype.expandCollapseSidePanel = function() {
	// If the side panel object is not found, do nothing
	if (!this.m_sidePanelObj.length) {
		return;
	}

	// Expand the side panel to show all of its contents, it more contents than
	// space, scroll
	if (this.m_expCollapseIconObj.hasClass("sp-expand")) {
		this.expandSidePanel();
	}
	// Collapse the side panel back to previous height before expanding
	else {
		this.collapseSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page.
 */
SidePanel.prototype.expandSidePanel = function() {
	//if the side panel is not already expanded, then set up the missing pieces
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		//Add expand bar if it is not currently showing
		this.m_expCollapseBarObj.removeClass("hidden");
		
		// Upon expand, absolute positioning is applied to allow the side panel to
		// expand over other content
		this.m_parentContainer.css({
			position : "absolute"
		});
		
		// Add the styles like shadow.
		this.m_sidePanelObj.addClass("sp-focusin");
		
		// Replace the expand-collapse icon
		this.m_expCollapseIconObj.addClass("sp-collapse").removeClass("sp-expand");
	}
	
	//Set panel obj to have min-height that matches the current panel height (so it does not "expand" shorter)
	this.m_previousMinHeight = this.m_minHeight;
	
	//convert the "45px" strings to their respective int values 45
	var heightVal = parseInt(this.m_height, 10);
	var minHeightVal = parseInt(this.m_minHeight, 10);
	
	if (heightVal > minHeightVal) {
		this.setMinHeight(this.m_height);
	}
	
	//Remove the max-height if its already on the scroll container, otherwise it will not expand to full size
	this.m_scrollContainer.css("max-height", "");
	
	var titleHeight = null;
	
	// set up for scrolling the panel if contents exceed panel height
	if (this.m_usingUpdatedPanel) {
		var bodyContentHeight = this.m_sidePanelBodyContents[0].offsetHeight;
		titleHeight = this.m_sidePanelContents.height() - bodyContentHeight;
	} else {
		var contentHeight = this.m_sidePanelContents[0].offsetHeight;
		titleHeight = contentHeight - this.m_scrollContainer.height();
	}

	// Set height to auto so it will expand to show contents
	this.m_sidePanelObj.css({
		"height" : "auto"
	});

	// Incrementing scrollMaxHeight to prevent issues when the content is the
	// same height as the max (its finicky)
	var scrollMaxHeight = (this.m_sidePanelObj.height() - titleHeight) + 1;

	// To enable the scroll bar, set the max-height. Need px here for other
	// check below to be number
	this.m_scrollContainer.css("max-height", scrollMaxHeight + "px");
	
	if (scrollMaxHeight === this.m_scrollContainer.outerHeight()) {
		this.m_scrollContainer.addClass("sp-add-scroll");
	}

	if (this.m_onExpandFunc) {
		this.m_onExpandFunc();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On collapse, set reset height for scroll container.
 */
SidePanel.prototype.collapseSidePanel = function() {
	// collapse panel only if it is expanded
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		// Revert the positioning of the side-panel
		this.m_parentContainer.css({
			position : "relative"
		});

		// Set the height of the pane as previous height
		this.m_sidePanelObj.css("height", this.m_height);

		// To disable the scroll bar, set the overflow as hidden and remove the
		// max-height.
		this.m_scrollContainer.css("max-height", "none");
		this.m_scrollContainer.removeClass("sp-add-scroll");
		
		if (this.m_usingUpdatedPanel) {
			// Remove collapse icon, put expand back
			this.m_expCollapseIconObj.removeClass("sp-collapse").addClass("sp-expand");
		} else {
			// Remove collapse icon
			this.m_expCollapseIconObj.removeClass("sp-collapse");
			// Hide the section
			this.m_expCollapseBarObj.addClass("hidden");
		}

		// Remove the styles like shadow.
		this.m_sidePanelObj.removeClass("sp-focusin");
		
		//show/hide the exp/col bar as necessary
		this.showHideExpandBar();
		
		//reset min height back to what it was before calling expandSidePanel
		this.setMinHeight(this.m_previousMinHeight);
		
		if (this.m_onCollapseFunc) {
			this.m_onCollapseFunc();
		}
	}
};

/**
 * Type of panel being created, more can be added later
 */
SidePanel.prototype.expandOption = {
	NONE : null,
	EXPAND_DOWN : SidePanel.prototype.expandDownListeners
};


/**
 * Option to show the side panel
 */
SidePanel.prototype.showPanel = function() {
	// Show the side panel by removing the display:non property
	this.m_sidePanelObj.show();
};


/**
 * Option to hide the side panel
 */
SidePanel.prototype.hidePanel = function() {
	// hide the side panel by adding the display:non property
	this.m_sidePanelObj.hide();
};


/**
 * Option to display the Close Side Panel button
 */
SidePanel.prototype.showCloseButton = function() {
	if(!this.m_closeButton) {
		logger.logError("Close button is not defined");
		return;
	}		
	this.m_closeButton.show();	
};

/**
 * Returns the function to be executed when close button is clicked
 * 
 * @returns {SidePanel.m_closeFunction} the function to close the side panel
 */
SidePanel.prototype.getCloseFunction = function() {
	return this.m_closeFunction;
};

/**
 * Sets the close function
 * 
 * @param {closeFunction}
 *            closeFunction The function which is executed when we click on the close button 
 */
SidePanel.prototype.setCloseFunction = function(closeFunction) {
	if(closeFunction instanceof Function) {
		this.m_closeFunction = closeFunction;
	}	
};
/**
 * CompSidePanel.js
 * 
 * @author Karoline Checkett
 * 
 * CompSidePanel class
 * ============================================================================
 * 
 * Uses the base SidePanel class and makes it easier for components to
 * implement.
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new component side-panel object
 * 
 * @name CompSidePanel
 * @namespace
 * @param {string}
 *            compId A unique ID for the object containing containing the
 *            side-panel. Likely the component ID.
 * @param {string}
 *            panelElementId The element id that will contain the side-panel.
 */
CompSidePanel = function(compId, panelElementId) {
	this.setUniqueId(compId);
	this.setContainerElementId(panelElementId);
	this.m_compBodyId = null;
	this.m_compBodyObj = null;
	this.m_removeOffsetFromHeight = 0;
};

CompSidePanel.prototype = new SidePanel();
CompSidePanel.prototype.constructor = SidePanel;


/**
 * Sets the offset height needed to be removed for panel height calculations
 * 
 * @param {number}
 *            offsetHeight The extra space in pixels that should be subtracted
 *            from the max height calculations for the side panel
 */
CompSidePanel.prototype.setOffsetHeight = function(offsetHeight) {
	if(isNaN(offsetHeight)) {
		logger.logError("Value passed to setOffsetHeight must be a number");
		return;
	}
	this.m_removeOffsetFromHeight = offsetHeight;
};

/**
 * Renders the inner HTML in the comp-side-panel
 * 
 * @param {string|jQuery}
 *            contents A string or jQuery object with the contents for the
 *            side-panel
 * @param {string}
 *            componentBodyId The id for the contents container in the main body
 *            in the component
 */
CompSidePanel.prototype.setContents = function(contents, componentBodyId) {
	// check if side-panel has been rendered, if not call renderSidePanel
	if (!this.m_sidePanelBodyContents) {
		this.renderSidePanel();
	}
	else{
		if(this.getApplyBodyContentsPadding()){
			this.m_sidePanelBodyContents.addClass('sp-body-contents-padding');
		}
		else{
			this.m_sidePanelBodyContents.removeClass('sp-body-contents-padding');
		}
	}

	// render panel contents based on type passed in
	if (typeof contents === "string" && contents.length) {
		// use .html to clean up any event listeners from previous content
		this.m_sidePanelBodyContents.html(contents);
	} else if (contents instanceof jQuery) {
		// clean up event listeners and clear content
		this.m_sidePanelBodyContents.empty();
		// append new content
		this.m_sidePanelBodyContents.append(contents);
	} else {
		logger.logError("Parameter contents must be of type string or jQuery Object for the SidePanel.setContents function.");
		return;
	}

	this.m_compBodyId = componentBodyId;
	this.m_scrollContainer = $("#sidePanelScrollContainer" + this.m_uniqueId);

	// check if maxHeight has been set yet, if not attempt to set using
	// createDefaultMaxHeight
	if (!this.m_maxHeight) {
		this.createDefaultMaxHeight();
	}

	// if an expand option was chosen, call that function
	if (this.m_expandOption) {
		if (!componentBodyId) {
			logger.logError("Parameter componentBodyId must be specified for the CompSidePanel.setContents function.");
			return;
		}
		this.m_compBodyObj = $("#" + componentBodyId);
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		this.m_expandOption.call(this);
		
	} else {
		// when default or none, set height to auto so it shows all content
		this.m_sidePanelObj.css("height", "auto");
		// still need to handle resize, unless pref turned off
		if (this.m_fullPanelScrollOn) {
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/**
 * Register the following events: 1. side-panel mouse enter/leave 2. Component
 * focus-out Overriding this function to set the focus out on the component,
 * instead of the panel, so you can still click in the component body and the
 * panel wont close
 */
CompSidePanel.prototype.expandDownListeners = function() {
	var uniqueId = this.m_uniqueId;
	var compBodyObj = this.m_compBodyObj;
	var self = this;
	var expCollapseBarId = "#sidePanelExpandCollapse" + uniqueId;
	var closeButton = "#closeButton" + uniqueId;
	var cornerCloseButton = "#cornerCloseButton" + uniqueId;

	// Register the mouse enter event for side-panel to show the expand/collapse
	// bar.
	this.m_expCollapseIconObj = $("#sidePanelExpandCollapseIcon" + uniqueId);
	this.m_expCollapseBarObj = $(expCollapseBarId);
	var scrollContainer = null;
	var ppId = "#" + this.m_panelId;
	
	//remove all event handlers from sidePanelObj and CompBodyObj
	this.m_sidePanelObj.off();
	compBodyObj.off();
	
	//only if the panel is not expanded, call showHideExpandBar
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		this.showHideExpandBar();
	}
	
	// When the user hovers over the side-panel, if the content exceeds the
	// height of the side-panel,
	// an expand/collapse control is presented.
	if (!this.m_usingUpdatedPanel) {
		this.m_sidePanelObj.on("mouseenter", function() {
			// if the exp/coll bar is visible, do not carry on this code
			if (!self.m_expCollapseBarObj.hasClass("hidden")) {
				return;
			}

			// Have to requery this DOM object because it could be different than
			// before (i.e. exp/clps options within content)
			scrollContainer = $("#sidePanelScrollContainer" + uniqueId);

			// If the side-panel info is overflowed or has a scroll bar, show the
			// expand icon
			if ((this.scrollHeight > this.offsetHeight) || scrollContainer.hasClass("sp-add-scroll")) {
				self.m_expCollapseIconObj.addClass("sp-expand");
				self.m_expCollapseIconObj.removeClass("sp-collapse");
				// make the section visible.
				self.m_expCollapseBarObj.removeClass("hidden");
			}

			if (self.m_mouseEnterFunc) {
				self.m_mouseEnterFunc();
			}
		});

		// Register the mouse leave event for side-panel to hide the expand/collapse
		// bar.
		this.m_sidePanelObj.on("mouseleave", function() {

			if (self.m_expCollapseIconObj.hasClass("sp-expand")) {
				// Hide the section.
				self.m_expCollapseBarObj.addClass("hidden");
			}

			if (self.m_mouseLeaveFunc) {
				self.m_mouseLeaveFunc();
			}
		});
	}
	
	// Register the click event for the expand/collapse bar
	this.m_sidePanelObj.on("click", expCollapseBarId, function(event) {
		self.expandCollapseSidePanel();
	});
	
	// Set the tabindex to -1 so clicking outside the component causes focusout
	// to get triggered
	/*compBodyObj.attr("tabindex", -1);
	compBodyObj.on("focusout", function(event) {
		var toElem = event.relatedTarget;
		if (!($(toElem).closest(compBodyObj).length)) {
			self.collapseSidePanel();

			if (self.m_focusOutFunc) {
				self.m_focusOutFunc();
			}
		}
	});*/
	
	if (this.m_usingUpdatedPanel) {
		// Register the click event for the corner close button
		this.m_sidePanelObj.on("click", cornerCloseButton, function(event) {
			if(!self.m_cornerCloseFunction){
				logger.logError("You must set the SidePanel.cornerCloseFunction.");
				return;
			}
			self.collapseSidePanel();
			self.m_sidePanelObj.hide();
			self.getCornerCloseFunction()();
		});
	} else {
		// Register the click event for the close button
		this.m_sidePanelObj.on("click", closeButton, function(event) {
			if(!self.m_closeFunction){
				logger.logError("You must set the SidePanel.closeFunction.");
				return;
			}
			self.collapseSidePanel();
			self.m_sidePanelObj.hide();
			self.getCloseFunction()();
		});
	}
	
	//If the side panel is already expanded, call expandSidePanel to get a scroll bar if needed
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		this.expandSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page.
 */
CompSidePanel.prototype.expandSidePanel = function() {
	// call the base expandSidePanel function
	SidePanel.prototype.expandSidePanel.call(this, null);
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On collapse, set reset height for scroll container.
 */
CompSidePanel.prototype.collapseSidePanel = function() {
	// call the base expandSidePanel function
	SidePanel.prototype.collapseSidePanel.call(this, null);
};

/**
 * This will be called on to attempt to set a default max height, checking to
 * see if the consuming artifact is in a viewpoint. If so, it determines the
 * appropriate maximum height that the panel can expand to.
 */
CompSidePanel.prototype.createDefaultMaxHeight = function() {
	var viewPointBodyObj = $("#vwpBody");
	// extra padding at bottom of pane between window
	var windowPadding = 70;

	// stop calculations if we are not in a viewpoint
	if (!viewPointBodyObj.length) {
		return;
	}

	var maxHeight = (viewPointBodyObj.height() - windowPadding - this.m_removeOffsetFromHeight) + "px";
	this.m_maxHeight = maxHeight;
};

/**
 * Calls the appropriate function to handle resizing the panel based on which
 * type of panel it is.
 * 
 * @param {string}
 *            [maxHeight] A string to represent the maximum height available for
 *            the side panel to expand in string format with "###px" or "###%"
 *            as the format
 */
CompSidePanel.prototype.resizePanel = function(maxHeight) {
	// reset max height to null
	this.m_maxHeight = null;

	// if maxHeight was passed in, attempt to set that as the maxHeight
	if (maxHeight && this.m_regexHeightWidth.test(maxHeight)) {
		this.m_maxHeight = maxHeight;
	}
	// if max height still not set, attempt to set using createDefaultMaxHeight
	else if (!this.m_maxHeight) {
		this.createDefaultMaxHeight();
	}
	// proper one must be passed
	if (!this.m_maxHeight) {
		logger.logError("Parameter maxHeight must match the regex /^(\d+((px)|%){1})$/ for the CompSidePanel.resizePanel function.");
		return;
	}

	// if still in here, Call resize function based on which type of panel is
	// built
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		
		this.showHideExpandBar();	
		
		this.collapseSidePanel();
	} else if (this.m_fullPanelScrollOn) {
		// when default or none, still need to handle resize, unless pref turned
		// off. Set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight); 
		this.fullPanelScroll();
	}
};

/**
 * Type of panel being created, more can be added later
 */
CompSidePanel.prototype.expandOption = {
	NONE : null,
	EXPAND_DOWN : CompSidePanel.prototype.expandDownListeners
};

StandardTemplates = {};
StandardTemplates["CLINICAL_LINK"] = [
    '<span>${ ((EVENT_CD_DISP) ? MP_Util.CreateClinNoteLink(PERSON_ID+".0",ENCNTR_ID+".0",EVENT_ID+".0",EVENT_CD_DISP,VIEWER_TYPE,PARENT_EVENT_ID+".0") : "--") }</span>'
].join('');

/**
 * The TableCellCallbackExtension class
 * This extension is meant to be used to provide a callback to the component
 * when the user clicks on a cell within the component table
 * @return {TableCellClickCallbackExtension} returns self
 * @constructor
 */
function TableCellClickCallbackExtension() {
    this.callback = function(event,data){ return; };
    return this;
}

TableCellClickCallbackExtension.prototype = new TableExtension();
TableCellClickCallbackExtension.prototype.constructor = TableExtension;


/**
 * Sets the callback that is triggered when the user clicks a cell within the component table
 * @param callback the callback function
 * @return {TableCellClickCallbackExtension} return self
 */
TableCellClickCallbackExtension.prototype.setCellClickCallback = function(callback) {
    if(typeof callback !== "function") {
        throw new Error("In TableCellCallbackExtension, attempted to setCallback() with non function type");
    }
    this.callback = callback;
    return this;
};

/**
 * Overrides the finalize method (this is called in the ComponentTable finalize method)
 * and attaches it to the table correctly
 * @param table the ComponentTable this extension belongs to
 */
TableCellClickCallbackExtension.prototype.finalize = function(table) {
    var self = this;
    var namespace = table.getNamespace();
    var resultData = null;
    var columnId = "";
    var data = {};
    $("#" + namespace + "tableBody").on("mouseup", ".table-cell", function(event){
        resultData = ComponentTableDataRetriever.getResultFromTable(table, this);
        columnId = ComponentTableDataRetriever.getColumnIdFromElement(table, this);
        //Set up the data to return via callback
        data = {
            "COLUMN_ID" : columnId,
            "RESULT_DATA" : resultData,
            "SOURCE" : "TableCellClickCallbackExtension:CELL_CLICK"
        };
        self.callback(event, data);
    });
};
/**
 * Defines the TableColumn class
 * This class is simply a column description that tells how a column should behave
 * @constructor
 */
function TableColumn() {
    this.columnDisplay = "&nbsp;";
    this.columnId = "";
    this.customClass = "";
    this.primarySortField = "";
    this.secondarySortFields = [];
    this.isSortable = false;
    this.sortDirection = TableColumn.SORT.NONE;
    this.template = TemplateBuilder.buildTemplate("<span>[Template Not Specified]</span>");       //Initialize with a default template
    this.width = null;
    this.defaultSort = TableColumn.SORT.ASCENDING;
}

/**
 * Gets the display value for the column
 * @return {string} the display for the column (as appears in the header)
 */
TableColumn.prototype.getColumnDisplay = function () {
    return this.columnDisplay;
};

/**
 * Sets the column display (what is shown in the header of the column)
 * @param columnDisplay the string that is to be displayed for the column header
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setColumnDisplay = function (columnDisplay) {
    if (typeof columnDisplay !== "string") {
        throw new Error("Called setColumnDisplay on TableColumn with non string type for columnDisplay parameter");
    }
    this.columnDisplay = columnDisplay;
    return this;
};

/**
 * Gets the ID of the column
 * @return {string} the column ID
 */
TableColumn.prototype.getColumnId = function () {
    return this.columnId;
};

/**
 * Sets the id of the column
 * @param columnId the id of the column
 */
TableColumn.prototype.setColumnId = function (columnId) {
    if(typeof columnId !== "string") {
        throw new Error("Called setColumnId on TableColumn with non string type for columnId parameter");
    }
    this.columnId = columnId;
    return this;
};

/**
 * Gets the custom column class
 * @return {string} the custom column class
 */
TableColumn.prototype.getCustomClass = function () {
    return this.customClass;
};

/**
 * Sets the custom class for the column
 * @param customClass set the column custom class
 */
TableColumn.prototype.setCustomClass = function (customClass) {
    if(typeof customClass !== "string") {
        throw new Error("Called setCustomClass on TableColumn with non string type for customClass parameter");
    }
    this.customClass = customClass;
    return this;
};

/**
 * Gets the default sort order for the column
 * @return {number} the display for the column (as appears in the header)
 */
TableColumn.prototype.getDefaultSort = function () {
    return this.defaultSort;
};

/**
 * Sets the column's default sort order 
 * @param columnDisplay the string that is to be displayed for the column header
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setDefaultSort = function (defaultSort) {
	if (TableColumn.isValidSortDirection(defaultSort)) {
		this.defaultSort = defaultSort;
	}
	return this;
};

/**
 * Gets the value ID used for sorting
 * @return {string} the field in the JSON that we use for sorting
 */
TableColumn.prototype.getPrimarySortField = function () {
    return this.primarySortField;
};

/**
 * Sets the field ID used for sorting
 * @param primarySortField the field ID used for sorting
 */
TableColumn.prototype.setPrimarySortField = function (primarySortField) {
    if (typeof primarySortField !== "string") {
        throw new Error("Invalid data field parameter for column, must be a string");
    }
    this.primarySortField = primarySortField;
    return this;
};

/**
 * Adds a secondary sort field to the table column
 * @param field the field on which the secondary sort will be performed
 * @param direction the direction that the secondary sort should be applied (ascending or descending)
 */
TableColumn.prototype.addSecondarySortField = function (field, direction) {
    if(typeof direction !== "number") {
        throw new Error("Called addSecondarySortField on TableColumn with non number type for direction parameter");
    }
    if (!TableColumn.isValidSortDirection(direction)) {
        throw new Error("Called addSecondarySortField on TableColumn with invalid direction. Please use TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    if (typeof field !== "string") {
        throw new Error("Called addSecondarySortField on TableColumn with non string type for field parameter.");
    }
    this.secondarySortFields.push({"FIELD": field, "DIRECTION": direction});
};

TableColumn.prototype.getSecondarySortFields = function () {
    return this.secondarySortFields;
};

/**
 * Gets whether the column is sortable
 * @return {boolean} true if sortable, false otherwise
 */
TableColumn.prototype.getIsSortable = function () {
    return this.isSortable;
};

/**
 * Sets whether or not the column sortable or not
 * @param isSortable true if sortable, false otherwise
 */
TableColumn.prototype.setIsSortable = function (isSortable) {
    if (typeof isSortable !== "boolean") {
        throw new Error("Called setIsSortable on TableColumn with non boolean type for isSortable parameter");
    }
    this.isSortable = isSortable;
    return this;
};

/**
 * Sets how the column is currently sorted (ascending/descending/none)
 * @param sortDirection how the column is sorted
 */
TableColumn.prototype.setColumnSortDirection = function (sortDirection) {
    //If user attempts to use a non-number value
    if (typeof sortDirection !== "number") {
        throw new Error("Called setColumnSortDirection on TableColumn with non number type for sortDirection parameter");
    }
    //If user attempts to set an invalid value. Valid values are defined in the TableColumn.SORT object
    if (sortDirection < -1 || sortDirection > 1) {
        throw new Error("Called setColumnSortDirection on TableColumn with invalid sortDirection: " + sortDirection + " the value must be 0, -1, or 1. It " +
            "is recommended that you use TableColumn.SORT.NONE, TableColumn.SORT.ASCENDING, or TableColumn.SORT.DESCENDING");
    }
    this.sortDirection = sortDirection;
    return this;
};

/**
 * Gets how the column is currently sorted
 * @return {number} -1 = ascending, 1 = descending, 0 = none
 */
TableColumn.prototype.getColumnSortDirection = function () {
    return this.sortDirection;
};

/**
 * Gets the render template for the column
 * @return {Template} the render template for the column
 */
TableColumn.prototype.getRenderTemplate = function () {
    return this.template;
};

/**
 * Sets the render template for the column
 * @param template the render template for the column
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setRenderTemplate = function (template) {
    this.template = TemplateBuilder.buildTemplate(template);
    return this;
};

/**
 * Gets the explicit width of the column.
 * @return {number} the width of the column.
 */
TableColumn.prototype.getWidth = function() {
    return this.width;
};

/**
 * Sets the explicit width of the column (in pixels).
 * @param width the width of the column in pixels.
 * @return {TableColumn} returns self.
 */
TableColumn.prototype.setWidth = function(width) {
    if(typeof width !== "number") {
        throw new Error("Called setWidth on TableColumn with non number type for width parameter");
    }
    if(width < 0) {
        throw new Error("Cannot call setWidth on TableColumn with a negative number");
    }
    this.width = width;
    return this;
};

/**
 * Helper function to determine if a sort direction is valid
 * @param sortDirection the direction of the sort
 * @return {boolean} true if the sort direction is valid
 */
TableColumn.isValidSortDirection = function(sortDirection) {
    if(typeof sortDirection !== "number") {
        throw new Error("Called isValidSortDirection on TableColumn with non number type for sortDirection parameter");
    }
    return (Math.abs(sortDirection) === 1);
};

/**
 * Just defines some sorting values so you can do things like ColumnDefinition.SORT.ASCENDING, etc.
 * @type {{ASCENDING: number, DESCENDING: number, NONE: number}}
 */
TableColumn.SORT = {
    "ASCENDING": -1,
    "DESCENDING": 1,
    "NONE": 0
};
/**
 * A table extension class that will serve to create addons for the component table
 * @constructor
 */
function TableExtension(){
    return this;
}

/**
 * The finalize method for a TableExtension.
 * @return {boolean}
 */
TableExtension.prototype.finalize = function(table) {
    throw new Error("Error, finalize method not implemented in a base TableExtension class");
};
/**
 * The TableGroup class. Serves as a container
 * for grouping functionality for the ComponentTable
 * @constructor
 */
function TableGroup() {
    this.canCollapse = true;
    this.display = "";
    this.expanded = true;
    this.groupId = "";
    this.key = "";
    this.rows = [];
    this.rowMap = {};
    this.showCount = false;
    this.groupValue = "";
    this.hideHeader = false;
}

/**
 * Binds a set of data to the group
 * @param data the set of data being bound to the group
 */
TableGroup.prototype.bindData = function(data) {
    for(var i = 0; i < data.length; i++) {
        var tableRow = new TableRow().setResultData(data[i]).setId("row" + i);
        this.rows.push(tableRow);
        this.rowMap[tableRow.getId()] = tableRow;
    }
    return this;
};

/**
 * Clears the data from the group
 */
TableGroup.prototype.clearData = function() {
    this.rows = [];
    this.rowMap = {};
};

/**
 * Gets whether the group can expand/collapse
 * @return {boolean} whether the group is collapsible
 */
TableGroup.prototype.getCanCollapse = function() {
    return this.canCollapse;
};

/**
 * Sets whether the group can expand/collapse
 * @param canCollapse if the group can be collapsed
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setCanCollapse = function(canCollapse) {
    if(typeof canCollapse !== "boolean") {
        throw new Error("Called setCanCollapse on TableGroup with non boolean type for parameter canCollapse");
    }
    this.canCollapse = canCollapse;
    return this;
};

/**
 * Gets the display of the group
 * @return {string} the display of the group
 */
TableGroup.prototype.getDisplay = function(){
    return this.display;
};

/**
 * Sets the display of the group
 * @param display the value to be displayed in the group section
 * @return {*}
 */
TableGroup.prototype.setDisplay = function(display) {
    if(typeof display !== "string") {
        throw new Error("Called setDisplay on TableGroup with non string type for parameter display");
    }
    this.display = display;
    return this;
};

/**
 * Determines if the group is expanded or collapsed
 * @return {boolean} whether the group is expanded
 */
TableGroup.prototype.isExpanded = function() {
    return this.expanded;
};

/**
 * Sets whether the group is expanded or not
 * @param expanded
 */
TableGroup.prototype.setIsExpanded = function(expanded) {
    if(typeof expanded !== "boolean") {
        throw new Error("Called setIsExpanded on TableGroup with non boolean type for isExpanded parameter");
    }
    this.expanded = expanded;
    return this;
};

/**
 * Gets the id of the group
 * @return {string} the id of the group
 */
TableGroup.prototype.getGroupId = function() {
    return this.groupId;
};

/**
 * Sets the id of the group
 * @param groupId the id of the group
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setGroupId = function(groupId) {
    if(typeof groupId !== "string" && typeof groupId !== "number") {
        throw new Error("Called setGroupId on TableGroup with non string type for groupId parameter");
    }
    this.groupId = groupId;
    return this;
};

/**
 * Gets the key of the group. The key is the field on which results are grouped, such as
 * ENCNTR_ID, etc.
 * @return {string} the key of the group
 */
TableGroup.prototype.getKey = function() {
    return this.key;
};

/**
 * Sets the key of the group
 * @param key the key of the group
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setKey = function(key) {
    if(typeof key !== "string" && typeof key !== "number") {
        throw new Error("Called setKey on TableGroup with non string/number type for parameter key");
    }
    this.key = key;
    return this;
};

/**
 * Adds a row to the group
 * @param row the row being added
 * @return {TableGroup} returns self
 */
TableGroup.prototype.addRow = function(row) {
    if(!TableRow.prototype.isPrototypeOf(row)) {
        throw new Error("Called addRow on TableGroup with non TableRow type for row parameter");
    }
    this.rows.push(row);
    this.rowMap[row.getId()] = row;
    return this;
};

/**
 * Gets the rows belonging to the group
 * @return {Array} the list of rows belonging to the group
 */
TableGroup.prototype.getRows = function() {
    return this.rows;
};

/**
 * Returns the row with the specified id. If the row does not exist, an exception is thrown
 * @param rowId the id of the row being obtained
 * @return {TableRow}
 */
TableGroup.prototype.getRowById = function(rowId) {
    if(!this.hasRow(rowId)) {
        throw new Error("In getRowById on TableGroup, TableRow with id: " + rowId + " does not exist");
    }
    return this.rowMap[rowId];
};

/**
 * Checks if the group has the row with the specified id
 * @param rowId the id of the row we're checking for
 * @return {boolean} whether the row exists or not.
 */
TableGroup.prototype.hasRow = function(rowId) {
    return ((typeof this.rowMap[rowId] !== "undefined") && this.rowMap[rowId] !== null);
};

/**
 * Sets the list of rows belonging to the group
 * @param rows the list of rows to be set for the group
 * @return {TableGroup
 */
TableGroup.prototype.setRows = function(rows) {
    if(!(rows instanceof Array)) {
        throw new Error("Called setRows on TableGroup with non Array type for rows parameter");
    }
    this.rows = rows;
    return this;
};

/**
 * Gets whether the group is to show the count in the subsection
 * @return {boolean} whether the group is to show the count in the
 */
TableGroup.prototype.getShowCount = function() {
    return this.showCount;
};

/**
 * Sets whether the group should show the count in the subsection
 * @param showCount whether the group should show the count in the subsection (true/false)
 * @return {TableGroup} return self
 */
TableGroup.prototype.setShowCount = function(showCount) {
    if(typeof showCount !== "boolean") {
        throw new Error("Called setShowCount on TableGroup with non boolean type for showCount parameter");
    }
    this.showCount = showCount;
    return this;
};

/**
 * Gets the value of the group. The value is what the key is equal to. For example, if we want to group on
 * ENCNTR_ID (group key), we may have a group whose value is, say, 125434.0.
 * @return {string} the value of the group
 */
TableGroup.prototype.getValue = function() {
    return this.groupValue;
};

/**
 * Sets the value of the group. The value is what the key is equal to. For example, if we want to group on
 * ENCNTR_ID (group key), we may have a group whose value is, say, 125434.0.
 * @param groupValue the value of the group. (what the key is equal to).
 * @return {TableGroup} returns self.
 */
TableGroup.prototype.setValue = function(groupValue) {
    if(typeof groupValue !== "string" && typeof groupValue !== "number") {
        throw new Error("Called setValue on TableGroup with non string type for parameter value");
    }
    this.groupValue = groupValue;
    return this;
};

/**
 * Gets whether the group's subsection header should be displayed/rendered or not
 * @return [boolean] whether or not the header should be displayed/rendered 
 */
TableGroup.prototype.getHideHeader = function() {
	return this.hideHeader;
};

/**
 * Sets whether the group's subsection header should be displayed/rendered or not
 * @param showHeader : Boolean value that determines if the header should be displayed/rendered
 * @return [TableGroup] return self 
 */
TableGroup.prototype.setHideHeader = function(hideHeader) {
	if(typeof hideHeader !== "boolean") {
		throw new Error("Called setShowHeader on TableGroup with non-boolean type for showHeader parameter value");
	}
	this.hideHeader = hideHeader;
	return this;
};

/**
 * Parses a group id from an element
 * @param elementId the id of the element we're parsing
 * @return {string} the id of the group parsed from the element id
 */
TableGroup.parseGroupId = function(elementId) {
    return elementId.split(":")[1];
};
/**
 * The TableGroupToggleCallbackExtension class
 * This extension is meant to be used to provide a callback to the component
 * when the user toggles a group within the component table
 * @return {TableGroupToggleCallbackExtension} returns self
 * @constructor
 */
function TableGroupToggleCallbackExtension(){
    this.callback = function(event,data){ return; };
    return this;
}

TableGroupToggleCallbackExtension.prototype = new TableExtension();
TableGroupToggleCallbackExtension.prototype.constructor = TableExtension;

/**
 * Sets the callback that is triggered when the user toggles a table group
 * @param callback the callback function
 */
TableGroupToggleCallbackExtension.prototype.setGroupToggleCallback = function(callback) {
    if(typeof callback !== "function") {
        throw new Error("Called setGroupToggleCallback on TableGroupToggleCallbackExtension with non function type for callback parameter");
    }
    this.callback = callback;
    return this;
};

/**
 * Overrides the finalize method (this is called in the ComponentTable finalize method)
 * and attaches it to the table correctly
 * @param table the ComponentTable this extension belongs to
 */
TableGroupToggleCallbackExtension.prototype.finalize = function(table) {
    var self = this;
    var namespace = table.getNamespace();
    var data = {};
    $("#" + namespace + "tableBody").on("click", ".sub-sec-hd", function(event){
        var group = table.getGroupById(TableGroup.parseGroupId($(this).attr("id")));
        data = {
            "GROUP_DATA" : {
                "KEY" : group.getKey(),
                "VALUE": group.getValue(),
                "EXPANDED" : group.isExpanded(),
                "GROUP_ID" : group.getGroupId()
            }
            , "SOURCE" : "TableGroupToggleCallbackExtension:GROUP_CLICK"
        };
        self.callback(event, data);
    });
};

/**
 * The HoverExtension class. It extends the TableExtension class. This class
 * provides functionality for hovers, integrating with the ComponentTable.
 * @return {HoverExtension} returns self.
 * @constructor
 */
function HoverExtension() {
    this.hoverClass = "mpage-tooltip-hover";
    this.onHover = function () {
        return;
    };
    this.onLeave = function () {
        return;
    };
    this.target = "";
    this.tooltip = new MPageTooltip().setShowDelay(0);
    return this;
}

HoverExtension.prototype = new TableExtension();
HoverExtension.prototype.constructor = TableExtension;

HoverExtension.prototype.getHoverClass = function () {
    return this.hoverClass;
};

HoverExtension.prototype.setHoverClass = function (hoverClass) {
    if (typeof hoverClass !== "string") {
        throw new Error("Called setHoverClass on HoverExtension with non string type for hoverClass parameter");
    }
    this.hoverClass = hoverClass;
    return this;
};

/**
 * Sets the callback for a hover event.
 * @param onHover the function to be triggered on the mouse enter.
 */
HoverExtension.prototype.setOnHoverCallback = function (onHover) {
    if (typeof onHover !== "function") {
        throw new Error("Called setOnHoverCallback on HoverExtension with non function type for onHover parameter");
    }
    this.onHover = onHover;
    return this;
};

/**
 * Sets the callback for a hover event.
 * @param onLeave the function to be triggered on the mouse leave.
 */
HoverExtension.prototype.setOnLeaveCallback = function (onLeave) {
    if (typeof onLeave !== "function") {
        throw new Error("Called setOnLeaveCallback on HoverExtension with non function type for onLeave parameter");
    }
    this.onLeave = onLeave;
    return this;
};

/**
 * Gets the target for the hover extension.
 * @return {string} the target for the extension.
 */
HoverExtension.prototype.getTarget = function () {
    return this.target;
};

/**
 * Sets the target for the hover extension. This ensures the delegate is attached to the correct elements.
 * @param target the identifier, telling the extension on what to attach the delegate.
 * @return {HoverExtension} returns self
 */
HoverExtension.prototype.setTarget = function (target) {
    if (typeof target !== "string") {
        throw new Error("Called setTarget on HoverExtension with non string type for target parameter");
    }
    this.target = target;
    return this;
};

/**
 * Gets the tooltip for the extension.
 * @return {MPageTooltip} the tooltip object for the extension.
 */
HoverExtension.prototype.getTooltip = function() {
    return this.tooltip;
};

/**
 * Sets the tooltip for the extension.
 * @param tooltip the tooltip object.
 * @return {HoverExtension} returns self.
 */
HoverExtension.prototype.setTooltip = function(tooltip) {
    if(!(MPageTooltip.prototype.isPrototypeOf(tooltip))) {
        throw new Error("Called setTooltip on HoverExtension with non MPageTooltip type for tooltip parameter");
    }
    this.tooltip = tooltip;
    return this;
};

/**
 * The finalize method for the HoverExtension. It overrides the finalize method in the TableExtension class.
 * This method attaches a mouseenter and mouseleave delegate for the table body. When a mouseenter occurs,
 * the target is highlighted and a hover is shown.
 * @param table the table to which this extension belongs.
 */
HoverExtension.prototype.finalize = function (table) {
    var thiz = this;
    var tableBodyTag = "#" + table.getNamespace() + "tableBody";
    var elementMap = {};
    //Bind the mouseenter event so we know when a user has hovered into an item
    $(tableBodyTag).on("mouseenter", this.getTarget(), function (event) {
        var anchor = this;
        var anchorId = $(this).attr("id");
        //If there is a hover class specified, add it to the element
        if (thiz.getHoverClass() !== "") {
            $(this).addClass(thiz.getHoverClass());
        }
        if (!elementMap[anchorId]) {
            elementMap[anchorId] = {};
        }
        thiz.onHover(event);
        //Store of a flag that we're hovered inside this element
        elementMap[anchorId].TIMEOUT = setTimeout(function () {
            thiz.showHover(event, table, anchor);
        }, 500);
    });
    //Bind the mouseleave event
    $(tableBodyTag).on("mouseleave", this.getTarget(), function (event) {
        $(this).removeClass("mpage-tooltip-hover");
        clearTimeout(elementMap[$(this).attr("id")].TIMEOUT);
        thiz.onLeave(event);
    });
};

/**
 * Base showHover function. Must be overwritten by subclasses of the HoverExtension class.
 * @param event the hover event.
 * @param table the table to which this extension belongs.
 * @param anchor the element that will serve as the anchor to the hover.
 */
HoverExtension.prototype.showHover = function (event, table, anchor) {
    throw new Error("showHover has not been overwritten for a HoverExtension base class");
};

/**
 * The TableRowHoverExtension class. Used when you wish to
 * have a row-level hover.
 * @return {TableRowHoverExtension} returns self
 * @constructor
 * @author Will Reynolds
 */
function TableRowHoverExtension() {
    this.setTarget("dl.result-info");                 //Set the target to result-info, or each row
    this.hoverRenderer = null;                      //The hover renderer (can be either a StringTemplateRenderer or a FunctionRenderer)
    return this;
}

TableRowHoverExtension.prototype = new HoverExtension();
TableRowHoverExtension.prototype.constructor = HoverExtension;

/**
 * Gets the hover renderer
 * @return {HoverRenderer} a HoverRenderer object
 */
TableRowHoverExtension.prototype.getHoverRenderer = function () {
    return this.hoverRenderer;
};

/**
 * Sets the hover renderer
 * @param renderer either a template string or a function used for rendering.
 * @return {TableRowHoverExtension} returns self
 */
TableRowHoverExtension.prototype.setHoverRenderer = function (renderer) {
    this.hoverRenderer = HoverRenderFactory.getHoverRenderer(renderer);
    return this;
};

/**
 * Overrides the showHover method in the HoverExtension base class.
 * @param event the hover event.
 * @param table the table to which this extension belongs.
 * @param anchor the element the anchor is being anchored to.
 */
TableRowHoverExtension.prototype.showHover = function (event, table, anchor) {
    if (!this.hoverRenderer) {
        return;
    }
    var data = {};
    data.RESULT_DATA = ComponentTableDataRetriever.getResultFromTable(table, anchor);
    data.SOURCE = "TableRowHoverExtension:ROW_HOVER";
    var content = this.hoverRenderer.render(data);
    if (!content) {
        return;
    }
    //Create a new tooltip
    var tooltip = this.getTooltip();
    tooltip.setX(event.pageX).setY(event.pageY).setAnchor(anchor).setContent(this.hoverRenderer.render(data));
    tooltip.show();
};

/**
 * The TableCellHoverExtension class. Used when you want cell level hovers.
 * @return {TableCellHoverExtension} returns self
 * @constructor
 * @author Will Reynolds
 */
function TableCellHoverExtension() {
    this.setTarget("dd.table-cell");                    //Set the target of the hovers to each table cell
    this.templateMap = {};                              //A mapping of column ids to hover renderers. Allows different hover content per column
    return this;
}

TableCellHoverExtension.prototype = new HoverExtension();
TableCellHoverExtension.prototype.constructor = HoverExtension;

/**
 * Adds a hover rendering method for the specified column
 * @param column the column for which we're specifying the hover renderer
 * @param renderer how the hover is to be rendered. Either a string or a function.
 */
TableCellHoverExtension.prototype.addHoverForColumn = function (column, renderer) {
    //If you attempt to call this on a non-column object, fail
    if (!TableColumn.prototype.isPrototypeOf(column)) {
        throw new Error("Called addTemplateForColumn on TableCellHoverExtension with non TableColumn type for column parameter");
    }
    this.templateMap[column.getColumnId()] = HoverRenderFactory.getHoverRenderer(renderer);
};

/**
 * Overrides the showHover method in the HoverExtension base class.
 * @param event the hover event
 * @param table the table to which this extension belongs
 * @param anchor the element the hover is being anchored to
 */
TableCellHoverExtension.prototype.showHover = function (event, table, anchor) {
    var data = {};
    var columnId = ComponentTableDataRetriever.getColumnIdFromElement(table, anchor);
    var hoverRenderer = this.templateMap[columnId];
    if (!hoverRenderer) {
        return;
    }
    data.RESULT_DATA = ComponentTableDataRetriever.getResultFromTable(table, anchor);
    data.COLUMN_ID = columnId;
    data.SOURCE = "TableCellHoverExtension:CELL_HOVER";
    data.EVENT = event;
    var content = hoverRenderer.render(data);
    if (!content) {
        return;
    }
    //Create a new tooltip
    var tooltip = this.getTooltip();
    tooltip.setX(event.pageX).setY(event.pageY).setAnchor(anchor).setContent(content);
    tooltip.show();
};

/**
 * A helper class used to get different HoverRenderer classes.
 * @constructor
 * @author Will Reynolds
 */
function HoverRenderFactory() {
}

/**
 * Gets a HoverRenderer object based on the object passed in. A string will return a StringTemplateRenderer, which uses
 * the string templating system. A function will return a FunctionRenderer, which uses a callback function to render the hover.
 * If neither a string nor a function are passed in, an exception is thrown.
 * @param renderObject the object that will handle rendering the hover.
 * @return {HoverRenderer} a HoverRenderer object based on the object passed in.
 */
HoverRenderFactory.getHoverRenderer = function (renderObject) {
    var renderer = null;
    //If the object is a string, we create a StringTemplateRenderer object
    if (typeof renderObject === "string") {
        renderer = new StringTemplateRenderer();
    } else if (typeof renderObject === "function") {
        renderer = new FunctionRenderer();
    } else {
        throw new Error("Called getHoverRenderer on HoverRenderFactory with invalid type for renderObject, use string or function");
    }
    //Initialize the HoverRenderer object with the object passed in
    renderer.init(renderObject);
    return renderer;
};

/**
 * An interface that will render hovers. This interface can be implemented.
 * @constructor
 * @author Will Reynolds
 */
function HoverRenderer() {
}

/**
 * The init interface method which takes in an object that will handle rendering a hover. This method
 * must be overwritten in all sub-classes.
 * @param renderObject the object that will handle rendering a hover
 */
HoverRenderer.prototype.init = function (renderObject) {
    throw new Error("HoverRenderer init method not implemented");
};

/**
 * The render method which takes in a data object. This will populate a hover with the data object. This method
 * must be overwritten in all sub-classes.
 * @param data the data object which will be injected into the hover.
 */
HoverRenderer.prototype.render = function (data) {
    throw new Error("HoverRenderer render method not implemented");
};

/**
 * The StringTemplateRenderer class. It is a sub-class of HoverRenderer. This implementation uses the string
 * templating system.
 * @constructor
 * @author Will Reynolds
 */
function StringTemplateRenderer() {
    this.template = null;
}
StringTemplateRenderer.prototype = new HoverRenderer();
StringTemplateRenderer.prototype.constructor = HoverRenderer;

/**
 * Gets the template
 * @return {Template} the renderer's template object
 */
StringTemplateRenderer.prototype.getTemplate = function () {
    return this.template;
};

/**
 * Sets the template object for the renderer
 * @param template the template object
 * @return {StringTemplateRenderer} returns self
 */
StringTemplateRenderer.prototype.setTemplate = function (template) {
    this.template = template;
    return this;
};

/**
 * Overrides the init method for the HoverRenderer interface. This init method takes the renderObject
 * and stores it as a template.
 * @param renderObject the render object which will be converted to a template. This renderObject must be a string
 * @return {StringTemplateRenderer} returns self
 */
StringTemplateRenderer.prototype.init = function (renderObject) {
    return this.setTemplate(TemplateBuilder.buildTemplate(renderObject));
};

/**
 * Overrides the render method for the HoverRenderer interface. This method simply renders the template with the
 * passed in data.
 * @param data the data to be rendered via the template.
 * @return {string} an html string rendered by the template.
 */
StringTemplateRenderer.prototype.render = function (data) {
    return this.template.render(data);
};

/**
 * The FunctionRenderer class. It is a sub-class of HoverRenderer. This implementation uses function callbacks
 * to perform rendering.
 * @constructor
 * @author Will Reynolds
 */
function FunctionRenderer() {
    this.renderFunction = function (data) {
        return "";
    };
}
FunctionRenderer.prototype = new HoverRenderer();
FunctionRenderer.prototype.constructor = HoverRenderer;

/**
 * Gets the render function
 * @return {Function} returns the function that will perform the rendering
 */
FunctionRenderer.prototype.getRenderFunction = function () {
    return this.renderFunction;
};

/**
 * Sets the render function
 * @param renderFunction the function that will handle rendering
 * @return {FunctionRenderer} returns self
 */
FunctionRenderer.prototype.setRenderFunction = function (renderFunction) {
    if (typeof renderFunction !== "function") {
        throw new Error("Called setRenderFunction on FunctionRenderer with non function type for renderFunction parameter");
    }
    this.renderFunction = renderFunction;
    return this;
};

/**
 * Overrides the init method for the HoverRenderer interface. This simply stores off the renderObject.
 * @param renderObject this will be a function that will perform rendering.
 * @return {FunctionRenderer} returns self
 */
FunctionRenderer.prototype.init = function (renderObject) {
    return this.setRenderFunction(renderObject);
};

/**
 * Overrides the render method for the HoverRenderer interface. This simply calls the renderFunction, passing
 * the data as a parameter.
 * @param data the data that is to be rendered via the renderFunction.
 * @return {string} the html string as rendered by the function.
 */
FunctionRenderer.prototype.render = function (data) {
    return this.renderFunction(data);
};

/**
 * Class for a component table row
 * @constructor
 */
function TableRow() {
    this.rowId = "";
    this.tableCells = [];
    this.resultData = null;
    this.rowAttributeHash = {attrName: "" , attrValue: ""};
    return this;
}

/**
 * Store the JSON data that belongs to the row
 * @param resultData the JSON result that is associated with the row
 */
TableRow.prototype.setResultData = function (resultData) {
    if(typeof resultData !== "object") {
        throw new Error("Called setResultData on TableRow with non object type for the resultData parameter");
    }
    this.resultData = resultData;
    return this;
};

/**
 * Gets the result data associated with the row
 * @return {JSON Object} the result data associated with the row
 */
TableRow.prototype.getResultData = function () {
    return this.resultData;
};

/**
 * Gets the row id
 * @return {string} gets the row id
 */
TableRow.prototype.getId = function(){
    return this.rowId;
};

/**
 * Sets the row id
 * @param id the row id
 */
TableRow.prototype.setId = function(id) {
    this.rowId = id;
    return this;
};

/**
 * Return all results for the row
 * @return {Array} an array of results for the row
 */
TableRow.prototype.getTableCells = function () {
    return this.tableCells;
};

/**
 * Sets the results for the row
 * @param tableCells the results that belong to the row
 */
TableRow.prototype.setTableCells = function (tableCells) {
    if(!tableCells instanceof Array) {
        throw new Error("Called setTableCells on TableRow with type other than Array");
    }
    this.tableCells = tableCells;
    return this;
};

/**
 * Adds a result to the row, associated with which column it belongs in
 * @param columnId the column we're associating the result to
 * @param tableCell the result
 */
TableRow.prototype.addTableCell = function (columnId, tableCell) {
    if(typeof columnId !== "string") {
        throw new Error("Called addTableCell on TableRow and passed non string type for columnId parameter");
    }
    if(!TableCell.prototype.isPrototypeOf(tableCell)) {
        throw new Error("Called addTableCell on TableRow and passed non TableCell type for tableCell parameter");
    }
    this.tableCells[columnId] = tableCell;
};

/**
 * Gets the result in the row at the specified column
 * @param columnId the column in which we want the result
 * @return {TableCell} a result cell at the specified column
 */
TableRow.prototype.getTableCellInColumn = function (columnId) {
    if(typeof columnId !== "string") {
        throw new Error("Called getTableCellInColumn on TableRow and passed non string type for columnId parameter");
    }
    if(typeof this.tableCells[columnId] === "undefined" || this.tableCells[columnId] === null) {
        throw new Error("In method getTableCellInColumn, the columnId: " + columnId + " returned undefined or null");
    }
    return this.tableCells[columnId];
};

/**
 * Creates a hash for setting a data attribute on the row
 * @param {String} attributeName: name of a data attribute applied for each row of the ComponentTable
 * @param {String} attributeValue: member from the result data that will be mapped as an attribute value
 */
TableRow.prototype.setRowAttributeHash = function(attributeName, attributeValue){
	if(typeof attributeName !== "string" || typeof attributeValue !== "string"){ 
        throw new Error("Called setRowAttributeHash on TableRow and passed non string type for attributeName or attributeValue parameter");
	}
	this.rowAttributeHash.attrName = attributeName;
	this.rowAttributeHash.attrValue = attributeValue;
	return this;
};

/**
 * Returns the rowAttributeHash object
 * @return {object} returns the rowAttributeHash
 */
TableRow.prototype.getRowAttributeHash = function(){
	return this.rowAttributeHash;
};
/**
 * Simple template class to encapsulate an html template
 * @author Will Reynolds
 * @constructor
 */
function Template() {
    this.id = "";
    this.templateFunction = null;
}

/**
 * Sets the id of the template
 * @param id the id of the template
 */
Template.prototype.setId = function(id) {
    this.id = id;
};

/**
 * Gets the id of the template
 * @return {string} the id of the template (this can be used to find it in the template cache)
 */
Template.prototype.getId = function() {
    return this.id;
};

/**
 * Set the template rendering function
 * @param templateFunction the template rendering function
 */
Template.prototype.setTemplateFunction = function(templateFunction) {
    this.templateFunction = templateFunction;
};

/**
 * Get the template rendering function
 * @return {Function} the template rendering function
 */
Template.prototype.getTemplateFunction = function() {
    return this.templateFunction;
};

/**
 * Renders the template with provided data
 * @param data the data object you wish to provide to the template
 * @return {string} the populated template
 */
Template.prototype.render = function(data) {
    data = data || {};
    try {
        return this.templateFunction(data);
    } catch(exe) {
        throw new Error("There was an error rendering the template: " + exe.message);
    }
};
/**
 * Simple template builder class
 * @author Will Reynolds
 * @constructor
 */
function TemplateBuilder() {
}

/**
 * Builds a template from a string
 * @param template a template string
 * @return {Template} a template object based on the template string passed in
 */
TemplateBuilder.buildTemplate = function(template) {
    if(typeof template !== "string") {
        throw new Error("Called buildTemplate on TemplateBuilder with non string type for template parameter");
    }
	
	// escape double quotes
	template = template.replace(/"/g, '\\"');
	
    var newTemplate = new Template();
    //Build the template rendering function
    var templateFunction = new Function("data", "var params=[];" +
        "params.push(\"" + template.split("${").join("\");params.push(data.").split("}").join(");params.push(\"") + "\");"+
        "return params.join(\"\");");
    newTemplate.setTemplateFunction(templateFunction);
    return newTemplate;
};

/**
 * Creates a template AND caches it in the template cache
 * @param id the id by which the template can be accessed
 * @param template the template string
 * @return {Template} the template object created
 */
TemplateBuilder.buildAndCacheTemplate = function(id, template) {
    var templateObject = TemplateBuilder.buildTemplate(template);
    TemplateCache.cacheTemplate(id, templateObject);
    return templateObject;
};
/**
 * Simple template cache class to store off constructed templates
 * @author Will Reynolds
 * @constructor
 */
function TemplateCache(){
}

TemplateCache.templates = {};

/**
 * Loads all standard template into the cache to be used later (only do this if you wish to load all templates)
 */
TemplateCache.loadStandardTemplates = function() {
    for(var templateKey in StandardTemplates) {
        var template = StandardTemplates[templateKey];
        if(template && typeof template === "string") {
            TemplateCache.cacheTemplate(templateKey, TemplateBuilder.buildTemplate(template));
        }
    }
};

/**
 * Stores a template in the cache
 * @param id the id of the template that you'll use to get it later
 * @param template the template object you're caching
 */
TemplateCache.cacheTemplate = function(id, template) {
    if(typeof id !== "string") {
        throw new Error("Called cacheTemplate on TemplateCache with non string type for id parameter");
    }
    if(!Template.prototype.isPrototypeOf(template)) {
        throw new Error("Called cacheTemplate on TemplateCache with non Template type for template parameter");
    }
    if(TemplateCache.hasTemplate(id)) {
        throw new Error("Called cacheTemplate on TemplateCache. Template with id: " + id + " already exists. Please use a different identifier.");
    }
    TemplateCache.templates[id] = template;
};

/**
 * Gets a template by the id passed in
 * @param id the id of the template one wishes to obtain
 * @return {Template} if a template exists for the id, returns that Template, otherwise returns null
 */
TemplateCache.getTemplate = function(id) {
    if(!TemplateCache.hasTemplate(id)) {
        throw new Error("Template with id: " + id + " does not exist");
    }
    return TemplateCache.templates[id];
};

/**
 * Checks if a template object exists in the cache
 * @param id the id of the template
 * @return {boolean} true if the template exists, otherwise false
 */
TemplateCache.hasTemplate = function(id) {
    return (typeof TemplateCache.templates[id] !== "undefined" && TemplateCache.templates[id] !== null);
};
function RCMAutoSuggestControl(textbox,queryHandler,selectionHandler,detailsHandler){this.cur=0;
this.layer=null;
this.queryHandler=queryHandler;
this.selectionHandler=selectionHandler;
this.detailsHandler=detailsHandler;
this.textbox=textbox;
this.prevSearchString=textbox.value;
this.suggestions=[];
this.isVerified=false;
this.isRequired=false;
this.ignoreOnBlur=false;
this.currentTimeout;
this.delay=300;
this.verifyStateChangeListeners=[];
this.init();
}RCMAutoSuggestControl.prototype.autosuggest=function(suggestions){this.layer.style.width=this.textbox.offsetWidth;
this.suggestions=suggestions;
if(suggestions.length>0){this.showSuggestions(suggestions);
}else{this.hideSuggestions();
}};
RCMAutoSuggestControl.prototype.createDropDown=function(){var that=this;
this.layer=document.createElement("div");
this.layer.className="rcm-search-suggestions";
this.layer.style.display="none";
this.layer.style.width=this.textbox.offsetWidth;
this.layer.onmousedown=this.layer.onmouseup=this.layer.onmouseover=function(oEvent){oEvent=oEvent||window.event;
oTarget=oEvent.target||oEvent.srcElement;
if(oEvent.type=="mousedown"){var index=that.indexOf(this,oTarget);
if(that.suggestions[index]){if(that.suggestions[index].VALUE){that.setVerified(true);
that.textbox.value=that.suggestions[index].NAME;
}else{that.textbox.value="";
}that.selectionHandler(that.suggestions[index].VALUE);
that.hideSuggestions();
}}else{if(oEvent.type=="mouseover"){var index=that.indexOf(this,oTarget);
that.cur=index;
that.highlightSuggestion(oTarget);
}else{that.textbox.focus();
}}};
document.body.appendChild(this.layer);
};
RCMAutoSuggestControl.prototype.getLeft=function(){return $(this.textbox).offset().left;
};
RCMAutoSuggestControl.prototype.getTop=function(){return $(this.textbox).offset().top;
};
RCMAutoSuggestControl.prototype.handleKeyDown=function(oEvent){if(this.layer.style.display!="none"){switch(oEvent.keyCode){case 38:this.previousSuggestion();
break;
case 40:this.nextSuggestion();
break;
case 13:if(this.suggestions[this.cur].VALUE){this.setVerified(true);
this.textbox.value=this.suggestions[this.cur].NAME;
}else{this.textbox.value="";
}this.selectionHandler(this.suggestions[this.cur].VALUE);
this.hideSuggestions();
break;
}}};
RCMAutoSuggestControl.prototype.addLoadingSpinner=function(){this.textbox.className="searchTextLoading";
};
RCMAutoSuggestControl.prototype.removeLoadingSpinner=function(){this.textbox.className="searchText";
};
RCMAutoSuggestControl.prototype.handleKeyUp=function(oEvent){var iKeyCode=oEvent.keyCode;
function handleQueryLater(that,searchText){return function(){that.queryHandler(that,searchText);
};
}if(iKeyCode==8||iKeyCode==46){this.setVerified(false);
if(this.currentTimeout){clearTimeout(this.currentTimeout);
}if(this.textbox.value.length>0){this.currentTimeout=setTimeout(handleQueryLater(this,this.textbox.value),this.delay);
}else{this.hideSuggestions();
}}else{if(iKeyCode<32||(iKeyCode>=33&&iKeyCode<46)||(iKeyCode>=112&&iKeyCode<=123)||this.prevSearchString===this.textbox.value){}else{this.setVerified(false);
if(this.currentTimeout){clearTimeout(this.currentTimeout);
}if(this.textbox.value.length>0){this.currentTimeout=setTimeout(handleQueryLater(this,this.textbox.value),this.delay);
this.prevSearchString=this.textbox.value;
}}}};
RCMAutoSuggestControl.prototype.setVerified=function(isVerified){if(isVerified!=this.isVerified){this.isVerified=isVerified;
this.updateRequiredDecoration();
for(var i=0;
i<this.verifyStateChangeListeners.length;
i++){this.verifyStateChangeListeners[i]();
}}};
RCMAutoSuggestControl.prototype.hideSuggestions=function(){this.layer.style.display="none";
};
RCMAutoSuggestControl.prototype.highlightSuggestion=function(suggestionNode){for(var i=0;
i<this.layer.childNodes.length;
i++){var curNode=this.layer.childNodes[i];
if(curNode==suggestionNode||curNode==suggestionNode.parentNode){curNode.className="rcm-search-current";
}else{if(curNode.className=="rcm-search-current"){curNode.className="";
}}}};
RCMAutoSuggestControl.prototype.init=function(){var that=this;
this.textbox.onkeyup=function(oEvent){if(!oEvent){oEvent=window.event;
}that.handleKeyUp(oEvent);
};
this.textbox.onkeydown=function(oEvent){if(!oEvent){oEvent=window.event;
}that.handleKeyDown(oEvent);
};
this.textbox.onblur=function(){that.hideSuggestions();
if(!that.ignoreOnBlur){if(!that.isVerified){that.textbox.value="";
that.selectionHandler(0);
}}};
this.createDropDown();
};
RCMAutoSuggestControl.prototype.nextSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur<cSuggestionNodes.length-1){var oNode=cSuggestionNodes[++this.cur];
this.highlightSuggestion(oNode);
}};
RCMAutoSuggestControl.prototype.previousSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur>0){var oNode=cSuggestionNodes[--this.cur];
this.highlightSuggestion(oNode);
}};
RCMAutoSuggestControl.prototype.showSuggestions=function(suggestions){this.ignoreOnBlur=true;
var oDiv=null;
this.layer.innerHTML="";
for(var i=0;
i<suggestions.length;
i++){oDiv=document.createElement("div");
if(i==0){oDiv.className="rcm-search-current";
}this.cur=0;
var itemText=this.emboldenTypeAheadText(suggestions[i].NAME,this.textbox.value);
oDiv.innerHTML=itemText;
this.detailsHandler(suggestions[i].DETAILS,oDiv);
this.layer.appendChild(oDiv);
}this.layer.style.left=this.getLeft()+"px";
this.layer.style.top=(this.getTop()+this.textbox.offsetHeight)+"px";
this.layer.style.display="block";
this.layer.style.position="absolute";
this.ignoreOnBlur=false;
};
RCMAutoSuggestControl.prototype.indexOf=function(parent,element){var nodeList=parent.childNodes;
for(var i=0;
i<nodeList.length;
i++){var curNode=nodeList[i];
if(curNode==element||curNode==element.parentNode){return i;
}}return -1;
};
RCMAutoSuggestControl.prototype.emboldenTypeAheadText=function(suggestionText,typedText){return"<strong>"+suggestionText.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+typedText.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi,"\\$1").split(" ").join("|")+")(?![^<>]*>)(?![^&;]+;)","gi"),"</strong>$1<strong>")+"</strong>";
};
RCMAutoSuggestControl.prototype.updateRequiredDecoration=function(){$(this.textbox).toggleClass("required-search-field",this.isRequired&&!this.isVerified);
};
RCMAutoSuggestControl.prototype.setRequired=function(isRequired){if(isRequired!=this.isRequired){this.isRequired=isRequired;
if(isRequired){$("label[for='"+$(this.textbox).prop("id")+"']").prepend("<span style='color:#cc0000'>*</span>");
}else{$("label[for='"+$(this.textbox).prop("id")+"']").children(1).remove();
}this.updateRequiredDecoration();
}};
RCMAutoSuggestControl.prototype.addVerifyStateChangeListener=function(listener){this.verifyStateChangeListeners.push(listener);
};
RCMAutoSuggestControl.prototype.removeVerifyStateChangeListener=function(listener){for(var i=0;
i<this.verifyStateChangeListeners.length;
i++){if(this.verifyStateChangeListeners[i]===listener){this.verifyStateChangeListeners.splice(i,1);
break;
}}};
function ToolTipDetailsHandler(details,itemDiv){if(details&&details.length>0){var oToolTipDiv=document.createElement("div");
oToolTipDiv.className="detailsToolTip";
oToolTipDiv.style.visibility="hidden";
itemDiv.appendChild(oToolTipDiv);
var oToolTipSpan=document.createElement("span");
oToolTipSpan.innerHTML=details;
oToolTipDiv.appendChild(oToolTipSpan);
itemDiv.onmouseover=function(oEvent){oToolTipDiv.style.visibility="visible";
var offsetWidth=(itemDiv.offsetWidth)?itemDiv.offsetWidth:0;
var parentMarginLeft=(itemDiv.marginLeft)?itemDiv.marginLeft:0;
var parentMarginRight=(itemDiv.marginRight)?itemDiv.marginRight:0;
oToolTipDiv.style.left=offsetWidth+parentMarginLeft+parentMarginRight+5+"px";
oToolTipDiv.style.top=0+"px";
};
itemDiv.onmouseout=function(e){oToolTipDiv.style.visibility="hidden";
};
}}
function AutoSuggestControl(oComponent,oQueryHandler,oSelectionHandler,oSuggestionDisplayHandler,oItemId){this.cur=0;
this.layer=null;
this.component=oComponent;
this.queryHandler=oQueryHandler;
this.selectionHandler=oSelectionHandler;
this.suggestionDisplayHandler=oSuggestionDisplayHandler;
if(oItemId){this.textbox=_g(oComponent.getStyles().getNameSpace()+oItemId+oComponent.getComponentId());
}else{this.textbox=_g(oComponent.getStyles().getNameSpace()+"ContentCtrl"+oComponent.getComponentId());
}this.objArray="";
this.init();
}AutoSuggestControl.prototype.autosuggest=function(aSuggestions,defaultSelected){this.layer.style.width=this.textbox.offsetWidth;
this.objArray=aSuggestions;
if(aSuggestions&&aSuggestions.length>0){this.showSuggestions(aSuggestions,defaultSelected);
}else{this.hideSuggestions();
}};
AutoSuggestControl.prototype.createDropDown=function(){var oThis=this;
this.layer=document.createElement("div");
this.layer.className="suggestions";
this.layer.style.display="none";
this.layer.style.zIndex="9999";
this.layer.onmousedown=this.layer.onmouseup=this.layer.onmouseover=function(oEvent){oEvent=oEvent||window.event;
oTarget=oEvent.target||oEvent.srcElement;
var index;
if(oEvent.type=="mousedown"){index=AutoSuggestControl.prototype.indexOf(this,oTarget);
oThis.selectionHandler(oThis.objArray[index],oThis.textbox,oThis.component);
oThis.hideSuggestions();
}else{if(oEvent.type=="mouseover"){index=AutoSuggestControl.prototype.indexOf(this,oTarget);
oThis.cur=index;
oThis.highlightSuggestion(oTarget);
}else{oThis.textbox.focus();
}}};
Util.ia(this.layer,Util.gp(this.textbox));
};
AutoSuggestControl.prototype.handleKeyDown=function(oEvent){if(this.layer.style.display!="none"){switch(oEvent.keyCode){case 38:this.previousSuggestion();
break;
case 40:this.nextSuggestion();
break;
case 13:this.selectionHandler(this.objArray[this.cur],this.textbox,this.component);
this.hideSuggestions();
break;
}}};
AutoSuggestControl.prototype.handleKeyUp=function(oEvent){var iKeyCode=oEvent.keyCode;
if(iKeyCode==8||iKeyCode==46){if(this.textbox.value.length>0){this.queryHandler(this,this.textbox,this.component);
}else{this.hideSuggestions();
}}else{if(iKeyCode<32||(iKeyCode>=33&&iKeyCode<46)||(iKeyCode>=112&&iKeyCode<=123)){}else{this.queryHandler(this,this.textbox,this.component);
}}};
AutoSuggestControl.prototype.hideSuggestions=function(){var oNode=this.textbox;
while(oNode&&!Util.Style.ccss(oNode,"section")){oNode=Util.gp(oNode);
}if(oNode){oNode.style.position="relative";
oNode.style.zIndex="1";
}this.layer.style.zIndex="9999";
this.layer.style.display="none";
};
AutoSuggestControl.prototype.highlightSuggestion=function(oSuggestionNode){for(var i=0;
i<this.layer.childNodes.length;
i++){var oNode=this.layer.childNodes[i];
if(oNode==oSuggestionNode||oNode==oSuggestionNode.parentNode){oNode.className="current";
}else{if(oNode.className=="current"){oNode.className="";
}}}};
AutoSuggestControl.prototype.init=function(){var oThis=this;
this.textbox.onkeyup=function(oEvent){if(!oEvent){oEvent=window.event;
}oThis.handleKeyUp(oEvent);
};
this.textbox.onkeydown=function(oEvent){if(!oEvent){oEvent=window.event;
}oThis.handleKeyDown(oEvent);
};
this.textbox.onblur=function(){oThis.hideSuggestions();
};
this.createDropDown();
};
AutoSuggestControl.prototype.nextSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur<cSuggestionNodes.length-1){var oNode=cSuggestionNodes[++this.cur];
this.highlightSuggestion(oNode);
}};
AutoSuggestControl.prototype.previousSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur>0){var oNode=cSuggestionNodes[--this.cur];
this.highlightSuggestion(oNode);
}};
AutoSuggestControl.prototype.showSuggestions=function(aSuggestions,defaultSelected){var oDiv=null;
this.layer.innerHTML="";
for(var i=0;
i<aSuggestions.length;
i++){oDiv=document.createElement("div");
if(i===0&&!defaultSelected){oDiv.className="current";
}if(defaultSelected){this.cur=-1;
}else{this.cur=0;
}var domText=this.suggestionDisplayHandler(aSuggestions[i],this.textbox.value);
oDiv.innerHTML=domText;
oDiv.appendChild(document.createTextNode(""));
this.layer.appendChild(oDiv);
}var oNode=this.textbox;
while(oNode&&!Util.Style.ccss(oNode,"section")){oNode=Util.gp(oNode);
}if(oNode){oNode.style.position="relative";
oNode.style.zIndex="2";
}this.layer.style.zIndex="100000";
this.layer.style.display="block";
};
AutoSuggestControl.prototype.indexOf=function(parent,el){var nodeList=parent.childNodes;
for(var i=0;
i<nodeList.length;
i++){var oNode=nodeList[i];
if(oNode==el||oNode==el.parentNode){return i;
}}return -1;
};
AutoSuggestControl.prototype.highlight=function(value,term){return"<strong>"+value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi,"\\$1").split(" ").join("|")+")(?![^<>]*>)(?![^&;]+;)","gi"),"</strong>$1<strong>")+"</strong>";
};
function BedrockMPage(categoryMean){
    this.mean = categoryMean;

    //public methods
    BedrockMPage.method('getCategoryMean', function(){
        return this.mean;
    });
}

BedrockMPage.inherits(MPageView);

/**
 * Bedrock schema methods for loading a MPage utilizing the bedrock configuration
 * @namespace MP_Bedrock
 * @static
 * @global
 */
var MP_Bedrock = function(){
    return {
    	bedrockShorthandConversions : {
			PARENT_ENTITY_ID: "PE_ID",
			PARENT_ENTITY_NAME: "PE_NM",
			CDF_MEANING: "CDF_MN",
			GROUP_SEQ: "G_SQ",
			VALUE_SEQ: "V_SQ",
			FREETEXT_DESC: "FTXT",
			VALUE_TYPE_FLAG:"V_TYP",
			QUALIFIER_FLAG:"Q_FLG"
		},
        LoadingPolicy: function(){
            var m_loadPageDetails = false;
            var m_loadComponentBasic = false;
            var m_loadComponentDetail = false;
            var m_loadCustomizeView = false;
            var m_categoryMean = "";
            var m_criterion = null;

            this.setLoadPageDetails = function(value){
                m_loadPageDetails = value;
            };
            this.getLoadPageDetails = function(){
                return m_loadPageDetails;
            };
            this.setLoadComponentBasics = function(value){
                m_loadComponentBasic = value;
            };
            this.getLoadComponentBasics = function(){
                return m_loadComponentBasic;
            };
            this.setLoadComponentDetails = function(value){
                m_loadComponentDetail = value;
            };
            this.getLoadComponentDetails = function(){
                return m_loadComponentDetail;
            };
            this.setCategoryMean = function(value){
                m_categoryMean = value;
            };
            this.getCategoryMean = function(){
                return m_categoryMean;
            };
            this.setCriterion = function(value){
                m_criterion = value;
            };
            this.getCriterion = function(){
                return m_criterion;
            };
            this.setCustomizeView = function(value){
                m_loadCustomizeView = value;
            };
            this.getCustomizeView = function(){
                return m_loadCustomizeView;
            };
        },
        GetPageFromRec: function(recordData, loadingPolicy){
            var categoryMean = loadingPolicy.getCategoryMean();
            for (var x = recordData.MPAGE.length; x--;) {
                if (categoryMean.toUpperCase() === recordData.MPAGE[x].SETTINGS.C_MN.toUpperCase()) {//C_MN is shorthand for Category Mean
                    return (recordData.MPAGE[x].SETTINGS);
                }
            }
        }
    };
}();

MP_Bedrock.MPage = function(){
    return {
        LoadBedrockMPage: function(loadingPolicy){

            var categoryMean = loadingPolicy.getCategoryMean();
            var returnPage = new BedrockMPage(categoryMean);
            var criterion = loadingPolicy.getCriterion();
            criterion.category_mean = categoryMean;

            returnPage.setCriterion(criterion);
            returnPage.setCustomizeView(loadingPolicy.getCustomizeView());

            if (m_bedrockMpage.MPAGE.length > 0) {
            	if (log.isBlackBirdActive()) {
					MP_Util.LogDebug("Bedrock JSON: " + JSON.stringify(m_bedrockMpage));
				}
                var page = MP_Bedrock.GetPageFromRec(m_bedrockMpage, loadingPolicy);
                if (!page) {
                    //page not a part of the initial load, will need to retrieve
					var ignoreCache = ((parseInt(criterion.debug_ind, 10) & 0x08) === 8)? 1 : 0;
                    var cclParams = ["^MINE^", "^" + categoryMean + "^", criterion.provider_id + ".0", criterion.position_cd + ".0", 0, ignoreCache];
                    var info = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();
                    info.onreadystatechange = function () {
                        if (this.readyState == 4 && this.status == 200) {
                            try {
                                m_bedrockMpage = JSON.parse(info.responseText).MP_SETTINGS;
                                MP_Util.LogScriptCallInfo(null, this, "bedrock.js", "LoadBedrockMPage");
                            }
                            catch (error) {
                                MP_Util.LogJSError(err, null, "bedrock.js", "LoadBedrockMPage");
                            }
                            page = m_bedrockMpage.MPAGE[0].SETTINGS;
                        }
                        if (this.readyState == 4) {
                            MP_Util.ReleaseRequestReference(this);
                        }
                    };
                    //  Call the ccl progam and send the parameter string
                    if(CERN_BrowserDevInd){
						var url = "MP_GET_MPAGE_SETTINGS?parameters=" + cclParams.join(",");
						info.open("GET", url, false);
						info.send(null);
					}
					else{
						info.open('GET', "MP_GET_MPAGE_SETTINGS", false);
                    	info.send(cclParams.join(","));
					}


                }
                var prefManager = MP_Core.AppUserPreferenceManager;
                prefManager.Initialize(criterion, categoryMean);
                if (page.BR_SET.UP.length > 0) {  //BR_SET is shorthand for Bedrock Settings and UP is shorthand for User Preferences
                    prefManager.SetPreferences(page.BR_SET.UP);
                }
                returnPage.setPageId(page.C_ID); //C_ID is shorthand for Category Id(br_datamart_category_id)

                //load page level parameters
                var jsMPage = page.BR_SET.PS; //BR_SET is shorthand for Bedrock Settings and PS is shorthand for Page Settings

                var y = 0;
                for (y = 0, yl = jsMPage.length; y < yl; y++) {
                    //Get the page pref settings function and execute it
					var curMPage = jsMPage[y];
					var valMPage = curMPage.VALS;
                    
                    if(curMPage.F_MN === "VIEWPOINT_LABEL") { //F_MN is shorthand for Filter Mean
	                    for(var z = valMPage.length; z--;) {
	                    	var curVal = valMPage[z];
	                    	if(curVal.FTXT) { //FTXT is shorthand for Freetext Description
	                    		returnPage.setName(curVal.FTXT); //FTXT is shorthand for Freetext Description
	                    	}
	                    }
	                }
                }

                //load basic information about components, leave detailed to the component when loaded
                var components = page.BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for Page Settings
                for (y = 0, yl = components.length; y < yl; y++) {
                    var jsonComponent = components[y];
                    returnPage.addComponentId(jsonComponent.R_ID); //R_ID is shorthand for Report Id(br_datamart_report_id)
                }
            }

            var loadComponentIndicator = (loadingPolicy.getLoadComponentBasics()) ? 1 : 0;
            if (loadComponentIndicator > 0) {
                var components = MP_Bedrock.MPage.Component.LoadBedrockComponents(loadingPolicy, returnPage.getComponentIds());
                returnPage.setComponents(components);
            }
            return returnPage;
        }
    };
}();

MP_Bedrock.MPage.Component = function(){
    return {

        LoadBedrockComponents: function(loadingPolicy, compIdAr){
            if (compIdAr && compIdAr !== null && compIdAr.length > 0) {
				var ComponentType = null;
                var returnAr = [];
                var reportData = MP_Bedrock.GetPageFromRec(m_bedrockMpage, loadingPolicy);
                var prefManager = MP_Core.AppUserPreferenceManager;
                var criterion = loadingPolicy.getCriterion();
                var isCustomizeView = loadingPolicy.getCustomizeView();

                for (var x = reportData.BR_SET.CS.length; x--;) {
                    var jsonComponent = reportData.BR_SET.CS[x]; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for Component Settings

                    if(!isCustomizeView){
						ComponentType = getComponentByFilterMean(jsonComponent.F_MN); //F_MN is shorthand for Filter Mean
                    }

                    if ((ComponentType) || isCustomizeView) //need to make sure components returned are part of the mapping requested.
                    {
                        var jsComponentFunc = null;
                        var component = null;
                        if (isCustomizeView) {
                            component = new MPageComponent();
                            component.setCriterion(criterion);
                            component.setStyles(new ComponentStyle());
                        }
                        else {
                            component = new ComponentType(criterion);
                        }

                        component.setCustomizeView(loadingPolicy.getCustomizeView());
                        component.setComponentId(jsonComponent.F_ID); //F_ID is shorthand for Filter Id (br_datamart_filter_id)
                        component.setReportId(jsonComponent.R_ID); //R_ID is shorthand for Filter Id (br_datamart_filter_id)
                        component.setReportMean(jsonComponent.R_MN); //R_MN is shorthand for Filter Id (br_datamart_filter_id)

                        var userPrefComp = prefManager.GetComponentById(component.getComponentId());
                        if (userPrefComp && userPrefComp !== null) {
                            component.setExpanded(userPrefComp.expanded);
                            component.setColumn(userPrefComp.col_seq);
                            component.setSequence(userPrefComp.row_seq);
                            component.setPageGroupSequence(userPrefComp.group_seq);
                            component.setPreferencesObj(userPrefComp.preferencesObj);
                            if (userPrefComp.compThemeColor) {
								component.setCompColor(userPrefComp.compThemeColor);
                            }
                            if(userPrefComp.lookbackunits) {
                            	component.setLookbackUnits(userPrefComp.lookbackunits);
                            }
                            else {
                            	component.setLookbackUnits(jsonComponent.LB_UNT); //LB_UNT is shorthand for Lookback Units
                            }
                            if(userPrefComp.lookbacktypeflag) {
                            	component.setLookbackUnitTypeFlag(userPrefComp.lookbacktypeflag);
                            }
                            else {
                            	component.setLookbackUnitTypeFlag(jsonComponent.LB_TYP); //LB_TYP is shorthand for Lookback Type Flag
                            }
                            if(userPrefComp.grouperFilterLabel) {
                            	component.setGrouperFilterLabel(userPrefComp.grouperFilterLabel);
                            }
                            else {
                            	component.setGrouperFilterLabel("");
                            }
                            if(userPrefComp.grouperFilterCatLabel) {
				component.setGrouperFilterCatLabel(userPrefComp.grouperFilterCatLabel);
			    }
			    else {
				component.setGrouperFilterCatLabel("");
                            }
                            if(userPrefComp.grouperFilterCriteria) {
                            	component.setGrouperFilterCriteria(userPrefComp.grouperFilterCriteria);
                            }
                            else {
                            	component.setGrouperFilterCriteria(null);
                            }
                            if (userPrefComp.grouperFilterCatalogCodes) {
								component.setGrouperFilterCatalogCodes(userPrefComp.grouperFilterCatalogCodes);
							}
							else {
								component.setGrouperFilterCatalogCodes(null);
							}
                            if(userPrefComp.selectedTimeFrame) {
                            	component.setSelectedTimeFrame(userPrefComp.selectedTimeFrame);
                            }
                            else {
                            	component.setSelectedTimeFrame(null);
                            }
                            if(userPrefComp.selectedDataGroup) {
                            	component.setSelectedDataGroup(userPrefComp.selectedDataGroup);
                            }
                            else {
                            	component.setSelectedDataGroup(null);
                            }
                            //Set the component toggle status.  If defined as 'Required' in bedrock, override the users prefs.
                            //0 - off, 1 - on, 2 - required
                            if(userPrefComp.toggleStatus !== "undefined" && userPrefComp.toggleStatus !== null){
                            	if(jsonComponent.TS !== 2){ //TS is shorthand for Toggle Status
                            		component.setToggleStatus(userPrefComp.toggleStatus);
                            	}
                            	else{
                            		component.setToggleStatus(jsonComponent.TS); //TS is shorthand for Toggle Status
                            	}
                            }
                            else{
                            	component.setToggleStatus(jsonComponent.TS); //TS is shorthand for Toggle Status
                            }
                        }
                        else {
                            component.setExpanded(jsonComponent.EXP); //EXP is shorthand for Expanded
                            component.setColumn(jsonComponent.C_SQ); //C_SQ is shorthand for Column Sequence
                            component.setSequence(jsonComponent.R_SQ); //R_SQ is shorthand for Row Sequence
                            component.setPageGroupSequence(jsonComponent.G_SQ); //G_SQ is shorthand for Group Sequence
                            component.setCompColor(jsonComponent.THM); //THM is shorthand for Theme
                            component.setToggleStatus(jsonComponent.TS); //TS is shorthand for Toggle Status
                        }

                        component.setLabel(jsonComponent.LBL); //LBL is shorthand for Label
                        component.setMenuOptionNames(null);
						component.setMenuOptions(null);
                        component.setLink(jsonComponent.LNK); //LNK is shorthand for Link
                        component.setScrollNumber(jsonComponent.SCR_NM); //SCR_NM is shorthand for Scroll Number
                        component.setScrollingEnabled(jsonComponent.SCR_EN); //SCR_EN is shorthand for Scroll Enabled
                        component.setPlusAddEnabled((jsonComponent.PLS_AD == 1 ? true : false)); //PLS_AD is shorthand for Pluss Add Enabled
                        if (component.getLookbackUnits() === 0) { //check if the lookbackUnits has not been overridden
                            component.setLookbackUnits(jsonComponent.LB_UNT); //LB_UNT is shorthand for Lookback Units
                        }
                        if (component.getLookbackUnitTypeFlag() === 0) { //check if the lookbackUnitTypeFlag has been overridden
                            component.setLookbackUnitTypeFlag(jsonComponent.LB_TYP); //LB_TYP is shorthand for Lookback Type Flag
                        }
                        if (component.getBrLookbackUnits() === 0) {
                        	component.setBrLookbackUnits(jsonComponent.LB_UNT); //LB_UNT is shorthand for Lookback Units
						}
						if (component.getBrLookbackUnitTypeFlag() === 0) {
							component.setBrLookbackUnitTypeFlag(jsonComponent.LB_TYP); //LB_TYP is shorthand for Lookback Type Flag
						}
                        component.setDateFormat(jsonComponent.DT_DSP); //DT_DSP is shorthand for Date display Flag
                        if (component.getScope() === 0) {//check if the scope has not been overridden by the component requirements
                            component.setScope(jsonComponent.SCP); //SCP is shorthand for Scope
                        }

                        var compSetPrefFunc = GetComponentFilterFuncs(component.getStyles().getNameSpace(), jsonComponent.R_MN); //R_MN is shorthand for Report Mean
                        for (var y = 0, yl = jsonComponent.FILT.length; y < yl; y++) {
                            var filter = jsonComponent.FILT[y];

                            //make sure and skip known 'group' types
                            switch (filter.FC_MN) { //FC_MN is shorthand for Filter Category Mean
                                case "EVENT":
                                    var aValue = GetFilterValues(filter);
                                    if (compSetPrefFunc) {
                                        //Will retrieve the correct function and perform the function call if available
                                        if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                            break;
                                        }
                                    }
                                    var eGroup = new MPageEventCodeGroup();
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        eGroup.addEventCode(aValue[z].getId());
                                    }
                                    eGroup.setGroupId(filter.F_ID); //F_ID is shorthand for Filter Id(br_datamart_filter_id)
                                    eGroup.setGroupName(filter.F_MN); //F_MN is shorthand for Filter Mean
                                    eGroup.setSequence(filter.F_SQ); //F_SQ is shorthand for Filter Sequence
                                    component.addGroup(eGroup);
                                    break;
                                case "EVENT_SET":
                                case "PRIM_EVENT_SET":
                                    var aValue = GetFilterValues(filter);
                                    if (compSetPrefFunc) {
                                        //Will retrieve the correct function and perform the function call if available
                                        if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                            break;
                                        }
                                    }
                                    var eGroup = new MPageEventSetGroup();
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        eGroup.addEventSet(aValue[z].getId());
                                    }
                                    eGroup.setGroupId(filter.F_ID); //F_ID is shorthand for Filter Id(br_datamart_filter_id)
                                    eGroup.setGroupName(filter.F_MN); //F_MN is shorthand for Filter Mean
                                    eGroup.setSequence(filter.F_SQ); //F_SQ is shorthand for Filter Sequence
                                    component.addGroup(eGroup);
                                    break;
                                case "CATALOG_TYPE_CDS":
									var aValue = GetFilterValues(filter);
									if (compSetPrefFunc) {
										//Will retrieve the correct function and perform the function call if available
										if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
											break;
										}
									}
									var eGroup = new MPageCatalogCodeGroup();
									for (var z = 0, zl = aValue.length; z < zl; z++) {
										eGroup.addCatalogCode(aValue[z].getId());
									}
									eGroup.setGroupId(filter.F_ID); //F_ID is shorthand for Filter Id(br_datamart_filter_id)
									eGroup.setGroupName(filter.F_MN); //F_MN is shorthand for Filter Mean
									eGroup.setSequence(filter.F_SQ); //F_SQ is shorthand for Filter Sequence
									component.addGroup(eGroup);
									break;
                                case "COLOR_THEME_CDS":
								if (!userPrefComp || (!userPrefComp.compThemeColor)) {
									var aValue = GetFilterValues(filter);
									var color = aValue[0].m_meaning.replace("_", "").toLowerCase();
									component.setCompColor(color);
								}
                                break;

                                case "LOOK_BACK":
                                    var aValue = GetFilterValues(filter);
                                     if (compSetPrefFunc) {
                                        //Will retrieve the correct function and perform the function call if available
                                        if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                            break;
                                        }
                                    }
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        var value = aValue[z];
                                        var item = new MP_Core.MenuItem();
                                        item.setName(value.getName());
                                        item.setDescription(value.getDescription());
                                        item.setMeaning(value.getMeaning());
                                        var tempMeaning = item.getMeaning();
                                        switch(tempMeaning) {
											case"HOURS":item.setId(1);
											break;
											case"DAYS":item.setId(2);
											break;
											case"WEEKS":item.setId(3);
											break;
											case"MONTHS":item.setId(4);
											break;
											case"YEARS":item.setId(5);
											break;
										}
                                        component.addLookbackMenuItem(item);
                                    }
                                    //Add the default value to the menu
                                    var defaultItem = new MP_Core.MenuItem();
									defaultItem.setName("CODE_VALUE");
									defaultItem.setDescription(component.getBrLookbackUnits());
									defaultItem.setId(component.getBrLookbackUnitTypeFlag());
									component.addLookbackMenuItem(defaultItem);
                                    break;
                                case "PF_MULTI_SELECT":
                                    var aValue = GetFilterValues(filter);
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        var value = aValue[z];
                                        var item = new MP_Core.MenuItem();
                                        item.setName(value.getName());
                                        item.setDescription(value.getDescription());
                                        item.setId(value.getId());
                                        component.addMenuItem(item);
                                    }
                                    break;
                                case "CAT_TYPE_ASSIGN":
                                    var aValue = GetFilterValues(filter);
                                    if (compSetPrefFunc) {
                                        //Will retrieve the correct function and perform the function call if available
                                        if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                            break;
                                        }
                                    }
                                    var eGrouper = new MPageGrouper();
                                    var eGroup = null;
                                    var curSeq = -1;
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        var val = aValue[z];
                                        if (val.getSequence() != curSeq) {
                                            curSeq = val.getSequence();
                                            eGroup = new MPageCodeValueGroup();
                                            eGroup.setSequence(curSeq);
                                            eGrouper.addGroup(eGroup);
                                        }
                                        eGroup.addCode(val.getId());
                                    }
                                    component.addGroup(eGrouper);
                                    break;
                                case "CE_GROUP":
                                    //Understood that these grouped results have a title and then a list of event codes associated
                                    //to them.  The identifier for each group is that the group sequence is the same for the results.
                                    //Only one field will have a free text description, the other results will be event codes

                                    //because bedrock is nice enough to store the grouping of event codes seperate from a flat list of
                                    //the codes, overwrite the existing group with the new MPageGrouper
                                    var groups = component.getGroups();
                                    if (groups != null) {
                                        for (var z = 0, zl = groups.length; z < zl; z++) {
                                            var group = groups[z];
                                            if (group.getSequence() == filter.F_SQ) { //F_SQ is shorthand for Filter Mean
                                                var aValue = GetFilterValues(filter);
                                                if (compSetPrefFunc) {
                                                    //Will retrieve the correct function and perform the function call if available
                                                    if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                                        break;
                                                    }
                                                }
                                                var eGrouper = new MPageGrouper();
                                                eGrouper.setGroupId(group.getGroupId()); //for alignment with sequencing of groups
                                                eGrouper.setGroupName(group.getGroupName());
                                                var eGroup = null;
                                                var curSeq = -1;
                                                for (var i = 0, il = aValue.length; i < il; i++) {
                                                    var val = aValue[i];
                                                    if (val.getSequence() != curSeq) {
                                                        curSeq = val.getSequence();
                                                        eGroup = new MPageEventCodeGroup();
                                                        eGroup.setSequence(curSeq);
                                                        eGrouper.addGroup(eGroup);
                                                    }
                                                    var id = val.getId();
                                                    var desc = val.getDescription();
                                                    var name = val.getName();
                                                    if (id > 0){
                                                        eGroup.addEventCode(id);
                                                    }
                                                    if (desc != ""){
                                                        eGroup.setGroupName(desc);
                                                    }
                                                }
                                                groups[z] = eGrouper;
                                            }
                                        }
                                    }
                                    break;
                                case "IVIEW_SELECT":
                                    var aValue = GetFilterValues(filter);
                                    for (var z = 0, zl = aValue.length; z < zl; z++) {
                                        var value = aValue[z];
                                        var item = new MP_Core.MenuItem();
                                        item.setName(value.getName());
                                        item.setDescription(value.getDescription());
                                        item.setId(value.getId());
                                        item.setValSequence(value.getValueSequence());
                                        item.setValTypeFlag(value.getValueTypeFlag());
                                        component.addIViewMenuItem(item);
                                    }
                                    break;
                                default:
                                    var aValue = GetFilterValues(filter);
                                    if (compSetPrefFunc) {
                                        //Will retrieve the correct function and perform the function call if available
                                        if (compSetPrefFunc(component, filter.F_MN, aValue)) { //F_MN is shorthand for Filter Mean
                                            break;
                                        }
                                    }
                            }
                        }
                        /*Now that event have been acquired loop again to get the event sequences
                        in case the event sequences have a lower index in the array than the events*/
                        for (var y = 0, yl = jsonComponent.FILT.length; y < yl; y++) {
                                    var filter = jsonComponent.FILT[y];

                                    //make sure and skip known 'group' types
                                    switch (filter.FC_MN) { //FC_MN is shorthand for Filter Category Mean

                                        case "EVENT_SEQ":
                                            // 1) Find the group with the same sequence
                                            var groups = component.getGroups();
                                            if (groups) {
                                                for (var z = 0, zl = groups.length; z < zl; z++) {
                                                    var group = groups[z];
                                                    if (group.getSequence() == filter.F_SQ) { //F_SQ is shorthand for Filter Sequence
                                                        //if a group with the same sequence has been discovered, remove existing event codes
                                                        // and add with sequenced event codes
                                                        group.setEventCodes(null);
                                                        group.setSequenced(true);
                                                        var aValue = GetFilterValues(filter);
                                                        for (var a = 0, bl = aValue.length; a < bl; a++) {
                                                            group.addEventCode(aValue[a].getId())
                                                        }
                                                    }
                                                }
                                            }
                                            break;
                                        case "EVENT_SET_SEQ":
                                            // 1) Find the group with the same sequence
                                            var groups = component.getGroups();
                                            if (groups) {
                                                for (var z = 0, zl = groups.length; z < zl; z++) {
                                                    var group = groups[z];
                                                    if (group.getSequence() == filter.F_SQ) { //F_SQ is shorthand for Filter Sequence
                                                        //if a group with the same sequence has been discovered, remove existing event codes
                                                        // and add with sequenced event codes
                                                        group.setEventSets(null);
                                                        group.setSequenced(true);

                                                        //there is an exception case in regards to vital signs that an event set sequence
                                                        //could be created that contains results other than event sets.  So the following exception
                                                        //logic will be added to evaluate and create a new type of group to denote the change.

                                                        //first, place all values into a single array.  In addition, check if the types are the same,
                                                        // if all types are the same, setEventSets with the array of items found
                                                        // else, create a MPageSequenceGroup which hold multi type values and setItems with new array
                                                        //   and setMultiValue(true);
                                                        var aValue = GetFilterValues(filter);
                                                        var tempAr = [];
                                                        var tempMap = [];
                                                        var filterType = "CODE_VALUE"; //by default, all event codes or event set codes are type code value
                                                        var isMultiValue = false;
                                                        for (var zz = 0, zzl = aValue.length; zz < zzl; zz++) {
                                                            var val = aValue[zz];
                                                            tempAr.push(val.getId())
                                                            if (filterType != val.getName())
                                                                {isMultiValue = true;}
                                                            MP_Util.AddItemToMapArray(tempMap, val.getName(), val.getId())
                                                        }
                                                        if (isMultiValue) {
                                                            var eGroup = new MPageSequenceGroup();
                                                            eGroup.setMultiValue(isMultiValue);
                                                            eGroup.setItems(tempAr);
                                                            eGroup.setMapItems(tempMap);
                                                            eGroup.setSequence(true);
                                                            eGroup.setGroupId(group.getGroupId())
                                                            eGroup.setGroupName(group.getGroupName())
                                                            groups[z] = eGroup;
                                                        }
                                                        else {
                                                            group.setEventSets(tempAr);
                                                        }
                                                    }
                                                }
                                            }
                                            break;


                                        default:
                                            var aValue = GetFilterValues(filter);
                                            if (jsComponentFunc != null) {
                                                var filterFunc = GetFunctionByFilterMean(jsComponentFunc, filter.F_MN);  //F_MN is shorthand for Filter Mean
                                                if (filterFunc) {
                                                    var strFunc = GetValueFromComponentFunc(filterFunc, aValue);
                                                    var ret = eval(strFunc);
                                                }
                                            }
                                    }
                                }

                        returnAr.push(component);
                    }

                }
                return returnAr;
            }
        },
        /**
         * This function is used as a passthrough for the MPageComponent object during the migration to a new Generic
         * Component Loading scheme.
         */
	getComponentFilterFuncsPassthrough: function(namespace, reportMean){
		return GetComponentFilterFuncs(namespace, reportMean);
	}       
    }
    function GetFilterValues(jsonFilter){
        var aReturn = [];
        for (var x = 0, xl = jsonFilter.VALS.length; x < xl; x++) {
            var jsonValue = jsonFilter.VALS[x];
            var value = new MPageGroupValue();
            value.setId(jsonValue.PE_ID); //PE_ID is shorthand for 
            value.setName(jsonValue.PE_NM); //PE_NM is shorthand for 
            value.setMeaning(jsonValue.CDF_MN); //CDF_MN is shorthand for 
            value.setDescription(jsonValue.FTXT); //FTXT is shorthand for 
            value.setSequence(jsonValue.G_SQ); //G_SQ is shorthand for 
            value.setValueSequence(jsonValue.V_SQ); //V_SQ is shorthand for 
            value.setValueTypeFlag(jsonValue.V_TYP); //V_TYP is shorthand for 
            value.setQualifierFlag(jsonValue.Q_FLG); //Q_FLG is shorthand for 

            aReturn.push(value);
        }
        return aReturn;
    }
    function getComponentByFilterMean(filterMean){
    	var fMEAN = filterMean.toUpperCase();
    	switch(fMEAN){
    	case "DMS_ALLERGIES":
    	case "WF_ALLERGY":
    		return AllergyComponentWF;
    	case "ALLERGY":
    		return AllergyComponent;
    	case "ANCIL_DOC":
    		return DocumentComponent;
    	case "APNEA":
    		return ABDComponent;
    	case "CLIN_DOC":
    		return DocumentComponent;
        case "CONSOL_PROBLEMS":
        case "NARRATIVE_PROBLEM":
		    return CvComponent;
    	case "CURR_STATUS":
    		return CurStatusComponentO1;
    	case "DC_ACTIVITIES":
    		return ActivitiesComponent;
    	case "DC_CARE_MGMT":
    		return DischargePlanningComponent;
    	case "DMS_DIAGNOSIS":
    	case "DC_DIAGNOSIS":
    	case "DIAGNOSIS":
    	case "DX":
    		return DiagnosesComponent;
    	case "DC_ORDER":
    		return DischargeOrdersComponent;
    	case "DC_READINESS":
    		return DischargeIndicatorComponent;
    	case "DC_RESULTS":
    		return ResultsComponent;
    	case "DC_SOCIAL":
    		return SocialComponent;
    	case "ED_TIMELINE":
    		return TimelineComponent;
    	case "FAMILY_HX":
    		return FamilyHistoryComponent;
    	case "FIM":
    		return FunIndepMeasuresComponentO1;
    	case "FLAG_EVENTS":
    		return FlaggedEventsComponent;
    	case "FLD_BAL":
    		return IntakeOutputComponent;
    	case "FOLLOWUP":
    		return FollowUpComponent;
 		case "FUTURE_ORD":
			return FutureOrdersComponent;
		case "GOALS":
    		return GoalsComponentO1;
    	case "GRAPHS":
    		return VSTimelineComponent;
    	case "GROWTH_CHART":
    		return GrowthChartComponent;
    	case "HEALTH_MAINT":
    		return HmiComponent;
		case "WF_HEALTH_MAINT":
    		return RecommendationsO2Component;
    	case "HOME_MEDS":
    		return HomeMedicationsComponent;
    	case "ICU_FLOWSHEET":
    		return ICUFlowsheetComponent;
    	case "IMMUNIZATIONS":
    		return ImmunizationComponent;
    	case "INCOMPLETE_ORDERS":
    	case "ORDERS":
    		return OrdersComponent;
    	case "INTER_TEAM":
    		return InterTeamComponentO1;
    	case "DMS_LAB":
    		return LabPagerComponent;
    	case "LAB":
    		return LaboratoryComponent;
    	case "LINES":
    		return LinesTubesDrainsComponent;
    	case "MEDS":
    		return MedicationsComponent;
    	case "MED_REC":
    		return MedicationReconciliationComponent;
    	case "WF_MBIOLOGY":
    		return MicrobiologyComponentWF;
    	case "MICRO":
    		return MicrobiologyComponent;
    	case "NC_DC_PLAN":
    		return DischargePlanComponent;
    	case "NC_OVERDUE_TASKS":
    	case "OVERDUE_TASKS":
    		return TaskActivityComponent;
    	case "NC_PLAN":
    		return PlanofCareComponent;
    	case "NC_PSYCHOSOC":
    		return PsychosocialFactorsComponent;
    	case "NC_PT_ASSESS":
    		return PatientAssessmentComponent;
    	case "NC_PT_BACKGROUND":
    		return PatientBackgroundComponent;
		case "NEO_OVERVIEW": 
			return NeonateOverviewComponent;
		case "NEO_TASK_TIMELINE": 
			return NeonateTaskTimelineComponent;
		case "NEO_WEIGHT": 
			return NeonateMeasurementComponent;
		case "NEO_HYPERBILI": 
			return NeonateBilirubinComponent;
		case "NEO_TRANSFUSION": 
			return NeonateTransfusionComponent;	    		
    	case "NEW_DOC":
    		return NewDocumentEntryComponent;
    	case "NEW_ORDERS":
    		return NewOrderEntryComponent;
    	case "NOTES":
    		return NotesRemindersComponent;
    	case "PATH":
    		return PathologyComponent;
		case "WF_PATH":
    		return Pathologyo2Component;
    	case "PAT_ED":
    	case "PT_ED":
    		return PatientFamilyEduSumComponent;
    	case "PRECAUTIONS":
    		return PrecautionsComponentO1;
    	case "PREG_ASSESS":
    		return PresAssessInitialExamComponent;
    	case "PREG_ASSESS_2":
    		return PregAssessment2Component;
		case "PREG_ASSESS_3":
    		return PregAssessment3Component;
    	case "PREG_BIRTH_PLAN":
    		return BirthPlanComponent;
    	case "PREG_ED":
    		return EducationAndCounselingComponent;
    	case "PREG_EDD_MAINT":
    		return EDDMaintenanceComponent;
    	case "PREG_FETAL_MON":
    		return FetalMonitoringComponent;
    	case "PREG_GENETIC_SCR":
    		return GeneticScreeningComponent;
    	case "PREG_HX":
    		return PregnancyHistoryComponent;
    	case "PREG_OVERVIEW":
    		return PregnancyOverviewComponent;
    	case "PREG_RESULTS":
    		return ResultTimelineComponent;
    	case "PT_INFO":
    		return PatientInfoComponent;
    	case "RAD":
    		return DiagnosticsComponent;
    	case "RESP":
    		return RespiratoryComponent;
    	case "RESP_ASSESS":
    		return RespAssessmentsComponent;
    	case "RESP_TX":
    		return RespTreatmentsComponent;
    	case "SIG_EVENTS":
    		return SignificantEventO1Component;
    	case "SOCIAL_HX":
    		return SocialHistoryComponent;
    	case "SURG_PROC_HX":
    		return Procedure2Component;
    	case "TREATMENTS":
    		return TreatmentsComponentO1;
    	case"TRIAGE_DOCUMENT":
    		return TriageDocComponent;
    	case "VISITS":
    		return VisitsComponent;
    	case "VS":
    		return VitalSignComponent;
    	case "WF_RAD":
    		return DiagnosticsComponent2;      		
    	case "WEIGHT":
    		return WeightsComponent;
    	case "WF_MEDS":
    		return MedicationsComponentO2;			
    	case "PROC_INFO":
            return ProceduralInfoComponent;
        case "PERIOP_TRACK":
            return PeriopTrackComponent;
        case "INTRAOP_SUMMARY":
            return IntraopSummaryComponent;
        case "PREOP_CHECKLIST":
           return PreopChcklstComponent;
        case "POSTOP_SUMMARY":
            return PostopSummaryComponent;
        case "EP_DA":
        	return DiscernAnalyticsComponent;
    	case "DMS_REFERENCE":
    		return ClinicalDecSuppComponent;
    	case "DMS_SCREENINGS":
    		return ScreeningsComponent;
    	case "DMS_DIET":
    		return DietsComponent;
    	case "DMS_ANTIDIABETIC":
    		return MedsSpecificComponent;
    	case "DMS_MEDS_GLUC_LVL":
    		return MedsGlucoseComponent;
    	case "DMS_INS_24_HRS":
    		return InsulinReqComponent;
    	case "DMS_GRAPH":
    		return DiabetesGraphComponent;
		case "CLIN_TRIALS":
            return ClinicalTrialsComponent;
		case "CHEMO_REVIEW":
            return ChemotherapyReviewComponent;
		case "WF_ASSESSMENT_PLAN":
            return DocumentationIPComponent;
		case "WF_CHIEF_COMPLAINT":
    	   return ChiefComplaintComponent;
        case "WF_FLD_BAL":
        	return IntakeOutputOpt2Component;
        case "WF_HOME_MEDS":
    		return HomeMedicationsComponent2;
		case "WF_HX_PRESENT_ILL":
            return DocumentationHPIComponent;
        case "WF_INCOMPLETE_ORDERS":
        	return OrdersOpt2Component;
    	case "WF_NEW_ORDERS":
    		return NewOrderEntryO2Component;
       	case "WF_ORDER_PROFILE":
       		return OrderProfileComponent;
		case "WF_PHYSICAL_EXAM":
            return DocumentationPEComponent;
		case "WF_REVIEW_SYMPT":
            return DocumentationROSComponent;
        case "THER_TREAT":
            return TherTreatmentComponent;
        case "SAFETY":
            return SafetyComponent;
        case "BH_ASSESSMENTS":
            return BhAssessmentComponent;	
        case "OPH_SCRIPTS":
            return OphPrescriptionComponent
        case "OPH_MEASUREMENTS":    
            return OphMeasurementComponent; 					
    	default:
    		logger.logMessage("Unknown filter mean: [" + fMEAN + "]. The component may have been deprecated, or it failed to be loaded in the static content.");
            return DummyComponent;
    	}
    }
    function BRCompPrefSetFuncCreation(filterMappings){
        //Function to return so that the mapped function can be executed.
        var ExecuteBRPrefFunction = function(component, filterMean, brFilterValues){
            var execResult;
            var functionArgs = [];
            var filter;
            var filterField;
            var filterType;
            var functionCall;
            var i;
            var setFuncName;

            if (!filterMean || !brFilterValues) {
                return false;
            }
            //Look through the mappings and see if one exists with the necessary information
            for (i = filterMappings.length; i--;) {
                filter = filterMappings[i];
                if (filter.m_filterMean.toUpperCase() === filterMean.toUpperCase()) {
                    setFuncName = filter.m_functionName;
                    filterType = filter.m_dataType;
                    filterField = filter.m_field;
                    break;
                }
            }

            if (!setFuncName) {
                return false;
            }
            else {
                //Use the components filter setting function to set the pref
                for (var x = brFilterValues.length; x--;) {
                    var val = brFilterValues[x];
                    switch (filterField.toUpperCase()) {
                        case "FREETEXT_DESC":
                        case "FTXT":
                            functionArgs.push(val.getDescription());
                            break;
                        case "PARENT_ENTITY_ID":
                        case "PE_ID":
                            functionArgs.push(val.getId());
                            break;
                        case "NOMEN":    
                        	functionArgs.push('{"nomen_id":' + val.getId() + ', "seq":' + val.getValueSequence() + ', "qual_flag":' + val.getQualifierFlag() +  "}"); 
                        	break;
                        case "VALUE_SEQ":    
                        case "V_SQ":  
                        	functionArgs.push('{"id":' + val.getId() + ', "seq":' + val.getValueSequence() + "}"); 			      
                       		break;                            
						case "LOOK_BACK":
							functionArgs.push("{value:" + val.getDescription() + ", units:\"" + val.getMeaning() + "\"}");
							break;
                        default:
                            break;
                    }
                }
                switch (filterType.toUpperCase()) {
                    case "ARRAY":
                        functionCall = "component." + setFuncName + "([" + functionArgs.join(",") + "])";
                        break;
                    case "STRING":
                        functionCall = "component." + setFuncName + "('" + functionArgs.join(",") + "')";
                        break;
                    case "NUMBER":
                        functionCall = "component." + setFuncName + "(" + functionArgs.join(",") + ")";
                        break;
                    case "BOOLEAN":
                        var bVal = (functionArgs[0] == "1") ? true : false;
                        functionCall = "component." + setFuncName + "(" + bVal + ")";
                        break;
                    case "OBJECT":
                        functionCall = "component." + setFuncName + "(" + functionArgs.join(",") + ")";
                        break;						
					case "NOMEN":
					case "VALUE_SEQ":
                    	functionCall = "component." + setFuncName + "([" + functionArgs.join(",") + "])";
                    	break;                        
                    default:
                        break;
                }
                eval(functionCall);
                return true;
            }
        };
        return ExecuteBRPrefFunction;
    }
    function FilterMapping(filterMean, functionName, dataType, field){
        this.m_filterMean = filterMean;
        this.m_functionName = functionName;
        this.m_dataType = dataType;
        //Perform a conversion to the shorthand versions of the BEdrock Filter Mappings field names
        this.m_field = (typeof MP_Bedrock.bedrockShorthandConversions[field] != 'undefined') ? MP_Bedrock.bedrockShorthandConversions[field] : field;
    }
    function GetComponentFilterFuncs(nameSpace, reportMean){
        var compFilterMaps = [];
		var custCompNum;
        if (nameSpace) {
            switch (nameSpace) {
                case 'abd':
                    compFilterMaps.push(new FilterMapping("MP_ABD_PT_DAYS", "setAgeDays", "Number", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_APNEA", "setApneaEventCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_APNEA_NOMEN", "setApneaNomenIds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_BRADY", "setBradyEventCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_BRADY_NOMEN", "setBradyNomenIds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_DESAT", "setDesatEventCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_DESAT_NOMEN", "setDesatNomenIds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_O2_SAT", "setO2SatCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_HR", "setHRCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_SKIN_COLOR", "setSkinColorCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_ACTIVITY", "setActivityCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_POSITION", "setPositionCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_STIMULATION", "setStimulationCds", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MP_ABD_DURATION", "setDurationCds", "Array", "PARENT_ENTITY_ID"));
                    break;
				case 'bp':
					compFilterMaps.push(new FilterMapping("PREG_BIRTH_PLAN_PF", "setBirthPlanPF", "Number", "PARENT_ENTITY_ID"));
					break;
                case 'cm':
                    compFilterMaps.push(new FilterMapping("DC_DC_PLAN_CE", "setDischScreenPlan", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_DC_DISP_CE", "setDischDisposition", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_TRANSP_ARR_CE", "setDocTransArrangement", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_PROF_SKILL_ANT_CE", "setProfSkillServices", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_DME_ANT_CE", "setDurableMedEquipment", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_DME_COORD_CE", "setDurableMedEquipmentCoordinated", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_PLAN_DC_DT_TM_CE", "setPlannedDischDate", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_ADM_MIM_CE", "setAdmissionMIMSigned", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DC_DSCH_MIM_CE", "setDischMIMGiven", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'chief':
                	compFilterMaps.push(new FilterMapping("WF_CHIEF_COMP_DOC","setClinicalEventSets","Array","PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("WF_CHIEF_COMP_EDIT","setModifyInd","Boolean","FREETEXT_DESC"));
                    break;
                case 'cv':
                    compFilterMaps.push(new FilterMapping("DEFAULT_SEARCH_VOCAB", "setDefaultSearchVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VISIT_VOCAB", "setVisitVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ACTIVE_VOCAB", "setActiveVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ACTIVE_LABEL", "setActiveLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("VISIT_LABEL", "setVisitLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HISTORICAL_LABEL", "setHistoricalLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("CP_QUICK_ADD_TYPE_DX", "setVisitAddType", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CP_QUICK_ADD_CLASS", "setActiveAddClass", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CP_QUICK_ADD_TYPE_CONFIRM", "setActiveAddType", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CP_QUICK_ADD_CLASS_DX", "setVisitAddClass", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CP_QUICK_ADD_CONF_STATUS", "setVisitAddConf", "Number", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("MODAL_DIALOG_IND", "setModifyInd", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("THIS_VISIT_PRIORITY_IND","setEnableModifyPrioritization","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NARR_DEFAULT_SEARCH_VOCAB","setDefaultSearchVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_VISIT_VOCAB","setVisitVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_ACTIVE_VOCAB","setActiveVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_ACTIVE_LABEL","setActiveLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NARR_VISIT_LABEL","setVisitLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NARR_HISTORICAL_LABEL","setHistoricalLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NARR_CP_QK_ADD_TYPE_DX","setVisitAddType","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_CP_QUICK_ADD_CLASS","setActiveAddClass","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_CP_QK_ADD_TYPE_CFRM","setActiveAddType","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_CP_QK_ADD_CLASS_DX","setVisitAddClass","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_CP_QK_ADD_CONF_STAT","setVisitAddConf","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NARR_MODAL_DIALOG_IND","setModifyInd","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NARR_THIS_VISIT_PRIORITY_IND","setEnableModifyPrioritization","Boolean","FREETEXT_DESC"));
					break;
                case 'cv2':
                    //For Workflow Components
                    compFilterMaps.push(new FilterMapping("WF_DEFAULT_SEARCH_VOCAB", "setDefaultSearchVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_VISIT_VOCAB", "setVisitVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_ACTIVE_VOCAB", "setActiveVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_ACTIVE_LABEL", "setActiveLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_VISIT_LABEL", "setVisitLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HISTORICAL_LABEL", "setHistoricalLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_CP_QUICK_ADD_TYPE_DX", "setVisitAddType", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_CP_QUICK_ADD_CLASS", "setActiveAddClass", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_CP_QUICK_ADD_TYPE_CONFIRM", "setActiveAddType", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_CP_QUICK_ADD_CLASS_DX", "setVisitAddClass", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_CP_QUICK_ADD_CONF_STATUS", "setVisitAddConf", "Number", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_MODAL_DIALOG_IND", "setModifyInd", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_THIS_VISIT_PRIORITY_IND","setEnableModifyPrioritization","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_DEFAULT_SEARCH_VOCAB","setDefaultSearchVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_VISIT_VOCAB","setVisitVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_ACTIVE_VOCAB","setActiveVocab","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_ACTIVE_LABEL","setActiveLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_VISIT_LABEL","setVisitLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_HISTORICAL_LABEL","setHistoricalLabel","String","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_CP_QK_ADD_TYPE_DX","setVisitAddType","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_CP_QUICK_ADD_CLASS","setActiveAddClass","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_CP_QK_ADD_TYPE_CFRM","setActiveAddType","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_CP_QK_ADD_CLASS_DX","setVisitAddClass","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_CP_QK_ADD_CONF_STAT","setVisitAddConf","Number","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_MODAL_DIALOG_IND","setModifyInd","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_NARR_THIS_VISIT_PRIORITY_IND","setEnableModifyPrioritization","Boolean","FREETEXT_DESC"));					
                    break;
                case 'curstat':
                    compFilterMaps.push(new FilterMapping("CS_ASSESSMENTS", "setAssessmentEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_VITAL_MEASURE", "setVitalMeasureEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_BOWEL_BLADDER", "setBowelBladderEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_SKIN_ASSESS_TOL", "setSkinAssessTolEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_ORTHOTICS_SCHED", "setOrthonticsShedEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_ADL", "setADLEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_IADL", "setIADLEventSets", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CS_COG_COMMUNICATE", "setCogCommunicateEventSets", "Array", "PARENT_ENTITY_ID"));
                    break;
                case "da":
					compFilterMaps.push(new FilterMapping("EP_DA_TEXT","setCustTxt","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("EP_DA_PF","setFormId","String","PARENT_ENTITY_ID"));
					break;
				case 'dg2':
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP1_LABEL","setLabel1","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_ES","setEvents1","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP2_LABEL","setLabel2","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP2_ES","setEvents2","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP3_LABEL","setLabel3","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP3_ES","setEvents3","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP4_LABEL","setLabel4","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP4_ES","setEvents4","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP5_LABEL","setLabel5","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP5_ES","setEvents5","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP6_LABEL","setLabel6","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP6_ES","setEvents6","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP7_LABEL","setLabel7","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP7_ES","setEvents7","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP8_LABEL","setLabel8","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP8_ES","setEvents8","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP9_LABEL","setLabel9","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP9_ES","setEvents9","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP10_LABEL","setLabel10","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_DIAGNOSTICS_GRP10_ES","setEvents10","Array","PARENT_ENTITY_ID"));
					break;					
				case 'dishord':
                    compFilterMaps.push(new FilterMapping("DC_ORDER_SELECT", "setCatalogCodes", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'doc':
                	compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP1_LABEL","setGrp1Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP1_ES","setGrp1Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP2_LABEL","setGrp2Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP2_ES","setGrp2Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP3_LABEL","setGrp3Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP3_ES","setGrp3Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP4_LABEL","setGrp4Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP4_ES","setGrp4Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP5_LABEL","setGrp5Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP5_ES","setGrp5Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP6_LABEL","setGrp6Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP6_ES","setGrp6Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP7_LABEL","setGrp7Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP7_ES","setGrp7Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP8_LABEL","setGrp8Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP8_ES","setGrp8Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP9_LABEL","setGrp9Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP9_ES","setGrp9Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP10_LABEL","setGrp10Label","String","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DOC_SPECIALTY_GRP10_ES","setGrp10Criteria","Array","PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("DOC_POWERNOTE_FAVOR_IND","setPowerNoteFavInd","Boolean","FREETEXT_DESC"));
					break;
                case 'dx':
                    compFilterMaps.push(new FilterMapping("DIAGNOSIS_TYPE", "setDiagnosisType", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DX_QUICK_ADD_VOCAB", "setDiagnosisVocab", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DX_QUICK_ADD_TYPE", "setDiagnosisAddTypeCd", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DX_QUICK_ADD_CLASS_DX", "setDiagnosisClassification", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("DX_QUICK_ADD_VOCAB_IND", "setDiagnosisVocabInd", "Number", "FREETEXT_DESC"));
                    break;
                case 'edu':
                    compFilterMaps.push(new FilterMapping("PREG_ED_PF", "setEdCounselingPF", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'fim':
                    compFilterMaps.push(new FilterMapping("TARGET_DC_DT", "setAnticipatedDischargeDateDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ANTI_DISPOSITION", "setAnticipatedDispositionDateDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PRIMARY_IMPAIR_CDS", "setPrimaryImpairmentCodeDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_EAT", "setEatingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_EAT_GOAL", "setEatingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_GROOM", "setGroomingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_GROOM_GOAL", "setGroomingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BATH", "setBathingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BATH_GOAL", "setBathingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_UP_EXT_DRESS", "setUpperExtremityDressingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_UP_EXT_DRESS_GOAL", "setUpperExtremityDressingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOW_EXT_DRESS", "setLowerExtremityDressingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOW_EXT_DRESS_GOAL", "setLowerExtremityDressingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TOILET", "setToiletingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TOILET_GOAL", "setToiletingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BLAD_LEV_ASSIST", "setBladderLevelofAssistanceDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BLAD_LEV_ASSIST_GOAL", "setBladderLevelofAssistanceGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BLAD_ACC", "setBladderAccidentsDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BLAD_ACC_4", "setBladderAccidentsPast4DaysDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BOWEL_LEV_ASSIST", "setBowelLevelofAssistanceDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BWL_LVL_ASSIST_GOAL", "setBowelLevelofAssistanceGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BOWEL_ACC", "setBowelAccidentsDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BOWEL_ACC_4", "setBowelAccidentsPast4DaysDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BED_CHAIR_WHEEL", "setBedChairWheelChairDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_BED_CHAIR_WHEEL_GOAL", "setBedChairWheelChairGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TOILET_TRANS", "setToiletTransferDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TOILET_TRANS_GOAL", "setToiletTransferGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TUB_TRANS", "setTubTransferDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_SHOWER_TRANS", "setShowerTransferDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_TUB_SHOWER_GOAL", "setTubShowerTransfergoaldocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_WALK", "setLocomotionWalkDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_WALK_GOAL", "setLocomotionWalkGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_WHEEL", "setLocomotionWheelChairDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_WHEEL_GOAL", "setLocomotionWheelChairGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_STAIR", "setLocomotionStairDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_MOTOR_LOCO_STAIR_GOAL", "setLocomotionStairGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_COMP", "setComprehensionDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_COMP_GOAL", "setComprehensionGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_EXPRESS", "setExpressionDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_EXPRESS_GOAL", "setExpressionGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_SOC_INTER", "setSocialInteractionDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_SOC_INTER_GOAL", "setSocialInteractionGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_PROB_SOLVE", "setProblemSolvingDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_PROB_SOLVE_GOAL", "setProblemSolvingGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_MEMORY", "setMemoryDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("FIM_COG_MEMORY_GOAL", "setMemoryGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    break;
				case 'fo':
					compFilterMaps.push(new FilterMapping("CAT_TYPE_1", "setTab1", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_1_DISP", "setTabDisplay1", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_2", "setTab2", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_2_DISP", "setTabDisplay2", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_3", "setTab3", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_3_DISP", "setTabDisplay3", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_4", "setTab4", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_4_DISP", "setTabDisplay4", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_5", "setTab5", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_5_DISP", "setTabDisplay5", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_6", "setTab6", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_6_DISP", "setTabDisplay6", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_7", "setTab7", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_7_DISP", "setTabDisplay7", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_8", "setTab8", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_8_DISP", "setTabDisplay8", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_9", "setTab9", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_9_DISP", "setTabDisplay9", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CAT_TYPE_10_DISP", "setAllTabDisplay", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("FUTURE_ORD_LOOK_BACK", "setLookBack", "Number", "LOOK_BACK"));
					compFilterMaps.push(new FilterMapping("FUTURE_ORD_LOOK_FORWARD", "setLookAhead", "Number", "LOOK_BACK"));
					break;
                case 'goals':
                    compFilterMaps.push(new FilterMapping("NURSE_GOAL_DOC", "setNursingGoals", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("OT_STG_DOC", "setOTShortTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("OT_LTG_DOC", "setOTLongTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PT_STG_DOC", "setPTShortTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PT_LTG_DOC", "setPTLongTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("SLP_STG_DOC", "setSLPShortTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("SLP_LTG_DOC", "setSLPLongTermGoalDocumented", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'hivprofile':
                    compFilterMaps.push(new FilterMapping("HIV_DISCLAIMER", "setDisclaimerText", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HIV_PROFILE_REPORT", "setFinalReportEventCode", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PR_MUTATION", "setPrEventCode", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PR_MUTATION_NOMEN", "setPrNoMutationsFilter", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("RT_MUTATION", "setRtEventCode", "Number", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("RT_MUTATION_NOMEN", "setRtNoMutationsFilter", "String", "FREETEXT_DESC"));
                    break;
				case 'hml':
                    compFilterMaps.push(new FilterMapping("MEDS_MODS", "setMedModInd", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("DISCH_MED_REC_MOD","setMedRec","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM1_LABEL", "setGrp1Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM1", "setGrp1Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM2_LABEL", "setGrp2Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM2", "setGrp2Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM3_LABEL", "setGrp3Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM3", "setGrp3Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM4_LABEL", "setGrp4Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM4", "setGrp4Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM5_LABEL", "setGrp5Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM5", "setGrp5Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM6_LABEL", "setGrp6Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM6", "setGrp6Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM7_LABEL", "setGrp7Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM7", "setGrp7Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM8_LABEL", "setGrp8Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM8", "setGrp8Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM9_LABEL", "setGrp9Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM9", "setGrp9Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM10_LABEL", "setGrp10Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HOME_MEDS_MULTUM10", "setGrp10Criteria", "Array", "PARENT_ENTITY_ID"));

                    break;
                case 'hml2':
                    compFilterMaps.push(new FilterMapping("WF_MEDS_MODS", "setMedModInd", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_DISCH_MED_REC_MOD","setMedRec","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM1_LABEL", "setGrp1Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM1", "setGrp1Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM2_LABEL", "setGrp2Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM2", "setGrp2Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM3_LABEL", "setGrp3Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM3", "setGrp3Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM4_LABEL", "setGrp4Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM4", "setGrp4Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM5_LABEL", "setGrp5Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM5", "setGrp5Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM6_LABEL", "setGrp6Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM6", "setGrp6Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM7_LABEL", "setGrp7Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM7", "setGrp7Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM8_LABEL", "setGrp8Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM8", "setGrp8Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM9_LABEL", "setGrp9Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM9", "setGrp9Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM10_LABEL", "setGrp10Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("WF_HOME_MEDS_MULTUM10", "setGrp10Criteria", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'icufs':
                    compFilterMaps.push(new FilterMapping("VITALS_GRAPH_LABEL", "setBPGraphTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("VITALS_HEMO_LABEL", "setVitalLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_LABEL", "setLabLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("RESP_LABEL", "setRespLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEURO_LABEL", "setNeuroLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ENDO_LABEL", "setEndoLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MULTUM_CLASS_VITALS_HEMO", "setHemoMultumClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MULTUM_SEQ_VITALS_HEMO", "setHemoMultumSeqClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NON_TITRATE_MED_IND_HEMO", "setHemoNonTitrateInd", "Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MULTUM_CLASS_RESP", "setRespMultumClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MULTUM_SEQ_RESP", "setRespMultumSeqClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NON_TITRATE_MED_IND_RESP", "setRespNonTitrateInd", "Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MULTUM_CLASS_NEURO", "setNeuroMultumClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MULTUM_SEQ_NEURO", "setNeuroMultumSeqClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NON_TITRATE_MED_IND_NEURO", "setNeuroNonTitrateInd", "Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MULTUM_CLASS_ENDO", "setEndoMultumClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MULTUM_SEQ_ENDO", "setEndoMultumSeqClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NON_TITRATE_MED_IND_ENDO", "setEndoNonTitrateInd", "Boolean","FREETEXT_DESC"));
                    break;
                case 'intm':
                    compFilterMaps.push(new FilterMapping("TEAM_CONF_ORDER", "setTeamConfOrder", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAST_TEAM_DISC", "setLastTeamDiscussionDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BARRIERS_DC_DOC", "setBarriersToDischargeDocumented", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PRIM_OT_NAME_DOC", "setPrimaryOccupationalTherapists", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PRIM_PT_NAME_DOC", "setPrimaryPhysicalTherapists", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PRIM_ST_NAME_DOC", "setPrimarySpeechTherapists", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'io':
                    compFilterMaps.push(new FilterMapping("OUTPUT_COUNT", "setCounts", "Array", "PARENT_ENTITY_ID"));                    
                    break;
                case 'io2':
                    compFilterMaps.push(new FilterMapping("WF_OUTPUT_COUNT", "setCounts", "Array", "PARENT_ENTITY_ID"));
                    break;    
                case 'lab':
                    compFilterMaps.push(new FilterMapping("LAB_PRIMARY_LABEL", "setPrimaryLabel", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_RESULTS_IND", "setShowTodayValue", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP1_LABEL", "setGrp1Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP1_ES", "setGrp1Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP2_LABEL", "setGrp2Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP2_ES", "setGrp2Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP3_LABEL", "setGrp3Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP3_ES", "setGrp3Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP4_LABEL", "setGrp4Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP4_ES", "setGrp4Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP5_LABEL", "setGrp5Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP5_ES", "setGrp5Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP6_LABEL", "setGrp6Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP6_ES", "setGrp6Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP7_LABEL", "setGrp7Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP7_ES", "setGrp7Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP8_LABEL", "setGrp8Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP8_ES", "setGrp8Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP9_LABEL", "setGrp9Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP9_ES", "setGrp9Criteria", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP10_LABEL", "setGrp10Label", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("LAB_SPECIALTY_GRP10_ES", "setGrp10Criteria", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'ld':
                    compFilterMaps.push(new FilterMapping("LINES_ES", "setLineCodes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("TUBES_DRAINS_ES", "setTubeCodes", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'med':
		    		compFilterMaps.push(new FilterMapping("MEDS_SCHED", "setScheduled", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MEDS_PRN","setPRN","Boolean","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_DISC","setDiscontinued","Boolean","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_ADM","setAdministered","Boolean","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_SUS","setSuspended","Boolean","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_CONT","setContinuous","Boolean","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_ADM_LB_HRS","setAdministeredLookBkHrs","Number","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_DISC_LB_HRS","setDiscontinuedLookBkHr","Number","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_SCHED_NEXT_DOSE","setScheduleNextDose","Number","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_PRN_LAST_DOSE","setPRNLastDose","Number","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_SCHED_NEXT_12","setSchedNextTwelve","Number","FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("MEDS_PRN_LAST_48","setPRNLastFortyEight","Number","FREETEXT_DESC"));
                    break;
                case 'nde':
                    compFilterMaps.push(new FilterMapping("NEW_DOC_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_TITLE", "setDocTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_SECT_LABEL_1", "setLabelOne", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_SECT_LABEL_2", "setLabelTwo", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_SECT_LABEL_3", "setLabelThree", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_SECT_LABEL_4", "setLabelFour", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("NEW_DOC_CE", "setDocEventCode", "Number", "PARENT_ENTITY_ID"));
                    break;
                case 'noe':
					compFilterMaps.push(new FilterMapping("ORD_SRCH_IND", "setOrderSearchInd", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("NEW_ORD_ENTRY", "setVenueType", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("ORDER_POWERPLAN_IND", "setPowerPlanEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("PERSONAL_FAV_OE", "setUserFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("PERSONAL_FAV_LABEL", "setUserFavLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("PUBLIC_FAV_OE", "setPublicFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("PUBLIC_FAV_LABEL", "setPublicFavLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("SHARED_FAV_OE", "setSharedFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("SHARED_FAV_LABEL", "setSharedFavLabel", "String", "FREETEXT_DESC"));
					break;
                case 'noe2':
					compFilterMaps.push(new FilterMapping("WF_ORD_SRCH_IND", "setOrderSearchInd", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_NEW_ORD_ENTRY", "setVenueType", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_ORDER_POWERPLAN_IND", "setPowerPlanEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_PERSONAL_FAV_OE", "setUserFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_PERSONAL_FAV_LABEL", "setUserFavLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_PUBLIC_FAV_OE", "setPublicFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_PUBLIC_FAV_LABEL", "setPublicFavLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_SHARED_FAV_OE", "setSharedFavEnabled", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_SHARED_FAV_LABEL", "setSharedFavLabel", "String", "FREETEXT_DESC"));
					break;
                case 'nr':
                    compFilterMaps.push(new FilterMapping("STICKY_NOTE_TYPES", "setStickyNoteTypeCodes", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'ohx':
					compFilterMaps.push(new FilterMapping("ORDER_HX_STATUS_IND", "setOHStatusOpt", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("ORDER_HX_CAT_TYPE", "setOHCatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP1_LABEL", "setGrp1CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP1_ORD", "setGrp1CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP2_LABEL", "setGrp2CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP2_ORD", "setGrp2CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP3_LABEL", "setGrp3CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP3_ORD", "setGrp3CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP4_LABEL", "setGrp4CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP4_ORD", "setGrp4CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP5_LABEL", "setGrp5CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP5_ORD", "setGrp5CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP6_LABEL", "setGrp6CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP6_ORD", "setGrp6CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP7_LABEL", "setGrp7CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP7_ORD", "setGrp7CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP8_LABEL", "setGrp8CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP8_ORD", "setGrp8CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP9_LABEL", "setGrp9CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP9_ORD", "setGrp9CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP10_LABEL", "setGrp10CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("CUSTOM_CATALOG_GRP10_ORD", "setGrp10CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					break;    
                case 'ohx2':
					compFilterMaps.push(new FilterMapping("WF_ORDER_HX_STATUS_IND", "setOHStatusOpt", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_ORDER_HX_CAT_TYPE", "setOHCatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP1_LABEL", "setGrp1CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP1_ORD", "setGrp1CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP2_LABEL", "setGrp2CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP2_ORD", "setGrp2CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP3_LABEL", "setGrp3CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP3_ORD", "setGrp3CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP4_LABEL", "setGrp4CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP4_ORD", "setGrp4CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP5_LABEL", "setGrp5CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP5_ORD", "setGrp5CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP6_LABEL", "setGrp6CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP6_ORD", "setGrp6CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP7_LABEL", "setGrp7CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP7_ORD", "setGrp7CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP8_LABEL", "setGrp8CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP8_ORD", "setGrp8CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP9_LABEL", "setGrp9CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP9_ORD", "setGrp9CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP10_LABEL", "setGrp10CatLabel", "String", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_CUSTOM_CATALOG_GRP10_ORD", "setGrp10CatalogCodes", "Array", "PARENT_ENTITY_ID"));
					break;
				case 'op':
					compFilterMaps.push(new FilterMapping("WF_ORDER_PROFILE_GRP", "setOPOrderGrouping", "Number", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_PEND_ORDER_CS", "setOPPendingOrderStatuses", "Array", "PARENT_ENTITY_ID"));
					break;
                case 'ord':
                    compFilterMaps.push(new FilterMapping("INCOMPLETE_ORDERS_CAT_TYPE", "setCatalogCodes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("INCOMPLETE_ORDERS_STATUS", "setOrderStatuses", "Array", "PARENT_ENTITY_ID"));
                    break;                   
                case 'ordsel':
                    compFilterMaps.push(new FilterMapping("ROOT_FAVORITE", "setFavFolderId", "Number", "PARENT_ENTITY_ID"));
                    break;
                case 'pbg':
                    compFilterMaps.push(new FilterMapping("NC_PAIN_SCR", "setPainScores", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_ASSIST_DEV", "setDevices", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_DIET_ORD", "setDietOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_PT_ACT_ORD", "setPatientActivityOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_RESUS_ORD", "setResucitationOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_SEIZURE_ORD", "setSeizureOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_ISOLATION_ORD", "setIsolationOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_ADV_DIR", "setAdvancedDirectives", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_PARA", "setParas", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_GRAVIDA", "setGravidas", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_FALL_PRECAUTIONS", "setFallPrecautions", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'pc':
                    compFilterMaps.push(new FilterMapping("NC_PLAN_STATUS", "setPlanStatusCodes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NC_PLAN_CLASS", "setPlanClassificationCodes", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'pa':
                    compFilterMaps.push(new FilterMapping("PREG_ASSESS_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("PREG_ANTEPARTUM_NOTE", "setAntepartumNote", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_ENC_TYPE", "setEncType", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_EST_GEST_GAP", "setEstGesAge", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_FUNDAL_HT", "setFundalHt", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_PRE_SGN_SYM", "setPreSgnAndSym", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_CERV_DILAT", "setCerDilat", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_CERV_EFF_LEN", "setCerEffLen", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_CERV_STAT", "setCerStat", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("CUMULATIVE_WT", "setCumulativeWt", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_WEIGHT", "setWeight", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_EDEMA", "setEdema", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_PROTEIN", "setProtein", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_GLUCOSE", "setGlucose", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_NEXT_APPT", "setNextAppointment", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_PAIN", "setPain", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_PRESENT", "setPresentation", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_FETAL_MOV", "setFetalMovement", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_FETAL_HR", "setFetalHrRt", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_FETAL_LIE", "setFetalLie", "Array", "PARENT_ENTITY_ID"));
				    compFilterMaps.push(new FilterMapping("PREG_ASSESS_BP_GROUP", "setBPResGroup", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'pa2':
                    compFilterMaps.push(new FilterMapping("PREG_ANTEPARTUM_NOTE_2", "setAntepartumNote2", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ASSESS_2_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
                    break;
				case 'pa3':
                    compFilterMaps.push(new FilterMapping("PREG_ANTEPARTUM_NOTE_3", "setAntepartumNote3", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ASSESS_3_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
                    break;
                case 'pch':
                	compFilterMaps.push(new FilterMapping("PREOP_LAST_FOOD_INTAKE", "setLastFdIntake", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_LAST_FLD_INTAKE", "setLastFlIntake", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_ANES_CONSENT", "setAnesCnst", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_BLD_CONSENT", "setBldCnst", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_SURG_CONSENT", "setSurgCnst", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_ORDERS_CMPLT", "setOrdrsCmplt", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_ECG_ORDERS", "setEcgOrdrs", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_HCG_ORDERS", "setHcgOrdrs", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_HX_PHYSICAL_REC", "setHnP", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_SURG_PREP_VER", "setSurgPrepVer", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_ALLERGY_BAND", "setIdVerf", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_BLD_BAND", "setBldBand", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_ID_BAND", "setPrIdBand", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_SITE_VER_PT", "setPrSiteVer", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_SITE_VER_RN", "setPrSiteVerRN", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_SITE_VER_MD", "setPrSiteVerMD", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_IMPLANT_AVAILABLE", "setPrImplntAvail", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_BLD_AVAILABLE", "setPrBldAvail", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_EQUIP_AVAILABLE", "setPrEquipAvail", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_MD_WHO_VER_SITE", "setWhoVerfSite", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("PREOP_RN_WHO_VER_SITE", "setRNWhoVerfSite", "Array", "PARENT_ENTITY_ID"));
                case 'po':
                    compFilterMaps.push(new FilterMapping("PREG_GRAVIDA", "setGravida", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PARA", "setPara", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PARA_ABORT", "setParaAbort", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PARA_PREM", "setParaPremature", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PARA_FT", "setParaFullTerm", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_LIVE_CHILD_HX", "setLiving", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_MULTI_BIRTH_HX", "setMulitBirths", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ECTOPIC_HX", "setEctopic", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_SPON_ABORT_HX", "setSpontAbort", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_IND_ABORT_HX", "setInducedAbort", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PRE_WT", "setPrePregWeight", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_HT", "setHeight", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_LAST_DOC_HT_WT", "setBMI", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ABORH_TYPE", "setABORhType", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_BLD_TYPE", "setBloodType", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_RH_TYPE", "setRhType", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_CURR_WT", "setCurrentWeight", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_EPI_DEGREE", "setEpiDegree", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_EPI_MIDLINE", "setEpiMidline", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_EPI_MEDIO", "setEpiMedio", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_EPI_PERF", "setEpiPerformed", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_EPI_OTHER", "setEpiOther", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PERI_INTACT", "setPerineumIntact", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_CX_LAC", "setCervicalLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PERINEIAL_LAC", "setPerinealLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_PERIURETHRAL_LAC", "setPeriurethralLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_SUPER_LAC", "setSuperficialLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_VAG_LAC", "setVaginalLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_LABIAL_LAC", "setLabialLac", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ANESTH_TYPE", "setAnesthType", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_ANESTH_OB_TYPE", "setAnesthOB", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_DT_TM_BIRTH", "setBirthDtTm", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_GENDER", "setGender", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_BIRTH_WT", "setBirthWeight", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_NEO_OUTCOME", "setNeoOutcome", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_NEO_COMP", "setNeoComps", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_APGAR_1_MIN", "setApgar1", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_APGAR_5_MIN", "setApgar5", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_APGAR_10_MIN", "setApgar10", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_FEED_TYPE_NB", "setFeeding", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_DELIVERY_TYPE", "setDeliveryType", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'pso':
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_EXPLANT", "setImplantExplant", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_DESC", "setImplantDesc", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_SERIAL_NBR", "setImplantSerNbr", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_LOT_NBR", "setImplantLotNbr", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_MANU", "setImplantManu", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_CAT_NBR", "setImplantCatNbr", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_SIZE", "setImplantSize", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_EXP_DT", "setImplantExpDt", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_SITE", "setImplantSite", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_IMPLANT_QTY", "setImplantQty", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_DRESS_COND", "setDressCond", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_DRESS_DRAINAGE", "setDressDrain", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_DRESS_DESC", "setDressDesc", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_DRESS_CARE", "setDressCare", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_DRESS_LOC", "setDressLoc", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_PAIN_LOC", "setPainLoc", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_PAIN_RATING", "setPainRating", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_PAIN_SCALE", "setPainScale", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_PAIN_QUAL", "setPainQual", "Array", "PARENT_ENTITY_ID"));
                	compFilterMaps.push(new FilterMapping("POSTOP_PAIN_INTERVENTIONS", "setPainInterv", "Array", "PARENT_ENTITY_ID"));
                	break;
                case 'pt':
                    compFilterMaps.push(new FilterMapping("CHIEF_COMP_CE", "setChiefComplaint", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("RESUS_ORDER", "setResusOrders", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ADV_DIRECTIVE", "setAdvancedDirectives", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("MODE_ARRIVAL_CE", "setModeofArrival", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NOTE_ES", "setDocumentTypes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("TARGET_DC_DT", "setEstimatedDischargeDate", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ENC_TYPE", "setVisitTypeCodes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("REASON_IND", "setRFVDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("PRIMARY_DR_IND", "setPrimaryPhysDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ED_CONTACT_IND", "setEmergencyContactsDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ADMIT_DR_IND", "setAdmittingPhysDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("RM_IND", "setRoomBedDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ATTEND_DR_IND", "setAttendingPhysDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("REFER_DR_IND","setReferringPhysDisplay","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ADM_DT_IND", "setAdmitDateDisplay", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("MED_SVC_IND", "setMedicalServiceDisplay", "Boolean", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("DIET_ORD","setDietOrders","Array","PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ACTIVITY_ORD","setPatientActivityOrders","Array","PARENT_ENTITY_ID"));
                    break;
                case 'reh_prec':
                    compFilterMaps.push(new FilterMapping("PRECAUTION_ORDERS", "setOrders", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'resp-tmln':
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_1", "setTimelineCds1", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_2", "setTimelineCds2", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_3", "setTimelineCds3", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_4", "setTimelineCds4", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_5", "setTimelineCds5", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_6", "setTimelineCds6", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_7", "setTimelineCds7", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_8", "setTimelineCds8", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_9", "setTimelineCds9", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_10", "setTimelineCds10", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_11", "setTimelineCds11", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_12", "setTimelineCds12", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_13", "setTimelineCds13", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_14", "setTimelineCds14", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_SEQ_15", "setTimelineCds15", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPH_DEFAULTS", "setDefaultSelected", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'rt':
                    compFilterMaps.push(new FilterMapping("PREG_TIMELINE_LAB", "setResultLabs", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PREG_TIMELINE_US", "setResultUltrasounds", "Array", "PARENT_ENTITY_ID"));
                    break;
				case 'se':
					compFilterMaps.push(new FilterMapping("FLAG_DATE_FORMAT_IND","setIsDateWithinInd","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("FLAG_COM_FACEUP_IND","setFaceupCommentsDisplayEnabled","Boolean","FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("EVENT_CODES_IST_IND","setISTEventCodesMappedInd","Boolean","FREETEXT_DESC"));
                    break;
                case 'seo2':
                    compFilterMaps.push(new FilterMapping("SIG_EVENTS_SELECT_COND", "setEventFilters", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'ta':
                	compFilterMaps.push(new FilterMapping("OVERDUE_TASK_TYPES","setOverdueTaskTypeCodes","Array","PARENT_ENTITY_ID"));
             	    break;
                case 'tl':
                    compFilterMaps.push(new FilterMapping("ED_TIMELINE_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("ED_LAB_RAD_CAT_TYPE", "setLabRadCatalogTypes", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("ED_TIMELINE_ORDERS", "setDocCatalogCds", "Array", "PARENT_ENTITY_ID"));
                    break;
                case 'tmln':
                    compFilterMaps.push(new FilterMapping("GRAPHS_IND", "setDisplayEnabled", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("GRAPHS_SUB_CONTROLLER", "setMasterGraphTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("GRAPHS_SUB_VS", "setVitalSignTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_DEFAULTS", "setDefaultSelected", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_1", "setTimelineCds1", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_2", "setTimelineCds2", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_3", "setTimelineCds3", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_4", "setTimelineCds4", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_5", "setTimelineCds5", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_6", "setTimelineCds6", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_7", "setTimelineCds7", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_8", "setTimelineCds8", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_9", "setTimelineCds9", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("VS_GRAPH_SEQ_10", "setTimelineCds10", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPHS_SUB_BP", "setBloodPressureTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_SYS_INVASIVE", "setTimelineCds11", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_DIAS_INVASIVE", "setTimelineCds12", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_SYS_NONINVASIVE", "setTimelineCds13", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_DIAS_NONINVASIVE", "setTimelineCds14", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_MAP_INVASIVE", "setTimelineCds15", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPH_MAP_CUFF", "setTimelineCds16", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("GRAPHS_SUB_VS_TABLE", "setTableGraphTitle", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("BP_GRAPHS_IND", "setIsBloodPressureDisplayed", "Boolean", "FREETEXT_DESC"));
                    break;
                case 'treat':
                    compFilterMaps.push(new FilterMapping("OT_TREAT_DOC", "setOTTreatments", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("PT_TREAT_DOC", "setPTTreatments", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("SLP_TREAT_DOC", "setSLPTreatments", "Array", "PARENT_ENTITY_ID"));
                    break;
                case  'vs':
                    compFilterMaps.push(new FilterMapping("VS_RESULTS_IND", "setShowTodayValue", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("VS_CHART_LAUNCH_IND", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                case  'wm':
                    compFilterMaps.push(new FilterMapping("WT_RESULTS_IND", "setShowTodayValue", "Boolean", "FREETEXT_DESC"));
                    break;
                case  'genscr':
                    compFilterMaps.push(new FilterMapping("PREG_GENETIC_SCR_PF", "setSelectedPowerform", "NUMBER", "PARENT_ENTITY_ID"));
                    break;
                case 'diab-graph':
					compFilterMaps.push(new FilterMapping("DMS_GRAPH_LOC","setGraphLocation","NUMBER","FREETEXT_DESC"));
					break;
                case 'cds':
                	// Clinical Decision Support Reference Links
					compFilterMaps.push(new FilterMapping("REFERENCE_NAME", "setReferenceName", "STRING", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("REFERENCE_LINK", "setReferenceLinks", "STRING", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("REFERENCE_DISPLAY", "setReferenceDisplay", "NUMBER", "FREETEXT_DESC"));
					// Clinical Decision Support MPage and Advisor Links
					compFilterMaps.push(new FilterMapping("MPAGE_NAME", "setMPageName", "STRING", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("MPAGE_LINK", "setMPageLinks", "STRING", "FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("MPAGE_DISPLAY", "setMPageDisplay", "NUMBER", "FREETEXT_DESC"));
					// Clinical Decision Support PowerForm Links
					compFilterMaps.push(new FilterMapping("FORMS_NAME", "setFormsName", "STRING", "FREETEXT_DESC"));
                    break;
				case 'vis':
		    		compFilterMaps.push(new FilterMapping("FUTURE_VISIT_MAX","setFutureMax","Number","FREETEXT_DESC"));
		    		compFilterMaps.push(new FilterMapping("PREVIOUS_VISIT_MAX","setPreviousMax","Number","FREETEXT_DESC"));
		    		break;
                case 'ct':
                    compFilterMaps.push(new FilterMapping("CLIN_TRIAL_THERAPEUTIC", "setTherapeuticInd", "String", "FREETEXT_DESC"));
                    break;
                case 'ctr':
                    compFilterMaps.push(new FilterMapping("CHEMO_RVW_PLAN_CLASS", "setPowerPlanClasses", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("CURRENT_SCROLL_IND", "setCurrentScrollInd", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("CURRENT_SCROLL_ROWS", "setCurrentScrollNum", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HIST_LOOK_BACK", "setHistoricalLookback", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HIST_EXP_COLLAPSE_IND", "setHistoricalOpen", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HIST_SCROLL_IND", "setHistoricalScrollInd", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("HIST_SCROLL_ROWS", "setHistoricalScrollNum", "String", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("RESPONSE_TREATMENT_IND", "setResponseInd", "String", "FREETEXT_DESC"));
                    break;
               case 'neotasks':
                    compFilterMaps.push(new FilterMapping("NEO_ID_BAND_NOMEN", "setIdBandNomens", "Nomen", "NOMEN"));
                    compFilterMaps.push(new FilterMapping("NEO_HEARING_SCR_NOMEN", "setHearingScrNomens", "Nomen", "NOMEN"));
                    compFilterMaps.push(new FilterMapping("NEO_CIRCUMCISION_NOMEN", "setCircumcisionNomens", "Nomen", "NOMEN"));
                    compFilterMaps.push(new FilterMapping("NEO_METABOLIC_SCR_NOMEN", "setMetabolicScrNomens", "Nomen", "NOMEN"));
                    compFilterMaps.push(new FilterMapping("NEO_OTHER_NB_TASKS_NOMEN", "setOtherNomens", "Nomen", "NOMEN"));
                    compFilterMaps.push(new FilterMapping("NEO_OTHER_NB_TASKS", "setOtherEvents", "Value_Seq", "VALUE_SEQ"));
                    break;
               case 'neooverview':
                    compFilterMaps.push(new FilterMapping("NEO_APGAR_1_MIN_COMP_SEQ", "setApgar1Seqs", "Value_Seq", "VALUE_SEQ"));
                    compFilterMaps.push(new FilterMapping("NEO_APGAR_5_MIN_COMP_SEQ", "setApgar5Seqs", "Value_Seq", "VALUE_SEQ"));
                    compFilterMaps.push(new FilterMapping("NEO_APGAR_10_MIN_COMP_SEQ", "setApgar10Seqs", "Value_Seq", "VALUE_SEQ"));
                    compFilterMaps.push(new FilterMapping("NEO_DELIVERY_INFO_SEQ", "setDeliveryInfoSeqs", "Value_Seq", "VALUE_SEQ"));
                    compFilterMaps.push(new FilterMapping("NEO_NEWBORN_INFO_SEQ", "setNewbornInfoSeqs", "Value_Seq", "VALUE_SEQ"));
                    compFilterMaps.push(new FilterMapping("NEO_MATERNAL_INFO_SEQ", "setMaternalInfoSeqs", "Value_Seq", "VALUE_SEQ"));
                    break;   
               case 'neoblood':
                    compFilterMaps.push(new FilterMapping("NEO_PHOTO_START_DT_TM_NOMEN", "setPhotoStartNomens", "Array", "PARENT_ENTITY_ID"));
                    compFilterMaps.push(new FilterMapping("NEO_PHOTO_STP_DT_TM_NOMEN", "setPhotoStopNomens", "Array", "PARENT_ENTITY_ID"));
                    break;
				case 'med-o2':
					compFilterMaps.push(new FilterMapping("WF_MEDS_SCHED", "setScheduled", "Boolean", "FREETEXT_DESC"));
				    compFilterMaps.push(new FilterMapping("WF_MEDS_PRN","setPRN","Boolean","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_DISC","setDiscontinued","Boolean","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_ADM","setAdministered","Boolean","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_SUS","setSuspended","Boolean","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_CONT","setContinuous","Boolean","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_ADM_LB_HRS","setAdministeredLookBkHrs","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_DISC_LB_HRS","setDiscontinuedLookBkHr","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_SCHED_NEXT_DOSE","setScheduleNextDose","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_PRN_LAST_DOSE","setPRNLastDose","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_SCHED_NEXT_12","setSchedNextTwelve","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_PRN_LAST_48","setPRNLastFortyEight","Number","FREETEXT_DESC"));
					compFilterMaps.push(new FilterMapping("WF_MEDS_SCHED_OVERDUE","setSchedOverdue","Number","FREETEXT_DESC"));
				    break;
               case 'sa':
                    compFilterMaps.push(new FilterMapping("SAFETY_CHART", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                    break;
               case 'thert':
                    compFilterMaps.push(new FilterMapping("ECT", "setDisplayECT", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("PHARM", "setDisplayPHARM", "Boolean", "FREETEXT_DESC"));					
                    compFilterMaps.push(new FilterMapping("VNS", "setDisplayVNS", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("PSYCHOTH", "setDisplayPSYCHOTH", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("OTHER", "setDisplayOTHER", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("THER_TREAT_CHART", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                    break;
               case 'bhas':
                    compFilterMaps.push(new FilterMapping("BH_ASSESS", "setDisplayBH", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("FX_ASSESS", "setDisplayFX", "Boolean", "FREETEXT_DESC"));                 
                    compFilterMaps.push(new FilterMapping("COG_ASSESS", "setDisplayCOG", "Boolean", "FREETEXT_DESC"));					
                    compFilterMaps.push(new FilterMapping("OTHER_ASSESS", "setDisplayOTHER", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("BH_CHART", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                    break;
               case 'ophp':
                    compFilterMaps.push(new FilterMapping("OPH_SCRIPTS_IND", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                    break;  
               case 'ophm':
                    compFilterMaps.push(new FilterMapping("OPH_MEAS_IND", "setIViewAdd", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("GEN_MEAS", "setDisplayGenMeas", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("VIS_ACUITY", "setDisplayVisAcuity", "Boolean", "FREETEXT_DESC"));                           
                    compFilterMaps.push(new FilterMapping("REFRAC", "setDisplayRefract", "Boolean", "FREETEXT_DESC"));                  
                    compFilterMaps.push(new FilterMapping("AUTO_REFRAC", "setDisplayAutoRefract", "Boolean", "FREETEXT_DESC"));                 
                    compFilterMaps.push(new FilterMapping("KERATO", "setDisplayKerato", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("RETINO", "setDisplayRetino", "Boolean", "FREETEXT_DESC"));                           
                    compFilterMaps.push(new FilterMapping("RET_ACUITY", "setDisplayRetAcuity", "Boolean", "FREETEXT_DESC"));                  
                    compFilterMaps.push(new FilterMapping("GLARE", "setDisplayGlare", "Boolean", "FREETEXT_DESC"));                 
                    compFilterMaps.push(new FilterMapping("PUP_MEAS", "setDisplayPupEqual", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("IOP", "setDisplayIOP", "Boolean", "FREETEXT_DESC"));                           
                    compFilterMaps.push(new FilterMapping("DILATION", "setDisplayDilation", "Boolean", "FREETEXT_DESC"));                  
                    compFilterMaps.push(new FilterMapping("MOTILITY", "setDisplayMotility", "Boolean", "FREETEXT_DESC"));                   
                    compFilterMaps.push(new FilterMapping("VIS_FIELDS", "setDisplayVisFields", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("PACHY", "setDisplayPachy", "Boolean", "FREETEXT_DESC"));                           
                    compFilterMaps.push(new FilterMapping("OCT", "setDisplayOCT", "Boolean", "FREETEXT_DESC"));                  
                    compFilterMaps.push(new FilterMapping("LID", "setDisplayLID", "Boolean", "FREETEXT_DESC"));                 
                    compFilterMaps.push(new FilterMapping("COLOR", "setDisplayColor", "Boolean", "FREETEXT_DESC"));
                    compFilterMaps.push(new FilterMapping("CONTRAST", "setDisplayContrast", "Boolean", "FREETEXT_DESC"));                           
                    compFilterMaps.push(new FilterMapping("AMSLER", "setDisplayAmsler", "Boolean", "FREETEXT_DESC"));                  
                    compFilterMaps.push(new FilterMapping("TITMUS", "setDisplayTitmus", "Boolean", "FREETEXT_DESC"));                                                           
                    compFilterMaps.push(new FilterMapping("WORTH", "setDisplayWorth", "Boolean", "FREETEXT_DESC"));
					break;
										
            }
            return BRCompPrefSetFuncCreation(compFilterMaps);
        }
    }
    //Page level filter mappings

}();
/**
 * A globally available construct to send and receive broadcasts within a Powerchart session.
 * Person/encounter/personnel ids are used to filter out broadcasts received. 
 * 
 */
var BroadcastDispatcher = (function () {
	var isEnabled = ('external' in window) && ('PCRegisterMessage' in window.external) && ('PCUnRegisterMessage' in window.external) && ('PCSendMessage' in window.external);
	
	var subscribers = {};
	var person_id = null;
	var encounter_id = null;
	var prsnl_id = null;
	var criterion = null;
	
	/**
	 * Receives and handles broadcasts. 
	 * Filters out broadcasts based on encounterId, patientId, and userId, if available.
	 * 
	 * This function is called by win32.
	 */
	var dispatch = function (broadcastNumber, payload) {
		
		// filter out broadcasts, if available
		if (payload) {
			if (payload.encounterId && encounter_id && payload.encounterId !== encounter_id) {
				return;
			}
			if (payload.patientId && person_id && payload.patientId !== person_id) {
				return;
			}
			if (payload.userId && prsnl_id && payload.userId !== prsnl_id) {
				return;
			}
		}
		
		$(subscribers[broadcastNumber]).each(function (index, handler) {
			// we need to queue up the handler calls because this dispatch method needs to return as soon as possible
			// since win32 is making a synchronous call to us
			window.setTimeout(function () {
				handler(payload);
			}, 0);
		});
	};
	
	
	if (!isEnabled) {
		if (typeof MP_Util !== 'undefined') {
			MP_Util.LogInfo("Powerchart broadcasts are not available.");
		}
	} else {
		// expose private function to be consumed by win32
		window.MP_BroadcastDispatch = dispatch;

		$(document).ready(function () {
			// perform initialization if the m_criterionJSON object exists
			if (typeof m_criterionJSON !== "undefined") {		
				criterion = JSON.parse(m_criterionJSON);
			}
			if (criterion) {
				person_id = criterion.CRITERION.PERSON_ID;
				// there will only be one encounter in the criterion, and the encounter id maybe 0 in the case of lifetime relationships
				encounter_id = criterion.CRITERION.ENCNTRS[0].ENCNTR_ID;
				prsnl_id = criterion.CRITERION.PRSNL_ID;
			}
			
			// attach delegate to re-register the BroadcastDispatcher after the click has been processed
			// since win32 currently automatically unregisters the BroadcastDispatcher whenever navigation via anchors happens
			// ... assuming no one will stopPropgation() on the click event
			$('body').on('click', 'a', function () {
				window.setTimeout(function () {
					BroadcastDispatcher.register();
				}, 0);
			});
		});
	}
	
	return {
		/**
		 * Broadcast number constants
		 */
		DYN_DOC_REFRESH: 3,		// broadcast from Dyn Doc to refresh Dyn Doc workflow information, as a note has been created and saved/signed
		/**
		 * Can be called to see if broadcasts are available.
		 */
		isAvailable : function () {
			return isEnabled;
		},
		/**
		 * Subscribes the handler to a specific broadcast.
		 * 
		 * NOTE: the actual subscription to the broadcasts may be queued to the end of the current execution
		 * 
		 * @param broadcastNumber
		 * 				a number, specifies the broadcast to subscribe to.
		 * @param handler
		 * 				a function, that accepts the broadcast payload as an object.
		 * 				eg. function myhandler(payload) { alert(payload.message); }
		 */
		subscribe : function (broadcastNumber, handler) {
			if (typeof broadcastNumber !== 'number') {
				throw "The supplied broadcast number must be a number.";
			}
			
			if (typeof handler !== 'function') {
				throw "The supplied handler must be a non-null function.";
			}
			
			if (!isEnabled) {
				return false;
			}
			
			var subscribedHandlers = subscribers[broadcastNumber];
			if (!subscribedHandlers) {
				subscribers[broadcastNumber] = subscribedHandlers = [];
				// push the subscription to the end of the current execution queue.
				// this is done specifically for win32, as win32 may unregister when the onload event gets floated up to win32 layer
				// we need to register after onload event is handled by win32, ie. at the end of the current execution.
				window.setTimeout(function () {
					window.external.PCRegisterMessage(broadcastNumber, "MP_BroadcastDispatch");
				}, 0);
			}
			
			subscribedHandlers.push(handler);
			
			return true;
		},
		/**
		 * Removes handler from the list of subscribers for a specific broadcast.
		 * 
		 * @param broadcastNumber
		 * 				a number, specifies the broadcast to unsubscribe to.
		 * @param handler
		 * 				a function, the same function that was used when subscribing.
		 */
		unsubscribe : function (broadcastNumber, handler) {
			if (typeof broadcastNumber !== 'number') {
				throw "The supplied broadcast number must be a number.";
			}

			if (!isEnabled) {
				return false;
			}
			
			var subscribedHandlers = subscribers[broadcastNumber];
			if (subscribedHandlers && subscribedHandlers.length) {
				for (var i = subscribedHandlers.length; i--;) {
					if (handler === subscribedHandlers[i]) {
						subscribedHandlers.splice(i, 1);
						break;
					}
				}
			}
						
			if (subscribedHandlers.length === 0) {
				window.external.PCUnRegisterMessage(broadcastNumber);
				subscribers[broadcastNumber] = null;
			}	
			
			return true;			
		},
		/**
		 * Sends a broadcast, with the payload, to the entire Powerchart session.
		 * 
		 * Please add the following attributes to the payload to allow the broadcast to be filtered:
		 * 	encounterId - only the specified encounter will receive the broadcast.
		 * 	patientId - only the specified patient/person will receive the broadcast.
		 * 	userId - only the specified user/personnel will receive the broadcast.
		 * 
		 * Combinations of the above attributes can be used to direct the broadcast at a specific encounter/patient/personnel.
		 * 
		 * @param broadcastNumber
		 * 				a number, specifies the broadcast "channel" to send to.
		 * @param payload
		 * 				an object, with user specified attributes and content.
		 */
		sendBroadcast : function (broadcastNumber, payload) {	
			if (typeof broadcastNumber !== 'number') {
				throw "The broadcast number needs to be number.";
			}
			
			if (typeof payload !== 'object') {
				throw "The payload needs to be an object.";
			}
			
			if (!isEnabled) {
				return false;
			}
			
			window.external.PCSendMessage(broadcastNumber, payload);			
		},
		/**
		 * Registers the BroadcastDispatcher to receive win32 broadcasts.
		 * Upon receiving broadcasts, the appropriate subscribed listeners will be called to handle the broadcast.
		 * 
		 * Can be called multiple times without side effects.
		 * 
		 */
		register : function () {
			var broadcastNumber = null;
			
			if (!isEnabled || !subscribers) {
				return;
			}
			
			for (broadcastNumber in subscribers) {
				if (subscribers[broadcastNumber]) {
					window.external.PCRegisterMessage(parseInt(broadcastNumber, 10), "MP_BroadcastDispatch");
				}
			}
		},
		/**
		 * Unregisters BroadcastDispatcher from win32 broadcast.
		 * The BroadcastDispatcher will no longer receive win32 broadcasts.
		 * 
		 * This allows win32 side to clean up properly.
		 * 
		 * Since BroadcastDispatcher no longer receives broadcasts from win32,
		 * this also means that subscribed listeners will not be called.
		 * Though, the listeners remain subscribed.
		 * 
		 * Can be called multiple times without side effects.
		 */
		unregister : function () {
			var broadcastNumber = null;
			
			if (!isEnabled || !subscribers) {
				return;
			}
			
			for (broadcastNumber in subscribers) {
				if (subscribers[broadcastNumber]) {
					window.external.PCUnRegisterMessage(parseInt(broadcastNumber, 10));
				}
			}
		}
	};
}());
function BusinessSearchControl(oTextBox){var selectedId=0;
var orgTypeCds=[];
var childOrgAddressTypeMeaning="";
var parentOrgId=0;
var serviceDelegate=new BusinessServiceDelegate();
var allOrgResults=null;
var getFilteredResults=function(searchString){var filteredResults=new Array();
for(var i=0,length=allOrgResults.length;
i<length;
i++){var result=allOrgResults[i];
if(result.NAME.substr(0,searchString.length).toLowerCase()===searchString.toLowerCase()){filteredResults.push(result);
}}return filteredResults;
};
var selectionHandler=function(newSelectedId){selectedId=newSelectedId;
};
var queryHandler=function(callback,searchString){if(allOrgResults==null){serviceDelegate.getResults(parentOrgId,orgTypeCds,childOrgAddressTypeMeaning,searchString,function(results){allOrgResults=results;
callback.autosuggest(getFilteredResults(searchString));
});
}else{callback.autosuggest(getFilteredResults(searchString));
}};
var autoSuggestControl=new RCMAutoSuggestControl(oTextBox,queryHandler,selectionHandler,ToolTipDetailsHandler);
autoSuggestControl.delay=0;
this.getSelectedOrganizationId=function(){return selectedId;
};
this.setSelectedOrganization=function(organizationId,organizationName){selectedId=organizationId;
oTextBox.value=organizationName;
autoSuggestControl.setVerified(organizationId>0);
};
this.setParentOrgId=function(newParentOrgId){allOrgResults=null;
parentOrgId=newParentOrgId;
};
this.setOrgTypeCds=function(newOrgTypeCds){allOrgResults=null;
orgTypeCds=newOrgTypeCds;
};
this.setChildOrgAddressTypeMeaning=function(newChildOrgAddressTypeMeaning){allOrgResults=null;
childOrgAddressTypeMeaning=newChildOrgAddressTypeMeaning;
};
this.setRequired=function(required){autoSuggestControl.setRequired(required);
};
this.isVerified=function(){return autoSuggestControl.isVerified;
};
this.addVerifyStateChangeListener=function(listener){autoSuggestControl.addVerifyStateChangeListener(listener);
};
this.removeVerifyStateChangeListener=function(listener){autoSuggestControl.removeVerifyStateChangeListener(listener);
};
var addEventHandler=function(element,event,handler){element.addEventListener?element.addEventListener(event,handler,false):element.attachEvent("on"+event,handler);
};
if(oTextBox.form){addEventHandler(oTextBox.form,"reset",function(){selectedId=0;
autoSuggestControl.setVerified(false);
});
}}
function BusinessServiceDelegate(){this.getResults=function(parentOrgId,orgTypeCds,childOrgAddressTypeMeaning,searchString,callback){var childOrgTypeCdsJson=[];
for(var i=0;
i<orgTypeCds.length;
i++){childOrgTypeCdsJson.push({ORG_TYPE_CD:orgTypeCds[i].toFixed(1)});
}var json={BUSINESS_SEARCH_REQUEST:{PARENT_ORG_ID:parentOrgId.toFixed(1),CHILD_ORG_ADDRESS_TYPE_MEANING:childOrgAddressTypeMeaning,CHILD_ORG_PHONE_TYPE_MEANING:"",SERVICES_IND:0,CHILD_ORG_TYPES:childOrgTypeCdsJson}};
var sendAr=[];
sendAr.push("^MINE^","0.0","2","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",sendAr,true,function(status,recordData){if("S"===status){var orgResults=new Array();
for(var i=0,length=recordData.CHILD_ORGS.length;
i<length;
i++){var child_org=recordData.CHILD_ORGS[i];
orgResults.push({NAME:child_org.ORG_NAME,VALUE:child_org.ORGANIZATION_ID,DETAILS:child_org.ORG_FORMATTED_ADDRESS});
}callback(orgResults);
}else{if("F"===status){if(recordData){alert(recordData);
}}}});
};
}
/**
 * care-team-selector.js
 * @author Swati Kode
 *
 * Care Team Selector class
 * ==================================================================================================================================
 *
 * Creates a care team banner in the HTML content element sent by the consumer. Makes a script call to mp_get_care_team_assign to 
 * bring all care teams the patient is assigned to. Creates a care team label, and populates the selector by a list of care teams 
 * and appends all this HTML data to the HTML content element. Displays appropriate message if an error is encountered during script 
 * call. 
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new care team selector object
 * @name CareTeamSelector
 */
CareTeamSelector = function() {
	this.m_uniqueId = null;
	this.m_criterion = null;
	this.m_selectedCareTeamId = "0";
	this.m_selectedCareTeamDisplay = "";
	this.m_funcOnSelectorChange = null;
	this.m_funcOnCareteamLoad = null;
	this.m_careteamCount = 0;
	this.careTeamMapping = {};
	this.ipassI18N = i18n.discernabu.ipass;
	this.careTeamSelectMsg = this.ipassI18N.CARE_TEAM_MESSAGE;
	this.m_xEncInd = 0;
};


// ------------------------------------------------------------------------
//  Getters and Setters
// ------------------------------------------------------------------------

/**
 * Returns a unique ID for the care team banner
 */
CareTeamSelector.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};


/**
 * Sets a unique ID for the care team banner
 * @param {string | number} uniqueId The unique id for care team banner
 * @returns {CareTeamSelector} returns the care team selector object to allow chaining
 */
CareTeamSelector.prototype.setUniqueId = function(uniqueId) {
	//Validate uniqueId, throw an error if not valid
	if (!uniqueId || (typeof uniqueId !== "string" && typeof uniqueId !== "number")){
		throw new Error("Error setting unique ID. Parameter Unique Id must either be a number or a string for the care team banner.");
	}
	this.m_uniqueId = uniqueId;
	return this;
};

/**
 * Returns a criterion of the calling component 
 */
CareTeamSelector.prototype.getCriterion = function() {
	return this.m_criterion;
};


/**
 * Sets a criterion for the calling component
 * @param {object} criterion The criterion of the calling component
 * @returns {CareTeamSelector} returns the care team selector object to allow chaining
 */
CareTeamSelector.prototype.setCriterion = function(criterion) {
	//Validate uniqueId, throw an error if not valid
	if (!criterion){
		throw new Error("Error setting criterion. Parameter criterion must be specified.");
	}
	this.m_criterion = criterion;
	return this;
};

/**
 * Returns the care team ID of the currently selected care team in the selector
 * @returns {string} the care team ID of the currently selected care team
 */
CareTeamSelector.prototype.getSelectedCareTeamId = function() {
	return this.m_selectedCareTeamId;
};

/**
 * Sets the care team ID of the currently selected care team in the selector
 * @param {string} careTeamId The ID of the currently selected care team
 */
CareTeamSelector.prototype.setSelectedCareTeamId = function(careTeamId) {
	this.m_selectedCareTeamId = careTeamId;
};

/**
 * Returns the care team display of the currently selected care team in the selector
 * @returns {string} the display of the currently selected care team as an html string
 */
CareTeamSelector.prototype.getSelectedCareTeamDisplay = function() {
	return this.m_selectedCareTeamDisplay;
};

/**
 * Sets the care team display of the currently selected care team in the selector
 * @param {string} careTeamDisplay The display of the currently selected care team
 */
CareTeamSelector.prototype.setSelectedCareTeamDisplay = function(careTeamDisplay) {
	this.m_selectedCareTeamDisplay = careTeamDisplay;
};

/**
 * Returns the users function chosen to be executed after selecting the care team from drop-down
 * @returns {function} the function to execute after selecting the care team
 */
CareTeamSelector.prototype.getOnSelectorChangeFunc = function(func) {
	return this.m_funcOnSelectorChange;
};


/**
 * Sets the users function to be executed after selecting the care team from drop-down
 * @param {function} func The function to execute after selecting the care team
 * @returns {CareTeamSelector} returns the care team selector object to allow chaining
 */
CareTeamSelector.prototype.setOnSelectorChangeFunc = function(func) {
	if (typeof func !== "function") {
		throw new Error("Parameter func must be of type function for the CareTeamSelector.setOnSelectorChangeFunc.");
	}
	
	this.m_funcOnSelectorChange = func;
	return this;
};

/**
 * Returns the users function chosen to be executed after mp_get_careteam_sign begins executing
 * @returns {function} the function to execute after care teams have loaded
 */
CareTeamSelector.prototype.getOnCareteamLoadFunc = function() {
	return 	this.m_funcOnCareteamLoad;
};


/**
 * Sets the users function to be executed after selecting the care team from drop-down
 * @param {function} func The function to execute after loading care teams
 * @returns {CareTeamSelector} returns the care team selector object to allow chaining
 */
CareTeamSelector.prototype.setOnCareteamLoadFunc = function(func) {
	if (typeof func !== "function") {
		throw new Error("Parameter func must be of type function for the CareTeamSelector.setOnCareteamLoadFunc.");
	}
	
	this.m_funcOnCareteamLoad = func;
	return this;
};


/**
 * Returns the cross encounter indicator of the currently selected care team in the selector
 * @returns {string} cross encounter indicator value of the currently selected care team
 */
CareTeamSelector.prototype.getSelectedCareTeamXEncInd = function() {
	return this.m_xEncInd;
};

/**
 * Sets the cross encounter indicator of the currently selected care team in the selector
 * @param {string} xEncInd cross encounter indicator value of the currently selected care team
 */
CareTeamSelector.prototype.setSelectedCareTeamXEncInd = function(xEncInd) {
	this.m_xEncInd = xEncInd;
};


/**
 * Selects a given careteam in the careteam selector based on its ID
 * @param {integer} careteamId The id of the careteam to be selected
 */
CareTeamSelector.prototype.selectCareTeamById = function(careteamId){
	var careteamSelector = $('#ipassCareTeamSelector' + this.getUniqueId());
	var careteamDisplay = "";
	var careteamXEncInd = 0;
	if (careteamId > 0){
		if (! this.careTeamMapping[careteamId]){
			throw new Error("Paramater integer must corresponding to an existing careteam in dropdown.");
		}
		careteamDisplay = this.careTeamMapping[careteamId].CARETEAM_DISPLAY || "";
		careteamXEncInd = this.careTeamMapping[careteamId].CROSS_ENC_FLAG;
	}
	careteamSelector.val(careteamId);
	this.setSelectedCareTeamId(careteamId);
	this.setSelectedCareTeamXEncInd(careteamXEncInd);
	this.setSelectedCareTeamDisplay(careteamDisplay);
};

/**
 * Determines whether or not the given careteam is a medical service
 * @param {integer} careteamId The id of the careteam to determine its medical service-ness
 * @returns {boolean} returns true iff the current careteam is a service
 */
CareTeamSelector.prototype.isMedicalService = function(careteamId){
	if (!this.careTeamMapping) {
		return false;
	}
	var careTeamMapping = this.careTeamMapping;
	var careTeam = careTeamMapping[careteamId];
	return careTeam && careTeam.PCT_MED_SERVICE_CD && !careTeam.PCT_TEAM_CD;
};

/**
 * Returns the number of unique careteams obtained
 * @returns {integer} returns the number of careteams present in the careTeamMappingObject
 */
CareTeamSelector.prototype.getCareteamCount = function(){
	return this.m_careteamCount;
};

/**
 * Sets the disabled property of the current careteam selector
 * @param {Boolean} isDisabled The value of whether or not the CareTeamSelector should be disabled
 */
CareTeamSelector.prototype.setSelectorDisabledProperty = function(isDisabled){
	var ipassCareTeamSelector = $("#ipassCareTeamSelector"+this.getUniqueId());
	ipassCareTeamSelector.prop('disabled', isDisabled);
};

/**
 * Returns the object for the current selected care team
 */
CareTeamSelector.prototype.getSelectedCareTeamObject = function(){
	var selectedTeamId = this.getSelectedCareTeamId();
	return this.careTeamMapping[selectedTeamId];

};

/**
 * Sets the care team select message for the current use of the care team selector
 * @param {string} i18nMessage The string to use for the care team select message
 */
CareTeamSelector.prototype.setCareTeamSelectMsg = function(i18nMessage){
	this.careTeamSelectMsg = i18nMessage;
};


/**
 * Function name: renderCareTeamSelector
 * This method makes a script call to mp_get_care_team_assign, process the care teams retrieved in the reply and renders the care team selector HTML.
 * If a the script fails to return success then an appropriate message is displayed in the care team banner.
 * @param {object} careTeamSelectorTarget The HTML element holding the care team selector
 */
CareTeamSelector.prototype.renderCareTeamSelector = function(careTeamSelectorTarget){
	var encounterId = this.m_criterion.encntr_id;
	var personId = this.m_criterion.person_id;
	var logicalDomainId = this.m_criterion.logical_domain_id;
	var providerId = this.m_criterion.provider_id;
	var facilityCd = this.m_criterion.facility_cd;

	var responseStatus = null;
	var reply = null;
	var self = this;
	var uniqueId = this.m_uniqueId;

	//Create the script request to retrieve the list of assigned careteams
	var careTeamAssignRequest = new MP_Core.ScriptRequest();
	careTeamAssignRequest.setProgramName("mp_get_provider_teams");
	careTeamAssignRequest.setParameters(["^MINE^", providerId+".0", logicalDomainId+".0", 0, facilityCd+".0"]);
	careTeamAssignRequest.setAsync(true);
	careTeamAssignRequest.setExecCallback(true);

	//Start off by creating a banner
	var careTeamBanner = $("<div id='ipassCareTeamBanner"+uniqueId+"' class='ipass-careteam-banner attention'><span id='ipassLoadingCareTeam"+uniqueId+"' class='ipass-careteam-loading'>"+ this.ipassI18N.LOADING_CARE_TEAM +"</span><div class='ipass-careteam-preloader'></div></div>");

	// Show the spinning icon until the scripts executed
	careTeamSelectorTarget.html(careTeamBanner);

	//Execute the ccl script
	MP_Core.XMLCCLRequestCallBack(null, careTeamAssignRequest, function(careTeamsReply){
		try{
			reply = careTeamsReply.getResponse();
			responseStatus = reply.STATUS_DATA.STATUS;

			// Throw an error if the call to retrieve the careteam selection items was not successful
			if(responseStatus !== "S" && responseStatus !== "Z") {
					throw new Error("Script failed to load");
			}

			// Retrieve the care teams from the reply
			var careTeamList = reply.CARE_TEAMS;
			var numberOfCareTeams = careTeamList.length;	
			var assignedCareTeams = 0;
			var uniqueCareTeamIDArray = [];
			var careTeamOptionsHTML = "";
			self.m_careteamCount = 0;
			
			// Map Care Team IDs to the care team object
			var careTeamMapping = self.careTeamMapping;
			var careTeamDisplay = "";
			var grandParentTeams = [];
			var grandParentCount = 0;
			
			// Get the number of care teams that are currently assigned to the provider
			for (var i = 0; i < numberOfCareTeams; i++) {
				if (careTeamList[i] && careTeamList[i].PARENT_LEVEL === 1) {
					assignedCareTeams++;
				}
			}

			// Loop through the care teams and retrieve care team data
			for(i = 0; i < numberOfCareTeams; i++) {
				var careTeam = careTeamList[i];
				var facilityText = "";
				// Retrieve the parent care team Id since the care teams in the drop-down need to have this value
				var careTeamId = careTeam.PARENT_CARE_TEAM_ID; 
				
				// Store the parent care team data in careTeamMapping only if level 1 parent
				if (careTeam.PARENT_LEVEL === 1) {
					careTeamMapping[careTeamId] = careTeam;
				} else {
					grandParentTeams[grandParentCount] = careTeam;
					grandParentCount++;
				}
				
				// Retrieve the med service and team display to show in the care team selector
				var teamName = careTeam.PCT_TEAM_CD ? careTeam.PCT_TEAM_DISPLAY : "";
				var medServiceName = careTeam.PCT_MED_SERVICE_DISPLAY;
				var xEncIndVal = 0;
				xEncIndVal = careTeam.CROSS_ENC_FLAG;
				// If that care team already exists then don't add it again in the selector
				if(!uniqueCareTeamIDArray[careTeamId] && (careTeam.PARENT_LEVEL === 1)){
					uniqueCareTeamIDArray[careTeamId] = true;
					
					//Increment the careteam count
					self.m_careteamCount++;
					
					careTeamDisplay = medServiceName || "";
					if (teamName){
						careTeamDisplay += "&nbsp;&nbsp;|&nbsp;&nbsp;" + teamName;
					}
					
					//If the facility code for any care team is 0, add (All Facilities) to the name
					if (!careTeam.FACILITY_CD) {
						facilityText = " (" + self.ipassI18N.ALL_FACILITIES + ")";
					}					
					
					// Don't display a drop-down if only 1 team is present instead show as a label
					
					// assignedCareTeams is the count of number of care teams a provider is currently assigned to
					// numberOfCareTeams is the count of teams that is returned from the script call, it might also includes MedServ with PARENT_LEVEL > 1
					if(assignedCareTeams === 1 || numberOfCareTeams === 1){
						careTeamOptionsHTML += "<span>" + careTeamDisplay + facilityText + "</span>";
						self.setSelectedCareTeamId(careTeamId);
						self.setSelectedCareTeamXEncInd(xEncIndVal);
						self.setSelectedCareTeamDisplay(careTeamDisplay);
					}
					else{
						careTeamOptionsHTML += "<option value='"+careTeamId+"'>" + careTeamDisplay + facilityText + "</option>";
					}
					
					//Store each careteam's display string
					careTeamMapping[careTeamId].CARETEAM_DISPLAY = careTeamDisplay.replace(/&nbsp;/g, ' ');
					self.careTeamMapping = careTeamMapping;
				}
			}
			
			// Add any grandparent IDs to their appropriate teams
			if (grandParentCount) {
				for (var j = grandParentTeams.length; j--;) {
					var origGPId = grandParentTeams[j].ORIG_PCT_CARE_TEAM_ID;
					// Find the matching ORIG_PCT_CARE_TEAM_ID in careTeamMapping
					for (var parentId in careTeamMapping) {
						if(careTeamMapping[parentId].ORIG_PCT_CARE_TEAM_ID === origGPId) {
							careTeamMapping[parentId].GRAND_PARENT_ID = grandParentTeams[j].PARENT_CARE_TEAM_ID;
							break;
						}
					}
				}
			}

			// Display the care team selector
			self.displayCareTeamSelector(careTeamSelectorTarget, careTeamBanner, careTeamOptionsHTML);
			
			// Attach the change listener to the selector
			var ipassCareTeamSelector = $("#ipassCareTeamSelector"+uniqueId);
			var careTeamMsgElement = $('#careTeamMsg'+uniqueId);
			ipassCareTeamSelector.change(function () {
				// Retrieve the value of the selected care team and set so that consumer can have access to this value
				var careTeamId = $(this).val();
				var careTeamDisplay = "";
				var xEncIndVal = 0;
				if (careTeamId !== "0"){
					careTeamDisplay = careTeamMapping[careTeamId].CARETEAM_DISPLAY;
					xEncIndVal = careTeamMapping[careTeamId].CROSS_ENC_FLAG;
				}
				self.setSelectedCareTeamId(careTeamId);
				self.setSelectedCareTeamDisplay(careTeamDisplay);
				self.setSelectedCareTeamXEncInd(xEncIndVal);
				// If the selected care team is other than "Select a care team" than remove the attention class
				if(self.getSelectedCareTeamId()!= "0"){
					careTeamBanner.removeClass("attention");
					careTeamMsgElement.addClass("hidden");
				}
				else{
					careTeamBanner.addClass("attention");
					careTeamMsgElement.removeClass("hidden");
				}
				
				// Call the consumers getOnSelectorChangeFunc()
				if(self.m_funcOnSelectorChange){
					self.getOnSelectorChangeFunc()();	
				}
			});
			var onLoadCallback = self.getOnCareteamLoadFunc();
			if(onLoadCallback){
				onLoadCallback();
			}
		}
		catch(exe){
			// Show appropriate message if error occurred
			careTeamBanner.html("<span class='ipass-careteam-warning'>&nbsp;</span><span class='ipass-careteam-warning-message'>" + self.ipassI18N.CARE_TEAM_FAILED +"</span>");
		}
	});
};


/**
 * Function name: displayCareTeamSelector
 * This method will choose to hide/display the care team drop-down based on the count of care teams the provider is built for. 
 * If no teams are build in domain or the provider is not built for any teams then no care team banner will be displayed. 
 * If count of teams equals 1 then displays only the care team name as a label and no drop-down. 
 * If provider is built for only 1 medical service and only 1 medical service/team then care team drop-down will be defaulted to medical service/team. 
 * If provider is built for 2 care teams and both are either med service only or med-service team only then drop-down will be defaulted to "Select a Care Team"
 * If provider is built for multiple care teams then drop-down will be defaulted to "Select a Care Team"
 * @param {object} careTeamSelectorTarget The HTML element holding the care team selector
 * @param {object} careTeamBanner The HTML element holding the loading icon and attention(orange) bar
 * @param {object} careTeamOptionsHTML A string holding care team names
 */
CareTeamSelector.prototype.displayCareTeamSelector = function(careTeamSelectorTarget, careTeamBanner, careTeamOptionsHTML){
	var selectorHtml = "";
	var uniqueId = this.m_uniqueId;
	var careTeamText = this.ipassI18N.CARE_TEAM;
	var selectCareTeamText = this.ipassI18N.SELECT_A_CARE_TEAM;
	
	switch(this.m_careteamCount){
	//Case 0: If no build exists or the provider is not built for any teams then do not display the banner 
	case 0:
			this.setSelectedCareTeamId("0");
			this.setSelectedCareTeamDisplay("");
			careTeamSelectorTarget.remove();
			break;
	//Case 1: If provider is built for only one care team then display the care team name as a label and no drop-down. 			
	case 1:
			//Create the careteam display
			selectorHtml = "<div class='ipass-careteam-selector'><span>" + careTeamText + ": </span>" + careTeamOptionsHTML + "</div>";
			
			//Remove the attention class 
			careTeamBanner.removeClass("attention");
			
			//Replace the banner html with the selector markup
			careTeamBanner.html(selectorHtml);
			break;
	//Case 2: If provider is built for only 2 care teams
	case 2:
			// Count to hold number of child level teams (i.e med-service team)
			var childLevelCareTeamCnt = 0;
			var childLevelCareTeamIdx = 0;
			
			//Determine if the care team is a child level team, if yes then store the careTeamIdx for defaulting the selector to that care team
			for(var careTeamIdx in this.careTeamMapping){
				if(this.careTeamMapping[careTeamIdx].PCT_TEAM_CD){
					childLevelCareTeamCnt ++;
					childLevelCareTeamIdx = careTeamIdx;
				}
			}
			
			// Show "Select a Care Team" option if both the care teams are med-service or both the care teams are med-service teams only 
			if(!childLevelCareTeamCnt || childLevelCareTeamCnt == 2){
				//Create the careteam selector html
				selectorHtml = "<div id='careTeamMsg"+uniqueId+"'><span class='filter-label'>"+this.careTeamSelectMsg+"</span></div><div class='ipass-careteam-selector'>" +
								"<span>" + careTeamText + ": </span>" + "<select id='ipassCareTeamSelector"+uniqueId+"'><option value='0'>" + 
								selectCareTeamText + "</option>"+careTeamOptionsHTML+ "</select></div>";
				
				//Replace the banner html with the selector markup
				careTeamBanner.html(selectorHtml);
			}
			else{
				//Create the careteam selector html
				selectorHtml = "<div class='ipass-careteam-selector'><span>" + careTeamText + ": </span>" +
								"<select id='ipassCareTeamSelector"+uniqueId+"'>"+careTeamOptionsHTML+"</select></div>";
				
				//Replace the banner html with the selector markup
				careTeamBanner.html(selectorHtml);
				
				// Remove the orange bar 
				careTeamBanner.removeClass("attention");
				
				// Default the drop-down to med-service team 
				var ipassCareTeamSelector = $("#ipassCareTeamSelector"+uniqueId);
				ipassCareTeamSelector.val(childLevelCareTeamIdx);
				this.setSelectedCareTeamId(childLevelCareTeamIdx);
				this.setSelectedCareTeamDisplay(this.careTeamMapping[childLevelCareTeamIdx].CARETEAM_DISPLAY);
			}
			break;
	//Case: Provider is built for multiple care teams then drop-down will be defaulted to "Select a Care Team"
	default:
			//Create the careteam selector html
			selectorHtml = "<div id='careTeamMsg"+uniqueId+"'><span class='filter-label'>"+this.careTeamSelectMsg+"</span></div><div class='ipass-careteam-selector'>" +
							"<span>" + careTeamText + ": </span>" + "<select id='ipassCareTeamSelector"+uniqueId+"'><option value='0'>" + 
							selectCareTeamText + "</option>"+careTeamOptionsHTML+ "</select></div>";
			
			//Replace the banner html with the selector markup
			careTeamBanner.html(selectorHtml);
			break;
	}
};
/**
 * date-selector.js
 * @author Swati Kode
 *
 * DateSelector class
 * ========================================================================================================================================
 *
 * Creates a date control in the HTML content element sent by a consumer. This control has a date precision selector, a date format selector, 
 * a date input field and a date picker. This control also creates an input field for entering age in years/months/weeks/days when Age is selected
 * from the date format selector. 
 */
// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new DateSelector object
 * @name DateSelector
 */
DateSelector = function() {
	this.m_uniqueId = null;
	this.m_criterion = null;
	this.m_dateSelectorOptions = {AGE: -1, YEAR: 3, MONTH_YEAR: 2, WEEK_OF: 1, DATE: 0};
	this.m_helperTextOptions = {3: "****", 2: "**/****", 1: "**/**/****", 0: "**/**/****"};
	this.m_patDOB = null;
	this.m_fuzzyFlag = false;
	this.m_selectedDate = null;
	this.m_selectedDateFlag = 0; // One of the options from the this.m_dateSelectorOptions
	this.m_selectedDatePrecisionCode = 0; // code for ABOUT, BEFORE, AFTER, UNKNOWN
	this.m_selectedAgeUnit = ""; // whether Days, Weeks, Months, Years
	var tempMonthYear = MP_Util.GetDateFormatter().lc.fullmonth4yrnodate;
	tempMonthYear = tempMonthYear.substr(0, tempMonthYear.length-2); 
	this.m_localeDateFormat = {3: "yy", 2: tempMonthYear, 1: MP_Util.GetDateFormatter().lc.fulldate2yr, 0: MP_Util.GetDateFormatter().lc.fulldate2yr};
	this.m_dateI18n = i18n.discernabu.date_selector;
	this.m_supportedDatePrecisions = ["ABOUT", "BEFORE", "AFTER", "UNKNOWN"];
	this.m_supportedAgeUnits = ["YEARS", "MONTHS" , "WEEKS", "DAYS"];
	this.m_dateSupportOption = 0; //0 - default(only past dates) , 1 - only future date support , 2 - support both past and future dates.
};

// ------------------------------------------------------------------------
//  Getters and Setters
// ------------------------------------------------------------------------

/**
 * Returns a unique ID for the date control
 */
DateSelector.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets a unique ID for the date control
 * @param {string | number} uniqueId The unique id for the date control
 * @returns {DateSelector} returns the DateSelector object to allow chaining
 */
DateSelector.prototype.setUniqueId = function(uniqueId) {
	//Validate uniqueId, throw an error if not valid
	if (!uniqueId || ( typeof uniqueId !== "string" && typeof uniqueId !== "number")) {
		throw new Error("Error setting unique ID. Parameter Unique Id must either be a number or a string for the date control.");
	}
	this.m_uniqueId = uniqueId;
	return this;
};

/**
 * Returns a criterion of the calling component
 */
DateSelector.prototype.getCriterion = function() {
	return this.m_criterion;
};

/**
 * Sets a criterion for the calling component
 * @param {object} criterion The criterion of the calling component
 * @returns {DateSelector} returns the DateSelector object to allow chaining
 */
DateSelector.prototype.setCriterion = function(criterion) {
	//Validate criterion, throw an error if not valid
	if (!criterion) {
		throw new Error("Error setting criterion. Parameter criterion must be specified.");
	}
	this.m_criterion = criterion;
	return this;
};

/**
 * Returns the value of fuzzy flag
 */
DateSelector.prototype.getFuzzyFlag = function() {
	return this.m_fuzzyFlag;
};

/**
 * Sets the fuzzy flag
 * @param {boolean} fuzzyFlag The fuzzy flag sent by the consumer. 
 * This flag determines if the consumer requested a fuzzy date logic or plain date picker. Setting this flag to "true" will render the date control with a 
 * date precision selector (At/On, About, After, Before, Unknown) , a date format selector (Age, Year, Month/Year, Week Of, Date), a date input field and a date picker
 * Setting the fuzzy flag to "false" will render the date control with just a date input field and a date picker. 
 */
DateSelector.prototype.setFuzzyFlag = function(fuzzyFlag) {
	this.m_fuzzyFlag = fuzzyFlag;
};

/**
 * Returns the value of selected date format whether it is Date, Week Of, Month/Year, Year 
 */
DateSelector.prototype.getSelectedDateFlag = function() {
	return this.m_selectedDateFlag;
};

/**
 * Sets the flag for selected date format whether it is Date, Week Of, Month/Year, Year 
 * This value can be any value selected from the m_dateSelectorOptions list
 * @param {int} selectedDateFlag The flag for selected date format from the m_dateSelectorOptions list
 */
DateSelector.prototype.setSelectedDateFlag = function(selectedDateFlag) {
	this.m_selectedDateFlag = selectedDateFlag;

	// Set this value in the date format selector as well
	if(this.dateFormatSelector){
		this.dateFormatSelector.val(selectedDateFlag);
		// Trigger change, this is needed because the date/age input field/date picker needs to appear accordingly 
		this.dateFormatSelector.triggerHandler("change");
	}
};

/**
 * Returns the selected date
 */
DateSelector.prototype.getSelectedDate = function() {
	return this.m_selectedDate;
};

/**
 * Sets the selected date
 * @param {object} selectedDate Date that will be set on the date picker
 */
DateSelector.prototype.setSelectedDate = function(selectedDate) {
	this.m_selectedDate = selectedDate;

	// Fire event to all listeners who are listening for the selected date
	CERN_EventListener.fireEvent(null,this,"selectedDateAvailable"+this.m_uniqueId,this);
};

/**
 * Sets the date precision code for "After", "About","Before","Unknown"
 * @param {double} datePrecisionCode The date precision code for "After", "About","Before","Unknown"
 */
DateSelector.prototype.setSelectedDatePrecisionCode = function(datePrecisionCode) {
	this.m_selectedDatePrecisionCode = datePrecisionCode;

	// Set the value in the date precision selector as well 
	if(this.datePrecisionSelector){
		this.datePrecisionSelector.val(datePrecisionCode);
		// Trigger the change so that appropriate controls appear
		this.datePrecisionSelector.triggerHandler('change');
	}
};

/**
 * Returns the date precision code
 */
DateSelector.prototype.getSelectedDatePrecisionCode = function() {
	return this.m_selectedDatePrecisionCode;
};

/**
 * Sets the unit selected (Years, Months, Weeks and Days) when Age is selected
 * @param {string} ageUnit Unit of age
 */
DateSelector.prototype.setSelectedAgeUnit = function(ageUnit) {
	this.m_selectedAgeUnit = ageUnit;
};

/**
 * Returns the unit selected whether it is Years, Months, Weeks and Days
 */
DateSelector.prototype.getSelectedAgeUnit = function() {
	return this.m_selectedAgeUnit;
};

/**
 * Sets the date support option which determines the date selection support in the datepicker
 * when the fuzzylogic flag is not set.
 * 0 - only past dates(default), 1 - only future dates, 2 - both past and future dates can be selected
 * @param {number} dateSupportOption - the date support option to be set
 */
 DateSelector.prototype.setDateSupportOption = function (dateSupportOption) {
	this.m_dateSupportOption = dateSupportOption;
};

/**
 * Returns the date support option set
 */
DateSelector.prototype.getDateSupportOption = function () {
	return this.m_dateSupportOption;
};

/**
 * Gets a Date Container Id for the date control
 * @returns {Object} an object containing the date selector container for the date control
 */
DateSelector.prototype.getDateSelectorContainer = function () {
   return this.m_dateSelectorContainer;
};

/**
 * Sets a Date Container Id for the date control
 * @param {Object} dateContainerId The unique date container id for the date control
 * @returns {undefined} returns nothing
 */
DateSelector.prototype.setDateSelectorContainer = function (dateContainerId) {
   if (!dateContainerId || ( typeof dateContainerId !== "object")) {
      throw new Error("Error setting Date Container Id. Parameter Date Container Id must be an object for the date control.");
   }
   this.m_dateSelectorContainer = dateContainerId;
};

/**
 * Function name: renderDateControl
 * This method will render the date control. If patient has a date of birth then the default option in the date format selector will be "Age" otherwise "Year".
 * The date control will also have a drop-down for selecting a precision (At/On, After, Before, About, Unknown), another menu for selecting 
 * a date format (Date, Week Of, Month/Year, and Year), a date/age input field for adding date manually.
 * @param none
 * @returns{String} dateControlHTML A HTML mark up for rendering the date control elements
 */
DateSelector.prototype.renderDateControl = function() {
	try{
		var precMeaning = "";
		var precDisplay = "";
		var precCode = 0;
	
		var ageDisplay = "";
	
		if(!this.datePrecisionCodes || !this.ageUnitCodes){
			logger.logJSError("Call retrieveRequiredResources function to get the date precision and age unit codes then call renderDateControl", null, "dateSelector.js", "renderDateControl");
			return;
		}
		
		// Create menu for date precisions, At/On precision means exact date/age
		var dateControlHTML = "<div class='dc-date-selector'><select id='datePrecisionSelector"+this.m_uniqueId+"'><option value='0'>"+this.m_dateI18n.AT_ON+"</option>";
		var precCodesLen = this.datePrecisionCodes.length;
	
		// Display the precisions in a menu
		for(var idx=0; idx < precCodesLen; idx++){
			precDisplay = this.datePrecisionCodes[idx].value.display;
			precMeaning = this.datePrecisionCodes[idx].value.meaning;
			precCode = this.datePrecisionCodes[idx].value.codeValue;
			
			// Show the precisions in the menu only if it is supported
			if(precMeaning && $.inArray(precMeaning, this.m_supportedDatePrecisions) >=0){
				dateControlHTML += "<option value="+precCode+">"+precDisplay+"</option>";
			}
			if(precMeaning === "AGE"){
				// Cache the label and code for Age since age is part of a separate menu
				ageDisplay = precDisplay;
			}
		}
		dateControlHTML += "</select>";
	
	 	// Create menu for date format
		dateControlHTML += "<select id='dateFormatSelector"+this.m_uniqueId+"' class='dc-date-format-selector'>";
	
		// Get patient's date of birth 
		this.m_patDOB = this.getCriterion().getPatientInfo().getDOB();
	
		// Add "Age" option only if the patient has a date of birth
		if(this.m_patDOB){
			dateControlHTML += "<option value="+this.m_dateSelectorOptions.AGE+">"+ageDisplay+"</option>"; 
			this.isAgeShown = true;
		}
	
		dateControlHTML +=	"<option value="+this.m_dateSelectorOptions.YEAR+">"+this.m_dateI18n.YEAR+"</option>" +
							"<option value="+this.m_dateSelectorOptions.MONTH_YEAR+">"+this.m_dateI18n.MONTH+"/"+this.m_dateI18n.YEAR+"</option>" +
							"<option value="+this.m_dateSelectorOptions.WEEK_OF+">"+this.m_dateI18n.WEEK_OF+"</option>" +
							"<option value="+this.m_dateSelectorOptions.DATE+">"+i18n.DATE+"</option></select>";
		
		
		
		// Add a class for controlling the hide/show of the age/date input fields
		var controlClass = "";
		if(this.isAgeShown){
			controlClass = "age-entry";
		}
		else{
			controlClass = "date-entry";
		}
		
		// Input element for entering date and age manually
		dateControlHTML += "<div id='dcControlFields"+this.m_uniqueId+"' class='"+controlClass+"'><input id='ageDisplayInput"+this.m_uniqueId+"' type='text' class='dc-age-input'/>"; //hidden
		dateControlHTML += "<input id='dateDisplayInput"+this.m_uniqueId+"' type='text' class='dc-date-input secondary-text '/>"; //hidden
		
		// Add a place holder for showing an "Invalid Age" message
		dateControlHTML += "<span id='invalidAgeMessage"+this.m_uniqueId+"' class='dc-invalid-age-message secondary-text hide'>"+this.m_dateI18n.INVALID_AGE+"</span></div></div>";
		
		// Since "Year" is the default option for Date, set YEAR as the selected date flag
		this.m_selectedDateFlag = this.m_dateSelectorOptions.YEAR;
	
		// Append the HTML in the target
		return dateControlHTML;
	}
	catch(err){
		logger.logJSError(err, this, "date-selector.js", "renderDateControl");
	}
};

/**
 * Register the events when the date precision selector, date format selector is flipped and the date/age input field is manually changed
 */
DateSelector.prototype.finalizeActions = function() {
	try{
		this.datePrecisionSelector = $("#datePrecisionSelector"+this.m_uniqueId);
		this.dateFormatSelector = $("#dateFormatSelector"+this.m_uniqueId);
		this.ageDisplayInput = $("#ageDisplayInput"+this.m_uniqueId);
		this.dateDisplayInput = $("#dateDisplayInput"+this.m_uniqueId);
		var dateControlTarget = $("#dcControlFields"+this.m_uniqueId);
		
		// If fuzzy flag is set to false then show simple date input field and a date picker 
		if(!this.getFuzzyFlag()){
			// Hide the precision and date selector, age input field if present 
			this.datePrecisionSelector.addClass("hidden");
			this.dateFormatSelector.addClass("hidden");
			
			if(this.isAgeShown){
				dateControlTarget.removeClass("age-entry");
				dateControlTarget.addClass("date-entry");
				this.isAgeShown = false;
			}
	
			// Call functions that shows the date picker and handles the date input changes
			// Set the format to be the full date 
			this.m_selectedDateFlag = this.m_dateSelectorOptions.DATE;
			this.handleDateSelector(dateControlTarget, this.getSelectedDateFlag());
			this.handleDateUserEnters(this.getSelectedDateFlag());
			return;
		}
	
		// If "Age" option is shown then call a function that handles all "Age" logic otherwise function that handles "Date" logic
		if(this.isAgeShown){
			this.handleAgeSelected();
			this.handleAgeEntered(this.ageDisplayInput.val());
		}
		else{
			this.handleDateSelector(dateControlTarget, this.getSelectedDateFlag());
			this.handleDateUserEnters(this.getSelectedDateFlag());
		}
	
		var selectedDateFormat = 0;
		var self = this;
	
		// Event handler when the date format selector is flipped between Date, Week Of, Month/Year and Year
		this.dateFormatSelector.change(function(){
			self.dateFormatSelector.blur();
			selectedDateFormat = parseInt(self.dateFormatSelector.val(),10);
	
			// Add remove age/date classes 
			self.dateControlField = $("#dcControlFields"+self.m_uniqueId);
			if(self.dateControlField.hasClass("age-entry")){
				self.dateControlField.removeClass("age-entry");
				self.dateControlField.addClass("date-entry");
			}
			
			else if(self.dateControlField.hasClass("date-entry") && selectedDateFormat === self.m_dateSelectorOptions.AGE){
				self.dateControlField.removeClass("date-entry");
				self.dateControlField.addClass("age-entry");
			}
	
			// -1 is for Age, since this option may always not display.
			if(selectedDateFormat === -1){
				// Show the Age fields
				self.handleAgeSelected();
			}
			else{
				self.handleDateSelector(dateControlTarget, selectedDateFormat);
				self.handleDateUserEnters(selectedDateFormat);
			
				//Set the format so that the consumer can read
				self.m_selectedDateFlag = selectedDateFormat;
			}
			// Fire event to all listeners who are listening for the selected date format
			CERN_EventListener.fireEvent(null,self,"selectedDateFormatAvailable"+self.m_uniqueId,self);
		});
	
		// Event handler for validating inputs when age is entered
		this.ageDisplayInput.on('keyup', function(){
			self.handleAgeInputChange();
		});
	
		// Event handler when date precision selector is flipped
		this.datePrecisionSelector.change(function(){
			//Set the precision value 
			self.m_selectedDatePrecisionCode = parseInt(self.datePrecisionSelector.val(), 10);
	
			// If "Unknown" option is selected then disable all date selector and input fields 
			var cdUnknown = MP_Util.GetCodeByMeaning(self.datePrecisionCodes, "UNKNOWN").codeValue; 
	
			if(parseInt(self.datePrecisionSelector.val(), 10) === cdUnknown){
				if(self.datePickerControl){
					self.datePickerControl.datepicker('disable');
				}
				if(self.dateFormatSelector){
					self.dateFormatSelector.prop("disabled", true);
				}
				if(self.dateDisplayInput){
					self.dateDisplayInput.prop("disabled", true);
				}
				if(self.ageDisplayInput){
					self.ageDisplayInput.prop("disabled", true);
				}
				if(self.ageUnitSelector){
					self.ageUnitSelector.prop("disabled", true);
				}
				
				// Set null selected date and flag to Date
				self.setSelectedDate(null);
				self.m_selectedDateFlag = self.m_dateSelectorOptions.DATE;
			}
			else{
				if(self.datePickerControl){
					self.datePickerControl.datepicker('enable');
				}
				if(self.dateFormatSelector){
					self.dateFormatSelector.prop("disabled", false);
				}
				if(self.dateDisplayInput){
					self.dateDisplayInput.prop("disabled", false);
				}
				if(self.ageDisplayInput){
					self.ageDisplayInput.prop("disabled", false);
				}
				if(self.ageUnitSelector){
					self.ageUnitSelector.prop("disabled", false);
				}
	
			}
			// Fire event to all listeners who are listening for the selected precision code 
			CERN_EventListener.fireEvent(null,self,"selectedPrecisionCodeAvailable"+self.m_uniqueId,self);
		});
	}
	catch(err){
		logger.logJSError(err, this, "date-selector.js", "finalizeActions");
	}
};

/**
 * The handleAgeInputChange function will display an Invalid Age message whenever age entered is greater than
 * the patient's age today. A red border indicating an error will also be placed on the age input.
*  accepted
 * @returns {undefined} returns nothing
 */
DateSelector.prototype.handleAgeInputChange = function(){
	var ageVal = this.ageDisplayInput.val();
	var numberRegexp = /^[0-9]+$/ ;
	var todaysDate = new Date();

	this.handleAgeEntered(this.ageDisplayInput.val());
	
	this.ageDisplayInput.val("");
	// Accept only numerical value
	if(ageVal=== "" || numberRegexp.test(ageVal)){
		// If age entered is greater than patient's age today then show an "Invalid Age" message
		// The message is not displayed when future dates are allowed
		this.invalidMessageElement = $("#invalidAgeMessage"+this.m_uniqueId);
		if(this.getSelectedDate() > todaysDate && this.m_dateSupportOption === 0){
			this.invalidMessageElement.addClass("show");
			this.ageDisplayInput.addClass("invalid");
		}
		else{
			this.invalidMessageElement.removeClass("show");
			this.ageDisplayInput.removeClass("invalid");
		}
		this.ageDisplayInput.val(ageVal);
	}
};

/**
 * The SortByCollationSeq function will sort the items according to the collation sequence
 */
DateSelector.prototype.SortByCollationSeq = function(a,b) {
	var aSeq = a.value.sequence;
	var bSeq = b.value.sequence;
	if (aSeq > bSeq) {
		return 1;
	} else {
		if (aSeq < bSeq) {
			return -1;
		}
		return 0;
	}
};

/**
* The retrieveRequiredResources function will determine if date and age precision codes are present in a shared resource otherwise make a script call to retrieve them
* @param {function} callBackFunction The call back function that will be executed after date and age codes are retrieved
*/ 
DateSelector.prototype.retrieveRequiredResources = function(callBackFunction){
	var self = this;

	// Get date precision codes from shared resource 
	var datePrecisionCdResource = MP_Resources.getSharedResource("datePrecisionCdResource");
	if(datePrecisionCdResource && datePrecisionCdResource.isResourceAvailable()){
		//At this point, the codes are already available, so get the data
		this.datePrecisionCodes = datePrecisionCdResource.getResourceData();
		this.retrievedDateCodes = true;
		
		// Sort precision codes by collation sequence
		this.datePrecisionCodes.sort(this.SortByCollationSeq);
	}
	else{
		// Make a call to retrieve the dates precision codes from code set 25320
		var dateDataRequest = new ScriptRequest();
		dateDataRequest.setName("DateCodesRequest");
		dateDataRequest.setProgramName("MP_GET_CODESET");
		dateDataRequest.setParameterArray(["^MINE^","25320.0"]);
		dateDataRequest.setAsyncIndicator(true);

		// Callback handler for dateDataRequest
		dateDataRequest.setResponseHandler(function(scriptReply){
			self.scriptCallBackHandler(scriptReply, self, callBackFunction);
		});

		dateDataRequest.performRequest();
	}

	// Get units for entering age from code set 340
	var ageUnitCdResource = MP_Resources.getSharedResource("ageUnitCdResource");
	if(ageUnitCdResource && ageUnitCdResource.isResourceAvailable()){
		//At this point, the codes are already available, so get the data
		this.ageUnitCodes = ageUnitCdResource.getResourceData();
		this.retrievedAgeCodes = true;
		
		// Sort unit codes by collation sequence
		this.ageUnitCodes.sort(this.SortByCollationSeq);
	}
	else{
		// Make a call to retrieve the age precision codes from code set 340
		var ageDataRequest = new ScriptRequest();
		ageDataRequest.setName("AgeCodesRequest");
		ageDataRequest.setProgramName("MP_GET_CODESET");
		ageDataRequest.setParameterArray(["^MINE^","340.0"]);
		ageDataRequest.setAsyncIndicator(true);

		// Callback handler for ageDataRequest
		ageDataRequest.setResponseHandler(function(scriptReply){
			self.scriptCallBackHandler(scriptReply, self,callBackFunction);
		});

		ageDataRequest.performRequest();
	}

	if(self.retrievedDateCodes && self.retrievedAgeCodes){
		// If both date and age codes are retrieved then call the call back function
		if(callBackFunction){
			callBackFunction();
		}
	}

};

/**
* The scriptCallBackHandler function will determine if the script reply from requests for retrieving date precision and age unit codes are returned 
* and only then call the call back function
* @param {object} scriptReply The reply of DateCodesRequest and AgeCodesRequest script
* @param {object} self The instance of DateSelector class
* @param {function}  callBackFunction The call back function that will be executed after date and age codes are retrieved
*/ 
DateSelector.prototype.scriptCallBackHandler = function(scriptReply, self, callBackFunction){
	if(scriptReply.getName() === "DateCodesRequest"){
		self.retrievedDateCodes = true;
		if(scriptReply.getResponse().STATUS_DATA.STATUS === "S"){
			self.datePrecisionCodes = scriptReply.getResponse().CODES;
			// Load the codes in a list so searching is easy
			self.datePrecisionCodes = MP_Util.LoadCodeListJSON(self.datePrecisionCodes);

			// Add it to the shared resource
			var datePrecisionCdResource = new SharedResource("datePrecisionCdResource");
			if(datePrecisionCdResource){
				datePrecisionCdResource.setResourceData(self.datePrecisionCodes);
				datePrecisionCdResource.setIsAvailable(true);
				MP_Resources.addSharedResource("datePrecisionCdResource",datePrecisionCdResource);
			}
		}
	}
	else if(scriptReply.getName() === "AgeCodesRequest"){
		self.retrievedAgeCodes = true;
		if(scriptReply.getResponse().STATUS_DATA.STATUS === "S"){
				self.ageUnitCodes = scriptReply.getResponse().CODES;
				// Load the codes in a list so searching is easy
				self.ageUnitCodes = MP_Util.LoadCodeListJSON(self.ageUnitCodes);

				// Add it to the shared resource
				var ageUnitCdResource = new SharedResource("ageUnitCdResource");
				if(ageUnitCdResource){
					ageUnitCdResource.setResourceData(self.ageUnitCodes);
					ageUnitCdResource.setIsAvailable(true);
					MP_Resources.addSharedResource("ageUnitCdResource",ageUnitCdResource);
				}
			}
	}
	if(self.retrievedDateCodes && self.retrievedAgeCodes){
		// Sort precision codes by collation sequence
		self.datePrecisionCodes.sort(self.SortByCollationSeq);

		// Sort unit codes by collation sequence
		self.ageUnitCodes.sort(self.SortByCollationSeq);
		
		// If both date and age codes are retrieved then call the call back function
		if(callBackFunction){
			callBackFunction();
		}
	}
};

/**
 * Function name: handleDateSelector
 * This function will set appropriate constraints and format on the date picker so that the date input field shows date in correct selected format
 * @param {HTML element} dateControlTarget A HTML div element where the date control will be appended
 * @param {integer} dateFlag A flag indicating whether the date format is Year, Month/Year, Week Of or Date. This is one of the options from m_dateSelectorOptions.
 */
DateSelector.prototype.handleDateSelector = function(dateControlTarget, dateFlag) {
    var self = this;

	this.dateHelperText = this.m_helperTextOptions[dateFlag];

	// Add a input field to invoke a date picker
	if(!$("#datePicker"+this.m_uniqueId).length){
		dateControlTarget.append("<span id='datePickerHolder"+this.m_uniqueId+"' class='dc-date-picker-holder'><input id='datePicker"+this.m_uniqueId+"' type='button' class='dc-date-picker'></span>");
	}
	
	var datePickerControl = $("#datePicker"+this.m_uniqueId);
	var displayInputValue = this.dateDisplayInput.val();

	var datepickerOptions = {showOn:"both",
							buttonImage:CERN_static_content+"/images/4974.png",
							buttonImageOnly:true,
							changeMonth: true,
							changeYear: true,
							showButtonPanel: true,
							altField:self.dateDisplayInput,  // Date selected in the picker will be displayed in this element
							onSelect: function(){
								self.dateDisplayInput.removeClass('secondary-text');
								//Set focus on date input field
								self.dateDisplayInput.focus();
							}
						  };
	
	datePickerControl.datepicker(datepickerOptions);
	datePickerControl.datepicker("option", "dateFormat", this.m_localeDateFormat[this.m_dateSelectorOptions.DATE]); // This needs to be the full date format according to the locale
	datePickerControl.datepicker("option", "constrainInput", true); 
	datePickerControl.datepicker("option", "maxDate", "0d" );
	datePickerControl.datepicker("option", "altFormat", this.m_localeDateFormat[dateFlag]);  //This is the format for the input field

	// Set minimum date on the date picker as the patient's date of birth
	if(this.m_patDOB){
		datePickerControl.datepicker("option", "minDate", this.m_patDOB);
	}
	
	//If the date supported option is set,set the minimum date and maximum date accordingly.
	//1 - allow only future dates
	//2 - allow both future and past dates and minimum date still depends on the DOB
	//3 - allow past dates but not limited to patient's DOB
	//This indicator is not dependent on the fuzzy flag.
	var dateSupportOptionSelected = this.getDateSupportOption();
	if(dateSupportOptionSelected){
		if(dateSupportOptionSelected === 1){
			datePickerControl.datepicker("option", "minDate", "0d");
			datePickerControl.datepicker("option", "maxDate", null);
		}
		else if(dateSupportOptionSelected === 2){
			datePickerControl.datepicker("option", "maxDate", null);
		}
		else if(dateSupportOptionSelected === 3){
			datePickerControl.datepicker("option", "minDate", null);
			datePickerControl.datepicker("option", "maxDate", "0d");
		}
	}

	// Check if any date is already set , this can occur when Age option is selected, We will want to show the date in the date input field then
	var selectedDateObj = this.getSelectedDate();
	var selectedDateStr = "";

	if(selectedDateObj){
		var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
		selectedDateStr = df.format(selectedDateObj, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR);
		datePickerControl.datepicker("setDate", selectedDateStr);
	}
	
	// Show a helper text if no date in the input exists
	if(!selectedDateStr && (!displayInputValue || displayInputValue === this.dateHelperText)){
		 this.dateDisplayInput.val(this.dateHelperText);
		 this.dateDisplayInput.addClass('secondary-text');
	}

	// Cache elements for future use 
	this.dateControlTarget = dateControlTarget;
	this.datePickerControl = datePickerControl;

    // Event handler when date in the input field is manually added or when selected from the date picker
    if(this.dateDisplayInput){
    	this.dateDisplayInput.on('change focusin',function(){
    		var selectedDateFormat = 0;
    		if(self.getFuzzyFlag()){
				selectedDateFormat = parseInt(self.dateFormatSelector.val(),10);
    		}
    		if(!self.dateDisplayInput.val()){
    			self.setSelectedDate(null);
    		}
			self.handleDateUserEnters(selectedDateFormat);
		});
    }
};

/**
 * The handleDateUserEnters function will set a date in the date picker whenever user manually enters a date in the date input field for the date picker. 
 * The constraints on the date input field is already applied by the date picker so no extra check is required. 
 * @param {integer} selectedDateFormat A flag indicating whether the date format is Year, Month/Year, Week Of or Date. This is one of the options from m_dateSelectorOptions.
 */
DateSelector.prototype.handleDateUserEnters = function(selectedDateFormat){
	var dateEntered = this.dateDisplayInput.val();
	
	if(dateEntered && dateEntered != this.dateHelperText){
		// Set the date on date-picker to this date so that selection is easy, the date picker also has its own format validator and will validate the date passed to 'setDate'
		this.dateDisplayInput.removeClass('secondary-text');
		var dateSetOnPicker = "";
		var tempDate = new Date();

		switch(selectedDateFormat){
			// When "Date" is selected
			case(0):
			// When "Week Of" is selected
			case(1): this.datePickerControl.datepicker('setDate', dateEntered);
					 break;
			// When Month/Year is selected format the date as mm/01/yyyy
			case(2): var dateToken = dateEntered.split("/");
					 // Find out if the date was entered with "/" (for English) or "." (for German)
					 if(!dateToken[1]){
						// If dateToken[1] is undefined that means the separator is not a "/" rather than a "."
						dateToken = dateEntered.split(".");
						tempDate.setDate(1);
						tempDate.setMonth(dateToken[0]-1); // Jan = 0
						tempDate.setFullYear(dateToken[1]);
						// Format the full date according to the locale 
						dateSetOnPicker = tempDate.format(MP_Util.GetDateFormatter().lc.fulldate4yr);
					 }
					 else{
					 	// If dateToken[1] is defined that means the separator is a "/" rather a "."
						tempDate.setDate(1);
						tempDate.setMonth(dateToken[0]-1); // Jan = 0
						tempDate.setFullYear(dateToken[1]);
						// Format the full date according to the locale 
						dateSetOnPicker = tempDate.format(MP_Util.GetDateFormatter().lc.fulldate4yr);
					 }
					 this.datePickerControl.datepicker("setDate", dateSetOnPicker);
					 break;
			case(3) : // When only Year is selected format the date as date and month both to 1 and year will be the one user selected
						tempDate.setDate(1);
						tempDate.setMonth(0);
						tempDate.setFullYear(dateEntered);
						dateSetOnPicker = tempDate.format(MP_Util.GetDateFormatter().lc.fulldate4yr);
						this.datePickerControl.datepicker("setDate", dateSetOnPicker);
					 break;
		}

		// Set the selected date object set on the date picker for consumer to read
		this.setSelectedDate(this.datePickerControl.datepicker("getDate"));
	}
	else{
		// Call the function that will set the helper text
		this.handleDateSelector(this, selectedDateFormat);
	}
};


/**
* The handleAgeSelected function will display a input field for entering the number and a then a menu to its right for selecting the unit for Age whether
* it is Days, Weeks, Months, Year. If a date is entered and the format selector was flipped to Age then the input field for age will show 'x' number of years/months/weeks/days
*/
DateSelector.prototype.handleAgeSelected = function(){
	var ageUnitLen = this.ageUnitCodes.length;
    var ageUnitDisplay = "";
    var ageUnitMeaning = "";
    var ageUnitCd = 0;
    var ageUnitHTML = "";

    var newDate = null;
    var diffDays = 0;

  	if(!$("#ageUnitSelector"+this.m_uniqueId).length){
    	 ageUnitHTML = "<select id='ageUnitSelector"+this.m_uniqueId+"' class='dc-age-unit-selector'>";
	
	    // Add the supported units in a menu
		for(var idx=0; idx < ageUnitLen; idx++){
			ageUnitDisplay = this.ageUnitCodes[idx].value.display;
			ageUnitMeaning = this.ageUnitCodes[idx].value.meaning;
			ageUnitCd = this.ageUnitCodes[idx].value.codeValue;
			if(ageUnitMeaning && $.inArray(ageUnitMeaning, this.m_supportedAgeUnits) >=0){
				ageUnitHTML += "<option value="+ageUnitCd+" data-unit="+ageUnitMeaning+">"+ageUnitDisplay+"</option>";
			} 
		}

		ageUnitHTML += "</select>";

		// Append a drop down after the date display input
		this.ageDisplayInput.after(ageUnitHTML);

		// Set the age unit flag as the first one in the units list 
		this.setSelectedAgeUnit(document.getElementById('ageUnitSelector'+this.m_uniqueId).options[0].getAttribute('data-unit'));
	}	

	// Hide the date input related fields
	if(this.dateControlTarget){
		$("#datePickerHolder"+this.m_uniqueId).find('.ui-datepicker-trigger').hide();
	}

	// Limit the input to accept only 3 numbers
	this.ageDisplayInput.attr("maxLength", "3");

	// Cache the selector 
	this.ageUnitSelector = $("#ageUnitSelector"+this.m_uniqueId);

	var self = this;

	// If format other than Age is selected and flipped back to Age then calculate the Age in year/month/weeks/days and show the number in age input field 
	if(this.getSelectedDate()){
		var ageSelectorElement = document.getElementById("ageUnitSelector"+this.m_uniqueId);
		switch(this.getSelectedAgeUnit()){
			case "YEARS" : 
						var diffYears = 0;
						// Find the difference in years 
						diffYears = this.getSelectedDate().getFullYear() - this.m_patDOB.getFullYear();
						
						if(diffYears>=0){
							this.ageDisplayInput.val(diffYears);
						}
						else{
							this.ageDisplayInput.val(0);
						}

						// Flip the unit selector to show Years if not already
						ageSelectorElement.value =  MP_Util.GetCodeByMeaning(this.ageUnitCodes, "YEARS").codeValue; 

						// When Age is selected and saved then the procedure date should go as the date and month from the date of birth and year is the selected year
						newDate = new Date(this.getSelectedDate().getFullYear(), this.m_patDOB.getMonth(), this.m_patDOB.getDate());
						this.setSelectedDate(newDate);
						this.m_selectedDateFlag = this.m_dateSelectorOptions.YEAR;
						break;
			case "MONTHS" : 
						var birthYear = this.m_patDOB.getFullYear();
						var selectedYr = this.getSelectedDate().getFullYear();
						var birthMonth = this.m_patDOB.getMonth();
						var selectedMonth = this.getSelectedDate().getMonth();

						var diffMonths=(selectedYr-birthYear)*12+(selectedMonth-birthMonth);
						
						if(diffMonths){
							this.ageDisplayInput.val(diffMonths);
						}
						else{
							this.ageDisplayInput.val(0);
						}
						
						// Flip the unit selector to show Years if not already
						ageSelectorElement.value =  MP_Util.GetCodeByMeaning(this.ageUnitCodes, "MONTHS").codeValue; 
						
						// When Age is selected and saved then the procedure date should go as the month from the date of birth and year is the selected year, the date is the 1st day
						newDate = new Date(selectedYr, selectedMonth, 1);
						this.setSelectedDate(newDate);
						this.m_selectedDateFlag = this.m_dateSelectorOptions.MONTH_YEAR;
						break;

			case "WEEKS" : 
 						diffDays = (this.getSelectedDate().getTime() - this.m_patDOB.getTime()) / 86400000;
 						var diffWeeks = Math.ceil(diffDays/7);
 						
 						if(diffWeeks){
 							 this.ageDisplayInput.val(diffWeeks);
 						}
 						else{
 							this.ageDisplayInput.val(0);
 						}

						// Flip the unit selector to show Years if not already
						ageSelectorElement.value =  MP_Util.GetCodeByMeaning(this.ageUnitCodes, "WEEKS").codeValue; 
						this.m_selectedDateFlag = this.m_dateSelectorOptions.WEEK_OF;
						break;
			case "DAYS" : 
 						diffDays = (this.getSelectedDate().getTime() - this.m_patDOB.getTime()) / 86400000;
 						
 						if(diffDays){
 							this.ageDisplayInput.val(Math.ceil(diffDays));
 						}
 						else{
 							this.ageDisplayInput.val(0);
 						}
						
						// Flip the unit selector to show days if not already
						ageSelectorElement.value =  MP_Util.GetCodeByMeaning(this.ageUnitCodes, "DAYS").codeValue; 
						this.m_selectedDateFlag = this.m_dateSelectorOptions.DATE;
						break;
		}
		
		// Trigger age display input change to show "Invalid Age" message appropriately
		this.ageDisplayInput.triggerHandler('keyup');
	}

	// Event handler when age unit is changed 
	this.ageUnitSelector.change(function(){
		// Trigger age display input change to show "Invalid Age" message appropriately
		self.ageDisplayInput.triggerHandler('keyup');
		var unitSelector = document.getElementById('ageUnitSelector'+self.m_uniqueId);
		var selectedUnit = unitSelector[unitSelector.selectedIndex].getAttribute('data-unit');
		self.setSelectedAgeUnit(selectedUnit);
		self.handleAgeEntered(self.ageDisplayInput.val());
		
		// Fire event to all listeners who are listening for the selected age unit 
		CERN_EventListener.fireEvent(null,self,"selectedAgeUnitAvailable"+self.m_uniqueId,self);
	});
};


/**
* The handleAgeEntered function will read the number and unit of age(Years, Months, Weeks, and Days) and convert that to date time 
* @param {integer} The number entered in the age input field. Only integers are allowed.
*/ 
DateSelector.prototype.handleAgeEntered = function(ageValue){
	ageValue = parseInt(ageValue, 10);

	if(ageValue >=0){
		// Read the number and unit selected by user
		var unitSelector = document.getElementById('ageUnitSelector'+this.m_uniqueId);
		var selectedUnit = unitSelector[unitSelector.selectedIndex].getAttribute('data-unit');
	
		var dt = 0; 
		var yr = 0;
		var mnth = 0;
		var calculatedDate = null;
	
		// Get date, month and year from patient's date of birth (DOB)
		var dobYr = this.m_patDOB.getFullYear();
		var dobMonth = this.m_patDOB.getMonth();
		var dobDate = this.m_patDOB.getDate();
	
		// Given the unit and number convert the age entered into a date/time
		switch(selectedUnit){
			case("YEARS") :  
					 	  	// Calculated the year per number of years entered
						 	yr = dobYr + ageValue;
	
						 	// Create a new date object by using the year calculated above 
						 	calculatedDate = new Date(yr, dobMonth, dobDate);
						 	this.setSelectedDate(calculatedDate);
						 	this.m_selectedDateFlag = this.m_dateSelectorOptions.YEAR;
							break;
			case("MONTHS") :  
						 	// Calculated the month per number of months entered
						 	mnth = dobMonth + ageValue;
	
						 	// Create a new date object by using the month calculated above , since a month is selected format date as the first date of the month
						 	calculatedDate = new Date(dobYr, mnth, 1);
						 	this.setSelectedDate(calculatedDate);
						 	this.m_selectedDateFlag = this.m_dateSelectorOptions.MONTH_YEAR;
							break;
	
			case("WEEKS") :
							// Convert weeks into days per number of weeks entered
							dt =  dobDate+ageValue*7;
	
						 	// Create a new date object by using the days calculated above 
						 	calculatedDate = new Date(dobYr, dobMonth, dt);
						 	this.setSelectedDate(calculatedDate);
						 	this.m_selectedDateFlag = this.m_dateSelectorOptions.WEEK_OF;
							break;
	
			case("DAYS") : 
							// Calculate days per number of age entered
							dt =  dobDate+ageValue;
	
						 	// Create a new date object by using the dates calculated above
						 	calculatedDate = new Date(dobYr, dobMonth, dt);
						 	this.setSelectedDate(calculatedDate);
						 	this.m_selectedDateFlag = this.m_dateSelectorOptions.DATE;
							break;
			}
	}
	else
	{
		this.setSelectedDate(null);
		this.m_selectedDateFlag = this.m_dateSelectorOptions.DATE;
	}
};
var HealtheIntent = HealtheIntent || {};
HealtheIntent.PersonSearch = HealtheIntent.PersonSearch || {};

HealtheIntent.PersonSearch.DemographicsList = function(demoList) {
	var list = $.map($.makeArray(demoList && demoList.persons), function(demo) {
		return HealtheIntent.PersonSearch.Demographics(demo);
	});

	list.more_results = demoList && demoList.more_results;
	list.total_results = demoList && demoList.total_results;

	return list;
};

HealtheIntent.PersonSearch.Demographics = (function() {
	// private

	var trans = i18n.discernabu.HealtheIntent.PersonSearch,
		noData = trans.noData;

	function address_last_line(demo) {
		if (demo.address && (demo.address.city || demo.address.state_or_province || demo.address.postal_code)) {
			var city = demo.address.city || '',
				postalCode = demo.address.postal_code || '',
				state = demo.address.state_or_province || '';

			return trans.addressLastLine
				.replace("{city}", city)
				.replace("{state}", state)
				.replace("{postalCode}", postalCode);
		}
		else {
			return noData;
		}
		;
	}

	function street_address(demo) {
		if (demo.address && demo.address.street_addresses) {
			return demo.address.street_addresses.join(trans.addressSeparator);
		}
		else {
			return noData;
		}
		;
	}

	function age(demo) {
		try {
			var dob = demo.date_of_birth && $.datepicker.parseDate(trans.dateFormat, demo.date_of_birth.split('T')[0]);
			return dob ? MP_Util.CalcAge(dob) : noData;
		} catch (err) { // occurs when date_of_birth is invalid
			return noData;
		}
	};

	function dob(demo) {
		var dob;

		try {
			if (demo.date_of_birth) {
				dob = new Date();
				dob.setISO8601(demo.date_of_birth);
				return dob.format(MPAGE_LOCALE.fulldate4yr, true);
			}
			else {
				return noData;
			}
		} catch (err) { // occurs when date_of_birth is invalid
			logger.logWarning("Date of birth is invalid");
			return noData;
		}
	};

	function gender(demo) {
		return (demo.gender && demo.gender[0]) || noData;
	}

	function name(demo) {
		return demo.formatted_name || noData;
	};

	function phone(demo) {
		var phone = $.grep($.makeArray(demo.telecoms), function(telecom) {
			return telecom.preferred;
		})[0];

		if (phone && phone.number && phone.extension) {
			return phone.number + ' ' + phone.extension;
		}
		else if (phone && phone.number) {
			return phone.number;
		}
		else {
			return noData;
		}
	}

	// public

	return function decorate(rawDemographics) {
		var demographics = $.extend({}, rawDemographics);

		demographics.address_last_line = address_last_line(demographics);
		demographics.street_address = street_address(demographics);

		demographics.age = age(demographics);
		demographics.dob = dob(demographics);
		demographics.gender = gender(demographics);
		demographics.name = name(demographics);
		demographics.phone = phone(demographics);

		return demographics;
	};
})();
function DrgSearchControl(oTextBox){var selectedDRG;
var drgResults;
var isSearchByCode=function(searchString){var reg=new RegExp("[0-9]+[.]?[0-9]*$");
return reg.test(searchString);
};
function ArraySortNumberAscending(a,b){if(a&&b){if(a.VALUE.SOURCEIDENTIFIER>b.VALUE.SOURCEIDENTIFIER){return 1;
}else{if(a.VALUE.SOURCEIDENTIFIER<b.VALUE.SOURCEIDENTIFIER){return -1;
}else{return 0;
}}}else{if(!a&&b){return -1;
}else{if(a&&!b){return 1;
}else{return 0;
}}}}function ArraySortStringAscending(a,b){if((!a.NAME||a.NAME.length===0)&&(b.NAME&&b.NAME.length>0)){return -1;
}else{if((!b.NAME||b.NAME.length===0)&&(a.NAME&&a.NAME.length>0)){return 1;
}else{if((a.NAME&&a.NAME.length>0)&&(b.NAME&&b.NAME.length>0)){var aName=a.NAME;
var bName=b.NAME;
if(aName.length>bName.length){aName=aName.substring(0,aName.length);
}else{if(aName.length>bName.length){bName=bName.substring(0,bName.length);
}}if(aName>bName){return 1;
}else{if(aName<bName){return -1;
}else{return 0;
}}}else{return 0;
}}}}var getFilteredResults=function(searchString){var filteredResults=[];
if(isSearchByCode(searchString)){for(var i=0,length=drgResults.length;
i<length;
i++){var result=drgResults[i];
if(result){filteredResults.push(result);
}}filteredResults.sort(ArraySortNumberAscending);
}else{for(var i=0,length=drgResults.length;
i<length;
i++){var result=drgResults[i];
if(result){filteredResults.push(result);
}}filteredResults.sort(ArraySortStringAscending);
}return filteredResults;
};
var selectionHandler=function(newselectedDRG){selectedDRG=newselectedDRG;
};
var queryHandler=function(callback,searchString){if(searchString.replace(/\s+/g,"").length<3&&!isSearchByCode(searchString)){callback.autosuggest(new Array());
}else{new DrgServiceDelegate().getResults(searchString,function(results){drgResults=results;
callback.autosuggest(getFilteredResults(searchString));
});
}};
this.setSelectedDRG=function(selectedDRG,term){selectedDRG=selectedDRG;
oTextBox.value=term;
autoSuggestControl.setVerified(selectedDRG);
};
var addEventHandler=function(element,event,handler){if(element){element.addEventListener?element.addEventListener(event,handler,false):element.attachEvent("on"+event,handler);
}};
addEventHandler(oTextBox.form,"reset",function(){if(oTextBox.form){selectedId=0;
autoSuggestControl.setVerified(false);
}});
this.getSelectedDRG=function(){return selectedDRG;
};
this.setRequired=function(required){autoSuggestControl.setRequired(required);
};
this.isVerified=function(){return autoSuggestControl.isVerified;
};
this.addVerifyStateChangeListener=function(listener){autoSuggestControl.addVerifyStateChangeListener(listener);
};
this.removeVerifyStateChangeListener=function(listener){autoSuggestControl.removeVerifyStateChangeListener(listener);
};
var autoSuggestControl=new RCMAutoSuggestControl(oTextBox,queryHandler,selectionHandler,ToolTipDetailsHandler);
autoSuggestControl.delay=3;
}
function DrgServiceDelegate(){this.getResults=function(searchString,callback){var json={drg_search_request:{search_phrase:searchString,term_limit:0}};
var sendAr=[];
sendAr.push("^MINE^","0.0","3","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",sendAr,true,function(status,recordData){if("S"===status){var drgResults=new Array();
for(var i=0,length=recordData.TERMS.length;
i<length;
i++){var drg=recordData.TERMS[i];
drgResults.push({NAME:drg.TERM+" ("+drg.CODE+")",VALUE:{SOURCEIDENTIFIER:drg.CODE,NOMENCLATUREID:drg.NOMENCLATURE_ID},DETAILS:"<strong>Description</strong>: <dfn>"+drg.TERM+"</dfn><br><strong>Code</strong>: <em>"+drg.CODE+"</em>"});
}callback(drgResults);
}else{if("F"===status){if(recordData){alert(recordData);
}}}});
};
}
mp_formatter={};
mp_formatter.Locale=function(properties){this._className="mp_formatter.Locale";
this._parseList=function(names,expectedItems){var array=[];
if(names===null){throw"Names not defined";
}else{if(typeof names=="object"){array=names;
}else{if(typeof names=="string"){array=names.split(";",expectedItems);
for(var i=0;
i<array.length;
i++){if(array[i][0]=='"'&&array[i][array[i].length-1]=='"'){array[i]=array[i].slice(1,-1);
}else{throw"Missing double quotes";
}}}else{throw"Names must be an array or a string";
}}}if(array.length!=expectedItems){throw"Expected "+expectedItems+" items, got "+array.length;
}return array;
};
this._validateFormatString=function(formatString){if(typeof formatString=="string"&&formatString.length>0){return formatString;
}else{throw"Empty or no string";
}};
if(properties===null||typeof properties!="object"){throw"Error: Invalid/missing locale properties";
}if(typeof properties.decimal_point!="string"){throw"Error: Invalid/missing decimal_point property";
}this.decimal_point=properties.decimal_point;
if(typeof properties.thousands_sep!="string"){throw"Error: Invalid/missing thousands_sep property";
}this.thousands_sep=properties.thousands_sep;
if(typeof properties.grouping!="string"){throw"Error: Invalid/missing grouping property";
}this.grouping=properties.grouping;
if(properties===null||typeof properties!="object"){throw"Error: Invalid/missing time locale properties";
}try{this.time24hr=this._validateFormatString(properties.time24hr);
}catch(error){throw"Error: Invalid time24hr property: "+error;
}try{this.time24hrnosec=this._validateFormatString(properties.time24hrnosec);
}catch(error){throw"Error: Invalid time24hrnosec property: "+error;
}try{this.shortdate2yr=this._validateFormatString(properties.shortdate2yr);
}catch(error){throw"Error: Invalid shortdate2yr property: "+error;
}try{this.fulldate4yr=this._validateFormatString(properties.fulldate4yr);
}catch(error){throw"Error: Invalid fulldate4yr property: "+error;
}try{this.fulldate2yr=this._validateFormatString(properties.fulldate2yr);
}catch(error){throw"Error: Invalid fulldate2yr property: "+error;
}try{this.fullmonth4yrnodate=this._validateFormatString(properties.fullmonth4yrnodate);
}catch(error){throw"Error: Invalid fullmonth4yrnodate property: "+error;
}try{this.full4yr=this._validateFormatString(properties.full4yr);
}catch(error){throw"Error: Invalid full4yr property: "+error;
}try{this.fulldatetime2yr=this._validateFormatString(properties.fulldatetime2yr);
}catch(error){throw"Error: Invalid fulldatetime2yr property: "+error;
}try{this.fulldatetime4yr=this._validateFormatString(properties.fulldatetime4yr);
}catch(error){throw"Error: Invalid fulldatetime4yr property: "+error;
}try{this.fulldatetimenoyr=this._validateFormatString(properties.fulldatetimenoyr);
}catch(error){throw"Error: Invalid fulldatetimenoyr property: "+error;
}};
mp_formatter._getPrecision=function(optionsString){if(typeof optionsString!="string"){return -1;
}var m=optionsString.match(/\.(\d)/);
if(m){return parseInt(m[1],10);
}else{return -1;
}};
mp_formatter._isNumber=function(arg){if(typeof arg=="number"){return true;
}if(typeof arg!="string"){return false;
}var s=arg+"";
return(/^-?(\d+|\d*\.\d+)$/).test(s);
};
mp_formatter._isDate=function(arg){if(arg.getDate){return true;
}return false;
};
mp_formatter._trim=function(str){var whitespace=" \n\r\t\f\x0b\xa0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000";
for(var i=0;
i<str.length;
i++){if(whitespace.indexOf(str.charAt(i))===-1){str=str.substring(i);
break;
}}for(i=str.length-1;
i>=0;
i--){if(whitespace.indexOf(str.charAt(i))===-1){str=str.substring(0,i+1);
break;
}}return whitespace.indexOf(str.charAt(0))===-1?str:"";
};
mp_formatter._splitNumber=function(amount){if(typeof amount=="number"){amount=amount+"";
}var obj={};
if(amount.charAt(0)=="-"){amount=amount.substring(1);
}var amountParts=amount.split(".");
if(!amountParts[1]){amountParts[1]="";
}obj.integer=amountParts[0];
obj.fraction=amountParts[1];
return obj;
};
mp_formatter._formatIntegerPart=function(intPart,grouping,thousandsSep){if(thousandsSep===""||grouping=="-1"){return intPart;
}var groupSizes=grouping.split(";");
var out="";
var pos=intPart.length;
var size;
while(pos>0){if(groupSizes.length>0){size=parseInt(groupSizes.shift(),10);
}if(isNaN(size)){throw"Error: Invalid grouping";
}if(size==-1){out=intPart.substring(0,pos)+out;
break;
}pos-=size;
if(pos<1){out=intPart.substring(0,pos+size)+out;
break;
}out=thousandsSep+intPart.substring(pos,pos+size)+out;
}return out;
};
mp_formatter._formatFractionPart=function(fracPart,precision){for(var i=0;
fracPart.length<precision;
i++){fracPart=fracPart+"0";
}return fracPart;
};
mp_formatter._hasOption=function(option,optionsString){if(typeof option!="string"||typeof optionsString!="string"){return false;
}if(optionsString.indexOf(option)!=-1){return true;
}else{return false;
}};
mp_formatter._validateFormatString=function(formatString){if(typeof formatString=="string"&&formatString.length>0){return true;
}else{return false;
}};
mp_formatter.NumericFormatter=function(locale){if(typeof locale!="object"||locale._className!="mp_formatter.Locale"){throw"Constructor error: You must provide a valid mp_formatter.Locale instance";
}this.lc=locale;
this.format=function(number,options){if(typeof number=="string"){number=mp_formatter._trim(number);
}if(!mp_formatter._isNumber(number)){throw"Error: The input is not a number";
}var floatAmount=parseFloat(number,10);
var reqPrecision=mp_formatter._getPrecision(options);
if(reqPrecision!=-1){floatAmount=Math.round(floatAmount*Math.pow(10,reqPrecision))/Math.pow(10,reqPrecision);
}var parsedAmount=mp_formatter._splitNumber(String(floatAmount));
var formattedIntegerPart;
if(floatAmount===0){formattedIntegerPart="0";
}else{formattedIntegerPart=mp_formatter._hasOption("^",options)?parsedAmount.integer:mp_formatter._formatIntegerPart(parsedAmount.integer,this.lc.grouping,this.lc.thousands_sep);
}var formattedFractionPart=reqPrecision!=-1?mp_formatter._formatFractionPart(parsedAmount.fraction,reqPrecision):parsedAmount.fraction;
var formattedAmount=formattedFractionPart.length?formattedIntegerPart+this.lc.decimal_point+formattedFractionPart:formattedIntegerPart;
if(mp_formatter._hasOption("~",options)||floatAmount===0){return formattedAmount;
}else{if(mp_formatter._hasOption("+",options)||floatAmount<0){if(floatAmount>0){return"+"+formattedAmount;
}else{if(floatAmount<0){return"-"+formattedAmount;
}else{return formattedAmount;
}}}else{return formattedAmount;
}}};
};
mp_formatter.DateTimeFormatter=function(locale){if(typeof locale!="object"||locale._className!="mp_formatter.Locale"){throw"Constructor error: You must provide a valid mp_formatter.Locale instance";
}this.lc=locale;
this.formatISO8601=function(dateStr,option){if(!mp_formatter._validateFormatString(dateStr)){throw"Error: The input is either empty or no string";
}var date=new Date();
date.setISO8601(dateStr);
return this.format(date,option);
};
this.format=function(dateTime,option){if(!mp_formatter._isDate(dateTime)){throw"Error: The input is not a date object";
}switch(option){case mp_formatter.DateTimeFormatter.TIME_24HOUR:return(dateTime.format(this.lc.time24hr));
case mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS:return(dateTime.format(this.lc.time24hrnosec));
case mp_formatter.DateTimeFormatter.SHORT_DATE_2YEAR:return dateTime.format(this.lc.shortdate2yr);
case mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR:return dateTime.format(this.lc.fulldate4yr);
case mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR:return dateTime.format(this.lc.fulldate2yr);
case mp_formatter.DateTimeFormatter.FULL_MONTH_4YEAR_NO_DATE:return dateTime.format(this.lc.fullmonth4yrnodate);
case mp_formatter.DateTimeFormatter.FULL_4YEAR:return dateTime.format(this.lc.full4yr);
case mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR:return(dateTime.format(this.lc.fulldatetime2yr));
case mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR:return(dateTime.format(this.lc.fulldatetime4yr));
case mp_formatter.DateTimeFormatter.FULL_DATE_TIME_NO_YEAR:return(dateTime.format(this.lc.fulldatetimenoyr));
default:alert("Unhandled date time formatting option");
}};
};
mp_formatter.DateTimeFormatter.TIME_24HOUR=1;
mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS=2;
mp_formatter.DateTimeFormatter.SHORT_DATE_2YEAR=3;
mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR=4;
mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR=5;
mp_formatter.DateTimeFormatter.FULL_MONTH_4YEAR_NO_DATE=6;
mp_formatter.DateTimeFormatter.FULL_4YEAR=7;
mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR=8;
mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR=9;
mp_formatter.DateTimeFormatter.FULL_DATE_TIME_NO_YEAR=10;
/**
 * The GapCheck object
 * This object is used to honour Gapcheck functionality and provides the ability add override reasons
 * for the unsatisfied components to complete the discharge work flow
 * @constructor
 * @author Neethu Shree
 */
var GapCheck = function(){
	this.m_auditEventsList = [];
	this.m_currentAuditEventsList = [];
	this.m_responseHandler = null;
	this.m_encounterType = 0;
	this.m_catergoryMean = "";
};

/**
 * Sets the function to be called after gap checking
 * @param {function} responseHandler : The function which is executed when we click on create Note link.
 * @return {undefined} This function does not return a value
 */
GapCheck.prototype.setResponseHandler = function(responseHandler){
	if(typeof responseHandler !== "function"){
		throw new Error("GapCheck.prototype.setResponseHandler expects a function.");
	}
	this.m_responseHandler = responseHandler;
};
/**
 * Returns the function to be executed when clicked on submit
 * @return {GapCheck.m_responseHandler} The function to be called after gap checking
 */
GapCheck.prototype.getResponseHandler = function(){
	return this.m_responseHandler;
};
/**
 * Holds the value of encounter type returned from mp_retrieve_audit_events
 * @param {int} encounterType : Holds the encounter type
 * @return {undefined} This function does not return a value
 */
GapCheck.prototype.setEncounterType = function(encounterType){
	this.m_encounterType = encounterType;
};
/**
 * Determines the encounter type based on the value set in m_encounterType.
 * @return {GapCheck.m_encounterType} The function returns the encounter type
 */
GapCheck.prototype.getEncounterType = function(){
	return this.m_encounterType;
};
/**
 * JSON for Audit Elements retrieved from mp_get_audit_event, this will 
 * be used populate the saved override reason details 
 * @return {Object} AuditEventElementsJSON : json object for saving the audit details information obtained from getAuditEventsList method.
 */
GapCheck.prototype.AuditEventElementsJSON = function () {
	return {
		tracking_audit_element_id : 0.0,
		audit_element_name : "",
		audit_element_txt : "",
		audit_value : 0.0,
		audit_string : "",
		audit_flag : 0,
		audit_dt_tm : "",
		update_flag : 0,
		component_Id : 0.0
	};
};
/**
 * JSON for Update Audit Elements Request to mp_add_upd_audit_event, this will be one of the
 * parameters within the Audit Events Request JSON
 * @return {Object} UpdateAuditEventElementsJSON : json object for saving the modified information of audit events
 */
GapCheck.prototype.UpdateAuditEventElementsJSON = function () {
	return {
		tracking_audit_element_id : 0.0,
		audit_element_name : "",
		audit_element_txt : "",
		audit_value : 0.0,
		audit_string : "",
		audit_flag : 0,
		audit_dt_tm : "",
		audit_element_string : ""
	};
};
/**
 * JSON for Audit Elements Request to mp_add_upd_audit_event, this will 
 * be one of the parameters within the Audit Events Request JSON
 * @return {Object} NewAuditEventElementsJSON : json object for saving the new audit event details
 */
GapCheck.prototype.NewAuditEventElementsJSON = function () {
	return {
		audit_element_name : "",
		audit_element_txt : "",
		audit_value : 0.0,
		audit_string : "",
		audit_flag : 0,
		audit_dt_tm : "",
		audit_element_string : ""
	};
};

/**
 * JSON for Audit Events request to mp_add_upd_audit_event
 * @return {Object} AuditEventsRequestJSON : Audit Event Request to mp_add_upd_audit_event
 */
GapCheck.prototype.AuditEventsRequestJSON = function () {
	this.tracking_audit_id = 0.0;
	this.encntr_id = 0.0;
	this.tracking_group_cd = 0.0;
	this.audit_type_cd = 0.0;
	this.updt_id = 0.0;
	this.clear_audit_elements_ind = 0;
	this.audit_elements = [];
	this.upd_audit_elements = [];
};

/**
 * Assorts all the details needed for the saving process
 * Creates two arrays add and update based on the update_flag 
 * @param {Object} criterion object
 * @return {undefined} This function does not return a value
 */
GapCheck.prototype.addUpdateAuditEventsList = function (criterion) {
	try {
		var encounterId = criterion.encntr_id;
		var self = this;
		var cclParam = [];
		var scriptRequest = new ScriptRequest();
		var requestJSONStr = "";
		var eventsList = this.m_currentAuditEventsList;
		var indexCnt = eventsList.length;
		var index = 0;
		var timerAddUpdAuditEvents = null;
		self.m_auditEventsList = new self.AuditEventsRequestJSON();
		self.m_auditEventsList.encntr_id = encounterId;
		timerAddUpdAuditEvents = MP_Util.CreateTimer("ENG:MPG.GAP-CHECK-ADD UPDATE AUDIT EVENTS");
		for (index = 0; index < indexCnt; index++) {
			var eventListObj = eventsList[index].value;
			if (eventListObj.update_flag === 0) {
				var auditElementsObj = new self.NewAuditEventElementsJSON();
				auditElementsObj.audit_element_name = eventListObj.audit_element_name;
				auditElementsObj.audit_element_txt = eventListObj.audit_element_txt;
				auditElementsObj.audit_value = parseInt(eventListObj.audit_value,10);
				auditElementsObj.audit_string = eventListObj.audit_string;
				auditElementsObj.audit_flag = eventListObj.audit_flag;
				self.m_auditEventsList.audit_elements.push(auditElementsObj);
			} else if (eventListObj.update_flag === 1) {
				var updAuditElementsObj = new self.UpdateAuditEventElementsJSON();
				updAuditElementsObj.tracking_audit_element_id = eventListObj.tracking_audit_element_id;
				updAuditElementsObj.audit_element_name = eventListObj.audit_element_name;
				updAuditElementsObj.audit_element_txt = eventListObj.audit_element_txt;
				updAuditElementsObj.audit_value = parseInt(eventListObj.audit_value,10);
				updAuditElementsObj.audit_string = eventListObj.audit_string;
				updAuditElementsObj.audit_flag = eventListObj.audit_flag;
				self.m_auditEventsList.upd_audit_elements.push(updAuditElementsObj);
			}
		}
		requestJSONStr = '{"AUDIT_LIST_REQ":' + MP_Util.enhancedStringify(self.m_auditEventsList, 0, 0, 1, ["audit_value"]) + '}';

		cclParam.push("^MINE^", encounterId + ".0");
		scriptRequest.setParameterArray(cclParam);
		scriptRequest.setProgramName("MP_ADD_UPD_AUDIT_EVENTS");
		scriptRequest.setAsyncIndicator(false);
		scriptRequest.setDataBlob(requestJSONStr);
		scriptRequest.setResponseHandler(function (scriptReply) {
			if (scriptReply.getStatus() === "S") {
				self.getResponseHandler()();
			}
		});
		scriptRequest.performRequest();
	} catch(error) {
		MP_Util.LogJSError(error, null, "gap-check.js", "addUpdateAuditEventsList");
		if (timerAddUpdAuditEvents) {
			timerAddUpdAuditEvents.Abort();
			timerAddUpdAuditEvents = null;
		}
		throw error;
	}
	finally {
		if (timerAddUpdAuditEvents) {
			timerAddUpdAuditEvents.Stop();
		}
	}
};

/**
 * Creates a Map Object using key\value pair
 * @param {string} name unique identifier
 * @param {value} object contains audit element information
 * @return {undefined} This function does not return a value
 */
GapCheck.prototype.MapObject = function (name, value) {
	this.name = name;
	this.value = value;
};

/**
 * Retrieves the saved override reasons details from the service
 * @param {Object} criterion object
 * @param {int} encntrTypeFlag Determines whether the encounter type information needs to be retrieved from back end or not
 * @return {undefined} This function does not return a value
 */
GapCheck.prototype.getAuditEventsList = function (criterion,encntrTypeFlag) {
	try {
		var encounterId = criterion.encntr_id;
		var cclParam = [];
		var self = this;
		var scriptRequest = new ScriptRequest();
		var x = 0;
		var timerGetAuditEvents = MP_Util.CreateTimer("ENG:MPG.GAP-CHECK-RETRIEVE AUDIT EVENTS DETAILS");
		cclParam.push("^MINE^", encounterId + ".0",encntrTypeFlag);
		scriptRequest.setParameterArray(cclParam);
		scriptRequest.setProgramName("MP_RETRIEVE_AUDIT_EVENTS");
		scriptRequest.setAsyncIndicator(false);
		scriptRequest.setResponseHandler(function (scriptReply) {
			if (scriptReply.getStatus() === "S" || scriptReply.getStatus() === "Z") {
				var auditDetailsReply = scriptReply.getResponse();
				var encounterReply = auditDetailsReply.ENCNTR_LIST;
				var encounterCount = encounterReply.length;
				if(encntrTypeFlag){
					self.setEncounterType(auditDetailsReply.ENCNTR_TYPE);
				}
				self.m_currentAuditEventsList = [];
				if (encounterCount) {
					var auditEventsReply = encounterReply[0].AUDIT_EVENTS;
					var auditEventsCount = auditEventsReply.length;
					if (auditEventsCount) {
						for (x = 0; x < auditEventsCount; x++) {
							var auditElementsReply = auditEventsReply[x].AUDIT_ELEMENTS;
							var auditElementsCount = auditElementsReply.length;
							var auditElemIndex = 0;
							for (auditElemIndex = 0; auditElemIndex < auditElementsCount; auditElemIndex++) {
								var auditElementObj = new self.AuditEventElementsJSON();
								auditElementObj.tracking_audit_element_id = auditElementsReply[auditElemIndex].TRACKING_AUDIT_ELEMENT_ID;
								auditElementObj.audit_element_name = auditElementsReply[auditElemIndex].AUDIT_ELEMENT_NAME;
								auditElementObj.audit_element_txt = auditElementsReply[auditElemIndex].AUDIT_ELEMENT_TXT;
								auditElementObj.audit_value = auditElementsReply[auditElemIndex].AUDIT_VALUE_DOUBLE;
								auditElementObj.audit_string = auditElementsReply[auditElemIndex].AUDIT_STRING;
								auditElementObj.audit_flag = auditElementsReply[auditElemIndex].AUDIT_FLAG;
								auditElementObj.update_flag = 1;
								var mapObj = new self.MapObject(auditElementObj.audit_element_name, auditElementObj);
								self.m_currentAuditEventsList.push(mapObj);
							}
						}
					}
				}

			}
		});
		scriptRequest.performRequest();
	}catch(error) {
		MP_Util.LogJSError(error, null, "gap-check.js", "getAuditEventsList");
		if (timerGetAuditEvents) {
			timerGetAuditEvents.Abort();
			timerGetAuditEvents = null;
		}
		throw error;
	}
	finally {
		if (timerGetAuditEvents) {
			timerGetAuditEvents.Stop();
		}
	}
};

/**
 * This function sets the override reason based on the value selected in the combo box. 
 * @param {string} comboBoxId override reasons combobox id 
 * @return {undefined}  This function does not return a value
 */
GapCheck.prototype.handleComboboxSelection = function(comboBoxId) {
	var categoryMean = this.m_catergoryMean;
	var overrideDivObj = $("#overrideContainer"+categoryMean);
	var comboId = "#" + comboBoxId;
	var self = this;
	
	var selectedValue = $(comboId).val();
	//remove the blank option and mandatory class , if the override reason is already set.
	if (selectedValue !== "-1") {
		$(comboId + " option[value='-1']").remove();
		$(comboId).removeClass("gc-none-option");
		var unselectedOverrideObj = overrideDivObj.find('.gc-none-option');
		if (!unselectedOverrideObj.length) {
			var saveModal = MP_ModalDialog.retrieveModalDialogObject("GapCheckDialog"+categoryMean);
			if (saveModal) {
				saveModal.setFooterButtonDither("saveOverrideModal"+categoryMean, false);
			}
		}
	}
};

/**
 * Stores all the component Information which are marked as required
 * @param {Array} compArr contains an array of components
 * @return {Array}componentsArr This function returns array of required components
 */
GapCheck.prototype.gatherComponentsToBeOverridden = function(compArr){
	var componentsCnt = compArr.length;
	var componentsArr = [];
	var component = null;
	var x;
	for (x = componentsCnt; x--; ) {
		component = compArr[x];
		if (component.getGapCheckRequiredInd() && !component.getSatisfiedInd()) {
			if (component.getOverrideInd()) {
				componentsArr.push(component);
			}
		}
	}
	return componentsArr;
};

/**
 * This function adds the change Listener function to the combo box
 * @param {Array} overrideComps Array of components
 * @return {undefined}  This function does not return a value
 */
GapCheck.prototype.attachListener = function(overrideComps){
	var overrideCompLength = overrideComps.length;
	var self = this;
	var x;
	for (x = 0; x < overrideCompLength; x++) {
		var currComp = overrideComps[x];
		var currCompId = currComp.getComponentId();
		var comboboxObj = $("#overrideReason" + currCompId);
		var comboboxChangeHandler = function () {
			var comboboxId = $(this).attr("id");
			self.handleComboboxSelection(comboboxId);
		};
		comboboxObj.change(comboboxChangeHandler);
		comboboxObj.change();
	}
};

/**
 * This function creates the override reason combo box html based on the values returned from the code set 20318.
 * @param {float} compId : contains component Id.  
 * @param {Array} overrideReasonArr :  holds the override reason information returned from the code set 20318. 
 * @param {string} selectedValue : holds the information of the previously stored override reason value for specific component.
 * @return {undefined}  This function does not return a value
 */
GapCheck.prototype.createOverrideReasonCombo = function(compId, overrideReasonArr, selectedValue) {
	var overRideReasonsCount = overrideReasonArr.length;
	var html = [];
	var index;

	html.push("<select id='overrideReason"+ compId +"' data-lookup='"+compId+"' class='gc-select gc-none-option'><option value='-1'></option>");

	for (index = 0; index < overRideReasonsCount; index++) {
		var overrideReasonObj = overrideReasonArr[index];
		var optionName = overrideReasonObj.name;
		var selectedInfo = (selectedValue === optionName) ? "selected=selected" : "";
		html.push("<option value='" + optionName + "' " + selectedInfo + ">" + overrideReasonObj.value.display + "</option>");
	}
	html.push("</select>");
	return html.join("");
};

/**
 * This function updates the m_currentAuditEventsList with the latest override reason value,selected in the combo box.
 * @return {undefined}  This function does not return a value
 */
GapCheck.prototype.updateAuditEventDetails = function(){
	var auditEventsList = this.m_currentAuditEventsList;
	var auditEventsCount = auditEventsList.length;
	var index = 0;
	var compId = "";
	for(index = 0;index < auditEventsCount ;index++){
		compId = auditEventsList[index].value.component_Id;
		this.m_currentAuditEventsList[index].value.audit_value = $("#overrideReason" + compId).val();
	}
};

/**
 * This function checks for the components that are not satisfied and provides a provision add the
 * override reason for the components with override Indicator set.
 * @param {Array} componentsList : Holds the array of components added to a particular view. 
 * @param {int} encntrTypeFlag Determines whether the encounter type information needs to be retrieved from back end or not
 * @param {criterion} criterion : Contains information such  as the person, encounter, personnel, etc.
 * @return {undefined}  This function does not return a value.
 */
GapCheck.prototype.InitiateGapCheck = function (componentsList, criterion,encntrTypeFlag) {
	var overrideComponents = [];
	var x = 0;
	var i = 0;
	var saveModal = null;
	var saveModalBtn = null;
	var cancelModalBtn = null;
	var dialogBodyHtml = [];
	var overrideCompLength = 0;
	var self = this;
	var gapChecki18n = i18n.discernabu.gap_check;
	var catergoryMean = criterion.category_mean;
	self.m_catergoryMean = catergoryMean;
	
	//Gather all the required Components
	overrideComponents = self.gatherComponentsToBeOverridden(componentsList);
	overrideCompLength = overrideComponents.length;
	if (overrideCompLength > 0) {
		//Order the components by the comp_seq so we know before they are rendered what order they will be in
		overrideComponents.sort(function(a, b) {
			var aSeq = a.getSequence();
			var bSeq = b.getSequence();
			if (aSeq < bSeq) {
				return -1;
			}
			//No two sequences will be the same so we already know bSeq > aSeq at this point.
			return 1;
		});
		//Create initial dialog box
		var overRideReasons = MP_Util.GetCodeSet(20318, false);
		self.getAuditEventsList(criterion,encntrTypeFlag);
		saveModal = MP_ModalDialog.retrieveModalDialogObject("GapCheckDialog"+catergoryMean);
		if (saveModal) {
			saveModal.setFooterButtonDither("saveOverrideModal"+catergoryMean, true);
		}
		if (!saveModal) {
			saveModal = new ModalDialog("GapCheckDialog"+catergoryMean).setLeftMarginPercentage(35).setTopMarginPercentage(20).setRightMarginPercentage(35).
				setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);
			saveModal.setShowCloseIcon(true);

			//Create the modal save button
			saveModalBtn = new ModalButton("saveOverrideModal"+catergoryMean);
			saveModalBtn.setFocusInd(true).setCloseOnClick(true).setText(gapChecki18n.SUBMIT);
			saveModalBtn.setIsDithered(true);
			saveModalBtn.setOnClickFunction(function () {
				//update m_currentAuditEventsList with latest values selected
				self.updateAuditEventDetails();
				//save the Override reasons information
				self.addUpdateAuditEventsList(criterion);
			});
			saveModal.addFooterButton(saveModalBtn);

			//Create the modal cancel button
			cancelModalBtn = new ModalButton("cancelModal"+catergoryMean);
			cancelModalBtn.setText(gapChecki18n.CANCEL);
			saveModal.addFooterButton(cancelModalBtn);
		}

		saveModal.setBodyDataFunction(function (modalObj) {
			dialogBodyHtml = [];
			var encounterType = self.getEncounterType();
			var dialogHeader = gapChecki18n.DISCHARGE_HEADER;
			if(encounterType === 2){
				dialogHeader = gapChecki18n.AMBULATORY_HEADER;
			}
			saveModal.setHeaderTitle(dialogHeader);
			dialogBodyHtml.push("<div class='gc-override-container'><div class='gc-override-note'>"+gapChecki18n.TITLE+"</div><div class='gc-override-subtitle'>"+gapChecki18n.SUB_TITLE+"</div><div class='gc-override-content' id='overrideContainer"+catergoryMean+"'>");
			var currAuditEventList = self.m_currentAuditEventsList;
			for (i = 0; i < overrideCompLength; i++) {
				var currComp = overrideComponents[i];
				var currCompId = currComp.getComponentId();
				var currCompReportMean = currComp.getReportMean();
				var found = false;
				var selectedValue = "";
				for (x = 0; x < currAuditEventList.length; x++) {
					if (currAuditEventList[x].name === currCompReportMean) {
						found = true;
						selectedValue = currAuditEventList[x].value.audit_value;
						self.m_currentAuditEventsList[x].value.component_Id = currCompId;
						self.m_currentAuditEventsList[x].value.update_flag = 1;
						break;
					}
				}
				if (!found) {
					var auditElementObj = new self.AuditEventElementsJSON();
					auditElementObj.audit_element_name = currCompReportMean;
					auditElementObj.component_Id = currCompId;
					auditElementObj.update_flag = 0;
					var mapObj = new self.MapObject(currCompReportMean, auditElementObj);
					self.m_currentAuditEventsList.push(mapObj);
				}
				dialogBodyHtml.push("<dl class='gc-override-comp'><dt id='overrideCompInfo-" + currCompId + "'><span class='gc-required-field-label'>*</span>"+ currComp.getLabel() + "</dt>");
				dialogBodyHtml.push("<dd>" + self.createOverrideReasonCombo(currCompId, overRideReasons, selectedValue) + "</dd></dl>");
			}
			dialogBodyHtml.push("</div>");
			modalObj.setBodyHTML(dialogBodyHtml.join(""));
		});
		//Create/launch Modal Dialog Box
		MP_ModalDialog.updateModalDialogObject(saveModal);
		MP_ModalDialog.showModalDialog("GapCheckDialog"+catergoryMean);
		self.attachListener(overrideComponents);
	}else{
		self.getResponseHandler()();
	}
};
(function($) {
	/**
	 * A HealthPlanEligibilityInfo caches information about retrived eligibility information in an
	 * elibilityMap field
	 */
	HealthPlanEligibilityInfo = function(){
		this.eligibilityMap = {};
	};

	/**
	 * retrieveEligibilityInfo retrieves the eligibility information of list of orderables (based on cki) based on the
	 * based health plan (by formulary uid)
	 * @param  {Float}   uid       the uid of the health plan to retrieve eligibility information for
	 * @param  {Array}   ckiList  list of CKI fields to retrieve eligibility information for
	 * @param  {Function} callback callback (that takes a map of cki to elibility information) to call after
	 *                             elibility information is retrieved
	 */
	HealthPlanEligibilityInfo.prototype.retrieveEligibilityInfo = function(uid, ckiList, callback){
		var self = this;
		var eligibilityMap = this.eligibilityMap;
		var ckiMap = eligibilityMap[uid];
		if (!ckiMap){
			ckiMap = {};
			eligibilityMap[uid] = ckiMap;
		}
		var unretrievedCkiList = [];
		var ckiListCnt = ckiList.length;
		var curCki;
		for (var i = 0; i < ckiListCnt; i++){
			curCki = ckiList[i];
			if(!ckiMap[curCki]){
				unretrievedCkiList.push("^" + curCki + "^");
			}
		}
		var unretrievedLength = unretrievedCkiList.length;
		if (unretrievedLength){
			var ckiListParam = MP_Util.CreateParamArray(unretrievedCkiList, 2);
			var eligibilityRequest = new ScriptRequest();
			eligibilityRequest.setProgramName('mp_formulary_display_json');
			eligibilityRequest.setParameterArray(["^MINE^", "^" + uid + "^", ckiListParam]);
			eligibilityRequest.setResponseHandler(function(scriptReply){
				self.populateEligibilityMap(scriptReply, ckiMap);
				var selectedCkiMap = self.eligibilityMap[uid] || {};
				callback(selectedCkiMap);
			});
			eligibilityRequest.performRequest();
		}
		else{
			var selectedCkiMap = self.eligibilityMap[uid] || {};
			callback(selectedCkiMap);
		}
	};

	/**
	 * populateEligibilityMap updates the eligibilityMap based on the details retrieved from mp_formulary_display_json
	 * @param  {ScriptReply} reply  ScriptReply from mp_formulary_display_json
	 * @param  {Object}      ckiMap ckiMap to be updated
	 */
	HealthPlanEligibilityInfo.prototype.populateEligibilityMap = function(reply, ckiMap){
		var status = reply.getStatus();
		var response = null;
		var formularyInformation = null;
		if (status === "S"){
			response = reply.getResponse();
			formularyInformation = response.FORMULARY_DISPLAY_INFORMATION;
			var formularyLength = formularyInformation.length;
			var ckiDetails;
			var cki;
			for (var i = 0; i < formularyLength; i++){
				ckiDetails = formularyInformation[i];
				cki = ckiDetails.CKI;
				var mappedEligibilityInfo = {};
				mappedEligibilityInfo.ANNOTATED_TEXT = ckiDetails.FORMULARY_DISPLAY.ANNOTATION_TEXT;
				mappedEligibilityInfo.BENEFIT_RATING = ckiDetails.FORMULARY_DISPLAY.BENEFIT_RATING;
				mappedEligibilityInfo.FORMATTED_DETAILS = ckiDetails.FORMATTED_FORMULARY_DETAILS;
				ckiMap[cki] = mappedEligibilityInfo;
			}
		}
	};

	HealthPlanEligibilityInfo.ELIGIBILITY_STYLING = {
			"preferred" : "health-plan-preferred",
			"poor": "health-plan-poor",
			"neutral": "health-plan-neutral"
	};

	/**
	 * Generate html for a formulary icon based on the given paramaters
	 * @param  {HTMLElement} element    HTML element in which to render the icon
	 * @param  {String} rating          The benefit rating for the eligibility icon
	 * @param  {String} shortDisplay    The annotated display for the eligibility icon (face up)
	 * @param  {String} longDescription The formatted formulary description for eligibility icon (hover)
	 */
	HealthPlanEligibilityInfo.generateIconHtml = function(element, rating, shortDisplay, longDescription){
		var self = this;
		var formularyStyling = HealthPlanEligibilityInfo.ELIGIBILITY_STYLING[rating] || 'health-plan-unknown';
		var elementHtml = "<div class='eligibility-info " + formularyStyling + "'>" +
								"<div class='health-plan-circle'></div>" +
								shortDisplay +
						   "</div>";
		var displayDetails = function(event){
			HealthPlanEligibilityInfo.generateHover(event, element, longDescription);
		};
		var eligibilityIcon = $(elementHtml);
		if (element){
			$(element).html(eligibilityIcon);
			//Only display tooltip if a formatted display description is present
			if(longDescription){
				eligibilityIcon.on("mouseenter", displayDetails);
			}
		}
	};

	/**
	 * Generate a hover for the eligibility icon to display formatted details
	 * @param  {Event} event            Event fired on hover
	 * @param  {HTML Element} element   Element to attatch tooltip to
	 * @param  {String} formattedDetails Details to display in tooltip
	 */
	HealthPlanEligibilityInfo.generateHover = function(event, element, formattedDetails){
		var curElement = $(element);
		var tooltip = new MPageTooltip().setShowDelay(0);
		var tipContent = "<pre class='eligibility-info-hover'>" + formattedDetails + "</pre>";
		tooltip.setX(event.pageX).setY(event.pageY).setAnchor(element).setContent(tipContent);
		tooltip.getContent().css('z-index', 3000);
		tooltip.show();
	};
	/**
	 * Generate Static SharedPlanEligibiltiyInfo to handl eall eligibility request and
	 * cache retrieved eligibility information
	 * @type {HealthPlanEligibilityInfo} Returns instance of HealthPlanEligibilityInfo object
	 */
	SharedPlanEligibilityInfo = new HealthPlanEligibilityInfo();


})(jQuery);
/**
 * ipass-actions.js
 * @author Swati Kode
 *
 * IPASS Actions class
 * ========================================================================================================================================
 *
 * Creates a IPASS Actions control in the HTML content element sent by a consumer. This control has a text area where a new action
 * can be entered.
 * A list of active and completed actions are displayed below the text area. Active actions can be completed by checking a check box
 * next to it.
 * If no actions exists then a message is displayed. Error handling is done if there was an error saving/completing/deleting an
 * action
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new IPASS action object
 * @name IPASSActions
 */
IPASSActions = function() {
	this.m_uniqueId = null;
	this.m_criterion = null;
	this.m_iPassActionsRef = null;
	this.m_personId = 0;
	this.m_selectedCareTeamId = 0;
	
	// Flag indicating whether the selected service is set with a preference of across encounters or not
	this.m_crossEncInd = 0;
	
	// Variable to indicate the lookback value
	this.m_lookbackVal = 0;
};

// ------------------------------------------------------------------------
//  Getters and Setters
// ------------------------------------------------------------------------

/**
 * Returns a unique ID for the actions control
 */
IPASSActions.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets a unique ID for the actions control
 * @param {string | number} uniqueId The unique id for the actions control
 * @returns {IPASSActions} returns the IPASS Actions object to allow chaining
 */
IPASSActions.prototype.setUniqueId = function(uniqueId) {
	//Validate uniqueId, throw an error if not valid
	if (!uniqueId || ( typeof uniqueId !== "string" && typeof uniqueId !== "number")) {
		throw new Error("Error setting unique ID. Parameter Unique Id must either be a number or a string for the actions control.");
	}
	this.m_uniqueId = uniqueId;
	return this;
};

/**
 * Returns a criterion of the calling component
 */
IPASSActions.prototype.getCriterion = function() {
	return this.m_criterion;
};

/**
 * Sets a criterion for the calling component
 * @param {object} criterion The criterion of the calling component
 * @returns {IPASSActions} returns the care team selector object to allow chaining
 */
IPASSActions.prototype.setCriterion = function(criterion) {
	//Validate uniqueId, throw an error if not valid
	if (!criterion) {
		throw new Error("Error setting criterion. Parameter criterion must be specified.");
	}
	this.m_criterion = criterion;

	// Retrieve the person ID from the criterion, few consumers can have members defined either in upper or lower case
	if (this.m_criterion.person_id) {
		this.m_personId = this.m_criterion.person_id;
	}
	else if (this.m_criterion.PERSON_ID) {
		this.m_personId = this.m_criterion.PERSON_ID;
	}
	return this;
};

/**
 * Returns the care team ID of the currently selected care team in the selector
 */
IPASSActions.prototype.getSelectedCareTeamId = function() {
	return this.m_selectedCareTeamId;
};

/**
 * Sets the care team ID of the currently selected care team in the selector
 * @param {string} careTeamId The ID of the currently selected care team
 */
IPASSActions.prototype.setSelectedCareTeamId = function(careTeamId) {
	this.m_selectedCareTeamId = careTeamId;
};

/**
 * @return {integer} Value for the cross encounter preference of the Medical Service
 */
IPASSActions.prototype.getCrossEncIndicatorVal = function() {
	return this.m_crossEncInd;
};

/**
 * Sets the value for the cross encounter preference of the Medical Service into a variable
 * @param {integer} crossEncInd Flag value indicating if the Medical Service is across encounters or not
 */
IPASSActions.prototype.setCrossEncIndicatorVal = function(crossEncInd) {
	this.m_crossEncInd = crossEncInd;
};

/**
 * Returns the lookback value
 */
IPASSActions.prototype.getLookbackVal = function() {
	return this.m_lookbackVal;
};

/**
 *	Sets the lookback value. This can be used for instance to disable the global indicator when the active pregnancy record is present
 *  @param {integer} lkbkVal lookback value for a patient
 */
IPASSActions.prototype.setLookbackVal = function(lkbkVal) {
	this.m_lookbackVal = lkbkVal;
};

/**
 * This function is used to retrieve the name of the category-mean/viewpoint key that the ipass utility is being shown in.
 * A default string will be returned if the category mean or viewpoint key is not retrieved
 * @param {none}
 * @returns {string}  Sub-timer name that is used in creating timer
 */
IPASSActions.prototype.getSubTimerName = function() {
	// If the component is at the Mpage level then get the category_mean
	if (this.m_criterion.category_mean) {
		return this.m_criterion.category_mean;
	}

	// If the component is at the viewpoint level then get the viewpoint key
	if (this.viewpointNameKey) {
		return this.viewpointNameKey;
	}
	// If viewpointNameKey does not exists then parse the viewpoint JSON
	try {
		this.viewpointNameKey = JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME_KEY;
		return this.viewpointNameKey;
	}
	catch (error) {
		MP_Util.LogJSError(error, null, "ipass-actions.js", "getSubTimerName");
		return "IPASS Actions Artifact";
	}
};

/**
 * Function name: renderActions
 * This method will render an Actions control. The control will have a textbox, and a list of active actions below the text area.
 * If there are no actions then a message is displayed below the text area. A link "Show Completed" will display all the completed
 * actions.
 * @param {object} response A response RECORD_DATA from mp_retrieve_ipass script
 * @param {object} actionsTarget The HTML element which be holding the actions control
 */
IPASSActions.prototype.renderActions = function(recordData, actionsTarget) {
	var activeHTML = [];
	var activeCnt = 0;
	var doneHTML = [];
	var doneCnt = 0;
	var parentEntityId = 0.0;
	var activeActions = null;
	var completedActions = null;
	var action = null;
	var actionCnt = 0;
	var activeActionCnt = 0;
	var actionId = 0.0;
	var actionUpdCnt = 0;
	var actionText = "";
	var uniqueId = this.m_uniqueId;
	var x = 0;
	var timerActionsRender = null;
	var provider = null;
	var actionAuthor = "";
	var critInfo = this.getCriterion();
	var personnelId = critInfo.provider_id;
	var editableClass = "";
	var actionCreateDtTm = "";
	var actionUpdateDtTm = "";
	var origProvider = null;
	var origActionAuthor = "";
	var origActionUpdateDtTm = "";
	var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	var dateFormatter = mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR;
	var response = recordData;
	var actionGblInd = 0;
	var self = this;
	try {
		// Render timer
		timerActionsRender = MP_Util.CreateTimer("ENG:MPG.IPASS-ACTIONS.O1 - render component", this.getSubTimerName());
		//Grab the action results and other information
		if (response) {
			// Retrieve provider information
			this.personnelArray = MP_Util.LoadPersonelListJSON(recordData.PRSNL);

			activeActions = response.ACTIVE_ACTIONS;
			completedActions = response.COMPLETED_ACTIONS;
			actionCnt = completedActions.length;
			parentEntityId = response.SELECTED_ENCOUNTER_ID;
			activeActionCnt = activeActions.length;
		}
		//Create the HTML for each of the action items
		for ( x = 0; x < actionCnt; x++) {
			actionGblInd = 0;
			action = completedActions[x];
			actionId = action.PCT_IPASS_ID;			
			actionText = unescape(action.TEXT).replace(/\s+$/,"");
			//below double space regex pattern replaces carriage return and spaces with their HTML equivalents
			actionText = actionText.replace(/ {2}/g, "&nbsp;&nbsp;");
			actionText = actionText.replace(/[\n]/g,"<br\/>");
			actionUpdCnt = action.UPDT_CNT;
			actionGblInd = action.GLOBAL_IND;

			//get updated by author and author date/time
			provider = MP_Util.GetValueFromArray(action.UPDT_BY_ID, this.personnelArray);
			actionAuthor = $.trim(provider.fullName);
			actionUpdateDtTm = df.formatISO8601(action.UPDT_DATE, dateFormatter);

			//get updated by author and author date/time
			origProvider = MP_Util.GetValueFromArray(action.ORIG_UPDT_BY_ID, this.personnelArray);
			origActionAuthor = $.trim(origProvider.fullName);
			origActionUpdateDtTm = df.formatISO8601(action.ORIG_BEGIN_DATE, dateFormatter);

			//Keep track of the completed actions
			doneCnt++;
			//This action item is marked as complete so show them as striken
			doneHTML.push("<dd class='ipass-actions-txt ipass-actions-done-txt-color' id='action" + actionId + uniqueId + "' data-enc-id='" + parentEntityId + "' data-action-id='" + actionId + "' data-upd-cnt='" + actionUpdCnt +
			"' data-action-gbl-ind-val='"+ actionGblInd + "'><span class='ipass-actions-itm'><span class = 'ipass-actions-chk'><input type='checkbox' checked='checked'></input></span><span class='ipass-actions-data ipass-actions-strike'> " + actionText + "</span></span>");
			doneHTML.push("<span class='ipass-actions-edit'>&nbsp;</span><span class='ipass-actions-del ipass-actions-active-item'><span class='hidden'>&nbsp;</span></span>");
			doneHTML.push("<span class='ipass-actions-author-container'><span class='ipass-actions-author-timestamp' data-ipass-actions-orig-auth-id='" + action.ORIG_UPDT_BY_ID + "' data-ipass-actions-orig-author-dt-tm='" + origActionAuthor + " " + origActionUpdateDtTm + "'>" + actionAuthor + " " + actionUpdateDtTm + "</span></span></dd>");
		}
		for ( x = 0; x < activeActionCnt; x++) {
			actionGblInd = 0;
			action = activeActions[x];
			actionId = action.PCT_IPASS_ID;
			actionText = unescape(action.TEXT).replace(/\s+$/,"");
			// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
			actionText = actionText.replace(/ {2}/g, "&nbsp;&nbsp;");
			actionText = actionText.replace(/[\n]/g,"<br/>");
			actionUpdCnt = action.UPDT_CNT;
			provider = MP_Util.GetValueFromArray(action.ORIG_UPDT_BY_ID, this.personnelArray);
			actionAuthor = $.trim(provider.fullName);
			actionCreateDtTm = df.formatISO8601(action.ORIG_BEGIN_DATE, dateFormatter);
			actionGblInd = action.GLOBAL_IND;

			//find out if current personnel matches author, if so add editable class
			if (action.ORIG_UPDT_BY_ID === personnelId) {
				editableClass = "ipass-actions-edit-active";
			}
			else {
				editableClass = "";
			}
			//Keep track of the active actions
			activeCnt++;
			//This action item is still active
			activeHTML.push("<dd class='ipass-actions-txt ipass-actions-active-txt-color' id='action" + actionId + uniqueId + "'  data-enc-id='" + parentEntityId + "' data-action-id='" + actionId + "' data-upd-cnt='" + actionUpdCnt + "' data-action-gbl-ind-val='"+ actionGblInd + "'><span class='ipass-actions-itm'><span class = 'ipass-actions-chk'><input type='checkbox' /></span><span class= 'ipass-actions-data'>" + actionText + "</span></span>");
			activeHTML.push("<span class='ipass-actions-edit " + editableClass + "'>&nbsp;</span><span class='ipass-actions-del ipass-actions-done-item'><span class='hidden'>&nbsp;</span></span>");
			activeHTML.push("<span class='ipass-actions-author-container'><span class='ipass-actions-author-timestamp' data-ipass-actions-orig-auth-id='" + action.ORIG_UPDT_BY_ID + "'>" + actionAuthor + " " + actionCreateDtTm + "</span></span></dd>");
		}

		var iPassI18N = CERN_IPASS_ACTIONS_O1.iPassI18N;
		var actionsI18N = CERN_IPASS_ACTIONS_O1.actionsI18N;

		//Create the actions html via string concatenation
		var actionsHtml = "";

		// Add a div for showing an error message if there is any failure adding/completing/deleting an action
		actionsHtml += "<div id='ipass-action-err" + uniqueId + "' class='ipass-pad ipass-action-err-msg hidden'></div>";

		actionsHtml += "<div id='ipassActionsWrapper" + uniqueId + "'>";
		actionsHtml += "<div class='ipass-actions-div' data-enc-id='" + parentEntityId + "'>";
		actionsHtml += "<textarea id='iPassActionsTextBox" + uniqueId + "' class='ipass-actions-new' maxlength='255' rows='5' value='" + actionsI18N.ADD_NEW_ACTION + "'>" + actionsI18N.ADD_NEW_ACTION + "</textarea>";
		actionsHtml += "<div id='iPassActionsID" + uniqueId + "' class='ipass-actions-savcan hidden'>";
		actionsHtml += "<span class='ipass-actions-field-max'></span>";
		actionsHtml += this.appendGlobalIndicatorElemt(false, 0);
		actionsHtml += "<span class='ipass-actions-save' data-enc-id='" + parentEntityId + "'>";
		actionsHtml += "<input class='ipass-actions-savebutton' type='button' disabled value='" + iPassI18N.SAVE + "'>";
		actionsHtml += "</span>";
		actionsHtml += "<span class='ipass-actions-savecancel'>";
		actionsHtml += "<input class='ipass-actions-cansavebutton' type='button' name='actioncancel' value='" + iPassI18N.CANCEL + "'>";
		actionsHtml += "</span>";
		actionsHtml += "</div>";
		actionsHtml += "</div>";
		actionsHtml += "<div id='ipassActiNoDataId" + uniqueId + "' class='ipass-actions-nodata " + ((activeCnt || doneCnt) ? "hidden" : "") + "'>" + actionsI18N.NO_ACTIONS_DOCUMENTED + "</div>";
		actionsHtml += "<div id='ipassActiNoActiveDataId" + uniqueId + "' class='ipass-actions-nodata " + ((activeCnt || (activeCnt === 0 && doneCnt === 0)) ? "hidden" : "") + "'>" + actionsI18N.NO_ACTIVE_ACTIONS_DOCUMENTED + "</div>";
		actionsHtml += "<div id='iPassActionsList" + uniqueId + "' class='ipass-actions-itms-div'>";

		//List of active
		actionsHtml += "<dl id='iPassActionsActiveItems" + uniqueId + "' class='ipass-actions-current' data-enc-id=" + parentEntityId + "'>" + activeHTML.join("") + "</dl>";

		//List of completed or 'done' actions
		actionsHtml += "<dl id='iPassActionsDoneItems" + uniqueId + "' class='ipass-actions-done'>" + doneHTML.join("") + "</dl>";

		actionsHtml += "</div>";

		//Show Completed options
		actionsHtml += "<div id='iPassActionsShowCompleted" + uniqueId + "' class='ipass-actions-done-hd " + ((doneCnt) ? "" : "hidden") + "'>";
		actionsHtml += "<span class='ipass-actions-done-hd-txt'>" + actionsI18N.COMPLETED + "</span>";
		actionsHtml += "<span id='iPassActionsDoneCnt" + uniqueId + "' class='ipass-actions-done-cnt'> (" + doneCnt + ") </span>";
		actionsHtml += "</div>";
		actionsHtml += "<div id='iPassActionsShowAll" + uniqueId + "' class='ipass-actions-show-all ipass-actions-done-hd'>";
		actionsHtml += "<a>" + iPassI18N.ALL_TEAMS + "</a>";
		actionsHtml += "</div>";

		//Generate the complete content
		actionsTarget.append(actionsHtml);

		
		$("#iPassActionsShowAll" + uniqueId).on("click", function() {
		self.launchShowAllActionsModal();
		});
		
	}
	catch(error) {
		MP_Util.LogJSError(error, null, "ipass-actions.js", "renderActions");
		if (timerActionsRender) {
			timerActionsRender.Abort();
			timerActionsRender = null;
		}
		throw error;
	}
	finally {
		if (timerActionsRender) {
			timerActionsRender.Stop();
		}
	}

};

/**
 * This function will launch a modal dialog that shows all actions for a patient across all care teams
 */
IPASSActions.prototype.launchShowAllActionsModal = function() {
	
	//Internationalization variables
	
	var ipassI18N = i18n.discernabu.ipass;
	var ipassActionsI18N = i18n.discernabu.ipass_actions;
	var marginValue = 15;
	var self = this;
	var criterion = this.getCriterion();
	var encounterId = criterion.encntr_id;
	var personId = criterion.person_id;
	var uniqueId = self.getUniqueId();
	var logicalDomainId = criterion.logical_domain_id;
	var personnelId = criterion.provider_id;
	
	//If the modal has already been created, just show it.
	var ipassActionsModalDialog = MP_ModalDialog.retrieveModalDialogObject("ipassActionsShowAll" + uniqueId);
	if (ipassActionsModalDialog) {
		ipassActionsModalDialog.displayActionsDialog = (self.getCrossEncIndicatorVal() ===1)? true:false;
		MP_ModalDialog.showModalDialog(ipassActionsModalDialog.getId());
		$("#ipassActionsModalHeader").addClass("ipass-Actions-Modal-Header");
		return;
	}
	//Create the show all modal
	var showAllModal = new ModalDialog("ipassActionsShowAll"+uniqueId);
	showAllModal.setHeaderElementId("ipassActionsModalHeader");
	showAllModal.setBodyElementId("ipassActionsModalBody");
	showAllModal.setFooterElementId("ipassActionsModalFooter");
	showAllModal.setTopMarginPercentage(marginValue).setRightMarginPercentage(marginValue).setBottomMarginPercentage(marginValue).setLeftMarginPercentage(marginValue);
	showAllModal.setHeaderTitle(ipassActionsI18N.ACTIONS);
	showAllModal.displayActionsDialog = (self.getCrossEncIndicatorVal() ===1)? true:false;

	var tableBodyPaddingBuffer = 10;
	

	//Helper function to size the body of the table to enable scrolling
	function calculateTableHeight(modalBody, tableHeader) {
		return modalBody.height() - tableHeader.height() - tableBodyPaddingBuffer;
	}

	//Helper function to create table columns
	function createActionsTableColumn(columnId, columnDisplay, sortable, primarySortField, renderTemplate, customClass) {
		return new TableColumn().setColumnId(columnId).setColumnDisplay(columnDisplay).setIsSortable(sortable).setPrimarySortField(primarySortField).setRenderTemplate(renderTemplate).setCustomClass(customClass);
	}

	// Replaces carriage return and spaces with their HTML equivalents
	function convertTextSpacingToHTML(text) {
		return text.replace(/ {2}/g, "&nbsp;&nbsp;").replace(/[\n]/g, "<br/>");
	}

	//Create the component table that will be shown inside the modal
	var allActionsTable = new ComponentTable();
	allActionsTable.setNamespace("ipassAllActions");
	allActionsTable.setCustomClass("ipass-component-table");
	var med_service_col = createActionsTableColumn("SERVICE", ipassI18N.MEDICAL_SERVICE, true, "CARETEAM_DISPLAY", '${ CARETEAM_DISPLAY }', "ipass-actions-sortable-column ipass-actions-service");
	med_service_col.addSecondarySortField("DISP_UPDT_DATE", TableColumn.SORT.DESCENDING);
	allActionsTable.addColumn(med_service_col);
	allActionsTable.addColumn(createActionsTableColumn("ACTION", ipassActionsI18N.ACTION, false, "TEXT", '${ TEXT }', "ipass-actions-action"));
	var author_col = createActionsTableColumn("AUTHOR", ipassI18N.AUTHOR, true, "PERSONNEL_DISPLAY", "${ PERSONNEL_DISPLAY }", "ipass-actions-sortable-column ipass-actions-author");
	author_col.addSecondarySortField("DISP_UPDT_DATE", TableColumn.SORT.DESCENDING);
	allActionsTable.addColumn(author_col);
	allActionsTable.addColumn(createActionsTableColumn("DATE", ipassI18N.DATE, true, "DISP_UPDT_DATE", '${ DATE_DISPLAY }', "ipass-actions-sortable-column ipass-actions-date"));
	allActionsTable.addColumn(createActionsTableColumn("STATUS", ipassI18N.STATUS, true, "STATUS", '${ STATUS }', "ipass-actions-sortable-column ipass-actions-status"));

	//Set the function responsible for rendering the contents of the modal
	showAllModal.setBodyDataFunction(function() {
		//Create arrays to hold each of the unique sets of data
		var dataMap = {
			"ACTIVE": [],
			"COMPLETED": [],
			"ALL": []
		};

		var modalElement = $("#vwpModalDialog" + showAllModal.getId());

		//Add the wf class to the modal root so standard styling will be applied
		modalElement.addClass("wf");

		//Grab the modal body element by id
		var modalBody = $("#" + showAllModal.getBodyElementId());
		//Add the wf class to the body so the component table will correctly inherit all necessary css styling

		var modalHead = $("#" + showAllModal.getHeaderElementId());
		modalHead.addClass("sec-hd");

		//First, we give the modal dialog a spinner to show that it is loading data
		modalBody.html("<div class='ipass-preloader-modal'></div>");

		//Create the filter buttons
		var actionsFilterHtml = "";
		var selectedVisit = "<div class='ipass-actions-selected-visits' id = 'ipassSelectedVisitId'>&nbsp;</div>";
		actionsFilterHtml += "<div class='ipass-actions-filter-container'>";
		actionsFilterHtml += selectedVisit;
		actionsFilterHtml += "<div id='ipassActionsFilterActive"+uniqueId+"' class='lookback-button lookback-button-active' data-set='ACTIVE'>"+ipassActionsI18N.ACTIVE+"</div>";
		actionsFilterHtml += "<div id='ipassActionsFilterComplete"+uniqueId+"' class='lookback-button lookback-button-no-left-border' data-set='COMPLETED'>" + ipassActionsI18N.COMPLETED_LABEL + "</div>";
		actionsFilterHtml += "<div id='ipassActionsFilterAll"+uniqueId+"' class='lookback-button lookback-button-no-left-border' data-set='ALL'>" + ipassActionsI18N.ALL + "</div>";
		actionsFilterHtml += "</div>";

		//Append the filter options to the modal head
		modalHead.append(actionsFilterHtml);

		//Initially, the activeFilterButton is the 'All' filter option
		var activeFilterButton = modalHead.find("#ipassActionsFilterActive"+uniqueId);

		//Create the request to retrieve all actions data
		var cclParams = ["^MINE^", personId + ".0", encounterId + ".0", "0.0", "^ACTION^", 0, "0.0", "-1.0", logicalDomainId + ".0"];
		var programName = "MP_RETRIEVE_IPASS_PERSON";
		var allActionsRequest = new ScriptRequest();
		allActionsRequest.setProgramName(programName);
		allActionsRequest.setParameterArray(cclParams);
		allActionsRequest.setResponseHandler(function (allActionsReply) {
			try {
				var allActionsResponseStatus = allActionsReply.m_status;

				//If there was some error performing the ccl mp_retrieve_ipass_person call
				if (allActionsResponseStatus !== "S" && allActionsResponseStatus !== "Z") {
					throw new Error(i18n.discernabu.ERROR_RETREIVING_DATA);
				}
				//If the modal has been closed since we fired off the request, do nothing
				if (!showAllModal.getIsActive()) {
					return;
				}

				//Utility function to process a list of actions in preparation for rendering
				function processActionList(actionList, actionSet, status) {
					var numberOfActions = actionList.length;
					for (var i = 0; i < numberOfActions; i++) {
						var action = actionList[i];
						action.TEXT = convertTextSpacingToHTML(unescape(action.TEXT));
						action.STATUS = status;
						var dateTimeString = "--";
						var author = (status === "Active") ? action.ORIG_UPDT_BY_ID : action.UPDT_BY_ID;
						action.DISP_UPDT_DATE = (status === "Active") ? action.ORIG_BEGIN_DATE : action.UPDT_DATE;
						if (action.DISP_UPDT_DATE) {
							var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
							dateTimeString = df.formatISO8601(action.DISP_UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
						}
						action.DATE_DISPLAY = dateTimeString;
						var actionPersonnel = personnelMapping[author];
						action.PERSONNEL_DISPLAY = (actionPersonnel) ? actionPersonnel.PROVIDER_NAME.NAME_FULL : "";
						//If a care team is associated to the result, display that information, otherwise it belongs to patient lists
						var actionCareTeam = careTeamMapping[action.PCT_CARE_TEAM_ID];
						if (actionCareTeam) {
							action.CARETEAM_DISPLAY = careTeamMapping[action.PCT_CARE_TEAM_ID].CTEAM_DETAILS.DISPLAY_NAME_HTML;
						}
						else {
							action.CARETEAM_DISPLAY = ipassI18N.PATIENT_LISTS;
						}
						actionSet.push(action);
					}
				}


				var allActionsResponse = allActionsReply.m_responseData;

				//Grab the list of personnel from the response and map them by IDs so we can easily access them
				var personnelList = allActionsResponse.PRSNL;
				var numberOfPersonnel = personnelList.length;
				var careTeamList = allActionsResponse.CARE_TEAMS;
				var numberOfCareTeams = careTeamList.length;
				var personnelMapping = {};
				var careTeamMapping = {};

				//Create a mapping of personnel ids to the personnel object
				for (var pIndex = 0; pIndex < numberOfPersonnel; pIndex++) {
					personnelMapping[personnelList[pIndex].ID] = personnelList[pIndex];
				}
				//Create a mapping of careteam ids to the careteam object
				for (var cIndex = 0; cIndex < numberOfCareTeams; cIndex++) {
					careTeamMapping[careTeamList[cIndex].ID] = careTeamList[cIndex];
				}
				
				//Display Slected Visit for the Medical Service having Data Retrival pref from Care Team Build Tool
				if (showAllModal.displayActionsDialog && allActionsResponseStatus === "S") {
					$('#ipassSelectedVisitId').html(i18n.discernabu.SELECTED_VISIT);
				}
				var activeActions = allActionsResponse.ACTIVE_ACTIONS;
				var completedActions = allActionsResponse.COMPLETED_ACTIONS;
				processActionList(activeActions, dataMap.ACTIVE, "Active");
				processActionList(completedActions, dataMap.COMPLETED, "Completed");

				//Create a set that encompasses both active and completed
				dataMap.ALL = dataMap.ACTIVE.concat(dataMap.COMPLETED);

				//Bind the data to the table
				if(dataMap.ACTIVE.length > 0){
					allActionsTable.bindData(dataMap.ACTIVE);
				}else{
					allActionsTable.bindData(dataMap.COMPLETED);
				}
				//Default the table sort on the Date column descending
				allActionsTable.sortByColumnInDirection("DATE", TableColumn.SORT.DESCENDING);

				modalBody.html(allActionsTable.render());

				//Grab some of the table elements since we'll be needing them for resizing
				var tableHeader = $("#ipassAllActionsheaderWrapper");
				var tableBody = $("#ipassAllActionstableBody");
				$("#ipassAllActionstable").addClass("ipass-all-teams-table");
				
				//Binding active data back to the table since the focus is on the ACTIVE toggle
				allActionsTable.bindData(dataMap.ACTIVE);
				allActionsTable.refresh();
				if (!dataMap.ACTIVE.length) {
					tableHeader.hide();
				} else {
					tableHeader.show();
				}
				
				//Set the initial max-height of the table body so scrolling is correctly applied
				tableBody.css({
					"max-height": calculateTableHeight(modalBody, tableHeader) + "px",
					"overflow-y": "auto"
				});
				allActionsTable.updateAfterResize();
				//Call to finalize the table, attaching all event listeners
				allActionsTable.finalize();

				//Attach the window resize listener to ensure correct visual styling and scrolling
				$(window).on("resize.ipassActions", function() {
					tableBody.css({
						"max-height": calculateTableHeight(modalBody, tableHeader) + "px"
					});
					allActionsTable.updateAfterResize();
				});
				//Attach click events for the filter buttons
				modalHead.on("click", ".lookback-button", function() {
					var button = $(this);
					//If this filter is already active, do nothing
					if (button.hasClass("lookback-button-active")) {
						return;
					}
					var dataSet = button.attr("data-set");
					//If somehow the data set attribute doesn't exist, return
					if (!dataSet) {
						return;
					}
					//Update the button stylings to reflect filter selection
					activeFilterButton.removeClass("lookback-button-active");
					button.addClass("lookback-button-active");
					activeFilterButton = button;
					var data = dataMap[dataSet];
					//Update the table with the requested set of data and refresh it
					allActionsTable.bindData(data);
					allActionsTable.refresh();
					//Some visual cleanup to hide the table header if there are no results for this data set
					if (!data.length) {
						tableHeader.hide();
					}
					else {
						tableHeader.show();
					}
				});
			}
			catch (exe) {
				modalBody.html(logger.logJSError("ipassAllActions", exe.message));
			}
		});
		allActionsRequest.performRequest();

	});

	//Create the modal buttons
	var closeButton = new ModalButton("ipassActionsClose");
	//Provide a custom handler
	closeButton.setOnClickFunction(function() {
		$(window).unbind(".ipassActions");
	});
	closeButton.setCloseOnClick(true);
	closeButton.setText(ipassI18N.CLOSE);

	//Add buttons to the modal
	showAllModal.addFooterButton(closeButton);

	//Make call to the modal framework to display the modal
	MP_ModalDialog.addModalDialogObject(showAllModal);
	MP_ModalDialog.showModalDialog(showAllModal.getId());
	
	//This will add css class to Modal Header at runtime.
	$("#ipassActionsModalHeader").addClass("ipass-Actions-Modal-Header");
};

/**
 * Register the following events:
 *  1. mouse-enter on the ipass text to show the delete icon
 *  2. mouse-leave on the ipass-actions-txt
 *  3. mouse-enter on the delete icon
 *  4. mouse-leave on the delete icon
 *  5. Show Completed/Hide Completed is clicked
 *  6. Action item checkbox is checked/unchecked
 *  7. Delete icon for an action is clicked
 *  8. Save button is clicked
 *  9. Cancel button is clicked
 *  10. Focus-in on the text entry field
 *  11. Focus-out on the text entry field
 *  12. Keyup in the textarea control
 */
IPASSActions.prototype.finalizeActions = function(actionsTarget) {
	// Retrieve unique ID
	var uniqueId = this.m_uniqueId;
	var self = this;

	//Attach all of the delegates for this section
	var actionsObj = $(actionsTarget);

	//This event executed when there is mouse enter on the ipass-actions-txt
	actionsObj.on("mouseenter", ".ipass-actions-txt", function() {
		if (!$(this).hasClass("ipass-actions-delete-action")) {
			$(this).addClass("ipass-actions-hover");
		}
	});

	//This event executed when there is mouse leave on the ipass-actions-txt
	actionsObj.on("mouseleave", ".ipass-actions-txt", function() {
		$(this).removeClass("ipass-actions-hover");
	});

	//This event executed when Show Completed/Hide Completed is clicked
	actionsObj.on("click", "#iPassActionsShowCompleted" + uniqueId + "", function() {
		self.actionShowCompleteToggle($(this));
	});

	//This event executed when the action item checkbox is checked/unchecked
	actionsObj.on("click", ".ipass-actions-chk", function() {
		self.actionChk($(this));
	});

	//This event executed when the action item delete icon is clicked
	actionsObj.on("click", ".ipass-actions-del", function() {
		self.actionDeleteConfirmation($(this));
	});

	//This event executed when the save button is clicked
	actionsObj.on("click", ".ipass-actions-save", function() {
		var selectedGlobalIndVal =  $(this).parent().find(".ipass-global-input-cb").is(":checked") ? 1 : 0;
		self.actionSave($(this),selectedGlobalIndVal);
	});

	//This event executed when the cancel button is clicked
	actionsObj.on("click", ".ipass-actions-savecancel", function() {
		self.actionCancel($(this));
	});

	//This event executed when the delete button is clicked
	actionsObj.on("click", ".ipass-actionsdelbutton", function() {
		self.actionDeletion($(this).closest(".ipass-actions-confirmicon").siblings(".ipass-actions-del"));
	});
	//This event executed when the cancel button is clicked while deleting
	actionsObj.on("click", ".ipass-actionscanbutton", function() {
		self.actionCancel($(this));
	});

	//This event executed when there is focusin on the text entry field
	actionsObj.on("focusin", ".ipass-actions-new", function() {
		var textArea = $(this);
		if (textArea.val() === CERN_IPASS_ACTIONS_O1.actionsI18N.ADD_NEW_ACTION) {
			textArea.val("").css({
				color : "#000000"
			});

			//Show the save and cancel dialog and reset the character count
			$("#iPassActionsID" + uniqueId + "").removeClass("hidden").find(".ipass-actions-field-max").html("255 " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT);
			
			//Reset the global indicator checkbox
			if(0.0 === (parseFloat(self.getSelectedCareTeamId()))) {
				$("#iPassActionsID" + uniqueId + "").find(".ipass-global-input-cb").prop("checked",true);
			}
			else{
				$("#iPassActionsID" + uniqueId + "").find(".ipass-global-input-cb").prop("checked",false);
			}
		}
	});

	//This event executed when the edit button is clicked
	actionsObj.on("click", ".ipass-actions-edit", function() {
		self.actionEdit($(this));
	});

	//This event executed when there is focusout on the text entry field
	actionsObj.on("focusout", ".ipass-actions-new", function() {
		var textArea = $(this);
		if (textArea.attr("id") === "iPassActionsEditTextBox") {
			return;
		}
		var value = textArea.val();
		if (!value || !$.trim(value)) {
			textArea.val(CERN_IPASS_ACTIONS_O1.actionsI18N.ADD_NEW_ACTION).css({
				color : "#7c7c7c"
			});

			//Hide the save and cancel dialog and reset the character count
			$("#iPassActionsID" + uniqueId + "").addClass("hidden").find(".ipass-actions-field-max").html("255 " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT).find(".ipass-actions-savebutton").attr('disabled', 'disabled');
			//Reset the global indicator checkbox
			if(0.0 === (parseFloat(self.getSelectedCareTeamId()))) {
				$("#iPassActionsID" + uniqueId + "").find(".ipass-global-input-cb").prop("checked",true);
			}
			else{
				$("#iPassActionsID" + uniqueId + "").find(".ipass-global-input-cb").prop("checked",false);
			}
		}
	});

	//This event executed when there is a keydown in the textarea control
	actionsObj.on("keydown", ".ipass-actions-new", function(event) {
		var textArea = $(this);
		
		// Retrieve the text entered in the text area
		var value = textArea.val().replace(/^\s+/, "");
		var buttonsContainer = null;
		var saveContainer = null;
		if ($(this).attr("id") === "iPassActionsEditTextBox") {
			buttonsContainer = $("#iPassEditActionsID" + uniqueId);
			saveContainer = $(this).parent().parent();
		}
		else {
			buttonsContainer = $('#iPassActionsID' + uniqueId);
			saveContainer = $(this).parent();
		}
		var saveButton = buttonsContainer.find(".ipass-actions-savebutton");
		var maxCharEle = buttonsContainer.find(".ipass-actions-field-max");
		
		// Ctrl+s key combination would save the action
		
		var code = 83;
		if (event && event.keyCode == code && event.ctrlKey) {
			event.preventDefault(event);
			if (value) {
				textArea.blur();
				var selectedGlobalIndVal =  saveContainer.find(".ipass-global-input-cb").is(":checked") ? 1 : 0;
				self.actionSave(saveContainer, selectedGlobalIndVal);
			}
			else {
				textArea.val("");
			}
			return;
		}
	});
		actionsObj.on("keyup", ".ipass-actions-new", function(event) {
		var textArea = $(this);

		// Hide error
		var errorDivElement = $('#ipass-action-err' + uniqueId);
		errorDivElement.addClass("hidden");
		errorDivElement.removeClass("ipass-err-adj");

		// Retrieve the text entered in the text area
		var value = textArea.val().replace(/^\s+/, "");
		var buttonsContainer = null;
		var saveContainer = null;
		if ($(this).attr("id") === "iPassActionsEditTextBox") {
			buttonsContainer = $("#iPassEditActionsID" + uniqueId);
			saveContainer = $(this).parent().parent();
		}
		else {
			buttonsContainer = $('#iPassActionsID' + uniqueId);
			saveContainer = $(this).parent();
		}
		var saveButton = buttonsContainer.find(".ipass-actions-savebutton");
		var maxCharEle = buttonsContainer.find(".ipass-actions-field-max");
		
		//any other key beside the enter key is pressed
		var charLimit = 255;
		if (value) {
			//Enable the save button
			saveButton.removeAttr('disabled');
			saveButton.attr("value", CERN_IPASS_ACTIONS_O1.iPassI18N.SAVE);

			//Check to see if there is error information present
			var errorObj = buttonsContainer.find(".error-icon-component");
			if (errorObj.length) {
				buttonsContainer.find(".ipass-actions-field-max").removeClass("hidden");
				saveButton.attr("value", CERN_IPASS_ACTIONS_O1.iPassI18N.SAVE);
				$(errorObj).remove();
			}

			var chars = value.length;
			var charsCount = charLimit - chars;
			if (chars >= charLimit) {
				//Too many characters so we need to trim anything over our charLimit
				textArea.val(value.substr(0, charLimit));
				maxCharEle.html("0 " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT).addClass("ipass-actions-field-textfull");
			}
			else {
				maxCharEle.html(charsCount + " " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT).removeClass("ipass-actions-field-textfull");
			}
		}
		else {
			saveButton.attr('disabled', 'disabled');
			maxCharEle.html(charLimit + " " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT);
		}
	});
	
	actionsObj.on("click", ".ipass-actions-edit-action", function(event) {
		var eventButton = event.target;
		//if save button was pushed
		if (eventButton.id === "idActionsEditSaveButton" + uniqueId && !eventButton.disabled) {
			var selectedGlobalIndval = $(this).find(".ipass-global-input-cb").is(":checked") ? 1 : 0;
			self.actionSave(this, selectedGlobalIndval);
		}
		//Cancel Button was pushed
		else if (eventButton.id === "idActionsEditCancelButton" + uniqueId) {
			var actionsEditDd = $(this);
			//unhide check box, data, author/dt tm
			actionsEditDd.find(".ipass-actions-chk :checkbox").removeClass("hidden");
			actionsEditDd.find(".ipass-actions-data").removeClass("hidden");
			actionsEditDd.find(".ipass-actions-author-timestamp").removeClass("hidden");
			//remove edit action class and padding
			actionsEditDd.removeClass("ipass-actions-edit-action");
			//remove buttons container
			actionsEditDd.find(".ipass-actions-textarea-buttons").remove();
			//remove edit text area
			$('#iPassActionsEditTextBox').remove();
		}
	});

};

/**
 * This function is used to toggle the display of the done action items
 * @param {DOM Element} completeToggle The DOM Element the user clicks to toggle the completed items display
 */
IPASSActions.prototype.actionShowCompleteToggle = function(completeToggle) {
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;

	// Hide error message
	var doneItems = $("#iPassActionsDoneItems" + uniqueId);

	if (doneItems.hasClass("ipass-actions-exp")) {

		//Hide the completed actions
		doneItems.removeClass("ipass-actions-exp");

		//Update the text of the complete toggle
		$(completeToggle).find(".ipass-actions-done-hd-txt").text(CERN_IPASS_ACTIONS_O1.actionsI18N.COMPLETED + " ");
	}
	else {
		//Show the completed actions
		doneItems.addClass("ipass-actions-exp");

		//Update the text of the complete toggle
		$(completeToggle).find(".ipass-actions-done-hd-txt").text(CERN_IPASS_ACTIONS_O1.actionsI18N.HIDE_COMPLETED + " ");
	}
};

/**
 * This function used to reset the display of the Action controls area when the user decides to cancel.
 * @param {DOM Element} cancelButton - Cancel Button Object
 */
IPASSActions.prototype.actionCancel = function(cancelButton) {
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;

		//If the cancel occurs when adding a new action
		if (cancelButton.hasClass("ipass-actions-savecancel")) {
			var textArea = $("#iPassActionsTextBox" + uniqueId);
			var buttonsContainer = $("#iPassActionsID" + uniqueId);

			// Hide error message
			var errorDivElement = $('#ipass-action-err' + uniqueId);
			errorDivElement.addClass("hidden");
			errorDivElement.removeClass("ipass-err-adj");
			textArea.val(CERN_IPASS_ACTIONS_O1.actionsI18N.ADD_NEW_ACTION).css({
				color : "#aaa"
			});

			buttonsContainer.addClass("hidden");

			buttonsContainer.find(".ipass-actions-savebutton").prop('disabled', true).attr("value", CERN_IPASS_ACTIONS_O1.iPassI18N.SAVE);
			buttonsContainer.find(".ipass-actions-field-max").removeClass("ipass-actions-field-textfull").html("");
			var errorObj = buttonsContainer.find(".error-icon-component");
			if (errorObj.length) {
				errorObj.remove();
				buttonsContainer.find(".ipass-actions-field-max").removeClass("hidden");
			}
		}
		//Cancel occurs when deleting an action
		else {
			var actionContainer = $(cancelButton).closest(".ipass-actions-txt");
			actionContainer.find("input").prop("disabled", false).css("cursor", "pointer");
			actionContainer.removeClass("ipass-actions-delete-action");
			actionContainer.find(".ipass-actions-confirmicon").remove();
		}
};

/**
 * This function is used to toggle active and done elements
 * @param {Object} actionChkObj - Check Button Object
 */
IPASSActions.prototype.actionChk = function(actionChkObj) {
	var self = this;

	//Replaces HTML <br> and &nbsp; with a carriage return and space, respectively
	function convertHTMLSpacingToText(text) {
		return text.replace(/<br\/?>/gi, "\n").replace(/&nbsp;/g, " ");
	}
	
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;

	var checkedItem = $(actionChkObj).closest("dd");
	var encounterId = checkedItem.attr("data-enc-id");
	var actionID = checkedItem.attr("data-action-id");
	var actionUpdCnt = checkedItem.attr("data-upd-cnt");
	var actionText = convertHTMLSpacingToText(checkedItem.find(".ipass-actions-data").html());
	var actionType = "";
	var actionGblIndVal = parseInt(checkedItem.attr("data-action-gbl-ind-val"), 10);
	var ipassActionsTimer = new RTMSTimer("USR:MPG.IPASS-ACTIONS_Actions_Actionability", self.getSubTimerName());
	// Hide error message
	var errorDivElement = $('#ipass-action-err' + uniqueId);
	errorDivElement.addClass("hidden");
	errorDivElement.removeClass("ipass-err-adj");
	try {
		
		if (actionText && encounterId) {

			//If the actionItem is now checked give it a done date
			if ($(actionChkObj).find("input").is(":checked")) {
				actionType = "COMPLETE";
				if (ipassActionsTimer) {
			ipassActionsTimer.addMetaData("rtms.legacy.metadata.1", "Action Complete");
			ipassActionsTimer.start();
		}

			}
			else {
				actionType = "PENDING";
				if (ipassActionsTimer) {
			ipassActionsTimer.addMetaData("rtms.legacy.metadata.1", "Action Active");
			ipassActionsTimer.start();
		}

			}

			var UPD_CNT = actionUpdCnt;
			var cclParam = CERN_IPASS_O1.createJSONRequest(this.m_personId + ".0", encounterId + ".0", "0.0", "0.0", actionID, "0.0", "ACTION", "MODIFY", "0.0", actionText, UPD_CNT, actionType, actionGblIndVal, 0, this.getSelectedCareTeamId() + ".0");
			this.m_iPassActionsRef = $(actionChkObj);
			CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], cclParam, function(response) {
				self.updateAction(response);
			}, false);
		}

	}
	catch(err) {
		if (ipassActionsTimer) {
			ipassActionsTimer.fail();
			ipassActionsTimer = null;
		}
		MP_Util.LogJSError(err, self, "ipass-actions.js", "Comments Actionability Complete Checked/Unchecked");
		throw (err);
	}
	finally {
		if (ipassActionsTimer) {
			ipassActionsTimer.stop();
		}
	}

};

/**
 * This function is used to save a new Action to the active Actions list
 * @param {DOM Element} actionSaveObj The save button clicked when saving a new Action
 */
IPASSActions.prototype.actionSave = function(actionSaveObj, selectedGblIndVal) {
	// Retrieve the unique ID
	var ipassActionsTimer = null;

	//for CAP Timer - Global Indicator
	var ipassActionsCAPTimer = null;
	var uniqueId = this.m_uniqueId;
	var self = this;
	var criterion = this.getCriterion();
	var personId = criterion.person_id || 0;
	var buttonsContainer = $("#iPassActionsID" + uniqueId);
	var saveContainer = $(actionSaveObj);
	var encounterId = $(saveContainer).attr("data-enc-id");
	var textArea = $("#iPassActionsTextBox" + uniqueId);
	var saveButton = null;
	var actionText = "";
	var cclParam = "";
	var globalOptionVal = 0;
	
	// Hide error message
	var errorDivElement = $('#ipass-action-err' + uniqueId);
	errorDivElement.addClass("hidden");
	errorDivElement.removeClass("ipass-err-adj");
	try {
		//Get the global indicator value and start the CAP timer only if is selected
		globalOptionVal = parseInt(selectedGblIndVal, 10);
		
		//CAP Timer for Global Indicator - Actions {CAP: MPG I-PASS Global}
		if(globalOptionVal){
			ipassActionsCAPTimer = new CapabilityTimer("CAP: MPG I-PASS Global", self.getSubTimerName());
			if(ipassActionsCAPTimer){
				ipassActionsCAPTimer.addMetaData("rtms.legacy.metadata.1", "Actions: Global");
				ipassActionsCAPTimer.capture();
			}
		}
		//Save Edit Todo
		ipassActionsTimer = new RTMSTimer("USR:MPG.IPASS-ACTIONS_Actions_Actionability", self.getSubTimerName());
		if (saveContainer.hasClass("ipass-actions-edit-action")) {

			if (ipassActionsTimer) {
				ipassActionsTimer.addMetaData("rtms.legacy.metadata.1", "Action Modify");
				ipassActionsTimer.start();
			}
			var editTextBox = $("#iPassActionsEditTextBox");
			saveButton = $("#idActionsEditSaveButton" + uniqueId);
			//disable save button and add loading image
			saveButton.prop("value", " ").prop("disabled", true);
			saveButton.addClass("ipass-save-image");
			//Disable the textArea
			editTextBox.prop("disabled", true);
			//grab value of the textarea
			actionText = editTextBox.val().replace(/^\s+/, "");
			
			if (actionText) {
				//setup ccl parameters for update
				cclParam = CERN_IPASS_O1.createJSONRequest(personId + ".0", saveContainer.attr("data-enc-id") + ".0", "0.0", "0.0", saveContainer.attr("data-action-id"), "0.0", "ACTION", "MODIFY", "0.0", actionText, saveContainer.attr("data-upd-cnt"), "", globalOptionVal, 0, "0.0");
				//setup reference
				self.m_iPassActionsRef = saveContainer.children(".ipass-actions-edit");
				CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], cclParam, function(response) {
					self.updateAction(response);
				}, false);
			}
		}
		//Save new todo
		else {
			if (ipassActionsTimer) {
				ipassActionsTimer.addMetaData("rtms.legacy.metadata.1", "Action Add");
				ipassActionsTimer.start();
			}
			buttonsContainer = $("#ipassActionsWrapper" + uniqueId).children(".ipass-actions-div");
			textArea = $("#iPassActionsTextBox" + uniqueId);
			encounterId = buttonsContainer.attr("data-enc-id");
			saveButton = saveContainer.find(".ipass-actions-savebutton");
			// Get the text from the textarea
			actionText = textArea.val().replace(/^\s+/, "");

			//Return if the default text is in the textbox
			if (actionText === CERN_IPASS_ACTIONS_O1.actionsI18N.ADD_NEW_ACTION) {
				return 1;
			}

			//Update the display of the save button and add the loading image
			saveButton.prop("value", "       ").prop("disabled", true);
			saveButton.addClass("ipass-save-image");

			//Disable the textArea
			textArea.prop("disabled", true);

			//Remove the error message if it is still being shown
			var errorObj = buttonsContainer.find(".error-icon-component");
			if (errorObj.length) {
				errorObj.remove();
				buttonsContainer.find(".ipass-actions-field-max").removeClass("hidden");
			}

			//Trim the text if it is too long
			if (actionText.length > 255) {
				textArea.val(actionText.substring(0, 255));
				buttonsContainer.find(".ipass-actions-field-max").html(actionText.length + " " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT).addClass('ipass-actions-field-textfull');
			}
			
			//If we have valid text and an encounterId save the action item
			if (actionText && encounterId) {
				cclParam = CERN_IPASS_O1.createJSONRequest(this.m_personId + ".0", encounterId + ".0", "0.0", "0.0", "0.0", "0.0", "ACTION", "ADD", "0.0", actionText, 0, "", globalOptionVal, 0, this.getSelectedCareTeamId() + ".0");
				self.m_iPassActionsRef = saveButton.parent();
				CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], cclParam, function(response) {
					self.updateAction(response);
				}, false);
			}
		}
	}
	catch(err) {
		if (ipassActionsCAPTimer) {
			ipassActionsCAPTimer.fail();
			ipassActionsCAPTimer = null;
		}
		if (ipassActionsTimer) {
			ipassActionsTimer.fail();
			ipassActionsTimer = null;
		}
		MP_Util.LogJSError(err, self, "ipass-actions.js", "Actions Actionability Update/New");
		throw (err);
	}
	finally {
		if (ipassActionsTimer) {
			ipassActionsTimer.stop();
		}
	}
};

/**
 * This function is used to prompt user for deletion if needed
 * @param {DOM Element} actionDeleteSource - delete Button Object
 */
IPASSActions.prototype.actionDeleteConfirmation = function(actionDeleteSource) {
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;
	var self = this;

	// Hide error message
	var errorDivElement = $('#ipass-action-err' + uniqueId);
	errorDivElement.addClass("hidden");
	errorDivElement.removeClass("ipass-err-adj");
	var actionDelObj = $(actionDeleteSource).parent();

	//If there is currently another action item that is being deleted, hide that delete interface before we show ours
	var previousDelete = $("#iPassActionsList" + uniqueId).find(".ipass-actions-delete-action");
	if (previousDelete.length) {
		previousDelete.find("input").removeAttr("disabled").css("cursor", "pointer");
		previousDelete.removeClass("ipass-actions-delete-action");
		previousDelete.find(".ipass-actions-confirmicon").remove();
		previousDelete.find(".ipass-actions-separator-container").remove();
	}

	var encounterId = actionDelObj.attr("data-enc-id");
	var actionText = actionDelObj.find(".ipass-actions-data").html();
	var parentDL = actionDelObj.closest("dl");

	if (actionText && encounterId) {
		//If we are removing a Active ToDo
		if (parentDL.hasClass("ipass-actions-current")) {
			actionDelObj.removeClass("ipass-actions-hover ipass-actions-del-hover").addClass("ipass-actions-delete-action");
			actionDelObj.find("input").attr("disabled", "disabled").css("cursor", "default");

			//create the delete button and add click events
			var deleteButton = ("<input class='ipass-actionsdelbutton' id='idActionsDelButton" + uniqueId + "' type='button' name='actiondel' value='" + CERN_IPASS_ACTIONS_O1.iPassI18N.DELETE + "'></input>");

			//Create the cancel button and add click events
			var cancelButton = ("<input class='ipass-actionscanbutton' id='idActionsCanButton" + uniqueId + "' type='button' name='ipass-actionscancel' value='" + CERN_IPASS_ACTIONS_O1.iPassI18N.CANCEL + "'></input>");

			//Add the delete and cancel buttons to the confirm container
			var confirmContainer = $("<div class='ipass-actions-confirmicon'><span class='del-confirm'>" + CERN_IPASS_ACTIONS_O1.actionsI18N.CONFIRM_MSG + "</span><span class='ipass-delete-confirm-buttons'>" + deleteButton + cancelButton + "</span></div>");
			actionDeleteSource.siblings(".ipass-actions-author-container").after(confirmContainer);

		}
		else {
			// If a completed action is being deleted then a confirmation is not shown and directly delete the action
			self.actionDeletion(actionDeleteSource);
		}
	}
};

/**
 * This function is used to delete an action
 * @param {DOM Element} actionDelete - action to be deleted
 */
IPASSActions.prototype.actionDeletion = function(actionDelete) {
	var self = this;
	var actionDelObj = $(actionDelete).closest(".ipass-actions-txt");
	var encounterId = actionDelObj.attr("data-enc-id");
	var actionID = actionDelObj.attr("data-action-id") + ".00";
	var actionText = actionDelObj.find(".ipass-actions-data").html();
	var actionUpdCnt = actionDelObj.attr("data-upd-cnt");
	var actionGblIndVal = parseInt(actionDelObj.attr("data-action-gbl-ind-val"), 10);
	var cclParam = CERN_IPASS_O1.createJSONRequest(this.m_personId + ".0", encounterId + ".0", "0.0", "0.0", actionID, "0.0", "ACTION", "DELETE", "0.0", actionText, actionUpdCnt, "", actionGblIndVal, 0, "0.0");
	var ipassActionsTimer = null;

	try {
		ipassActionsTimer = new RTMSTimer("USR:MPG.IPASS-ACTIONS_Actions_Actionability", self.getSubTimerName());

		if (ipassActionsTimer) {
			ipassActionsTimer.addMetaData("rtms.legacy.metadata.1", "Action Delete");
			ipassActionsTimer.start();
		}

		self.m_iPassActionsRef = $(actionDelete);
		CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], cclParam, function(response) {
			self.updateAction(response);
		}, false);
	}
	catch(err) {
		if (ipassActionsTimer) {
			ipassActionsTimer.fail();
			ipassActionsTimer = null;
		}
		MP_Util.LogJSError(err, self, "ipass-actions.js", "Actions Actionability Delete");
		throw (err);
	}
	finally {
		if (ipassActionsTimer) {
			ipassActionsTimer.stop();
		}
	}
};
/**
 * This function is used to edit an action
 * @param {DOM Element} actionEditSource - edit Button Object
 */
IPASSActions.prototype.actionEdit = function(actionEditSource) {
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;
	//Only allow edit click action when action is editable
	if (!actionEditSource.hasClass("ipass-actions-edit-active")) {
		return;
	}
	var actionEditObj = actionEditSource.closest(".ipass-actions-txt");
	var ipassActionsData = actionEditObj.children(".ipass-actions-itm").children(".ipass-actions-data");
	
	var ipassActionsText = ipassActionsData.html().replace(/\s+$/,"");
	ipassActionsText = ipassActionsText.replace(/&nbsp\;/g, ' ');
	 ipassActionsText = ipassActionsText.replace(/<br>+/gi, "\n");
	 
	var charsLeft = (255 - ipassActionsText.length);
	var charsFull = "";
	var currentGlobalIndStatus = 0;
	//If there is currently another action item that is being edited, hide that edit interface before we show ours
	var previousEdit = $("#iPassActionsActiveItems" + uniqueId).find(".ipass-actions-edit-action");
	
		if (previousEdit.length) {
			previousEdit.find("input").removeClass("hidden");
			previousEdit.find(".ipass-actions-data").removeClass("hidden");
			previousEdit.find(".ipass-actions-author-timestamp").removeClass("hidden");
			previousEdit.removeClass("ipass-actions-edit-action");
			$("#iPassEditActionsID" + uniqueId).remove();
			previousEdit.find('.ipass-actions-new').remove();
		}
		// Add edit dislpay, hide checkbox and hovers
		actionEditObj.removeClass("ipass-actions-hover ipass-actions-del-hover").addClass("ipass-actions-edit-action");
		actionEditObj.find("input").addClass("hidden");
		
		//Get the current global indicator value - If it was checked then we need to disable it from editing
		currentGlobalIndStatus = parseInt(actionEditObj.attr("data-action-gbl-ind-val"), 10);
		//if Character length is 255 or greater, neeed to add bold red front to count
		if (charsLeft <= 0) {
			charsFull = "ipass-actions-field-textfull";
		}

		//Create textarea after the ipass-actions-data and populate with current todo data
		ipassActionsData.after("<textarea id='iPassActionsEditTextBox' class='ipass-actions-new' maxlength='255' rows='4' >" + ipassActionsText + "</textarea>");

		//Hide the current ipass actions data and author/dt tm
		ipassActionsData.addClass("hidden");
		actionEditObj.children(".ipass-actions-author-container").children(".ipass-actions-author-timestamp").addClass("hidden");

		//create the save button
		var saveButton = ("<input class='ipass-actions-savebutton' id='idActionsEditSaveButton" + uniqueId + "' type='button' name='ipass-actionssave' value='" + CERN_IPASS_ACTIONS_O1.iPassI18N.SAVE + "' disabled></input>");
		
		//Create the cancel button and add click events
		var cancelButton = ("<input class='ipass-actions-cansavebutton' id='idActionsEditCancelButton" + uniqueId + "' type='button' name='ipass-actionscancel' value='" + CERN_IPASS_ACTIONS_O1.iPassI18N.CANCEL + "'></input>");

		//Create the textarea buttons container and set the Global indicator status to the previous checkbox value
		var editTextareaButtons = $("<div id='iPassEditActionsID" + uniqueId + "' class='ipass-actions-textarea-buttons'><span class='ipass-actions-field-max " + charsFull + "'>" + charsLeft + " " + CERN_IPASS_ACTIONS_O1.iPassI18N.CHARACTERS_LEFT + "</span><span class='ipass-edit-confirm-buttons'>" + this.appendGlobalIndicatorElemt(true, currentGlobalIndStatus) + saveButton + cancelButton + "</span></div>");

		actionEditObj.append(editTextareaButtons);
		
		//Add a onclick event for the save button to be enabled when the "Available to All" option is checked
		//This allows us to be independent of the text box.
		actionEditObj.find(".ipass-global-input-cb").on("click", function(event) {
			if (currentGlobalIndStatus === 0 && ($(this).is(":checked"))) {
				$(this).parents().find(".ipass-actions-savebutton").prop("disabled",false);
			}
			else
			{
				$(this).parents().find(".ipass-actions-savebutton").prop("disabled",true);
			}
		});
		
};

/**
 * This function is called when an Active/Completed action item is Added/Deleted/Modified in the database.
 * @param {Object} response Response from mp_upd_pct_ipass script call
 */
IPASSActions.prototype.updateAction = function(response) {
	
		// Retrieve the unique ID and actions reference
		var sourceObj = this.m_iPassActionsRef;
		var uniqueId = this.m_uniqueId;

		if (response) {
			var jsReply = response.getResponse();

			//If we received an error log handle it gracefully
			if (response.getStatus() !== "S") {
				MP_Util.LogScriptCallError(null, this, "ipass-actions.js", "updateAction");
				this.sytemFailureMessage(sourceObj);
				return;
			}

			var encounterId = sourceObj.attr("data-enc-id");
			var actionId = jsReply.RECORDS[0].PCT_IPASS_ID;
			var actionText = unescape(jsReply.RECORDS[0].TEXT).replace(/\s+$/,"");
			// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
			actionText = actionText.replace(/ {2}/g, "&nbsp;&nbsp;");
			actionText = actionText.replace(/[\n]/g,"<br/>");
			var actionUpdCnt = jsReply.RECORDS[0].UPDT_CNT;
			var actionUpdById = jsReply.RECORDS[0].UPDT_BY_ID;
			var actiongblInd = jsReply.RECORDS[0].GLOBAL_IND;
			var personnelArray = MP_Util.LoadPersonelListJSON(jsReply.PRSNL);
			var actionProvider = MP_Util.GetValueFromArray(actionUpdById, personnelArray);
			var actionAuthor = $.trim(actionProvider.fullName);
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			var actionUpdateDtTm = df.formatISO8601(jsReply.RECORDS[0].UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
			var personnelId = this.getCriterion().provider_id;
			var actionHTML = "";
			var actionEditable = "";
			//Saving a new action
			if (sourceObj.hasClass("ipass-actions-save")) {
				//determine if new action is editable
				if (actionUpdById === personnelId) {
					actionEditable = "ipass-actions-edit-active";
				}

				//The user has added a new action item and saved it
				//Add the new active action to the beginning of the list
				actionHTML += "<dd class='ipass-actions-txt ipass-actions-active-txt-color' id='action" + actionId + uniqueId + "' data-enc-id='" + encounterId + "' data-action-id='" + actionId + "' data-upd-cnt='" + actionUpdCnt +
				"' data-action-gbl-ind-val='" + actiongblInd +"'><span  class='ipass-actions-itm'><span class='ipass-actions-chk'><input type='checkbox' /></span><span class= 'ipass-actions-data'>" + actionText + "</span></span><span class='ipass-actions-edit " + actionEditable + "'>&nbsp;</span><span class='ipass-actions-del ipass-actions-active-item'><span class='hidden'>&nbsp;</span></span>";
				actionHTML += "<span class='ipass-actions-author-container'><span class='ipass-actions-author-timestamp' data-ipass-actions-orig-auth-id='" + actionUpdById + "' data-ipass-actions-orig-author-dt-tm='" + actionAuthor + " " + actionUpdateDtTm + "'>" + actionAuthor + " " + actionUpdateDtTm + "</span></span></dd>";
				$("#iPassActionsList" + uniqueId).find(".ipass-actions-current").prepend(actionHTML);

				//Reset the textarea text and change the style
				$("#iPassActionsTextBox" + uniqueId).val(CERN_IPASS_ACTIONS_O1.actionsI18N.ADD_NEW_ACTION).removeAttr("disabled").css({
					color : "#AAA",
					background : "#FFF"
				});

				//Reset the Add Actions area
				//Remove the error icon if shown
				var addTodoControls = $("#iPassActionsID" + uniqueId);
				addTodoControls.find(".error-icon-component").remove();

				//Reset any save button text back to 'Save'
				addTodoControls.find(".ipass-actions-savebutton").attr("value", CERN_IPASS_ACTIONS_O1.iPassI18N.SAVE).attr("disabled", "disabled").removeClass("ipass-save-image");

				//Reset the color of the char count
				addTodoControls.find(".ipass-actions-field-max").removeClass("ipass-actions-field-textfull");

				//Remove the loading image
				addTodoControls.find('.ipass-loading').remove();

				//Hide the controls content
				addTodoControls.addClass("hidden");
			}
			//Removed deleted Action
			else if (sourceObj.hasClass("ipass-actions-del")) {
				//The user has deleted a action item
				//Remove the deleted item
				$("#action" + actionId + uniqueId).remove();
			}
			//action was completed / uncompleted
			else if (sourceObj.hasClass("ipass-actions-chk")) {
				//The user is activating/deactivating a action item
				var checkedToDo = $("#action" + actionId + uniqueId);
				var tempAuthorText = "";
				var ipassOrigAuthorDtTm = checkedToDo.children(".ipass-actions-author-container").children(".ipass-actions-author-timestamp");

				//Remove the hover classes
				checkedToDo.removeClass("ipass-actions-hover");

				if (sourceObj.find("input").is(":checked")) {
					//The user is moving the action from active to done
					checkedToDo.find(".ipass-actions-data").addClass("ipass-actions-strike");
					checkedToDo.removeClass("ipass-actions-active-txt-color").addClass("ipass-actions-done-txt-color");
					checkedToDo.attr("data-upd-cnt", actionUpdCnt);

					//Move the original Author / Date Time to attr
					tempAuthorText = ipassOrigAuthorDtTm.text();
					ipassOrigAuthorDtTm.attr("data-ipass-actions-orig-author-dt-tm", tempAuthorText);

					//Update Author / Date Time
					ipassOrigAuthorDtTm.text(actionAuthor + " " + actionUpdateDtTm);

					//Remove edit-active class
					checkedToDo.children(".ipass-actions-edit").removeClass("ipass-actions-edit-active");

					//Move the action from the active list to the done list
					$("#iPassActionsDoneItems" + uniqueId).prepend(checkedToDo);
				}
				else {
					checkedToDo.find(".ipass-actions-data").removeClass("ipass-actions-strike");
					checkedToDo.removeClass("ipass-actions-done-txt-color").addClass("ipass-actions-active-txt-color");
					checkedToDo.attr("data-upd-cnt", actionUpdCnt);

					//Add the Original Author / Date Time
					ipassOrigAuthorDtTm.text(ipassOrigAuthorDtTm.attr("data-ipass-actions-orig-author-dt-tm"));

					//Add edit-active class if personnel is original author
					if (parseInt(ipassOrigAuthorDtTm.attr("data-ipass-actions-orig-auth-id"), 10) === personnelId) {
						checkedToDo.children(".ipass-actions-edit").addClass("ipass-actions-edit-active");
					}

					//Move the action from the active list to the done list
					$("#iPassActionsActiveItems" + uniqueId).prepend(checkedToDo);
				}
			}
			//saving an edit action
			else if (sourceObj.hasClass("ipass-actions-edit-active")) {
				var actionsItem = sourceObj.siblings(".ipass-actions-itm");
				actionsItem.children("#iPassActionsEditTextBox").remove();
				//unhide action and update text
				actionsItem.children(".ipass-actions-data").removeClass("hidden").html(actionText);
				actionsItem.find("input").prop("disabled", false).css("cursor", "pointer");
				actionsItem.closest(".ipass-actions-txt").removeClass("ipass-actions-edit-action").attr("data-upd-cnt", actionUpdCnt);
				
				// When the edit is performed the global indicator value is preserved
				actionsItem.closest(".ipass-actions-txt").attr("data-action-gbl-ind-val", actiongblInd);
				
				$(".ipass-actions-textarea-buttons").remove();
				//unhide check box, author/dt tm, padding for editing
				actionsItem.find("input").removeClass("hidden");
				sourceObj.siblings(".ipass-actions-author-container").children(".ipass-actions-author-timestamp").removeClass("hidden");
			}

			//Update the various containers determining on the current actions shown
			var activeCnt = $("#iPassActionsActiveItems" + uniqueId).find("dd").length;
			var doneCnt = $("#iPassActionsDoneItems" + uniqueId).find("dd").length;

			// Cache elements
			var ipassActionNoDataID = $("#ipassActiNoDataId" + uniqueId);
			var ipassActiNoActiveDataId = $("#ipassActiNoActiveDataId" + uniqueId);
			var iPassActionsShowCompleted = $("#iPassActionsShowCompleted" + uniqueId);
			var iPassActionsDoneCnt = $("#iPassActionsDoneCnt" + uniqueId);

			if (!activeCnt && !doneCnt) {
				//Show the message "There are no actions for this patient."
				ipassActionNoDataID.removeClass("hidden");

				//Hide the message "There are no active actions."
				ipassActiNoActiveDataId.addClass("hidden");

				//Hide the completed section and update the count
				iPassActionsShowCompleted.addClass("hidden");
				iPassActionsDoneCnt.html("(" + doneCnt + ")");
			}
			else {
				//Make sure the "There are no actions for this patient." message is hidden
				ipassActionNoDataID.addClass("hidden");
				if (activeCnt) {
					//Hide the message "There are no active actions."
					ipassActiNoActiveDataId.addClass("hidden");
				}
				else {
					//Show the message "There are no active actions."
					ipassActiNoActiveDataId.removeClass("hidden");
				}

				if (doneCnt) {
					//Update the count of done items
					iPassActionsShowCompleted.removeClass("hidden");
				}
				else {
					//Hide the "Show Completed" element
					iPassActionsShowCompleted.addClass("hidden");
				}
				iPassActionsDoneCnt.html("(" + doneCnt + ")");
			}
		}
};

/**
 * This function is used to display error messages if there was an error saving/completing/deleting an action
 * @param {Object} sourceElement The source element on whom the update action was taken. (Save Button, Delete Button or Checkbox)
 * @return null
 */
IPASSActions.prototype.sytemFailureMessage = function(sourceElement) {
	// Retrieve the unique ID
	var uniqueId = this.m_uniqueId;

	var sourceObj = $(sourceElement);
	var errorMsg = "";
	var errorHTML = "";
	var actionsControl = $('#iPassActionsID' + uniqueId);
	var errorDivElement = $('#ipass-action-err' + uniqueId);

	//Attempted to save an action and an error occurred
	if (sourceObj.hasClass("ipass-actions-save")) {
		errorMsg = CERN_IPASS_ACTIONS_O1.actionsI18N.UNABLE_ADD_ACTION;
		errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
		errorDivElement.html(errorHTML);

		//Update the visuals on the remaining controls
		actionsControl.find(".ipass-actions-savebutton").attr("value", CERN_IPASS_ACTIONS_O1.iPassI18N.RETRY).removeAttr("disabled");

		//Re-enable the textarea and remove the grayed background
		actionsControl.prev().removeAttr("disabled");

		//Remove the loading gif
		actionsControl.find('img').remove();
		errorDivElement.removeClass("hidden");
		errorDivElement.addClass("ipass-err-adj");
		return;
	}

	//Attempted to complete/uncomplete an action item
	if (sourceObj.hasClass("ipass-actions-chk")) {
		if (sourceElement.find("input").is(":checked")) {

			//Atempted to complete an active action item and it failed
			errorMsg = CERN_IPASS_ACTIONS_O1.actionsI18N.UNABLE_ACTION_COMPLETE.replace("{0}", "\"" + CERN_IPASS_ACTIONS_O1.actionsI18N.COMPLETE + ".\"");
			errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
			errorDivElement.html(errorHTML);
			errorDivElement.removeClass("hidden");
			errorDivElement.addClass("ipass-err-adj");
			sourceElement.find("input").attr("checked", false);
		}
		else {
			//Attempted to un-complete an inactive action item and it failed
			errorMsg = CERN_IPASS_ACTIONS_O1.actionsI18N.UNABLE_ACTION_ACTIVE.replace("{0}", "\"" + CERN_IPASS_ACTIONS_O1.actionsI18N.ACTIVE + ".\"");
			errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
			errorDivElement.html(errorHTML);
			sourceElement.attr("checked", true);
			errorDivElement.removeClass("hidden");
			errorDivElement.addClass("ipass-err-adj");
		}
		return;
	}

	//Attempted to delete an action item and it failed
	if (sourceObj.hasClass("ipass-actions-del")) {
		errorMsg = CERN_IPASS_ACTIONS_O1.actionsI18N.UNABLE_ACTION_DELETE;
		errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
		errorDivElement.html(errorHTML);
		errorDivElement.removeClass("hidden");
		errorDivElement.addClass("ipass-err-adj");
		return;
	}

};

/**
 * Helper function to create global indicator HTML with default checked flexed based on list type
 * @param isEdit  boolean - used to determine if global indicator is for an edit
 * @param globalInd  number - indicates if the current edit item is a global
 * @return {string} globalIndHTML - HTML string for the global indicator checkbox
 */

IPASSActions.prototype.appendGlobalIndicatorElemt = function(isEdit, gblInd) {
	var globalIndHTML = "";
	var checkedHTML = "";
	var toolTipText = "";
	var disabledHTML = "";
	var globalInd = parseInt(gblInd,10);
	var iPassI18n = i18n.discernabu.ipass;
	//If lookback value is set then the global indicator checkbox wont be shown and it would essentially behave with a Cross encounter pref
	if(this.getLookbackVal()){
		return "";
	}
	else if(this.getCrossEncIndicatorVal()){
		return "";
	}
	//if the item is from an edit and currently a global, default the checkbox to checked and dither since it cannot be changed
	if (isEdit) {
		if (globalInd === 1) {
			checkedHTML = " checked='checked'";
			disabledHTML = " disabled='disabled'";
		}
	}
	//If patient list it is populated checkbox will be checked by default
	else if (0.0 === (parseFloat(this.getSelectedCareTeamId())) || globalInd) {
		checkedHTML = " checked='checked'";
	}
	toolTipText = iPassI18n.AVAILABLE_TO_ALL_TOOLTIP_ACTIONS;
	globalIndHTML += '<label class="ipass-global-label" title="' + toolTipText + '"><input type="checkbox" class="ipass-global-input-cb"' + checkedHTML + disabledHTML + ' />' + iPassI18n.AVAILABLE_TO_ALL + '</label>';
	return globalIndHTML;
};
/**
 * ipass-comments.js
 * @author Swati Kode
 *
 * IPASS Comments class
 * ========================================================================================================================================
 *
 * Creates a IPASS Comments control in the HTML content element sent by a consumer. This control has a text area where a new comment
 * can be entered.
 * A list of previously added comments are displayed belowed the text area. An author name and date/time when the comment was
 * added is also displayed next to the comment. If no comments exists then a message is displayed.
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new Comments object
 * @name IPASSComments
 */
IPASSComments = function() {
	this.m_uniqueId = null;
	this.m_criterion = null;
	this.m_personId = 0;
	this.m_encntrId = 0;
	
	// Arrays for storing the comments
	this.saveComm = [];
	this.htmlSave = [];

	// Flag for showing all comments
	this.dispShowAll = 0;

	// Flag to identify if delete is in progress
	this.deleteInProgress = false;

	// Variable for holding the care team ID
	this.m_selectedCareTeamId = 0;
	
	// Variable to store max number of characters in comments text field
	this.maxChars = 1000;
	
	// Flag indicating whether the selected service is set with a preference of across encounters or not
	this.m_crossEncInd = 0;
	
	// Variable to indicate the lookback value
	this.m_lookbackVal = 0;
};

/**
 * Returns a unique ID for the comments control
 */
IPASSComments.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets a unique ID for the comments control
 * @param {string | number} uniqueId The unique id for the comments control
 * @returns {IPASSComments} returns the IPASS Comments object to allow chaining
 */
IPASSComments.prototype.setUniqueId = function(uniqueId) {
	//Validate uniqueId, throw an error if not valid
	if (!uniqueId || ( typeof uniqueId !== "string" && typeof uniqueId !== "number")) {
		throw new Error("Error setting unique ID. Parameter Unique Id must either be a number or a string for the comments control.");
	}
	this.m_uniqueId = uniqueId;
	return this;
};

/**
 * Returns a criterion of the calling component
 */
IPASSComments.prototype.getCriterion = function() {
	return this.m_criterion;
};

/**
 * Sets a criterion for the calling component
 * @param {object} criterion The criterion of the calling component
 * @returns {IPASSComments} returns the care team selector object to allow chaining
 */
IPASSComments.prototype.setCriterion = function(criterion) {
	//Validate uniqueId, throw an error if not valid
	if (!criterion) {
		throw new Error("Error setting criterion. Parameter criterion must be specified.");
	}
	this.m_criterion = criterion;

	// Retrieve the person ID from the criterion
	this.m_personId = criterion.person_id || criterion.PERSON_ID || "";

	// Retrieve the encounter ID from the criterion
	this.m_encntrId = criterion.encntr_id || criterion.ENCNTR_ID || "";

	return this;
};

/**
 * Returns the care team ID of the currently selected care team in the selector
 */
IPASSComments.prototype.getSelectedCareTeamId = function() {
	return this.m_selectedCareTeamId;
};

/**
 * Sets the care team ID of the currently selected care team in the selector
 * @param {integer} careTeamId The ID of the currently selected care team
 */
IPASSComments.prototype.setSelectedCareTeamId = function(careTeamId) {
	this.m_selectedCareTeamId = careTeamId;
};


/**
 * Returns the lookback value
 */
IPASSComments.prototype.getLookbackVal = function() {
	return this.m_lookbackVal;
};

/**
 *	Sets the lookback value. This can be used for instance to disable the global indicator when the active pregnancy record is present
 *  @param {integer} lkbkVal lookback value for a patient
 */
IPASSComments.prototype.setLookbackVal = function(lkbkVal) {
	this.m_lookbackVal = lkbkVal;
};
/**
 * This function is used to retrieve the name of the category-mean/viewpoint key that the ipass utility is being shown in.
 * A default string will be returned if the category mean or viewpoint key is not retrieved
 * @param {none}
 * @returns {string}  Sub-timer name that is used in creating timer
 */
IPASSComments.prototype.getSubTimerName = function() {
	// If the component is at the Mpage level then get the category_mean
	if (this.m_criterion.category_mean) {
		return this.m_criterion.category_mean;
	}

	// If the component is at the viewpoint level then get the viewpoint key
	if (this.viewpointNameKey) {
		return this.viewpointNameKey;
	}
	// If viewpointNameKey does not exists then parse the viewpoint JSON
	try {
		this.viewpointNameKey = JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME_KEY;
		return this.viewpointNameKey;
	}
	catch (error) {
		MP_Util.LogJSError(error, null, "ipass-comments.js", "getSubTimerName");
		return "IPASS Comments Artifact";
	}
};

/**
 * @return {integer} Value for the cross encounter preference of the Medical Service
 */
IPASSComments.prototype.getCrossEncIndicatorVal = function() {
	return this.m_crossEncInd;
};

/**
 * Sets the value for the cross encounter preference of the Medical Service into a variable
 * @param {integer} crossEncInd Flag value indicating if the Medical Service is across encounters or not
 */
IPASSComments.prototype.setCrossEncIndicatorVal = function(crossEncInd) {
	this.m_crossEncInd = crossEncInd;
};

/**
 * Function name: renderComments
 * This method will render a Comments control. The control will have a text area which will allow to enter new comment and a list of
 * all comments below the text area.
 * If there are no comments then a message is displayed below the text area. Maximum of 4 comments will be showed face-up.
 * Any additional comment(s) can be displayed by clicking a "Show All" link below the 4 comment.
 * @param {object} response A response RECORD_DATA from mp_retrieve_ipass script
 * @param {object} commentsTarget The HTML element which be holding the comments control
 * @class IPASS Comments
 * @scope public
 */
IPASSComments.prototype.renderComments = function(response, commentsTarget) {
	var timerSitAwareRender = null;

	try {
		// Retrieve the patient and encounter information from response
		var encounterInfo = response;
		// Cache the target element to access later
		this.commentsTarget = commentsTarget;
		var dateFormat = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
		var commentsArray = encounterInfo.COMMENTS;
		var provider = null;
		var origProvider = null;
		var providerName = "";
		var origProviderName = "";

		// Reset the array for saving comments
		this.saveComm = [];
		this.htmlSave = [];
		
		// Render Timer
		timerSitAwareRender = MP_Util.CreateTimer("ENG:MPG.IPASS_SIT_AWARE - render", this.getSubTimerName());
		
		// Retrieve provider information
		this.personnelArray = MP_Util.LoadPersonelListJSON(response.PRSNL);

		// Create comment objects from the records returned from the script and store them in the comment array
		for (var i = 0, il = commentsArray.length; i < il; i++) {
			var commentItem = commentsArray[i];
			provider = MP_Util.GetValueFromArray(commentItem.UPDT_BY_ID, this.personnelArray);
			origProvider = MP_Util.GetValueFromArray(commentItem.ORIG_UPDT_BY_ID, this.personnelArray);
			providerName = (provider === null) ? "" : provider.fullName;
			origProviderName = (origProvider === null) ? "" : origProvider.fullName;
			var commentText = unescape(commentItem.TEXT).replace(/\s+$/,"");
			// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
			commentText = commentText.replace(/ {2}/g, "&nbsp;&nbsp;");
			commentText = commentText.replace(/[\n]/g,"<br\/>");
			var globalIndicator = commentItem.GLOBAL_IND;
			var tempData = new this.newComment(commentItem.PCT_IPASS_ID, commentText, providerName, dateFormat.formatISO8601(commentItem.UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR), providerName, dateFormat.formatISO8601(commentItem.UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR), commentItem.UPDT_BY_ID, commentItem.UPDT_CNT, globalIndicator);
			this.saveComm.push(tempData);
		}

		// Build html for the comments returned by the script
		this.buildCommData();

		// Render the comments
		commentsTarget.append(this.buildHTML());

		// Attach delegate to events
		this.addDelegates(commentsTarget);
	}
	catch(err) {
		MP_Util.LogJSError(error, null, "ipass-comments.js", "renderComments");
		if (timerSitAwareRender) {
			timerSitAwareRender.Abort();
			timerSitAwareRender = null;
		}
		throw error;
	}
	finally {
		if (timerSitAwareRender) {
			timerSitAwareRender.Stop();
		}
	}
};

/**
 * This function object stores the comment details from PCT_IPASS table.
 * @param {string} stickyId : stores PCT_IPASS_ID.
 * @param {string} comment : stores TEXT.
 * @param {string} author : stores author name from UPDT_BY_ID.
 * @param {string} dtTm : stores UPDT_DT_TM.
 * @param {string} origAuthor : stores original author name from ORIG_UPDT_BY_ID.
 * @param {string} origDtTm : stores ORIG_BEGIN_DT_TM.
 * @param {string} origAuthId
 * @param {int} updCnt
 * @param (integer) gblInd : Global Indicator flag for the comment
 * @class IPASS Comments
 * @scope public
 */
IPASSComments.prototype.newComment = function(stickyId, comment, author, dtTm, origAuthor, origDtTm, origAuthId, updCnt, gblInd) {
	this.stickyId = stickyId;
	this.comment = comment;
	this.author = author;
	this.dtTm = dtTm;
	this.origAuthor = origAuthor;
	this.origDtTm = origDtTm;
	this.origAuthId = origAuthId;
	this.updCnt = updCnt;
	this.gblInd = gblInd;
};

/**
 * This function stores HTML for each comment in an array.
 * @class IPASS Comments
 * @scope public
 */
IPASSComments.prototype.buildCommData = function() {
	var uniqueId = this.m_uniqueId;
	var saveCommSize = this.saveComm.length;
	var commEditClass = "";
	var critInfo = this.getCriterion();
	var personnelId = critInfo.provider_id ? critInfo.provider_id : 0.0;
	for (var i = 0; i < saveCommSize; i++) {
		if (personnelId === this.saveComm[i].origAuthId) {
			commEditClass = "commEditable";
		}
		else {
			commEditClass = "";
		}
		var zebraStriping = i % 2 === 0 ? "ipass-sitaware-odd" : "ipass-sitaware-even";

		// Create a block for every comment , use zebra stripping
		var commentWrapper = "<div class='" + zebraStriping + " " + commEditClass + "' id='commCurComm" + i + uniqueId + "'>";

		// Show the actual comment, author name and date/time when the comment was added
		var commentData = "<dd class='ipass-sitaware-full'><span class='ipass-sitaware-itm' data-sitaware-update-count='" + this.saveComm[i].updCnt + "' data-sitaware-id='" + 
							this.saveComm[i].stickyId + "'data-ipass-sitaware-global-ind='" + this.saveComm[i].gblInd + "'><span class='ipass-sitaware-text'>" + 
							this.saveComm[i].comment + "</span><span class='ipass-sitaware-edit' id ='commEdit" + i + 
							uniqueId + "' data-index-val=" + i + 
							" data-ipass-sitaware-auth-id='" + 
							this.saveComm[i].origAuthId + "'>&nbsp;</span><span class='ipass-sitaware-del' data-index-val=" + i + 
							" id ='commDel" + i + uniqueId + "'>&nbsp;</span></span><span class='ipass-sitaware-prsnl-dt'>" + 
							this.saveComm[i].author + " " + this.saveComm[i].dtTm + "</span></dd></div>";
		var commentHTML = commentWrapper + commentData;
		this.htmlSave.push(commentHTML);
	}
};

/**
 * This function will build the comments html for the modal window.
 * @class IPASS Comments
 * @scope public
 */
IPASSComments.prototype.buildHTML = function() {
	var saveSize = this.htmlSave.length;
	var numberCommentsToShow = 0;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	var uniqueId = this.m_uniqueId;

	// Build out the content
	var sitAwareContent = "";
	var iPassI18N = i18n.discernabu.ipass;
	var filteredByHtml = "";

	// Add div for showing errors
	sitAwareContent += "<div id='ipassSitError" + uniqueId + "' class='ipass-pad ipass-sit-aware-err-msg hidden'></div>";

	//Add the text area
	sitAwareContent += this.textArea();

	//If there are no saved comments, display no comments and return
	if (!saveSize) {
		sitAwareContent += "<div id='commCurComm" + uniqueId + "'><ul><li class='ipass-sitaware-det'><span class='ipass-sitaware-none ipass-sitaware-text'>" + situationalAwarenessI18n.NO_COMMENTS_DOCUMENTED + "</span></li></ul></div>";
		//If careteam is enabled, we provide an All Teams option
		sitAwareContent += "<a id='ipassCommentsShowAll" + uniqueId + "' class='ipass-comments-show-all'>" + iPassI18N.ALL_TEAMS + "</a>";
		return sitAwareContent;
	}

	//Determine the number of comments to show face up
	numberCommentsToShow = this.dispShowAll ? saveSize : 4;
	numberCommentsToShow = Math.min(numberCommentsToShow, saveSize);

	//Create the html string content for each of the comments
	sitAwareContent += "<div id='commList" + uniqueId + "' class='ipass-sitaware-scroll'>";

	//Begin list of comments
	for (var i = 0; i < numberCommentsToShow; i++) {
		if (this.htmlSave[i]) {
			sitAwareContent += this.htmlSave[i];
		}
	}
	sitAwareContent += "</div>";
	//End list of comments

	//If we have 4 or less comments, just return with the content we have now
	if (saveSize <= 4) {
		sitAwareContent += "<a id='ipassCommentsShowAll" + uniqueId + "' class='ipass-comments-show-all'>" + iPassI18N.ALL_TEAMS + "</a>";
		return sitAwareContent;
	}

	//Create the show button content
	if (!this.dispShowAll) {
		sitAwareContent += "<a id='commShowAll" + uniqueId + "' class='ipass-sitaware-btn' href='#'>" + situationalAwarenessI18n.SHOWALLTEXT + " (" + saveSize + ")</a>";
	}
	else {
		sitAwareContent += "<a id='commShowThree" + uniqueId + "' class='ipass-sitaware-btn' href='#'>" + situationalAwarenessI18n.SHOWLESSTEXT + "</a>";
	}
	sitAwareContent += "<a id='ipassCommentsShowAll" + uniqueId + "' class='ipass-comments-show-all'>" + iPassI18N.ALL_TEAMS + "</a>";
	return sitAwareContent;
};

/**
 * This function builds the html for the textarea and previous comment header.
 * @class IPASS Comments
 * @scope private
 */
IPASSComments.prototype.textArea = function() {
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	var iPassI18n = i18n.discernabu.ipass;
	var saveText = [];
	var uniqueId = this.m_uniqueId;
	var self = this;
	
	saveText.push("<div id='commTextArea" + uniqueId + "' class='ipass-sitaware-text-area'><textarea id='commText" + uniqueId + 
	"' class='ipass-sitaware-new ipass-sitaware-text' rows='2' name='textarea' value='", situationalAwarenessI18n.ADD_NEW_COMMENT, "' maxlength='"+ 
	this.maxChars +"'>", situationalAwarenessI18n.ADD_NEW_COMMENT, "</textarea><div id='commSaveText" + uniqueId + 
	"' class='ipass-sitaware-savcan hidden'><span id='iPassSitAwareFieldMax" + uniqueId + "' class='ipass-sitaware-field-max'>"+this.maxChars+" ", 
	iPassI18n.CHARACTERS_LEFT,"</span>" + this.appendGlobalIndicatorElemt(false, 0) + 
	"<span class='comm-save ipass-sitaware-save'><input id='iPassSitAwareSaveButton" + uniqueId + 
	"' class='ipass-sitaware-savebutton' type='submit' name='sitawaresave' disabled value='", iPassI18n.SAVE, "'></input></span><span class='ipass-sitaware-savecancel'><input id='iPassSitAwareCancelButton" + 
	uniqueId + "' class='ipass-sitaware-cansavebutton' type='submit' name='sitawaresavecancel'  value='", iPassI18n.CANCEL, "'></input></span></div></div>");
	return saveText.join("");
};

/**
 * This function builds the html for the textarea and previous comment header.
 * @class
 * @scope public
 */
IPASSComments.prototype.editTextArea = function(inputText, globalInd) {
	var iPassI18n = i18n.discernabu.ipass;
	var saveText = [];
	var charsLeft = (this.maxChars - inputText.length);
	var textFull = "";
	var uniqueId = this.m_uniqueId;
	if (charsLeft <= 0) {
		textFull = "ipass-sitaware-field-textfull";
	}
	saveText.push("<div id='commTextArea" + uniqueId + "' class='ipass-sitaware-edit-text-area-container'><textarea id='commEditText" + uniqueId + 
	"' class='ipass-sitaware-edit-text-area ipass-sitaware-text' rows='6' name='textarea' maxlength='"+ this.maxChars +"'>" + inputText + 
	"</textarea><span class=' ipass-sitaware-separator-top'>&nbsp;</span><span class=' ipass-sitaware-separator-bottom'>&nbsp;</span><span id='iPassSitAwareEditFieldMax" + uniqueId + "' class='ipass-sitaware-field-max " + textFull + 
	"'>", charsLeft, " ", iPassI18n.CHARACTERS_LEFT, "</span><div id='commEditSaveFooter" + uniqueId + 
	"' class='ipass-sitaware-edit-footer'>" + this.appendGlobalIndicatorElemt(true, globalInd) + "<span class='comm-save ipass-sitaware-save'><input id='iPassSitAwareEditSaveButton" + uniqueId + 
	"' class='ipass-sitaware-savebutton' type='submit' name='sitawaresave' disabled value='", iPassI18n.SAVE, 
	"'></input></span><span class='ipass-sitaware-savecancel'><input id='iPassSitAwareEditCancelButton" + uniqueId + 
	"' class='ipass-sitaware-cansavebutton' type='submit' name='sitawaresavecancel'  value='", iPassI18n.CANCEL, "'></input></span></div></div>");
	return saveText.join("");
};

/**
 * Register the following events:
 *  1. Textarea is clicked
 *  2. keyup in the textarea
 *  3. Focus set outside of textarea
 *  4. Save button is clicked
 *  5. Cancel button is clicked
 *  6. 'Show All' link is clicked
 *  7. 'Show Less' link is clicked
 *  8. Comment is hovered over
 *  9. Mouse leave on the delete icon
 *  10. Delete icon is clicked
 */
IPASSComments.prototype.addDelegates = function(commentsTarget) {
	var uniqueId = this.m_uniqueId;
	var self = this;

	//This event executed when the textarea is clicked
	$("#commText" + uniqueId).on("click", function() {
		self.onTextBoxClick();
	});

	//This event executed when there is a keyup in the textarea
	$("#commText" + uniqueId).on("keyup", function(event) {
		self.commNewKeyUp(event, this);
	});
	
	//This event executed when there is a keydown in the textarea
	$("#commText" + uniqueId).on("keydown", function(event) {
		self.commNewKeyDown(event, this);
	});
	
	//This event executed for text area to return to initial state when focus set outside of textarea.
	$("#commText" + uniqueId).on("focusout", function(event) {
		self.onLostFocus(event, this);
	});
	
	//This event executed for text area to return to initial state when focus set inside the textarea.
	$("#commText" + uniqueId).on("focusin", function(event) {
		self.onGainFocus(event, this);
	});
	// This event executed when a Save button is clicked
	$("#iPassSitAwareSaveButton" + uniqueId).on("click", function() {
		self.saveComment($(this).parent());
	});

	// This event executed when a Cancel button is clicked
	$("#iPassSitAwareCancelButton" + uniqueId).on("click", function(event) {
		self.onCancelComment(event, this);
	});

	// This event executed when 'Show All' link is clicked
	$("#commShowAll" + uniqueId).on("click", function(event) {
		self.setShowAllClicked(true);
	});

	// This event executed when 'Show Less' link is clicked
	$("#commShowThree" + uniqueId).on("click", function(event) {
		self.setLastThreeClicked(true);
	});

	// This event executed when a comment is hovered over
	$(commentsTarget).on("mouseenter", ".ipass-sitaware-full", function(event) {
		$(event.currentTarget).find(".ipass-sitaware-del").addClass("ipass-sitaware-del-btn");
	});

	// This event executed when there is mouse leave on the delete icon
	$(commentsTarget).on("mouseleave", ".ipass-sitaware-full", function(event) {
		$(event.currentTarget).find(".ipass-sitaware-del").removeClass("ipass-sitaware-del-btn");
	});

	// This event executed when a comment is hovered over and the current user is the original author that comment
	$(commentsTarget).find(".commEditable").on("mouseenter", function(event) {
		$(event.currentTarget).find(".ipass-sitaware-edit").addClass("ipass-sitaware-edit-btn");
	});

	// This event executed when there is a mouse leave on a comment and the current user is the original author that comment
	$(commentsTarget).find(".commEditable").on("mouseleave", function(event) {
		$(event.currentTarget).find(".ipass-sitaware-edit").removeClass("ipass-sitaware-edit-btn");
	});

	// This event executed when the delete icon is clicked
	$(commentsTarget).on("click", ".ipass-sitaware-del", function(event) {
		var commentIndex = $(event.currentTarget).attr("data-index-val");
		self.deleteComment(commentIndex);
	});

	// This event executed when the edit icon is clicked
	$(commentsTarget).on("click", ".ipass-sitaware-edit", function(event) {
		var commentIndex = $(event.currentTarget).attr("data-index-val");
		self.editComment(commentIndex, this);
	});

	// function to display show all dialog.
	$("#ipassCommentsShowAll" + uniqueId).on("click", function() {
		self.launchShowAllCommentsModal();
	});
};

/**
 * Clear textarea value and color.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.onTextBoxClick = function() {
	var uniqueId = this.m_uniqueId;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;

	var textArea = $("#commText" + uniqueId);
	if (textArea.val() === situationalAwarenessI18n.ADD_NEW_COMMENT) {
		textArea.val("").css({
			color : "#000000"
		});
		$('#commText' + uniqueId).attr("rows",6);
		$('#commSaveText' + uniqueId).removeClass("hidden");
		
	}
};

/**
 * This function adds ability to change the save text color and cursor type when there is data and no data.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.commNewKeyUp = function(event, commNewObj) {
	 var uniqueId = this.m_uniqueId;
	var iPassI18n = i18n.discernabu.ipass;

	//This is the comment box
	var commentBox = $(commNewObj);
	var fieldMax = null;
	var saveButton = null;
	if (commentBox.hasClass("ipass-sitaware-edit-text-area")) {
		fieldMax = $("#iPassSitAwareEditFieldMax" + uniqueId);
		saveButton = $("#iPassSitAwareEditSaveButton" + uniqueId);
	}
	else {
		fieldMax = $("#iPassSitAwareFieldMax" + uniqueId);
		saveButton = $("#iPassSitAwareSaveButton" + uniqueId);
	}

	//Get the text in the comment box and trim and replace special characters
	var text = commentBox.val().replace(/^\s+/, "");
	
	//Get the number of characters in the text
	var numberCharacters = text.length;
	if (numberCharacters > this.maxChars) {
		commentBox.val(text.substr(0, this.maxChars));
	}

	//Make sure the character count is greater then 0 or disable the save button
	if (numberCharacters <= 0) {
		saveButton.prop("disabled", true);
	}
	else {
		saveButton.prop("disabled", false);
	}

	//Calculate the number of remaining characters
	var charactersRemaining = Math.max(this.maxChars - numberCharacters, 0);

	//Set the remaining characters value
	fieldMax.html(charactersRemaining + " " + iPassI18n.CHARACTERS_LEFT);
	if (!charactersRemaining) {
		fieldMax.addClass("ipass-sitaware-field-textfull");
	}
	else {
		fieldMax.removeClass("ipass-sitaware-field-textfull");
	}

	saveButton.prop("value", iPassI18n.SAVE);

	//If the box is empty
	if (!text) {
		saveButton.prop("disabled", true);
		return;
	}
	//If we have text, enable the save button
	saveButton.prop("disabled", false);
	
};

/**
 * This function adds ability to change the save text color and cursor type when there is data and no data.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.commNewKeyDown = function(event, commNewObj) {
	var uniqueId = this.m_uniqueId;
	var iPassI18n = i18n.discernabu.ipass;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	
	// Hide the error messages.
	var errorElement = $("#ipassSitError" + uniqueId);
	errorElement.addClass("hidden");
	errorElement.removeClass("ipass-err-adj");

	//This is the comment box
	var commentBox = $(commNewObj);
	var fieldMax = null;
	var saveButton = null;
	if (commentBox.hasClass("ipass-sitaware-edit-text-area")) {
		fieldMax = $("#iPassSitAwareEditFieldMax" + uniqueId);
		saveButton = $("#iPassSitAwareEditSaveButton" + uniqueId);
	}
	else {
		fieldMax = $("#iPassSitAwareFieldMax" + uniqueId);
		saveButton = $("#iPassSitAwareSaveButton" + uniqueId);
	}

	//Get the text in the comment box and trim and replace special characters
	var text = commentBox.val().replace(/^\s+/, "");

	//Get the number of characters in the text
	var numberCharacters = text.length;
	if (numberCharacters > this.maxChars) {
		commentBox.val(text.substr(0, this.maxChars));
	}

	//Make sure the character count is greater then 0 or disable the save button
	if (numberCharacters <= 0) {
		saveButton.prop("disabled", true);
	}
	else {
		saveButton.prop("disabled", false);
	}

	//Calculate the number of remaining characters
	var charactersRemaining = Math.max(this.maxChars - numberCharacters, 0);

	//Set the remaining characters value
	if (!charactersRemaining) {
		fieldMax.addClass("ipass-sitaware-field-textfull");
	}
	else {
		fieldMax.removeClass("ipass-sitaware-field-textfull");
	}

	saveButton.prop("value", iPassI18n.SAVE);

	//If the box is empty
	if (!text) {
		saveButton.prop("disabled", true);
		return;
	}
	//If we have text, enable the save button
	saveButton.prop("disabled", false);

	//When User presses "Ctrl+s", save the comment
	var code = 83;
	if (event && event.keyCode == code && text !== situationalAwarenessI18n.ADD_NEW_COMMENT) {
		if(event.ctrlKey) {		
		event.preventDefault(event);
		text = commentBox.val().replace(/\s+$/,"");
		this.saveComment(saveButton.parent());
	}
	}
	
};


/**
 * This function allows for editing of a comment
 * @param {string} commIndexVal : The index of comment to be used in removal from array
 * @class
 * @scope public
 */
IPASSComments.prototype.editComment = function(commIndexVal, objThis) {
	var uniqueId = this.m_uniqueId;
	var self = this;
	//Ensure only 1 edit is happening at a time
	if (!$("#commCurComm" + commIndexVal + uniqueId).hasClass("commEditable")) {
		return;
	}
	var prevEdit = $("#commList" + uniqueId).find(".ipass-sitaware-edit-action");
	if (prevEdit.length) {
		prevEdit.removeClass("ipass-sitaware-edit-action");
		prevEdit.find(".ipass-sitaware-text").removeClass("hidden");
		prevEdit.find(".ipass-sitaware-prsnl-dt").removeClass("hidden");
		prevEdit.find("#commTextArea" + uniqueId).remove();
	}
	var sitAwareText = $(objThis).siblings(".ipass-sitaware-text");
	
	//get current text for comment
	var commentText = sitAwareText.html().replace(/\s+$/,"");
	commentText = commentText.replace(/&nbsp\;/g, ' ');
	commentText = commentText.replace(/<br>/gi, "\n");

	//hide sitAwareText, author dt/tm
	sitAwareText.addClass("hidden");
	$(objThis).parent().siblings(".ipass-sitaware-prsnl-dt").addClass("hidden");
	
	//add border to parent
	$("#commCurComm" + commIndexVal + uniqueId).addClass("ipass-sitaware-edit-action");
	
	// Use the global indicator status that came with the response after insert to check the box
	var currentGlobalIndStatus = $("#commList" + uniqueId).find(".ipass-sitaware-edit-action").find(".ipass-sitaware-itm").attr("data-ipass-sitaware-global-ind");
	var commentTextArea = this.editTextArea(commentText, currentGlobalIndStatus);
	$(objThis).parent().append(commentTextArea);

	//This event executed when there is a keyup in the text edit area
	$("#commEditText" + uniqueId).on("keyup", function(event) {
		self.commNewKeyUp(event, this);
	});

	//This event executed when there is a keyup in the text edit area
	$("#commEditText" + uniqueId).on("keydown", function(event) {
		self.commNewKeyDown(event, this);
	});
	// This event executed when a Save button is clicked
	$("#iPassSitAwareEditSaveButton" + uniqueId).on("click", function() {
		self.saveComment($(this).parent());
	});

	// This event executed when a Cancel button is clicked
	$("#iPassSitAwareEditCancelButton" + uniqueId).on("click", function() {
		self.onCancelEditComment();
	});
	
	// Event executes when the "Available to All" checkbox is clicked
	
	$("#commList" + uniqueId).find(".ipass-global-input-cb").on("click", function() {
		var saveButtonStatus = $(this).closest(".ipass-sitaware-edit-footer").find(".ipass-sitaware-savebutton");
		if($(this).is(":checked")){
			saveButtonStatus.prop("disabled", false);
		}
		else{
			saveButtonStatus.prop("disabled", true);
		}
	}); 

};

/**
 * This function will save the comment to the PCT_IPASS table.
 * @param {object} buttonRef : this is the jquery object/element that was used to call this function
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.saveComment = function(buttonRef) {
	// Retrieve unique ID and criterion
	var uniqueId = this.m_uniqueId;
	var criterion = this.m_criterion;
	var self = this;

	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;

	//Get the text box
	var commentBox = null;
	var commentControls = null;
	var saveType = "";
	var updCnt = 0;
	var sitAwareId = 0.0;
	var updateInd = 0;
	var sitAwareItm = null;
	var buttonId = $(buttonRef).children(".ipass-sitaware-savebutton");
	var ipassCommentsTimer = null;
	var ipassCommentsCAPTimer = null;
	var globalOptionVal = 0;

	try {
		// Create user timer
		ipassCommentsTimer = new RTMSTimer("USR:MPG.IPASS_SIT_AWARE - Comments Actionability", this.getSubTimerName());

		if (buttonId.attr("id") == "iPassSitAwareEditSaveButton" + uniqueId) {
			commentBox = $("#commEditText" + uniqueId);
			commentControls = $("#commEditSaveFooter" + uniqueId);
			
			//Set the global indicator selected for Edit
			globalOptionVal = commentControls.find(".ipass-global-input-cb").is(":checked") ? 1 : 0;
			
			//CAP Timer for Global Indicator - Comments {CAP: MPG I-PASS Global}
			if(globalOptionVal){
				ipassCommentsCAPTimer = new CapabilityTimer("CAP: MPG I-PASS Global", this.getSubTimerName());
				if(ipassCommentsCAPTimer){
					ipassCommentsCAPTimer.addMetaData("rtms.legacy.metadata.1", "Comments: Global");
					ipassCommentsCAPTimer.capture();
				}
			}
			
			// Timer for Action Modify
			if (ipassCommentsTimer) {
				ipassCommentsTimer.addMetaData("rtms.legacy.metadata.1", "Comment Modify");
				ipassCommentsTimer.start();
			}
			
			saveType = "MODIFY";
			sitAwareItm = commentBox.parent().parent();
			updCnt = parseInt(sitAwareItm.attr("data-sitaware-update-count"), 10);
			sitAwareId = sitAwareItm.attr("data-sitaware-id");
			updateInd = 1;
		}
		else {
			commentBox = $("#commText" + uniqueId);
			commentControls = $("#commSaveText" + uniqueId);
			
			//Set the global indicator selected for Add
			globalOptionVal = commentControls.find(".ipass-global-input-cb").is(":checked") ? 1 : 0;
			
			//CAP Timer for Global Indicator - Comments {CAP: MPG I-PASS Global}
			if(globalOptionVal){
				ipassCommentsCAPTimer = new CapabilityTimer("CAP: MPG I-PASS Global", this.getSubTimerName());
				if(ipassCommentsCAPTimer){
					ipassCommentsCAPTimer.addMetaData("rtms.legacy.metadata.1", "Comments: Global");
					ipassCommentsCAPTimer.capture();
				}
			}
			
			// Timer for Actions Add
			if (ipassCommentsTimer) {
				ipassCommentsTimer.addMetaData("rtms.legacy.metadata.1", "Comment Add");
				ipassCommentsTimer.start();
			}
			saveType = "ADD";
		}

		//Get the text in the text box
		var commentText = commentBox.val().replace(/^\s+/, "");
		
		//If no text is entered, or the default "Add New" text is present, just return
		if (!commentText || commentText === "" || commentText === situationalAwarenessI18n.ADD_NEW_COMMENT) {
			return;
		}

		//disable comment box and save button
		commentBox.prop("disabled", true);
		commentBox.parent().find(".ipass-sitaware-savebutton").prop("value", " ").prop("disabled", true).addClass("ipass-save-image");

		//Only get the first 1000 characters
		var text = commentText.substr(0, this.maxChars);
		var encntrId = criterion.encntr_id;
		var personId = criterion.person_id ? criterion.person_id : 0.0;
		
		var refreshSaveComment = function(response) {
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			var providerName = "";

			if (response.getStatus() === "S") {
				var recordData = response.getResponse();
				var parentSitAware = $("#commList" + uniqueId).find(".ipass-sitaware-edit-action");
				var parentId = parentSitAware.attr("id");
				var sitAwareItm = parentSitAware.find(".ipass-sitaware-itm");
				//update the count
				sitAwareItm.attr("data-sitaware-update-count", recordData.RECORDS[0].UPDT_CNT);
				sitAwareItm.attr("data-ipass-sitaware-global-ind", recordData.RECORDS[0].GLOBAL_IND);
				var commentTextEdit = unescape(recordData.RECORDS[0].TEXT).replace(/\s+$/,"");
				// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
				commentTextEdit = commentTextEdit.replace(/ {2}/g, "&nbsp;&nbsp;");
				commentTextEdit = commentTextEdit.replace(/\n/g,"<br/>");
				
				//update the text and remove the hidden
				sitAwareItm.children(".ipass-sitaware-text").html(commentTextEdit).removeClass("hidden");
				//unhide author
				sitAwareItm.siblings(".ipass-sitaware-prsnl-dt").removeClass("hidden");
				//remove edit
				sitAwareItm.children(".ipass-sitaware-edit-text-area-container").remove();
				//remove edit formatting
				$("#" + parentId).removeClass("ipass-sitaware-edit-action");
				
			}
			else {
				MP_Util.LogScriptCallError(null, this, "ipass.js", "saveComment");
				self.alertConfirm(3);
			}
		};
		var ar = CERN_IPASS_O1.createJSONRequest(personId + ".0", encntrId + ".0", "0.0", "0.0", sitAwareId, "0.0", "COMMENT", saveType, "0.0", text, updCnt, "", globalOptionVal, 0, this.getSelectedCareTeamId() + ".0");
		if (updateInd === 1) {
			CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], ar, refreshSaveComment, false);
		}
		else {
			CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], ar, function(response) {
				self.updateSaveComment(response);
			}, false);
		}

		//Disable the following elements until the script returns
		commentBox.prop("disabled", true);
		commentControls.prop("disabled", true);
	}
	catch(err) {
		if (ipassCommentsCAPTimer) {
			ipassCommentsCAPTimer.fail();
			ipassCommentsCAPTimer = null;
		}
		if (ipassCommentsTimer) {
			ipassCommentsTimer.fail();
			ipassCommentsTimer = null;
		}
		MP_Util.LogJSError(err, self, "ipass-comments.js", "Comments Actionability Add/Modify");
		throw (err);
	}
	finally {
		if (ipassCommentsTimer) {
			ipassCommentsTimer.stop();
		}
	}
};

/**
 *  This function will update the comments list after a comment is added/deleted
 * @param{Object} response  Response from mp_upd_pct_ipass script call
 */
IPASSComments.prototype.updateSaveComment = function(response) {
	var self = this;
	var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	var providerName = "";
	var uniqueId = this.m_uniqueId;

	//Get the text box
	var commentBox = $("#commText" + uniqueId);
	var commentControls = $("#commSaveText" + uniqueId);

	if (response.getStatus() === "S") {
		var recordData = response.getResponse();

		//Reset the html storage array
		self.htmlSave = [];

		var providerData = response.getResponse().PRSNL[0];
		providerName = (providerData === null) ? "" : providerData.PROVIDER_NAME.NAME_FULL;
		
		var commentText = unescape(recordData.RECORDS[0].TEXT).replace(/\s+$/,"");
		// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
		commentText = commentText.replace(/ {2}/g, "&nbsp;&nbsp;");
		commentText = commentText.replace(/[\n]/g,"<br/>");

		var tempData = new self.newComment(recordData.RECORDS[0].PCT_IPASS_ID, commentText, providerName, df.formatISO8601(recordData.RECORDS[0].UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR), providerName, df.formatISO8601(recordData.RECORDS[0].UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR), recordData.RECORDS[0].UPDT_BY_ID, recordData.RECORDS[0].UPDT_CNT, recordData.RECORDS[0].GLOBAL_IND);
		self.saveComm.unshift(tempData);
		self.buildCommData();

		this.commentsTarget.html(this.buildHTML());
	}
	else {
		MP_Util.LogScriptCallError(null, this, "ipass-comments.js", "saveComment");
		this.alertConfirm(3);
	}
	//Re enable the following elements since the script has returned.
	commentBox.prop("disabled", false);
	commentControls.prop("disabled", false);

	// Attach delegate to events
	this.addDelegates(this.commentsTarget);
};

/**
 * Return text area to initial state when focus set outside of textarea.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.onLostFocus = function() {
	// Retrieve unique ID
	var uniqueId = this.m_uniqueId;
	var commentText = $("#commText" + uniqueId);
	var commentSaveText = $("#commSaveText" + uniqueId);
	
	if (commentText.val().replace(/^\s+/, "") === "") {
		var iPassI18n = i18n.discernabu.ipass;
		var saveTextContainer = commentSaveText;
		saveTextContainer.find(".error-icon-component").remove();
		saveTextContainer.addClass("hidden");
		saveTextContainer.find(".ipass-sitaware-savebutton").attr("value", iPassI18n.SAVE);	
		this.clearTextArea();
		commentText.attr("rows",2);
	}
	
};

/**
 * Set text area when focus set to textarea.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.onGainFocus = function() {
	// Retrieve unique ID
		var uniqueId = this.m_uniqueId;
		var iPassI18n = i18n.discernabu.ipass;
		var saveTextContainer = $("#commSaveText" + uniqueId);
		
		saveTextContainer.removeClass("hidden");
};

/**
 * Return text area to initial state.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.clearTextArea = function() {
	// Retrieve unique ID
	var uniqueId = this.m_uniqueId;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;

	$("#commText" + uniqueId).val(situationalAwarenessI18n.ADD_NEW_COMMENT).css({
		color : "#7c7c7c"
	});
};

/**
 * This function occurs when the cancel button is clicked for adding a comment. It performs several resets to ensure that
 * next time the user begins to add a comment, the visuals are correct.
 */
IPASSComments.prototype.onCancelComment = function() {
	// Retrieve unique ID
	var uniqueId = this.m_uniqueId;
	var iPassI18n = i18n.discernabu.ipass;

	var saveTextContainer = $("#commSaveText" + uniqueId);

	//If there is an error displayed, remove it.
	saveTextContainer.find(".error-icon-component").remove();

	//Hide the save/cancel controls
	saveTextContainer.addClass("hidden");

	//Reset the remaining character field
	$("#iPassSitAwareFieldMax" + uniqueId).html(this.maxChars+" "+ iPassI18n.CHARACTERS_LEFT).removeClass("hidden");

	//Disable the save button again
	$("#iPassSitAwareSaveButton" + uniqueId).attr("value", iPassI18n.SAVE).attr("disabled", "disabled");
	
	//Reset if max characters are entered
	$("#iPassSitAwareFieldMax" + uniqueId).removeClass("ipass-sitaware-field-textfull");

	//Clear out the text area
	this.clearTextArea();
	
	// Reset number of rows
	$("#commText" + uniqueId).attr("rows",2);

	// Hide the error messages
	var errorDivElement = $('#ipassSitError' + uniqueId);
	errorDivElement.addClass("hidden");
	errorDivElement.removeClass("ipass-err-adj");
};

/**
 * This function occurs when the cancel button is clicked for editing a comment.
 */
IPASSComments.prototype.onCancelEditComment = function() {
	var uniqueId = this.m_uniqueId;
	var openEdit = $("#commList" + uniqueId).find(".ipass-sitaware-edit-action");
	openEdit.removeClass("ipass-sitaware-edit-action");
	openEdit.find(".ipass-sitaware-text").removeClass("hidden");
	openEdit.find(".ipass-sitaware-prsnl-dt").removeClass("hidden");
	openEdit.find("#commTextArea" + uniqueId).remove();
};

/**
 * This function sets a variable if 'Show All' link is clicked for previous comments.
 * @param {boolean} val true = set dispShowAll=1. false = set dispShowAll=0.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.setShowAllClicked = function(val) {
	if (val) {
		this.dispShowAll = 1;
		this.commentsTarget.html(this.buildHTML());

		// Attach delegate to events
		this.addDelegates(this.commentsTarget);
	}
	else {
		this.dispShowAll = 0;
	}
};

/**
 * This function sets a variable if 'Show Less' link is clicked for previous comments.
 * @param {boolean} val true = set dispShowAll=0, false = set dispShowAll=1.
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.setLastThreeClicked = function(val) {
	if (val) {
		this.dispShowAll = 0;
		this.commentsTarget.html(this.buildHTML());

		// Attach delegate to events
		this.addDelegates(this.commentsTarget);
	}
	else {
		this.dispShowAll = 1;
	}
};

/**
 * This function initializes call to display delete confirmation window.
 * @param {string} commIndexVal The index of comment to be used in removal from array
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.deleteComment = function(commIndexVal) {

	var iPassI18n = i18n.discernabu.ipass;
	var uniqueId = this.m_uniqueId;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	var self = this;

	var commentList = $("#commList" + uniqueId);
	var existingDeleteComment = commentList.find(".ipass-sitaware-delete");
	

		//If a comment already has a delete confirm pane open
		if (existingDeleteComment.length) {
			existingDeleteComment.find(".ipass-sitaware-confirm-icon").remove();
			existingDeleteComment.find(".ipass-sitaware-delete-separator").remove();
			existingDeleteComment.removeClass("ipass-sitaware-delete");
		}
		//Get the comment dom object by using the index for an id
		var commentObject = $("#commCurComm" + commIndexVal + uniqueId);
		var commentItem = commentObject.find(".ipass-sitaware-itm");

		//If we try clicking the delete icon more than once (delete confirmation is already open)
		if (commentObject.hasClass("ipass-sitaware-delete")) {
			return;
		}

		//Add the delete styling to the element
		commentObject.addClass("ipass-sitaware-delete");

		//Create container to house delete confirmation dialog
		var separatorContainer = $("<div class = 'ipass-sitaware-delete-separator'><span class=' ipass-sitaware-separator-top'>&nbsp;</span><span class=' ipass-sitaware-separator-bottom'>&nbsp;</span></div>");
		var deleteConfirmationContainer = $("<div class='ipass-sitaware-confirm-icon' style='display: inline-block;'><span class='ipass-sitaware-del-confirm'>" + situationalAwarenessI18n.DELETECONFIRMTEXT + "</span></div>");
		var parentContainer = $("<div id='ipassSitBtnsContainer" + uniqueId + "' class='ipass-sitaware-btns-container'></div>");

		var confirmDeleteButton = $("<span class='ipass-sitaware-deletepad'><input class='ipass-sitaware-delbutton' type='submit' name='sitwaredel' value='" + iPassI18n.DELETE + "'></input></span>");
		var cancelDeleteButton = $("<span class='ipass-sitawarecancel'><input class='ipass-sitaware-cansavebutton' type='submit' name='ipass-sitaware-cancel' value='" + iPassI18n.CANCEL + "'></input></span>");

		//When the user clicks to confirm deletion of the comment. Only one delete can happen at a time.
		confirmDeleteButton.click(function(event) {
			self.commentDeleteFunction(commIndexVal, commentItem);
		});

		//When the user clicks to cancel deletion of the comment
		cancelDeleteButton.click(function() {
			separatorContainer.remove();
			deleteConfirmationContainer.remove();
			commentObject.removeClass("ipass-sitaware-delete");
			var errorDivElement = $('#ipassSitError' + uniqueId);
			errorDivElement.addClass("hidden");
			errorDivElement.removeClass("ipass-err-adj");
		});

		//Append elements to create the correct structure
		parentContainer.append(confirmDeleteButton);
		parentContainer.append(cancelDeleteButton);
		deleteConfirmationContainer.append(parentContainer);
		commentObject.append(separatorContainer);
		commentObject.append(deleteConfirmationContainer);

};

/**
 * This function will remove/inactivate the comment to the PCT_IPASS table.
 * @param {string} commIndexVal The index of comment to be used in removal from array
 * @param {object} commObj : the jquery object of the entire comment item div
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.commentDeleteFunction = function(commIndexVal, commObj) {
	//Retrieve the unique ID
	var uniqueId = this.m_uniqueId;
	var self = this;

	//If we already have a delete in progress, prevent further deletes
	if (this.deleteInProgress) {
		return;
	}

	//Set boolean to indicate we have a delete in progress
	this.deleteInProgress = true;

	var iPassI18n = i18n.discernabu.ipass;
	var updateCount = commObj.attr("data-sitaware-update-count");

	//Obtain the information about the note we are deleting
	this.commIndexVal = commIndexVal;
	var stickyId = self.saveComm[commIndexVal].stickyId;
	var commentTxt = self.saveComm[commIndexVal].comment;
	var ar = CERN_IPASS_O1.createJSONRequest(this.m_personId + ".0", this.m_encntrId + ".0", "0.0", "0.0", stickyId, "0.0", "COMMENT", "DELETE", "0.0", commentTxt, updateCount, "", 0, 0, "0.0");
	var ipassCommentsTimer = null;

	try {
		// Create user timer for Delete action
		ipassCommentsTimer = new RTMSTimer("USR:MPG.IPASS_SIT_AWARE - Comments Actionability", self.getSubTimerName());

		if (ipassCommentsTimer) {
			ipassCommentsTimer.addMetaData("rtms.legacy.metadata.1", "Comment Delete");
			ipassCommentsTimer.start();
		}
	CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], ar, function(response) {
		self.updateDelComment(response);
	}, false);
	}
	catch(err) {
		if (ipassCommentsTimer) {
			ipassCommentsTimer.fail();
			ipassCommentsTimer = null;
		}
		MP_Util.LogJSError(err, self, "ipass-comments.js", "Comments Actionability Delete");
		throw (err);
	}
	finally {
		if (ipassCommentsTimer) {
			ipassCommentsTimer.stop();
		}
	}
};

/**
 *  This function initializes adds a new comment to the comments list if there is a success while saving comment.
 * Also displays appropriate error message if there is any failure saving the comment.
 * @param {Object} response Response from mp_upd_pct_ipass script call
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.updateDelComment = function(response) {
	var recordData = response.getResponse();
	if (response.getStatus() === "S") {
		this.saveComm.splice(this.commIndexVal, 1);
		this.htmlSave = [];
		this.buildCommData();
		this.commentsTarget.html(this.buildHTML());
		//Attach delegates
		this.addDelegates(this.commentsTarget);
	}
	else {
		MP_Util.LogScriptCallError(null, this, "ipass-comments.js", "updateDelComment");
		this.alertConfirm(4, this.commIndexVal);
	}
	//Reset the delete in progress flag since we're finished.
	this.deleteInProgress = false;
};

/**
 * This function initializes call to display appropriate confirmation window.
 * @param {string} commAlertFlag : The alert confirm box to display
 * @param {string} control : The index of comment to be used in removal from array
 * @class IPASSComments
 * @scope public
 */
IPASSComments.prototype.alertConfirm = function(commAlertFlag, control) {
	var iPassI18n = i18n.discernabu.ipass;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	var situationalAssessmentErrorModal = null;
	var uniqueId = this.m_uniqueId;
	var errorMsg = "";

	var errorDivElement = $('#ipassSitError' + uniqueId);
	errorDivElement.removeClass("hidden");
	errorDivElement.addClass("ipass-err-adj");

	if (commAlertFlag === 3) {
		//Error saving a comment
		//Grab the save button and update it
		var saveButton = $("#iPassSitAwareSaveButton" + uniqueId);
		saveButton.attr("value", iPassI18n.RETRY);
		saveButton.prop("disabled", false);

		// Remove the loading icon
		$('#saveCommentsLoading' + uniqueId).removeAttr("src");

		//show in-line error message
		errorMsg = iPassI18n.UNABLE_TO_SAVE;
		errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
		errorDivElement.html(errorHTML);
	}
	else if (commAlertFlag === 4) {
		//Error deleting a comment
		//show in-line error message
		errorMsg = situationalAwarenessI18n.UNABLEDELTEXT;
		errorHTML = MP_Core.generateUserMessageHTML("error", errorMsg, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
		errorDivElement.html(errorHTML);

	}
	else {
		// do nothing
	}
};

/**
 * Helper function to create global indicator HTML with default checked flexed based on list type
 * @param isEdit [OPTIONAL] boolean - used to determine if global indicator is for an edit
 * @param globalInd [OPTIONAL] number - indicates if the current edit item is a global
 * @return {string} globalIndHTML - HTML string for the global indicator checkbox
 */

IPASSComments.prototype.appendGlobalIndicatorElemt = function(isEdit, gblInd) {
	var globalIndHTML = "";
	var checkedHTML = "";
	var toolTipText = "";
	var disabledHTML = "";
	var globalInd = parseInt(gblInd,10);
	var iPassI18n = i18n.discernabu.ipass;
	//If lookback value is set then the global indicator checkbox wont be shown and it would essentially behave with a Cross encounter pref
	if(this.getLookbackVal()){
		return "";
	}
	else if(this.getCrossEncIndicatorVal()){
		return "";
	}
	//if the item is from an edit and currently a global, default the checkbox to checked and dither since it cannot be changed
	if (isEdit) {
		if (globalInd === 1) {
			checkedHTML = " checked='checked'";
			disabledHTML = " disabled='disabled'";
		}
	}
	//If patient list it is populated checkbox will be checked by default
	else if (0.0 === (parseFloat(this.getSelectedCareTeamId())) || globalInd) {
		checkedHTML = " checked='checked'";
	}
	toolTipText = iPassI18n.AVAILABLE_TO_ALL_TOOLTIP_COMMENT;
	globalIndHTML += '<label class="ipass-global-label" title="' + toolTipText + '"><input type="checkbox" class="ipass-global-input-cb"' + checkedHTML + disabledHTML + ' />' + iPassI18n.AVAILABLE_TO_ALL + '</label>';
	return globalIndHTML;
};
/**
 * Function to display all teams modal dialog. 
 * 
 */
IPASSComments.prototype.launchShowAllCommentsModal = function() {

	var self =this;
	var uniqueId = this.getUniqueId();
	//If the modal has already been created, just show it.
	var ipassCommentsModalDialog = MP_ModalDialog.retrieveModalDialogObject("ipassAllCommentsModal" + uniqueId);
	if (ipassCommentsModalDialog) {
		ipassCommentsModalDialog.isDisplayCommentsDialog = (self.getCrossEncIndicatorVal() ===1)? true:false; 
		MP_ModalDialog.showModalDialog(ipassCommentsModalDialog.getId());
		$("#ipassAllCommentsModalHeader").addClass("ipass-sitaware-modal-header");
		return;
	}

	//Internationalization variables
	var ipassI18N = i18n.discernabu.ipass;
	var ipassCommentsI18N = i18n.discernabu.ipass_sit_aware;
	var marginValue = 15;
	var criterion = self.getCriterion();	
	if (!criterion.encntr_id) {
		throw new Error("Error, no encounter id found, cannot retrieve all actions");
	}

	//Create the show all modal
	var showAllModal = new ModalDialog("ipassAllCommentsModal" + uniqueId);
	showAllModal.setHeaderElementId("ipassAllCommentsModalHeader");
	showAllModal.setBodyElementId("ipassAllCommentsModalBody");
	showAllModal.setFooterElementId("ipassAllCommentsModalFooter");
	showAllModal.setTopMarginPercentage(marginValue).setRightMarginPercentage(marginValue).setBottomMarginPercentage(marginValue).setLeftMarginPercentage(marginValue);
	showAllModal.setHeaderTitle(ipassCommentsI18N.SITUATIONAL_AWARENESS_PLAN);
	showAllModal.setShowCloseIcon(true);
	showAllModal.isDisplayCommentsDialog = (self.getCrossEncIndicatorVal() ===1)? true:false;

	var tableBodyPaddingBuffer = 10;

	//Helper function to size the body of the table to enable scrolling
	function calculateTableHeight(modalBody, tableHeader) {
		return modalBody.height() - tableHeader.height() - tableBodyPaddingBuffer;
	}

	//Helper function to create table columns
	function createCommentsTableColumn(columnId, columnDisplay, sortable, primarySortField, renderTemplate, customClass) {
		return new TableColumn().setColumnId(columnId).setColumnDisplay(columnDisplay).setIsSortable(sortable).setPrimarySortField(primarySortField).setRenderTemplate(renderTemplate).setCustomClass(customClass);
	}
	
	// Replaces carriage return and spaces with their HTML equivalents
	function convertTextSpacingToHTML(text) {
		return text.replace(/ {2}/g, "&nbsp;&nbsp;").replace(/[\n]/g, "<br/>");
	}

	//Create the component table that will be shown inside the modal
	var allCommentsTable = new ComponentTable();
	allCommentsTable.setNamespace("ipassAllComments");
	allCommentsTable.setCustomClass("ipass-component-table");
	allCommentsTable.addColumn(createCommentsTableColumn("SERVICE", ipassI18N.MEDICAL_SERVICE, true, "CARETEAM_DISPLAY", '${ CARETEAM_DISPLAY }', "ipass-comments-service"));
	allCommentsTable.addColumn(createCommentsTableColumn("TEXT", ipassCommentsI18N.AWARENESS_AND_PLANNING, false, "TEXT", '${ TEXT }', "ipass-comments-text"));
	allCommentsTable.addColumn(createCommentsTableColumn("AUTHOR", ipassI18N.AUTHOR, true, "PERSONNEL_DISPLAY", '${ PERSONNEL_DISPLAY }', "ipass-comments-author"));
	allCommentsTable.addColumn(createCommentsTableColumn("DATE", ipassI18N.DATE, true, "UPDT_DATE", '${ DATE_DISPLAY }', "ipass-comments-date"));

	//Set the function responsible for rendering the contents of the modal
	showAllModal.setBodyDataFunction(function() {
		var criterion = self.getCriterion();
		var encounterId = (criterion.encntr_id)? criterion.encntr_id:0;
		var logicalDomainId = (criterion.logical_domain_id)? criterion.logical_domain_id:0;
		var allCommentsList = [];
		var modalElement = $("#vwpModalDialog" + showAllModal.getId());
		//Add the wf class to the root of the modal so we can inherit standard styles
		modalElement.addClass("wf");

		//Grab the modal body element by id
		var modalBody = $("#" + showAllModal.getBodyElementId());
		//Add the wf class to the body so the component table will correctly inherit all necessary css styling

		var modalHead = $("#" + showAllModal.getHeaderElementId());
		modalHead.addClass("sec-hd");

		//First, we give the modal dialog a spinner to show that it is loading data
		modalBody.html("<div class='preloader-modal'></div>");
		var cclParams = ["^MINE^", criterion.person_id + ".0", encounterId + ".0", "0.0", "^COMMENT^", 0, "0.0", "-1", logicalDomainId + ".0"];
		var programName = "MP_RETRIEVE_IPASS_PERSON";
		var allCommentsRequest = new ScriptRequest();
		allCommentsRequest.setProgramName(programName);
		allCommentsRequest.setParameterArray(cclParams);
		allCommentsRequest.setResponseHandler(function (allCommentsReply){
			try {
				var allCommentsResponseStatus = allCommentsReply.m_status;				
				//If there was some error performing the ccl mp_retrieve_ipass call
				if (allCommentsResponseStatus !== "S" && allCommentsResponseStatus !== "Z") {
					throw new Error("There was an error processing mp_retrieve_ipass_person, please check blackbird to verify the ccl parameters and response");
				}
				//If the modal has been closed since we fired off the request, do nothing
				if (!showAllModal.getIsActive()) {
					return;
				}
				//Helper function to process the list of comments returned by the script
				function processCommentsList(commentsList) {
					var numberOfComments = commentsList.length;
					for (var i = 0; i < numberOfComments; i++) {
						var comment = commentsList[i];
						var dateTimeString = "--";
						if (comment.UPDT_DATE) {
							var dateTime = new Date();
							dateTime.setISO8601(comment.UPDT_DATE);
							dateTimeString = MP_Util.GetDateFormatter().format(dateTime, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
						}
						comment.DATE_DISPLAY = dateTimeString;
						var commentPersonnel = personnelMapping[comment.UPDT_BY_ID];
						comment.PERSONNEL_DISPLAY = commentPersonnel ? commentPersonnel.PROVIDER_NAME.NAME_FULL : "";
						//If a care team is associated to the result, display that information, otherwise it belongs to patient lists
						var commentCareTeam = careTeamMapping[comment.PCT_CARE_TEAM_ID];

						if (commentCareTeam) {
							comment.CARETEAM_DISPLAY = careTeamMapping[comment.PCT_CARE_TEAM_ID].CTEAM_DETAILS.DISPLAY_NAME_HTML;
						} else {
							comment.CARETEAM_DISPLAY = ipassI18N.PATIENT_LISTS;
						}
						
						var commentText = unescape(comment.TEXT);
						// below double space regex pattern replaces carriage return and spaces with their HTML equivalents
						commentText = commentText.replace(/ {2}/g, "&nbsp;&nbsp;");
						commentText = commentText.replace(/[\n]/g,"<br/>");
						comment.TEXT = commentText;

						allCommentsList.push(comment);
					}
				}
				
				var allCommentsResponse = allCommentsReply.m_responseData;								
				//Grab the list of encounters from the response
				var encounterList = allCommentsResponse.SELECTED_ENCOUNTER_ID;
				var numberOfEncounters = encounterList.length;
				//Grab the list of personnel from the response and map them by IDs so we can easily access them
				var personnelList = allCommentsResponse.PRSNL;
				var numberOfPersonnel = personnelList.length;
				var careTeamList = allCommentsResponse.CARE_TEAMS;
				var numberOfCareTeams = careTeamList.length;
				var personnelMapping = {};
				var careTeamMapping = {};
				//Create a mapping of personnel ids to the personnel object
				for (var i = 0; i < numberOfPersonnel; i++) {
					personnelMapping[personnelList[i].ID] = personnelList[i];
				}
				//Create a mapping of careteam ids to the careteam object
				for (var i = 0; i < numberOfCareTeams; i++) {
					careTeamMapping[careTeamList[i].ID] = careTeamList[i];
				}

				processCommentsList(allCommentsResponse.COMMENTS || []);

				if (showAllModal.isDisplayCommentsDialog && allCommentsResponseStatus === "S") {
					modalHead.append("<div class='ipass-sitaware-selected-visits'>" + i18n.discernabu.SELECTED_VISIT +"&nbsp;&nbsp;"+ "</div>");
				}

				//Bind the data to the table
				allCommentsTable.bindData(allCommentsList);
				allCommentsTable.sortByColumnInDirection("DATE", TableColumn.SORT.DESCENDING);

				modalBody.html(allCommentsTable.render());

				  
				//Grab some of the table elements since we'll be needing them for resizing
				var tableHeader = $("#ipassAllCommentsheaderWrapper");
				var tableBody = $("#ipassAllCommentstableBody");
				$("#ipassAllCommentstable").css({
					"margin-top" : "5px"
				});
				//Set the initial max-height of the table body so scrolling is correctly applied
				tableBody.css({
					"max-height" : calculateTableHeight(modalBody, tableHeader) + "px",
					"overflow-y" : "auto"
				});
				allCommentsTable.updateAfterResize();
				//Call to finalize the table, attaching all event listeners
				allCommentsTable.finalize();

				//Attach the window resize listener to ensure correct visual styling and scrolling
				$(window).on("resize.ipassComments", function() {
					tableBody.css({
						"max-height" : calculateTableHeight(modalBody, tableHeader) + "px"
					});
					allCommentsTable.updateAfterResize();
				});
			} catch(exe) {
				modalBody.html(MP_Util.HandleErrorResponse("ipassAllComments", exe.message));
			}
		});
		
		allCommentsRequest.performRequest();

	});

	//Create the modal buttons
	var closeButton = new ModalButton("ipassAllCommentsModalClose");
	//Provide a custom handler
	closeButton.setOnClickFunction(function() {
		$(window).unbind(".ipassComments");
	});
	closeButton.setCloseOnClick(true);
	closeButton.setText(ipassI18N.CLOSE);

	//Add buttons to the modal
	showAllModal.addFooterButton(closeButton);

	//Make call to the modal framework to display the modal
	MP_ModalDialog.addModalDialogObject(showAllModal);
	MP_ModalDialog.showModalDialog(showAllModal.getId());
	/* ***************
	 *  This css class would be used to get the alignment right for close button in
	 *	modal dialog 
	 * *************** */

	$("#ipassAllCommentsModalHeader").addClass("ipass-sitaware-modal-header");
};
/**
 * IPASS methods
 * @namespace CERN_IPASS_O1
 * @static
 * @global
 */

var CERN_IPASS_O1 = {
	personnelArray : [],
	iPassI18n : i18n.discernabu.ipass,
	actionsI18N : i18n.discernabu.ipass_actions,
	situationalAwarenessI18n : i18n.discernabu.ipass_sit_aware,
	iPassRef : null,
	criterion : null,
	viewpointNameKey : "",
	careTeamEnabled : false,
	selectedCareTeamId : "0",
	careTeams : null,
	careTeamMapping : null,
	iPassCareteamSelector : null,
	iPassActions : null,
	iPassComments : null,
	viewpointCriterionObj : null
};
/**
 * Gets the Care Team Id that is currently selected in the IPASS component
 */
CERN_IPASS_O1.getSelectedCareTeamId = function() {
	return CERN_IPASS_O1.selectedCareTeamId;
};

/**
 * Sets the Care Team Id that is currently selected in the IPASS component
 * @param careTeamId the id of the care team that
 */
CERN_IPASS_O1.setSelectedCareTeamId = function(careTeamId) {
	CERN_IPASS_O1.selectedCareTeamId = careTeamId;
};

/**
 * This function is used to retrieve the name of the viewpoint that the ipass utility is being shown in
 */
CERN_IPASS_O1.getViewpointNameKey = function() {
	//Check to see if we have already retreived the name
	if (this.viewpointNameKey) {
		return this.viewpointNameKey;
	}
	try {
		this.viewpointNameKey = JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME_KEY;
		return this.viewpointNameKey;
	}
	catch (error) {
		MP_Util.LogJSError(error, null, "ipass.js", "init");
		return "";
	}
};
CERN_IPASS_O1.initIPassComponent = function(iconCommElementId, careTeamEnabled) {

	var IPASS_CONT_PADDING = 25;
	var IPASS_MENU_WIDTH = 600;

	CERN_IPASS_O1.careTeamEnabled = careTeamEnabled;

	//Grab the viewpoint utilities icon and update the class
	var vwpIcon = $("#" + iconCommElementId);
	if (vwpIcon.length) {
		$(vwpIcon).addClass("ipass-util-icon");
	}
	
	//Add title to the icon and indicator holder to display tool tip
	var iPassMenuAnchor = $(vwpIcon).parent();
	iPassMenuAnchor.attr("title", this.iPassI18n.I_PASS);
	
	//Initiate the script request to retrieve illness severity and display the illness severity indicator on the page load
	CERN_IPASS_O1.criterion = JSON.parse(m_criterionJSON).CRITERION;
	CERN_IPASS_O1.viewpointCriterionObj = new MP_Core.Criterion(CERN_IPASS_O1.criterion, CERN_IPASS_O1.criterion.STATIC_CONTENT);
	var encounterID = (CERN_IPASS_O1.criterion.ENCNTRS.length) ? CERN_IPASS_O1.criterion.ENCNTRS[0].ENCNTR_ID + ".0" : 0;
	var logicalDomainId = CERN_IPASS_O1.criterion.LOGICAL_DOMAIN_ID;
	var personId = CERN_IPASS_O1.criterion.PERSON_ID;
	var cclParam = [];
	cclParam.push("^MINE^", personId + ".0", encounterID, "0.0", '"ILLSEVERITY"', 1, "0.0", "0.0", logicalDomainId + ".0");
	CERN_IPASS_O1.loadWithCBParameters("mp_retrieve_ipass_person", cclParam, null, CERN_IPASS_ILL_SEVERITY_O1.displayIllnessSeverityIndicator, true);

	//Create the menu that will be associated with the iPass Utility icon
	if (iPassMenuAnchor.length) {
		var iPassMenu = new UtilitiesMenu("vwpComments");
		iPassMenu.setWidth(IPASS_MENU_WIDTH);
		iPassMenu.setAnchorElementId($(iPassMenuAnchor).attr("id"));
		iPassMenu.setTypeClass("utilities-menu-override ipass-menu-override");
		iPassMenu.setUtilitiesContentCreationFunction(function() {
			//Make sure each time I-PASS is opened, the selected care team id is reset to 0
			CERN_IPASS_O1.setSelectedCareTeamId("0");
			//Create the main container with the gradient div at the top
			var iPassContent = $("<div id='iPassContent' class='ipass-dialog'><div id='ipassPreloader' class='preloader-modal'></div><div class='ipass-gradient'>&nbsp;</div></div>");
			CERN_IPASS_O1.iPassRef = iPassContent;
			return CERN_IPASS_O1.iPassRef;
		});
		//Add the menu object to the MenuManager
		MP_MenuManager.addMenuObject(iPassMenu);
		iPassMenuAnchor.click(function() {
			var iPASSClickTimer = MP_Util.CreateTimer("CAP:MPG.IPASS");
			if (iPASSClickTimer) {
				iPASSClickTimer.Stop();
			}
			if (iPassMenu.isVisible()) {
				MP_MenuManager.closeMenuStack();
			}
			else {
				var iPassModalHeight = $('#vwpBody').height() - IPASS_CONT_PADDING;
				iPassMenu.setMaxHeight(iPassModalHeight);
				MP_MenuManager.showMenu("vwpComments");
				//Render the I-PASS content
				CERN_IPASS_O1.renderIPass(CERN_IPASS_ILL_SEVERITY_O1.replyObj);
			}
		});
	}
};

/**
 * This renders the careteam dropdown selector
 */
CERN_IPASS_O1.renderCareTeamSelector = function() {
	var criterion = CERN_IPASS_O1.criterion;
	var encounterId = criterion.ENCNTRS[0].ENCNTR_ID;
	var personId = criterion.PERSON_ID;
	var categoryMean = criterion.CATEGORY_MEAN;
	var logicalDomainId = criterion.LOGICAL_DOMAIN_ID;
	var ipassI18N = i18n.discernabu.ipass;
	var responseStatus = null;
	var reply = null;

	var ipassMenu = MP_MenuManager.getMenuObject("vwpComments");
	var menuContentElement = $("#menuContentvwpComments");
	// Cache the filtered by text container for actions and comments components
	var ipassActionsFilteredBy = $("#ipassActionsFilteredBy");
	var ipassCommentsFilteredBy = $("#ipassCommentsFilteredBy");
	var ipassPatSummFilteredBy = $("#ipassPatSummFilteredBy");

	// Cache the component wrappers for actions and comments components
	var ipassActionsWrapper = $('#ipassActionsContentWrapper');
	var ipassCommentsWrapper = $('#ipassCommentsContentWrapper');
	var ipassPatSumWrapper = $('#ipassPatSumContentWrapper');

	var careteamSelector = new CareTeamSelector();
	careteamSelector.setCriterion(CERN_IPASS_O1.viewpointCriterionObj);
	careteamSelector.setUniqueId("ipassCareteamSelector" + categoryMean);
	careteamSelector.setCareTeamSelectMsg(ipassI18N.PAT_SUM_ACT_COMM);

	//Helper function to refresh I-PASS after selecting a care team
	function updateFilterText(selectedCareTeamId) {
		//If you have selected an actual care team
		if (selectedCareTeamId !== "0") {
			var selectedText = careteamSelector.getSelectedCareTeamDisplay();
			
			var selectObj = careteamSelector.getSelectedCareTeamObject();
			var selectedMedService = selectObj.PCT_MED_SERVICE_DISPLAY; //still need to ensure (All Facilities) is present if needed
			
			selectedText += ((careteamSelector.isMedicalService(selectedCareTeamId)) ? (" (" + ipassI18N.ALL_TEAMS + ")") : "");
			ipassActionsFilteredBy.attr("title", selectedText).html(ipassI18N.FILTERED_BY + ":&nbsp;" + ipassI18N.CARE_TEAM);
			ipassCommentsFilteredBy.attr("title", selectedText).html(ipassI18N.FILTERED_BY + ":&nbsp;" + ipassI18N.CARE_TEAM);
			ipassPatSummFilteredBy.attr("title", selectedMedService).html(ipassI18N.FILTERED_BY + ":&nbsp;" + ipassI18N.MEDICAL_SERVICE);
		}
		else {
			ipassActionsFilteredBy.removeAttr("title").empty();
			ipassCommentsFilteredBy.removeAttr("title").empty();
			ipassPatSummFilteredBy.removeAttr("title").empty();
		}
	}

	//empties the actions, comments, and patient summary sections and sets selected team to 0
	var emptyPatSumActionsAndCommentsSections = function() {
		var careTeamId = "0";
		ipassActionsWrapper.empty();
		ipassCommentsWrapper.empty();
		ipassPatSumWrapper.empty();
		updateFilterText(careTeamId);
		CERN_IPASS_O1.setSelectedCareTeamId(careTeamId);
	};

	//Function to handle rendering of Actions, Comments, and Patient Summary section based on the reply from mp_retrieve_ipass_person
	var loadPatSumActionsAndCommentsCallback = function(careTeamsIPassReply) {
		try {
			//If for some reason the IPASS menu was closed while making this request, do nothing
			if (!ipassMenu.isVisible()) {
				return;
			}
			var careTeamObj = careteamSelector.getSelectedCareTeamObject();
			var careTeamId = "";
			if (careTeamObj) {
				careTeamId = careTeamObj.PARENT_CARE_TEAM_ID;
			} else {
				careTeamId = "0";
			}
			reply = careTeamsIPassReply.getResponse();
			responseStatus = reply.STATUS_DATA.STATUS;
			CERN_IPASS_O1.personnelArray = MP_Util.LoadPersonelListJSON(reply.PRSNL);
			//If there was some sort of problem performing the ccl call
			if (responseStatus !== "S" && responseStatus !== "Z") {
				throw new Error("Failed to retrieve IPASS information for the selected careteam");
			}
			//Store off the selected care-team id since other actions will require it
			CERN_IPASS_O1.setSelectedCareTeamId(careTeamId);
			ipassActionsWrapper.empty();
			ipassCommentsWrapper.empty();
			ipassPatSumWrapper.empty();
			
			//Refresh the actions section
			CERN_IPASS_O1.iPassActions.setSelectedCareTeamId(careTeamId);
			
			//Set the cross encounter indicator values to be used in renderComponent
			CERN_IPASS_O1.iPassActions.setCrossEncIndicatorVal(careteamSelector.getSelectedCareTeamXEncInd());
			
			CERN_IPASS_O1.iPassActions.renderActions(reply, ipassActionsWrapper);

			//Refresh the Comments section
			CERN_IPASS_O1.iPassComments.setSelectedCareTeamId(careTeamId);
			
			//Set the cross encounter indicator values to be used in renderComponent
			CERN_IPASS_O1.iPassComments.setCrossEncIndicatorVal(careteamSelector.getSelectedCareTeamXEncInd());
			
			CERN_IPASS_O1.iPassComments.renderComments(reply, ipassCommentsWrapper);
			
			//Refresh the Patient Summary section
			CERN_PATSUM_O1.findSelectedGrandParentCareTeamId(careTeamObj);
			CERN_PATSUM_O1.renderPatientSummary(reply.PATIENT_SUMMARY, ipassPatSumWrapper);
			
			updateFilterText(careTeamId);
		}
		catch (exe) {
			MP_Util.LogJSError(exe, null, "ipass.js", "loadPatSumActionsAndCommentsCallback");
			throw exe;
		}
	};

	// Add error html to error div and then show the error message
	var displayErrorMessage = function(errorMessage, errorContainer) {
		var errorHTML = MP_Core.generateUserMessageHTML("error", errorMessage, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
		errorContainer.removeClass("hidden");
		errorContainer.addClass("ipass-err-adj");
		errorContainer.html(errorHTML);
	};

	// Create the error messages for Actions/Comments if an error occurs
	var generateErrorMessages = function() {
		// Check for error containers
		var actionsErrorContainer = ipassActionsWrapper.find('.ipass-action-err-msg');
		var commentsErrorContainer = ipassCommentsWrapper.find('.ipass-sit-aware-err-msg');
		// If error containers don't exist, append them to wrapper
		if (!actionsErrorContainer.length) {
			actionsErrorContainer = $("<div class='ipass-pad ipass-action-err-msg ipass-err-adj'></div>");
			ipassActionsWrapper.append(actionsErrorContainer);
		}

		if (!commentsErrorContainer.length) {
			commentsErrorContainer = $("<div class='ipass-pad ipass-sit-aware-err-msg ipass-err-adj'></div>");
			ipassCommentsWrapper.append(commentsErrorContainer);
		}
		// Display desired error messages within each component
		displayErrorMessage(CERN_IPASS_O1.actionsI18N.ERROR_ACTION_LOAD, actionsErrorContainer);
		displayErrorMessage(CERN_IPASS_O1.situationalAwarenessI18n.COMMFAILTEXT, commentsErrorContainer);
	};

	//Function to handle updates to Actions, Comments, and Patient Summary after a careteam has been selected
	var selectCareTeam = function() {
		var careTeamId = careteamSelector.getSelectedCareTeamId();
		//If the current careteam id is 0 AND a careteam is assigned to this provider, don't show Comments and Actions sections
		if (careTeamId == "0") {
			emptyPatSumActionsAndCommentsSections();
			return;
		}

		//resets to previous careteam if query fails
		var resetCareTeams = function() {
			generateErrorMessages();
			var careTeamId = CERN_IPASS_O1.getSelectedCareTeamId();
			careteamSelector.selectCareTeamById(careTeamId);
			CERN_IPASS_O1.iPassComments.setSelectedCareTeamId(careTeamId);
			CERN_IPASS_O1.iPassActions.setSelectedCareTeamId(careTeamId);
			updateFilterText(careTeamId);
		};

		requestPatSumActionsAndComments(careTeamId, resetCareTeams);
	};

	/**
	 * Handles creation of actions, comments, and patient summary sections
	 * @param  {Number} careTeamId id Of the care team to return Actions and Comments for
	 * @param  {Function} errorHandling function that is executed when query fails
	 */
	var requestPatSumActionsAndComments = function(careTeamId, errorHandling) {
		//disable selector until request completes
		careteamSelector.setSelectorDisabledProperty(true);
		ipassActionsFilteredBy.empty().addClass("ipass-careteam-preloader");
		ipassCommentsFilteredBy.empty().addClass("ipass-careteam-preloader");
		ipassPatSummFilteredBy.empty().addClass("ipass-careteam-preloader");
		var retrieveActionsCommentsScript = new MP_Core.ScriptRequest();
		retrieveActionsCommentsScript.setProgramName("MP_RETRIEVE_IPASS_PERSON");
		retrieveActionsCommentsScript.setParameters(["^MINE^", personId + ".0", encounterId + ".0", "0.0", MP_Util.CreateParamArray(["\"PATSUMMARY\"", "\"ACTION\"", "\"COMMENT\""]), 0, "0.0", careTeamId + ".0", logicalDomainId + ".0"]);
		retrieveActionsCommentsScript.setAsync(true);
		retrieveActionsCommentsScript.setExecCallback(true);

		//Actually perform the script and handle the response
		MP_Core.XMLCCLRequestCallBack(null, retrieveActionsCommentsScript, function(careTeamsIPassReply) {
			try {
				loadPatSumActionsAndCommentsCallback(careTeamsIPassReply);
			}
			catch(error) {
				errorHandling(error);
			}
			finally {
				//re-enable selector after actions/comments data is loaded
				careteamSelector.setSelectorDisabledProperty(false);
				ipassActionsFilteredBy.removeClass("ipass-careteam-preloader");
				ipassCommentsFilteredBy.removeClass("ipass-careteam-preloader");
				ipassPatSummFilteredBy.removeClass("ipass-careteam-preloader");
			}
		});
	};

	//Function to handle updates to Action, Comments, and Patient Summary after careteams have been loaded
	var loadCareTeamsCallback = function() {
		var careTeamId = careteamSelector.getSelectedCareTeamId();
		var careteamCnt = careteamSelector.getCareteamCount();

		// If no careteams assigned to provider, behave as before (retrieve data using 0.0 row)
		if (!careteamCnt) {
			requestPatSumActionsAndComments(0, generateErrorMessages);
		}
		else {
			//If no care team selected, show empty Actions and Comments sections
			if (careTeamId == "0") {
				emptyPatSumActionsAndCommentsSections();
				return;
			}
			//Use requestPatSumActionsAndComments to load Actions/Comments based on currently selected careTeam
			requestPatSumActionsAndComments(careTeamId, generateErrorMessages);
		}
	};

	/*Selected change function will perform the following actions:
	 1. Use the selected care team id to make a request to get ipass information
	 2. Reload components based on the response
	 */
	careteamSelector.setOnCareteamLoadFunc(loadCareTeamsCallback);
	careteamSelector.setOnSelectorChangeFunc(selectCareTeam);

	//Start off by creating a banner
	var careTeamBanner = $("<div id='ipassCareTeamBannerWrapper'></div>");

	menuContentElement.find(".utilities-menu-label").html(careTeamBanner);
	careteamSelector.renderCareTeamSelector(careTeamBanner);
	//Grab the custom content element so we can make sure the menu fits within the view
	var customContentElement = menuContentElement.find(".utilities-menu-custom-content");
	var viewpointBody = $("#vwpBody");
	customContentElement.css({
		"max-height" : (viewpointBody.height() - $("#ipassCareTeamBanner").height() - 50) + "px"
	});

};

/**
 * This function is used to initialize the content for the Comments section of the iPass utility
 * @param {Object} response This is the object which will contain the mp_retrieve_ipass_person response containing comments data
 * @param {jQuery Object} commentsContent This is the jquery object where all comments HTML will be rendered
 * @return null
 */
CERN_IPASS_O1.initCommentsSection = function(response, commentsContent) {
	var criterion = CERN_IPASS_O1.criterion;
	var categoryMean = criterion.CATEGORY_MEAN;
	var ipassI18N = i18n.discernabu.ipass;
	var situationalAwarenessI18n = i18n.discernabu.ipass_sit_aware;
	var filteredByHtml = "";
	filteredByHtml = "<span id='ipassCommentsFilteredBy' class='ipass-careteam-filtered'></span>";
	$(commentsContent).html("<div class='ipass-vwp-header'>" + situationalAwarenessI18n.SITUATIONAL_AWARENESS_PLAN + "</div>" + filteredByHtml + "<div class='ipass-vwp-separator'>&nbsp;</div><div id='ipassCommentsContentWrapper'></div>");
	var ipassCommentsContent = $('#ipassCommentsContentWrapper');
	CERN_IPASS_O1.iPassComments = new IPASSComments();
	var iPassComments = CERN_IPASS_O1.iPassComments;
	iPassComments.setUniqueId("ipassActions" + categoryMean);
	iPassComments.setCriterion(CERN_IPASS_O1.viewpointCriterionObj);
};

/**
 * This function is used to initialize the content for the Actions section of the iPass utility
 * @param {Object} reply This is the object from the mp_retrieve_ipass_person response containing actions data
 * @param {jQuery Object} actionsContent This is the jquery object where all actions HTML will be rendered
 * @return null
 */
CERN_IPASS_O1.initActionsSection = function(reply, actionsContent) {
	var criterion = CERN_IPASS_O1.criterion;
	var categoryMean = criterion.CATEGORY_MEAN;
	var ipassI18N = i18n.discernabu.ipass;
	var actionsI18N = i18n.discernabu.ipass_actions;
	var filteredByHtml = "";
	filteredByHtml = "<span id='ipassActionsFilteredBy' class='ipass-careteam-filtered'></span>";
	$(actionsContent).html("<div class='ipass-vwp-header'>" + actionsI18N.ACTIONS + "</div>" + filteredByHtml + "<div class='ipass-vwp-separator'>&nbsp;</div><div id='ipassActionsContentWrapper'></div>");
	var ipassActionsContent = $('#ipassActionsContentWrapper');
	CERN_IPASS_O1.iPassActions = new IPASSActions();
	var iPassActions = CERN_IPASS_O1.iPassActions;
	iPassActions.setUniqueId("ipassActions" + categoryMean);
	iPassActions.setCriterion(CERN_IPASS_O1.viewpointCriterionObj);
	iPassActions.finalizeActions(actionsContent);
};

CERN_IPASS_O1.renderIPass = function(replyObj) {
	var timerIPassRender = MP_Util.CreateTimer("ENG:MPG.IPASS - render", CERN_IPASS_O1.getViewpointNameKey());
	var iPassTarget = CERN_IPASS_O1.iPassRef;
	try {

		var actionsContent = null;
		var patSummaryContent = null;
		var sitAwareContent = null;
		var illSeverityContent = null;
		var patSumi18N = i18n.discernabu.patient_summary_o1;

		var reply = null;
		reply = replyObj.getResponse();
		MP_Util.LogInfo("replyObj status=" + replyObj.getStatus());
		MP_Util.LogInfo("reply contents=\n" + reply);

		if (replyObj.getStatus() === "F") {
			MP_Util.LogScriptCallError(null, this, "ipass.js", "renderIPass");
			CERN_IPASS_O1.alertErrorConfirm(1, patSumi18N.SYSTEM_FAILURE, patSumi18N.ERROR_RETRIEVE, CERN_IPASS_O1.iPassI18n.OK_TEXTVAL);
			MP_MenuManager.closeMenuStack();
			return;
		}

		CERN_IPASS_O1.personnelArray = MP_Util.LoadPersonelListJSON(reply.PRSNL);

		//Remove the ipass preloader
		$("#ipassPreloader").remove();

		illSeverityContent = $("<div></div>").attr("id", "illSevContent");
		iPassTarget.append(illSeverityContent);
		CERN_IPASS_ILL_SEVERITY_O1.initIllSeverity(reply, illSeverityContent);

		patSummaryContent = $("<div id = 'patSumContent' class = 'ipass-sections-padding'></div>");
		iPassTarget.append(patSummaryContent);
		CERN_PATSUM_O1.initPatientSummary(reply.PATIENT_SUMMARY, patSummaryContent);

		actionsContent = $("<div id='ipass-actions-content' class='ipass-sections-padding'></div>");
		iPassTarget.append(actionsContent);
		CERN_IPASS_O1.initActionsSection(reply, actionsContent);

		sitAwareContent = $("<div id='ipass-sitaware-content' class='ipass-sections-padding'></div>");
		iPassTarget.append(sitAwareContent);
		CERN_IPASS_O1.initCommentsSection(reply, sitAwareContent);
		//Make the call to render the careteam selector dropdown/determine whether is shows
		CERN_IPASS_O1.renderCareTeamSelector();
		return iPassTarget;
	}
	catch (error) {
		MP_Util.LogJSError(error, null, "ipass.js", "renderIPass");
		if (timerIPassRender) {
			timerIPassRender.Abort();
			timerIPassRender = null;
		}
		throw error;
	}
	finally {
		if (timerIPassRender) {
			timerIPassRender.Stop();
		}
	}

};
/**
 * This function makes a call to the backend and gets the data in JSON format.
 * @param {string} programName - Script Name
 * {string} params - script parameters
 *{object} blobIn - BlobIn Object with parameters data
 *{function address} callback - callback function
 *{bool} isLoadScript - bool value to start load timer
 */

CERN_IPASS_O1.loadWithCBParameters = function(programName, params, blobIn, callback, isLoadScript) {

	var request = isLoadScript ? new MP_Core.ScriptRequest(this, "USR:MPG.IPASS - load illness severity") : new MP_Core.ScriptRequest(this);

	request.setProgramName(programName);
	request.setParameters(params);
	request.setAsync(true);
	if (blobIn) {
		request.setRequestBlobIn(blobIn);
	}
	MP_Core.XMLCCLRequestCallBack(null, request, callback);
};

/**
 * This function is used to build JSON format request with all the details and
 * @return Returns the JSON format.
 */
CERN_IPASS_O1.createJSONRequest = function(personId, encId, posCd, prsnlId, ipassId, ipassTypeCd, ipassTypeMean, actionType, parentEntId, txt, updateCnt, statusMeaning, globalInd, seq, careTmId) {

	if (txt) {
		txt = txt.replace(/"/g, String.fromCharCode(216));
	}
	var blobIn = '{"REQUEST":{"PERSON_ID":' + personId + ',"ENCOUNTER_ID":' + encId + ',"POSITION_CD":' + posCd + ',"PRSNL_ID":' + prsnlId + ',"QUAL":[{"PCT_IPASS_ID":' + ipassId + ',"IPASS_TYPE_CD":' + ipassTypeCd + ',"IPASS_TYPE_MEAN":"' + ipassTypeMean + '","ACTION_TYPE":"' + actionType + '","PARENT_ENTITY_ID":' + parentEntId + ',"TEXT":"' + txt + '","UPDT_CNT":' + updateCnt + ',"STATUS_MEANING":"' + statusMeaning + '","GLOBAL_IND":' + globalInd + ',"PCT_SEQ":' + seq + ',"CARE_TEAM_ID":' + careTmId + '}]}}';

	return blobIn;
};

/**
 * This function is used to alert the user to an error that has occurred within the actions portion of the iPass utility
 * @param {int} displayType Type of the modal dialog like inline/alert. 1 === ModalDialog, 2 === Inline
 * @param {string} message Message to be displayed on the user.
 * @param {string} title Title of the ModalDialog if the displayType is 1
 * @param {string} buttonText Text applied on the confirmation button
 */
CERN_IPASS_O1.alertErrorConfirm = function(displayType, message, title, buttonText) {

	if (displayType === 1) {
		//Create the content for the ModalDialog Object.  If the ModalDialog does not current exist it will be created for us passively
		var modalObj = MP_Util.generateModalDialogBody("iPassActionsFailureAlert", "error", message, "");
		//If the ModalDialog object was just created we need to add our own button
		var modalButton = modalObj.getFooterButton("modalOkBtn");
		if (!modalButton) {
			//Add the confirmation button
			modalButton = new ModalButton("modalOkBtn");
			modalButton.setText(buttonText);
			modalButton.setFocusInd(true).setOnClickFunction(function() {
				MP_MenuManager.closeMenuStack();
			});
			modalObj.addFooterButton(modalButton);
			//Make sure the user has to click the button
			modalObj.setShowCloseIcon(false);
		}
		modalObj.setHeaderTitle(title);
		modalObj.setFooterButtonText("modalOkBtn", buttonText);
		MP_ModalDialog.updateModalDialogObject(modalObj);
		MP_ModalDialog.showModalDialog("iPassActionsFailureAlert");
	}
	else if (displayType === 2) {
		//This error is only used when attempting to save an action and it does not save successfully
		//Grab the container for the New Actions controls
		var actionsControl = $('#iPassActionsID');
		if (actionsControl.length) {
			//Check to see if we have already added an error section
			if (!actionsControl.find(".error-icon-component").length) {
				actionsControl.find(".ipass-actions-field-max").addClass("hidden");
				actionsControl.append("<span class='error-icon-component'><span class='error-text'>" + CERN_IPASS_O1.actionsI18N.UNABLE_ADD_ACTION + "</span></span>");
			}
			//Update the visuals on the remaining controls
			actionsControl.find(".ipass-actions-savebutton").attr("value", CERN_IPASS_O1.iPassI18n.RETRY).removeAttr("disabled");
			//re-enable the textarea and remove the grayed background
			actionsControl.prev().removeAttr("disabled");
			//Remove the loading gif
			actionsControl.find('img').remove();
		}
	}
};
/**
 * This function is used to show inline failure message to user when any action like Update/Insert/Select to the database fails
 * @param {string} errorMessage The error mesage to dispaly as inline message.
 * @param {string} iPassSection In which section the inline messgae to be displayed
 */
CERN_IPASS_O1.buildInlineFailureMessage = function(errorMessage, iPassSection) {

	//Generating error HTML	using MP core getEWIHTML function
	var errorHTML = MP_Core.generateUserMessageHTML("error", errorMessage, " " + CERN_IPASS_O1.iPassI18n.NETWORK_FAIL, "inline-message");
	var errEle = null;

	switch (iPassSection) {

		case "ILLSEVERITY":
			//generate the illnessseverity HTML
			errEle = $('#illSevContent').find(".ipass-ill-sev-err-msg");
			break;
		case "PATSUMMARY":
			//generate the patient summary HTML
			errEle = $('#patSumContent').find(".ipass-pat-summ-err-msg");
			break;
		case "ACTION":
			//generate the actions HTML
			errEle = $('#ipass-actions-content').find(".ipass-action-err-msg");
			break;
		case "COMMENT":
			//generate the situational awarness HTML
			errEle = $('#ipass-sitaware-content').find(".ipass-sit-aware-err-msg");
			break;
	}
	$(errEle).html(errorHTML);
	$(errEle).removeClass("hidden");

	return;
};

/**
 * This name space is used to isolate all of the iPass Illness Severity functions and also provide global access
 * @name space CERN_IPASS_ILL_SEVERITY_O1
 * @static
 * @global
 */
var CERN_IPASS_ILL_SEVERITY_O1 = {
	illSeverityI18N : i18n.discernabu.ipass_illSeverity,
	iPassI18N : i18n.discernabu.ipass,
	ILL_CODES : [],
	replyObj : {}
};

/**
 * This function is used to initialise the content for the Illness Severity  section of the iPass utility
 * @param {jQuery Object} response This is the object which will contain all of the illSeverity HTML and user interface.
 * @return null
 */
CERN_IPASS_ILL_SEVERITY_O1.initIllSeverity = function(response, illSeverityContent) {

	var illSeverityData = response.ILL_SEVERITY;
	var illSevIPassId = 0;
	var illSevUpdCnt = 0;

	if (illSeverityData) {
		illSevIPassId = illSeverityData.PCT_IPASS_ID;
		illSevUpdCnt = illSeverityData.UPDT_CNT;
	}

	var timerIllSeverityRender = MP_Util.CreateTimer("ENG:MPG.IPASS_ILL_SEVERITY - render", CERN_IPASS_O1.getViewpointNameKey());
	try {
		var illHTML = "<div class='ipass-vwp-header'>" + CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.ILLSEVERITY + "</div><div class='ipass-vwp-separator'>&nbsp;</div><div class='ipass-pad ipass-ill-sev-err-msg hidden'></div>";
		illHTML += "<div class='ipass-ill-btns'>";

		illHTML += CERN_IPASS_ILL_SEVERITY_O1.buildIllSevButtons(illSevIPassId, illSevUpdCnt, illSeverityData, response.DISCHARGED_IND);
		illHTML += "</div>";
		$(illSeverityContent).html(illHTML);
	}
	catch (error) {
		MP_Util.LogJSError(error, null, "ipass.js", "buildIllSevButtons");
		if (timerIllSeverityRender) {
			timerIllSeverityRender.Abort();
			timerIllSeverityRender = null;
		}
		throw error;
	}
	finally {
		if (timerIllSeverityRender) {
			timerIllSeverityRender.Stop();
		}
	}

	$(illSeverityContent).on("click", ".ipass-ill-btn", function() {
		//ensure the error message is hidden on click
		$(this).parent(".ipass-ill-btns").prev(".ipass-ill-sev-err-msg").addClass("hidden");
		//do not complete the click function if button is locked
		if ($(this).hasClass("btn-locked")) {
			return;
		}

		var criterion = CERN_IPASS_O1.criterion;
		var encounterId = (criterion.ENCNTRS.length) ? criterion.ENCNTRS[0].ENCNTR_ID : 0.0;
		var personId = criterion.PERSON_ID ? criterion.PERSON_ID : 0;
		var refEl = $(this);
		var btnParent = $(this).parent(".ipass-ill-btns");
		var buttons = $(btnParent).children(".ipass-ill-btn");
		var resetInd = $(this).hasClass("ipass-ill-btn-active");
		var selectedCd = $(this).attr("data-code-value");
		var codeInfo = CERN_IPASS_ILL_SEVERITY_O1.findIllnessSeverityCode(selectedCd);
		var existingSelection = 0.0;
		var existingIPassId = parseInt($(refEl).attr("data-ipass-id"), 10);
		var existingUpdCnt = parseInt($(refEl).attr("data-upd-cnt"), 10);

		//callback to update illness Severity buttons
		var updateIllSevElements = function(response) {
			var errMessage = "";
			//Remove button locks
			$(btnParent).children().removeClass("btn-locked");
			if (response) {

				if (response.getStatus() === "S") {
					var jsReply = response.getResponse();
					var successRec = jsReply.RECORDS[0];
					var newIpassId = 0;
					var newUpdCnt = 0;
					var newCode = 0;
					if (successRec.ACTION_TYPE === "DELETE") {
						newIpassId = 0;
						newUpdCnt = 0;
					}
					else {
						newIpassId = successRec.PCT_IPASS_ID;
						newUpdCnt = successRec.UPDT_CNT;
						newCode = successRec.PARENT_ENTITY_ID;
					}

					$(buttons).each(function() {
						//update the ipass-id on all buttons
						$(this).attr("data-ipass-id", newIpassId);
						//update the update count on all buttons
						$(this).attr("data-upd-cnt", newUpdCnt);
						//update the data-btn-sel attribute
						if (parseInt($(this).attr("data-code-value"), 10) === newCode) {
							$(this).attr("data-btn-sel", true);
						}
						else {
							$(this).attr("data-btn-sel", false);
						}
					});
					
					//Update the reply object of illness severity
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.PCT_IPASS_ID = newIpassId;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.ILL_SEV_CD = newCode;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.ILL_SEV_DISPLAY = codeInfo.DISPLAY;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.UPDT_BY_ID = successRec.UPDT_BY_ID;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.UPDT_DT_TM = successRec.UPDT_DT_TM;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.UPDT_DATE = successRec.UPDT_DATE;
					CERN_IPASS_ILL_SEVERITY_O1.replyObj.m_responseData.ILL_SEVERITY.UPDT_CNT = newUpdCnt;
					
					//Update the illness severity indicator with the latest illness severity
					CERN_IPASS_ILL_SEVERITY_O1.updateIllnessSeverityIndicator(codeInfo,resetInd);
				}
				// Script request was not successful
				else {
					//Display Error message
					if (resetInd) {
						errMessage = CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.FAIL_RESET;
					}
					else {
						errMessage = CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.UPDATE_STAT_FAIL.replace("{0}", "\"" + codeInfo.DISPLAY + ".\"");
					}
					//Remove button locks
					$(btnParent).children().removeClass("btn-locked");
					CERN_IPASS_O1.buildInlineFailureMessage(errMessage, "ILLSEVERITY");

					//Revert Selection
					$(buttons).each(function() {
						//update the data-btn-sel attribute
						if (parseInt($(this).attr("data-code-value"), 10) === parseInt(existingSelection, 10)) {
							$(this).addClass("ipass-ill-btn-active");
							$(this).attr("data-btn-sel", true);
						}
						else {
							$(this).removeClass("ipass-ill-btn-active");
							$(this).attr("data-btn-sel", false);
						}
					});

				}
			}
		};

		//determine if there is an existing value and lock all the buttons until a script response is received
		$(buttons).each(function() {
			$(this).addClass("btn-locked");
			if ($(this).hasClass("ipass-ill-btn-active")) {
				existingSelection = $(this).attr("data-code-value");

			}
		});

		// Update all Illness/Severity Elements to new selection
		// Change all buttons back to default
		$(btnParent).children().removeClass("ipass-ill-btn-active");

		if (!resetInd) {
			//activate button that was clicked
			$(this).addClass("ipass-ill-btn-active");
		}

		var actionType = "";
		actionType = (existingIPassId) ? ((existingSelection === selectedCd) ? "DELETE" : "MODIFY") : "ADD";

		var cclParams = CERN_IPASS_O1.createJSONRequest(personId + ".0", encounterId + ".0", "0.0", "0.0", existingIPassId, "0.0", "ILLSEVERITY", actionType, selectedCd + ".0", "", existingUpdCnt, "", 0, 0, "0.0");

		CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], cclParams, updateIllSevElements, false);

	});

	$(illSeverityContent).on("mouseenter", ".ipass-ill-btn", function() {
		if ($(this).hasClass("btn-locked")) {
			return;
		}
		$(this).addClass("ipass-ill-btn-hover");
	});
	$(illSeverityContent).on("mouseleave", ".ipass-ill-btn", function() {
		if ($(this).hasClass("btn-locked")) {
			return;
		}
		$(this).removeClass("ipass-ill-btn-hover");
	});

};

/**
 * This function is used to build the Illness Severity status indicator buttons of iPass utility
 * @return Returns the illnessSeverity buttons HTML string.
 */
CERN_IPASS_ILL_SEVERITY_O1.buildIllSevButtons = function(iPassId, updCnt, illSeverityData, dischFlg) {
	var selectedCd = "";
	var updtCnt = (updCnt) ? updCnt : 0;
	if (illSeverityData) {
		selectedCd = illSeverityData.ILL_SEV_CD;
	}

	var illHTML = "";
	var codes = CERN_IPASS_ILL_SEVERITY_O1.ILL_CODES;
	var codesLen = CERN_IPASS_ILL_SEVERITY_O1.ILL_CODES.length;
	for (var y = codesLen; y--; ) {
		var btnClass = "";
		var btnLock = "";
		var curValue = false;
		if (selectedCd == codes[y].CODE_VALUE) {
			btnClass = " ipass-ill-btn-active";
			curValue = true;
		}
		if (dischFlg) {
			btnClass = 'sev-default';
			btnLock = " btn-locked";
		}
		if (y === 0) {
			illHTML += "<div class='ipass-ill-btns-sep'>&nbsp;</div>";
		}
		illHTML += "<span class='ipass-ill-btn " + codes[y].MEANING + btnClass + btnLock + "' data-upd-cnt='" + updtCnt + "' data-ipass-id='" + iPassId + "' data-code-value='" + codes[y].CODE_VALUE + "' data-btn-sel='" + curValue + "'>";
		illHTML += "<span class='ipass-ill-btn-left'>&nbsp;</span><span class='ipass-ill-btn-center'><span class='ipass-ill-btn-val'>" + codes[y].DISPLAY + "</span></span><span class='ipass-ill-btn-right'>&nbsp;</span>";
		illHTML += "</span>";

	}
	return illHTML;

};

/**
 * This function is used to find the details of a given illness severity.
 * @param {number} code - The code value of the illness severity.
 * @param {string} meaning - The meaning of the illness severity.
 * @return {object} Returns the details of the illness severity matching with the given code or meaning.
 */
CERN_IPASS_ILL_SEVERITY_O1.findIllnessSeverityCode = function(code, meaning) {
	var codes = CERN_IPASS_ILL_SEVERITY_O1.ILL_CODES;
	var codesLen = codes.length;
	for (var i = codesLen; i--; ) {
		if (code == codes[i].CODE_VALUE || meaning == codes[i].MEANING) {
			return codes[i];
		}
	}
};
		
/**
 * This function is used to display the Illness Severity status indicator.
 * @param {object} replyObj - The object is the response of mp_retrieve_ipass_person containing illness severity data.
 * @return null.
 */
CERN_IPASS_ILL_SEVERITY_O1.displayIllnessSeverityIndicator = function(replyObj){
	var response = replyObj.getResponse();
	var status = replyObj.getStatus();
	var illSevIndicator = $('#vwpIllSevInd');
	
	//Grab the reply object and the illness codes
	CERN_IPASS_ILL_SEVERITY_O1.replyObj = replyObj;
	CERN_IPASS_ILL_SEVERITY_O1.ILL_CODES = response.ILL_SEV_CDS;
	if(status !== "F")
	{
		if(response.DISCHARGED_IND){
			illSevIndicator.text(CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.DISCHARGED);
			illSevIndicator.addClass('ill-sev-ind-discharged');
			return;
		}
		if(status === "S"){
			var severityCodeInfoObj = CERN_IPASS_ILL_SEVERITY_O1.findIllnessSeverityCode(response.ILL_SEVERITY.ILL_SEV_CD);
			illSevIndicator.addClass(severityCodeInfoObj.MEANING);
			illSevIndicator.text(severityCodeInfoObj.DISPLAY);
		}
		else if(status === "Z"){
			illSevIndicator.text(CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.NO_SEVERITY);
			illSevIndicator.addClass("ill-sev-ind-no-severity");
		}
	}
	else{
		illSevIndicator.text(CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.ERROR);
		illSevIndicator.addClass("ill-sev-ind-error");
	}
};

/**
 * This function is used to update the Illness Severity status indicator.
 * @param {object} codeInfo - This object contains information of the selected illness severity.
 * @param {boolean} resetInd - This indicator specifies whether to reset the indicator.
 */
CERN_IPASS_ILL_SEVERITY_O1.updateIllnessSeverityIndicator = function(codeInfo, resetInd){
	var illSevIndicator = $('#vwpIllSevInd');
	
	//Display No-Severity when the reset indicator is set
	if(resetInd){
		illSevIndicator.attr('class','vwp-ill-sev-ind ill-sev-ind-no-severity');
		illSevIndicator.text(CERN_IPASS_ILL_SEVERITY_O1.illSeverityI18N.NO_SEVERITY);
	}
	else{
		illSevIndicator.attr('class', 'vwp-ill-sev-ind ' + codeInfo.MEANING);
		illSevIndicator.text(codeInfo.DISPLAY);
	}
};

/**
 * This namespace is used to isloate all of the iPass Patient Summary functions
 * @namespace CERN_PATSUM_O1
 * @static
 * @global
 */

var CERN_PATSUM_O1 = function() {
	/*
	 * Class level variables.
	 */
	var patSummNoteId = "";
	var updtPrsnl = "";
	var updtDtTm = "";
	var patSummNoteLength = 0;
	var encounterId = "";
	var oldText = "";
	var patSumText = "";
	var maxChars = 1000;
	var patSumi18N = i18n.discernabu.patient_summary_o1;
	var iPassI18N = i18n.discernabu.ipass;
	var viewpointNameKey = "";
	var personId = "";
	var patSummUpdCnt = 0;
	var filteredByHtml = "";
	var parentCareTeamId = "";

	//Global references to the various HTML elements of the Patient Summary display
	var patSummContainer = null;
	var patSummCurrentDisplay = null;
	var patSummTextAreaContainer = null;
	var patSummTextArea = null;
	var patSummCharCount = null;
	var patSummSaveContainer = null;
	var patSummSaveButton = null;
	var patSummCancelContainer = null;
	var patSummCancelButton = null;
	var patSummErrorText = null;
	var patSummContent = null;
	
	return {

		/**
		 * This function is used to initialize the content for the Patient Summary section of the iPass utility
		 * @param {string} reply This is the object from the mp_retrieve_ipass_person response containing patient summary data
		 * @param {DOM Element} patSumContent This is the jquery object where all patient summary HTML will be rendered
		 */
		initPatientSummary : function(reply, patSumContent) {
			filteredByHtml = "<span id='ipassPatSummFilteredBy' class='ipass-careteam-filtered'></span>";
			$(patSumContent).html("<div class='ipass-vwp-header'>" + patSumi18N.PATIENT_SUMMARY + "</div>" + filteredByHtml + "<div class='ipass-vwp-separator pat-sum-separator-width'></div><div id='ipassPatSumContentWrapper'><div id='iPassPatSummError' class='ipass-pad ipass-pat-summ-err-msg hidden'></div></div>");
			patSummContent = $('#ipassPatSumContentWrapper');
			
			// Initialize all the delegates
			CERN_PATSUM_O1.addDelegates(patSummContent);
		},
		
		/**
		 * This function is used to add delegates that responds to various events such as,
		 * Mouse-enter
		 * Mouse-leave
		 * Click: Save
		 * Click: Cancel
		 * Click: Edit Text
		 * Keyup: Text area
		 * KeyDown: Text area
		 * 
		 * @param {DOM Element} patSumContent Object that is the wrapper for the patient summary entities
		 */
		addDelegates: function (patSumContentElement) {
			if(patSumContentElement){
				$(patSumContentElement).on("mouseenter", "#iPatSummText", function() {
					var patSummCurrentDisplay = $("#iPassPatSummDisplay");
					var patSummContainer = $("#iPassPatSummContainer");
	
					patSummCurrentDisplay.find('.pat-sum-span').addClass("pat-sum-inside-box");
					patSummContainer.addClass("pat-sum-outer-block");
				});
	
				$(patSumContentElement).on("mouseleave", "#iPatSummText", function() {
					var patSummCurrentDisplay = $("#iPassPatSummDisplay");
					var patSummContainer = $("#iPassPatSummContainer");
	
					patSummCurrentDisplay.find('.pat-sum-span').removeClass("pat-sum-inside-box");
					patSummContainer.removeClass("pat-sum-outer-block");
				});
	
				$(patSumContentElement).on("click", "#iPatSummText", function() {
					CERN_PATSUM_O1.patSumTextEdit($(this));
				});
	
				$(patSumContentElement).on("click", ".pat-sum-savebutton", function() {
					CERN_PATSUM_O1.savePatientSummaryNote($(this));
				});
				
				$(patSumContentElement).on("click", ".pat-sum-cancelbutton", function() {
					CERN_PATSUM_O1.cancelPatientSummaryNoteUpdates($(this));
				});
				
				$(patSumContentElement).on("keyup", "#iPassPatSummTextArea", function(event) {
					CERN_PATSUM_O1.patSumKeyUp(this, event);
				});
	
				$(patSumContentElement).on("keydown", "#iPassPatSummTextArea", function(event) {
					CERN_PATSUM_O1.patSumKeyDown($(this), event);
				});
			}
		},
		
		/**
		 * This function is used to render the patient summary user interface once the script returns
		 * @param {string} response The JSON reply from the script called
		 * @param {DOM Element} patSumContainer The DOM Element used when the script called was initiated
		 */
		renderPatientSummary : function(response, patSumContainer) {
			var timerPatSumRenderComponent = MP_Util.CreateTimer("ENG:MPG.PATSUM.O1 - render component", CERN_IPASS_O1.getViewpointNameKey());
			try {

				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

				var provider = null;
				var providerName = "";
				//If there is a saved summary, gather summary information
				if (response.PCT_IPASS_ID) {
					patSummNoteId = response.PCT_IPASS_ID;
					patSumText = unescape(response.TEXT);
					patSumText = patSumText.replace(/\s+$/,"");
					patSumText = patSumText.replace(/[\n]/g,"<br/>");
					patSumText = patSumText.replace(/ {2}/g, "&nbsp;&nbsp;");
					patSummNoteLength = patSumText.length;
					patSummUpdCnt = response.UPDT_CNT;
					provider = MP_Util.GetValueFromArray(response.UPDT_BY_ID, CERN_IPASS_O1.personnelArray);
					providerName = (provider === null) ? "" : provider.fullName;
					updtPrsnl = providerName;
					updtDtTm = df.formatISO8601(response.UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
				} else {
					//reset values if no summary saved
					patSummNoteId = 0;
					updtPrsnl = "";
				}
				//Create the HTML for the Patient Summary Utility
				var patSummContent = "<div id='iPassPatSummContainer' class='pat-sum-outerDiv'><div id='iPassPatSummDisplay' class='pat-sum-textDiv'><div id = 'iPatSummText' class='pat-sum-span" + ((patSummNoteId) ? " pat-sum-existing-text" : " pat-sum-default-text") + "'>" + ((patSummNoteId) ? patSumText : patSumi18N.ENTER_PAT_SUMMARY) + "</div><span class='pat-sum-author'>" + ((updtPrsnl) ? updtPrsnl + "&nbsp;" + updtDtTm : "") + "</span></div><div id='iPassPatSummTextAreaContainer' class='pat-sum-textareaDiv hidden'><textarea id='iPassPatSummTextArea' class='pat-sum-textarea-main'></textarea></div><div style='width:97%; padding-top:4px;'><span id='iPassPatSummCount' class='hidden pat-sum-count-div'><span class='pat-sum-count-text'></span></span><span id='iPassPatSummCancel' class='pat-sum-cancel-span hidden'><input id='iPassPatSummCancelButton' type='button' value='" + iPassI18N.CANCEL + "' class='pat-sum-cancelbutton'/></span><span id='iPassPatSummSave' class='pat-sum-save-span hidden'><input id='iPassPatSummSaveButton' type='button' value='" + iPassI18N.SAVE + "' class='pat-sum-savebutton'/></span></div></div>"+
				"<a id='iPassPatSumShowAllMedServ' class='ipass-patsum-show-all-med-serv' onclick='CERN_PATSUM_O1.launchShowAllMedServPatSumModal();return false;'>"+ patSumi18N.ALL_MEDICAL_SERVICES +"</a>";
				
				$(patSumContainer).append(patSummContent);

				//Cache the various elements within patient summary so we can access them easily later
				patSummContainer = $("#iPassPatSummContainer");
				patSummCurrentDisplay = $("#iPassPatSummDisplay");
				patSummTextAreaContainer = $("#iPassPatSummTextAreaContainer");
				patSummTextArea = $("#iPassPatSummTextArea");
				patSummCharCount = $("#iPassPatSummCount");
				patSummSaveContainer = $("#iPassPatSummSave");
				patSummSaveButton = $("#iPassPatSummSaveButton");
				patSummCancelContainer = $("#iPassPatSummCancel");
				patSummCancelButton = $("#iPassPatSummCancelButton");
				patSummErrorText = $("#iPassPatSummError");
			}
			//if rendering of data fails, remember to abort timing to assure invalid timings are not stored
			catch (err) {
				MP_Util.LogJSError(err, null, "ipass.js", "renderPatientSummary");
				if (timerPatSumRenderComponent) {
					timerPatSumRenderComponent.Abort();
					timerPatSumRenderComponent = null;
				}
				//remember to throw the error to assure the 'load component' try/catch block is executed to assure its timer is aborted as well
				throw (err);
			}
			//stop the actual render timer if still exists and no failure was found.
			finally {
				if (timerPatSumRenderComponent) {
					timerPatSumRenderComponent.Stop();
				}
			}

		},
		/**
		 * This function is used to save the new Patient Summary content
		 */
		savePatientSummaryNote : function() {

			var params = "";
			//Update the UI
			//Grab the text and disable the textarea
			var newText = patSummTextArea.prop('disabled', true).val();
			var ipassPatSumTimer = null;

			try {

				//Hide the error message if it is being shown
				patSummErrorText.addClass('hidden');
				patSummErrorText.removeClass('ipass-err-adj');
				//Make sure the character count div is shown
				patSummCharCount.removeClass('hidden');
				//Disable both the save and cancel buttons
				patSummContainer.addClass('pat-sum-bg-update');
				patSummSaveButton.addClass('pat-sum-load').prop('disabled', true).attr("value", " ");
				patSummCancelButton.prop('disabled', true);
				var criterion = CERN_IPASS_O1.criterion;
				encounterId = (criterion.ENCNTRS.length) ? criterion.ENCNTRS[0].ENCNTR_ID : 0.0;
				personId = criterion.PERSON_ID ? criterion.PERSON_ID : 0;
				ipassPatSumTimer = new RTMSTimer("USR:MPG.IPASS - Patient Summary Actionability", CERN_IPASS_O1.getViewpointNameKey());
				//Do not save results that do not have an encounter Id
				if (!encounterId) {
					MP_Util.LogError("No encounter ID defined for this patient.");
					CERN_PATSUM_O1.handleError(patSumi18N.UNABLE_TO_SAVE);

					//Reset the global parameters to prevent stale data
					patSummNoteId = "";
					updtPrsnl = "";
					updtDtTm = "";
					patSummNoteLength = 0;
					patSumText = "";
					patSummUpdCnt = 0;
					//Rest the Patient Summary display to the default text
					patSummCurrentDisplay.find('.pat-sum-span').removeClass('pat-sum-existing-text').addClass('pat-sum-default-text').html(patSumi18N.ENTER_PAT_SUMMARY);
					patSummCurrentDisplay.find('.pat-sum-author').html("");
					//Update the UI
					CERN_PATSUM_O1.refreshPatSum();
					return;
				}

				if (!patSummNoteId) {
					// Start user timer for add action
					if (ipassPatSumTimer) {
						ipassPatSumTimer.addMetaData("rtms.legacy.metadata.1", "Patient Summary Add");
						ipassPatSumTimer.start();
					}
					//Patient does not currently have a summary defined
					params = CERN_IPASS_O1.createJSONRequest(personId + ".0", encounterId + ".0", "0.0", "0.0", "0.0", "0.0", "PATSUMMARY", "ADD", "0.0", newText, 0, "", 0, 0, parentCareTeamId + ".0");

					CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], params, CERN_PATSUM_O1.insertPatSum, false);

				}
				else {
					var UPD_CNT = patSummUpdCnt;
					// Start user timer for modify action
					if (ipassPatSumTimer) {
						ipassPatSumTimer.addMetaData("rtms.legacy.metadata.1", "Patient Summary Modify");
						ipassPatSumTimer.start();
					}
					if (newText) {

						var insertParams = CERN_IPASS_O1.createJSONRequest(personId + ".0", encounterId + ".0", "0.0", "0.0", patSummNoteId, "0.0", "PATSUMMARY", "MODIFY", "0.0", newText, UPD_CNT, "", 0, 0, parentCareTeamId + ".0");

						CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], insertParams, CERN_PATSUM_O1.updatePatSum, false);
					}
					else {
						// Start user timer for delete action
						if (ipassPatSumTimer) {
							ipassPatSumTimer.addMetaData("rtms.legacy.metadata.1", "Patient Summary Delete");
							ipassPatSumTimer.start();
						}
						//The user has deleted all of the text
						params = CERN_IPASS_O1.createJSONRequest(personId + ".0", encounterId + ".0", "0.0", "0.0", patSummNoteId, "0.0", "PATSUMMARY", "DELETE", "0.0", oldText, UPD_CNT, "", 0, 0, parentCareTeamId + ".0");
						CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], params, CERN_PATSUM_O1.patSumHandleBlankText, false);
					}
				}
			}
			catch(err) {
				if (ipassPatSumTimer) {
					ipassPatSumTimer.fail();
					ipassPatSumTimer = null;
				}
				MP_Util.LogJSError(err, self, "ipass.js", "Patient Summary Actionability Add/Modify/Delete");
				throw (err);
			}
			finally {
				if (ipassPatSumTimer) {
					ipassPatSumTimer.stop();
				}
			}
		},
		/**
		 * This function is used to reset the user interface when the user decides to cancel the updates to the Patient Summary text
		 */
		cancelPatientSummaryNoteUpdates : function(ref) {
			//Show the Patient Summary text display
			patSummCurrentDisplay.css("display", "inline-block");
			//Hide the editable textArea
			patSummTextAreaContainer.addClass('hidden').addClass('pat-sum-textarea-position');
			patSummContainer.removeClass('pat-sum-outside-box');
			// Remove the count and error messages
			patSummCharCount.addClass('hidden');
			patSummErrorText.addClass('hidden');
			patSummErrorText.removeClass('ipass-err-adj');
			//Reset the save button and hide both buttons
			patSummCancelContainer.addClass("hidden");
			patSummSaveContainer.addClass("hidden");
			patSummSaveButton.attr("value", iPassI18N.SAVE);
		},
		/**
		 * This function is used to examine the text that is currently in the textarea.  It will trim the string if it is too long
		 * and prevent the user from entering more text.
		 * @param {DOM Element} referenceEle The DOMElement which is firing this event
		 * @param {HTML Event} event The keyup event that has taken place
		 */
		patSumKeyUp : function(referenceEle, event) {
			var patSummText = $(referenceEle).val().replace(/^\s+/, "");
			var charCnt = patSummText.length;
			var countEle = patSummCharCount.find("span");
			var charsLeft = maxChars - charCnt;
			var removeClass = "pat-sum-error-disp";
			var addClass = "pat-sum-countText-font";

			//If there are too many characters trim it down and update the classes being added and removed
			if (charCnt >= maxChars) {
				referenceEle.value = referenceEle.value.substring(0, maxChars);
				removeClass = "pat-sum-countText-font";
				addClass = "pat-sum-error-disp";
				charsLeft = 0;
			}

			//Update the classes on the controls
			patSummSaveButton.removeAttr("disabled");
			countEle.removeClass(removeClass).addClass(addClass).text(charsLeft + ' ' + iPassI18N.CHARACTERS_LEFT);

			//Make sure the current text isn't what is already saved
			if (patSummText) {
				//Enable/Disable the save button based on a comparison of the old and new text
				if (patSummNoteLength !== 0) {
					patSummSaveButton.prop('disabled', (patSummText === oldText.replace(/^\s+/, "")));
				}
				else {
					patSummSaveButton.prop('disabled', false);
				}
			}
			else {
				//Since our new string is "" only activate the save button if the old string isn't ""
				patSummSaveButton.prop('disabled', (patSummNoteLength === 0));
			}

			//Check to see if the retry button was shown
			var saveButtonText = patSummSaveButton.attr("value");
			if (saveButtonText === iPassI18N.RETRY) {
				//Reset the save button text to Save
				patSummSaveButton.attr("value", iPassI18N.SAVE);
				//Hide the error if shown
				patSummErrorText.addClass('hidden');
				patSummErrorText.removeClass('ipass-err-adj');
				//Show the count again
				patSummCharCount.removeClass('hidden');
			}
		},
		/**
		 * This function is used to prepare the textarea so the user can enter in the Patient Summary text
		 * @param {DOM Element} ref The DOM Element which triggered the function call
		 */
		patSumTextEdit : function(ref) {
			//Save off the existing text and grab the character count
			oldText = patSumText.replace(/^\s+/, "");
			// Extract the original text format from html markup text
			oldText = oldText.replace(/<br\/>/g, "\n");
			oldText = oldText.replace(/&nbsp\;/g, ' ');
			var oldTextCnt = oldText.length;
			var charsLeft = maxChars - oldTextCnt;
			var removeClass = "pat-sum-error-disp";
			var addClass = "pat-sum-countText-font";
			//Hide the Patient Summary display and show the textarea
			patSummTextAreaContainer.removeClass("hidden").addClass('pat-sum-textarea-position');
			patSummContainer.addClass('pat-sum-outside-box');
			patSummCurrentDisplay.css('display', 'none');
			//Show the Sign and Cancel buttons and disable the save button bt default
			patSummSaveContainer.removeClass('hidden').find('input').attr("disabled", "disabled");
			patSummCancelContainer.removeClass('hidden');
			//Make the count visible
			patSummCharCount.removeClass('hidden').find("span").removeClass("hidden");

			//Make sure we are not populating the textarea with the default text
			if (patSummNoteId && patSummNoteLength) {
				
				patSummTextArea.val(oldText);
			}
			else {
				patSummTextArea.val("");
				charsLeft = maxChars;
			}
			patSummTextArea.focus();

			//Alter the chars left display based on the character count
			if (charsLeft === 0) {
				removeClass = "pat-sum-countText-font";
				addClass = "pat-sum-error-disp";
			}
			//Update the classes on the count so it displays red if there are no characters left and normal if there are characters left
			patSummCharCount.find("span").addClass(addClass).removeClass(removeClass).text(charsLeft + ' ' + iPassI18N.CHARACTERS_LEFT);
		},
		/*
		 * This function is used to handle the event of the user hovering over the Patient Summary text
		 * @param {DOM Element} ref The DOM Element that initiated the mouseover event
		 */
		patSumMouseOver : function() {
			patSummCurrentDisplay.find('.pat-sum-span').addClass("pat-sum-inside-box");
			patSummContainer.addClass("pat-sum-outer-block");
		},
		/*
		 * This function is used to handle the event of the user hovering out of the Patient Summary text
		 * @param {DOM Element} ref The DOM Element that initiated the mouseout event
		 */
		patSumMouseOut : function() {
			patSummCurrentDisplay.find('.pat-sum-span').removeClass("pat-sum-inside-box");
			patSummContainer.removeClass("pat-sum-outer-block");
		},
		/**
		 * This function is used to handle errors encountered during the execution of the Patient Summary utility
		 * @param {boolean} fromScriptCall A flag indicating if the error occurred during a script call
		 */
		handleError : function(errorMessage) {

			$('#iPassPatSummContent').removeClass('pat-sum-bg-update');
			//Update the save button to show 'Retry'
			patSummSaveButton.prop('disabled', false).removeClass('pat-sum-load').attr("value", iPassI18N.RETRY);
			// use properties to enable button
			patSummCancelButton.prop('disabled', false);
			//hide count.
			patSummCharCount.addClass('hidden');
			//show in-line error message
			CERN_IPASS_O1.buildInlineFailureMessage(errorMessage, "PATSUMMARY");

			// enable editing
			patSummTextArea.prop('disabled', false);
			$('#iPassPatSummError').addClass('ipass-err-adj');

		},
		/**
		 * This function is used to check for the 'Ctrl + s' key combination.  IF 'Ctrl + s' key combination is pressed the patient summary text will be saved
		 * @param {DOM Element} ref The DOM Element which triggered the function call
		 * @param {event} event the event that caused the trigger of the function call
		 */
		patSumKeyDown : function(ref, event) {
			var patSummText = $(ref).val().replace(/^\s+/, "");
			var charCnt = patSummText.length;
			var countEle = patSummCharCount.find("span");
			var charsLeft = maxChars - charCnt;
			var removeClass = "pat-sum-error-disp";
			var addClass = "pat-sum-countText-font";
		//If there are too many characters trim it down and update the classes being added and removed
			if (charCnt > maxChars) {
				ref.val(patSummText.substr(0, maxChars));
				removeClass = "pat-sum-countText-font";
				addClass = "pat-sum-error-disp";
				charsLeft = 0;
			}
			//Update the classes on the controls
			patSummSaveButton.removeAttr("disabled");
			countEle.removeClass(removeClass).addClass(addClass).text(charsLeft + ' ' + iPassI18N.CHARACTERS_LEFT);

			// key code for 's' character
			var code = 83;
			
			// check if Ctrl key and 's' character key are used in combination and save text if condition satisfies
			if(event && event.keyCode == code && event.ctrlKey) {
					event.preventDefault(event);
					if(patSummSaveButton.prop('disabled')){
						return;
					}
					CERN_PATSUM_O1.savePatientSummaryNote(ref);
						return;
			}
		},
		/**
		 * This function is used to insert the recently saved Patient Summary text into the PAtient Summary display
		 * @param {string} response The JSON response from the call to mp_upd_pct_ipass
		 */
		insertPatSum : function(response) {
			try {
				if (response) {
					var recordData = response.getResponse().RECORDS[0];
					if (response.getStatus() !== "F") {
						var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
						patSummNoteId = recordData.PCT_IPASS_ID;
						patSummUpdCnt = recordData.UPDT_CNT;
						patSumText = unescape(recordData.TEXT);
						patSumText = patSumText.replace(/\s+$/,"");
						// Build html text for display by replacing break line and white space characters
						patSumText = patSumText.replace(/[\n]/g,"<br/>");
						patSumText = patSumText.replace(/ {2}/g, "&nbsp;&nbsp;");
						updtPrsnl = response.getResponse().PRSNL[0].PROVIDER_NAME.NAME_FULL;
						updtDtTm = (recordData.UPDT_DATE) ? df.formatISO8601(recordData.UPDT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR) : "";
						patSummNoteLength = patSumText.length;
						// display the new text faceup
						patSummCurrentDisplay.find('.pat-sum-span').addClass('pat-sum-existing-text').removeClass('pat-sum-default-text').html(patSumText);
						patSummCurrentDisplay.find('.pat-sum-author').html(updtPrsnl + "&nbsp;" + updtDtTm);
						//Update the UI
						CERN_PATSUM_O1.refreshPatSum();
					}
					else {
						CERN_PATSUM_O1.handleError(patSumi18N.UNABLE_TO_SAVE);
						CERN_PATSUM_O1.refreshPatSum();
					}
				}
			}
			catch (err) {
				MP_Util.LogJSError(err, null, "ipass.js", "insertPatSum");
				throw (err);
			}
		},
		/**
		 * This function is used to handle the case where the user decides to clear the Patient Summary information
		 * @param {string} response The JSON response from the call to  mp_upd_pct_ipass
		 */
		patSumHandleBlankText : function(response) {
			try {

				if (response) {
					if (response.getStatus() !== "F") {
						//Reset the global parameters to prevent stale data
						patSummNoteId = "";
						updtPrsnl = "";
						updtDtTm = "";
						patSummNoteLength = 0;
						patSummUpdCnt = 0;
						patSumText = "";
						//Rest the Patient Summary display to the default text
						patSummCurrentDisplay.find('.pat-sum-span').removeClass('pat-sum-existing-text').addClass('pat-sum-default-text').html(patSumi18N.ENTER_PAT_SUMMARY);
						patSummCurrentDisplay.find('.pat-sum-author').html("");
						//Update the UI
						CERN_PATSUM_O1.refreshPatSum();
					}
				}
			}
			catch (err) {
				MP_Util.LogJSError(err, null, "ipass.js", "patSumHandleBlankText");
				throw (err);
			}
		},
		/**
		 * This function is used to update the previous Patient Summary note so that is has a end_effective date and time
		 */
		updatePatSum : function(response, insertParams) {
			try {

				if (response.getResponse()) {
					if (response.getStatus() !== "F") {
						//Make the call to update the previous note
						CERN_IPASS_O1.loadWithCBParameters("mp_upd_pct_ipass", ["^MINE^"], insertParams, function() {
						}, false);

						//Refresh the user interface while the update script call is executing
						CERN_PATSUM_O1.insertPatSum(response);
					}
					else {
						CERN_PATSUM_O1.handleError(patSumi18N.UNABLE_TO_SAVE);
					}
				}
			}
			catch (err) {
				MP_Util.LogJSError(err, null, "ipass.js", "updatePatSum");
				throw (err);
			}
		},
		/**
		 * This function is used to refresh the display of the Patient Summary and resetting it back to the inactive state
		 */
		refreshPatSum : function() {
			patSummContainer.removeClass('pat-sum-bg-update pat-sum-outside-box');
			//Update the buttons
			patSummSaveButton.prop('disabled', false).removeClass('pat-sum-load hidden').attr("value", iPassI18N.SAVE);
			patSummCancelButton.prop('disabled', false).removeClass('hidden');
			//Show the Patient Summary text and author information
			patSummCurrentDisplay.css('display', 'inline-block').find("span").removeClass("hidden");
			//Hide the save and cancel button containers
			patSummSaveContainer.addClass('hidden');
			patSummCancelContainer.addClass('hidden');
			//Hide the editable text area
			patSummTextAreaContainer.addClass('hidden').addClass('pat-sum-textarea-position');
			//Hide the character count
			patSummCharCount.addClass('hidden');
			//Enable text area
			patSummTextArea.prop('disabled', false);
		},
		
		/**
		 * This function is used to refresh the display of the Patient Summary and resetting it back to the inactive state
		 */
		findSelectedGrandParentCareTeamId : function(careTeamObject) {
			if (careTeamObject) {
				if (careTeamObject.GRAND_PARENT_ID) {
					parentCareTeamId = careTeamObject.GRAND_PARENT_ID;
				} else {
					parentCareTeamId = careTeamObject.PARENT_CARE_TEAM_ID;
				}
			}
		},
		/**
		 *Launches the Modal for showing Patient Summaries for "All Medical Services" link
		 */
		launchShowAllMedServPatSumModal: function() {
			//If the modal has already been created, just show it.
			if (MP_ModalDialog.retrieveModalDialogObject("iPassPatSumAllMedServModal")) {
				MP_ModalDialog.showModalDialog("iPassPatSumAllMedServModal");
				return;
			}

			//Internationalization variables
			var iPassI18N = i18n.discernabu.ipass;
			var iPassPatSumi18N = i18n.discernabu.patient_summary_o1;
			var marginValue = 15;

			//Criterion Object
			var criterion = CERN_IPASS_O1.criterion;
			var personId = criterion.PERSON_ID;

			if (!criterion.ENCNTRS || !criterion.ENCNTRS[0]) {
				throw new Error("Error, no encounter id found, cannot retrieve all patient summaries");
			}
			var encounterId = criterion.ENCNTRS[0].ENCNTR_ID;
			var logicalDomainId = criterion.LOGICAL_DOMAIN_ID;

			//Create the show all modal
			var showAllMedServModal = new ModalDialog("iPassPatSumAllMedServModal");

			var tableBodyPaddingBuffer = 5;

			/**
			 *Helper function to size the body of the table to enable scrolling 
			 * @param {DOM Element} Patient Summary and the Medical Services and other details 
			 * @param {DOM Element} Content header
			 * 
			 * @return {integer} Calculated table height to be considered as the number of pixels
			 */
			var calculateTableHeight = function(modalBody, tableHeader) {
				return modalBody.height() - tableHeader.height() - tableBodyPaddingBuffer;
			};

			/**
			 *Helper function to create table columns
			 * @param {string} Column header id to be shown in each column
			 * @param {string} Column header value to be shown in each column
			 * @param {boolean} TRUE if Sortable, FALSE otherwise
			 * @param {string} primary sort field
			 * @param {string} template to render
			 * @param {string} custom css class id to be loaded
			 * 
			 * @return {TableColumn} returns a TableColumn object that specifies column properties
			 */
			var renderPatSumModalColumn = function(columnId, columnDisplay, sortable, primarySortField, renderTemplate, customClass) {
				return new TableColumn().setColumnId(columnId).setColumnDisplay(columnDisplay).setIsSortable(sortable).setPrimarySortField(primarySortField).setRenderTemplate(renderTemplate).setCustomClass(customClass);
			};
			
			/**
			 * Function that takes the text from the patient summary as the input and accounts for the carriage returns
			 * @param {string} Text with carriage returns obtained as a response
			 * 
			 * @return {string} Text with breaks instead of \n
			 */
			var renderPatSumText = function(summaryText){
				var patSumModalText = unescape(summaryText);
				patSumModalText = patSumModalText.replace(/[\n]/g,"<br />");
				return patSumModalText;
			};
			
			/**
			 * Creates an ModalButton object for close button
			 * @param {string} Id assigned for the button
			 * @param {string} Id of the modal for unbinding
			 * 
			 * @return {ModalButton} Object returned with text and properties
			 */
			var getCloseButtonContext = function(buttonId, modalToUnbind) {
				var closeButton = new ModalButton(buttonId);
				closeButton.setOnClickFunction(function() {
					$(window).unbind(modalToUnbind);
				});
				closeButton.setCloseOnClick(true);
				closeButton.setText(iPassI18N.CLOSE);
				return closeButton;
			}; 
			
			//Create the component table that will be shown inside the modal
			var allPatSumTable = new ComponentTable();

			showAllMedServModal.setHeaderElementId("iPassPatSumAllMedServModalHeader");
			showAllMedServModal.setBodyElementId("iPassPatSumAllMedServModalBody");
			showAllMedServModal.setFooterElementId("iPassPatSumAllMedServModalFooter");
			showAllMedServModal.setTopMarginPercentage(marginValue).setRightMarginPercentage(marginValue).setBottomMarginPercentage(marginValue).setLeftMarginPercentage(marginValue);
			showAllMedServModal.setHeaderTitle(iPassPatSumi18N.PATIENT_SUMMARIES);

			allPatSumTable.setNamespace("ipassAllMedServicesPatSum");
			allPatSumTable.setCustomClass("ipass-patsum-modal");
			allPatSumTable.addColumn(renderPatSumModalColumn("SERVICE", iPassI18N.MEDICAL_SERVICE, true, "CARETEAM_DISPLAY", '${ CARETEAM_DISPLAY }', "ipass-patsum-service"));
			allPatSumTable.addColumn(renderPatSumModalColumn("TEXT", iPassPatSumi18N.PATIENT_SUMMARY, false, "TEXT", '${ TEXT }', "ipass-patsum-text"));
			allPatSumTable.addColumn(renderPatSumModalColumn("PROVIDER", i18n.discernabu.ipass.AUTHOR, true, "PERSONNEL_DISPLAY", '${ PERSONNEL_DISPLAY }', "ipass-patsum-provider"));
			allPatSumTable.addColumn(renderPatSumModalColumn("DATE", iPassI18N.DATE, true, "UPDT_DATE", '${ DATE_DISPLAY }', "ipass-patsum-date"));
			
			//Set the function responsible for rendering the contents of the modal
			showAllMedServModal.setBodyDataFunction(function() {
				var patSumsList = [];
				//Create the request to retrieve all patient summary
				var retrievePatSumAllMedServ = new MP_Core.ScriptRequest();
				var modalElement = $("#vwpModalDialog" + showAllMedServModal.getId());
				//Add the wf class to the root of the modal so we can inherit standard styles
				modalElement.addClass("wf");

				//Grab the modal body element by id
				var modalBody = $("#" + showAllMedServModal.getBodyElementId());
				var modalHead = $("#" + showAllMedServModal.getHeaderElementId());
				
				//Override the modal footer button with the custom css
				var modalFooterButton = $("#"+showAllMedServModal.getFooterElementId()+"btnCont button");
				modalFooterButton.addClass("ipass-patsum-modal-button-container");
				
				//First, we give the modal dialog a spinner to show that it is loading data
				modalBody.html("<div class='preloader-modal'></div>");

				retrievePatSumAllMedServ.setProgramName("MP_RETRIEVE_IPASS_PERSON");
				retrievePatSumAllMedServ.setParameters(["^MINE^", personId + ".0", encounterId + ".0", "0.0", "\"PATSUMMARY\"", 0, "0.0", "-1.0", logicalDomainId + ".0"]);
				retrievePatSumAllMedServ.setAsync(true);
				retrievePatSumAllMedServ.setExecCallback(true);

				//Use XmlCclRequestCallback to handle the script request and provide a custom callback when the response is returned
				MP_Core.XMLCCLRequestCallBack(null, retrievePatSumAllMedServ, function(careTeamsIPassReply) {
					try {
						var patSumsResponseStatus = careTeamsIPassReply.getStatus();
						var patSumsResponse = careTeamsIPassReply.getResponse();
						var personnelMapping = {};
						var careTeamMapping = {};
						var summariesList = [];
						//If there was some error performing the ccl mp_retrieve_ipass_person call
						if (patSumsResponseStatus === "F") {
							throw new Error("There was an error processing mp_retrieve_ipass_person, please check blackbird to verify the ccl parameters and response");
						}
						//If the modal has been closed since we fired off the request, do nothing
						if (!showAllMedServModal.getIsActive()) {
							return;
						}

						//Personnel List
						var personnelList = patSumsResponse.PRSNL;
						var numberOfPersonnel = personnelList.length;

						//Care Team list
						var careTeamList = patSumsResponse.CARE_TEAMS;
						var numberOfCareTeams = careTeamList.length;

						//Create a mapping of personnel ids to the personnel object
						for (var i = 0; i < numberOfPersonnel; i++) {
							personnelMapping[personnelList[i].ID] = personnelList[i];
						}
						//Create a mapping of careteam ids to the careteam object
						for (i = 0; i < numberOfCareTeams; i++) {
							careTeamMapping[careTeamList[i].ID] = careTeamList[i];
						}

						//Populate patient summaries into a list from the reply
						if (patSumsResponse.PATIENT_SUMMARY.PATIENT_SUMMARIES) {
							summariesList = patSumsResponse.PATIENT_SUMMARY.PATIENT_SUMMARIES;
							var patSumCount = summariesList.length;
							for (i = 0; i < patSumCount; i++) {
								var summary = summariesList[i];
								var dateTimeString = "--";
								var displayText = summary.TEXT;
								if (summary.UPDT_DATE) {
									var dateTime = new Date();
									dateTime.setISO8601(summary.UPDT_DATE);
									dateTimeString = MP_Util.GetDateFormatter().format(dateTime, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
								}
								summary.DATE_DISPLAY = dateTimeString;
								var patSumAuthorId = personnelMapping[summary.UPDT_BY_ID];
								summary.PERSONNEL_DISPLAY = patSumAuthorId ? patSumAuthorId.PROVIDER_NAME.NAME_FULL : "";

								//If a care team is associated to the result, display that information, otherwise it belongs to patient lists
								var patSumMedServ = careTeamMapping[summary.PCT_CARE_TEAM_ID];
								if (patSumMedServ) {
									summary.CARETEAM_DISPLAY = careTeamMapping[summary.PCT_CARE_TEAM_ID].CTEAM_DETAILS.DISPLAY_NAME_HTML;
								}
								else {
									summary.CARETEAM_DISPLAY = iPassI18N.PATIENT_LISTS;
								}
								summary.TEXT = renderPatSumText(displayText);
								patSumsList.push(summary);
							}
						}
	
						//Bind the data to the table
						allPatSumTable.bindData(patSumsList);
						allPatSumTable.sortByColumnInDirection("DATE", TableColumn.SORT.DESCENDING);

						modalBody.html(allPatSumTable.render());

						//Grab some of the table elements since we'll be needing them for resizing
						var tableHeader = $("#ipassAllMedServicesPatSumheaderWrapper");
						var tableBody = $("#ipassAllMedServicesPatSumtableBody");
						
						$("#ipassPatSumtable").addClass("ipass-component-table");
						//Set the initial max-height of the table body so scrolling is correctly applied
						tableBody.css({
							"max-height" : calculateTableHeight(modalBody, tableHeader) + "px",
							"overflow-y" : "auto"
						});
						allPatSumTable.updateAfterResize();
						//Call to finalize the table, attaching all event listeners
						allPatSumTable.finalize();
						
						$(window).on("resize.ipasstable", function() {
							tableBody.css({
								"max-height" : calculateTableHeight(modalBody, tableHeader) + "px",
								"overflow-y" : "auto"
							});
							allPatSumTable.updateAfterResize();
						}); 
					}
					catch(exception) {
						modalBody.html(MP_Util.HandleErrorResponse("ipassAllMedServicesPatSum", exception.message));
					}
				});
			});
			showAllMedServModal.addFooterButton(getCloseButtonContext("iPassPatSumMedServModalClose", "ipasstable"));
			//Make call to the modal framework to display the modal
			MP_ModalDialog.addModalDialogObject(showAllMedServModal);
			MP_ModalDialog.showModalDialog(showAllMedServModal.getId());
		}
		};
		}();



/**
 * This namespace is used to isloate all of the iPass Actions functions and also provide global access
 * This object still exists due to the IPASSActions component having references to the i18n content located in the object
 * @namespace CERN_IPASS_ACTIONS_O1
 * @static
 * @global
 */
var CERN_IPASS_ACTIONS_O1 = {
	actionsI18N : i18n.discernabu.ipass_actions,
	iPassI18N : i18n.discernabu.ipass,
	iPassActionsRef : null
};
var _canLog=true;
function _log(mode,msg){if(!_canLog){return;
}var args=Array.prototype.slice.apply(arguments,[1]);
var dt=new Date();
var tag=dt.getHours()+":"+dt.getMinutes()+":"+dt.getSeconds()+"."+dt.getMilliseconds();
args[0]=tag+" - "+args[0];
try{switch(mode){case"info":window.console.info.apply(window.console,args);
break;
case"warn":window.console.warn.apply(window.console,args);
break;
default:window.console.log.apply(window.console,args);
break;
}}catch(e){if(!window.console){_canLog=false;
}}}function logMsg(msg){Array.prototype.unshift.apply(arguments,["debug"]);
_log.apply(this,arguments);
}var getDynaTreePersistData=null;
var DTNodeStatus_Error=-1;
var DTNodeStatus_Loading=1;
var DTNodeStatus_Ok=0;
(function($){var Class={create:function(){return function(){this.initialize.apply(this,arguments);
};
}};
function getDtNodeFromElement(el){alert("getDtNodeFromElement is deprecated");
return $.ui.dynatree.getNode(el);
}function noop(){}var DynaTreeNode=Class.create();
DynaTreeNode.prototype={initialize:function(parent,tree,data){this.parent=parent;
this.tree=tree;
if(typeof data==="string"){data={title:data};
}if(data.key===undefined){data.key="_"+tree._nodeCount++;
}this.data=$.extend({},$.ui.dynatree.nodedatadefaults,data);
this.li=null;
this.span=null;
this.ul=null;
this.childList=null;
this._isLoading=false;
this.hasSubSel=false;
this.bExpanded=false;
this.bSelected=false;
},toString:function(){return"DynaTreeNode<"+this.data.key+">: '"+this.data.title+"'";
},toDict:function(recursive,callback){var dict=$.extend({},this.data);
dict.activate=(this.tree.activeNode===this);
dict.focus=(this.tree.focusNode===this);
dict.expand=this.bExpanded;
dict.select=this.bSelected;
if(callback){callback(dict);
}if(recursive&&this.childList){dict.children=[];
for(var i=0,l=this.childList.length;
i<l;
i++){dict.children.push(this.childList[i].toDict(true,callback));
}}else{delete dict.children;
}return dict;
},fromDict:function(dict){var children=dict.children;
if(children===undefined){this.data=$.extend(this.data,dict);
this.render();
return;
}dict=$.extend({},dict);
dict.children=undefined;
this.data=$.extend(this.data,dict);
this.removeChildren();
this.addChild(children);
},_getInnerHtml:function(){var tree=this.tree,opts=tree.options,cache=tree.cache,level=this.getLevel(),data=this.data,res="";
if(level<opts.minExpandLevel){if(level>1){res+=cache.tagConnector;
}}else{if(this.hasChildren()!==false){res+=cache.tagExpander;
}else{res+=cache.tagConnector;
}}if(opts.checkbox&&data.hideCheckbox!==true&&!data.isStatusNode){res+=cache.tagCheckbox;
}if(data.icon){res+="<img src='"+opts.imagePath+data.icon+"' alt='' />";
}else{if(data.icon===false){noop();
}else{res+=cache.tagNodeIcon;
}}var nodeTitle="";
if(opts.onCustomRender){nodeTitle=opts.onCustomRender.call(tree,this)||"";
}if(!nodeTitle){var tooltip=data.tooltip?' title="'+data.tooltip.replace(/\"/g,"&quot;")+'"':"",href=data.href||"#";
if(opts.noLink||data.noLink){nodeTitle='<span style="display:inline-block;" class="'+opts.classNames.title+'"'+tooltip+">"+data.title+"</span>";
}else{nodeTitle='<a href="'+href+'" class="'+opts.classNames.title+'"'+tooltip+">"+data.title+"</a>";
}}res+=nodeTitle;
return res;
},_fixOrder:function(){var cl=this.childList;
if(!cl||!this.ul){return;
}var childLI=this.ul.firstChild;
for(var i=0,l=cl.length-1;
i<l;
i++){var childNode1=cl[i];
var childNode2=childLI.dtnode;
if(childNode1!==childNode2){this.tree.logDebug("_fixOrder: mismatch at index "+i+": "+childNode1+" != "+childNode2);
this.ul.insertBefore(childNode1.li,childNode2.li);
}else{childLI=childLI.nextSibling;
}}},render:function(useEffects,includeInvisible){var tree=this.tree,parent=this.parent,data=this.data,opts=tree.options,cn=opts.classNames,isLastSib=this.isLastSibling(),firstTime=false;
if(!parent&&!this.ul){this.li=this.span=null;
this.ul=document.createElement("ul");
if(opts.minExpandLevel>1){this.ul.className=cn.container+" "+cn.noConnector;
}else{this.ul.className=cn.container;
}}else{if(parent){if(!this.li){firstTime=true;
this.li=document.createElement("li");
this.li.dtnode=this;
if(data.key&&opts.generateIds){this.li.id=opts.idPrefix+data.key;
}this.span=document.createElement("span");
this.span.className=cn.title;
this.li.appendChild(this.span);
if(!parent.ul){parent.ul=document.createElement("ul");
parent.ul.style.display="none";
parent.li.appendChild(parent.ul);
}parent.ul.appendChild(this.li);
}this.span.innerHTML=this._getInnerHtml();
var cnList=[];
cnList.push(cn.node);
if(data.isFolder){cnList.push(cn.folder);
}if(this.bExpanded){cnList.push(cn.expanded);
}if(this.hasChildren()!==false){cnList.push(cn.hasChildren);
}if(data.isLazy&&this.childList===null){cnList.push(cn.lazy);
}if(isLastSib){cnList.push(cn.lastsib);
}if(this.bSelected){cnList.push(cn.selected);
}if(this.hasSubSel){cnList.push(cn.partsel);
}if(tree.activeNode===this){cnList.push(cn.active);
}if(data.addClass){cnList.push(data.addClass);
}cnList.push(cn.combinedExpanderPrefix+(this.bExpanded?"e":"c")+(data.isLazy&&this.childList===null?"d":"")+(isLastSib?"l":""));
cnList.push(cn.combinedIconPrefix+(this.bExpanded?"e":"c")+(data.isFolder?"f":""));
this.span.className=cnList.join(" ");
this.li.className=isLastSib?cn.lastsib:"";
if(firstTime&&opts.onCreate){opts.onCreate.call(tree,this,this.span);
}if(opts.onRender){opts.onRender.call(tree,this,this.span);
}}}if((this.bExpanded||includeInvisible===true)&&this.childList){for(var i=0,l=this.childList.length;
i<l;
i++){this.childList[i].render(false,includeInvisible);
}this._fixOrder();
}if(this.ul){var isHidden=(this.ul.style.display==="none");
var isExpanded=!!this.bExpanded;
if(useEffects&&opts.fx&&(isHidden===isExpanded)){var duration=opts.fx.duration||200;
$(this.ul).animate(opts.fx,duration);
}else{this.ul.style.display=(this.bExpanded||!parent)?"":"none";
}}},getKeyPath:function(excludeSelf){var path=[];
this.visitParents(function(node){if(node.parent){path.unshift(node.data.key);
}},!excludeSelf);
return"/"+path.join(this.tree.options.keyPathSeparator);
},getParent:function(){return this.parent;
},getChildren:function(){if(this.hasChildren()===undefined){return undefined;
}return this.childList;
},hasChildren:function(){if(this.data.isLazy){if(this.childList===null||this.childList===undefined){return undefined;
}else{if(this.childList.length===0){return false;
}else{if(this.childList.length===1&&this.childList[0].isStatusNode()){return undefined;
}}}return true;
}return !!this.childList;
},isFirstSibling:function(){var p=this.parent;
return !p||p.childList[0]===this;
},isLastSibling:function(){var p=this.parent;
return !p||p.childList[p.childList.length-1]===this;
},isLoading:function(){return !!this._isLoading;
},getPrevSibling:function(){if(!this.parent){return null;
}var ac=this.parent.childList;
for(var i=1,l=ac.length;
i<l;
i++){if(ac[i]===this){return ac[i-1];
}}return null;
},getNextSibling:function(){if(!this.parent){return null;
}var ac=this.parent.childList;
for(var i=0,l=ac.length-1;
i<l;
i++){if(ac[i]===this){return ac[i+1];
}}return null;
},isStatusNode:function(){return(this.data.isStatusNode===true);
},isChildOf:function(otherNode){return(this.parent&&this.parent===otherNode);
},isDescendantOf:function(otherNode){if(!otherNode){return false;
}var p=this.parent;
while(p){if(p===otherNode){return true;
}p=p.parent;
}return false;
},countChildren:function(){var cl=this.childList;
if(!cl){return 0;
}var n=cl.length;
for(var i=0,l=n;
i<l;
i++){var child=cl[i];
n+=child.countChildren();
}return n;
},sortChildren:function(cmp,deep){var cl=this.childList;
if(!cl){return;
}cmp=cmp||function(a,b){var x=a.data.title.toLowerCase(),y=b.data.title.toLowerCase();
return x===y?0:x>y?1:-1;
};
cl.sort(cmp);
if(deep){for(var i=0,l=cl.length;
i<l;
i++){if(cl[i].childList){cl[i].sortChildren(cmp,"$norender$");
}}}if(deep!=="$norender$"){this.render();
}},_setStatusNode:function(data){var firstChild=(this.childList?this.childList[0]:null);
if(!data){if(firstChild&&firstChild.isStatusNode()){try{if(this.ul){this.ul.removeChild(firstChild.li);
firstChild.li=null;
}}catch(e){}if(this.childList.length===1){this.childList=[];
}else{this.childList.shift();
}}}else{if(firstChild){data.isStatusNode=true;
data.key="_statusNode";
firstChild.data=data;
firstChild.render();
}else{data.isStatusNode=true;
data.key="_statusNode";
firstChild=this.addChild(data);
}}},setLazyNodeStatus:function(lts,opts){var tooltip=(opts&&opts.tooltip)?opts.tooltip:null,info=(opts&&opts.info)?" ("+opts.info+")":"";
switch(lts){case DTNodeStatus_Ok:this._setStatusNode(null);
$(this.span).removeClass(this.tree.options.classNames.nodeLoading);
this._isLoading=false;
if(this.tree.options.autoFocus){if(this===this.tree.tnRoot&&this.childList&&this.childList.length>0){this.childList[0].focus();
}else{this.focus();
}}break;
case DTNodeStatus_Loading:this._isLoading=true;
$(this.span).addClass(this.tree.options.classNames.nodeLoading);
if(!this.parent){this._setStatusNode({title:this.tree.options.strings.loading+info,tooltip:tooltip,addClass:this.tree.options.classNames.nodeWait});
}break;
case DTNodeStatus_Error:this._isLoading=false;
this._setStatusNode({title:this.tree.options.strings.loadError+info,tooltip:tooltip,addClass:this.tree.options.classNames.nodeError});
break;
default:throw"Bad LazyNodeStatus: '"+lts+"'.";
}},_parentList:function(includeRoot,includeSelf){var l=[];
var dtn=includeSelf?this:this.parent;
while(dtn){if(includeRoot||dtn.parent){l.unshift(dtn);
}dtn=dtn.parent;
}return l;
},getLevel:function(){var level=0;
var dtn=this.parent;
while(dtn){level++;
dtn=dtn.parent;
}return level;
},_getTypeForOuterNodeEvent:function(event){var cns=this.tree.options.classNames;
var target=event.target;
if(target.className.indexOf(cns.node)<0){return null;
}var eventX=event.pageX-target.offsetLeft;
var eventY=event.pageY-target.offsetTop;
for(var i=0,l=target.childNodes.length;
i<l;
i++){var cn=target.childNodes[i];
var x=cn.offsetLeft-target.offsetLeft;
var y=cn.offsetTop-target.offsetTop;
var nx=cn.clientWidth,ny=cn.clientHeight;
if(eventX>=x&&eventX<=(x+nx)&&eventY>=y&&eventY<=(y+ny)){if(cn.className==cns.title){return"title";
}else{if(cn.className==cns.expander){return"expander";
}else{if(cn.className==cns.checkbox){return"checkbox";
}else{if(cn.className==cns.nodeIcon){return"icon";
}}}}}}return"prefix";
},getEventTargetType:function(event){var tcn=event&&event.target?event.target.className:"",cns=this.tree.options.classNames;
if(tcn===cns.title){return"title";
}else{if(tcn===cns.expander){return"expander";
}else{if(tcn===cns.checkbox){return"checkbox";
}else{if(tcn===cns.nodeIcon){return"icon";
}else{if(tcn===cns.empty||tcn===cns.vline||tcn===cns.connector){return"prefix";
}else{if(tcn.indexOf(cns.node)>=0){return this._getTypeForOuterNodeEvent(event);
}}}}}}return null;
},isVisible:function(){var parents=this._parentList(true,false);
for(var i=0,l=parents.length;
i<l;
i++){if(!parents[i].bExpanded){return false;
}}return true;
},makeVisible:function(){var parents=this._parentList(true,false);
for(var i=0,l=parents.length;
i<l;
i++){parents[i]._expand(true);
}},focus:function(){this.makeVisible();
try{$(this.span).find(">a").focus();
}catch(e){}},isFocused:function(){return(this.tree.tnFocused===this);
},_activate:function(flag,fireEvents){this.tree.logDebug("dtnode._activate(%o, fireEvents=%o) - %o",flag,fireEvents,this);
var opts=this.tree.options;
if(this.data.isStatusNode){return;
}if(fireEvents&&opts.onQueryActivate&&opts.onQueryActivate.call(this.tree,flag,this)===false){return;
}if(flag){if(this.tree.activeNode){if(this.tree.activeNode===this){return;
}this.tree.activeNode.deactivate();
}if(opts.activeVisible){this.makeVisible();
}this.tree.activeNode=this;
if(opts.persist){$.cookie(opts.cookieId+"-active",this.data.key,opts.cookie);
}this.tree.persistence.activeKey=this.data.key;
$(this.span).addClass(opts.classNames.active);
if(fireEvents&&opts.onActivate){opts.onActivate.call(this.tree,this);
}}else{if(this.tree.activeNode===this){if(opts.onQueryActivate&&opts.onQueryActivate.call(this.tree,false,this)===false){return;
}$(this.span).removeClass(opts.classNames.active);
if(opts.persist){$.cookie(opts.cookieId+"-active","",opts.cookie);
}this.tree.persistence.activeKey=null;
this.tree.activeNode=null;
if(fireEvents&&opts.onDeactivate){opts.onDeactivate.call(this.tree,this);
}}}},activate:function(){this._activate(true,true);
},activateSilently:function(){this._activate(true,false);
},deactivate:function(){this._activate(false,true);
},isActive:function(){return(this.tree.activeNode===this);
},_userActivate:function(){var activate=true;
var expand=false;
if(this.data.isFolder){switch(this.tree.options.clickFolderMode){case 2:activate=false;
expand=true;
break;
case 3:activate=expand=true;
break;
}}if(this.parent===null){expand=false;
}if(expand){this.toggleExpand();
this.focus();
}if(activate){this.activate();
}},_setSubSel:function(hasSubSel){if(hasSubSel){this.hasSubSel=true;
$(this.span).addClass(this.tree.options.classNames.partsel);
}else{this.hasSubSel=false;
$(this.span).removeClass(this.tree.options.classNames.partsel);
}},_updatePartSelectionState:function(){var sel;
if(!this.hasChildren()){sel=(this.bSelected&&!this.data.unselectable&&!this.data.isStatusNode);
this._setSubSel(false);
return sel;
}var i,l,cl=this.childList,allSelected=true,allDeselected=true;
for(i=0,l=cl.length;
i<l;
i++){var n=cl[i],s=n._updatePartSelectionState();
if(s!==false){allDeselected=false;
}if(s!==true){allSelected=false;
}}if(allSelected){sel=true;
}else{if(allDeselected){sel=false;
}else{sel=undefined;
}}this._setSubSel(sel===undefined);
this.bSelected=(sel===true);
return sel;
},_fixSelectionState:function(){var p,i,l;
if(this.bSelected){this.visit(function(node){node.parent._setSubSel(true);
if(!node.data.unselectable){node._select(true,false,false);
}});
p=this.parent;
while(p){p._setSubSel(true);
var allChildsSelected=true;
for(i=0,l=p.childList.length;
i<l;
i++){var n=p.childList[i];
if(!n.bSelected&&!n.data.isStatusNode&&!n.data.unselectable){allChildsSelected=false;
break;
}}if(allChildsSelected){p._select(true,false,false);
}p=p.parent;
}}else{this._setSubSel(false);
this.visit(function(node){node._setSubSel(false);
node._select(false,false,false);
});
p=this.parent;
while(p){p._select(false,false,false);
var isPartSel=false;
for(i=0,l=p.childList.length;
i<l;
i++){if(p.childList[i].bSelected||p.childList[i].hasSubSel){isPartSel=true;
break;
}}p._setSubSel(isPartSel);
p=p.parent;
}}},_select:function(sel,fireEvents,deep){var opts=this.tree.options;
if(this.data.isStatusNode){return;
}if(this.bSelected===sel){return;
}if(fireEvents&&opts.onQuerySelect&&opts.onQuerySelect.call(this.tree,sel,this)===false){return;
}if(opts.selectMode==1&&sel){this.tree.visit(function(node){if(node.bSelected){node._select(false,false,false);
return false;
}});
}this.bSelected=sel;
if(sel){if(opts.persist){this.tree.persistence.addSelect(this.data.key);
}$(this.span).addClass(opts.classNames.selected);
if(deep&&opts.selectMode===3){this._fixSelectionState();
}if(fireEvents&&opts.onSelect){opts.onSelect.call(this.tree,true,this);
}}else{if(opts.persist){this.tree.persistence.clearSelect(this.data.key);
}$(this.span).removeClass(opts.classNames.selected);
if(deep&&opts.selectMode===3){this._fixSelectionState();
}if(fireEvents&&opts.onSelect){opts.onSelect.call(this.tree,false,this);
}}},select:function(sel){if(this.data.unselectable){return this.bSelected;
}return this._select(sel!==false,true,true);
},toggleSelect:function(){return this.select(!this.bSelected);
},isSelected:function(){return this.bSelected;
},isLazy:function(){return !!this.data.isLazy;
},_loadContent:function(){try{var opts=this.tree.options;
this.tree.logDebug("_loadContent: start - %o",this);
this.setLazyNodeStatus(DTNodeStatus_Loading);
if(true===opts.onLazyRead.call(this.tree,this)){this.setLazyNodeStatus(DTNodeStatus_Ok);
this.tree.logDebug("_loadContent: succeeded - %o",this);
}}catch(e){this.tree.logWarning("_loadContent: failed - %o",e);
this.setLazyNodeStatus(DTNodeStatus_Error,{tooltip:""+e});
}},_expand:function(bExpand,forceSync){if(this.bExpanded===bExpand){this.tree.logDebug("dtnode._expand(%o) IGNORED - %o",bExpand,this);
return;
}this.tree.logDebug("dtnode._expand(%o) - %o",bExpand,this);
var opts=this.tree.options;
if(!bExpand&&this.getLevel()<opts.minExpandLevel){this.tree.logDebug("dtnode._expand(%o) prevented collapse - %o",bExpand,this);
return;
}if(opts.onQueryExpand&&opts.onQueryExpand.call(this.tree,bExpand,this)===false){return;
}this.bExpanded=bExpand;
if(opts.persist){if(bExpand){this.tree.persistence.addExpand(this.data.key);
}else{this.tree.persistence.clearExpand(this.data.key);
}}var allowEffects=!(this.data.isLazy&&this.childList===null)&&!this._isLoading&&!forceSync;
this.render(allowEffects);
if(this.bExpanded&&this.parent&&opts.autoCollapse){var parents=this._parentList(false,true);
for(var i=0,l=parents.length;
i<l;
i++){parents[i].collapseSiblings();
}}if(opts.activeVisible&&this.tree.activeNode&&!this.tree.activeNode.isVisible()){this.tree.activeNode.deactivate();
}if(bExpand&&this.data.isLazy&&this.childList===null&&!this._isLoading){this._loadContent();
return;
}if(opts.onExpand){opts.onExpand.call(this.tree,bExpand,this);
}},isExpanded:function(){return this.bExpanded;
},expand:function(flag){flag=(flag!==false);
if(!this.childList&&!this.data.isLazy&&flag){return;
}else{if(this.parent===null&&!flag){return;
}}this._expand(flag);
},scheduleAction:function(mode,ms){if(this.tree.timer){clearTimeout(this.tree.timer);
this.tree.logDebug("clearTimeout(%o)",this.tree.timer);
}var self=this;
switch(mode){case"cancel":break;
case"expand":this.tree.timer=setTimeout(function(){self.tree.logDebug("setTimeout: trigger expand");
self.expand(true);
},ms);
break;
case"activate":this.tree.timer=setTimeout(function(){self.tree.logDebug("setTimeout: trigger activate");
self.activate();
},ms);
break;
default:throw"Invalid mode "+mode;
}this.tree.logDebug("setTimeout(%s, %s): %s",mode,ms,this.tree.timer);
},toggleExpand:function(){this.expand(!this.bExpanded);
},collapseSiblings:function(){if(this.parent===null){return;
}var ac=this.parent.childList;
for(var i=0,l=ac.length;
i<l;
i++){if(ac[i]!==this&&ac[i].bExpanded){ac[i]._expand(false);
}}},_onClick:function(event){var targetType=this.getEventTargetType(event);
if(targetType==="expander"){this.toggleExpand();
this.focus();
}else{if(targetType==="checkbox"){this.toggleSelect();
this.focus();
}else{this._userActivate();
var aTag=this.span.getElementsByTagName("a");
if(aTag[0]){if(!($.browser.msie&&parseInt($.browser.version,10)<9)){aTag[0].focus();
}}else{return true;
}}}event.preventDefault();
},_onDblClick:function(event){},_onKeydown:function(event){var handled=true,sib;
switch(event.which){case 107:case 187:if(!this.bExpanded){this.toggleExpand();
}break;
case 109:case 189:if(this.bExpanded){this.toggleExpand();
}break;
case 32:this._userActivate();
break;
case 8:if(this.parent){this.parent.focus();
}break;
case 37:if(this.bExpanded){this.toggleExpand();
this.focus();
}else{if(this.parent&&this.parent.parent){this.parent.focus();
}}break;
case 39:if(!this.bExpanded&&(this.childList||this.data.isLazy)){this.toggleExpand();
this.focus();
}else{if(this.childList){this.childList[0].focus();
}}break;
case 38:sib=this.getPrevSibling();
while(sib&&sib.bExpanded&&sib.childList){sib=sib.childList[sib.childList.length-1];
}if(!sib&&this.parent&&this.parent.parent){sib=this.parent;
}if(sib){sib.focus();
}break;
case 40:if(this.bExpanded&&this.childList){sib=this.childList[0];
}else{var parents=this._parentList(false,true);
for(var i=parents.length-1;
i>=0;
i--){sib=parents[i].getNextSibling();
if(sib){break;
}}}if(sib){sib.focus();
}break;
default:handled=false;
}if(handled){event.preventDefault();
}},_onKeypress:function(event){},_onFocus:function(event){var opts=this.tree.options;
if(event.type=="blur"||event.type=="focusout"){if(opts.onBlur){opts.onBlur.call(this.tree,this);
}if(this.tree.tnFocused){$(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
}this.tree.tnFocused=null;
if(opts.persist){$.cookie(opts.cookieId+"-focus","",opts.cookie);
}}else{if(event.type=="focus"||event.type=="focusin"){if(this.tree.tnFocused&&this.tree.tnFocused!==this){this.tree.logDebug("dtnode.onFocus: out of sync: curFocus: %o",this.tree.tnFocused);
$(this.tree.tnFocused.span).removeClass(opts.classNames.focused);
}this.tree.tnFocused=this;
if(opts.onFocus){opts.onFocus.call(this.tree,this);
}$(this.tree.tnFocused.span).addClass(opts.classNames.focused);
if(opts.persist){$.cookie(opts.cookieId+"-focus",this.data.key,opts.cookie);
}}}},visit:function(fn,includeSelf){var res=true;
if(includeSelf===true){res=fn(this);
if(res===false||res=="skip"){return res;
}}if(this.childList){for(var i=0,l=this.childList.length;
i<l;
i++){res=this.childList[i].visit(fn,true);
if(res===false){break;
}}}return res;
},visitParents:function(fn,includeSelf){if(includeSelf&&fn(this)===false){return false;
}var p=this.parent;
while(p){if(fn(p)===false){return false;
}p=p.parent;
}return true;
},remove:function(){if(this===this.tree.root){throw"Cannot remove system root";
}return this.parent.removeChild(this);
},removeChild:function(tn){var ac=this.childList;
if(ac.length==1){if(tn!==ac[0]){throw"removeChild: invalid child";
}return this.removeChildren();
}if(tn===this.tree.activeNode){tn.deactivate();
}if(this.tree.options.persist){if(tn.bSelected){this.tree.persistence.clearSelect(tn.data.key);
}if(tn.bExpanded){this.tree.persistence.clearExpand(tn.data.key);
}}tn.removeChildren(true);
this.ul.removeChild(tn.li);
for(var i=0,l=ac.length;
i<l;
i++){if(ac[i]===tn){this.childList.splice(i,1);
break;
}}},removeChildren:function(isRecursiveCall,retainPersistence){this.tree.logDebug("%s.removeChildren(%o)",this,isRecursiveCall);
var tree=this.tree;
var ac=this.childList;
if(ac){for(var i=0,l=ac.length;
i<l;
i++){var tn=ac[i];
if(tn===tree.activeNode&&!retainPersistence){tn.deactivate();
}if(this.tree.options.persist&&!retainPersistence){if(tn.bSelected){this.tree.persistence.clearSelect(tn.data.key);
}if(tn.bExpanded){this.tree.persistence.clearExpand(tn.data.key);
}}tn.removeChildren(true,retainPersistence);
if(this.ul){$("li",$(this.ul)).remove();
}}this.childList=null;
}if(!isRecursiveCall){this._isLoading=false;
this.render();
}},setTitle:function(title){this.fromDict({title:title});
},reload:function(force){throw"Use reloadChildren() instead";
},reloadChildren:function(callback){if(this.parent===null){throw"Use tree.reload() instead";
}else{if(!this.data.isLazy){throw"node.reloadChildren() requires lazy nodes.";
}}if(callback){var self=this;
var eventType="nodeLoaded.dynatree."+this.tree.$tree.attr("id")+"."+this.data.key;
this.tree.$tree.bind(eventType,function(e,node,isOk){self.tree.$tree.unbind(eventType);
self.tree.logDebug("loaded %o, %o, %o",e,node,isOk);
if(node!==self){throw"got invalid load event";
}callback.call(self.tree,node,isOk);
});
}this.removeChildren();
this._loadContent();
},_loadKeyPath:function(keyPath,callback){var tree=this.tree;
tree.logDebug("%s._loadKeyPath(%s)",this,keyPath);
if(keyPath===""){throw"Key path must not be empty";
}var segList=keyPath.split(tree.options.keyPathSeparator);
if(segList[0]===""){throw"Key path must be relative (don't start with '/')";
}var seg=segList.shift();
if(this.childList){for(var i=0,l=this.childList.length;
i<l;
i++){var child=this.childList[i];
if(child.data.key===seg){if(segList.length===0){callback.call(tree,child,"ok");
}else{if(child.data.isLazy&&(child.childList===null||child.childList===undefined)){tree.logDebug("%s._loadKeyPath(%s) -> reloading %s...",this,keyPath,child);
var self=this;
child.reloadChildren(function(node,isOk){if(isOk){tree.logDebug("%s._loadKeyPath(%s) -> reloaded %s.",node,keyPath,node);
callback.call(tree,child,"loaded");
node._loadKeyPath(segList.join(tree.options.keyPathSeparator),callback);
}else{tree.logWarning("%s._loadKeyPath(%s) -> reloadChildren() failed.",self,keyPath);
callback.call(tree,child,"error");
}});
}else{callback.call(tree,child,"loaded");
child._loadKeyPath(segList.join(tree.options.keyPathSeparator),callback);
}}return;
}}}callback.call(tree,undefined,"notfound",seg,segList.length===0);
tree.logWarning("Node not found: "+seg);
return;
},resetLazy:function(){if(this.parent===null){throw"Use tree.reload() instead";
}else{if(!this.data.isLazy){throw"node.resetLazy() requires lazy nodes.";
}}this.expand(false);
this.removeChildren();
},_addChildNode:function(dtnode,beforeNode){var tree=this.tree,opts=tree.options,pers=tree.persistence;
dtnode.parent=this;
if(this.childList===null){this.childList=[];
}else{if(!beforeNode){if(this.childList.length>0){$(this.childList[this.childList.length-1].span).removeClass(opts.classNames.lastsib);
}}}if(beforeNode){var iBefore=$.inArray(beforeNode,this.childList);
if(iBefore<0){throw"<beforeNode> must be a child of <this>";
}this.childList.splice(iBefore,0,dtnode);
}else{this.childList.push(dtnode);
}var isInitializing=tree.isInitializing();
if(opts.persist&&pers.cookiesFound&&isInitializing){if(pers.activeKey===dtnode.data.key){tree.activeNode=dtnode;
}if(pers.focusedKey===dtnode.data.key){tree.focusNode=dtnode;
}dtnode.bExpanded=($.inArray(dtnode.data.key,pers.expandedKeyList)>=0);
dtnode.bSelected=($.inArray(dtnode.data.key,pers.selectedKeyList)>=0);
}else{if(dtnode.data.activate){tree.activeNode=dtnode;
if(opts.persist){pers.activeKey=dtnode.data.key;
}}if(dtnode.data.focus){tree.focusNode=dtnode;
if(opts.persist){pers.focusedKey=dtnode.data.key;
}}dtnode.bExpanded=(dtnode.data.expand===true);
if(dtnode.bExpanded&&opts.persist){pers.addExpand(dtnode.data.key);
}dtnode.bSelected=(dtnode.data.select===true);
if(dtnode.bSelected&&opts.persist){pers.addSelect(dtnode.data.key);
}}if(opts.minExpandLevel>=dtnode.getLevel()){this.bExpanded=true;
}if(dtnode.bSelected&&opts.selectMode==3){var p=this;
while(p){if(!p.hasSubSel){p._setSubSel(true);
}p=p.parent;
}}if(tree.bEnableUpdate){this.render();
}return dtnode;
},addChild:function(obj,beforeNode){if(typeof(obj)=="string"){throw"Invalid data type for "+obj;
}else{if(!obj||obj.length===0){return;
}else{if(obj instanceof DynaTreeNode){return this._addChildNode(obj,beforeNode);
}}}if(!obj.length){obj=[obj];
}var prevFlag=this.tree.enableUpdate(false);
var tnFirst=null;
for(var i=0,l=obj.length;
i<l;
i++){var data=obj[i];
var dtnode=this._addChildNode(new DynaTreeNode(this,this.tree,data),beforeNode);
if(!tnFirst){tnFirst=dtnode;
}if(data.children){dtnode.addChild(data.children,null);
}}this.tree.enableUpdate(prevFlag);
return tnFirst;
},append:function(obj){this.tree.logWarning("node.append() is deprecated (use node.addChild() instead).");
return this.addChild(obj,null);
},appendAjax:function(ajaxOptions){var self=this;
this.removeChildren(false,true);
this.setLazyNodeStatus(DTNodeStatus_Loading);
if(ajaxOptions.debugLazyDelay){var ms=ajaxOptions.debugLazyDelay;
ajaxOptions.debugLazyDelay=0;
this.tree.logInfo("appendAjax: waiting for debugLazyDelay "+ms);
setTimeout(function(){self.appendAjax(ajaxOptions);
},ms);
return;
}var orgSuccess=ajaxOptions.success,orgError=ajaxOptions.error,eventType="nodeLoaded.dynatree."+this.tree.$tree.attr("id")+"."+this.data.key;
var options=$.extend({},this.tree.options.ajaxDefaults,ajaxOptions,{success:function(data,textStatus,jqXHR){var prevPhase=self.tree.phase;
self.tree.phase="init";
if(options.postProcess){data=options.postProcess.call(this,data,this.dataType);
}else{if(data&&data.hasOwnProperty("d")){data=(typeof data.d)=="string"?$.parseJSON(data.d):data.d;
}}if(!$.isArray(data)||data.length!==0){self.addChild(data,null);
}self.tree.phase="postInit";
if(orgSuccess){orgSuccess.call(options,self,data,textStatus);
}self.tree.logDebug("trigger "+eventType);
self.tree.$tree.trigger(eventType,[self,true]);
self.tree.phase=prevPhase;
self.setLazyNodeStatus(DTNodeStatus_Ok);
if($.isArray(data)&&data.length===0){self.childList=[];
self.render();
}},error:function(jqXHR,textStatus,errorThrown){self.tree.logWarning("appendAjax failed:",textStatus,":\n",jqXHR,"\n",errorThrown);
if(orgError){orgError.call(options,self,jqXHR,textStatus,errorThrown);
}self.tree.$tree.trigger(eventType,[self,false]);
self.setLazyNodeStatus(DTNodeStatus_Error,{info:textStatus,tooltip:""+errorThrown});
}});
$.ajax(options);
},move:function(targetNode,mode){var pos;
if(this===targetNode){return;
}if(!this.parent){throw"Cannot move system root";
}if(mode===undefined||mode=="over"){mode="child";
}var prevParent=this.parent;
var targetParent=(mode==="child")?targetNode:targetNode.parent;
if(targetParent.isDescendantOf(this)){throw"Cannot move a node to it's own descendant";
}if(this.parent.childList.length==1){this.parent.childList=this.parent.data.isLazy?[]:null;
this.parent.bExpanded=false;
}else{pos=$.inArray(this,this.parent.childList);
if(pos<0){throw"Internal error";
}this.parent.childList.splice(pos,1);
}if(this.parent.ul){this.parent.ul.removeChild(this.li);
}this.parent=targetParent;
if(targetParent.hasChildren()){switch(mode){case"child":targetParent.childList.push(this);
break;
case"before":pos=$.inArray(targetNode,targetParent.childList);
if(pos<0){throw"Internal error";
}targetParent.childList.splice(pos,0,this);
break;
case"after":pos=$.inArray(targetNode,targetParent.childList);
if(pos<0){throw"Internal error";
}targetParent.childList.splice(pos+1,0,this);
break;
default:throw"Invalid mode "+mode;
}}else{targetParent.childList=[this];
}if(!targetParent.ul){targetParent.ul=document.createElement("ul");
targetParent.ul.style.display="none";
targetParent.li.appendChild(targetParent.ul);
}if(this.li){targetParent.ul.appendChild(this.li);
}if(this.tree!==targetNode.tree){this.visit(function(node){node.tree=targetNode.tree;
},null,true);
throw"Not yet implemented.";
}if(!prevParent.isDescendantOf(targetParent)){prevParent.render();
}if(!targetParent.isDescendantOf(prevParent)){targetParent.render();
}},lastentry:undefined};
var DynaTreeStatus=Class.create();
DynaTreeStatus._getTreePersistData=function(cookieId,cookieOpts){var ts=new DynaTreeStatus(cookieId,cookieOpts);
ts.read();
return ts.toDict();
};
getDynaTreePersistData=DynaTreeStatus._getTreePersistData;
DynaTreeStatus.prototype={initialize:function(cookieId,cookieOpts){if(cookieId===undefined){cookieId=$.ui.dynatree.prototype.options.cookieId;
}cookieOpts=$.extend({},$.ui.dynatree.prototype.options.cookie,cookieOpts);
this.cookieId=cookieId;
this.cookieOpts=cookieOpts;
this.cookiesFound=undefined;
this.activeKey=null;
this.focusedKey=null;
this.expandedKeyList=null;
this.selectedKeyList=null;
},_log:function(msg){Array.prototype.unshift.apply(arguments,["debug"]);
_log.apply(this,arguments);
},read:function(){this.cookiesFound=false;
var cookie=$.cookie(this.cookieId+"-active");
this.activeKey=(cookie===null)?"":cookie;
if(cookie!==null){this.cookiesFound=true;
}cookie=$.cookie(this.cookieId+"-focus");
this.focusedKey=(cookie===null)?"":cookie;
if(cookie!==null){this.cookiesFound=true;
}cookie=$.cookie(this.cookieId+"-expand");
this.expandedKeyList=(cookie===null)?[]:cookie.split(",");
if(cookie!==null){this.cookiesFound=true;
}cookie=$.cookie(this.cookieId+"-select");
this.selectedKeyList=(cookie===null)?[]:cookie.split(",");
if(cookie!==null){this.cookiesFound=true;
}},write:function(){$.cookie(this.cookieId+"-active",(this.activeKey===null)?"":this.activeKey,this.cookieOpts);
$.cookie(this.cookieId+"-focus",(this.focusedKey===null)?"":this.focusedKey,this.cookieOpts);
$.cookie(this.cookieId+"-expand",(this.expandedKeyList===null)?"":this.expandedKeyList.join(","),this.cookieOpts);
$.cookie(this.cookieId+"-select",(this.selectedKeyList===null)?"":this.selectedKeyList.join(","),this.cookieOpts);
},addExpand:function(key){if($.inArray(key,this.expandedKeyList)<0){this.expandedKeyList.push(key);
$.cookie(this.cookieId+"-expand",this.expandedKeyList.join(","),this.cookieOpts);
}},clearExpand:function(key){var idx=$.inArray(key,this.expandedKeyList);
if(idx>=0){this.expandedKeyList.splice(idx,1);
$.cookie(this.cookieId+"-expand",this.expandedKeyList.join(","),this.cookieOpts);
}},addSelect:function(key){if($.inArray(key,this.selectedKeyList)<0){this.selectedKeyList.push(key);
$.cookie(this.cookieId+"-select",this.selectedKeyList.join(","),this.cookieOpts);
}},clearSelect:function(key){var idx=$.inArray(key,this.selectedKeyList);
if(idx>=0){this.selectedKeyList.splice(idx,1);
$.cookie(this.cookieId+"-select",this.selectedKeyList.join(","),this.cookieOpts);
}},isReloading:function(){return this.cookiesFound===true;
},toDict:function(){return{cookiesFound:this.cookiesFound,activeKey:this.activeKey,focusedKey:this.activeKey,expandedKeyList:this.expandedKeyList,selectedKeyList:this.selectedKeyList};
},lastentry:undefined};
var DynaTree=Class.create();
DynaTree.version="$Version: 1.2.1$";
DynaTree.prototype={initialize:function($widget){this.phase="init";
this.$widget=$widget;
this.options=$widget.options;
this.$tree=$widget.element;
this.timer=null;
this.divTree=this.$tree.get(0);
_initDragAndDrop(this);
},_load:function(callback){var $widget=this.$widget;
var opts=this.options,self=this;
this.bEnableUpdate=true;
this._nodeCount=1;
this.activeNode=null;
this.focusNode=null;
if(opts.rootVisible!==undefined){this.logWarning("Option 'rootVisible' is no longer supported.");
}if(opts.minExpandLevel<1){this.logWarning("Option 'minExpandLevel' must be >= 1.");
opts.minExpandLevel=1;
}if(opts.classNames!==$.ui.dynatree.prototype.options.classNames){opts.classNames=$.extend({},$.ui.dynatree.prototype.options.classNames,opts.classNames);
}if(opts.ajaxDefaults!==$.ui.dynatree.prototype.options.ajaxDefaults){opts.ajaxDefaults=$.extend({},$.ui.dynatree.prototype.options.ajaxDefaults,opts.ajaxDefaults);
}if(opts.dnd!==$.ui.dynatree.prototype.options.dnd){opts.dnd=$.extend({},$.ui.dynatree.prototype.options.dnd,opts.dnd);
}if(!opts.imagePath){$("script").each(function(){var _rexDtLibName=/.*dynatree[^\/]*\.js$/i;
if(this.src.search(_rexDtLibName)>=0){if(this.src.indexOf("/")>=0){opts.imagePath=this.src.slice(0,this.src.lastIndexOf("/"))+"/skin/";
}else{opts.imagePath="skin/";
}self.logDebug("Guessing imagePath from '%s': '%s'",this.src,opts.imagePath);
return false;
}});
}this.persistence=new DynaTreeStatus(opts.cookieId,opts.cookie);
if(opts.persist){if(!$.cookie){_log("warn","Please include jquery.cookie.js to use persistence.");
}this.persistence.read();
}this.logDebug("DynaTree.persistence: %o",this.persistence.toDict());
this.cache={tagEmpty:"<span class='"+opts.classNames.empty+"'></span>",tagVline:"<span class='"+opts.classNames.vline+"'></span>",tagExpander:"<span class='"+opts.classNames.expander+"'></span>",tagConnector:"<span class='"+opts.classNames.connector+"'></span>",tagNodeIcon:"<span class='"+opts.classNames.nodeIcon+"'></span>",tagCheckbox:"<span class='"+opts.classNames.checkbox+"'></span>",lastentry:undefined};
if(opts.children||(opts.initAjax&&opts.initAjax.url)||opts.initId){$(this.divTree).empty();
}var $ulInitialize=this.$tree.find(">ul:first").hide();
this.tnRoot=new DynaTreeNode(null,this,{});
this.tnRoot.bExpanded=true;
this.tnRoot.render();
this.divTree.appendChild(this.tnRoot.ul);
var root=this.tnRoot,isReloading=(opts.persist&&this.persistence.isReloading()),isLazy=false,prevFlag=this.enableUpdate(false);
this.logDebug("Dynatree._load(): read tree structure...");
if(opts.children){root.addChild(opts.children);
}else{if(opts.initAjax&&opts.initAjax.url){isLazy=true;
root.data.isLazy=true;
this._reloadAjax(callback);
}else{if(opts.initId){this._createFromTag(root,$("#"+opts.initId));
}else{this._createFromTag(root,$ulInitialize);
$ulInitialize.remove();
}}}this._checkConsistency();
if(!isLazy&&opts.selectMode==3){root._updatePartSelectionState();
}this.logDebug("Dynatree._load(): render nodes...");
this.enableUpdate(prevFlag);
this.logDebug("Dynatree._load(): bind events...");
this.$widget.bind();
this.logDebug("Dynatree._load(): postInit...");
this.phase="postInit";
if(opts.persist){this.persistence.write();
}if(this.focusNode&&this.focusNode.isVisible()){this.logDebug("Focus on init: %o",this.focusNode);
this.focusNode.focus();
}if(!isLazy){if(opts.onPostInit){opts.onPostInit.call(this,isReloading,false);
}if(callback){callback.call(this,"ok");
}}this.phase="idle";
},_reloadAjax:function(callback){var opts=this.options;
if(!opts.initAjax||!opts.initAjax.url){throw"tree.reload() requires 'initAjax' mode.";
}var pers=this.persistence;
var ajaxOpts=$.extend({},opts.initAjax);
if(ajaxOpts.addActiveKey){ajaxOpts.data.activeKey=pers.activeKey;
}if(ajaxOpts.addFocusedKey){ajaxOpts.data.focusedKey=pers.focusedKey;
}if(ajaxOpts.addExpandedKeyList){ajaxOpts.data.expandedKeyList=pers.expandedKeyList.join(",");
}if(ajaxOpts.addSelectedKeyList){ajaxOpts.data.selectedKeyList=pers.selectedKeyList.join(",");
}if(ajaxOpts.success){this.logWarning("initAjax: success callback is ignored; use onPostInit instead.");
}if(ajaxOpts.error){this.logWarning("initAjax: error callback is ignored; use onPostInit instead.");
}var isReloading=pers.isReloading();
ajaxOpts.success=function(dtnode,data,textStatus){if(opts.selectMode==3){dtnode.tree.tnRoot._updatePartSelectionState();
}if(opts.onPostInit){opts.onPostInit.call(dtnode.tree,isReloading,false);
}if(callback){callback.call(dtnode.tree,"ok");
}};
ajaxOpts.error=function(dtnode,XMLHttpRequest,textStatus,errorThrown){if(opts.onPostInit){opts.onPostInit.call(dtnode.tree,isReloading,true,XMLHttpRequest,textStatus,errorThrown);
}if(callback){callback.call(dtnode.tree,"error",XMLHttpRequest,textStatus,errorThrown);
}};
this.logDebug("Dynatree._init(): send Ajax request...");
this.tnRoot.appendAjax(ajaxOpts);
},toString:function(){return"Dynatree '"+this.$tree.attr("id")+"'";
},toDict:function(){return this.tnRoot.toDict(true);
},serializeArray:function(stopOnParents){var nodeList=this.getSelectedNodes(stopOnParents),name=this.$tree.attr("name")||this.$tree.attr("id"),arr=[];
for(var i=0,l=nodeList.length;
i<l;
i++){arr.push({name:name,value:nodeList[i].data.key});
}return arr;
},getPersistData:function(){return this.persistence.toDict();
},logDebug:function(msg){if(this.options.debugLevel>=2){Array.prototype.unshift.apply(arguments,["debug"]);
_log.apply(this,arguments);
}},logInfo:function(msg){if(this.options.debugLevel>=1){Array.prototype.unshift.apply(arguments,["info"]);
_log.apply(this,arguments);
}},logWarning:function(msg){Array.prototype.unshift.apply(arguments,["warn"]);
_log.apply(this,arguments);
},isInitializing:function(){return(this.phase=="init"||this.phase=="postInit");
},isReloading:function(){return(this.phase=="init"||this.phase=="postInit")&&this.options.persist&&this.persistence.cookiesFound;
},isUserEvent:function(){return(this.phase=="userEvent");
},redraw:function(){this.tnRoot.render(false,false);
},renderInvisibleNodes:function(){this.tnRoot.render(false,true);
},reload:function(callback){this._load(callback);
},getRoot:function(){return this.tnRoot;
},enable:function(){this.$widget.enable();
},disable:function(){this.$widget.disable();
},getNodeByKey:function(key){var el=document.getElementById(this.options.idPrefix+key);
if(el){return el.dtnode?el.dtnode:null;
}var match=null;
this.visit(function(node){if(node.data.key==key){match=node;
return false;
}},true);
return match;
},getActiveNode:function(){return this.activeNode;
},reactivate:function(setFocus){var node=this.activeNode;
if(node){this.activeNode=null;
node.activate();
if(setFocus){node.focus();
}}},getSelectedNodes:function(stopOnParents){var nodeList=[];
this.tnRoot.visit(function(node){if(node.bSelected){nodeList.push(node);
if(stopOnParents===true){return"skip";
}}});
return nodeList;
},activateKey:function(key){var dtnode=(key===null)?null:this.getNodeByKey(key);
if(!dtnode){if(this.activeNode){this.activeNode.deactivate();
}this.activeNode=null;
return null;
}dtnode.focus();
dtnode.activate();
return dtnode;
},loadKeyPath:function(keyPath,callback){var segList=keyPath.split(this.options.keyPathSeparator);
if(segList[0]===""){segList.shift();
}if(segList[0]==this.tnRoot.data.key){this.logDebug("Removed leading root key.");
segList.shift();
}keyPath=segList.join(this.options.keyPathSeparator);
return this.tnRoot._loadKeyPath(keyPath,callback);
},selectKey:function(key,select){var dtnode=this.getNodeByKey(key);
if(!dtnode){return null;
}dtnode.select(select);
return dtnode;
},enableUpdate:function(bEnable){if(this.bEnableUpdate==bEnable){return bEnable;
}this.bEnableUpdate=bEnable;
if(bEnable){this.redraw();
}return !bEnable;
},count:function(){return this.tnRoot.countChildren();
},visit:function(fn,includeRoot){return this.tnRoot.visit(fn,includeRoot);
},_createFromTag:function(parentTreeNode,$ulParent){var self=this;
$ulParent.find(">li").each(function(){var $li=$(this),$liSpan=$li.find(">span:first"),$liA=$li.find(">a:first"),title,href=null,target=null,tooltip;
if($liSpan.length){title=$liSpan.html();
}else{if($liA.length){title=$liA.html();
href=$liA.attr("href");
target=$liA.attr("target");
tooltip=$liA.attr("title");
}else{title=$li.html();
var iPos=title.search(/<ul/i);
if(iPos>=0){title=$.trim(title.substring(0,iPos));
}else{title=$.trim(title);
}}}var data={title:title,tooltip:tooltip,isFolder:$li.hasClass("folder"),isLazy:$li.hasClass("lazy"),expand:$li.hasClass("expanded"),select:$li.hasClass("selected"),activate:$li.hasClass("active"),focus:$li.hasClass("focused"),noLink:$li.hasClass("noLink")};
if(href){data.href=href;
data.target=target;
}if($li.attr("title")){data.tooltip=$li.attr("title");
}if($li.attr("id")){data.key=$li.attr("id");
}if($li.attr("data")){var dataAttr=$.trim($li.attr("data"));
if(dataAttr){if(dataAttr.charAt(0)!="{"){dataAttr="{"+dataAttr+"}";
}try{$.extend(data,eval("("+dataAttr+")"));
}catch(e){throw ("Error parsing node data: "+e+"\ndata:\n'"+dataAttr+"'");
}}}var childNode=parentTreeNode.addChild(data);
var $ul=$li.find(">ul:first");
if($ul.length){self._createFromTag(childNode,$ul);
}});
},_checkConsistency:function(){},_setDndStatus:function(sourceNode,targetNode,helper,hitMode,accept){var $source=sourceNode?$(sourceNode.span):null,$target=$(targetNode.span);
if(!this.$dndMarker){this.$dndMarker=$("<div id='dynatree-drop-marker'></div>").hide().prependTo($(this.divTree).parent());
}if(hitMode==="after"||hitMode==="before"||hitMode==="over"){var pos=$target.offset();
switch(hitMode){case"before":this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-over");
this.$dndMarker.addClass("dynatree-drop-before");
pos.top-=8;
break;
case"after":this.$dndMarker.removeClass("dynatree-drop-before dynatree-drop-over");
this.$dndMarker.addClass("dynatree-drop-after");
pos.top+=8;
break;
default:this.$dndMarker.removeClass("dynatree-drop-after dynatree-drop-before");
this.$dndMarker.addClass("dynatree-drop-over");
$target.addClass("dynatree-drop-target");
pos.left+=8;
}this.$dndMarker.css({left:pos.left,top:pos.top,"z-index":1000}).show();
}else{$target.removeClass("dynatree-drop-target");
this.$dndMarker.hide();
}if(hitMode==="after"){$target.addClass("dynatree-drop-after");
}else{$target.removeClass("dynatree-drop-after");
}if(hitMode==="before"){$target.addClass("dynatree-drop-before");
}else{$target.removeClass("dynatree-drop-before");
}if(accept===true){if($source){$source.addClass("dynatree-drop-accept");
}$target.addClass("dynatree-drop-accept");
helper.addClass("dynatree-drop-accept");
}else{if($source){$source.removeClass("dynatree-drop-accept");
}$target.removeClass("dynatree-drop-accept");
helper.removeClass("dynatree-drop-accept");
}if(accept===false){if($source){$source.addClass("dynatree-drop-reject");
}$target.addClass("dynatree-drop-reject");
helper.addClass("dynatree-drop-reject");
}else{if($source){$source.removeClass("dynatree-drop-reject");
}$target.removeClass("dynatree-drop-reject");
helper.removeClass("dynatree-drop-reject");
}},_onDragEvent:function(eventName,node,otherNode,event,ui,draggable){var opts=this.options,dnd=this.options.dnd,res=null,nodeTag=$(node.span),hitMode,enterResponse;
switch(eventName){case"helper":var $helper=$("<div class='dynatree-drag-helper'><span class='dynatree-drag-helper-img' /></div>").append($(event.target).closest("a").clone());
$("ul.dynatree-container",node.tree.divTree).append($helper);
$helper.data("dtSourceNode",node);
res=$helper;
break;
case"start":if(node.isStatusNode()){res=false;
}else{if(dnd.onDragStart){res=dnd.onDragStart(node);
}}if(res===false){this.logDebug("tree.onDragStart() cancelled");
ui.helper.trigger("mouseup");
ui.helper.hide();
}else{nodeTag.addClass("dynatree-drag-source");
}break;
case"enter":res=dnd.onDragEnter?dnd.onDragEnter(node,otherNode):null;
res={over:(res!==false)&&((res===true)||(res==="over")||$.inArray("over",res)>=0),before:(res!==false)&&((res===true)||(res==="before")||$.inArray("before",res)>=0),after:(res!==false)&&((res===true)||(res==="after")||$.inArray("after",res)>=0)};
ui.helper.data("enterResponse",res);
break;
case"over":enterResponse=ui.helper.data("enterResponse");
hitMode=null;
if(enterResponse===false){break;
}else{if(typeof enterResponse==="string"){hitMode=enterResponse;
}else{var nodeOfs=nodeTag.offset();
var relPos={x:event.pageX-nodeOfs.left,y:event.pageY-nodeOfs.top};
var relPos2={x:relPos.x/nodeTag.width(),y:relPos.y/nodeTag.height()};
if(enterResponse.after&&relPos2.y>0.75){hitMode="after";
}else{if(!enterResponse.over&&enterResponse.after&&relPos2.y>0.5){hitMode="after";
}else{if(enterResponse.before&&relPos2.y<=0.25){hitMode="before";
}else{if(!enterResponse.over&&enterResponse.before&&relPos2.y<=0.5){hitMode="before";
}else{if(enterResponse.over){hitMode="over";
}}}}}if(dnd.preventVoidMoves){if(node===otherNode){hitMode=null;
}else{if(hitMode==="before"&&otherNode&&node===otherNode.getNextSibling()){hitMode=null;
}else{if(hitMode==="after"&&otherNode&&node===otherNode.getPrevSibling()){hitMode=null;
}else{if(hitMode==="over"&&otherNode&&otherNode.parent===node&&otherNode.isLastSibling()){hitMode=null;
}}}}}ui.helper.data("hitMode",hitMode);
}}if(hitMode==="over"&&dnd.autoExpandMS&&node.hasChildren()!==false&&!node.bExpanded){node.scheduleAction("expand",dnd.autoExpandMS);
}if(hitMode&&dnd.onDragOver){res=dnd.onDragOver(node,otherNode,hitMode);
}this._setDndStatus(otherNode,node,ui.helper,hitMode,res!==false);
break;
case"drop":var isForbidden=ui.helper.hasClass("dynatree-drop-reject");
hitMode=ui.helper.data("hitMode");
if(hitMode&&dnd.onDrop&&!isForbidden){dnd.onDrop(node,otherNode,hitMode,ui,draggable);
}break;
case"leave":node.scheduleAction("cancel");
ui.helper.data("enterResponse",null);
ui.helper.data("hitMode",null);
this._setDndStatus(otherNode,node,ui.helper,"out",undefined);
if(dnd.onDragLeave){dnd.onDragLeave(node,otherNode);
}break;
case"stop":nodeTag.removeClass("dynatree-drag-source");
if(dnd.onDragStop){dnd.onDragStop(node);
}break;
default:throw"Unsupported drag event: "+eventName;
}return res;
},cancelDrag:function(){var dd=$.ui.ddmanager.current;
if(dd){dd.cancel();
}},lastentry:undefined};
$.widget("ui.dynatree",{_init:function(){if(parseFloat($.ui.version)<1.8){if(this.options.debugLevel>=0){_log("warn","ui.dynatree._init() was called; you should upgrade to jquery.ui.core.js v1.8 or higher.");
}return this._create();
}if(this.options.debugLevel>=2){_log("debug","ui.dynatree._init() was called; no current default functionality.");
}},_create:function(){var opts=this.options;
if(opts.debugLevel>=1){logMsg("Dynatree._create(): version='%s', debugLevel=%o.",$.ui.dynatree.version,this.options.debugLevel);
}this.options.event+=".dynatree";
var divTree=this.element.get(0);
this.tree=new DynaTree(this);
this.tree._load();
this.tree.logDebug("Dynatree._init(): done.");
},bind:function(){this.unbind();
var eventNames="click.dynatree dblclick.dynatree";
if(this.options.keyboard){eventNames+=" keypress.dynatree keydown.dynatree";
}this.element.bind(eventNames,function(event){var dtnode=$.ui.dynatree.getNode(event.target);
if(!dtnode){return true;
}var tree=dtnode.tree;
var o=tree.options;
tree.logDebug("event(%s): dtnode: %s",event.type,dtnode);
var prevPhase=tree.phase;
tree.phase="userEvent";
try{switch(event.type){case"click":return(o.onClick&&o.onClick.call(tree,dtnode,event)===false)?false:dtnode._onClick(event);
case"dblclick":return(o.onDblClick&&o.onDblClick.call(tree,dtnode,event)===false)?false:dtnode._onDblClick(event);
case"keydown":return(o.onKeydown&&o.onKeydown.call(tree,dtnode,event)===false)?false:dtnode._onKeydown(event);
case"keypress":return(o.onKeypress&&o.onKeypress.call(tree,dtnode,event)===false)?false:dtnode._onKeypress(event);
}}catch(e){var _=null;
tree.logWarning("bind(%o): dtnode: %o, error: %o",event,dtnode,e);
}finally{tree.phase=prevPhase;
}});
function __focusHandler(event){event=$.event.fix(event||window.event);
var dtnode=$.ui.dynatree.getNode(event.target);
return dtnode?dtnode._onFocus(event):false;
}var div=this.tree.divTree;
if(div.addEventListener){div.addEventListener("focus",__focusHandler,true);
div.addEventListener("blur",__focusHandler,true);
}else{div.onfocusin=div.onfocusout=__focusHandler;
}},unbind:function(){this.element.unbind(".dynatree");
},enable:function(){this.bind();
$.Widget.prototype.enable.apply(this,arguments);
},disable:function(){this.unbind();
$.Widget.prototype.disable.apply(this,arguments);
},getTree:function(){return this.tree;
},getRoot:function(){return this.tree.getRoot();
},getActiveNode:function(){return this.tree.getActiveNode();
},getSelectedNodes:function(){return this.tree.getSelectedNodes();
},lastentry:undefined});
if(parseFloat($.ui.version)<1.8){$.ui.dynatree.getter="getTree getRoot getActiveNode getSelectedNodes";
}$.ui.dynatree.version="$Version: 1.2.1$";
$.ui.dynatree.getNode=function(el){if(el instanceof DynaTreeNode){return el;
}if(el.selector!==undefined){el=el[0];
}while(el){if(el.dtnode){return el.dtnode;
}el=el.parentNode;
}return null;
};
$.ui.dynatree.getPersistData=DynaTreeStatus._getTreePersistData;
$.ui.dynatree.prototype.options={title:"Dynatree",minExpandLevel:1,imagePath:null,children:null,initId:null,initAjax:null,autoFocus:true,keyboard:true,persist:false,autoCollapse:false,clickFolderMode:3,activeVisible:true,checkbox:false,selectMode:2,fx:null,noLink:false,onClick:null,onDblClick:null,onKeydown:null,onKeypress:null,onFocus:null,onBlur:null,onQueryActivate:null,onQuerySelect:null,onQueryExpand:null,onPostInit:null,onActivate:null,onDeactivate:null,onSelect:null,onExpand:null,onLazyRead:null,onCustomRender:null,onCreate:null,onRender:null,postProcess:null,dnd:{onDragStart:null,onDragStop:null,autoExpandMS:1000,preventVoidMoves:true,onDragEnter:null,onDragOver:null,onDrop:null,onDragLeave:null},ajaxDefaults:{cache:false,timeout:0,dataType:"json"},strings:{loading:"Loading&#8230;",loadError:"Load error!"},generateIds:false,idPrefix:"dynatree-id-",keyPathSeparator:"/",cookieId:"dynatree",cookie:{expires:null},classNames:{container:"dynatree-container",node:"dynatree-node",folder:"dynatree-folder",empty:"dynatree-empty",vline:"dynatree-vline",expander:"dynatree-expander",connector:"dynatree-connector",checkbox:"dynatree-checkbox",nodeIcon:"dynatree-icon",title:"dynatree-title",noConnector:"dynatree-no-connector",nodeError:"dynatree-statusnode-error",nodeWait:"dynatree-statusnode-wait",hidden:"dynatree-hidden",combinedExpanderPrefix:"dynatree-exp-",combinedIconPrefix:"dynatree-ico-",nodeLoading:"dynatree-loading",hasChildren:"dynatree-has-children",active:"dynatree-active",selected:"dynatree-selected",expanded:"dynatree-expanded",lazy:"dynatree-lazy",focused:"dynatree-focused",partsel:"dynatree-partsel",lastsib:"dynatree-lastsib"},debugLevel:1,lastentry:undefined};
if(parseFloat($.ui.version)<1.8){$.ui.dynatree.defaults=$.ui.dynatree.prototype.options;
}$.ui.dynatree.nodedatadefaults={title:null,key:null,isFolder:false,isLazy:false,tooltip:null,href:null,icon:null,addClass:null,noLink:false,activate:false,focus:false,expand:false,select:false,hideCheckbox:false,unselectable:false,children:null,lastentry:undefined};
function _initDragAndDrop(tree){var dnd=tree.options.dnd||null;
if(dnd&&(dnd.onDragStart||dnd.onDrop)){_registerDnd();
}if(dnd&&dnd.onDragStart){tree.$tree.draggable({addClasses:false,appendTo:"body",containment:false,delay:0,distance:4,revert:false,scroll:true,scrollSpeed:7,scrollSensitivity:10,connectToDynatree:true,helper:function(event){var sourceNode=$.ui.dynatree.getNode(event.target);
if(!sourceNode){return"<div></div>";
}return sourceNode.tree._onDragEvent("helper",sourceNode,null,event,null,null);
},start:function(event,ui){var sourceNode=ui.helper.data("dtSourceNode");
return !!sourceNode;
},_last:null});
}if(dnd&&dnd.onDrop){tree.$tree.droppable({addClasses:false,tolerance:"intersect",greedy:false,_last:null});
}}var didRegisterDnd=false;
var _registerDnd=function(){if(didRegisterDnd){return;
}$.ui.plugin.add("draggable","connectToDynatree",{start:function(event,ui){var draggable=$(this).data("draggable"),sourceNode=ui.helper.data("dtSourceNode")||null;
if(sourceNode){draggable.offset.click.top=-2;
draggable.offset.click.left=+16;
return sourceNode.tree._onDragEvent("start",sourceNode,null,event,ui,draggable);
}},drag:function(event,ui){var draggable=$(this).data("draggable"),sourceNode=ui.helper.data("dtSourceNode")||null,prevTargetNode=ui.helper.data("dtTargetNode")||null,targetNode=$.ui.dynatree.getNode(event.target);
if(event.target&&!targetNode){var isHelper=$(event.target).closest("div.dynatree-drag-helper,#dynatree-drop-marker").length>0;
if(isHelper){return;
}}ui.helper.data("dtTargetNode",targetNode);
if(prevTargetNode&&prevTargetNode!==targetNode){prevTargetNode.tree._onDragEvent("leave",prevTargetNode,sourceNode,event,ui,draggable);
}if(targetNode){if(!targetNode.tree.options.dnd.onDrop){noop();
}else{if(targetNode===prevTargetNode){targetNode.tree._onDragEvent("over",targetNode,sourceNode,event,ui,draggable);
}else{targetNode.tree._onDragEvent("enter",targetNode,sourceNode,event,ui,draggable);
}}}},stop:function(event,ui){var draggable=$(this).data("draggable"),sourceNode=ui.helper.data("dtSourceNode")||null,targetNode=ui.helper.data("dtTargetNode")||null,mouseDownEvent=draggable._mouseDownEvent,eventType=event.type,dropped=(eventType=="mouseup"&&event.which==1);
if(!dropped){logMsg("Drag was cancelled");
}if(targetNode){if(dropped){targetNode.tree._onDragEvent("drop",targetNode,sourceNode,event,ui,draggable);
}targetNode.tree._onDragEvent("leave",targetNode,sourceNode,event,ui,draggable);
}if(sourceNode){sourceNode.tree._onDragEvent("stop",sourceNode,null,event,ui,draggable);
}}});
didRegisterDnd=true;
};
}(jQuery));
/**
MIT License 

Copyright (c) 2012 Jon Nylander, project maintained at 
https://bitbucket.org/pellepim/jstimezonedetect

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to 
do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/
/* jstz.min.js Version: 1.0.5 Build date: 2014-10-28 */
!function (e) {
	var a = function () {
		"use strict";
		var e = "s",
		s = {
			DAY : 864e5,
			HOUR : 36e5,
			MINUTE : 6e4,
			SECOND : 1e3,
			BASELINE_YEAR : 2014,
			MAX_SCORE : 864e6,
			AMBIGUITIES : {
				"America/Denver" : ["America/Mazatlan"],
				"America/Chicago" : ["America/Mexico_City"],
				"America/Santiago" : ["America/Asuncion", "America/Campo_Grande"],
				"America/Montevideo" : ["America/Sao_Paulo"],
				"Asia/Beirut" : ["Asia/Amman", "Asia/Jerusalem", "Europe/Helsinki", "Asia/Damascus", "Africa/Cairo", "Asia/Gaza", "Europe/Minsk"],
				"Pacific/Auckland" : ["Pacific/Fiji"],
				"America/Los_Angeles" : ["America/Santa_Isabel"],
				"America/New_York" : ["America/Havana"],
				"America/Halifax" : ["America/Goose_Bay"],
				"America/Godthab" : ["America/Miquelon"],
				"Asia/Dubai" : ["Asia/Yerevan"],
				"Asia/Jakarta" : ["Asia/Krasnoyarsk"],
				"Asia/Shanghai" : ["Asia/Irkutsk", "Australia/Perth"],
				"Australia/Sydney" : ["Australia/Lord_Howe"],
				"Asia/Tokyo" : ["Asia/Yakutsk"],
				"Asia/Dhaka" : ["Asia/Omsk"],
				"Asia/Baku" : ["Asia/Yerevan"],
				"Australia/Brisbane" : ["Asia/Vladivostok"],
				"Pacific/Noumea" : ["Asia/Vladivostok"],
				"Pacific/Majuro" : ["Asia/Kamchatka", "Pacific/Fiji"],
				"Pacific/Tongatapu" : ["Pacific/Apia"],
				"Asia/Baghdad" : ["Europe/Minsk", "Europe/Moscow"],
				"Asia/Karachi" : ["Asia/Yekaterinburg"],
				"Africa/Johannesburg" : ["Asia/Gaza", "Africa/Cairo"]
			}
		},
		i = function (e) {
			var a = -e.getTimezoneOffset();
			return null !== a ? a : 0
		},
		r = function () {
			var a = i(new Date(s.BASELINE_YEAR, 0, 2)),
			r = i(new Date(s.BASELINE_YEAR, 5, 2)),
			n = a - r;
			return 0 > n ? a + ",1" : n > 0 ? r + ",1," + e : a + ",0"
		},
		n = function () {
			if ("undefined" != typeof Intl && "undefined" != typeof Intl.DateTimeFormat) {
				var e = Intl.DateTimeFormat();
				if ("undefined" != typeof e && "undefined" != typeof e.resolvedOptions)
					return e.resolvedOptions().timeZone
			}
		},
		o = function (e) {
			for (var a = new Date(e, 0, 1, 0, 0, 1, 0).getTime(), s = new Date(e, 12, 31, 23, 59, 59).getTime(), i = a, r = new Date(i).getTimezoneOffset(), n = null, o = null; s - 864e5 > i; ) {
				var A = new Date(i),
				u = A.getTimezoneOffset();
				u !== r && (r > u && (n = A), u > r && (o = A), r = u),
				i += 864e5
			}
			return n && o ? {
				s : t(n).getTime(),
				e : t(o).getTime()
			}
			 : !1
		},
		t = function l(e, a, i) {
			"undefined" == typeof a && (a = s.DAY, i = s.HOUR);
			for (var r = new Date(e.getTime() - a).getTime(), n = e.getTime() + a, o = new Date(r).getTimezoneOffset(), t = r, A = null; n - i > t; ) {
				var u = new Date(t),
				c = u.getTimezoneOffset();
				if (c !== o) {
					A = u;
					break
				}
				t += i
			}
			return a === s.DAY ? l(A, s.HOUR, s.MINUTE) : a === s.HOUR ? l(A, s.MINUTE, s.SECOND) : A
		},
		A = function (e, a, s, i) {
			if ("N/A" !== s)
				return s;
			if ("Asia/Beirut" === a) {
				if ("Africa/Cairo" === i.name && 13983768e5 === e[6].s && 14116788e5 === e[6].e)
					return 0;
				if ("Asia/Jerusalem" === i.name && 13959648e5 === e[6].s && 14118588e5 === e[6].e)
					return 0
			} else if ("America/Santiago" === a) {
				if ("America/Asuncion" === i.name && 14124816e5 === e[6].s && 1397358e6 === e[6].e)
					return 0;
				if ("America/Campo_Grande" === i.name && 14136912e5 === e[6].s && 13925196e5 === e[6].e)
					return 0
			} else if ("America/Montevideo" === a) {
				if ("America/Sao_Paulo" === i.name && 14136876e5 === e[6].s && 1392516e6 === e[6].e)
					return 0
			} else if ("Pacific/Auckland" === a && "Pacific/Fiji" === i.name && 14142456e5 === e[6].s && 13961016e5 === e[6].e)
				return 0;
			return s
		},
		u = function (e, i) {
			for (var r = function (a) {
				for (var r = 0, n = 0; n < e.length; n++)
					if (a.rules[n] && e[n]) {
						if (!(e[n].s >= a.rules[n].s && e[n].e <= a.rules[n].e)) {
							r = "N/A";
							break
						}
						if (r = 0, r += Math.abs(e[n].s - a.rules[n].s), r += Math.abs(a.rules[n].e - e[n].e), r > s.MAX_SCORE) {
							r = "N/A";
							break
						}
					}
				return r = A(e, i, r, a)
			}, n = {}, o = a.olson.dst_rules.zones, t = o.length, u = s.AMBIGUITIES[i], c = 0; t > c; c++) {
				var m = o[c],
				l = r(o[c]);
				"N/A" !== l && (n[m.name] = l)
			}
			for (var f in n)
				if (n.hasOwnProperty(f) && -1 != u.indexOf(f))
					return f;
			return i
		},
		c = function (e) {
			var s = function () {
				for (var e = [], s = 0; s < a.olson.dst_rules.years.length; s++) {
					var i = o(a.olson.dst_rules.years[s]);
					e.push(i)
				}
				return e
			},
			i = function (e) {
				for (var a = 0; a < e.length; a++)
					if (e[a] !== !1)
						return !0;
				return !1
			},
			r = s(),
			n = i(r);
			return n ? u(r, e) : e
		},
		m = function () {
			var e = null;
			return e || (e = a.olson.timezones[r()], "undefined" != typeof s.AMBIGUITIES[e] && (e = c(e))), {
				name : function () {
					return e
				}
			}
		};
		return {
			determine : m
		}
	}
	();
	a.olson = a.olson || {},
	a.olson.timezones = {
		"-720,0" : "Etc/GMT+12",
		"-660,0" : "Pacific/Pago_Pago",
		"-660,1,s" : "Pacific/Apia",
		"-600,1" : "America/Adak",
		"-600,0" : "Pacific/Honolulu",
		"-570,0" : "Pacific/Marquesas",
		"-540,0" : "Pacific/Gambier",
		"-540,1" : "America/Anchorage",
		"-480,1" : "America/Los_Angeles",
		"-480,0" : "Pacific/Pitcairn",
		"-420,0" : "America/Phoenix",
		"-420,1" : "America/Denver",
		"-360,0" : "America/Guatemala",
		"-360,1" : "America/Chicago",
		"-360,1,s" : "Pacific/Easter",
		"-300,0" : "America/Bogota",
		"-300,1" : "America/New_York",
		"-270,0" : "America/Caracas",
		"-240,1" : "America/Halifax",
		"-240,0" : "America/Santo_Domingo",
		"-240,1,s" : "America/Santiago",
		"-210,1" : "America/St_Johns",
		"-180,1" : "America/Godthab",
		"-180,0" : "America/Argentina/Buenos_Aires",
		"-180,1,s" : "America/Montevideo",
		"-120,0" : "America/Noronha",
		"-120,1" : "America/Noronha",
		"-60,1" : "Atlantic/Azores",
		"-60,0" : "Atlantic/Cape_Verde",
		"0,0" : "UTC",
		"0,1" : "Europe/London",
		"60,1" : "Europe/Berlin",
		"60,0" : "Africa/Lagos",
		"60,1,s" : "Africa/Windhoek",
		"120,1" : "Asia/Beirut",
		"120,0" : "Africa/Johannesburg",
		"180,0" : "Asia/Baghdad",
		"180,1" : "Europe/Moscow",
		"210,1" : "Asia/Tehran",
		"240,0" : "Asia/Dubai",
		"240,1" : "Asia/Baku",
		"270,0" : "Asia/Kabul",
		"300,1" : "Asia/Yekaterinburg",
		"300,0" : "Asia/Karachi",
		"330,0" : "Asia/Kolkata",
		"345,0" : "Asia/Kathmandu",
		"360,0" : "Asia/Dhaka",
		"360,1" : "Asia/Omsk",
		"390,0" : "Asia/Rangoon",
		"420,1" : "Asia/Krasnoyarsk",
		"420,0" : "Asia/Jakarta",
		"480,0" : "Asia/Shanghai",
		"480,1" : "Asia/Irkutsk",
		"525,0" : "Australia/Eucla",
		"525,1,s" : "Australia/Eucla",
		"540,1" : "Asia/Yakutsk",
		"540,0" : "Asia/Tokyo",
		"570,0" : "Australia/Darwin",
		"570,1,s" : "Australia/Adelaide",
		"600,0" : "Australia/Brisbane",
		"600,1" : "Asia/Vladivostok",
		"600,1,s" : "Australia/Sydney",
		"630,1,s" : "Australia/Lord_Howe",
		"660,1" : "Asia/Kamchatka",
		"660,0" : "Pacific/Noumea",
		"690,0" : "Pacific/Norfolk",
		"720,1,s" : "Pacific/Auckland",
		"720,0" : "Pacific/Majuro",
		"765,1,s" : "Pacific/Chatham",
		"780,0" : "Pacific/Tongatapu",
		"780,1,s" : "Pacific/Apia",
		"840,0" : "Pacific/Kiritimati"
	},
	a.olson.dst_rules = {
		years : [2008, 2009, 2010, 2011, 2012, 2013, 2014],
		zones : [{
				name : "Africa/Cairo",
				rules : [{
						e : 12199572e5,
						s : 12090744e5
					}, {
						e : 1250802e6,
						s : 1240524e6
					}, {
						e : 12858804e5,
						s : 12840696e5
					}, !1, !1, !1, {
						e : 14116788e5,
						s : 1406844e6
					}
				]
			}, {
				name : "America/Asuncion",
				rules : [{
						e : 12050316e5,
						s : 12243888e5
					}, {
						e : 12364812e5,
						s : 12558384e5
					}, {
						e : 12709548e5,
						s : 12860784e5
					}, {
						e : 13024044e5,
						s : 1317528e6
					}, {
						e : 1333854e6,
						s : 13495824e5
					}, {
						e : 1364094e6,
						s : 1381032e6
					}, {
						e : 13955436e5,
						s : 14124816e5
					}
				]
			}, {
				name : "America/Campo_Grande",
				rules : [{
						e : 12032172e5,
						s : 12243888e5
					}, {
						e : 12346668e5,
						s : 12558384e5
					}, {
						e : 12667212e5,
						s : 1287288e6
					}, {
						e : 12981708e5,
						s : 13187376e5
					}, {
						e : 13302252e5,
						s : 1350792e6
					}, {
						e : 136107e7,
						s : 13822416e5
					}, {
						e : 13925196e5,
						s : 14136912e5
					}
				]
			}, {
				name : "America/Goose_Bay",
				rules : [{
						e : 122559486e4,
						s : 120503526e4
					}, {
						e : 125704446e4,
						s : 123648486e4
					}, {
						e : 128909886e4,
						s : 126853926e4
					}, {
						e : 13205556e5,
						s : 129998886e4
					}, {
						e : 13520052e5,
						s : 13314456e5
					}, {
						e : 13834548e5,
						s : 13628952e5
					}, {
						e : 14149044e5,
						s : 13943448e5
					}
				]
			}, {
				name : "America/Havana",
				rules : [{
						e : 12249972e5,
						s : 12056436e5
					}, {
						e : 12564468e5,
						s : 12364884e5
					}, {
						e : 12885012e5,
						s : 12685428e5
					}, {
						e : 13211604e5,
						s : 13005972e5
					}, {
						e : 13520052e5,
						s : 13332564e5
					}, {
						e : 13834548e5,
						s : 13628916e5
					}, {
						e : 14149044e5,
						s : 13943412e5
					}
				]
			}, {
				name : "America/Mazatlan",
				rules : [{
						e : 1225008e6,
						s : 12074724e5
					}, {
						e : 12564576e5,
						s : 1238922e6
					}, {
						e : 1288512e6,
						s : 12703716e5
					}, {
						e : 13199616e5,
						s : 13018212e5
					}, {
						e : 13514112e5,
						s : 13332708e5
					}, {
						e : 13828608e5,
						s : 13653252e5
					}, {
						e : 14143104e5,
						s : 13967748e5
					}
				]
			}, {
				name : "America/Mexico_City",
				rules : [{
						e : 12250044e5,
						s : 12074688e5
					}, {
						e : 1256454e6,
						s : 12389184e5
					}, {
						e : 12885084e5,
						s : 1270368e6
					}, {
						e : 1319958e6,
						s : 13018176e5
					}, {
						e : 13514076e5,
						s : 13332672e5
					}, {
						e : 13828572e5,
						s : 13653216e5
					}, {
						e : 14143068e5,
						s : 13967712e5
					}
				]
			}, {
				name : "America/Miquelon",
				rules : [{
						e : 12255984e5,
						s : 12050388e5
					}, {
						e : 1257048e6,
						s : 12364884e5
					}, {
						e : 12891024e5,
						s : 12685428e5
					}, {
						e : 1320552e6,
						s : 12999924e5
					}, {
						e : 13520016e5,
						s : 1331442e6
					}, {
						e : 13834512e5,
						s : 13628916e5
					}, {
						e : 14149008e5,
						s : 13943412e5
					}
				]
			}, {
				name : "America/Santa_Isabel",
				rules : [{
						e : 12250116e5,
						s : 1207476e6
					}, {
						e : 12564612e5,
						s : 12389256e5
					}, {
						e : 12885156e5,
						s : 12703752e5
					}, {
						e : 13199652e5,
						s : 13018248e5
					}, {
						e : 13514148e5,
						s : 13332744e5
					}, {
						e : 13828644e5,
						s : 13653288e5
					}, {
						e : 1414314e6,
						s : 13967784e5
					}
				]
			}, {
				name : "America/Sao_Paulo",
				rules : [{
						e : 12032136e5,
						s : 12243852e5
					}, {
						e : 12346632e5,
						s : 12558348e5
					}, {
						e : 12667176e5,
						s : 12872844e5
					}, {
						e : 12981672e5,
						s : 1318734e6
					}, {
						e : 13302216e5,
						s : 13507884e5
					}, {
						e : 13610664e5,
						s : 1382238e6
					}, {
						e : 1392516e6,
						s : 14136876e5
					}
				]
			}, {
				name : "Asia/Amman",
				rules : [{
						e : 1225404e6,
						s : 12066552e5
					}, {
						e : 12568536e5,
						s : 12381048e5
					}, {
						e : 12883032e5,
						s : 12695544e5
					}, {
						e : 13197528e5,
						s : 13016088e5
					}, !1, !1, {
						e : 14147064e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Damascus",
				rules : [{
						e : 12254868e5,
						s : 120726e7
					}, {
						e : 125685e7,
						s : 12381048e5
					}, {
						e : 12882996e5,
						s : 12701592e5
					}, {
						e : 13197492e5,
						s : 13016088e5
					}, {
						e : 13511988e5,
						s : 13330584e5
					}, {
						e : 13826484e5,
						s : 1364508e6
					}, {
						e : 14147028e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Dubai",
				rules : [!1, !1, !1, !1, !1, !1, !1]
			}, {
				name : "Asia/Gaza",
				rules : [{
						e : 12199572e5,
						s : 12066552e5
					}, {
						e : 12520152e5,
						s : 12381048e5
					}, {
						e : 1281474e6,
						s : 126964086e4
					}, {
						e : 1312146e6,
						s : 130160886e4
					}, {
						e : 13481784e5,
						s : 13330584e5
					}, {
						e : 13802292e5,
						s : 1364508e6
					}, {
						e : 14116788e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Irkutsk",
				rules : [{
						e : 12249576e5,
						s : 12068136e5
					}, {
						e : 12564072e5,
						s : 12382632e5
					}, {
						e : 12884616e5,
						s : 12697128e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Jerusalem",
				rules : [{
						e : 12231612e5,
						s : 12066624e5
					}, {
						e : 1254006e6,
						s : 1238112e6
					}, {
						e : 1284246e6,
						s : 12695616e5
					}, {
						e : 131751e7,
						s : 1301616e6
					}, {
						e : 13483548e5,
						s : 13330656e5
					}, {
						e : 13828284e5,
						s : 13645152e5
					}, {
						e : 1414278e6,
						s : 13959648e5
					}
				]
			}, {
				name : "Asia/Kamchatka",
				rules : [{
						e : 12249432e5,
						s : 12067992e5
					}, {
						e : 12563928e5,
						s : 12382488e5
					}, {
						e : 12884508e5,
						s : 12696984e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Krasnoyarsk",
				rules : [{
						e : 12249612e5,
						s : 12068172e5
					}, {
						e : 12564108e5,
						s : 12382668e5
					}, {
						e : 12884652e5,
						s : 12697164e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Omsk",
				rules : [{
						e : 12249648e5,
						s : 12068208e5
					}, {
						e : 12564144e5,
						s : 12382704e5
					}, {
						e : 12884688e5,
						s : 126972e7
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Vladivostok",
				rules : [{
						e : 12249504e5,
						s : 12068064e5
					}, {
						e : 12564e8,
						s : 1238256e6
					}, {
						e : 12884544e5,
						s : 12697056e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yakutsk",
				rules : [{
						e : 1224954e6,
						s : 120681e7
					}, {
						e : 12564036e5,
						s : 12382596e5
					}, {
						e : 1288458e6,
						s : 12697092e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yekaterinburg",
				rules : [{
						e : 12249684e5,
						s : 12068244e5
					}, {
						e : 1256418e6,
						s : 1238274e6
					}, {
						e : 12884724e5,
						s : 12697236e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yerevan",
				rules : [{
						e : 1224972e6,
						s : 1206828e6
					}, {
						e : 12564216e5,
						s : 12382776e5
					}, {
						e : 1288476e6,
						s : 12697272e5
					}, {
						e : 13199256e5,
						s : 13011768e5
					}, !1, !1, !1]
			}, {
				name : "Australia/Lord_Howe",
				rules : [{
						e : 12074076e5,
						s : 12231342e5
					}, {
						e : 12388572e5,
						s : 12545838e5
					}, {
						e : 12703068e5,
						s : 12860334e5
					}, {
						e : 13017564e5,
						s : 1317483e6
					}, {
						e : 1333206e6,
						s : 13495374e5
					}, {
						e : 13652604e5,
						s : 1380987e6
					}, {
						e : 139671e7,
						s : 14124366e5
					}
				]
			}, {
				name : "Australia/Perth",
				rules : [{
						e : 12068136e5,
						s : 12249576e5
					}, !1, !1, !1, !1, !1, !1]
			}, {
				name : "Europe/Helsinki",
				rules : [{
						e : 12249828e5,
						s : 12068388e5
					}, {
						e : 12564324e5,
						s : 12382884e5
					}, {
						e : 12884868e5,
						s : 1269738e6
					}, {
						e : 13199364e5,
						s : 13011876e5
					}, {
						e : 1351386e6,
						s : 13326372e5
					}, {
						e : 13828356e5,
						s : 13646916e5
					}, {
						e : 14142852e5,
						s : 13961412e5
					}
				]
			}, {
				name : "Europe/Minsk",
				rules : [{
						e : 12249792e5,
						s : 12068352e5
					}, {
						e : 12564288e5,
						s : 12382848e5
					}, {
						e : 12884832e5,
						s : 12697344e5
					}, !1, !1, !1, !1]
			}, {
				name : "Europe/Moscow",
				rules : [{
						e : 12249756e5,
						s : 12068316e5
					}, {
						e : 12564252e5,
						s : 12382812e5
					}, {
						e : 12884796e5,
						s : 12697308e5
					}, !1, !1, !1, !1]
			}, {
				name : "Pacific/Apia",
				rules : [!1, !1, !1, {
						e : 13017528e5,
						s : 13168728e5
					}, {
						e : 13332024e5,
						s : 13489272e5
					}, {
						e : 13652568e5,
						s : 13803768e5
					}, {
						e : 13967064e5,
						s : 14118264e5
					}
				]
			}, {
				name : "Pacific/Fiji",
				rules : [!1, !1, {
						e : 12696984e5,
						s : 12878424e5
					}, {
						e : 13271544e5,
						s : 1319292e6
					}, {
						e : 1358604e6,
						s : 13507416e5
					}, {
						e : 139005e7,
						s : 1382796e6
					}, {
						e : 14215032e5,
						s : 14148504e5
					}
				]
			}
		]
	},
	"undefined" != typeof exports ? exports.jstz = a : e.jstz = a
}
(this);
/**
 * Instantiates a new ManageProvider object
 * @name ManageProvider
 */
var ManageProvider = {};
//Global objects to be used throughout the class.

ManageProvider.modalObject = null;
ManageProvider.getCareTeamsTimer = null;
ManageProvider.authFacilityCodes = [];
ManageProvider.careTeamConfigReplyForManageProviders = null;
ManageProvider.tempProviderQueue = [];
ManageProvider.facilityHTMLOptions = [];
ManageProvider.providerSearchBar = null;
ManageProvider.teamsDropDown = "";
ManageProvider.serviceDropDown = "";
ManageProvider.facilityDropDown = "";
ManageProvider.providerAddReqJsonString = "";
ManageProvider.saveNewProvidersTimer = null;
ManageProvider.userLogicalDomainId = 0;
ManageProvider.returnValForSaveCareTeamConfigReply = false;

/**
 * Creates a modal dialog box to manage care team providers
 * @param {string} msg The HTML markup to be shown in the modal dialog box
 * @param {string} title The title of the modal dialog box
 * @param {string} btnApplyText The Apply button in the modal dialog box
 * @param {string} btnCancelText The Cancel button in the modal dialog box
 * @param {function} callBack The call back method which is called if the Apply button is clicked.
 * @return {boolean} Returns true if the creation of the dialog box was successful, false otherwise
 */
ManageProvider.createModalDialog = function(msg, title, btnApplyText, btnCancelText, callBack) {
	try {
		//Applying default values to the title and the buttons.
		title = title || i18n.discernabu.manage_providers.MANAGE_CARE_TEAM_PROVIDERS;
		btnApplyText = btnApplyText || i18n.discernabu.manage_providers.APPLY;
		btnCancelText = btnCancelText || i18n.discernabu.manage_providers.CANCEL;
		if ( typeof msg !== "string" || !msg.length) {
			throw new Error("ManageProvider.createModalDialog - Error creating modal dialog : msg, the HTML markup is empty or not a string");
		}
		if ( typeof title !== "string") {
			throw new Error("ManageProvider.createModalDialog - Error creating modal dialog : title, the title of the modal dialog is not a string");
		}
		if ( typeof btnApplyText !== "string") {
			throw new Error("ManageProvider.createModalDialog - Error creating modal dialog : btnApplyText, the Apply button text is not a string");
		}
		if ( typeof btnCancelText !== "string") {
			throw new Error("ManageProvider.createModalDialog - Error creating modal dialog : btnFalseText, the Cancel button is not a string");
		}
		if ( typeof callBack !== "function") {
			throw new Error("ManageProvider.createModalDialog - Error creating modal dialog : callBack, the Callback method associated with the buttons is not a function");
		}
		var modalDialogId = "careTeamProviderModalDialogId";
		var modalDialog = MP_ModalDialog.retrieveModalDialogObject(modalDialogId);
		if (modalDialog == null) {
			modalDialog = new ModalDialog(modalDialogId);
			var marginValueWidth = 30;
			var marginValueLength = 15;

			/**
			 * Provides the binding between the button click and the callback method called.
			 * @param {string} buttonId The Id of the button being clicked.
			 * @param {string} buttonLabel The label of the button being clicked.
			 */
			var bindButton = function(buttonId, buttonLabel) {
				var mdlButton = new ModalButton(buttonId);
				mdlButton.setOnClickFunction(function() {
					//Destroy the provider search bar if it exists
					if (ManageProvider.providerSearchBar) {
						ManageProvider.providerSearchBar.destroy();
					}
					if (buttonId === "manageCareTeamProviderApplyButton") {
						callBack();
					}
					//Close the modal dialog after the button has been clicked
					MP_ModalDialog.closeModalDialog(modalDialogId);
					MP_ModalDialog.deleteModalDialogObject(modalDialogId);
				});
				mdlButton.setCloseOnClick(true);
				mdlButton.setText(buttonLabel);
				return mdlButton;
			};

			//Set the margins of the modal dialog
			modalDialog.setTopMarginPercentage(marginValueLength);
			modalDialog.setRightMarginPercentage(marginValueWidth);
			modalDialog.setBottomMarginPercentage(marginValueLength);
			modalDialog.setLeftMarginPercentage(marginValueWidth);
			//Set the header of the modal dialog box
			modalDialog.setHeaderTitle(title);

			//Set the body of the dialog box
			modalDialog.setBodyDataFunction(function() {
				$("#" + modalDialog.getBodyElementId()).html(msg);
			});

			//Add the buttons to the dialog box and also bind the buttons to the callback.
			modalDialog.addFooterButton(bindButton("manageCareTeamProviderApplyButton", btnApplyText));
			modalDialog.addFooterButton(bindButton("manageCareTeamProviderCancelButton", btnCancelText));

			//Function to handle the case when the close icon in the header is clicked.
			modalDialog.setHeaderCloseFunction(function() {
				//Destroy the provider search bar if it exists
				if (ManageProvider.providerSearchBar) {
					ManageProvider.providerSearchBar.destroy();
				}
				MP_ModalDialog.closeModalDialog(modalDialogId);
				MP_ModalDialog.deleteModalDialogObject(modalDialogId);
			});
		}

		// We need this object to call setFooterButtonDither
		ManageProvider.modalObject = modalDialog;

		// Update the modal dialog and show it
		MP_ModalDialog.updateModalDialogObject(modalDialog);
		MP_ModalDialog.showModalDialog(modalDialog.getId());
	}
	catch (err) {
		logger.logJSError(err, null, "manage-provider.js", "createModalDialog");
		return false;
	}
	return true;
};

/**
 * Creates a ScriptRequest according to the parameters passed in
 * @param {string} programName The name of the script
 * @param {Array} parameterArray The parameters used for the HTTP request
 * @param {RTMSTimer} loadTimer The RTMSTimer associated with the script call
 * @param {boolean} asyncIndicator If false makes the script call in a synchronous way. If true it makes the process asynchronous
 * @param {function} callBackMethod The call back method which handles the script request reply
 * @param {int} medServiceCode An integer representing the medical service code.
 */
ManageProvider.createScriptRequest = function(programName, parameterArray, loadTimer, asyncIndicator, callBackMethod, medServiceCode) {
	try {

		//Check for error conditions
		if ( typeof programName !== "string" || !programName.length) {
			throw new Error("ManageProvider.createScriptRequest - Error creating script request : the program name is empty or not a string");
		}
		if (!$.isArray(parameterArray) || !parameterArray.length) {
			throw new Error("ManageProvider.createScriptRequest - Error creating script request : the parameter array is not of type array or empty");
		}
		if (loadTimer !== null && !( loadTimer instanceof RTMSTimer)) {
			throw new Error("ManageProvider.createScriptRequest - Error creating script request : the load timer is not an instance of RTMSTimer");
		}
		if ( typeof asyncIndicator !== "boolean") {
			throw new Error("ManageProvider.createScriptRequest - Error creating script request : the asyncIndicator is not a boolean");
		}
		if ( typeof callBackMethod !== "function") {
			throw new Error("ManageProvider.createScriptRequest - Error creating script request : the callBackMethod is not a function");
		}
		//Create the ScriptRequest Object and set its properties.
		var scriptRequest = new ScriptRequest();
		scriptRequest.setProgramName(programName);
		if (loadTimer) {
			scriptRequest.setLoadTimer(loadTimer);
		}
		scriptRequest.setAsyncIndicator(asyncIndicator);
		scriptRequest.setParameterArray(parameterArray);
		scriptRequest.setResponseHandler(function(scriptReply) {
			if (medServiceCode) {
				callBackMethod(scriptReply, medServiceCode);
			}
			else {
				callBackMethod(scriptReply);
			}
		});
		scriptRequest.performRequest();
	}
	catch (err) {
		logger.logError(err.message);
	}
};

/**
 * Creates an error modal dialog for the error message taken as input
 * @param {string} appendHtml The error string HTML to be added to the modal dialog body
 */
ManageProvider.createErrorModal = function(appendHtml) {
	try {
		if ( typeof appendHtml !== "string" || !appendHtml.length) {
			throw new Error("ManageProvider.createErrorModal - Error creating error modal dialog : appendHtml is empty or not a string");
		}
		//Create the modal dialog body using the MP_Util utility
		var modalObj = MP_Util.generateModalDialogBody("careTeamErrorModalDialogId", "", appendHtml, "");
		var bindButton = function(buttonId, buttonLabel) {
			var mdlButton = new ModalButton(buttonId);
			mdlButton.setOnClickFunction(function() {
				MP_ModalDialog.closeModalDialog("careTeamErrorModalDialogId");
				MP_ModalDialog.deleteModalDialogObject("careTeamErrorModalDialogId");
			});
			mdlButton.setCloseOnClick(true);
			mdlButton.setText(buttonLabel);
			return mdlButton;
		};
		modalObj.setShowCloseIcon(false);
		var footerButton = bindButton("manageCareTeamProviderErrorButton", i18n.discernabu.manage_providers.OK);
		modalObj.addFooterButton(footerButton);
		MP_ModalDialog.updateModalDialogObject(modalObj);
		MP_ModalDialog.showModalDialog("careTeamErrorModalDialogId");
	}
	catch (err) {
		logger.logError(err.message);
	}
};


/**
 * Enables/Disables the apply button based on the number of changes.
 * @return {undefined} Returns nothing.
 */
ManageProvider.handleApplyButtonDither = function() {
	ManageProvider.modalObject.setFooterButtonDither("manageCareTeamProviderApplyButton", ManageProvider.tempProviderQueue.length === 0);
};

/**
 * Renders the provider list in the auto suggest box when the user begins to type a provider name.
 * @param {Object} reply The JSON Object which contains provider data.
 */
ManageProvider.renderProviders = function(reply) {

	if (reply.m_responseData.STATUS_DATA.STATUS !== "S") {
		return;
	}
	else {
		var prsnlRecord = reply.m_responseData.PRSNL;
		var prsnlRecordLength = prsnlRecord.length;
		var providerObjArray = [];
		var existingProviderIdsArray = [];
		var providerExistsFlag = 0;

		ManageProvider.providerList
			.find("span")
			.each(function() {
				existingProviderIdsArray.push(parseInt($(this).attr("value"), 10));
			});

		for (var i = 0; i < prsnlRecordLength; i++) {
			var prsnlName = prsnlRecord[i].NAME_FULL_FORMATTED;
			var prsnlId = prsnlRecord[i].PERSON_ID;
			for (var j = 0; j < existingProviderIdsArray.length; j++) {
				providerExistsFlag = 0;
				if (prsnlId === existingProviderIdsArray[j]) {
					providerExistsFlag = 1;
					break;
				}
			}
			if (!providerExistsFlag) {
				var providerObj = {};
				providerObj.providerName = prsnlName;
				providerObj.providerId = prsnlId;
				providerObjArray.push(providerObj);
			}
		}
		ManageProvider.providerSearchBar.setSuggestions(providerObjArray);
	}
};

/**
 * Retrieves the provider list in the auto suggest box to render when the user begins to type a provider name.
 * @param {string} searchText The search string which the user types in.
 * @param {string} personId The personnel id.
 */
ManageProvider.retrieveProviders = function(searchText, personId) {
	try {
		var splitFullName = searchText.split(",");
		var lastName = "";
		var firstName = "";
		if (splitFullName.length > 1) {
			lastName = splitFullName[0];
			firstName = splitFullName[1];
		}
		else {
			var splitEnteredName = searchText.split(" ");
			if (splitEnteredName.length > 1) {
				firstName = splitEnteredName[0];
				lastName = splitEnteredName[1];
			}
			else {
				lastName = splitEnteredName[0];
				firstName = "";
			}
		}
		var parameterArray = ["^MINE^," + personId + ".0,'" + lastName + "' ,'" + firstName + "', 10"];
		ManageProvider.createScriptRequest("mp_get_prsnl_json", parameterArray, null, false, ManageProvider.renderProviders, null);

	}
	catch (err) {
		logger.logError("Error in manage-provider : ManageProvider.retrieveProviders " + err.message);
		return;
	}
};

/**
 * resizeMngCtTeamProvidersTable resizes manage care team providers table section
 */
ManageProvider.resizeMngCtTeamProvidersTable = function() {
	/**
	 * calculateProviderContentHeight calculates provider table height for manage care team providers modal window
	 * @return {integer} calculated height for the providers list
	 */
	function calculateProviderContentHeight (){
		var mdContentHeight = $(".dyn-modal-body-container").height();
		var mngProvDropDownsHeight = $(".mng-providers-dropdowns").height();
		var tableHeaderHeight = ManageProvider.providerList.find(".content-hdr").outerHeight();
		var height = mdContentHeight - mngProvDropDownsHeight - tableHeaderHeight - 5;

		return height < 0 ? 0 : height;
	}

	var $content = ManageProvider.providerList.find(".content-body");
	$content.css("max-height", calculateProviderContentHeight());

	// Adjust the header width based on whether the scrollbar is present.
	ManageProvider.providerList
		.find(".hdr")
		.width($content.children().first().width());
};

/**
 * Handles the autosuggest functionality of the modal dialog box.
 * @param {string} personId The personnel id.
 */
ManageProvider.autoSuggestProviders = function(personId) {
	ManageProvider.providerSearchBar = new MPageControls.AutoSuggest(ManageProvider.providerSearchBarContainer);
	ManageProvider.providerSearchBar.setDelay(500);
	ManageProvider.providerSearchBar.setCaption(i18n.discernabu.manage_providers.ADD_A_PROVIDER);
	ManageProvider.providerSearchBar.activateCaption();
	ManageProvider.providerSearchBar.setRequestItemValueCallback(function() {
		return "";
	});
	ManageProvider.providerSearchBar.setOnDelay(function() {
		var searchText = ManageProvider.providerSearchBarContainer
			.find(":input")
			.val();

		if (searchText) {
			searchText = searchText.replace(/[^a-zA-Z 0-9,\s*]+/g, "");
			ManageProvider.retrieveProviders(searchText, personId);
		}
	});
	var providerTemplate = new TemplateEngine.TemplateFactory((function() {
		var templateEngine = TemplateEngine;
		var div = templateEngine.tag("div");
		return {
			providerInfo : function(context) {
				return div({
					"class" : "search-item",
					id : context._elementId
				}, div({
					id : context.providerId,
					"class" : "selected-provider-name"
				}, context.providerName));
			}

		};
	})());

	ManageProvider.providerSearchBar.setListItemTemplate(providerTemplate.providerInfo);
	ManageProvider.providerSearchBar.getList().setOnSelect(function(item) {
		ManageProvider.providerSearchBar.close();
		var selectedTeam = ManageProvider.teamsDropDown.find(":selected");
		var selectedMedService = ManageProvider.serviceDropDown.find(":selected");

		// Gather the relevant information.
		var careTeamId = parseInt(selectedTeam.attr("data-care-team-id") || selectedMedService.attr("data-care-team-id"), 10);
		var logicalDomainId = parseInt(ManageProvider.userLogicalDomainId, 10) || 0;
		var selectedFacilityCd = parseInt(ManageProvider.facilityDropDown.val(), 10) || 0;
		var selectedMedServiceCd = parseInt(ManageProvider.serviceDropDown.val(), 10);
		var selectedTeamCd = parseInt(ManageProvider.teamsDropDown.val(), 10) || 0;
		var searchedProviderId = parseInt(item.providerId, 10);

		// Set the data personnel id attribute for the search textbox.
		ManageProvider.providerSearchBarContainer
			.find(":input")
			.attr("data-prsnl-id", searchedProviderId);

		// If a medical service has been selected...
		if (selectedMedServiceCd) {
			// Determine if the provider already exists in the tempProvider queue
			var indexInQueue = (function () {
				var tempProviderQueueLength = ManageProvider.tempProviderQueue.length;
				for (var i = 0; i < tempProviderQueueLength; i++) {
					var tempProvider = ManageProvider.tempProviderQueue[i];
					if (searchedProviderId === tempProvider.PRSNL_ID && careTeamId === tempProvider.PRSNL_ORIG_PCT_CARE_TEAM_ID) {
						return i;
					}
				}
				return -1;
			})();

			// If the provider is not already in the queue, add them.
			if (indexInQueue < 0) {
				ManageProvider.tempProviderQueue.push({
					NEW_PROVIDER: true,

					PRSNL_ORIG_PCT_CARE_TEAM_ID: careTeamId,
					LOGICAL_DOMAIN_ID: logicalDomainId,
					FACILITY_CD: selectedFacilityCd,
					PCT_MED_SERVICE_CD: selectedMedServiceCd,
					PCT_TEAM_CD: selectedTeamCd,
					PRSNL_ID: searchedProviderId,
					FULL_NAME: item.providerName,

					ACTIVE_IND: 1,
					UPDT_CNT: 0
				});
			}

			ManageProvider.providerSearchBar.setCaption(i18n.discernabu.manage_providers.ADD_A_PROVIDER);
			ManageProvider.providerSearchBar.activateCaption();
			ManageProvider.handleApplyButtonDither();
			ManageProvider.getProviders(selectedFacilityCd, selectedMedServiceCd);
		}
	});
	$(".mng-providers-search-box-container").find(".search-box.caption").prop("disabled", true);

};

/**
 * Shows the error banner within the manage providers modal
 *
 * @param  {String} msg
 *         The main text to display within the error banner.
 * @param  {String} heading
 *         The heading text to be displayed within the error banner.
 */
ManageProvider.showErrorBanner = function(msg, heading) {
	function removeErrorBanner() {
		$('#careTeamProviderModalDialogIdbody .mng-providers-err-banner').remove();
	}

	function getHeadingHTML() {
		if (heading) {
			return [
				'<span class="mng-providers-err-banner-heading">',
					heading,
				'</span>'
			].join('');
		}
		else {
			return '';
		}
	}

	function getContentHTML() {
		return [
			'<span class="mng-providers-err-banner-content">',
				msg,
			'</span>'
		].join('');
	}

	var msgHTML = [
		'<div class="mng-providers-err-banner">',
			getHeadingHTML(),
			getContentHTML(),
		'</div>'
	].join('');

	$('#careTeamProviderModalDialogIdbody').prepend(msgHTML);

	$('#vwpModalDialogcareTeamProviderModalDialogId').one('click.mng-providers', removeErrorBanner);
};

/**
 * Returns the selected team record
 * @return {obj}
 */
ManageProvider.getSelectedTeam = function() {
	var selectedFacilityCd = parseInt(ManageProvider.facilityDropDown.val(), 10) || 0;
	var selectedTeamCd = parseInt(ManageProvider.teamsDropDown.val(), 10) || 0;

	var teamIsSelected = function(team) {
		if (selectedFacilityCd === team.FACILITY_CD && selectedTeamCd === team.PCT_TEAM_CD) {
			return true;
		}
		return false;
	};

	var teamsRecordLength = this.teamsRecord.length;
	for (var i = 0; i < teamsRecordLength; i++) {
		var team = this.teamsRecord[i];
		if (teamIsSelected(team)) {
			return team;
		}
	}
};

/**
 * Determine whether the provider should be shown in the current context.
 *
 * @param  {object} personnel
 * @return {boolean}
 *         True if the personnel should be shown
 *         False if the personnel should not be shown
 */
ManageProvider.providerIsInContext = function(personnel) {
	if (parseInt(ManageProvider.facilityDropDown.val(), 10) !== personnel.FACILITY_CD) {
		return false;
	}
	else if (parseInt(ManageProvider.serviceDropDown.val(), 10) !== personnel.PCT_MED_SERVICE_CD) {
		return false;
	}
	else if ((parseInt(ManageProvider.teamsDropDown.val(), 10) || 0) !== personnel.PCT_TEAM_CD) {
		return false;
	}
	return true;
};

ManageProvider.Table = {
	providersToDisplay: [],
	/**
	 * Create the providers table and insert it into the DOM
	 */
	createProvidersTable: function() {
		var self = ManageProvider.Table;

		ManageProvider.selectedTeam = ManageProvider.getSelectedTeam();
		var prsnlResult = ManageProvider.selectedTeam.PRSNL;

		var personnel;
		self.providersToDisplay = [];

		// If there are providers in either the matchedPrsnl or tempProviderQueue...
		var matchedPrsnlLength = prsnlResult.length;
		var tempProviderQueueLength = ManageProvider.tempProviderQueue.length;
		if (matchedPrsnlLength || tempProviderQueueLength) {
			var includedTempProviders = [];

			/**
			 * Determine whether the personnel has already been added to the provider list.
			 *
			 * @param  {object} provider
			 *         Provider we want to check against the existing list of providers.
			 * @return {boolean}
			 *         True if the provider is not in the list
			 *         False if the provider is in the list
			 */
			var uniqueProvider = function(provider) {
				return includedTempProviders.indexOf(provider.PRSNL_ID) < 0;
			};

			var providerIndex;

			// Iterate through the temp provider queue and add the relevant providers to the providersToDisplay array
			for (providerIndex = 0; providerIndex < tempProviderQueueLength; providerIndex++) {
				personnel = ManageProvider.tempProviderQueue[providerIndex];
				if (ManageProvider.providerIsInContext(personnel) && uniqueProvider(personnel)) {
					includedTempProviders.push(personnel.PRSNL_ID);
					self.providersToDisplay.push(personnel);
				}
			}

			// Iterate through the matched personnel and add those who have not already been added to the providersToDisplay array
			for (providerIndex = 0; providerIndex < matchedPrsnlLength; providerIndex++) {
				personnel = prsnlResult[providerIndex];
				if (uniqueProvider(personnel)) {
					self.providersToDisplay.push(personnel);
				}
			}
		}


		// Generate the providers list.
		self.generateTable();
	},
	/**
	 * Generates the component table containing provider information.
	 */
	generateTable: function() {
		var self = ManageProvider.Table;

		// Handle data for all displayed providers.
		var personnelTable = new ComponentTable()
			.setIsHeaderEnabled(true)
			.setCustomClass('mng-providers-result-table');

		// If there are providers to display
		var providersToDisplayLength = self.providersToDisplay.length;
		if (providersToDisplayLength) {
			// Handle data for all displayed providers.
			for (var i = 0; i < providersToDisplayLength; i++) {
				self.handleDataForProvider(self.providersToDisplay[i]);
			}

			// Create and configure the name column.
			var nameColumn = new TableColumn()
				.setColumnId('NAME')
				.setCustomClass('mng-providers-provider-name-column')
				.setColumnDisplay(i18n.discernabu.manage_providers.PROVIDER_NAME)
				.setRenderTemplate("${NAME_DISPLAY}");

			// Create and configure the phone column.
			var phoneColumn = new TableColumn()
				.setColumnId('PHONE')
				.setCustomClass('mng-providers-provider-phone-column')
				.setColumnDisplay(i18n.discernabu.manage_providers.PHONE)
				.setRenderTemplate('${PHONE_DISPLAY}');

			// Create and configure the delete column.
			var deleteColumn = new TableColumn()
				.setColumnId('DELETE')
				.setCustomClass('mng-providers-provider-delete-column')
				.setRenderTemplate('${DELETE_DISPLAY}');

			// Add each column to the personnel table.
			personnelTable.addColumn(nameColumn);
			personnelTable.addColumn(phoneColumn);
			personnelTable.addColumn(deleteColumn);

			// Sort providers by their full name property
			self.providersToDisplay.sort(function (a, b) {
				if (a.FULL_NAME < b.FULL_NAME) {
					return -1;
				}
				if (a.FULL_NAME > b.FULL_NAME) {
					return 1;
				}
				return 0;
			});

			// Bind the provider data to the personnel table.
			personnelTable.bindData(self.providersToDisplay);
		}
		// If no personnel are to be displayed, display the "No providers assigned" string, instead
		else {
			// Create the sole column for the personnel table.
			var noProvColumn = new TableColumn()
				.setColumnId('NAME')
				.setCustomClass('mng-providers-no-providers-column')
				.setPrimarySortField('NO_PROV_DISPLAY')
				.setRenderTemplate('${NO_PROV_DISPLAY}');

			// Add the column to the personnel column.
			personnelTable.addColumn(noProvColumn);

			// Set the HTML to display the No Providers string.
			var noProv = [{
				NO_PROV_DISPLAY: [
					'<span class="mng-providers-no-provider-list">',
						'<span class="mng-providers-no-provider">',
							i18n.discernabu.manage_providers.NO_PROVIDERS_ASSIGNED,
						'</span>',
					'</span>'
				].join("")
			}];

			// Bind the No Providers data to the personnel table.
			personnelTable.bindData(noProv);
		}

		// Render and finalize the personnel table.
		ManageProvider.providerList.html(personnelTable.render());
		personnelTable.finalize();

		self.initializePhoneHover();

		// Set up the delete/undo click event.
		$(".mng-providers-result-table .delete-icon").click(function() {
			self.handleDelete($(this).parents('.result-info').first());
		});

		// Resize the providers list.
		ManageProvider.resizeMngCtTeamProvidersTable();
	},
	/**
	 * Set up the data to the displayed in the table for each provider
	 *
	 * @param  {object} personnel
	 */
	handleDataForProvider: function(personnel) {
		var getFullName = function(personnel) {
			return MP_Util.GetValueFromArray(personnel.PRSNL_ID, ManageProvider.prsnlArray).fullName;
		};

		var deleteClass = 'delete-icon';
		var strikeThroughClass = '';

		// If the personnel is queued for deletion, set up the appropriate classes.
		if (personnel.NEW_PROVIDER === false && personnel.ACTIVE_IND !== 1) {
			deleteClass += ' undo-delete-icon';
			strikeThroughClass = 'strike-through';
		}

		// If the full name has not already been set for the personnel, get their full name.
		personnel.FULL_NAME = personnel.FULL_NAME || getFullName(personnel);

		// Create the HTML used to display the personnel's name.
		personnel.NAME_DISPLAY = [
			'<span class="mng-providers-provider-details ' + strikeThroughClass + '" value="' + personnel.PRSNL_ID + '" data-facility-cd="' + ManageProvider.selectedTeam.FACILITY_CD + '" data-med-serv-cd="' + ManageProvider.medServiceCd + '" data-team-cd="' + ManageProvider.selectedTeam.PCT_TEAM_CD + '.0" data-orig-pct-team-id="' + personnel.PRSNL_ORIG_PCT_CARE_TEAM_ID + '" data-updt-cnt="' + personnel.UPDT_CNT + '">',
				personnel.FULL_NAME,
			'</span>'
		].join('');

		/**
		 * Gets the phone data stored for the current personnel
		 *
		 * @return {object}
		 *         Phone data or (if nothing is defined for the personnel) empty object
		 */
		personnel.PHONE = (function() {
			var personnelId = personnel.PRSNL_ID;
			var phonesRecord = ManageProvider.phonesRecord;
			var phonesRecordLength = phonesRecord.length;

			for (var i = 0; i < phonesRecordLength; i++) {
				var phone = phonesRecord[i];

				if (parseInt(phone.PERSON_ID, 10) === personnelId) {
					if (phone.PHONES.length > 0) {
						return phone.PHONES[0];
					}
				}
			}

			return {};
		})();


		// Create the HTML used to display the personnel's phone number.
		var phoneActiveClass = ManageProvider.careTeamCodeValueActiveInd === 1 ? "phone-active" : "";
		personnel.PHONE_DISPLAY = [
			'<span class="' + phoneActiveClass + " phone " + strikeThroughClass + '">',
				personnel.PHONE.PHONE_NUM || '--',
			'</span>'
		].join('');


		// Create the HTML used to edit the personnel's phone number within the popover dialog.
		personnel.PHONE_HOVER = [
			'<label for="phone-number">',
				i18n.discernabu.manage_providers.PHONE,
			'</label>',
			'<input type="text" id="providerPhoneNumberInput" value="' + (personnel.PHONE.PHONE_NUM || '') + '"/>'
		].join('');


		personnel.DELETE_DISPLAY = '<span id="handleDelete' + personnel.PRSNL_ID + '" class="' + deleteClass + '"></span>';
	},
	/**
	 * Handles the deletes when the user deletes a provider from the modal dialog box.
	 *
	 * @param {jQuery Element} $providerRowElement
	 *        The provider row element selector
	 */
	handleDelete: function($providerRowElement) {
		// Get the row element containing data relevant to the provider.
		var $providerDetailsElement = $providerRowElement.find(".mng-providers-provider-details");

		// Gather relevant information for the provider.
		var facilityCd = parseInt($providerDetailsElement.attr("data-facility-cd"), 10) || 0;
		var medServiceCd = parseInt($providerDetailsElement.attr("data-med-serv-cd"), 10);
		var teamCd = parseInt($providerDetailsElement.attr("data-team-cd"), 10) || 0;
		var personnelId = parseInt($providerDetailsElement.attr("value"), 10);
		var originalTeamId = parseInt($providerDetailsElement.attr("data-orig-pct-team-id"), 10) || 0;

		var indexInQueue = (function() {
			var tempProviderQueueLength = ManageProvider.tempProviderQueue.length;
			for (var i = 0; i < tempProviderQueueLength; i++) {
				var tempProvider = ManageProvider.tempProviderQueue[i];
				if (personnelId === tempProvider.PRSNL_ID && originalTeamId === tempProvider.PRSNL_ORIG_PCT_CARE_TEAM_ID) {
					return i;
				}
			}
			return -1;
		}());

		// If the provider is not in the queue, add them.
		if (indexInQueue < 0) {
			ManageProvider.tempProviderQueue.push({
				NEW_PROVIDER: false,

				PRSNL_ORIG_PCT_CARE_TEAM_ID: originalTeamId,
				LOGICAL_DOMAIN_ID: parseInt(ManageProvider.userLogicalDomainId, 10) || 0,
				FACILITY_CD: facilityCd,
				PCT_MED_SERVICE_CD: medServiceCd,
				PCT_TEAM_CD: teamCd,
				PRSNL_ID: personnelId,

				ACTIVE_IND: 0,
				UPDT_CNT: $providerDetailsElement.attr("data-updt-cnt") || 0
			});
		}
		// If the provider is in the queue, remove them.
		else {
			ManageProvider.tempProviderQueue.splice(indexInQueue, 1);
		}

		ManageProvider.handleApplyButtonDither();

		// Recreate the provider component table.
		ManageProvider.Table.createProvidersTable();
	},
	/**
	 * Sets up the click event for phone elements to display the popover dialog
	 */
	initializePhoneHover: function() {
		var self = ManageProvider.Table;

		// Set up the phone click event for the personnel table.
		$(".mng-providers-result-table").on('click', '.phone-active', function() {
			var $phoneElement = $(this);
			// If the phone element is not currently activated, nor is it queued for deletion...
			if (!$phoneElement.hasClass('phone-hover') && !$phoneElement.hasClass('strike-through')) {
				var hoveredPersonnelId = $phoneElement
					.parents('.result-info').first()
					.find('.mng-providers-provider-details').first()
					.attr('value');
				hoveredPersonnelId = parseInt(hoveredPersonnelId, 10);

				// Get the object that represents the personnel that is being hovered over.
				var hoveredPersonnel = (function () {
					var personnel;

					var providersToDisplayLength = self.providersToDisplay.length;
					for (var i = 0; i < providersToDisplayLength; i++) {
						personnel = self.providersToDisplay[i];
						if (hoveredPersonnelId === personnel.PRSNL_ID) {
							return personnel;
						}
					}
				})();

				// Remove any existing popover dialogs.
				$('.mng-providers-provider-phone-hover').remove();

				// Remove the hover class from all phone elements.
				$(".mng-providers-result-table .phone").removeClass('phone-hover mng-provider-popover-trigger');

				// Add the hover class to the phone element that triggered the hover event.
				$phoneElement.addClass('phone-hover');

				// Create, configure and render the popover dialog.
				var popoverDialog = new ManageProvider.PopoverDialog()
					.setTargetElement($phoneElement)
					.setHTML(hoveredPersonnel.PHONE_HOVER)
					.addClass('mng-providers-provider-phone-hover')
					.setSaveCallback(function() {
						var phoneId = (hoveredPersonnel.PHONE.PHONE_ID || 0) + ".0";
						var phoneNumber = $("#providerPhoneNumberInput").val();

						var requestJson = '{' +
							'"PHONE_LIST":{' +
								'"PHONE_CNT":1,' +
								'"QUAL":[{' +
									'"NUMBER":"' + phoneNumber + '",' +
									'"PRSNL_ID":' + hoveredPersonnelId + '.0,' +
									'"PHONE_ID":' + phoneId + ',' +
									'"CONTACT_METHOD":"TEL"' +
								'}]' +
							'}' +
						'}';

						var scriptRequest = new ScriptRequest();
						scriptRequest.setProgramName('mp_manage_provider_phone');
						scriptRequest.setParameterArray(["'MINE', '" + requestJson + "'"]);
						scriptRequest.setResponseHandler(function (scriptReply) {
							if (scriptReply.m_status === 'S') {
								var response = scriptReply.m_responseData.QUAL[0];
								var phoneId = response.PHONE_ID;

								// If the phone record already exists, simply update it.
								if (hoveredPersonnel.PHONE.PHONE_ID) {
									hoveredPersonnel.PHONE.PHONE_ID = phoneId;
									hoveredPersonnel.PHONE.PHONE_NUM = phoneNumber;
								}
								// If the phone record does not exist, push a new one to the ManageProvider.phonesRecord.
								else {
									ManageProvider.phonesRecord.push({
										PERSON_ID: hoveredPersonnelId,
										PHONES: [{
											PHONE_ID: phoneId,
											PHONE_NUM: phoneNumber
										}]
									});
								}

								// Close the dialog and regenerate the table.
								popoverDialog.close();
								self.generateTable();
							}
							// If a failure has occurred with the request, display the error banner and close the popover dialog.
							else {
								ManageProvider.showErrorBanner(i18n.discernabu.manage_providers.PHONE_ERROR_TEXT, i18n.discernabu.manage_providers.PHONE_ERROR_HEAD);
								popoverDialog.close();
							}
						});

						scriptRequest.performRequest();
					})
					.setCloseCallback(function() {
						// Remove the phone-hover and mng-provider-popover-trigger from all .phone elements in the table.
						$(".mng-providers-result-table .phone").removeClass('phone-hover mng-provider-popover-trigger');
					});

				// Render the popover dialog.
				popoverDialog.render();

				// Select the text for the phone number input within the popover dialog.
				$('#providerPhoneNumberInput').select();
			}
		});
	}
};

/**
 * Populated the providers in the modal dialog box when a selection is made from the facility and medical service.
 * @param {Object} reply The JSON Object containing the list of providers meeting the criteria for a particular facility, medical
 * service and team
 * @param {int} medServiceCd The medical service code
 */
ManageProvider.populateProviders = function(reply, medServiceCd) {
	try {
		// If the response was successful...
		if (reply && reply.m_responseData.STATUS_DATA.STATUS === "S") {
			// Get the teams record from the response.
			ManageProvider.medServiceCd = medServiceCd;
			ManageProvider.teamsRecord = reply.m_responseData.PCT_TEAMS;

			// Get the care team code value indicator from the response.
			ManageProvider.careTeamCodeValueActiveInd = reply.m_responseData.CT_CV_ACTIVE_IND;

			// Get the phones record from the response.
			ManageProvider.phonesRecord = reply.m_responseData.PHONE_LIST;

			// Get the personnel record from the response.
			ManageProvider.prsnlArray = MP_Util.LoadPersonelListJSON(reply.m_responseData.PRSNL);

			ManageProvider.Table.createProvidersTable();
		} // End of status S
	}
	catch (e) {
		logger.logError("Error in manage-provider : ManageProvider.populateProviders " + e.message);
	}
};

/**
 * Makes the script call to get the providers for a particular selection of medical service and team
 * @param {int} medServiceCd The medical service code
 */
ManageProvider.getProviders = function(facilityCd, medServiceCd) {
	// Set up the parameter array for the request
	var parameterArray = [
		"'MINE'," + // OUTDEV
		ManageProvider.userLogicalDomainId + ".0, " + // Logical Domain ID
		medServiceCd + ".0," + // Medical Service Code
		"-1.0," + // Team Code
		"0.0," + // Personnel ID
		"0.0," + // Return As Record
		"1," + // Return Personnel Phones
		facilityCd + ".0" // Facility Codes
	];

	// Initialize the RTMS timer for the request
	var getProvidersListTimer = new RTMSTimer("USR:MPG.PHYS_HANDOFF_Get_Providers_List", "Returning providers of corresponding medical service");

	// Send the script request to retrieve provider data.
	ManageProvider.createScriptRequest("mp_get_pct_care_team_config", parameterArray, getProvidersListTimer, false, ManageProvider.populateProviders, medServiceCd);
};

/**
 * Gathers references to relevant elements in the DOM.
 * @return {undefined} Returns nothing.
 */
ManageProvider.gatherElements = function() {
	ManageProvider.serviceDropDown = $("#serviceList");
	ManageProvider.teamsDropDown = $("#teamsList");
	ManageProvider.facilityDropDown = $("#mngCTProvidersFacilityList");
	ManageProvider.providerList = $("#providerList");
	ManageProvider.providerSearchBarContainer = $("#providerSearchBox");
};

/**
 * Handles the event change in the drop down of facility and service.
 *
 * @returns {undefined} Returns nothing.
 */
ManageProvider.popManageProviders = function() {
	ManageProvider.handleApplyButtonDither();

	var defaultMedServiceOption = [
		"<option value=\"default\">",
			i18n.discernabu.manage_providers.SELECT_A_MED_SERVICE,
		"</option>"
	].join("");

	var defaultTeamsOption = [
		"<option value=\"default\">",
			"&lt;" + i18n.discernabu.manage_providers.NO_TEAM_SELECTED + "&gt;",
		"</option>"
	].join("");

	var resetTeamsDropDown = function() {
		ManageProvider.teamsDropDown
			.html(defaultTeamsOption)
			.prop("disabled", true);
	};

	var setProviderSearchEnabled = function(enabled) {
		ManageProvider.providerSearchBarContainer
			.find(".search-box.caption")
				.prop("disabled", !enabled);
	};

	var resetProviderList = function() {
		ManageProvider.providerList.empty();
	};

	var activateProviderSearch = function() {
		setProviderSearchEnabled(true);
		ManageProvider.providerSearchBar.setCaption(i18n.discernabu.manage_providers.ADD_A_PROVIDER);
		ManageProvider.providerSearchBar.activateCaption();
	};

	var facilityDropDownChange = function() {
		var selectedFacilityCd = parseInt(ManageProvider.facilityDropDown.val(), 10) || 0;

		ManageProvider.serviceDropDown
			.html(ManageProvider.buildMedServiceOptionsForManagingProviders(selectedFacilityCd, defaultMedServiceOption))
			.prop("disabled", false);

		resetTeamsDropDown();
		resetProviderList();
		setProviderSearchEnabled(false);
	};

	var serviceDropDownChange = function() {
		var selectedMedServCd = parseInt(ManageProvider.serviceDropDown.val(), 10) || 0;

		if (selectedMedServCd) {
			var selectedFacilityCd = parseInt(ManageProvider.facilityDropDown.val(), 10) || 0;

			ManageProvider.teamsDropDown
				.html(ManageProvider.buildTeamOptionsForManagingProviders(selectedMedServCd, selectedFacilityCd, defaultTeamsOption))
				.prop("disabled", false);

			activateProviderSearch();
			ManageProvider.getProviders(selectedFacilityCd, selectedMedServCd);
		}
		else {
			resetTeamsDropDown();
			resetProviderList();
			setProviderSearchEnabled(false);
		}
	};

	// Set up change events for each of the dropdowns.
	ManageProvider.facilityDropDown.change(facilityDropDownChange);
	ManageProvider.serviceDropDown.change(serviceDropDownChange);
	ManageProvider.teamsDropDown.change(ManageProvider.Table.createProvidersTable);

	// Initialize the facility drop down.
	ManageProvider.facilityDropDown
		.removeClass("ajax-loader")
		.prop("disabled", false)
		.html(ManageProvider.facilityHTMLOptions.join(""));
	facilityDropDownChange();
};

/**
 * Build the medical service drop down for managing providers
 * @param {int} selectedFacilityCd The facility code of the chosen facility in the drop down
 * @param {string} defaultOptionHTML The default HTML options
 */
ManageProvider.buildMedServiceOptionsForManagingProviders = function(selectedFacilityCd, defaultOptionHTML) {
	var serviceListHtml = "";
	var confReplyInd = ManageProvider.checkCareTeamConfigReplyForManagingProviders();
	if (confReplyInd) {
		var ctConfigData = ManageProvider.careTeamConfigReplyForManageProviders;
		var results = ctConfigData.PCT_TEAMS;
		var codes = ctConfigData.CODES;
		var resultsLength = results.length;
		var serviceDisplay = "";
		var codeArray = MP_Util.LoadCodeListJSON(codes);
		serviceListHtml += defaultOptionHTML;
		var parsedFacilityCd = parseInt(selectedFacilityCd, 10) || 0;
		for (var i = 0; i < resultsLength; i++) {
			var resultItem = results[i];
			serviceDisplay = "";
			if (!resultItem.PCT_TEAM_CD && (parseInt(resultItem.FACILITY_CD, 10) || 0) === parsedFacilityCd) {
				serviceDisplay = MP_Util.GetValueFromArray(resultItem.PCT_MEDSERV_CD, codeArray).display;
				serviceListHtml += "<option data-care-team-id=" + resultItem.ORIG_PCT_TEAM_ID + " value=" + resultItem.PCT_MEDSERV_CD + ">" + serviceDisplay + "</option>";
			}
		}
	}
	return serviceListHtml;
};

/**
 * Build the Team drop down for managing providers
 * @param {int} selectedMedServCd The med service code of the chosen med service in the drop down
 * @param {int} selectedFacilityCd The facility code of the chosen facility in the drop down
 * @param {string} defaultOptionHTML The default HTML options
 */
ManageProvider.buildTeamOptionsForManagingProviders = function(selectedMedServCd, selectedFacilityCd, defaultOptionHTML) {
	var teamOptionsHtml = "";
	var confReplyInd = ManageProvider.checkCareTeamConfigReplyForManagingProviders();
	if (confReplyInd) {
		var ctConfigData = ManageProvider.careTeamConfigReplyForManageProviders;
		var results = ctConfigData.PCT_TEAMS;
		var codes = ctConfigData.CODES;
		var resultsLength = results.length;
		var codeArray = MP_Util.LoadCodeListJSON(codes);
		var teamName = "";
		var parsedMedCd = parseInt(selectedMedServCd, 10) || 0;
		var parsedFacilityCd = parseInt(selectedFacilityCd, 10) || 0;
		teamOptionsHtml += defaultOptionHTML;
		for (var y = 0; y < resultsLength; y++) {
			var resItem = results[y];
			if (resItem.PCT_MEDSERV_CD === parsedMedCd && resItem.PCT_TEAM_CD > 0 && (parseInt(resItem.FACILITY_CD, 10) || 0) === parsedFacilityCd) {
				teamName = MP_Util.GetValueFromArray(resItem.PCT_TEAM_CD, codeArray).display;
				teamOptionsHtml += "<option value='" + resItem.PCT_TEAM_CD + ".0' data-care-team-id='" + resItem.ORIG_PCT_TEAM_ID + "'>" + teamName + "</option>";
			}
		}
	}
	return teamOptionsHtml;
};

/**
 * Response handler for saving the care team config reply
 * @param {Object} reply The JSON object consisting of the config care team config
 */
ManageProvider.saveCareTeamConfigReply = function(reply) {
	if (reply) {
		if (reply.m_responseData.STATUS_DATA.STATUS === "S") {
			ManageProvider.careTeamConfigReplyForManageProviders = reply.m_responseData;
			ManageProvider.returnValForSaveCareTeamConfigReply = true;
		}
		else {
			ManageProvider.returnValForSaveCareTeamConfigReply = false;
		}
	}
};

/**
 * Makes a script call to get the care team configuration
 */
ManageProvider.checkCareTeamConfigReplyForManagingProviders = function() {
	ManageProvider.returnValForSaveCareTeamConfigReply = false;
	if (ManageProvider.careTeamConfigReplyForManageProviders == null) {
		var parameterArray = ["'MINE'," + ManageProvider.userLogicalDomainId + ".0, 0.0, 0.0, 0.0, 0, 0, -1.0"];
		ManageProvider.getCareTeamsTimer = new RTMSTimer("USR:MPG.PHYS_HANDOFF_Get_Care_Teams", "Returning list of care teams for a particular logical domain");
		ManageProvider.createScriptRequest("mp_get_auth_pct_providers", parameterArray, ManageProvider.getCareTeamsTimer, false, ManageProvider.saveCareTeamConfigReply, null);
	}
	else {
		ManageProvider.returnValForSaveCareTeamConfigReply = true;
	}
	return ManageProvider.returnValForSaveCareTeamConfigReply;
};

/**
 * Validates the JSON Object once the Apply button is clicked in the dialog box
 * @param {Object} reply The JSON object consisting of the care team configuration
 */
ManageProvider.validateSaveRequest = function(reply) {

	if (reply && reply.m_responseData.STATUS_DATA.STATUS === "F") {
		alert(i18n.discernabu.SAVE_PROVIDERS_ERROR);
	}
	else {
		if (reply && reply.m_responseData.STATUS_DATA.STATUS === "S" && reply.m_responseData.ERRORS.length) {
			var prsnlResults = reply.m_responseData.PRSNL;
			var jsonErrorArray = reply.m_responseData.ERRORS;
			var jsonErrorArrayLength = jsonErrorArray.length;
			ManageProvider.Table.prsnlArray = MP_Util.LoadPersonelListJSON(prsnlResults);
			var prsnlName = "";
			var alreadyUpdatedProviderNamesArray = [];
			var activePatientsErrorProviderNamesArray = [];
			var genericErrorProviderNamesArray = [];
			var appendHtml = "";
			for (var i = 0; i < jsonErrorArrayLength; i++) {
				prsnlName = MP_Util.GetValueFromArray(jsonErrorArray[i].PRSNL_ID, ManageProvider.Table.prsnlArray).fullName;
				if (jsonErrorArray[i].ERROR_MEAN === "ITEM_W_ACTIVE_ASSIGNMENTS") {
					activePatientsErrorProviderNamesArray.push(prsnlName);
				}
				else {
					if (jsonErrorArray[i].ERROR_MEAN === "UPDT_CNT_CHECK" || jsonErrorArray[i].ERROR_MEAN === "DUP_PRSNL") {
						alreadyUpdatedProviderNamesArray.push(prsnlName);
					}
					else {
						genericErrorProviderNamesArray.push(prsnlName);
					}
				}
			}
			var sortByPrsnlName = function(a, b) {
				var aName = a.toLowerCase();
				var bName = b.toLowerCase();
				return ((aName < bName) ? -1 : ((aName > bName) ? 1 : 0));
			};
			activePatientsErrorProviderNamesArray = activePatientsErrorProviderNamesArray.sort(sortByPrsnlName);
			alreadyUpdatedProviderNamesArray = alreadyUpdatedProviderNamesArray.sort(sortByPrsnlName);
			genericErrorProviderNamesArray = genericErrorProviderNamesArray.sort(sortByPrsnlName);
			appendHtml += '<div class="mng-providers-error-list-container"><div class="mng-providers-error-general-display-container"><span class="mng-providers-err-icon">&nbsp;</span><span class="mng-providers-err-msg">' + i18n.discernabu.manage_providers.SYSTEM_ENCOUNTERED_ERRORS + "</span></div>";
			appendHtml += '<div class="mng-providers-error-specific-container">';
			if (activePatientsErrorProviderNamesArray.length) {
				appendHtml += '<div class = "mng-providers-error-active-patient-assignments"><span class="mng-providers-error-active-patient-assignments-lbl">' + i18n.discernabu.manage_providers.ACTIVE_PATIENTS_ASSIGNED_ERROR + ":</span>";
				for (var x = 0; x < activePatientsErrorProviderNamesArray.length; x++) {
					appendHtml += '<span class="mng-providers-error-providers-list">' + activePatientsErrorProviderNamesArray[x] + "</span>";
				}
				appendHtml += "</div>";
			}
			if (alreadyUpdatedProviderNamesArray.length) {
				appendHtml += '<div class="mng-providers-error-assign-provider"><span class="mng-providers-error-assign-provider-lbl">' + i18n.discernabu.manage_providers.UPDATE_ERROR + ":</span>";
				for (var y = 0; y < alreadyUpdatedProviderNamesArray.length; y++) {
					appendHtml += '<span class="mng-providers-error-providers-list">' + alreadyUpdatedProviderNamesArray[y] + "</span>";
				}
				appendHtml += "</div>";
			}
			if (genericErrorProviderNamesArray.length) {
				appendHtml += '<div class="mng-providers-error-unknown-cause"><span class="mng-providers-error-unknown-cause-lbl">' + i18n.discernabu.manage_providers.UNKNOWN_ERROR + "</span>";
				for (var t = 0; t < genericErrorProviderNamesArray.length; t++) {
					appendHtml += '<span class="mng-providers-error-providers-list">' + genericErrorProviderNamesArray[t] + "</span>";
				}
				appendHtml += "</div>";
			}
			appendHtml += "</div></div>";
			MP_ModalDialog.closeModalDialog("careTeamProviderModalDialogId");
			MP_ModalDialog.deleteModalDialogObject("careTeamProviderModalDialogId");
			ManageProvider.createErrorModal(appendHtml);
		}
	}
};

/**
 * Callback method which is triggered when the Apply button is clicked. It saves the new state of the Providers JSON
 */
ManageProvider.saveCareTeamPreference = function() {
	var pctTeamData = [];
	if (ManageProvider.tempProviderQueue.length) {
		var tempProviderQueueLength = ManageProvider.tempProviderQueue.length;
		for (var i = 0; i < tempProviderQueueLength; i++) {
			var provider = ManageProvider.tempProviderQueue[i];

			var careTeamId = provider.NEW_PROVIDER ? 0 : provider.PRSNL_ORIG_PCT_CARE_TEAM_ID;

			pctTeamData.push('{' +
				'"PCT_FACILITY_CD":' + provider.FACILITY_CD + '.00,' +
				'"ORIG_PCT_TEAM_ID":' + careTeamId + '.00,' +
				'"PCT_MED_SERVICE_CD":' + provider.PCT_MED_SERVICE_CD + '.00,' +
				'"PCT_TEAM_CD":' + provider.PCT_TEAM_CD + '.00,' +
				'"PRSNL_ID":' + provider.PRSNL_ID + '.00,' +
				'"ACTIVE_IND":' + provider.ACTIVE_IND + ',' +
				'"UPDT_CNT":' + provider.UPDT_CNT + ',' +
				'"LOGICAL_DOMAIN_ID":' + provider.LOGICAL_DOMAIN_ID + '.00' +
			'}');
		}
	}
	ManageProvider.providerAddReqJsonString = '{' +
		'"REQUESTIN":{' +
			'"pct_teams":[' +
				pctTeamData.join(',') +
			']' +
		'}' +
	'}';
	var parameterArray = ["'MINE','" + ManageProvider.providerAddReqJsonString + "'"];
	ManageProvider.saveNewProvidersTimer = new RTMSTimer("USR:MPG.PHYS_HANDOFF_Save_New_Providers", "Adding providers to corresponding care teams");
	ManageProvider.createScriptRequest("mp_upd_pct_care_team_config", parameterArray, ManageProvider.saveNewProvidersTimer, false, ManageProvider.validateSaveRequest, null);
};

/**
 * Handles the response of the script call when a option changes in the facility drop down.
 * @param {Array} teamsObjArr An Array containing the config data for PCT teams
 */
ManageProvider.handleResponseForFacilityCodes = function(teamsObjArr) {
	for (var i = 0; i < teamsObjArr.length; i++) {
		ManageProvider.authFacilityCodes.push(parseInt(teamsObjArr[i].FACILITY_CD, 10) || 0);
	}
};

/**
 * Build the Facility drop down for managing providers
 */
ManageProvider.buildFacilityOptionsForManagingProviders = function() {
	var confReplyInd = ManageProvider.checkCareTeamConfigReplyForManagingProviders();
	if (confReplyInd) {
		var ctConfigData = ManageProvider.careTeamConfigReplyForManageProviders;
		var results = ctConfigData.PCT_TEAMS;
		ManageProvider.handleResponseForFacilityCodes(results);
		var codes = ctConfigData.CODES;
		var resultsLength = results.length;
		var facilityArrList = [];
		var facilityCodeArr = [];
		var facilityDisplay = "";
		var facilityListHtml = [];
		var allFacilitiesOptionObj = null;
		var codeArray = MP_Util.LoadCodeListJSON(codes);

		for (var i = 0; i < resultsLength; i++) {
			var resultItem = results[i];
			var facilityCd = parseInt(resultItem.FACILITY_CD, 10) || 0;
			if (($.inArray(-1, ManageProvider.authFacilityCodes) >= 0 || $.inArray(facilityCd, ManageProvider.authFacilityCodes) >= 0 || facilityCd === 0) && $.inArray(facilityCd, facilityCodeArr) === -1) {
				facilityCodeArr.push(facilityCd);
				if (facilityCd === 0) {
					var selectedByDefault = 'selected="selected" ';
					allFacilitiesOptionObj = {
						FACILITY_CD : 0,
						FACILITY_DISPLAY : i18n.discernabu.manage_providers.ALL_FACILITIES,
						SELECTED : selectedByDefault
					};
				}
				else {
					facilityDisplay = MP_Util.GetValueFromArray(facilityCd, codeArray).display;
					var facilityItemObj = {
						FACILITY_CD : facilityCd,
						SORT_VALUE : facilityDisplay.toUpperCase(),
						FACILITY_DISPLAY : facilityDisplay,
						SELECTED : ""
					};
					if (i === 0) {
						facilityItemObj.SELECTED = 'selected="selected" ';
					}
					facilityArrList.push(facilityItemObj);
				}
			}
		}
		facilityArrList = facilityArrList.sort(function(a, b) {
			return a.SORT_VALUE.localeCompare(b.SORT_VALUE);
		});
		if (allFacilitiesOptionObj) {
			facilityArrList.unshift(allFacilitiesOptionObj);
		}

		var facilityArrListLen = facilityArrList.length;
		for (var x = 0; x < facilityArrListLen; x++) {
			var curFacility = facilityArrList[x];
			facilityListHtml.push("<option " + curFacility.SELECTED + " value=" + curFacility.FACILITY_CD + ">" + curFacility.FACILITY_DISPLAY + "</option>");
		}
		ManageProvider.facilityHTMLOptions = facilityListHtml;
	}
};

/**
 * Reinitializes the static variables.
 */
ManageProvider.reInitializeStaticVariables = function() {
	ManageProvider.getCareTeamsTimer = null;
	ManageProvider.authFacilityCodes = [];
	ManageProvider.careTeamConfigReplyForManageProviders = null;
	ManageProvider.tempProviderQueue = [];
	ManageProvider.facilityHTMLOptions = [];
	ManageProvider.providerSearchBar = null;
	ManageProvider.teamsDropDown = "";
	ManageProvider.serviceDropDown = "";
	ManageProvider.facilityDropDown = "";
	ManageProvider.providerAddReqJsonString = "";
	ManageProvider.saveNewProvidersTimer = null;

};

/**
 * This is the entry point of the artifact. This delegates to various other methods in this artifact to build up a modal dialog box
 * for managing care team providers and handles the script calls.
 * @param {string} personId The person id of the personnel. This is received as an input from the consumer of this artifact.
 * @param {int} userLogicalDomainId The logical domain id of the user. This is received as an input from the consumer of this
 * artifact.
 */
ManageProvider.manageProviders = function(personId, userLogicalDomainId) {
	try {
		var modalWindowTitle = i18n.discernabu.manage_providers.MANAGE_CARE_TEAM_PROVIDERS;
		ManageProvider.userLogicalDomainId = userLogicalDomainId;
		//Reinitializes the static variables.
		ManageProvider.reInitializeStaticVariables();
		var listBoxHtml = '<div class="mng-providers-window">';
		listBoxHtml += '<div class="mng-providers-dropdowns">';
		listBoxHtml += '<div class="mng-providers-dropdown-lbl">' + i18n.discernabu.manage_providers.FACILITY + "</div>";
		listBoxHtml += '<div class="mng-providers-dropdown-content"><select class="mng-facility-list ajax-loader" id="mngCTProvidersFacilityList" disabled="disabled"></select></div>';
		listBoxHtml += '<div class="mng-providers-dropdown-lbl">' + i18n.discernabu.manage_providers.MED_SERVICE + "</div>";
		listBoxHtml += '<div class="mng-providers-dropdown-content"><select class="mng-service-list" id="serviceList" disabled="disabled"><option value="default">' + i18n.discernabu.manage_providers.SELECT_A_MED_SERVICE + "</option></select></div>";
		listBoxHtml += '<div class="mng-providers-dropdown-lbl">' + i18n.discernabu.manage_providers.TEAM + "</div>";
		listBoxHtml += '<div class="mng-providers-dropdown-content"><select class="mng-teams-list" id="teamsList" disabled="disabled"><option value="default">&lt;' + i18n.discernabu.manage_providers.NO_TEAM_SELECTED + "&gt;</option></select></div>";
		listBoxHtml += '<div class="mng-providers-horizontal-seperator">&nbsp;</div>';
		listBoxHtml += '<div class="mng-providers-results-container">';
		listBoxHtml += '<div class="mng-providers-team-members">' + i18n.discernabu.manage_providers.PROVIDERS + "</div>";
		listBoxHtml += '<div class="mng-providers-search-box-container"><div class="mng-providers-search-box" id="providerSearchBox"></div></div></div>';
		listBoxHtml += "</div>";
		listBoxHtml += '<div id="providerList" class="mng-providers-team-members-container"></div></div>';

		if (!ManageProvider.createModalDialog(listBoxHtml, modalWindowTitle, i18n.discernabu.manage_providers.APPLY, i18n.discernabu.manage_providers.CANCEL, ManageProvider.saveCareTeamPreference)) {
			throw new Error("Error in createModalDialog");
		}

		ManageProvider.gatherElements();
		ManageProvider.autoSuggestProviders(personId);
		ManageProvider.buildFacilityOptionsForManagingProviders();
		ManageProvider.popManageProviders();

		var resizeTimerMngCareTeamProviderTable;
		$(window).resize(function() {
			if (resizeTimerMngCareTeamProviderTable) {
				clearTimeout(resizeTimerMngCareTeamProviderTable);
			}
			resizeTimerMngCareTeamProviderTable = setTimeout(function() {
				ManageProvider.resizeMngCtTeamProvidersTable();
			}, 100);
		});
	}
	catch (err) {
		logger.logError("Error in manage-provider : ManageProvider.manageProviders " + err.message);
	}
};

/**
 * PopoverDialog Constructor
 */
ManageProvider.PopoverDialog = function() {
	this.m_html = "";
	this.m_classes = [];
	this.m_offset = {
		top: 0,
		left: 0
	};
	this.m_pointerSide = "top";
	this.m_saveCallback = function() {};
	this.m_closeCallback = function() {};
	this.m_$element = null;
	this.m_$targetElement = null;
}

/**
 * Set the HTML string to be displayed in the popover dialog.
 * @param {string} html
 */
ManageProvider.PopoverDialog.prototype.setHTML = function(html) {
	this.m_html = html;
	return this;
};

/**
 * Add a class for the popover dialog element.
 * @param {string} htmlClass
 */
ManageProvider.PopoverDialog.prototype.addClass = function(htmlClass) {
	this.m_classes.push(htmlClass);
	return this;
};

/**
 * Set the top and left position for the popover dialog element.
 * @param {number} top
 * @param {number} left
 */
ManageProvider.PopoverDialog.prototype.setOffset = function(top, left) {
	// Create the position object, rounding the top and left to the nearest integer.
	this.m_offset = {
		top: Math.round(top),
		left: Math.round(left)
	};
	return this;
};

/**
 * Sets the element that the dialog's arrow should point at.
 * @param {jQuery object} element
 *        Element that triggered the dialog's display.
 */
ManageProvider.PopoverDialog.prototype.setTargetElement = function(element) {
	element.addClass('mng-provider-popover-trigger');
	this.m_$targetElement = element;
	return this;
};

/**
 * Gets the absolute position where the dialog should be placed.
 * @return {object}
 *         Contains the top and left values to be used for absolute positioning.
 */
ManageProvider.PopoverDialog.prototype.getPosition = function() {
	var $element = this.m_$element;
	var $targetElement = this.m_$targetElement;
	var targetOffset = $targetElement.offset();

	var getTop = function() {
		var targetHeight = $targetElement.outerHeight();
		return targetOffset.top + targetHeight;
	};

	var getLeft = function() {
		var targetWidth = $targetElement.outerWidth();
		return targetOffset.left + (targetWidth / 2) - 52;
	};

	return {
		top: getTop() + this.m_offset.top,
		left: getLeft() + this.m_offset.left
	};
};

/**
 * Set the callback function that will be triggered by the save button.
 * @param {Function} callback
 */
ManageProvider.PopoverDialog.prototype.setSaveCallback = function(callback) {
	this.m_saveCallback = callback;
	return this;
};

/**
 * Set the callback function that will be triggered by the cancel button.
 * @param {Function} callback
 */
ManageProvider.PopoverDialog.prototype.setCloseCallback = function(callback) {
	this.m_closeCallback = callback;
	return this;
};

/**
 * Closes the dialog and unbinds events.
 */
ManageProvider.PopoverDialog.prototype.close = function() {
	this.m_closeCallback();
	$(window).off('resize.popoverDialog');
	$('body').off('click.popoverDialog');
	this.m_$element.remove();
};

/**
 * Render the popover dialog on the page.
 * @return {jQuery object}
 *         The jQuery object which represents the popover dialog element that was appended on the page.
 */
ManageProvider.PopoverDialog.prototype.render = function() {
	var self = this;

	// Create the popover dialog element.
	self.m_$element = $([
		'<div class="mng-provider-popover-dialog ' + this.m_classes.join(' ') + '">',
			'<div class="point-' + this.m_pointerSide + ' mng-provider-popover-dialog-contents">',
				'<div class="panel">',
					this.m_html,
				'</div>',
				'<div class="button-container">',
					'<button class="btn-save">' + i18n.discernabu.manage_providers.SAVE + '</button>',
					'<button class="btn-cancel">' + i18n.discernabu.manage_providers.CANCEL + '</button>',
				'</div>',
			'</div>',
		'</div>'
	].join(''));

	// Append the popover dialog element to the body.
	$('body').append(self.m_$element);

	var position = this.getPosition();
	self.m_$element.css('top', position.top);
	self.m_$element.css('left', position.left);

	// Set up the button events.
	self.m_$element.find('.btn-save').on('click.save', function() {
		$(this).prop('disabled', true);
		self.m_saveCallback();
	});
	self.m_$element.find('.btn-cancel').on('click.cancel', function() {
		self.close();
	});

	// If the window is resized, close the popover dialog.
	$(window).on('resize.popoverDialog', function() {
		self.close();
	});

	// If the user clicks outside of the popover dialog, close it.
	$('body').on('click.popoverDialog', function(event) {
		var targetHasClass = function (targetClass) {
			return ($target.hasClass(targetClass) || $target.parents('.' + targetClass).length > 0);
		};
		var $target = $(event.target);
		if (!targetHasClass('mng-provider-popover-dialog') && !targetHasClass('mng-provider-popover-trigger')) {
			self.close();
		}
	});

	return self.m_$element;
};
/**
 * This MessageCenterOrderReview object extends the base class DailyOrderReview.
 * It implements functions of fetching the content of daily orders review modal.
 * @constructor
 * Initialise a unique review id
 */
function MessageCenterOrderReview(reviewId) {
	this.m_reviewId = reviewId;
	this.m_i18nReview = i18n.discernabu.order_review;
	this.m_ordersReviewObj = ordersReviewObj;
}

MessageCenterOrderReview.prototype = new DailyOrderReview();
MessageCenterOrderReview.prototype.constructor = DailyOrderReview;

/*
 *This function calls the order service to get all the qualified orders for the sign in user
 * @param {function} a callback function
*/
MessageCenterOrderReview.prototype.getQualifiedDailyOrders = function (callback) {
	var self = this;
	try {
		var APPLICATION_NUMBER = 560201;
		var TASK_NUMBER = 3202004;
		var REQUEST_NUMBER = 680850;
		var requestParam = self.getScriptRequestParams();
		var personId = (requestParam.PERSON_ID) ? requestParam.PERSON_ID : 0.0;
		var providerId = (requestParam.PRSNL_ID) ? requestParam.PRSNL_ID : 0.0;
		var DATE = new Date();
		var JSONParam = {
				daily_review_criterias: [
					{
						responsible_provider_id: providerId,
						person_id: personId,
						daily_review_loading_criteria: {
							load_pending_ind: 1,
							load_overdue_ind: 1
						},
						org_security_bypass_ind: 1
					}
				],
				daily_review_anchor_dt_tm: DATE
			};
		
		var replyObj = self.m_ordersReviewObj.makeScriptCall(JSONParam, APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER);
		var reviewData = replyObj.m_responseData;
		if(reviewData.STATUS_DATA.STATUS){
			if(reviewData.DAILY_REVIEW_RESPONSES.length){
				var dailyReviews = reviewData.DAILY_REVIEW_RESPONSES[0].DAILY_REVIEWS;
				self.m_ordersReviewObj.setReviewOrders(dailyReviews);
				self.m_ordersReviewObj.setPendingOrders(dailyReviews.length);
			}
			if(callback){
				callback();
			}
		}
	
	} catch (error) {
		var errorBannerHtml = self.m_ordersReviewObj.generateErrorBannerHtml();
		$(document.body).html(errorBannerHtml);
		logger.logJSError(error, null, "mc-review.js", "getQualifiedDailyOrders");
	}
};

/*The function renderReviewOrders renders daily order review UI in message center
 */
MessageCenterOrderReview.prototype.renderReviewOrders = function () {
	var self = this;
	var timerRenderComponent = MP_Util.CreateTimer("ENG:MPG.DAILYREVIEWORDERS.01 - render");
	try {
			self.getQualifiedDailyOrders(function(){
				var orderList = self.m_ordersReviewObj.getReviewOrders();
				if(orderList.length){							
					var orderDetails = self.getOrdersdetail(orderList);
					var modalDialogContent = self.m_ordersReviewObj.generateReviewHtmlContent(self.m_reviewId, orderDetails);
					$(document.body).html(modalDialogContent);
					//calls checkIfCompletOrdersListIsViewed on window.onscroll to check user has viewed all the orders
					window.onscroll = function () {
						self.checkIfCompletOrdersListIsViewed();
					};
				}else{
					$(document.body).html("<br/>" + i18n.NO_RESULTS_FOUND);
				} 
			});
	} catch (error) {
		if (timerRenderComponent) {
			timerRenderComponent.Abort();
			timerRenderComponent = null;
		}
		var errorBannerHtml = self.m_ordersReviewObj.generateErrorBannerHtml();
		$(document.body).html(errorBannerHtml);
		logger.logJSError(error, null, "mc-review.js", "renderReviewOrders");
	}finally {
		if (timerRenderComponent) {
			timerRenderComponent.Stop();
		}
	}
};

 /*This function is the entry point in the Daily Orders Review API
 *lauchOrderReviewFromMessageCenter() will be called from the mp_order_review_driver script
 */
function lauchOrderReviewFromMessageCenter() {
	var criterion = JSON.parse(m_criterionJSON).CRITERION;
	var personId = criterion.PERSON_ID;
	var encounterId = criterion.ENCNTR_ID;
	var providerId = criterion.PRSNL_ID;
	var userTimeZone = criterion.CLIENT_TZ;
	var reviewId = personId + "_" + providerId + "_" + userTimeZone;
	var mc_ordersReviewObj = new MessageCenterOrderReview(reviewId);
	$(document.body).html("<div class='dor-preloader-modal'>&nbsp;</div><div class='dor-preloader-text'>" + mc_ordersReviewObj.m_i18nReview.LOADING_ORDERS + "</div>");
	var requestParam = {PERSON_ID : personId, ENCOUNTER_ID : encounterId, PRSNL_ID : providerId};
	mc_ordersReviewObj.setScriptRequestParams(requestParam);
	ordersReviewObj.setScriptRequestParams(requestParam);
	mc_ordersReviewObj.renderReviewOrders();
}

 /*This function will be called from message center to review the orders
  *@param {number} responsibleProviderId - personnel id responsible for the review
  *@returns {string} status code
 */
function completeReviewOrders(responsibleProviderId) {
	var criterion = JSON.parse(m_criterionJSON).CRITERION;
	var personId = criterion.PERSON_ID;
	var providerId = criterion.PRSNL_ID;
	var userTimeZone = criterion.CLIENT_TZ;
	var reviewId = personId + "_" + providerId + "_" + userTimeZone;
	if(responsibleProviderId){
		var requestParam = ordersReviewObj.getScriptRequestParams();
		requestParam.PRSNL_ID = responsibleProviderId;
		ordersReviewObj.setScriptRequestParams(requestParam);
	}
	var statusCodes = {
			SUCCESS : {
				REVIEW_SUCCESSFUL : "1"
			},
			WARNING : {
				PARTIAL_REVIEW : "101",
				SCROLL_DOWN : "102",
				NOT_DONE :"103"
			},
			SERVICE_ERROR : "201"
		};
		
	var status = statusCodes.SERVICE_ERROR;
	var serviceStatus = "";
	var isAllOrdersViewed = ordersReviewObj.checkIfCompletOrdersListIsViewed();
	if(isAllOrdersViewed){
		serviceStatus = ordersReviewObj.markOrdersAsReviewed(reviewId, userTimeZone);
	} else{
		serviceStatus = "SCROLL_DOWN";
	}
	
	switch (serviceStatus) {
		case "SUCCESS":
			status = statusCodes.SUCCESS.REVIEW_SUCCESSFUL;
			break;
		case "FAILURE":
			status = statusCodes.SERVICE_ERROR;
			break;
		case "PARTIAL_REVIEW":
			status = statusCodes.WARNING.PARTIAL_REVIEW;
			break;
		case "SCROLL_DOWN":
			status = statusCodes.WARNING.SCROLL_DOWN;
			break;
		case "NOT_DONE":
			status = statusCodes.WARNING.NOT_DONE;
			break;
		default:
			status = statusCodes.SERVICE_ERROR;
			break;
	}
	return status;
}

/*Creates a global instance of base class DailyOrderReview
 *since the functions of base class is call from two different global function*/
var ordersReviewObj = new DailyOrderReview();
/**
 * @class
 * This Mfa_Auth object is the main entry point of the Multi-Factor Authentication API. 
 * Possible Values for m_iMfaAuthStatus:
 * 0 - Authentication Success
 * 1 - Invalid Configuration Parameters
 * 2 - Authentication Failure
 * 3 - Cancelled by User
 * 4 - Error
 * 5 - Authentication Not Required
 */
var Mfa_Auth = function() {
	//Accessible variables
	this.m_mfaAuthObject = null;
	this.m_iMfaAuthStatus = 4;
	this.m_statusMessage = "";
	this.m_mfaSRObject = null;
};

/*
 * LaunchMfaAuth calls the Authenticate method from the WIN32 Multi-Factor Authentication API.
 */
Mfa_Auth.prototype.RetrieveMfaAuthStatus = function() {
	try {
		//Place the status in a Shared Resource so that the MFA only needs to be called once per session.
	    var resourceName = "MFAAuthStatus";
	    var mfaAuthResource = MP_Resources.getSharedResource(resourceName);
	    
	    if (!mfaAuthResource) {
	    	mfaAuthResource = new SharedResource(resourceName);
	    	MP_Resources.addSharedResource(resourceName, mfaAuthResource);
	    }
	    	
	    //If the resource already exists make sure that there is data in it and it is available
	    this.m_mfaSRObject = mfaAuthResource.getResourceData();
	    if(mfaAuthResource.isResourceAvailable() && this.m_mfaSRObject) {
	    	return mfaAuthResource;
	    } else {
	    	//If in Millennium retrieve the MFA Auth COM object
			this.m_mfaAuthObject = CERN_Platform.getDiscernObject('PVMFAAUTH');
		       	
			//If the MFA Auth COM object exists call the Authenticate method
			if (this.m_mfaAuthObject) {
				this.m_iMfaAuthStatus = this.m_mfaAuthObject.Authenticate();
		    	switch(this.m_iMfaAuthStatus){
		    		case 0:
		    			this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_SUCCESS_MSG;
		    			logger.logWarning(i18n.discernabu.mfa_auth.MFA_SUCCESS_MSG);
		    			break;
					case 1:
						this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_ERROR_MSG;
						logger.logWarning(i18n.discernabu.mfa_auth.MFA_INVALID_PARAMS_MSG);
						break;
					case 2:
						this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_AUTH_FAILED_MSG;
						logger.logWarning(i18n.discernabu.mfa_auth.MFA_AUTH_FAILED_MSG);
						break;
					case 3:
						this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_USER_CANCELLED_MSG;
						logger.logWarning(i18n.discernabu.mfa_auth.MFA_USER_CANCELLED_MSG);
						break;
					case 4:
						this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_ERROR_MSG;
						logger.logWarning(i18n.discernabu.mfa_auth.MFA_ERROR_MSG);
						break;
					case 5:
						this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_AUTH_NOT_REQUIRED_MSG;
						logger.logWarning(i18n.discernabu.mfa_auth.MFA_AUTH_NOT_REQUIRED_MSG);
						break;
				}
			} else {
				this.m_iMfaAuthStatus = 5;
				this.m_statusMessage = i18n.discernabu.mfa_auth.MFA_AUTH_NOT_REQUIRED_MSG;
				logger.logWarning(i18n.discernabu.mfa_auth.MFA_COM_OBJ_MISSING);
			}
	    }
	    	//Set the Shared Resource data
	    	this.m_mfaSRObject = {status:this.m_iMfaAuthStatus, message:this.m_statusMessage};
			mfaAuthResource.setResourceData(this.m_mfaSRObject);
			mfaAuthResource.setIsAvailable(true);
			return mfaAuthResource;
	} catch (err) {
	    	logger.logJSError(err, this, "mfa-auth.js", "RetrieveMfaAuthStatus");
	}
};


/*global logger, MP_Viewpoint*/

/**
 * A collection of functions which can be used to maintain, create, destroy and update modal dialogs.
 * The MP_ModalDialog function keeps a copy of all of the ModalDialog objects that have been created
 * for the current view.  If a ModalDialog object is updated outside of these functions, the updated
 * version of the object should replace the stale version that is stored here by using the
 * updateModalDialogObject functionality.
 * @namespace
 */
var MP_ModalDialog = {};
MP_ModalDialog.modalDialogObjects = {};
MP_ModalDialog.whiteSpacePixels = 26;

/**
 * This function will be used to add ModalDialog objects to the collection of ModalDialog objects for the current
 * View.  This list of ModalDialog objects will be the one source of this type of object and will be used when
 * showing modal dialogs.
 * @param {ModalDialog} modalObject An instance of the ModalDialog object
 * @return [boolean] true if the ModalDialog object was added successfully, false otherwise.
 */
MP_ModalDialog.addModalDialogObject = function (modalObject) {
	var modalId = "";
	//Check that he object is not null and that the object type is ModalDialog
	if (!(modalObject instanceof ModalDialog)) {
		logger.logError("MP_ModalDialog.addModalDialogObject only accepts objects of type ModalDialog");
		return false;
	}

	//Check for a valid id.
	modalId = modalObject.getId();
	if (!modalId) {
		//Modal id is not populated
		logger.logError("MP_ModalDialog.addModalDialogObject: no/invalid ModalDialog id given");
		return false;
	}
	else if(this.modalDialogObjects[modalId]) {
		//Modal id is already in use
		logger.logError("MP_ModalDialog.addModalDialogObject: modal dialog id " + modalId + " is already in use");
		return false;
	}

	//Add the ModalDialog Object to the list of ModalDialog objects
	this.modalDialogObjects[modalId] = modalObject;
	return true;
};

/**
 * Add the modal dialog icon to the viewpoint framework.  This icon will be responsible for
 * launching the correct modal dialog based on the ModalDialog object that it is associated to.
 * @param {string} modalDialogId The id of the ModalDialog object to reference when creating the modal dialog icon
 * @return {boolean} true if the dialog was added to the viewpoint, false otherwise.
 */
MP_ModalDialog.addModalDialogOptionToViewpoint = function (modalDialogId) {
	var modalObj = null;

	//Check to see if the ModalDialog exists
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		return false;
	}

	//If the MP_Viewpoint function is defined call it
	if (typeof MP_Viewpoint !== "undefined" && typeof MP_Viewpoint.addModalDialogUtility !== "undefined") {
		MP_Viewpoint.addModalDialogUtility(modalObj);
		return true;
	}
};

/**
 * Closes all of the associated modal dialog windows
 * @param {string} modalDialogId The id of the modal dialog to close
 * @return {boolean} true if the dialog was closed, false otherwise
 */
MP_ModalDialog.closeModalDialog = function (modalDialogId) {
	var modalObj = null;

	//Check to see if the ModalDialog exists
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		return false;
	}

	//destroy the modal dialog
	$("#vwpModalDialog" + modalObj.getId()).remove();
	//destroy the modal background
	$("#vwpModalBackground" + modalObj.getId()).remove();
	//Mark the modal dialog as inactive
	modalObj.setIsActive(false);
	$("body").css("overflow", "auto");
	return true;
};

/**
 * Deletes the modal dialog object with the id modalDialogId.
 * @param {string} modalDialogId The id of the modal dialog object to be deleted
 * @return {boolean} True if a ModalDialog object was deleted, false otherwise
 */
MP_ModalDialog.deleteModalDialogObject = function (modalDialogId) {
	if (this.modalDialogObjects[modalDialogId]) {
		delete this.modalDialogObjects[modalDialogId];
		return true;
	}
	return false;
};

/**
 * Retrieves the ModalDialog object with the id of modalDialogId
 * @param {string} modalDialogId The id of the modal dialog object to retrieve
 * @return {ModalDialog} Returns the modal dialog object if it exists in the collection
 */
MP_ModalDialog.retrieveModalDialogObject = function (modalDialogId) {
	if (this.modalDialogObjects[modalDialogId]) {
		return this.modalDialogObjects[modalDialogId];
	}
	return null;
};

/**
 * Resizes all of the active modal dialogs when the window itself is being resized.
 * @param {string} modalDialogId The id of the modal dialog object to resize
 * @return null
 */
MP_ModalDialog.resizeAllModalDialogs = function () {
	var dialog = null;
	var attr = "";
	//Get all of the modal dialog objects from the modalDialogObjects collection
	for (attr in MP_ModalDialog.modalDialogObjects) {
		if (MP_ModalDialog.modalDialogObjects.hasOwnProperty(attr)) {
			dialog = MP_ModalDialog.modalDialogObjects[attr];
			if (dialog.isActive()) {
				MP_ModalDialog.resizeModalDialog(dialog.getId());
			}
		}
	}
};

/**
 * Resizes the modal dialog when the window itself is being resized.
 * @param {string} modalDialogId The id of the modal dialog object to resize
 * @return null
 */
MP_ModalDialog.resizeModalDialog = function (modalDialogId) {
	var docHeight = 0;
	var docWidth = 0;
	var topMarginSize = 0;
	var leftMarginSize = 0;
	var bottomMarginSize = 0;
	var rightMarginSize = 0;
	var modalWidth = "";
	var modalHeight = "";
	var modalObj = null;

	//Get the ModalDialog object
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		logger.logError("MP_ModalDialog.resizeModalDialog: No modal dialog with the id " + modalDialogId + " exists");
		return;
	}

	if (!modalObj.isActive()) {
		logger.logError("MP_ModalDialog.resizeModalDialog: this modal dialog is not active it cannot be resized");
		return;
	}

	//Determine the new margins and update accordingly
	docHeight = $(window).height();
	docWidth = $(document.body).width();
	topMarginSize = Math.floor(docHeight * (modalObj.getTopMarginPercentage() / 100));
	leftMarginSize = Math.floor(docWidth * (modalObj.getLeftMarginPercentage() / 100));
	bottomMarginSize = Math.floor(docHeight * (modalObj.getBottomMarginPercentage() / 100));
	rightMarginSize = Math.floor(docWidth * (modalObj.getRightMarginPercentage() / 100));
	modalWidth = (docWidth - leftMarginSize - rightMarginSize);
	modalHeight = (docHeight - topMarginSize - bottomMarginSize);
	$("#vwpModalDialog" + modalObj.getId()).css({
		"top" : topMarginSize,
		"left" : leftMarginSize,
		"width" : modalWidth + "px"
	});

	//Make sure the body div fills all of the alloted space if the body is a fixed size and also make sure the modal dialog is sized correctly.
	if (modalObj.isBodySizeFixed()) {
		$("#vwpModalDialog" + modalObj.getId()).css("height", modalHeight + "px");
		$("#" + modalObj.getBodyElementId()).height(modalHeight - $("#" + modalObj.getHeaderElementId()).height() - $("#" + modalObj.getFooterElementId()).height() - this.whiteSpacePixels);
	}
	else {
		$("#vwpModalDialog" + modalObj.getId()).css("max-height", modalHeight + "px");
		$("#" + modalObj.getBodyElementId()).css("max-height", (modalHeight - $("#" + modalObj.getHeaderElementId()).height() - $("#" + modalObj.getFooterElementId()).height() - this.whiteSpacePixels) + "px");
	}

	//Make sure the modal background is resized as well
	$("#vwpModalBackground" + modalObj.getId()).css({
		"height" : "100%",
		"width" : "100%"
	});
};

/**
 * Render and show the modal dialog based on the settings applied in the ModalDialog object referenced by the
 * modalDialogId parameter.
 * @param {string} modalDialogId The id of the ModalDialog object to render
 * @return null
 */
MP_ModalDialog.showModalDialog = function (modalDialogId) {
	var bodyDiv = null;
	var bodyLoadFunc = null;
	var bottomMarginSize = 0;
	var button = null;
	var dialogDiv = null;
	var docHeight = 0;
	var docWidth = 0;
	var focusButtonId = "";
	var footerDiv = null;
	var footerButtons = [];
	var footerButtonsCnt = 0;
	var footerButtonContainer = null;
	var headerDiv = null;
	var leftMarginSize = 0;
	var modalDiv = null;
	var modalObj = null;
	var modalHeight = "";
	var modalWidth = "";
	var rightMarginSize = 0;
	var topMarginSize = 0;
	var x = 0;
	var footerCheckbox = null;
	var footerText = "";

	/**
	 * This function is used to create onClick functions for each button.  Using this function
	 * will prevent closures from applying the same action onClick function to all buttons.
	 */
	function createButtonClickFunc(buttonObj, modalDialogId) {
		var clickFunc = buttonObj.getOnClickFunction();
		var closeModal = buttonObj.closeOnClick();
		if (!clickFunc) {
			clickFunc = function () {};

		}
		return function () {
			clickFunc();
			if (closeModal) {
				MP_ModalDialog.closeModalDialog(modalDialogId);
			}
		};

	}

	//Get the ModalDialog object
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		logger.logError("MP_ModalDialog.showModalDialog: No modal dialog with the id " + modalDialogId + " exists");
		return;
	}

	//Check to see if the modal dialog is already displayed.  If so, return
	if (modalObj.isActive()) {
		return;
	}

	//Create the modal window based on the ModalDialog object
	//Create the header div element
	headerDiv = $("<div id='" + modalObj.getHeaderElementId() + "' class='dyn-modal-hdr-container'><span class='dyn-modal-hdr-title'>" + (modalObj.getHeaderTitle() || "&nbsp;") + "</span></div>");
	if (modalObj.showCloseIcon()) {
		headerDiv.append($("<span class='dyn-modal-hdr-close'></span>").click(function () {
				var closeFunc = null;
				var closeFunctionResponse = true;
				//call the close function of the modalObj
				closeFunc = modalObj.getHeaderCloseFunction();
				if (closeFunc) {
					closeFunctionResponse = closeFunc();
				}

				//Determine if we should close the modal or not
				if (modalObj.verifyCloseFunctionResponse()) {
					//Since we need to verify the close function response only close the modal when
					//the close function returned a truthy value or no close function is executed
					if (closeFunctionResponse) {
						MP_ModalDialog.closeModalDialog(modalObj.getId());
					}
			}
			else {
					MP_ModalDialog.closeModalDialog(modalObj.getId());
				}
			}));
	}

	//Create the body div element
	bodyDiv = $("<div id='" + modalObj.getBodyElementId() + "' class='dyn-modal-body-container'></div>");

	//Create the footer element if there are any buttons available or the checkbox is available
	footerButtons = modalObj.getFooterButtons();
	footerButtonsCnt = footerButtons.length;
	footerCheckbox = modalObj.getFooterCheckbox();
	footerText = modalObj.getFooterText();
	if (footerButtonsCnt || footerCheckbox.enabled || footerText !== "") {
		//Create the footer element
		footerDiv = $("<div id='" + modalObj.getFooterElementId() + "' class='dyn-modal-footer-container'></div>");
		//If the checkbox is enabled create the necessary elements
		if (footerCheckbox.enabled) {
			var checkboxContainer = $("<label class='dyn-modal-checkbox-container'></label>");
			var checkboxEle = $("<input type='checkbox' class='dyn-modal-checkbox'" + ((footerCheckbox.isChecked) ? " checked" : "") + ">");
			checkboxEle.click(footerCheckbox.onClick);
			checkboxContainer.append(checkboxEle);
			checkboxContainer.append("<span class='dyn-modal-checkbox-label'>" + footerCheckbox.label + "</span>");
			footerDiv.append(checkboxContainer);
		}
		
		//If footer buttons are enabled, rendering each button and apply the necessary click events
		if (footerButtonsCnt) {
			footerButtonContainer = $("<div id='" + modalObj.getFooterElementId() + "btnCont' class='dyn-modal-button-container'></div>");
			for (x = 0; x < footerButtonsCnt; x++) {
				button = footerButtons[x];
				footerButtonContainer.append($("<button id='" + button.getId() + "' class='dyn-modal-button'" + ((button.isDithered()) ? " disabled" : "") + ">" + button.getText() + "</button>").click(createButtonClickFunc(button, modalObj.getId())));
				//Check to see the footer button has a separator.
				if (button.getSeparatorInd()) {
					footerButtonContainer.append("<span class='dyn-modal-button-separator'></span>");
				}
				//Check to see if we should focus on this button when loading the modal dialog
				if (!focusButtonId) {
					focusButtonId = (button.getFocusInd()) ? button.getId() : "";
				}
			}
			footerDiv.append(footerButtonContainer);
		}

		//Create a footer text element if there is a label
		if (footerText !== "") {
			footerDiv.append("<span id='" + modalObj.getFooterTextElementId() + "' class='dyn-modal-footer-text'>" + footerText + "</span>");
		}

	}
	else if(modalObj.isFooterAlwaysShown()) {
		footerDiv = $("<div id='" + modalObj.getFooterElementId() + "' class='dyn-modal-footer-container'></div>");
	}

	//determine the dialog size
	docHeight = $(window).height();
	docWidth = $(document.body).width();
	topMarginSize = Math.floor(docHeight * (modalObj.getTopMarginPercentage() / 100));
	leftMarginSize = Math.floor(docWidth * (modalObj.getLeftMarginPercentage() / 100));
	bottomMarginSize = Math.floor(docHeight * (modalObj.getBottomMarginPercentage() / 100));
	rightMarginSize = Math.floor(docWidth * (modalObj.getRightMarginPercentage() / 100));
	modalWidth = (docWidth - leftMarginSize - rightMarginSize);
	modalHeight = (docHeight - topMarginSize - bottomMarginSize);
	dialogDiv = $("<div id='vwpModalDialog" + modalObj.getId() + "' class='dyn-modal-dialog'></div>").css({
			"top" : topMarginSize,
			"left" : leftMarginSize,
			"width" : modalWidth + "px"
		});
	dialogDiv.append(headerDiv).append(bodyDiv).append(footerDiv);

	//Create the modal background if set in the ModalDialog object.
	modalDiv = $("<div id='vwpModalBackground" + modalObj.getId() + "' class='" + ((modalObj.hasGrayBackground()) ? "dyn-modal-div" : "dyn-modal-div-clear") + "'></div>").height($(document).height());

	//Add the flash function to the modal if using a clear background
	if (!modalObj.hasGrayBackground()) {
		modalDiv.click(function () {
			var modal = $("#vwpModalDialog" + modalObj.getId());
			modal.fadeOut(100);
			modal.fadeIn(100);
		});

	}

	//Add all of these elements to the document body
	$(document.body).append(modalDiv).append(dialogDiv);

	//Set the focus of a button if indicated
	if (focusButtonId) {
		$("#" + focusButtonId).focus();
	}
	//disable page scrolling when modal is enabled
	$("body").css("overflow", "hidden");

	//Make sure the body div fills all of the alloted space if the body is a fixed size and also make sure the modal dialog is sized correctly.
	if (modalObj.isBodySizeFixed()) {
		$(dialogDiv).css("height", modalHeight + "px");
		$(bodyDiv).height(modalHeight - $(headerDiv).height() - $(footerDiv).height() - this.whiteSpacePixels);
	}
	else {
		$(dialogDiv).css("max-height", modalHeight + "px");
		$(bodyDiv).css("max-height", (modalHeight - $(headerDiv).height() - $(footerDiv).height() - this.whiteSpacePixels) + "px");
	}

	//This next line makes the modal draggable.  If this is commented out updates will need to be made
	//to resize functions and also updates to the ModalDialog object to save the location of the modal
	//$(dialogDiv).draggable({containment: "parent"});

	//Mark the displayed modal as active and save its id
	modalObj.setIsActive(true);

	//Call the onBodyLoadFunction of the modal dialog
	bodyLoadFunc = modalObj.getBodyDataFunction();
	if (bodyLoadFunc) {
		bodyLoadFunc(modalObj);
	}

	//Attempt to resize the window as it is being resized
	$(window).resize(this.resizeAllModalDialogs);
};

/**
 * Updates the existing ModalDialog with a new instance of the object.  If the modal objet does not exist it is added to the collection
 * @param {ModalDialog} modalObject The updated instance of the ModalDialog object.
 * @return null
 */
MP_ModalDialog.updateModalDialogObject = function (modalObject) {
	var modalDialogId = "";

	//Check to see if we were passed a ModalDialog object
	if (!modalObject || !(modalObject instanceof ModalDialog)) {
		logger.logError("MP_ModalDialog.updateModalDialogObject only accepts objects of type ModalDialog");
		return;
	}

	//Blindly update the ModalDialog object.  If it didnt previously exist, it will now.
	modalDialogId = modalObject.getId();
	this.modalDialogObjects[modalDialogId] = modalObject;
	return;
};


/**
 * The ModalButton class is used specifically for adding buttons to the footer of a modal dialog.
 * @constructor
 */
function ModalButton(buttonId) {
	//The id given to the button.  This id will be used to identify individual buttons
	this.m_buttonId = buttonId;
	//The text that will be displayed in the button itself
	this.m_buttonText = "";
	//A flag to determine if the button shall be disabled or not
	this.m_dithered = false;
	//The function to call when the button is clicked
	this.m_onClickFunction = null;
	//A flag to determine if this button should be closed when clicked.
	this.m_closeOnClick = true;
	//A flag to determine if this button should be focused when the modal dialog is shown
	this.m_focusInd = false;
	//A flag to determine if this button should show a separator next to it.
	this.m_separatorInd = false;
}

/** Checkers **/
/**
 * Check to see if the button click should close the modal dialog on click
 * @return {boolean} A boolean which determines if the button click should cause the modal dialog to close
 */
ModalButton.prototype.closeOnClick = function () {
	return this.m_closeOnClick;
};

/**
 * Check to see if the Modal Button is currently dithered
 * @return {boolean} A boolean flag that indicates if the modal button is dithered or not
 */
ModalButton.prototype.isDithered = function () {
	return this.m_dithered;
};

/** Getters **/
/**
 * Retrieves the id assigned the this ModalButton object
 * @return {string} The id assigned to this ModalButton object
 */
ModalButton.prototype.getId = function () {
	return this.m_buttonId;
};

/**
 * Retrieve the close on click flag of the ModalButton object
 * @return {boolean} The close on click flag of the ModalButton object
 */
ModalButton.prototype.getCloseOnClick = function () {
	return this.m_closeOnClick;
};

/**
 * Retrieve the focus indicator flag of the ModalButton object
 * @return {boolean} The focus indicator flag of the ModalButton object
 */
ModalButton.prototype.getFocusInd = function () {
	return this.m_focusInd;
};

/**
 * Retrieves the text used for the ModalButton display
 * @return {string} The text which will be used in the button display
 */
ModalButton.prototype.getText = function () {
	return this.m_buttonText;
};

/**
 * Retrieves the onClick function associated to this Modal Button
 * @return {function} The function executed when the button is clicked
 */
ModalButton.prototype.getOnClickFunction = function () {
	return this.m_onClickFunction;
};
/**
 * Retrieve the button separator indicator flag of the ModalButton object
 * @return {boolean} The button separator indicator flag of the ModalButton object
 */
ModalButton.prototype.getSeparatorInd = function () {
	return this.m_separatorInd;
};

/** Setters **/

/**
 * Sets the id of the ModalButton object.  The id must be a string otherwise it is ignored.
 * @param {string} buttonId The id which will be assigned to the button DOM element
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setId = function (buttonId) {
	if (buttonId && typeof buttonId === "string") {
		this.m_buttonId = buttonId;
	}
	return this;
};

/**
 * Sets the close on click flag of the dialog button
 * @param {boolean} closeFlag A boolean flag which determines if the dialog should close when the
 * button is clicked
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setCloseOnClick = function (closeFlag) {
	if (typeof closeFlag === "boolean") {
		this.m_closeOnClick = closeFlag;
	}
	return this;
};

/**
 * Sets the focus indicator flag of the dialog button
 * @param {boolean} focusInd A boolean flag which determines if the button should have focus on
 * initial dialog load.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setFocusInd = function (focusInd) {
	if (typeof focusInd === "boolean") {
		this.m_focusInd = focusInd;
	}
	return this;
};

/**
 * Sets the text which will be shown in the button
 * @param {string} buttonText The string value to display as the button text
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setText = function (buttonText) {
	if (buttonText && typeof buttonText === "string") {
		this.m_buttonText = buttonText;
	}
	return this;
};

/**
 * Sets the dithered status of the dialog button
 * @param {boolean} dithere A boolean flag which determines if the button should be dithered
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setIsDithered = function (dithered) {
	if (typeof dithered === "boolean") {
		this.m_dithered = dithered;
	}
	return this;
};

/**
 * Sets the onClick function for the ModalButton
 * @param {function} clickFunc The function to execute when this button is clicked.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setOnClickFunction = function (clickFunc) {
	if (typeof clickFunc === "function") {
		this.m_onClickFunction = clickFunc;
	}
	return this;
};

/**
 * Sets the button separator indicator flag of the dialog button.If the separator indicator is
 * set to true then the separator is displayed to the right of the button.
 * @param {boolean} separatorFlag A boolean flag which determines if the button will have a visual
 * separator displayed to the right of the button.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setSeparatorInd = function (separatorFlag) {
	if (typeof separatorFlag === "boolean") {
		this.m_separatorInd = separatorFlag;
	}
	return this;
};

/**
 * The ModalDialog object contains information about the aspects of how the modal dialog will be created and what actions will take
 * place.  Depending on how the variables are set, the modal can flex based on the consumers needs.  Customizable options include the following;
 * size, modal title, onClose function, modal body content, variable footer buttons with dither options and onclick events.
 * @constructor
 */
function ModalDialog(modalId) {
	//The id given to the ModalDialog object.  Will be used to set/retrieve the modal dialog
	this.m_modalId = modalId;
	//A flag used to determine if the modal is active or not
	this.m_isModalActive = false;
	//A flag to determine if the modal should be fixed to the icon used to activate the modal
	this.m_isFixedToIcon = false;
	//A flag to determine if the modal dialog should grey out the background when being displayed or not.
	this.m_hasGrayBackground = true;
	//A flag to determine if the close icon should be shown or not
	this.m_showCloseIcon = true;

	//The margins object contains the margins that will be applied to the modal window.
	this.m_margins = {
		top : 5,
		right : 5,
		bottom : 5,
		left : 5
	};

	//The icon object contains information about the icon that the user will use to launch the modal dialog
	this.m_icon = {
		elementId : modalId + "icon",
		cssClass : "",
		text : "",
		hoverText : "",
		isActive : true
	};

	//The header object of the modal.  Contains all of the necessary information to render the header of the dialog
	this.m_header = {
		elementId : modalId + "header",
		title : "",
		closeFunction : null,
		verifyCloseFunctionResponse : false
	};

	//The body object of the modal.  Contains all of the necessary information to render the body of the dialog
	this.m_body = {
		elementId : modalId + "body",
		dataFunction : null,
		isBodySizeFixed : true
	};

	//The footer object of the modal.  Contains all of the necessary information to render the footer of the dialog
	this.m_footer = {
		isAlwaysShown : false,
		elementId : modalId + "footer",
		buttons : [],
		checkbox : {
			enabled : false,
			isChecked : false,
			onClick : function () {
				return false;
			},
			label : ""
		},
		footerText : {
			text : "",
			elementId : modalId + "FooterText"
		}
	};
}

/** Adders **/

/**
 * Adds a ModalButton object to the list of buttons that will be used in the footer of to modal dialog.
 * Only ModalButtons will be used, no other object type will be accepted.
 * @param {ModalButton} modalButton The button to add to the footer.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.addFooterButton = function (modalButton) {
	if (!(modalButton instanceof ModalButton)) {
		logger.logError("ModalDialog.addFooterButton: Cannot add footer button which isnt a ModalButton object.\nModalButtons can be created using the ModalDialog.createModalButton function.");
		return this;
	}

	if (!modalButton.getId()) {
		logger.logError("ModalDialog.addFooterButton: All ModalButton objects must have an id assigned");
		return this;
	}

	this.m_footer.buttons.push(modalButton);
	return this;
};

/** Checkers **/

/**
 * Checks to see if the modal dialog object has a gray background or not
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.hasGrayBackground = function () {
	return this.m_hasGrayBackground;
};

/**
 * Checks to see if the modal dialog object is active or not
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.isActive = function () {
	return this.m_isModalActive;
};

/**
 * Checks to see if the modal dialog body should have a fixed size or not
 * @return {boolean} True if the modal dialog body is a fixed size, false otherwise
 */
ModalDialog.prototype.isBodySizeFixed = function () {
	return this.m_body.isBodySizeFixed;
};

/**
 * Checks to see if the modal dialog footer should always be shown or not
 * @return {boolean} True if the modal dialog footer should always be shown
 */
ModalDialog.prototype.isFooterAlwaysShown = function () {
	return this.m_footer.isAlwaysShown;
};

/**
 * Checks if the modal should be fixed to the icon used to activate the modal
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.isFixedToIcon = function () {
	return this.m_isFixedToIcon;
};

/**
 * Checks to see if the modal dialog icon is active or not
 * @return {boolean} True if the modal dialog icon is active, false otherwise
 */
ModalDialog.prototype.isIconActive = function () {
	return this.m_icon.isActive;
};

/**
 * Checks to see if the close icon should be shown in the modal dialog
 * @return {boolean} True if the close icon should be shown, false otherwise
 */
ModalDialog.prototype.showCloseIcon = function () {
	return this.m_showCloseIcon;
};

/**
 * Checks to see if the response of the close function associated to the Header close icon
 * should be checked before closing the dialog.  If set to true, the response of the close function will determine
 * if the dialog will be closed or not.  A true response indicates that the dialog can be closed.  A false response
 * indicates that they dialog should not be closed.
 * @return {boolean} A flag which determines if the dialog should check the response of the close function
 * before closing the dialog.
 */
ModalDialog.prototype.verifyCloseFunctionResponse = function () {
	return this.m_header.verifyCloseFunctionResponse;
};

/** Getters **/

/**
 * Retrieves the function that will be used when attempting to populate the content of the modal dialog body.
 * @return {function} The function used when loading the modal dialog body
 */
ModalDialog.prototype.getBodyDataFunction = function () {
	return this.m_body.dataFunction;
};

/**
 * Retrieves the id associated to the modal dialog body element
 * @return {string} The id associated to the modal dialog body element
 */
ModalDialog.prototype.getBodyElementId = function () {
	return this.m_body.elementId;
};

/**
 * Retrieves the percentage set for the bottom margin of the modal dialog
 * @return {number} The percentage assigned to the bottom margin for the modal dialog
 */
ModalDialog.prototype.getBottomMarginPercentage = function () {
	return this.m_margins.bottom;
};

/**
 * Retrieves the button identified by the id passed into the function
 * @param {string} buttonId The if of the ModalButton object to retrieve
 * @return {ModalButton} The modal button with the id of buttonId, else null
 */
ModalDialog.prototype.getFooterButton = function (buttonId) {
	var x = 0;
	var button = null;
	var buttons = this.getFooterButtons();
	var buttonCnt = buttons.length;
	//Get the ModalButton
	for (x = buttonCnt; x--; ) {
		button = buttons[x];
		if (button.getId() === buttonId) {
			return buttons[x];
		}
	}
	return null;
};

/**
 * Retrieves the array of buttons which will be used in the footer of the modal dialog.
 * @return {ModalButton[]} An array of ModalButton objects which will be used in the footer of the modal dialog
 */
ModalDialog.prototype.getFooterButtons = function () {
	return this.m_footer.buttons;
};

/**
 * Retrieves the id associated to the modal dialog footer element
 * @return {string} The id associated to the modal dialog footer element
 */
ModalDialog.prototype.getFooterElementId = function () {
	return this.m_footer.elementId;
};

/**
 * Retrieves the footer checkbox object associated to the modal dialog
 * @return {object} The checkbox associated to the modal dialog footer element
 */
ModalDialog.prototype.getFooterCheckbox = function () {
	return this.m_footer.checkbox;
};

/**
 * Retrieves a boolean which determines if the checkbox is enabled in the modal dialog footer.
 * @return {boolean} The flag which determines if this modal dialog should display a checkbox in the footer
 */
ModalDialog.prototype.getIsFooterCheckboxEnabled = function () {
	return this.m_footer.checkbox.enabled;
};

/**
 * Retrieves a boolean which determines if the checkbox is checked in the modal dialog footer.
 * @return {boolean} The flag which returns the state of the modal dialog footer checkbox
 */
ModalDialog.prototype.getFooterCheckboxIsChecked = function () {
	return this.m_footer.checkbox.isChecked;
};

/**
 * Retrieves the string label for the checkbox in the modal dialog footer.
 * @return {string} The label that appears next to the checkbox in the modal dialog footer
 */
ModalDialog.prototype.getFooterCheckboxLabel = function () {
	return this.m_footer.checkbox.label;
};

/**
 * Retrieves a boolean which determines if the modal dialog should display a gray background or not
 * @return {boolean} The flag which determines if this modal dialog should display a gray background
 */
ModalDialog.prototype.getHasGrayBackground = function () {
	return this.m_hasGrayBackground;
};

/**
 * Retrieves the function that will be used when the user attempts to close the modal dialog.
 * @return {function} The function used when closing the modal dialog
 */
ModalDialog.prototype.getHeaderCloseFunction = function () {
	return this.m_header.closeFunction;
};

/**
 * Retrieves the id associated to the modal dialog header element
 * @return {string} The id associated to the modal dialog header element
 */
ModalDialog.prototype.getHeaderElementId = function () {
	return this.m_header.elementId;
};

/**
 * Retrieves the title which will be used in the header of the modal dialog
 * @return {string} The title given to the modal dialog header element
 */
ModalDialog.prototype.getHeaderTitle = function () {
	return this.m_header.title;
};

/**
 * Retrieves the css class which will be applied to the html span used to open the modal dialog
 * @return {string} The css which will be applied to the html span used ot open the modal dialog
 */
ModalDialog.prototype.getIconClass = function () {
	return this.m_icon.cssClass;
};

/**
 * Retrieves the id associated to the modal dialog icon element
 * @return {string} The id associated to the modal dialog icon element
 */
ModalDialog.prototype.getIconElementId = function () {
	return this.m_icon.elementId;
};

/**
 * Retrieves the text which will be displayed the user hovers over the modal dialog icon
 * @return {string} The text displayed when hovering over the modal dialog icon
 */
ModalDialog.prototype.getIconHoverText = function () {
	return this.m_icon.hoverText;
};

/**
 * Retrieves the text which will be displayed next to the icon used to open the modal dialog
 * @return {string} The text displayed next to the icon
 */
ModalDialog.prototype.getIconText = function () {
	return this.m_icon.text;
};

/**
 * Retrieves the id given to this modal dialog object
 * @return {string} The id given to this modal dialog object
 */
ModalDialog.prototype.getId = function () {
	return this.m_modalId;
};

/**
 * Retrieves a boolean which determines if this modal dialog object is active or not
 * @return {boolean} The flag which determines if this modal dialog object is active or not
 */
ModalDialog.prototype.getIsActive = function () {
	return this.m_isModalActive;
};

/**
 * Retrieves a boolean which determines if this body of the modal dialog object has a fixed height or not
 * @return {boolean} The flag which determines if the body of the modal dialog object is fixed or not
 */
ModalDialog.prototype.getIsBodySizeFixed = function () {
	return this.m_body.isBodySizeFixed;
};

/**
 * Retrieves a boolean which determines if this modal dialog object is fixed to the icon used to launch it.
 * @return {boolean} The flag which determines if this modal dialog object is active or not
 */
ModalDialog.prototype.getIsFixedToIcon = function () {
	return this.m_isFixedToIcon;
};

/**
 * Retrieves a boolean which determines if this modal dialog footer is always shown or not.
 * @return {boolean} The flag which determines if this modal dialog footer is always shown or not.
 */
ModalDialog.prototype.getIsFooterAlwaysShown = function () {
	return this.m_footer.isAlwaysShown;
};

/**
 * Retrieves a boolean which determines if this modal dialog icon is active or not.  If the icon is not active it should
 * not be clickable by the user and the cursor should not change when hovered over.
 * @return {boolean} The flag which determines if modal dialog icon is active or not.
 */
ModalDialog.prototype.getIsIconActive = function () {
	return this.m_icon.isActive;
};

/**
 * Retrieves the percentage set for the left margin of the modal dialog
 * @return {number} The percentage assigned to the left margin for the modal dialog
 */
ModalDialog.prototype.getLeftMarginPercentage = function () {
	return this.m_margins.left;
};

/**
 * Retrieves the percentage set for the right margin of the modal dialog
 * @return {number} The percentage assigned to the right margin for the modal dialog
 */
ModalDialog.prototype.getRightMarginPercentage = function () {
	return this.m_margins.right;
};

/**
 * Retrieves a boolean which determines if the close icon should be shown in the modal dialog.
 * @return {boolean} The flag which determines if the close icon should be shown or not.
 */
ModalDialog.prototype.getShowCloseIcon = function () {
	return this.m_showCloseIcon;
};

/**
 * Retrieves the percentage set for the top margin of the modal dialog
 * @return {number} The percentage assigned to the top margin for the modal dialog
 */
ModalDialog.prototype.getTopMarginPercentage = function () {
	return this.m_margins.top;
};
/**
 * Retrieves the footer text which will be displayed in the footer of the modal dialog
 * @return {string} The text to display in the footer of the modal dialog.
 */
ModalDialog.prototype.getFooterText = function () {
	return this.m_footer.footerText.text;
};
/**
 * Retrieves the id associated to the modal dialog footer text element
 * @return {string} The id associated to the modal dialog footer text element
 */
ModalDialog.prototype.getFooterTextElementId = function () {
	return this.m_footer.footerText.elementId;
};

/** Setters **/
/**
 * Sets the function to be called when the modal dialog is shown.  This function will be passed ModalDialog object so that
 * it can interact with the modal dialog easily while the dialog is open.
 * @param {function} dataFunc The function used to populate the body of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyDataFunction = function (dataFunc) {

	//Check the proposed function
	if (!(typeof dataFunc === "function") && dataFunc !== null) {
		logger.logError("ModalDialog.setBodyDataFunction: dataFunc param must be a function or null");
		return this;
	}

	this.m_body.dataFunction = dataFunc;
	return this;
};

/**
 * Sets the html element id of the modal dialog body.  This id will be used to insert html into the body of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getBodyElementId()).attr("id", elementId);
		}
		this.m_body.elementId = elementId;
	}
	return this;
};

/**
 * Sets the html of the body element.
 * @param {string} html The HTML to insert into the body element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyHTML = function (html) {
	if (html && typeof html === "string") {
		//Update the existing html iff the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getBodyElementId()).html(html);
		}
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the bottom margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the bottom margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBottomMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.bottom = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the close on click property of a specific button in the modal dialog.
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} closeOnClick A boolean used to determine if the button should close the dialog or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonCloseOnClick = function (buttonId, closeOnClick) {
	var button = null;
	var buttonElement = null;
	var onClickFunc = null;
	var modal = this;

	//check the closeOnClick type
	if (!(typeof closeOnClick === "boolean")) {
		logger.logError("ModalDialog.setFooterButtonCloseOnClick: closeOnClick param must be of type boolean");
		return this;
	}

	//Get the ModalButton
	button = this.getFooterButton(buttonId);
	if (button) {
		//Update the closeOnClick flag
		button.setCloseOnClick(closeOnClick);
		//If the modal dialog is active, update the existing class
		if (this.isActive()) {
			//Update the class of the object
			buttonElement = $("#" + buttonId);
			buttonElement.click(function () {
				onClickFunc = button.getOnClickFunction();
				if (onClickFunc && typeof onClickFunc === "function") {
					onClickFunc();
				}
				if (closeOnClick) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			});

		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonCloseOnClick: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the dithered property of a specific button in the modal dialog
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} dithered A boolean used to determine if the button should be dithered or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonDither = function (buttonId, dithered) {
	var button = null;
	var buttonElement = null;

	//check the dithered type
	if (!(typeof dithered === "boolean")) {
		logger.logError("ModalDialog.setFooterButtonDither: Dithered param must be of type boolean");
		return this;
	}

	//Get the ModalButton
	button = this.getFooterButton(buttonId);
	if (button) {
		//Update the dithered flag
		button.setIsDithered(dithered);
		//If the modal dialog is active, update the existing class
		if (this.isActive()) {
			//Update the class of the object
			buttonElement = $("#" + buttonId);
			if (dithered) {
				buttonElement.attr("disabled", true);
			}
			else {
				buttonElement.attr("disabled", false);
			}
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonDither: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the onclick function of the footer button with the given buttonId
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} dithered A boolean used to determine if the button should be dithered or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonOnClickFunction = function (buttonId, clickFunc) {
	var button = null;
	var modal = this;

	//Check the proposed function and make sure it is a function
	if (!(typeof clickFunc === "function") && clickFunc !== null) {
		logger.logError("ModalDialog.setFooterButtonOnClickFunction: clickFunc param must be a function or null");
		return this;
	}

	//Get the modal button
	button = this.getFooterButton(buttonId);
	if (button) {
		//Set the onclick function of the button
		button.setOnClickFunction(clickFunc);
		//If the modal dialog is active, update the existing onClick function
		if (this.isActive()) {
			$("#" + buttonId).unbind("click").click(function () {
				if (clickFunc) {
					clickFunc();
				}
				if (button.closeOnClick()) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			});
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonOnClickFunction: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the text displayed in the footer button with the given buttonId
 * @param {string} buttonId The id of the button to be dithered
 * @param {string} buttonText the text to display in the button
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonText = function (buttonId, buttonText) {
	var button = null;

	//Check the proposed text and make sure it is a string
	if (!(typeof buttonText === "string")) {
		logger.logError("ModalDialog.setFooterButtonText: buttonText param must be a string");
		return this;
	}

	//Check make sure the string is not empty
	if (!buttonText) {
		logger.logError("ModalDialog.setFooterButtonText: buttonText param must not be empty or null");
		return this;
	}

	//Get the modal button
	button = this.getFooterButton(buttonId);
	if (button) {
		//Set the onclick function of the button
		button.setText(buttonText);
		//If the modal dialog is active, update the existing onClick function
		if (this.isActive()) {
			$("#" + buttonId).html(buttonText);
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonText: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog footer.  This id will be used to interact with the footer of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getFooterElementId()).attr("id", elementId);
		}
		this.m_footer.elementId = elementId;
	}
	return this;
};

/**
 * Sets the label that will appear next to the checkbox in the modal dialog footer
 * @param {string} label A label that will appear next to the corresponding checkbox
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxLabel = function (label) {
	if (typeof label === "string" && label !== "") {
		this.m_footer.checkbox.label = label;
	}
	return this;
};

/**
 * Sets the flag that will determine if the checkbox in the footer of the modal dialog
 * is visible or not.
 * @param {boolean} isEnabled A flag that will determine if the footer checkbox is visible or not.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxEnabled = function (isEnabled) {
	if (typeof isEnabled === "boolean") {
		this.m_footer.checkbox.enabled = isEnabled;
	}
	return this;
};

/**
 * Sets the flag that will determine if the checkbox in the footer of the modal dialog
 * is checked or not checked.
 * @param {boolean} isChecked A flag that will determine the state of the footer checkbox.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxIsChecked = function (isChecked) {
	if (typeof isChecked === "boolean") {
		this.m_footer.checkbox.isChecked = isChecked;
	}
	return this;
};

/**
 * Sets the function that will be called when the footer checkbox is clicked.
 * @param {function} checkboxClickFunction A function that will be called whenever the footer
 * checkbox is clicked
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxClickFunction = function (checkboxClickFunction) {
	if (checkboxClickFunction && (typeof checkboxClickFunction === "function")) {
		//If the user defines the checkbox click function, assume they want it enabled
		this.setFooterCheckboxEnabled(true);
		this.m_footer.checkbox.onClick = checkboxClickFunction;
	}
	return this;
};

/**
 * Sets the flag which determines if the dialog should verify the response from the close function
 * before attempting to close.  If the response is true, the dialog can be closed.  If the response is
 * false the dialog should not be closed.
 * @param {boolean} verifyResponse The flag which will indicate if verification of the close function response
 * is needed
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used.
 */
ModalDialog.prototype.setVerifyCloseFunctionResponse = function (verifyResponse) {
	if (typeof verifyResponse === "boolean") {
		this.m_header.verifyCloseFunctionResponse = verifyResponse;
	}
	return this;
};

/**
 * EventHandler for the click on the icon when it is active. This will call the showModalDialog method
 * which renders the ModalDialog. It can be overwritten by any implementations of ModalDialog.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.activeIconClickEventHandler = function () {
	MP_ModalDialog.showModalDialog(this.getId());
	return this;
};
/**
 * Sets the indicator which determines if the icon to launch the modal dialog is active or not.  When this is
 * set, the icon and its interactions are updated if it is shown on the MPage.
 * @param {boolean} activeInd An indicator which determines if the modal dialog icon is active or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsIconActive = function (activeInd) {
	var modal = this;

	if (typeof activeInd === "boolean") {
		this.m_icon.isActive = activeInd;
		//Update the icon click event based on the indicator
		//Get the icon container and remove all events if there are any
		var iconElement = $("#" + this.getIconElementId());
		if (iconElement) {
			iconElement.unbind("click");
			iconElement.removeClass("vwp-util-icon");
			if (activeInd) {
				//Add the click event
				iconElement.click(function () {
					modal.activeIconClickEventHandler();
				});
				iconElement.addClass("vwp-util-icon");
			}
		}
	}
	return this;
};

/**
 * Sets the flag which determines if the modal dialog will have a gray backgound when rendered.  This property
 * will not update dynamically.
 * @param {boolean} hasGrayBackground The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHasGrayBackground = function (hasGrayBackground) {
	if (typeof hasGrayBackground === "boolean") {
		this.m_hasGrayBackground = hasGrayBackground;
	}
	return this;
};

/**
 * Sets the function to be called upon the user choosing to close the dialog via the exit button instead of one of the available buttons.
 * @param {function} closeFunc The function to call when the user closes the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderCloseFunction = function (closeFunc) {
	var modal = this;
	//Check the proposed function and make sure it is a function
	if (!(typeof closeFunc === "function") && closeFunc !== null) {
		logger.logError("ModalDialog.setHeaderCloseFunction: closeFunc param must be a function or null");
		return this;
	}

	//Update close function since it is valid
	this.m_header.closeFunction = closeFunc;

	//Update the header close function if the modal is active
	if (this.isActive()) {
		//Get the close element
		$(".dyn-modal-hdr-close").click(function () {
			var closeFunctionResponse = true;
			if (closeFunc) {
				closeFunctionResponse = closeFunc();
			}

			//Determine if we should close the modal or not
			if (modal.verifyCloseFunctionResponse()) {
				//Since we need to verify the close function response only close the modal when
				//the close function returned a truthy value or no close function is executed
				if (closeFunctionResponse) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			}
			else {
				MP_ModalDialog.closeModalDialog(modal.getId());
			}
		});
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog header.  This id will be used to interact with the header of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getHeaderElementId()).attr("id", elementId);
		}
		this.m_header.elementId = elementId;
	}
	return this;
};

/**
 * Sets the title to be displayed in the modal dialog header.
 * @param {string} headerTitle The string to be used in the modal dialog header as the title
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderTitle = function (headerTitle) {
	if (headerTitle && typeof headerTitle === "string") {
		//Update the existing header title if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getHeaderElementId() + " .dyn-modal-hdr-title").html(headerTitle);
		}
		this.m_header.title = headerTitle;
	}
	return this;
};

/**
 * Sets the css class to be used to display the modal dialog launch icon.  This class should contain a background and proper sizing
 * as to diaply the entire icon.
 * @param {string} iconClass The css class to be applied to the html element the user will use to launch the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconClass = function (iconClass) {
	if (iconClass && typeof iconClass === "string") {
		//Update the existing icon class
		$("#" + this.getIconElementId()).removeClass(this.m_icon.cssClass).addClass(iconClass);
		this.m_icon.cssClass = iconClass;
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog icon.  This id will be used to interact with the icon of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		$("#" + this.getIconElementId()).attr("id", elementId);
		this.m_icon.elementId = elementId;
	}
	return this;
};

/**
 * Sets the text which will be displayed to the user when hovering over the modal dialog icon.
 * @param {string} iconHoverText The text to display in the icon hover
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconHoverText = function (iconHoverText) {
	if (iconHoverText !== null && typeof iconHoverText === "string") {
		this.m_icon.hoverText = iconHoverText;
		//Update the icon hover text
		$("#" + this.getIconElementId()).attr("title", iconHoverText);
	}
	return this;
};

/**
 * Sets the text to be displayed next to the modal dialog icon.
 * @param {string} iconText The text to display next to the modal dialog icon.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconText = function (iconText) {
	if (iconText !== null && typeof iconText === "string") {
		this.m_icon.text = iconText;
		//Update the icon text
		$("#" + this.getIconElementId()).html(iconText);
	}
	return this;
};

/**
 * Sets the id which will be used to identify a particular ModalDialog object.
 * @param {string} id The id that will be assigned to this ModalDialog object
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setId = function (id) {
	if (id && typeof id === "string") {
		this.m_modalId = id;
	}
	return this;
};

/**
 * Sets the flag which identifies the modal dialog as being active or not
 * @param {boolean} activeInd A boolean that can be used to determine if the modal is active or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsActive = function (activeInd) {
	if (typeof activeInd === "boolean") {
		this.m_isModalActive = activeInd;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog body is a fixed height or not.
 * @param {boolean} bodyFixed A boolean that can be used to determine if the modal dialog has a fixed size body or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsBodySizeFixed = function (bodyFixed) {
	if (typeof bodyFixed === "boolean") {
		this.m_body.isBodySizeFixed = bodyFixed;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog is fixed to the icon or not.  If this flag is set
 * the modal dialog will be displayed as an extension of the icon used to launch the dialog, much like a popup window.
 * In this case the Top and Right margins are ignored and the location of the icon will determine those margins.  If this
 * flag is set to false the modal dialog window will be displayed according to all of the margin settings.
 * @param {boolean} fixedToIcon A boolean that can be used to determine if the modal is fixed to the launch icon or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsFixedToIcon = function (fixedToIcon) {
	if (typeof fixedToIcon === "boolean") {
		this.m_isFixedToIcon = fixedToIcon;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog footer is always shown or not
 * @param {boolean} footerAlwaysShown A boolean used to determine if the modal dialog footer is always shown or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsFooterAlwaysShown = function (footerAlwaysShown) {
	if (typeof footerAlwaysShown === "boolean") {
		this.m_footer.isAlwaysShown = footerAlwaysShown;
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the left margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the left margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setLeftMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.left = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the right margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the right margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setRightMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.right = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog close icon is shown or not
 * @param {boolean} showCloseIcon A boolean used to determine if the modal dialog close icon is shown or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setShowCloseIcon = function (showCloseIcon) {
	if (typeof showCloseIcon === "boolean") {
		this.m_showCloseIcon = showCloseIcon;
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the top margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the top margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setTopMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.top = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};
/**
 * Sets the text to be displayed in the footer of the modal dialog.
 * @param {string} footerText The text to display in the footer of the modal dialog.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterText = function (footerText) {
	if (typeof footerText === "string" && footerText !== "") {
		this.m_footer.footerText.text = footerText;
		if (this.isActive()) {
			//Update the footer text if the dialog is active
			$("#" + this.getFooterTextElementId()).html(footerText);
		}
	}
	return this;
};
var CPEventManager = ( function() {

		var observers = {};
		var nodeBehaviors = {};
		var behaviorNodes = {};
		var self = this;

		function getBehaviorNodes() {
			return behaviorNodes;
		}

		// Initialize a new behavior for a new pathway or a new node in cache
		function initializeBehavior(pathwayId, nodeId) {
			// Update node behaviors
			if (!nodeBehaviors[pathwayId]) {
				nodeBehaviors[pathwayId] = {};
			}
			if (!nodeBehaviors[pathwayId][nodeId]) {
				nodeBehaviors[pathwayId][nodeId] = {};
			}
		}

		// Retrieve the behaviors for a specific node and pass the list to a callback method
		// If this a new behavior not in cache, call the CP_GET_NODE_BHVR script, add the reaction list to cache
		// For an existing behavior in cache, perform callBack with the reaction list as parameter
		function getNodeBehaviors(nodeData, callBack) {
			var pathwayId = nodeData.PATHWAY_ID, nodeId = nodeData.NODE_ID, responseIdent = nodeData.RESPONSE_IDENT;
			// no existing behavior for the pathway or the node
			if (!nodeBehaviors[pathwayId] || !nodeBehaviors[pathwayId][nodeId]) {
				// initialize behavior for the given pathway and node
				initializeBehavior(pathwayId, nodeId);
				// perform a script request the behavior data
				var sendAr = [];

				var scriptRequest = new ScriptRequest();
				scriptRequest.setProgramName("CP_GET_NODE_BHVR");
				scriptRequest.setParameterArray(["^MINE^", pathwayId + ".0", "value(" + nodeId + ".0)"]);
				scriptRequest.setResponseHandler(function(scriptReply) {
					// add the reaction list to cache
					nodeBehaviors[pathwayId][nodeId] = buildBehaviorCollection(scriptReply.m_responseData.QUAL);

					(function() {
						if (!behaviorNodes.hasOwnProperty(pathwayId)) {
							behaviorNodes[pathwayId] = {};
						}

						behaviorNodes[pathwayId][nodeId] = {};

						var behaviors = nodeBehaviors[pathwayId][nodeId];
						var nodes = behaviorNodes[pathwayId][nodeId];
						var x, y, z;

						for (x in behaviors) {
							for ( y = 0, z = behaviors[x].length; y < z; y++) {
								if (!nodes.hasOwnProperty(behaviors[x][y].REACTION_ENTITY_ID)) {
									nodes[behaviors[x][y].REACTION_ENTITY_ID] = [];
								}

								nodes[behaviors[x][y].REACTION_ENTITY_ID].push({
									"REACTION_ENTITY_NAME" : behaviors[x][y].REACTION_ENTITY_NAME,
									"RESPONSE_IDENT" : behaviors[x][y].RESPONSE_IDENT
								});
							}
						}
					})();

					// callback
					callBack(nodeBehaviors[pathwayId][nodeId][responseIdent]);
				});
				scriptRequest.performRequest();
			}
			else {
				callBack(nodeBehaviors[pathwayId][nodeId][responseIdent]);
			}
		}

		//Add a new reaction to stratified collection by type
		//Return the modified collection
		function addBehaviorToCollection(behaviorCollection, currentBehavior) {
			var responseIdent = currentBehavior.RESPONSE_IDENT;
			if (!behaviorCollection[responseIdent]) {
				behaviorCollection[responseIdent] = [];
			}
			// push the behavior into collection
			behaviorCollection[responseIdent].push(currentBehavior);
			return (behaviorCollection)
		}

		// Builds the behavior collection classified by type from the reaction list defined for a behavior
		// Return the collection
		function buildBehaviorCollection(behaviorList) {
			var behaviorCollection = {};
			if (behaviorList) {
				for (var behaviorLength = behaviorList.length; behaviorLength--; ) {
					var currentBehavior = behaviorList[behaviorLength];
					behaviorCollection = addBehaviorToCollection(behaviorCollection, currentBehavior);
				}
			}
			return (behaviorCollection);
		}

		//Add a new reaction to stratified collection by type
		//Return the modified collection
		function addReactionToCollection(type, reactionsCollection, currentReaction) {
			if (!reactionsCollection[type]) {
				reactionsCollection[type] = [];
			}

			var newReaction = {};
			newReaction.PARENT_ENTITY_ID = currentReaction.REACTION_ENTITY_ID;
			newReaction.PARENT_ENTITY_NAME = currentReaction.REACTION_ENTITY_NAME;
			newReaction.ACTION_TYPE_MEAN = currentReaction.REACTION_TYPE_MEAN || "SUGGEST";
			newReaction.RESPONSE_IDENT = currentReaction.RESPONSE_IDENT;

			reactionsCollection[type].push(newReaction);

			return (reactionsCollection);
		}

		// Builds the reaction collection classified by type from the reaction list defined for a behavior
		// Return the collection
		function buildReactionsCollection(reactionList) {
			var reactionsCollection = {};
			if (reactionList) {
				for (var reactionLength = reactionList.length; reactionLength--; ) {
					var currentReaction = reactionList[reactionLength];

					if (!reactionsCollection.hasOwnProperty("CP_NODE_ID")) {
						reactionsCollection.CP_NODE_ID = currentReaction.CP_NODE_ID;
					}

					switch(currentReaction.REACTION_ENTITY_NAME) {
						case "ORDER_CATALOG_SYNONYM":
						case "ALT_SEL_CAT":
							reactionsCollection = addReactionToCollection("ORDER", reactionsCollection, currentReaction);
							break;
						case "CP_NODE":
							reactionsCollection = addReactionToCollection("NODE", reactionsCollection, currentReaction);
							break;
						case "REGIMEN_CATALOG" :
							reactionsCollection = addReactionToCollection("REGIMEN", reactionsCollection, currentReaction);
							break;
						case "PATHWAY_CATALOG" :
							reactionsCollection = addReactionToCollection("PATHWAY", reactionsCollection, currentReaction);
							break;
						case "ORDER_SENTENCE" :
							reactionsCollection = addReactionToCollection("SENTENCE", reactionsCollection, currentReaction);
							break;
					}
				}
			}
			return (reactionsCollection);
		}

		// Fires the appropriate event for each type defined in the reaction collection
		function fireReactionEvents(reactionsCollection) {
            var types = ["ORDER", "NODE", "REGIMEN", "PATHWAY", "SENTENCE"];
        
            var plansReactions = [];
        
            for (x in types) {
                if (reactionsCollection.hasOwnProperty(types[x])) {
                    // for powerplan reactions -> build them into a list
                    if (types[x] === "PATHWAY") {
                        plansReactions = plansReactions.concat(reactionsCollection[types[x]]);
                    }
                    // else fire notification for each reaction
                    else {
                        notifyObservers("CP_NODE_BEHAVIOR_REACTION", {
                            "CP_NODE_ID" : reactionsCollection.CP_NODE_ID,
                            "TYPE" : types[x],
                            "DATA" : reactionsCollection[types[x]]
                        });
                    }
                }
            }
            // add any powerplans reaction -> fire a special powerplan reaction event
            if (plansReactions.length > 0) {
                notifyObservers("CP_NODE_BEHAVIOR_REACTION_PLANS", {
                    "CP_NODE_ID" : reactionsCollection.CP_NODE_ID,
                    "PLANS_TO_SUGGEST" : plansReactions
                });
            }
        
            /*if (reactionsCollection.ORDER) {
            notifyObservers("CP_NODE_BEHAVIOR_ORDER", reactionsCollection.ORDER);
            }
            if (reactionsCollection.NODE) {
            notifyObservers("CP_NODE_BEHAVIOR_NODE", reactionsCollection.NODE);
            }*/
        }


		// Master method which will accept the reaction List for a behavior, classify the reactions and fire events out to other components
		function handleNodeBehaviorReactions(reactionList) {
			var reactionsCollection = buildReactionsCollection(reactionList);
			fireReactionEvents(reactionsCollection);
		}

		// Master method to handle event activity on the node, this will retrieve the reactions to initiate the process
		function handleNodeBehavior(eventData) {
			getNodeBehaviors(eventData, CPEventManager.handleNodeBehaviorReactions);
		}

		function addObserver(eventName, fn) {
			if (!observers[eventName]) {
				observers[eventName] = [];
			}
			observers[eventName].push(fn);
		}

		function notifyObservers(eventName, eventData) {
			var x, y;
			if (observers[eventName]) {
				for ( x = 0, y = observers[eventName].length; x < y; x++) {
					observers[eventName][x](eventData);
				}
			}
		}

		// Listen to the Node Behavior event
		addObserver("CP_NODE_BEHAVIOR", handleNodeBehavior);

		//Methods returned for tests
		return ( {
			"getBehaviorNodes" : getBehaviorNodes,
			"handleNodeBehavior" : handleNodeBehavior,
			"handleNodeBehaviorReactions" : handleNodeBehaviorReactions,
			"buildBehaviorCollection" : buildBehaviorCollection,
			"buildReactionsCollection" : buildReactionsCollection,
			"getNodeBehaviors" : getNodeBehaviors,
			"addObserver" : addObserver,
			"notifyObservers" : notifyObservers
		});
	}());

var MPageControls = MPageControls || {};
MPageObjectOriented = {};

MPageObjectOriented.inherits = function (clazz, parent) {
	// instance methods
	$.each(parent.prototype, function(k, m) {
		clazz.prototype[k] = m;
	});
	
	// static methods
	$.each(parent, function(k, m) {
	   clazz[k] = m; 
	});
};

MPageObjectOriented.createAttribute = function(clazz, name) {
	clazz.prototype["set" + name] = function(value) {
		this["m_"+name] = value;
	};

	clazz.prototype["get" + name] = function() {
		return this["m_" + name];
	};
};

/**
 * Returns a string with the ID of the element. Element can be an ID string,
 * a jquery object, or a plain DOM element. Either way, the ID will be
 * automatically detected. If it can't detect, then an exception will
 * be thrown.
 *  
 * @param {Object} element 
 */
MPageControls.getId = function(element) {
	if (element instanceof String || typeof element === "string") {
		return element;
	}
	
	// note that null != undefined. We only want to return
	// an empty string when the client has explicitly informed
	// that it is a null variable.
	if (element === null) {
		return "";
	}
	
	var id = undefined;
	if (element instanceof jQuery) {
		 id = element.attr("id");
	}
	
	if (element && element.getAttribute) {
		id = element.getAttribute("id");
	}
	
	if (!id) {
		throw new Error("You have tried to pass an object to MPageControls.getId that does not have a valid ID attribute.");
	}
	
	return id;
};

MPageControls.getDefaultTemplates = function() {
	return new TemplateEngine.TemplateFactory(MPageControls.defaultTemplates());
};

MPageControls.fromId = function(idStr) {
	var el = $("#" + idStr);
	return el.length === 0 ? null : el;
};

MPageControls.setMaxHeight = function(maxHeight) {
	this.m_maxHeight = maxHeight;
};

MPageControls.getMaxHeight = function() {
	return this.m_maxHeight;
};
/**
 * control.js
 * @author Leonardo Sa
 *
 * Control class
 * ============================================================================
 *
 * Serves as a base class for all other controls. It automatically assigns the
 * "element" constructor argument to its element attribute. It will also
 * automatically call the init method, that is meant to be overriden by child
 * classes.
 */

(function() {
    // ------------------------------------------------------------------------
    // Imports
    // ------------------------------------------------------------------------
	var ns = MPageControls;
    var attribute = MPageObjectOriented.createAttribute;

    // ------------------------------------------------------------------------
    // Class Declaration
    // ------------------------------------------------------------------------
	ns.Control = function(element) {

	    this.setControlId(ns.Control.idCounter);
	    ns.Control.idCounter++;

        if (element) {
            this.setElement(element);
            this.init();
        } else {
            this.setElement(ns.Control.ID_PREFIX + this.getControlId());
        }
	};
	
	ns.Control.idCounter = 0;
    ns.Control.ID_PREFIX = "mpage_controls_control_";
	
	// ------------------------------------------------------------------------
    // Attributes
    // ------------------------------------------------------------------------
	
	/**
	 * A unique ID that identifies this control 
	 */
	attribute(ns.Control, "ControlId");

	/**
	 * Some controls can be nested in a parent/child relationship
	 */
	 attribute(ns.Control, "Parent");
	
	// ------------------------------------------------------------------------
    // Member Methods
    // ------------------------------------------------------------------------
	
	/**
	 * Executed right after the control is created. Can be overriden by child
	 * classes. The purpose of a separate init method is to allow the user
	 * to rebuild the control from the ground up without having to call
	 * its constructor, removing the need to copy all properties.
	 */
	ns.Control.prototype.init = function() {

	};
	
	ns.Control.prototype.setElement = function(element) {
	    this.m_element = MPageControls.getId(element);
	};
	
	ns.Control.prototype.getElement = function() {
	    return MPageControls.fromId(this.m_element);
	};
	
	ns.Control.prototype.setContents = function(contents) {
	    this.m_contents = MPageControls.getId(contents);
	};
	
	ns.Control.prototype.getContents = function() { 
	    return MPageControls.fromId(this.m_contents);
	};

    ns.Control.prototype.getElementId = function() {
        return this.m_element;
    };

    /**
     * Renders a template function into the current element.
     *
     * Executes a function as specified by the template argument, passing the context
     * as an argument, and sets the innerHTML of the current element to the result
     * of the function execution. A "control_[id]" string will be set to the controlId
     * property of the context if it has not been set yet.
     *
     * @param template
     * @param context
     */
    ns.Control.prototype.renderTemplate = function(template, context) {
        if (!context) {
            context = {};
        }

        if (!context.controlId) {
            context.controlId = this.getControlId();
        }

        var html = template(context);
        this.getElement().html(html);
    };

	// ________________________________________________________________________

	/**
	 * Calls the function as specified by eventName in the parent,
	 * passing the arguments.
	 */
	ns.Control.prototype.fire = function(eventName, args) {
	    var parent = this.getParent();
	    if (!parent) { return; }
        if (!(parent[eventName])) { return; }
        if(args != undefined || args != null){
        	parent[eventName].apply(parent, args);
        }else{
        	parent[eventName].apply(parent, []);
        }        
	};

	// ________________________________________________________________________
	
	/**
	 * Binds an event to a jQuery element. This is similar to jQuery's bind,
	 * except that here we keep track of the binded events in the control so
	 * we can destroy them later if needed. 
     * @param {Object} eventName
     * @param {Object} element
     * @param {Object} handler
	 */
	ns.Control.prototype.bind = function(eventName, element, handler) {
	    element.bind(eventName + ".control" + this.getControlId(), handler);
	};
	
	// ________________________________________________________________________
	
	/**
	 * Destroys all the events associated with the current control 
	 */
	ns.Control.prototype.destroyEvents = function() {
	    if (this.getElement()) {
	       this.getElement().unbind(".control" + this.getControlId());
	    }
	};
	
	// ________________________________________________________________________
	
	ns.Control.prototype.focus = function() {
	   this.getElement().focus();    
	};

    // ________________________________________________________________________

    ns.Control.prototype.trigger = function (eventName, args) {
      if (this[eventName]) {
          if (!args) { args = []; }
          return this[eventName].apply(this, args);
      }
    };

})();
MPageControls.defaultTemplates = function() {
	var te = TemplateEngine;
	var div = te.tag("div");
	var input = te.tag("input");
	var span = te.tag("span");

	return {
		
		// --------------------------------------------------------------------
		// List
		// --------------------------------------------------------------------
		
		list: function(context) {
			return div({"class": "list", "tabindex":"0", "id": context.listId}, context.items);
		},
		
		listItem: function(context) {
			return div({"class": "list-item", "id": context._elementId}, context.content);
		},

		// --------------------------------------------------------------------
		// Drop Down List
		// --------------------------------------------------------------------

		ddListItem: function(context) {
			return div({"class": "list-item", "id": context._elementId}, context[context.displayKey]);
		},
		
		// --------------------------------------------------------------------
		// AutoSuggent
		// --------------------------------------------------------------------
		
		autoSuggest: function(context) {
			return div({"class":"auto-suggest input"},
				div({"id": context.closebtnId,"class":"close-btn"}, "&nbsp;"),
				div({"class":"auto-suggest-input-wrapper"},
					input({"type":"text", "class":"search-box", "id": context.textboxId})
				)
			);
		},
		
		autoSuggestList: function(context) {
			return div({
				"class":"auto-suggest suggestions", 
				"style":"position: relative", 
				"tabindex":"0", 
				"id": context.listId}, context.items);
		},

		emptyList: function() {
			return div({
				"class":"auto-suggest suggestions res-none",
				"style":"position: relative",
				"tabindex":"0"}, i18n.NO_RESULTS_FOUND);
		},

		// --------------------------------------------------------------------
		// ScriptSearch
		// --------------------------------------------------------------------
		cclSearch: function(context) {
			return div({"class":"auto-suggest"},
				div({"class":"auto-suggest-search-box"},
					input({"type":"text", "id": context.textboxId})
				),
				div({"class":"clear-search", "id": context.closebtnId},
					span({"class":"clear-button", "style": "display: inline-block"})
				)
			);
		},

		personnelSearchItem: function(context) {
			return div({"id": context._elementId},
				context.NAME_FULL_FORMATTED
			);
		},

		providerSuggestList: function(context) {
			var divDetails = {
				"class":"auto-suggest suggestions",
				"style":"position: relative;",
				"tabindex":"0",
				"id": context.listId
			};

			var maxHeight = MPageControls.getMaxHeight();

			if(maxHeight) {
				divDetails.style = "position: relative; max-height: " + maxHeight + "px;";
			}

			return div(
				divDetails,
				context.items,
				div({"id":"newProviderAssignment"}, i18n.ASSIGN_NEW_PROVIDER)
			);
		},

		// --------------------------------------------------------------------
		// OrderSearch
		// --------------------------------------------------------------------

		orderSearch: function(context) {
			return div({"class":"auto-suggest"},
				div({"class":"order-search-box"},
					input({"type":"text", "class":"search-box noe2-search", "id": context.textboxId})
				),
				div({"class":"clear-search", "id": context.closebtnId}, 
					span({"class":"clear-button", "style": "display: inline-block"})
				)
			); 
		},
		
		orderSearchItem: function(context) {
			return div({"id": context._elementId},
				span({"class":context.iconClass}, "&nbsp;"), 
				context.content,
				span({"class":"order-sentence"}, context.SENTENCE)
			);
		},
		
		// --------------------------------------------------------------------
		// NomenclatureSearch
		// --------------------------------------------------------------------
		nomenSearchItem: function(context){
			return div({"id": context._elementId}, context.m_Data.SOURCESTRING);
		},
		
		// --------------------------------------------------------------------
		// Message
		// --------------------------------------------------------------------
		messageBar : function(context){
			return  div({"class": context.msgDivClass},
				span("&nbsp;"), 
				context.message,
				span({"class":'close-btn hidden','id':context.closeBtnId},"&nbsp;"));
		},
		
		// --------------------------------------------------------------------
		// Venue dropdown
		// --------------------------------------------------------------------
		venueTemplate : function(context) {
			return div({
				"id" : context._elementId
			}, div({
				"class" : 'venue-item'
			}, context.VENUE_DISPLAY));

		}

	};
};
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A control that represents alert message, which can be added to any 
	 * summary or workflow component. 
	 */
	ns.AlertMessage = function(element, messageTemplate, messageType) {
		this.setTemplate(messageTemplate);
		this.setCssClass(messageType);
		this.setIsClosable(false);		
		ns.Control.call(this, element);
	};
	
	inherits(ns.AlertMessage, ns.Control);
	/**
	 *The MessageTypes object will map the type of message with the css class. 
	 */
	ns.AlertMessage.MessageTypes = {
			WARNING : "msg-warning",
			INFORMATION : "msg-info",
			ERROR: "msg-error"
	};
	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * A string-template that will be used when rendering the Message bar.
	 */
	attribute(ns.AlertMessage, "Template");

	/**
	 *Css class for the message div. 
	 */
	attribute(ns.AlertMessage, "CssClass");
	
	/**
	 *Flag to allow closing of the alert message 
	 */
	attribute(ns.AlertMessage, "IsClosable");
	
	
	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	
	var prot = ns.AlertMessage.prototype;
	
	// ________________________________________________________________________
	
	prot.getCloseBtnId = function() {
		return "control_" + this.getControlId() + "_closebtn";
	};
	/**
	 * Appends the html markup created by the template to the target element.
	 */
	prot.render = function(message) {
		var context = {
			"msgDivClass":this.getCssClass(),
			"message": message,
			"closeBtnId":this.getCloseBtnId()
		};
		var self = this;
		this.getElement().html(this.getTemplate().render(context));
		if(this.getIsClosable()){
			$("#"+this.getCloseBtnId()).removeClass("hidden");
			$("#"+this.getCloseBtnId()).click(function(){
				self.close();
			});	
		}
	};
	prot.close = function(){
		$(this.getElement()).hide();
	};	
})(jQuery);
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.AutoSuggest = function(element) {
		this.setCaptionClass("caption");
		this.setTemplate(MPageControls.getDefaultTemplates().autoSuggest);
		this.setCaption("");
		this.setAutoHideCloseButton(true);
		this.setDelay(50);
		this.setDetailDialog(null);
		this.setHighlightEnabled(true);
		this.setSynchSuggestionsWidth(true);
		this.setBackgroundClass("search-box-image");
		this.mBlurEnabled = true;

		this.setOnChange(function() {
		});
		this.setOnClose(function() {
		});
		this.setOnEnter(function() {
		});
		this.setOnDelay(function() {
		});
		this.setRequestItemValueCallback(function(item) {
			return item.content;
		});

		ns.Control.call(this, element);
	};

	inherits(ns.AutoSuggest, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The list control responsible for displaying the suggestions
	 */
	attribute(ns.AutoSuggest, "List");

	/**
	 * Class that will be applied to the textbox when it has a caption
	 */
	attribute(ns.AutoSuggest, "CaptionClass");

	/**
	 * The DetailDialog where the List of suggestions will reside
	 */
	attribute(ns.AutoSuggest, "DetailDialog");

	/**
	 * Delay, in ms, that the control waits until it starts processing keys
	 */
	attribute(ns.AutoSuggest, "Delay");

	/**
	 * Template used to render the textbox and the close button - can be
	 * completely customized by the client.
	 */
	attribute(ns.AutoSuggest, "Template");

	/**
	 * A text to be displayed inside the textbox when it is empty and
	 * out of focus. This text will be erased once it receives focus.
	 * If the caption is not set, then the caption class will not be
	 * added.
	 */
	attribute(ns.AutoSuggest, "Caption");

	/**
	 * Callback to be executed when the textbox value is changed.
	 * The delay attribute has no effect here.
	 */
	attribute(ns.AutoSuggest, "OnChange");

	/**
	 * Callback to be executed when the suggestions drop down
	 * is closed.
	 */
	attribute(ns.AutoSuggest, "OnClose");

	/**
	 * Callback to be executed after the delay timer has expired.
	 * Here is where you will add logic to call setSuggestions()
	 * in order to show suggestions.
	 */
	attribute(ns.AutoSuggest, "OnDelay");

	/**
	 * Callback to be executed when the user presses "enter"
	 * while in the textbox.
	 */
	attribute(ns.AutoSuggest, "OnEnter");

	/**
	 * Holds the delay timer. If cleared, the timer will not fire.
	 */
	attribute(ns.AutoSuggest, "Timer");

	/**
	 * Callback to be executed whenever the control needs a textual
	 * value from an item object. This essentially needs to convert
	 * an Item object into a string.
	 */
	attribute(ns.AutoSuggest, "RequestItemValueCallback");

	/**
	 * Whether the suggestions will be highlighted with the text
	 * typed into the textbox or not.
	 *
	 * For custom highlighting logic, set this to false and manually
	 * instantiate the TextHighlighter class after calling renderItems
	 * in your script.
	 */
	attribute(ns.AutoSuggest, "HighlightEnabled");
	
	/**
	 * Whether the suggestion drop down will be resized to be the same
	 * width as the search text box 
	 */
	attribute(ns.AutoSuggest, "SynchSuggestionsWidth");
	
	/**
	 * If set to true, hides the close button if there are no suggestions
	 * opened. 
	 */
	attribute(ns.AutoSuggest, "AutoHideCloseButton");
	
	/**
	 * Will be automatically set to whatever value "items" is on
	 * "setSuggestions". This is useful to retrieve JSON data set by
	 * controls that abstract the setSuggestions method.
	 */
	attribute(ns.AutoSuggest, "Items");
	
	/**
	 * Class that will be applied to the textbox when search icon has to be set.
	 * This attribute will help maintain passivity.
	 */
	attribute(ns.AutoSuggest,"BackgroundClass");

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.AutoSuggest.prototype;

	/**
	 * Renders the template and attaches events to the textbox. The template
	 * must provide a textbox with getTextboxId() as its ID. The variable
	 * "textboxId" will be passed through the context.
	 */
	prot.init = function() {
		var self = this;
		var txtBox = null;

		// --------------------------------------------------------------------
		// Render template
		// --------------------------------------------------------------------
		this.getElement().empty();
		this.getElement().append(this.getTemplate().render({
			"textboxId": this.getTextboxId(),
			"closebtnId": this.getClosebtnId()
		}));
		txtBox = this.getTextbox();
		this.activateCaption();
		this.createDialog();
		this.setListTemplate(MPageControls.getDefaultTemplates().autoSuggestList);
		
		// --------------------------------------------------------------------
		// Textbox events
		// --------------------------------------------------------------------
		txtBox.click(function() {
			self.deactivateCaption();
		});

		txtBox.blur(function() {
			if (self.getValue().length === 0) {
				self.activateCaption();
			}
			
			// Gives a little time to process list click events
			setTimeout(function() {
				var suggestionsContainer = $("#control_" + self.getControlId() + "_content .suggestions");
				//close only if the autosuggest content is not in focus
				if (!suggestionsContainer.is(":focus")) {
					self.close();
				}
			}, 300);
		});

		txtBox.keyup(function(e) {
			self.processTextboxKeyDown(e);
		});

		// ------------------------------------------------------------------------
		// Attach event to the close button
		// ------------------------------------------------------------------------
		$("#" + this.getClosebtnId()).click(function() {
			self.close();
			self.getTextbox()[0].value = "";
			self.activateCaption();
		});
		
		// hide the close button, if necessary
        if (this.getAutoHideCloseButton()) {
           this.hideCloseButton();
        }

	};

	// ________________________________________________________________________

	/**
	 * Handles key presses in the textbox
	 */
	prot.processTextboxKeyDown = function(e) {
		var self = this;
		var dialog = this.getDetailDialog();
		
		// Cleans the timer, if it exists
		if (self.getTimer()) {
			clearTimeout(self.getTimer());
		}

		// Disables the caption if it was enabled
		if (this.getTextbox().hasClass(this.getCaptionClass())) {
			this.getTextbox().removeClass(this.getCaptionClass());
		}
		
		// hides the close button and results if the text is empty. Displays it otherwise
        if (this.getValue().length === 0) {
           this.hideCloseButton();
           if (dialog && dialog.getVisible()) {
        	   this.close();
           }
           return;
        } else {
           $("#" + this.getClosebtnId()).css("display","inline-block"); 
        }
		
		// The "enter" key will close the dialog, if any, and execute the
		// "onEnter" event. It will stop all other processing. Unless there
		// is an item selected in the dropdown. In that case, it will execute
		// the list's onEnter
		if (e.keyCode == 13) {
			
			if (dialog && 
					dialog.getVisible() &&
					this.getList().getSelectedIndex() >= 0) {
				this.getList().getOnEnter()();
				this.close();
				return;
			}
			
			this.close();
			this.getOnEnter()();
			return;
		}

		// binds key events to the list, so we can use the arrows to move
		// between suggestions.
		if (self.getList()) {
			self.getList().processKeyEvent(e);
		}

		// we wont process these keycodes:
		// up arrow, down arrow
		var dontProcess = [38, 40];
		if ($.inArray(e.keyCode, dontProcess) != -1) {
			this.moveCaretToEnd();
			return;
		}
		
		// fires the on change event
		this.getOnChange()();
		
		// ----------------------------------------------------------------
		// Triggers the OnDelay event after waiting "Delay" milliseconds
		// ----------------------------------------------------------------
		var t = setTimeout(function() {
			self.getOnDelay()();

			// we check textbox here because the user can delete the textbox in
			// the delay callback
			if (self.getValue() && self.getValue().length === 0) {
				self.close();
			}
		}, self.getDelay());

		self.setTimer(t);
	};

	// ________________________________________________________________________

	/**
	 * Displays the caption text in the textbox
	 */
	prot.activateCaption = function() {
		if (this.getCaption().length === 0) {
			return;
		}

		this.getTextbox().addClass(this.getCaptionClass());
		this.getTextbox()[0].value = this.getCaption();
		
		// hide the close button
        if (this.getAutoHideCloseButton()) {
            this.hideCloseButton();
        }
	};
	
	// ________________________________________________________________________
	
	/**
	 * Moves the caret position of the textbox to the last character
	 */
	prot.moveCaretToEnd = function() {
		var txtbox = this.getTextbox().get(0);
		var pos = this.getValue().length;
		
		if (txtbox.setSelectionRange) {
			txtbox.setSelectionRange(pos,pos);
			return;
		}
		
		if (txtbox.createTextRange) {
			var range = txtbox.createTextRange();
			range.moveEnd('character', pos);
			range.moveStart('character', pos);
			range.select();
		}
	};

	// ________________________________________________________________________
	
	/**
	 * Removes the close button from the search box
	 */
	prot.hideCloseButton = function() {
		$("#" + this.getClosebtnId()).css("display","none");
	};

	// ________________________________________________________________________

	/**
	 * Erases the caption text from the textbox and removes the caption class
	 * from it. Will not fire if the class has already been removed.
	 */
	prot.deactivateCaption = function() {
		if (!this.getTextbox().hasClass(this.getCaptionClass())) {
			return;
		}

		this.getTextbox().removeClass(this.getCaptionClass());
		this.getTextbox()[0].value = "";
	};

	// ________________________________________________________________________

	/**
	 * Returns the textbox element
	 */
	prot.getTextbox = function() {
		return this.getElement().find("#" + this.getTextboxId());
	};

	// ________________________________________________________________________

	/**
	 * Returns the generated textbox element id
	 */
	prot.getTextboxId = function() {
		return "control_" + this.getControlId() + "_textbox";
	};

	// ________________________________________________________________________

	prot.getClosebtnId = function() {
		return "control_" + this.getControlId() + "_closebtn";
	};

	// ________________________________________________________________________

	/**
	 * Closes the suggestion drop down
	 */
	prot.close = function() {
		if (this.getDetailDialog()) {
			this.getDetailDialog().hide();
		}
		
		this.mBlurEnabled = true;
	};

	// ________________________________________________________________________

	/**
	 * Sets the items to be displayed as suggestions. These items should be an
	 * array of objects.
	 */
	prot.setSuggestions = function(items) {
		this.setItems(items);
		
		// No items or no text or caption active, hide it
		if (items.length === 0 || this.getValue().length === 0 || this.getTextbox().hasClass(this.getCaptionClass())) {
			this.close();
			return;
		}
		
		// Synchs the listDiv width, if necessary
		if (this.getSynchSuggestionsWidth()) {
		      $("#control_" + this.getControlId() + "_content").css('min-width', this.getElement().width() + "px");
		}

		this.getList().renderItems(items);
		this.getDetailDialog().show();
		this.getDetailDialog().updatePosition();

		// apply highlighting, if enabled
		if (this.getHighlightEnabled()) {
			var hl = new ns.TextHighlighter(this.getList().getElement());
			hl.highlight(this.getValue());
		}

		var self = this;
		var suggestionsContainer = "#control_" + self.getControlId() + "_content .suggestions";
		//make the suggestions container focusable
		$(suggestionsContainer).attr("tabindex", 0);

		$(suggestionsContainer).on("blur", function() { 
			// Gives a little time to process the blur event
			setTimeout(function() {
				//close the autosuggest content if the search textbox is not focused
				if (self.getElement() && !self.getTextbox().is(":focus")) {
					self.close();
				}
			}, 300);
		});
	};

	// ________________________________________________________________________

	/**
	 * Creates the detail dialog that contains the suggestions
	 */
	prot.createDialog = function() {
		var self = this;

		// creates the div that will contain the list
		var listDiv = $("<div></div>");
		listDiv.appendTo(this.getElement().offsetParent());
		listDiv.attr("id", "control_" + this.getControlId() + "_content");

		// creates the detail dialog that contains the list
		// and is attached to the textbox
		var dd = new ns.DetailDialog(this.getElement(), listDiv);
		dd.setElementCorner(["bottom", "left"]);
		dd.setAlwaysOnTop(true);
		
		// creates the list
		var list = new ns.List(listDiv);

		// When an item is selected, sets the value of the textbox,
		// fires this component's onEnter and closes the list.
		list.setOnSelect(function(item) {
			self.setValue(self.getRequestItemValueCallback()(item));
			self.getOnEnter()();
			self.close();
		});

		this.setList(list);
		this.setDetailDialog(dd);
	};

	// ________________________________________________________________________

	/**
	 * Returns the value that is currently in the textbox
	 */
	prot.getValue = function() {
		if (!this.getElement() || !this.getTextbox().length ) {
			return null;
		}
		
		return this.getTextbox()[0].value;
	};

	// ________________________________________________________________________

	/**
	 * sets the textbox value
	 * @param {Object} value
	 */
	prot.setValue = function(value) {
		this.getTextbox()[0].value = value;
	};

	// ________________________________________________________________________

	/**
	 * Destroys this control and its children controls
	 */
	prot.destroy = function() {
		if (this.getList()) {
			this.getList().destroy();
		}

		if (this.getDetailDialog()) {
			this.getDetailDialog().destroy();
		}
	};
	
	// ________________________________________________________________________
	
	/**
     * Template used to render each item in the suggestion list
     */
	prot.setListItemTemplate = function(template) {
	    this.getList().setItemTemplate(template);
	};
	
	// ________________________________________________________________________
    
    /**
     * Template used to render the list of suggestions
     */
    prot.setListTemplate = function(template) {
        this.getList().setListTemplate(template);
    };
	
	//_________________________________________________________________________
	
	/**
     * Displays the search icon in the textbox
     */
	prot.activateBackground = function() {
		this.getTextbox().addClass(this.getBackgroundClass());
	};

})(jQuery);
/**
 * detail_dialog.js
 * @author Leonardo Sa
 *
 * DetailDialog class
 * ============================================================================
 *
 * Shows a dialog that is attached to an element. This means that
 * it will show next to that element when the show() method is called, similar
 * to drop down menus, except one can make it drop left, right, or even up
 * by changing the ElementCorner and ContentsCorner attributes.
 *
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var oo = MPageObjectOriented;
	var inherits = oo.inherits;
	var attribute = oo.createAttribute;

	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------

	/**
	 * Instantiates a new detail dialog attached to element, where its contents
	 * will be an element defined by contentsElement.
	 */
	ns.DetailDialog = function(element, contentsElement) {
		var defaultHideFx = function(element) {
			element.slideUp(150);
		};

		var defaultShowFx = function(element) {
		    element.slideDown(150);
		};

		this.setAlwaysOnTop(false);
		this.setElementCorner(["bottom", "left"]);
		this.setContentsCorner(["top", "left"]);
		this.setBeforeShow(function() {
		});
		this.setAutoFlipVertical(true);
		this.setAutoFlipHorizontal(true);
		this.setContents(contentsElement);
		this.setShowEffect(defaultShowFx);
		this.setHideEffect(defaultHideFx);
		this.setVisible(false);
		this.setOnShow(function() {
		});
		this.setOnHide(function() {
		});

		// Calls the parent class constructor
		ns.Control.call(this, element);
	};

	inherits(ns.DetailDialog, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The contents of the dialog. Since we are using an external library
	 * to render the window, those contents will be used only as a base
	 * to create the dialog. To access the dialog HTML, use the pane()
	 * function.
	 */

	/**
	 * A jQuery effect for showing the dialog
	 */
	attribute(ns.DetailDialog, "ShowEffect");

	/**
	 * A jQuery effect for hiding the dialog
	 */
	attribute(ns.DetailDialog, "HideEffect");

	/**
	 * Whether the dialog is visible or not. This is read only - to change
	 * the visibility, use the hide() and show() functions.
	 */
	attribute(ns.DetailDialog, "Visible");

	/**
	 * Function to be executed after the dialog is shown and the
	 * animation is complete
	 */
	attribute(ns.DetailDialog, "OnShow");

	/**
	 * Function to be executed after the dialog is shown and the
	 * animation is complete
	 */
	attribute(ns.DetailDialog, "OnHide");

	/**
	 * Whether the dialog has been created or not. This is read only
	 * and does not signify that a dialog is visible, only that its
	 * HTML elements have been created.
	 */
	attribute(ns.DetailDialog, "Created");

	/**
	 * Defines to which corner of the element the dialog will attach to
	 */
	attribute(ns.DetailDialog, "ElementCorner");

	/**
	 * Defines which corner of the contents will attach to the element
	 */
	attribute(ns.DetailDialog, "ContentsCorner");

	/**
	 * Defines to which corner of the element the dialog will attach to when being flipped
	 */
	attribute(ns.DetailDialog, "ElementFlippedCorner");

	/**
	 * Defines which corner of the contents will attach to the element when being flipped
	 */
	attribute(ns.DetailDialog, "ContentsFlippedCorner");
	
	/**
	 * Event to be executed right before the dialog is shown
	 */
	attribute(ns.DetailDialog, "BeforeShow");

	/**
	 * Whether the dialog will automatically flip up, down or center if it's near
	 * the edge of the page.
	 */
	attribute(ns.DetailDialog, "AutoFlipVertical");
	
	/**
	 * Whether the dialog will automatically flip left or right if it's near
	 * the edge of the page.
	 */
	attribute(ns.DetailDialog, "AutoFlipHorizontal");
	
	/**
	 * When true, sets the z-index of the dialog to 100 to ensure
	 * it will be above everything else.
	 */
	attribute(ns.DetailDialog, "AlwaysOnTop");
	

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.DetailDialog.prototype;

	prot.init = function() {
	};
	
	// ________________________________________________________________________

    /**
     * Defines a jQuery element to be used as a reference for the autoflip.
     * Sometimes this is necessary if you want the detail dialog to flip
     * when it reaches the end of a certain DIV instead of the window. 
     */
    prot.setFlipReference = function(reference) {
        this.m_flipReference = MPageControls.getId(reference);
    };

    prot.getFlipReference = function() {
       return MPageControls.fromId(this.m_flipReference);
    };

	// ________________________________________________________________________

	/**
	 * Hides or shows the dialog every time this method is called
	 */
	prot.toggle = function() {
		if (this.getVisible()) {
			this.hide();
		}
		else {
			this.show();
		}
	};

	// ________________________________________________________________________

	/**
	 * Updates the position of the dialog in relation to its attached element.
	 * The position will vary according to values of getElementCorner and
	 * getContentsCorner, which specify which corners will be used for alignment.
	 */
	prot.updatePosition = function(elementConnection, contentConnection) {

		// --------------------------------------------------------------------
		// Gets the element x and y
		// --------------------------------------------------------------------
		var element = this.getElement();
		var content = this.getContents();
		
		var elx = 0;
		var ely = 0;
		var elpos = element.offset();
		
		//Make sure we have connections defined
		if(!elementConnection){
			elementConnection = this.getElementCorner();
		}
		
		if(!contentConnection){
			contentConnection = this.getContentsCorner();
		}
		
		switch (elementConnection[0]) {
			case "top":
				ely = elpos.top;
				break;
			case "bottom":
				ely = elpos.top + element.outerHeight();
				break;
		}

		switch (elementConnection[1]) {
			case "left":
				elx = elpos.left;
				break;
			case "right":
				elx = elpos.left + element.outerWidth();
				break;
		}

		// --------------------------------------------------------------------
		// Offsets the x and y with the width and height of the contents
		// --------------------------------------------------------------------
		if (contentConnection[0] == "bottom") {
			ely = ely - content.outerHeight();
		}

		if (contentConnection[1] == "right") {
			elx = elx - content.outerWidth();
		}

		// --------------------------------------------------------------------
		// Compensate coordinates to be relative to parent instead of window
		// --------------------------------------------------------------------
		//This is a special case for IE7 when offsetParent returns the HTML tag which has offset of {top: 2, left: 2} even though it should be {top:0. left:0}.
		var parent = content.offsetParent();
		if(parent.length && parent.prop('tagName') === "HTML"){
			parent = $(document.body);
		}
		var x = elx - parent.offset().left;
		var y = 0;
		
		//windowTop is a special condition where the dialog contents will be hidden if flipped to the opposite side
		//so we use the top of the viewable area for the y offset.
		if(contentConnection[0] == "windowTop"){
			y = parent.offset().top;
		}
		else{
			y = ely - parent.offset().top;
		}

		// --------------------------------------------------------------------
		// Updates the contents
		// --------------------------------------------------------------------
		if (this.getAlwaysOnTop()) {
			this.getContents().css("z-index","100");
		}
		this.getContents().css("position", "absolute");
		this.getContents().css({
			left: x,
			top: y
		}).show();
	};

	// ________________________________________________________________________

	/**
	 * Displays the dialog
	 */
	prot.show = function() {
		if (this.getVisible()) {
			return;
		}

        // show it to calculate the position
		var self = this;
		this.beforeShow();
		this.getContents().css("display", "block");
		this.updatePosition(this.getElementCorner(), this.getContentsCorner());
		
		//Save a copy of the current connection corners for use when we attempt to flip the content
		this.setElementFlippedCorner(this.getElementCorner());
		this.setContentsFlippedCorner(this.getContentsCorner());
		this.autoFlipVertical();
		this.autoFlipHorizontal();
		this.m_OnShow(this);
		this.setVisible(true);
	};

	// ________________________________________________________________________

	/**
	 * This function is used for passivity reasons and will call the updated autoFlipVertical function 
	 */
	prot.autoFlipUp = function(){
		this.autoFlipVertical();
	};

	/**
	 * If the AutoFlipVertical is true and the content is close to the bottom of
	 * the viewport, this will move it to the top instead.  If it then does not fit in the top
	 * it will be positioned so that the top of the content is aligned with the top of the screen.
	 * If the contents still do not fit the content will be scrolled and a max-height will be set
	 * on the content element container. 
	 */
	prot.autoFlipVertical = function() {
		var anchorVertical = "";
		//Check to see if we should attempt to auto flip
		if (!this.getAutoFlipVertical()) {
			return;
		}
		
		//Get the bottom edge of the window based on the scrolled position and the window height
		var windowEdge = $(window).scrollTop() + $(window).height();
		var contents = this.getContents();
		// If we have a flip reference, then we will use that as the edge instead of the window element
		if (this.getFlipReference()) {
		  //May need to apply scrollTop() to the filp reference if it is scrolled
		  windowEdge = this.getFlipReference().offset().top + parseInt(this.getFlipReference().outerHeight(), 10);
		}
		var contentHeight = parseInt(contents.outerHeight(), 10);
		var contentTop = contents.offset().top;
		var bottomEdge = contentTop + contentHeight;
		if (bottomEdge >= windowEdge) {
			anchorVertical = (this.getElementFlippedCorner()[1] == this.getContentsFlippedCorner()[1]) ? "top" : "bottom";
			if(contentTop <= contentHeight){
				//Check to see if the dialog is larger than the screen.  If so we will scroll its content.
				if(contentHeight >= windowEdge){
					//Reduce the size of the content container plus some padding
					contents.outerHeight(windowEdge - 10);
					//Expand the menu width to account for the scroll bar
					contents.outerWidth(contents.outerWidth() + 17);
					//Apply scrolling to the container
					contents.css("overflow-y", "auto");
				}
				//Flipping the content up will still hide some of the content so we will align it with the top of the screen
				this.setElementFlippedCorner([anchorVertical, this.getElementFlippedCorner()[1]]);
				this.setContentsFlippedCorner(["windowTop", this.getContentsFlippedCorner()[1]]);
				this.updatePosition(this.getElementFlippedCorner(), this.getContentsFlippedCorner());
			}
			else{
				//Flipping the menu up will let it show all of its contents
				this.setElementFlippedCorner([anchorVertical, this.getElementFlippedCorner()[1]]);
				this.setContentsFlippedCorner(["bottom", this.getContentsFlippedCorner()[1]]);
				this.updatePosition(this.getElementFlippedCorner(), this.getContentsFlippedCorner());
			}
		}
	};

	// ________________________________________________________________________

	
	/**
	 * If the AutoFlipHorizontal is true and the content is close to edge of
	 * the viewport, this will move it to the opposite side.
	 */
	prot.autoFlipHorizontal = function() {
		//Check to see if we should attempt to flip horizontally
		if (!this.getAutoFlipHorizontal()) {
			return;
		}
		
		//Get the viewport edge offsets
		var windowRightEdge = $(window).width();
		var windowLeftEdge = 0;
		var flipReference = this.getFlipReference();
		// if we have a flip reference, then we will use that as the edge instead
		if (flipReference) {
			windowLeftEdge = flipReference.offset().left;
			windowRightEdge = windowLeftEdge + parseInt(flipReference.outerWidth(), 10);
		}
		//Get the dialog edge offsets
		var dialogLeftEdge = this.getContents().offset().left;
		var dialogRightEdge = dialogLeftEdge + parseInt(this.getContents().outerWidth(), 10);
		
		//Flip the dialog if necessary
		if(dialogLeftEdge < windowLeftEdge){
			//Dialog left edge is less than the viewport left edge so we will flip right
			this.updatePosition([this.getElementFlippedCorner()[0], "right"], [this.getContentsFlippedCorner()[0], "left"]);
		}
		else if(dialogRightEdge > windowRightEdge){
			//Dialog right edge is greater than the viewport left edge so we will flip left
			this.updatePosition([this.getElementFlippedCorner()[0], "left"], [this.getContentsFlippedCorner()[0], "right"]);
		}
	};

	// ________________________________________________________________________

	/**
	 * Hides the dialog
	 */
	prot.hide = function() {
		if (!this.getVisible()) {
			return;
		}

		this.getContents().css("display", "none");
		this.setVisible(false);
		this.m_OnHide(this);
	};

	// ________________________________________________________________________

	/**
	 * Executed before showing the dialog. Is a wrapper for the beforeShow
	 * event.
	 */
	prot.beforeShow = function() {
		this.getBeforeShow()(this);
	};

	// ________________________________________________________________________

	/**
	 * Destroys the HTML elements inside the dialog, along with the dialog
	 * itself.
	 */
	prot.destroy = function() {
	    if (this.getContents()) {
		  this.getContents().remove();
		}
		this.setVisible(false);
		this.setCreated(false);
	};
})(jQuery);
/**
 * drop_down.js
 * @author Leonardo Sa
 *
 * DropDown Class
 * ============================================================================
 *
 * Abstract base for other drop down classes. Connects a detail dialog with a selector 
 * in order to form a drop down like control. Also, makes it possible to change 
 * or set a value by calling get/setValue.
 *
 */
(function($) {
	// -----------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDown = function(element, contentsElement, defaultValue) {

        if (element) {
            this.setSelector(new ns.Selector(element, "selected", "unselected"));
        }

		if (contentsElement) {
			this.setContents(contentsElement);
		}
		
		this.setOnShow(function() {
		});
		this.setOnHide(function() {
		});
		this.setOnSelect(function() {
		});
		this.setDisabledCssClass("disabled");

		this.m_value = defaultValue;

		ns.Control.call(this, element);
	};

	inherits(ns.DropDown, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The DetailDialog that contains the menu content
	 */
	attribute(ns.DropDown, "DetailDialog");

	/**
	 * The selector that triggers the DetailDialog
	 */
	attribute(ns.DropDown, "Selector");

	/**
	 * Function to be executed when the drop down is shown
	 */
	attribute(ns.DropDown, "OnShow");

	/**
	 * Function to be executed when the drop down has been hidden
	 */
	attribute(ns.DropDown, "OnHide");

	/**
	 * Function to be executed when an item is selected
	 */
	attribute(ns.DropDown, "OnSelect");

    /**
     * Whether the drop down will be clickable to be displayed or not
     */
    attribute(ns.DropDown, "Enabled");

    /**
     * Class to be added to the Selector when this control is disabled
     */
     attribute(ns.DropDown, "DisabledCssClass");

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	
	var prot = ns.DropDown.prototype;

	/**
	 * Generates the root node with a tree of nodes and updates the contents
	 * of the DetailDialog with the generated <ul>s from the Node.
	 */
	prot.init = function() {
		this.setDetailDialog(new ns.DetailDialog(this.getElement(), this.getContents()));

        if (!this.getSelector()) {
            this.setSelector(new ns.Selector(this.getElement(), "selected", "unselected"));
        }

		var self = this;
		this.getSelector().setOnSelect(function() {
			self.getDetailDialog().show();
		});

		this.getSelector().setOnUnselect(function() {
			self.getDetailDialog().hide();
		});

		this.getDetailDialog().setOnShow(function() {
			// make sure this will be above everyone else
			self.getDetailDialog().getContents().css("z-index", "7000");
			self.onShow();
		});

		this.getDetailDialog().setOnHide(function() {
			self.m_OnHide(self);
		});

		// this is needed to force updating the value of the textbox
		this.setValue(this.getValue());
	};

	// ________________________________________________________________________

	prot.setValue = function(value) {
		this.m_value = value;
		
		if (this.getElement()) {
		  this.getElement().html(value);
		}
	};
	
	// ________________________________________________________________________

	prot.onShow = function() {
		this.m_OnShow(this);
	};
	
	// ________________________________________________________________________

	prot.getValue = function() {
		if (!this.getDetailDialog()) {
            return "";
        }
		
		return this.m_value;
	};
	
	// ________________________________________________________________________

	/**
	 * Shows the drop down list
	 */
	prot.show = function() {
	    if (!this.getDetailDialog()) {
	        return;
	    }
	    
		this.getDetailDialog().show();
	};
	
	// ________________________________________________________________________

	/**
	 * Hides the drop down list
	 */
	prot.hide = function() {
	    if (!this.getDetailDialog()) {
	        return;
	    }
	    
		this.getDetailDialog().hide();
		this.getSelector().unselect();
	};
	
	// ________________________________________________________________________

	/**
	 * Erases the drop down list from the DOM
	 */
	prot.destroy = function() {
	    if (!this.getDetailDialog() || !this.getElement()) {
	        return;
	    }
	    
		this.getDetailDialog().destroy();
		this.getElement().remove();
	};

	// ________________________________________________________________________

	prot.disable = function() {
	    this.m_Enabled = false;
	    this.hide();
	    this.getSelector().setEnabled(false);
	    this.getSelector().getElement().addClass(this.getDisabledCssClass());
	};

	// ________________________________________________________________________

	prot.enable = function() {
	    this.m_Enabled = true;
	    this.getSelector().setEnabled(true);
	    this.getSelector().getElement().removeClass(this.getDisabledCssClass());
	};

	// ________________________________________________________________________

	prot.setEnabled = function(val) {
	    if (val) {
	        this.enable();
	    } else {
	        this.disabled();
	    }
	};

})(jQuery);
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * DropDownNested Class
 * ============================================================================
 *
 * Renders a drop down list attached to the specified element.
 * The drop down list data can be provided in the form of a tree, causing the actual
 * drop down menu to appear nested into different levels. The tree format must
 * follow the standard set on DropDownNested.Node class.
 *
 * It uses a DetailDialog as the generator for the list. Therefore, to change
 * its position, one can change the associated DetailDialog alignment.
 *
 */
(function($) {
    // ------------------------------------------------------------------------
    // Imports
    // ------------------------------------------------------------------------
	var ns = MPageControls;
	var attribute = MPageObjectOriented.createAttribute;
    var inherits = MPageObjectOriented.inherits;
    
	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDownNested = function(element, tree) {
        this.setSelector(new ns.Selector(element, "selected", "unselected"));
        this.setOnShow(function() {
        });
        this.setOnHide(function() {
        });
        this.setOnSelect(function() {
        });
        this.setTree(tree);

		ns.Control.call(this, element);
	};

	inherits(ns.DropDownNested, ns.Control);
	var prot = ns.DropDownNested.prototype;

    // ------------------------------------------------------------------------
    // Attributes
    // ------------------------------------------------------------------------

    /**
     * The DetailDialog that contains the menu content
     */
    attribute(ns.DropDownNested, "DetailDialog");

    /**
     * The selector that triggers the DetailDialog
     */
    attribute(ns.DropDownNested, "Selector");

    /**
     * Data for the list
     */
    attribute(ns.DropDownNested, "Tree");

    /**
     * Root node element of the tree, once the tree is parsed
     */
    attribute(ns.DropDownNested, "RootNode");

    /**
     * Function to be executed when the drop down is shown
     */
    attribute(ns.DropDownNested, "OnShow");

    /**
     * Function to be executed when the drop down has been hidden
     */
    attribute(ns.DropDownNested, "OnHide");

    /**
     * Function to be executed when an item is selected
     */
    attribute(ns.DropDownNested, "OnSelect");

    /**
     * Returns the current selected node in the tree. It is
     * updated by the select() method.
     */
    attribute(ns.DropDownNested, "SelectedNode");

	// ------------------------------------------------------------------------
	// Inner Classes
	// ------------------------------------------------------------------------

	/**
	 * Represents a single node in a tree structure.
	 *
	 * This constructor will build an entire node tree according to JsonData
	 * and the provided arguments. If you are making a root node, parentNode
	 * can be null. ParentDropDown will be the same for all nodes in the tree.
	 *
	 * JsonData needs to be provided according to the following standard:
	 *
	 * var jsonData = {
	 *     name: "root",
	 *     children: [
	 *          {name: "Child 1" },
	 *          {
	 *           name: "Child 2",
	 *           children: [ ... ]
	 *          }
	 *     ]
	 * }   
	 *
	 * @param {Object} jsonData
	 * @param {Object} parentNode
	 * @param {Object} parentDropDown
	 */
	ns.DropDownNested.Node = function(jsonData, parentNode, parentDropDown) {
		this.children = [];
		this.parent = parentNode;
		this.dropDown = parentDropDown;
		var self = this;

		$.each(jsonData, function(k, v) {
			if (k == "children") {
				$.each(v, function() {
					self.children.push(new ns.DropDownNested.Node(this, self, parentDropDown));
				});
			}
			else {
				self[k] = v;
			}
		});
	};

	// ________________________________________________________________________

	/**
	 * Appends a series of nested lists of <ul> and <li> tags based on the tree
	 * structure of the current node. Also, attaches dropdown.select() to the
	 * on click event of each <li>.
	 *
	 * @param {Object} parentElement
	 */
	ns.DropDownNested.Node.prototype.makeElement = function(parentElement) {
		var current = $("<li></li>").html(this.name);
		var self = this;
		$(current).click(function() {
			self.dropDown.select(self);
		});
		parentElement.append(current);

		var rootUl = "";
		if (this.children.length > 0) {
			rootUl = $("<ul></ul>");
			$.each(this.children, function() {
				this.makeElement(rootUl);
			});
		}
		parentElement.append(rootUl);

		return current;
	};

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------

	/**
	 * Generates the root node with a tree of nodes and updates the contents
	 * of the DetailDialog with the generated <ul>s from the Node.
	 */
	prot.init = function() {
		this.setRootNode(new ns.DropDownNested.Node(this.getTree(), null, this));
		var id = "controlContents" + this.getControlId();
		var rootUl = $("<ul></ul>");
		this.getRootNode().makeElement(rootUl);
		
		// we exclude the root node here
		var menuContent = $("<div></div>");
		menuContent.attr("id", id);
		menuContent.append(rootUl.children("ul"));
		menuContent.appendTo($("body"));
		
		this.setDetailDialog(new ns.DetailDialog(this.getElement(), menuContent));
		var self = this;
		this.getSelector().setOnSelect(function() {
			self.getDetailDialog().show();
		});
		this.getSelector().setOnUnselect(function() {
			self.getDetailDialog().hide();
		});
		this.getDetailDialog().setOnShow(function() {
			// make sure this will be above everyone else
			self.getDetailDialog().getContents().css("z-index", "7000");
			self.m_OnShow(self);
		});
		this.getDetailDialog().setOnHide(function() {
			self.m_OnHide(self);
		});
	};

	// ________________________________________________________________________

	/**
	 * Marks a node as selected, causing the drop down list to hide and its
	 * value to change.
	 *
	 * @param {Object} node
	 */
	prot.select = function(node) {
		this.getElement().html(node.name);
		this.setSelectedNode(node);
		this.getSelector().unselect();
		this.m_OnSelect(node);
	};

	// ________________________________________________________________________

	/**
	 * Shows the drop down list
	 */
	prot.show = function() {
		this.getDetailDialog().show();
	};
	// ________________________________________________________________________

	/**
	 * Hides the drop down list
	 */
	prot.hide = function() {
		this.getDetailDialog().hide();
	};
	// ________________________________________________________________________

	/**
	 * Erases the drop down list from the DOM
	 */
	prot.destroy = function() {
		this.getDetailDialog().destroy();
		this.getElement().remove();
	};
})(jQuery);
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * DropDownTree Class
 * ============================================================================
 *
 * Renders a detail dialog which contains a tree, usually used to lazy load
 * folders. The main difference between this control and the drop down list
 * is that this control can expand and controct folders, and perform ajax
 * calls for the folders
 *
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var DropDown = MPageControls.DropDown;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var Tree = MPageControls.Tree;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDownTree = function(element) {
		this.setTreeCreated(false);
		this.setOnSelect(function() {
		});
		this.setOnCreate(function() {
		    
		});
        DropDown.call(this, element, null);
	};

	inherits(ns.DropDownTree, DropDown);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	attribute(ns.DropDownTree, "Tree");
	attribute(ns.DropDownTree, "TreeCreated");
	attribute(ns.DropDownTree, "OnLazyRead");
	attribute(ns.DropDownTree, "OnCreate");
	attribute(ns.DropDownTree, "OnSelect");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.DropDownTree.prototype;

	prot.init = function() {
		var content = $("<div></div>");

        content.appendTo(this.getElement().offsetParent());
        content.attr("id", "content" + this.getControlId());
        this.setContents(content);
		
		DropDown.prototype.init.call(this);
		
		var self = this;
		this.getDetailDialog().setBeforeShow(function() {
			self.beforeShow();
		});
		
	};

    prot.setTreeElement = function(element) {
        this.mTreeElement = MPageControls.getId(element);
    };
    
    prot.getTreeElement = function() {
      return MPageControls.fromId(this.mTreeElement);  
    };

	// ________________________________________________________________________

	prot.create = function() {
		var self = this;
		var treeElement = $("<div class='dynatree'></div>").appendTo(this.getContents());
		var id = "treeElement" + this.getControlId();
		treeElement.attr("id", id);
		
		this.setTreeElement(treeElement);
		this.setTree(new MPageControls.Tree(this.getTreeElement()));
		this.getTree().setOnSelect(function(node) {
			self.onSelect(node);
		});
		this.getOnCreate()();
		this.setTreeCreated(true);
	};

	// ________________________________________________________________________

	prot.onSelect = function(node) {
		this.setValue(node.data.title);
		this.getSelector().unselect();
	};

	// ________________________________________________________________________

    /**
     * Returns the node that has been selected by the user mouse click 
     */
	prot.getSelectedNode = function() {
		if (this.getTree() === null || this.getTree() === undefined) {
			return null;
		}

		return this.getTree().getSelectedNode();
	};
	// ________________________________________________________________________

	/**
	 * Is executed before the tree is shown, and automatically triggers lazy
	 * loading if the tree hasn't been initialized yet.
	 */
	prot.beforeShow = function() {
		if (this.getTreeCreated()) {
			return;
		}

		this.create();
		if (this.getOnLazyRead()) {
			this.getTree().setOnLazyRead(this.getOnLazyRead());
		}
	};

})(jQuery);
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	
	
	/**
	 * Serves as a generic container for any functionality that can be applied 
	 * to a range of controls
	 */
	ns.Group = function() {
		this.setControls([]);
		this.setCurrent(null);
	};
	
	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	
	/**
	 * An array of mpage controls  or any other object that has select() and
	 * unselect() methods
	 */
	attribute(ns.Group, "Controls");
	
	/**
	 * The control(s) that are/is currently selected.
	 */
	attribute(ns.Group, "Current");

	// ------------------------------------------------------------------------
	// Member methods
	// ------------------------------------------------------------------------
	
	var prot = ns.Group.prototype;
	
	/**
	 * Appends a new control to the controls array
	 */
	prot.add = function(control) {
		this.getControls().push(control);
	};
	
	// ________________________________________________________________________
	
	/**
	 * Loops through the control array and executes unselect() on all the 
	 * controls that are different than the one specified in the argument.
	 * Control.select() will then be performed.
	 *  
	 *  @param control the control to be selected
	 */
	prot.selectSingle = function(control) {
		this.unselectAllExcept(control);
		control.select();	
	};
	
	// ________________________________________________________________________
	
	/**
	 * Calls unselect on all controls except the one specified in the parameter
	 */
	prot.unselectAllExcept = function(control) {
		var controls = this.getControls();
		
		for (var i=controls.length;i--;) {
			if (controls[i].unselect && controls[i] != control) {
				controls[i].unselect();
			}
		}
		
		this.setCurrent(control);
	};

    // ________________________________________________________________________

    /**
     * Executes fun for each item in the group
     * @param fun
     */
    prot.each = function(fun) {
        var controls = this.getControls();
        for (var i=controls.length;i--;) {
            fun(controls[i]);
        }
    };

})(jQuery);(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.List = function(element) {
		var self = this;

		ns.Control.call(this, element);
		this.setSelectedIndex(-1);
		this.setSelectedOption(0);
		this.setListTemplate(MPageControls.getDefaultTemplates().list);
		this.setItemTemplate(MPageControls.getDefaultTemplates().listItem);
		this.setHighlightClass("current");
		this.setSelectedOptionClass("selected-option");
		this.setOnSelect(function() {
		});
		this.setOnMoveUp(function() {
		});
		this.setOnMoveDown(function() {
		});
		this.setOnKeyDown(function() {
		});
		this.setOnDblClick(function() {
		});

		// By default, when pressing the enter key the control will perform
		// a select. This can be changed by the user by setting another
		// onEnter function.
		this.setOnEnter(function() {
			self.select(self.getSelectedIndex());
		});
	};

	inherits(ns.List, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	attribute(ns.List, "SelectedIndex");
	attribute(ns.List, "ListTemplate");
	attribute(ns.List, "ItemTemplate");
	attribute(ns.List, "Items");
	attribute(ns.List, "OnSelect");
	attribute(ns.List, "OnMoveUp");
	attribute(ns.List, "OnMoveDown");
	attribute(ns.List, "OnEnter");
	attribute(ns.List, "OnKeyDown");
	attribute(ns.List, "OnDblClick");
	attribute(ns.List, "HighlightClass");
	attribute(ns.List, "DisplayKey");
	attribute(ns.List, "SelectedOption");
	attribute(ns.List, "SelectedOptionClass");



	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.List.prototype;

	prot.init = function() {

	};

	/**
	 * Can be overriden to provide custom item processing logic
	 */
	prot.makeItem = function(item) {
	    if (!item.content) {
	        item.content = item[this.getDisplayKey()];
	    }

	    return item;
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item placed before the currently selected item
	 */
	prot.moveUp = function() {
		if (this.getSelectedIndex() <= 0) {
			this.setSelectedIndex(0);
		}
		else {
			this.setSelectedIndex(this.getSelectedIndex() - 1);
		}
		var listDiv = $(this.getElement()).children();
		//Scroll up when current item is at the top
		var index = this.getSelectedIndex();
		var curItemDiv = listDiv.children().eq(index);
		//Calculate distance from item's top to list's top
		var itemTopY = curItemDiv.position().top;
		if (itemTopY < 0) {
			listDiv.scrollTop(listDiv.scrollTop() + itemTopY);
		}
		this.highlight(index);
		this.getOnMoveUp()(this.getSelectedItem());
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item placed after the currently selected item
	 */
	prot.moveDown = function() {
		if (this.getSelectedIndex() >= this.getItems().length - 1) {
			this.setSelectedIndex(this.getItems().length - 1);
		}
		else {
			this.setSelectedIndex(this.getSelectedIndex() + 1);
		}
		var listDiv = $(this.getElement()).children();
		//Scroll down when current item is at the bottom
		var index = this.getSelectedIndex();
		var curItemDiv = listDiv.children().eq(index);
		//Calculate distance from item's bottom to list's bottom
		var itemBottomYDistance = curItemDiv.position().top + curItemDiv.outerHeight(true) - listDiv.height();
		if (itemBottomYDistance > 0) {
			listDiv.scrollTop(listDiv.scrollTop() + itemBottomYDistance);
		}
		
		this.highlight(index);
		this.getOnMoveDown()(this.getSelectedItem());
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item at the specified index.
	 *
	 * @param {int} index The index to be selected
	 */
	prot.highlight = function(index) {
		// Removes highlight from other items
		this.getElement().find("." + this.getHighlightClass()).removeClass(this.getHighlightClass());

		// Adds highlight to the current element
		this.getElement().find("#" + this.getIdByIndex(index)).addClass(this.getHighlightClass());
	};
	
	// ________________________________________________________________________

	/**
	*Highlight s the current selected option
	*
	*@param {int} index The index to be selected
	*/

	prot.highlightSelectedOption = function(index) {
		var selectedOption = this.getSelectedOption();
		// When the list is clicked for the first time, highlight the current option
		if(index < 0 && selectedOption === 0){
			this.getElement().find("#" + this.getIdByIndex(selectedOption)).addClass(this.getSelectedOptionClass());		
			this.getElement().find("#" + this.getIdByIndex(index)).removeClass(this.getSelectedOptionClass());	
		}
		//When any item other than the first one is selected.
		if(index > 0 || selectedOption > 0){
			this.getElement().find(".selected-item").removeClass(this.getSelectedOptionClass());
			this.getElement().find("#" + this.getIdByIndex(selectedOption)).addClass(this.getSelectedOptionClass());	
		}
	};

	/**
	 * Get the current item. Index <=-1 assume not item is selected, so it will return null 
	 */
	prot.getSelectedItem = function() {
		if (this.getSelectedIndex() <= -1) {
			return null;
		}

		var items = this.getItems();

		return items[this.getSelectedIndex()];
	};

	/**
	 * Highlights and marks the provided item as the selected one.
	 * Will not trigger any events.
	 *
	 * @param item
	 */
	prot.setSelectedItem = function(item) {
		var index = this.getItemIndex(item);
		this.setSelectedIndex(index);
		this.highlight(index);
	};

	/**
	 * Returns the position of the provided item in the list
	 *
	 * @param item
	 */
	prot.getItemIndex = function(item) {
		var items = this.getItems();
		for (var i=items.length; i--;) {
			if (items[i] == item) {
				return i;
			}
		}
		return -1;
	};

	// ________________________________________________________________________

	prot.renderItems = function(items) {
		var self = this;
		this.setItems(items);
		this.setSelectedIndex(-1);
		
		// --------------------------------------------------------------------
		// Render items
		// --------------------------------------------------------------------
		var renderedItems = [];
		$.each(items, function(i, item) {
		    item = self.makeItem(item);
			item._elementId = self.getIdByIndex(i);
			var rendered = self.getItemTemplate().render(item);
			renderedItems.push(rendered);

			// Attaches the click event of the item to the select method
			rendered.click(function() {
				(function(index) {
					self.select(index);
				})(i);
			});
			
			// Attaches the click event of the item to the select method
			rendered.dblclick(function() {
				(function(index) {
					self.doubleClick(index);
				})(i);
			});

		});
		
		// --------------------------------------------------------------------
		// Renders the list
		// --------------------------------------------------------------------
		var list = this.getListTemplate().render({
			"items": renderedItems,
			"listId": this.getListId()
		});
		this.getElement().empty();
		this.getElement().append(list);

		// --------------------------------------------------------------------
		// Attaches key press events
		// --------------------------------------------------------------------
		list.keydown(function(e) {
			self.processKeyEvent(e);
		});
	};

    // ________________________________________________________________________

	prot.processKeyEvent = function(e) {
		this.getOnKeyDown()(e);
		switch(e.keyCode) {
			case(40):
				e.preventDefault();
				this.moveDown();
				break;
			case(38):
				e.preventDefault();
				this.moveUp();
				break;
			case(13):
				this.getOnEnter()();
				break;
		}
	};
	
	// ________________________________________________________________________

	prot.select = function(index) {
	    if (typeof index === "undefined" || index === null) {
	        index = this.getSelectedIndex();
	    }
		this.setSelectedIndex(index);
		this.highlight(index);
		this.getOnSelect()(this.getSelectedItem());
		this.setSelectedOption(index);
	};
	
	// ________________________________________________________________________

	prot.doubleClick = function(index) {
		//doesn't need to set index or highlight, because onclick -> select function will do it.  
		this.getOnDblClick()(this.getSelectedItem());
	};


	// ________________________________________________________________________

	prot.getIdByIndex = function(index) {
		return "controls_" + this.getControlId() + "_" + index;
	};
	// ________________________________________________________________________

	prot.getListId = function() {
		return "controls_" + this.getControlId() + "_list";
	};
	// ________________________________________________________________________

	prot.focus = function() {
		$("#" + this.getListId()).focus();
	};
	// ________________________________________________________________________

	prot.destroy = function() {
		this.getElement().remove();
	};
})(jQuery);
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * Modeless Class
 * ============================================================================
 *
 * Renders a drop down list attached to the specified element. The only difference
 * between this class and the detaildialog class is that modeless windows can only
 * be opened one at a time.
 *
 */
(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var oo = MPageObjectOriented;
	var inherits = oo.inherits;
	var attribute = oo.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.Modeless = function(element, contentsElement) {
		this.setOnForceHide(function() {
		});
		ns.DetailDialog.call(this, element, contentsElement);
	};
	
	/**
	 * hides the last shown modeless instance
	 */
	ns.Modeless.hide = function() {
		
		if (ns.Modeless.visibleInstance && ns.Modeless.visibleInstance.getVisible()) {
			ns.Modeless.visibleInstance.hide();
			ns.Modeless.visibleInstance.getOnForceHide()();
		}
	};
	
	
	ns.Modeless.visibleInstance = null;
    inherits(ns.Modeless, ns.DetailDialog);

    // ------------------------------------------------------------------------
    // Attributes
    // ------------------------------------------------------------------------

	/**
	 * Callback executed when the modeless is forced to hide because another
	 * one is about to be shown
	 */
	attribute(ns.Modeless, "OnForceHide");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.Modeless.prototype;
	
	prot.show = function() {
		ns.Modeless.hide();
		ns.DetailDialog.prototype.show.call(this);
		ns.Modeless.visibleInstance = this;
	};

})(jQuery);
/**
 * selector.js
 * @author Leonardo Sa
 *
 * Selector class
 * ============================================================================
 * A simple selector that alternates between two css classes on click, much
 * like a checkbox would do. The css styles can be specified in the constructor.
 */
(function($) {
    // -----------------------------------------------------------------------
    // Imports
    // ------------------------------------------------------------------------
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.Selector = function(element, selClass, unselClass) {
		this.setIsSelected(false);
		this.setEnabled(true);
		this.setSelectedClass(selClass);
		this.setUnselectedClass(unselClass);
		this.setUnselectOnClickEnabled(true);
		this.setOnSelect(function() {
		});
		this.setOnUnselect(function() {
		});
        this.setDisabledClass("dithered");

		ns.Control.call(this, element);
	};
	
	// -----------------------------------------------------------------------
    // Attributes
    // ------------------------------------------------------------------------

	/**
	 * The CSS class to be applied to the element when it is selected
	 */
	attribute(ns.Selector, "SelectedClass");

	/**
	 * The CSS class to be applied to the element when it is unselected
	 */
	attribute(ns.Selector, "UnselectedClass");

	/**
	 * Whether the control has been selected or not
	 */
	attribute(ns.Selector, "IsSelected");

	/**
	 * Event fired on select
	 */
	attribute(ns.Selector, "OnSelect");

	/**
	 * Event fired on unselect
	 */
	attribute(ns.Selector, "OnUnselect");
	
	/**
	 * Whether the star will toggle when clicked on 
	 */
	attribute(ns.Selector, "Enabled");

    /**
     * CSS class to be applied to the element when it is set to enabled = false.
     * Defaults to "dithered". The class will be removed once the element is enabled.
     */
	attribute(ns.Selector, "DisabledClass");

	/**
	 * If set to false, the selector will not unselect after it is
	 * selected on a click event. Direct calls to select() will
	 * still work.
	 */
	attribute(ns.Selector, "UnselectOnClickEnabled");

	inherits(ns.Selector, ns.Control);
	var prot = ns.Selector.prototype;

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------

	prot.init = function() {
		var self = this;
		this.getElement().addClass(this.getUnselectedClass());
		this.bind("click", this.getElement(), function() {
			if (self.getIsSelected() && !self.getUnselectOnClickEnabled()) {
				return;
			}
			
		    if (self.getEnabled()) {
			 self.toggle();
			}
		});

		if (this.getIsSelected()) {
			this.performSelection();
		}
		else {
			this.performUnselection();
		}
	};

	// ________________________________________________________________________

	/**
	 * Toggles the selector to select() or unselect()
	 */
	prot.toggle = function() {
		if (this.getIsSelected()) {
			this.unselect();
		}
		else {
			this.select();
		}
	};

	// ________________________________________________________________________

	/**
	 * Triggers the selection of the control
	 */
	prot.select = function() {
		if (this.getIsSelected()) {
			return;
		}

		this.performSelection();
		this.m_OnSelect(this);
	};
    
    // ________________________________________________________________________

	prot.performSelection = function() {
		if (this.getUnselectedClass() !== undefined) {
			this.getElement().removeClass(this.getUnselectedClass());
		}
		
		this.getElement().addClass(this.getSelectedClass());
		this.setIsSelected(true);
	};

	// ________________________________________________________________________

	/**
	 * Triggers the unselection of the control
	 */
	prot.unselect = function() {
		if (!this.getIsSelected()) {
			return;
		}

		this.performUnselection();
		this.m_OnUnselect(this);
	};

    // ________________________________________________________________________

	prot.performUnselection = function() {
		if (this.getSelectedClass() !== undefined) {
			this.getElement().removeClass(this.getSelectedClass());
		}
		
		this.getElement().addClass(this.getUnselectedClass());
		this.setIsSelected(false);
	};

	// ________________________________________________________________________

	prot.destroy = function() {
		this.destroyEvents();
	};

    // ________________________________________________________________________

    prot.setEnabled = function(value) {
        this.m_Enabled = value;

        if (!this.getElement()) { return; }

        if (value) {
            this.getElement().removeClass(this.getDisabledClass());
        } else {
            this.getElement().addClass(this.getDisabledClass());
        }
    };

})(jQuery); (function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A control that represents a single tab, which can be added to a tab 
	 * group. 
	 */
	ns.Tab = function() {
		this.setButtonTemplate(null);
		this.setButtonSelectedClass("selected");
		this.setContentUnselectedClass("hidden");
		this.setOnSelect(function() {});
		this.setOnUnselect(function() {});
		this.setOnRender(function() {});
		this.setEnabled(true);
		
		ns.Control.call(this, null);
	};
	
	inherits(ns.Tab, ns.Control);
	
	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	
	/**
	 * The name of the tab. It is not used by this class itself, but is a
	 * standardized way for derived class to set the title.
	 */
	attribute(ns.Tab, "Title");
	
	/**
	 * A selector that represents the button which the user will click to 
	 * select the tab.
	 */
	attribute(ns.Tab, "Button");
	
	/**
	 * A selector that represents the contents of the tab
	 */
	attribute(ns.Tab, "Content");
	
	/**
	 * A string-template that will be used when rendering the button
	 */
	attribute(ns.Tab, "ButtonTemplate");
	
	/**
	 * The CSS class to be applied when the tab button is selected. Will
	 * default to "selected"
	 */
	attribute(ns.Tab, "ButtonSelectedClass");
	
	/**
	 * The CSS class to be applied when a tab is not selected. Will default to
	 * "hidden"
	 */
	attribute(ns.Tab, "ContentUnselectedClass");
	
	/**
	 * Callback executed whenever the tab is selected.
	 */
	attribute(ns.Tab, "OnSelect");
	
	/**
	 * Callback executed whenever the tab is unselected
	 */
	attribute(ns.Tab, "OnUnselect");
	
	/**
	 * Whether the tab can be selected or not
	 */
	attribute(ns.Tab, "Enabled");
	
	/**
	 * Callback executed whenever the tab is rendered. Tabs are initially 
	 * rendered all at the same time, hence lazy loading functions should be 
	 * placed inside OnSelect instead.
	 */
	attribute(ns.Tab, "OnRender");
	
	
	/**
	 * The tab group that this tab belongs to
	 */
	attribute(ns.Tab, "TabGroup");
	
	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	
	var prot = ns.Tab.prototype;
	
	/**
	 * Returns the ID to be used for the button div
	 */
	prot.getButtonId = function() {
		return "control_" + this.getControlId() + "_button";
	};
	
	// ________________________________________________________________________
	
	/**
	 * Returns the ID to be used for the content div
	 */
	prot.getContentId = function() {
		return "control_" + this.getControlId() + "_content";
	};
	
	// ________________________________________________________________________
	
	/**
	 * When set to true, the user will not be able to click the tab button
	 */
	prot.setEnabled = function(isEnabled) {
		this.m_Enabled = isEnabled;
		if (this.getButton()) {
			this.getButton().setEnabled(isEnabled);
		}
	};

	// ________________________________________________________________________
	
	/**
	 * Creates a blank div in the target, where its id is 
	 * control_[controlid]_button, and appends that div to targetId. Then 
	 * creates a Selector with the newly created div, and sets that as the 
	 * Button instance variable. Finally, renders the template set in 
	 * buttonTemplate into the div.
	 * 
	 * @param targetId the ID of the element that will contain the button
	 */
	prot.renderButton = function(targetId) {
		var template = TemplateBuilder.buildTemplate(this.getButtonTemplate());
		var self = this;
		
		// button html
		var html = template.render({"tab": this, "tabButtonId": this.getButtonId()});
		$("#" + targetId).append(html);
		var btnDiv = $("#" + this.getButtonId());
		
		if (!btnDiv.length) {
			// there is no button. This might happen if the template was empty
			this.setButton(undefined);
			return;
		}
		
		// button selector instance
		var selector = new ns.Selector(btnDiv);
		selector.setSelectedClass(this.getButtonSelectedClass());
		selector.setUnselectOnClickEnabled(false);
		selector.setOnSelect(function() { self.select(); });
		selector.performUnselection();
		
		this.setButton(selector);
	};
	
	// ________________________________________________________________________
	
	/**
	 * Creates a blank div in the target, where its id is [controlid]_content, 
	 * and appends that div to targetId. Then creates a Selector with the newly
	 * created div, and sets that as the Content instance variable.
	 * 
	 * @param targetId the ID of the element that will contain the content
	 */
	prot.renderContent = function(targetId) {
		var contentDiv = $("<div id='" + this.getContentId() + "'></div>");
		$("#" + targetId).append(contentDiv);
		this.setElement(contentDiv);
		var selector = new ns.Selector(contentDiv);
		selector.setUnselectedClass(this.getContentUnselectedClass());
		selector.setEnabled(false);
		selector.performUnselection();
		this.setContent(selector);
	};
	
	// ________________________________________________________________________
	
	/**
	 * Calls renderButton and renderContents with their respective arguments
	 */
	prot.render = function(targetButtonId, targetContentId) {
		this.renderButton(targetButtonId);
		this.renderContent(targetContentId);
		this.getOnRender()();
	};
	
	// ________________________________________________________________________
	
	/**
	 * Makes the current tab visible
	 */
	prot.select = function() {
		var button = this.getButton();
		if (button !== undefined) {
			button.performSelection();
		}
		if (this.getTabGroup()) {
            this.getTabGroup().unselectAllExcept(this);
        }
		this.getContent().performSelection();
		this.getOnSelect()();
	};
	
	// ________________________________________________________________________
	
	/**
	 * Hides the current tab
	 */
	prot.unselect = function() {
		var button = this.getButton();
		if (button !== undefined) {
			button.unselect();
		}
		this.getContent().unselect();
		this.getOnUnselect()();
	};
	
})(jQuery);(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	
	/**
	 * Extends the Group class, and assists on rendering a group of tabs and 
	 * ensuring only one is displayed at a time.
     *
     * Example:
     *
     * var tab1 = new Tab();
     * tab1.setButtonTemplate("<div id=${tabButtonId}>CLICK ME!</div>");
     *
     * var tab2 = new Tab();
     * tab2.setTitle("my tab name");
     * tab2.setButtonTemplate("<div id=${tabButtonId}> ${tab.getTitle()} </div>");
     *
     * var group = new TabGroup();
     * group.addTab(tab1);
     * group.addTab(tab2);
     *
     * group.setButtonsContainerId("an_id_to_store_the_buttons");
     * group.setContentsContainerId("an_id_to_store_the_contents");
     * group.render();
     *
     * tab1.getContentsElement().html("<div> some content </div>");
     * tab2.getContentsElement().html("<div> some other tab </div>");
	 */
	ns.TabGroup = function() {
		ns.Group.call(this);
		
		this.setFirstTabCSSClass("first");
		this.setLastTabCSSClass("last");
	};
	
	inherits(ns.TabGroup, ns.Group);
	
	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	
	/**
	 * The ID of the HTML element which will contain all the tab buttons
	 */
	attribute(ns.TabGroup, "ButtonsContainerId");
	
	/**
	 * The ID of the HTML element which will hold the tab contents
	 */
	attribute(ns.TabGroup, "ContentsContainerId");
	
	/**
	 * A string template to be used when rendering a single button
	 */
	attribute(ns.TabGroup, "DefaultButtonTemplate");
	
	/**
	 * A CSS class to be added to the first tab in the list
	 */
	attribute(ns.TabGroup, "FirstTabCSSClass");
	
	/**
	 * A CSS class to be added to the last tab in the list
	 */
	attribute(ns.TabGroup, "LastTabCSSClass");
	
	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	
	var prot = ns.TabGroup.prototype;
	
	/**
	 * Will cycle through the controls array, and execute the render method on
	 * each, passing buttonsContainerId and contentsContainerId as arguments. 
	 * If the control (tab) does not have a buttonTemplate, the 
	 * defaultButtonTemplate will be set as the template.
	 */
	prot.render = function() {
		var controls = this.getControls();
		var firstTabElement = null;
		var lastTabElement = null;
		
		for (var i=0; i < controls.length; i++) {
			var tab = controls[i];
			if (tab.getButtonTemplate() === null) {
				tab.setButtonTemplate(this.getDefaultButtonTemplate());
			}
			
			tab.render(this.getButtonsContainerId(), 
					this.getContentsContainerId());
			
			// no button? then we're done.
			if (tab.getButton() === undefined) {
				continue;
			}
			
			// identifies the first and last rendered tabs
			var tabElement = tab.getButton().getElement();
			if (firstTabElement === null) {
				firstTabElement = tabElement;
			}
			lastTabElement = tabElement;
			
			tab.setTabGroup(this);
			
		}
		
		// adds the CSS classes for first and last tabs
		var firstCssClass = this.getFirstTabCSSClass();
		var lastCssClass = this.getLastTabCSSClass();
		
		if (firstTabElement !== null && firstCssClass !== null) {
			firstTabElement.addClass(firstCssClass);
		}
		if (lastTabElement !== null && lastCssClass !== null) {
			lastTabElement.addClass(lastCssClass);
		}
	};
	
	// ________________________________________________________________________
	
	/**
	 * Executes a function in each control
	 */
	prot.eachControl = function(fun) {
		var controls = this.getControls();
		for (var i=controls.length; i--;) {
			fun(controls[i]);
		}
	};

	// ________________________________________________________________________	
	
	/**
	 * Sets the enabled attribute of all controls to false
	 */
	prot.disableAll = function() {
		this.eachControl(function(control) {
			if (control.setEnabled) {
				control.setEnabled(false);
			}
		});
	};
	
	// ________________________________________________________________________
	
	/**
	 * Sets the enabled attribute of all controls to true
	 */
	prot.enableAll = function() {
		this.eachControl(function(control) {
			if (control.setEnabled) {
				control.setEnabled(true);
			}
		});
	};

    // ________________________________________________________________________

    /**
     * Adds a new tab to be rendered
     */
	prot.addTab = function(tab) {
        this.getControls().push(tab);
    };

})(jQuery);/**
 * @author LS025469
 */
(function($) {
    var ns = MPageControls;
    var inherits = MPageObjectOriented.inherits;
    var attribute = MPageObjectOriented.createAttribute;

    // ------------------------------------------------------------------------
    // Class Declaration
    // ------------------------------------------------------------------------
    ns.TextHighlighter = function(element) {
        this.setClass("highlight");
        this.setTag("span");
        
        ns.Control.call(this, element);
    };
    
    inherits(ns.TextHighlighter, ns.Control);
    
    attribute(ns.TextHighlighter, "Tag");
    attribute(ns.TextHighlighter, "Class");
    attribute(ns.TextHighlighter, "OnHighlightWord");
    
    ns.TextHighlighter.prototype.highlight = function(term) {
        // regex efficiently reused from the original autosuggest control
        var regex = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1").split(/[, ]/).join("|") + ")(?![^<>]*>)(?![^&;]+;)", "gi");
        
        var tagStart = "<" + this.getTag() + " class='" + this.getClass() + "'>";
        var tagEnd = "</" + this.getTag() + ">";
        var textNode;
        var newHtml;
        
        // we have to cycle through the elements instead of just getting
        // the HTML so we don't lose event data attached to the DOM.
        var textNodes = this.getElement().find('*').contents().filter(function() { return (this.nodeType === 3); });
        $.each(textNodes, function(i, node) {
            textNode = $(node);
            newHtml = textNode.text().replace(regex, tagStart + "$1" + tagEnd);
            textNode.replaceWith(newHtml);
        });
    };
})(jQuery);
/**
 * tree.js
 * @author Leonardo Sa
 *
 * Tree class
 * ============================================================================
 *
 * Renders a AJAX tree of folders, based on the dynatree jquery plugin.
 * In order to populate the tree, one needs to register a function listener
 * by using setOnLazyRead.
 *
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var attribute = MPageObjectOriented.createAttribute;
	var inherits = MPageObjectOriented.inherits;

	// ------------------------------------------------------------------------
	// Class declaration
	// ------------------------------------------------------------------------
	ns.Tree = function(element) {
		this.setDynatreeOptions({});
		this.setOnSelect(function() {
		});

		ns.Control.call(this, element);
	};

	inherits(ns.Tree, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * Options for the dynatree third party library
	 */
	attribute(ns.Tree, "DynatreeOptions");

	/**
	 * Function to be executed when an element is selected
	 */
	attribute(ns.Tree, "OnSelect");

	/**
	 * Returns the dynatree node that is currently selected
	 */
	attribute(ns.Tree, "SelectedNode");

	var prot = ns.Tree.prototype;

	// ________________________________________________________________________

	prot.init = function() {

		var self = this;
		var opts = this.getDynatreeOptions();
		opts.onLazyRead = function(node) {
			self.lazyRead(node);
		};
		opts.onActivate = function(node) {
			self.onSelect(node);
		};
		opts.OnPostInit = this.treeInit;
		opts.autoFocus = false;
		opts.initAjax = {};
		this.getElement().dynatree(opts);
	};

	// ________________________________________________________________________

	/**
	 * Defines a function to be executed whenever there is a need to load more
	 * nodes in the tree. A "node" argument will be passed with the node that
	 * is the parent caller. A first call to this function will be performed
	 * with the dynatree's root node to populate the initial folders.
	 *
	 * @param {function} function to be executed
	 */
	prot.setOnLazyRead = function(fun) {
		this.m_OnLazyRead = fun;
		this.lazyRead(this.getElement().dynatree("getRoot"));
	};

	// ________________________________________________________________________

	prot.getOnLazyRead = function() {
		return this.m_OnLazyRead;
	};

	// ________________________________________________________________________

	prot.lazyRead = function(node) {
		this.m_OnLazyRead(node);
	};

	// ________________________________________________________________________

	prot.onSelect = function(node) {
		this.getOnSelect()(node);
		this.setSelectedNode(node);
	};
})(jQuery); (function() {

    var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
    var List = MPageControls.List;

    ns.DropDownList = function(element) {
        this.setList(new List());
        this.setHighlightClass("current");
        this.setIsMouseOverContents(false);
        ns.DropDown.call(this, element);
    };

    attribute(ns.DropDownList, "List");
    attribute(ns.DropDownList, "DisplayKey");

    /**
     * The CSS class to be applied to the current value in the list. Defaults to
     * "current"
     *
     * @type String
     */
    attribute(ns.DropDownList, "HighlightClass");

    /**
     * Whether the mouse is currently hovering over the contents or not.
     * Is set automatically.
     *
     * @type boolean
     */
    attribute(ns.DropDownList, "IsMouseOverContents");

    inherits(ns.DropDownList, ns.DropDown);

    var prot = ns.DropDownList.prototype;

    prot.init = function() {
    	var self = this;
        var selector = $("<div tabindex='0' id='control_" + this.getControlId() + "_selector' class='selector'></div>");
        var contents = $("<div style='display: none' id='control_" + this.getControlId() + "_contents' class ='contents' ></div>");

        var list = this.getList();
        list.setElement(contents);
        list.setListTemplate(MPageControls.getDefaultTemplates().list);
        list.setItemTemplate(MPageControls.getDefaultTemplates().ddListItem);
        list.setHighlightClass(this.getHighlightClass());
        list.setOnSelect(function() {
            self.selectItem();
        });

        list.bind("mouseover", contents, function() {
            self.setIsMouseOverContents(true);
        });
        list.bind("mouseout", contents, function() {
            self.setIsMouseOverContents(false);
        });
        list.bind("blur", selector, function() {
            if (!self.getIsMouseOverContents()) {
                self.hide();
            }
        });

        this.getElement().append(selector);
        this.getElement().append(contents);
        this.setContents(contents);
        this.setElement(selector);

        // if an element is passed in the constructor it will build a selector automatically.
        // this ensures we remove the events of the old selector before changing the element.
        if (this.getSelector()) {
            this.getSelector().destroyEvents();
            this.getSelector().setElement(selector);
            this.getSelector().init();
        }

        this.getList().makeItem = function(item) {
            item.displayKey = self.getDisplayKey();
			return item;
        };

        ns.DropDown.prototype.init.call(this);

        // we rendered contents with display none, so it is hidden
        this.getDetailDialog().setVisible(false);
			
    };

    /**
     * Overrides the DropDown onShow method to provide highlighting
     * functionality for the currently selected item.
     */
    prot.onShow = function() {
        var selectedIndex = this.getList().getSelectedIndex();

        ns.DropDown.prototype.onShow.call(this);

        this.getList().setSelectedIndex(selectedIndex);
        this.getList().highlight(selectedIndex);
    };

    /**
     * Collapses the drop down and sets the display value according
     * to the current selected item
     */
    prot.selectItem = function() {
        this.hide();
        this.setValue(this.getList().getSelectedItem()[this.getDisplayKey()]);
        this.getOnSelect()(this.getList().getSelectedItem());
    };

    /**
     * Returns the currently selected item
     * @return {*}
     */
    prot.getSelectedItem = function() {
        return this.getList().getSelectedItem();
    };

    /**
     * Sets the currently selected item without firing any events or
     * callbacks.
     *
     * @param item
     */
    prot.setSelectedItem = function(item) {
        this.setValue(item[this.getDisplayKey()]);
        this.getList().setSelectedItem(item);
    };

    /**
     * Renders all the items inside the drop down
     *
     * @param items
     * @return {*}
     */
    prot.renderItems = function(items) {
        return this.getList().renderItems(items);
    };

    prot.setItemTemplate = function(template) {
        this.getList().setItemTemplate(template);
    };

    prot.setItems = function(items) {
        this.getList().setItems(items);
    };

    prot.selectByIndex = function(index) {
        this.getList().select(index);
    };

})();(function($) {

    var inherits = MPageObjectOriented.inherits;
    var attribute = MPageObjectOriented.createAttribute;
    var ns = MPageControls;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------

	MPageControls.CclSearch = function(element) {
	    this.setRequestCount(0);
        this.setSynchSuggestionsWidth(true);
        this.setInBrowserDir("../../mpages/reports/");
        ns.AutoSuggest.call(this, element);
	};

	inherits(ns.CclSearch, ns.AutoSuggest);

    /**
     * Name of the CCL program to be executed
     */
	attribute(ns.CclSearch, "ProgramName");

	/**
	 * How many requests have been queued. This is needed to ensure
	 * the right request will be displayed in case there are multiple
	 * keystrokes in a period less than the delay.
	 */
	attribute(ns.CclSearch, "RequestCount");

	/**
	 * Directory to be prepended to a CCL call when CERN_BrowserDevInd is true
	 */
	attribute(ns.CclSearch, "InBrowserDir")

	var prot = ns.CclSearch.prototype;

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	/**
     * Sets the template to render list items and attaches searchOrders()
     * function to be triggered when the user types.
     */
    prot.init = function() {
       MPageControls.AutoSuggest.prototype.init.call(this);

       var self = this;

       this.setTemplate(MPageControls.getDefaultTemplates().cclSearch);

       this.setOnDelay(function() {
           self.callProgram();
       });

       this.setRequestItemValueCallback(function(item) {
            return item.content;
       });
    };

    // ..................................................................................

    /**
    * Performs a CCL call to the program specified by setProgramName(), with parameters
    * generated by buildParameters()
    */
    prot.callProgram = function(httpRequestHandler) {
        var searchPhrase = this.getValue();
        var self = this;

        // increase the request count
        this.setRequestCount(this.getRequestCount() + 1);
        var reqNumber = this.getRequestCount();

        // Initialize request object
        if (httpRequestHandler) {
            var xhr = httpRequestHandler;
        } else {
            var xhr = (!CERN_Platform.inMillenniumContext()) ? new XMLHttpRequest() : new XMLCclRequest();
        }

        // Handle response
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4 && xhr.status == 200) {
               MP_Util.LogScriptCallInfo(null, this, "script_search.js", "callProgram");
               self.handleSuccess(reqNumber, xhr.responseText);
            }
        };

        // Send request
        var params = this.buildParameters();
        if (!CERN_Platform.inMillenniumContext()) {
            var urlSuffix = this.getProgramName() + "?parameters=" + params;
            var url = CERN_Platform.getScriptServletLocation() || this.getInBrowserDir();
            url += urlSuffix;

            xhr.open("GET", url);
            xhr.send(null);
        }
        else {
            xhr.open('GET', this.getProgramName());
            xhr.send(params);
        }
    };

    // ..................................................................................

    /**
     * Handles a successful request from the Ajax program call
     */
    prot.handleSuccess = function(reqNumber, responseText) {

        // ensure we are processing the latest request made
		if (reqNumber != this.getRequestCount() || !responseText) {
			return;
		}

        var jsonSearch = JSON.parse(responseText);

        // Handle failed CCL call
        if (jsonSearch.RECORD_DATA.STATUS_DATA.STATUS === "F") {
            MP_Util.LogScriptCallError(null, responseText, "program_search.js", "handleSuccess");
            MP_Util.LogError(this.getProgramName() + " failed: " + responseText);
            return;
        }

        // Do not render if there is no response
        if (!jsonSearch) {
            return;
        }

        var context = this.makeContext(jsonSearch);
        this.setSuggestions(context);
    };

    // ..................................................................................

    /**
     * Should be overwritten by the derived class to return the parameter string
     * to be used on the CCL call
     */
    prot.buildParameters = function() {
        throw "buildParameters() is abstract.";
    };

    // ..................................................................................

    /**
     * Can be overriden by the client if there is a need to edit the context before
     * it is sent to rendering.
     */
    prot.makeContext = function(responseJson) {
        return responseJson;
    };


}(jQuery));(function($) {
    var inherits = MPageObjectOriented.inherits;
    var attribute = MPageObjectOriented.createAttribute;
    var ns = MPageControls;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	MPageControls.OrderSearch = function(element) {
		this.setRequestCount(0);
		this.setSynchSuggestionsWidth(true);
		
	    ns.AutoSuggest.call(this, element);
	};
	
	inherits(ns.OrderSearch, ns.AutoSuggest);
        
    // ----------------------------------------------------------------
    // Attributes
    // ----------------------------------------------------------------
    attribute(ns.OrderSearch, "Criterion");
    attribute(ns.OrderSearch, "SuggestionLimit");
    attribute(ns.OrderSearch, "EncounterTypeCd");
    attribute(ns.OrderSearch, "FacilityId");
    attribute(ns.OrderSearch, "SearchIndicators");
    attribute(ns.OrderSearch, "VenueType");
    attribute(ns.OrderSearch, "RequestCount");
    attribute(ns.OrderSearch, "BirthDate");
    attribute(ns.OrderSearch, "BirthDateTimeZone");
    attribute(ns.OrderSearch, "ClinicalWeight");
    attribute(ns.OrderSearch, "ClinicalWeightUnit");
    attribute(ns.OrderSearch, "PMAInDays");    
	
	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = MPageControls.OrderSearch.prototype;

	/**
	 * Sets the template to render list items and attaches searchOrders()
	 * function to be triggered when the user types.
	 */
	prot.init = function() {
	   MPageControls.AutoSuggest.prototype.init.call(this);
		
	   var self = this;
	    
	   this.setListItemTemplate(MPageControls.getDefaultTemplates().orderSearchItem);
	   this.setTemplate(MPageControls.getDefaultTemplates().orderSearch);
	   
		this.setOnDelay(function() {
			var originalValue = self.m_SearchIndicators;
			self.m_SearchIndicators &= ~(1 << 10); //Turns 10th bit of searchIndicators off. Auto-search always filtered
			self.searchOrders();
			self.m_SearchIndicators = originalValue;
		}); 

	   	   this.setRequestItemValueCallback(function(item) {
	        return item.content;
	        
       });
       
       
	};
	
	// ________________________________________________________________________
	
	prot.searchOrders = function(callback) {
	    var searchPhrase = this.getValue();
	    var self = this;
	    
	    // increase the request count
	    this.setRequestCount(this.getRequestCount() + 1);
	    var reqNumber = this.getRequestCount();
	    
	    // --------------------------------------------------------------------
        // Initialize the request object
	    // --------------------------------------------------------------------
        var xhr = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();
        
	    // --------------------------------------------------------------------
        // Handle response
	    // --------------------------------------------------------------------
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4 && xhr.status == 200) {
               MP_Util.LogScriptCallInfo(null, this, "order_search.js", "handleSearchOrderSuccess");
               self.handleSearchOrdersSuccess(reqNumber, 
            		   xhr.responseText, callback);
            }
        };

	    // --------------------------------------------------------------------
        // Send request
	    // --------------------------------------------------------------------
        if (this.getSearchIndicators() === null) {
        	throw "OrderSearch: no search indicators specified";
        }

        var birthDate = this.getBirthDate() ? this.getBirthDate() : "";
        var birthDateTimeZone = this.getBirthDateTimeZone() ? this.getBirthDateTimeZone() : 0;
        var weightValue = this.getClinicalWeight() ? this.getClinicalWeight() : 0.0;
        var weightUnit = this.getClinicalWeightUnit() ? this.getClinicalWeightUnit() : 0;
        var pmaInDays = this.getPMAInDays() ? this.getPMAInDays() : 0;
		      
        var sugLimit = this.getSuggestionLimit();
        if (this.getSuggestionLimit() <= 0) {
        	sugLimit = 50;
        }
        
        var params = "^MINE^,^" + searchPhrase + "^," + sugLimit + "," + this.getEncounterTypeCd() + ".0," + this.getFacilityId() + ".0," + this.getCriterion().provider_id + ".0," + this.getCriterion().ppr_cd + ".0," + this.getVenueType() + "," + this.getSearchIndicators() + "," + 1 + "," + this.getCriterion().person_id + ".0,^" + birthDate + "^," + birthDateTimeZone + "," + weightValue + "," + weightUnit + "," + pmaInDays;
        if (CERN_BrowserDevInd) {
            var url = "mp_search_orders?parameters=" + params;
            xhr.open("GET", url);
            xhr.send(null);
        }
        else {
            xhr.open('GET', "mp_search_orders");
            xhr.send(params);
        }      
	};
	
	// ________________________________________________________________________
	
	prot.handleSearchOrdersSuccess = function(requestNumber, responseText, callback) {
		// ensure we are processing the latest request made
		if ((requestNumber != this.getRequestCount())|| !responseText) {
			return;
		}
		 
         var jsonSearch = "";
         
         jsonSearch = JSON.parse(responseText);
         
         if (!jsonSearch) {
             return;
         }
         
         if (jsonSearch.RESULTS.STATUS_DATA.STATUS === "F") {
        	 MP_Util.LogScriptCallError(null, responseText, "order_search.js", "handleSearchOrderSuccess");
        	 MP_Util.LogError("mp_search_orders failed: " + responseText);
        	 return;
         }
         
         //Cache the patient demographic information for future use.
         if (jsonSearch.RESULTS.BIRTH_DATE) {
             this.setBirthDate(jsonSearch.RESULTS.BIRTH_DATE);
         }
         if (jsonSearch.RESULTS.BIRTH_DATE_TZ) {
             this.setBirthDateTimeZone(jsonSearch.RESULTS.BIRTH_DATE_TZ);
         }
         if (jsonSearch.RESULTS.WEIGHT_VALUE) {
             this.setClinicalWeight(jsonSearch.RESULTS.WEIGHT_VALUE);
         }
         if (jsonSearch.RESULTS.WEIGHT_CODE) {
             this.setClinicalWeightUnit(jsonSearch.RESULTS.WEIGHT_CODE);
         }
         if (jsonSearch.RESULTS.PMA_VALUE) {
             this.setPMAInDays(jsonSearch.RESULTS.PMA_VALUE);
         }	      	          
         if (callback) {
         	callback(responseText);
         } else {
        	var returnData = jsonSearch.RESULTS.ORDERS.concat(jsonSearch.RESULTS.PLANS);
         	this.renderJson(returnData);
         }
         
	};
	
	// ________________________________________________________________________
	
	prot.renderJson = function(returnData) {
	   var self = this;
	    
	   $.each(returnData, function(i, item) {
	        // Figures out the item content
            if (item.SYNONYM) {
                item.content = item.SYNONYM;
            } else if (item.PW_CAT_SYN_NAME) {
                item.content = item.PW_CAT_SYN_NAME;
            }
            
            // Figures out the item CSS class
            if (item.ORDERABLE_TYPE_FLAG == 6) {
                item.iconClass = "careset-icon";
            } else if (item.ORDERABLE_TYPE_FLAG === 0) {
                item.iconClass = "";
            } else if (item.PATH_CAT_ID) {
                item.iconClass = "powerplan-icon";
            }
	   });

	   this.setSuggestions(returnData);
	    
	};
	
})(jQuery);
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A component level control that creates a dropdown list for venues, which can be used by components like New order entry option 1 and 2.
	 */
	ns.OrderVenueGroup = function(element,defaultValue,venueList, selectedOption) {
		ns.DropDownList.call(this, element);
		this.setValue(defaultValue);
		this.setVenueList(venueList);
		this.getList().setSelectedOption(selectedOption);
		this.getList().setItemTemplate(MPageControls.getDefaultTemplates().venueTemplate);
	};

	attribute(ns.OrderVenueGroup, "VenueList");
	inherits(ns.OrderVenueGroup, ns.DropDownList);
	
	var prot = ns.OrderVenueGroup.prototype;

	prot.init = function(){
		var self = this;
		this.setOnShow( function(){

			self.getList().setDisplayKey("VENUE_DISPLAY");
			self.getList().renderItems(self.getVenueList());
			self.getList().highlightSelectedOption(self.getList().getSelectedIndex());
		});
		ns.DropDownList.prototype.init.call(this);
	};
	
})(jQuery);(function($) {
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var ns = MPageControls;

	/**
	 * Renders a textbox autosuggest control into element and uses
	 * MP_GET_PRSNL_JSON to suggest results.
	 */
	MPageControls.PersonnelSearch = function(element) {
		ns.CclSearch.call(this, element);

		this.setProgramName("MP_GET_PRSNL_JSON");
		this.setSuggestionLimit(10);
		this.setListItemTemplate(MPageControls.getDefaultTemplates().personnelSearchItem);
	};

	inherits(ns.PersonnelSearch, MPageControls.CclSearch);

	attribute(ns.PersonnelSearch, "UserId");
	attribute(ns.PersonnelSearch, "SuggestionLimit");

	var prot = ns.PersonnelSearch.prototype;

	prot.buildParameters = function() {
		var lastName = "";
		var firstName = "";
		// split first/last name if a comma exists
		var splitted = this.getValue().split(",");
		if (splitted.length > 1) {
			lastName = splitted[0];
			firstName = splitted[1];
		} else {
			lastName = splitted[0];
			firstName = "";
		}

		// builds the parameter string
		return "^MINE^"
		+ "," + this.getUserId() + ".00"
		+ ",^" + lastName + "^"
		+ ",^" + firstName + "^"
		+ "," + this.getSuggestionLimit();
	};

	prot.makeContext = function(response) {
		return response.RECORD_DATA.PRSNL;
	};

	prot.setTemplateMaxHeight = function(maxHeight) {
		ns.setMaxHeight(maxHeight);
	};
})(jQuery);
/**
 * CPM Resource
 * Represents and contains information on a CPM
 * @constructor
 */
function CPMResource(){
    this.m_id = "";
    this.m_pathwayName = "";
    this.m_autoAddedInd = false;
    this.m_commentText = "";
    this.m_cpPathwayActivityId = 0;
    this.m_cpPathwayId = 0;
    this.m_pathwayInstanceId = 0;
    this.m_encntrId = 0;
    this.m_statusCd = 0;
    this.m_statusMean = "";
    this.m_conceptCd = 0;
    this.m_conceptMean = "";
    this.m_conceptDisp = "";
    this.m_proposedByName = "";
    this.m_triggeringDxNomenclatureId = 0;
    this.m_triggerDescription = "";
    this.m_triggerType = "";
}

/**
 * Enumerable
 * @type {{ACTIVE: string, COMPLETE: string, ON_HOLD: string, VOID: string}}
 */
CPMResource.STATUSES = {
    ACTIVE: "ACTIVE"
    , COMPLETE: "COMPLETE"
    , INACTIVE: "INACTIVE"
    , ON_HOLD: "HOLD"
    , PROPOSED: "PROPOSED"
    , REJECTED: "REJECTED"
    , VOID: "VOID"
};

CPMResource.TRIGGER_TYPES = {
    PROBLEM: "PROBLEM"
    , DIAGNOSIS: "DIAGNOSIS"
    , PATHWAY_STATUS: "PATHWAY_STATUS"
};

/**
 * Retrieves CPMResource's unique id
 * @returns {string} - unique id
 */
CPMResource.prototype.getId = function(){
    return this.m_id;
};

/**
 * Retrieves CPM's pathway name
 * @returns {string} - pathway name
 */
CPMResource.prototype.getPathwayName = function(){
    return this.m_pathwayName;
};

/**
 * Returns if the CPM was automatically added
 * @returns {boolean} - true if CPM was automatically added
 */
CPMResource.prototype.wasAutoAdded = function(){
    return this.m_autoAddedInd;
};

/**
 * Retrieves comment text associated with the CPM
 * @returns {string} - comment text
 */
CPMResource.prototype.getCommentText = function(){
    return this.m_commentText;
};

/**
 * Retrieves CPM's pathway activity id
 * @returns {number} - pathway activity id
 */
CPMResource.prototype.getPathwayActivityId = function(){
    return this.m_cpPathwayActivityId;
};

/**
 * Retrieves CPM's pathway id
 * @returns {number} - pathway id
 */
CPMResource.prototype.getPathwayId = function(){
    return this.m_cpPathwayId;
};

/**
 * Retrieves CPM's pathway instance id
 * Note: Instances of pathways are based on the person/encounter being referenced
 * @returns {number} - pathway instance id
 */
CPMResource.prototype.getPathwayInstanceId = function(){
    return this.m_pathwayInstanceId;
};

/**
 * Retrieves CPM's encounter id
 * @returns {number} - encounter id
 */
CPMResource.prototype.getEncounterId = function(){
    return this.m_encntrId;
};

/**
 * Retrieves CPM's status mean
 * @returns {string} - status mean
 */
CPMResource.prototype.getStatusMean = function(){
    return this.m_statusMean;
};

/**
 * Retrieves CPM's status code value
 * @returns {number} - status code value
 */
CPMResource.prototype.getStatusCd = function(){
    return this.m_statusCd;
};

/**
 * Retrieves CPM's concept code value
 * @returns {number} - concept code value
 */
CPMResource.prototype.getConceptCd = function(){
    return this.m_conceptCd;
};

/**
 * Retrieves CPM's concept mean
 * @returns {string} - concept mean
 */
CPMResource.prototype.getConceptMean = function(){
    return this.m_conceptMean;
};

/**
 * Retrieves CPM's concept display
 * @returns {string} - concept display
 */
CPMResource.prototype.getConceptDisp = function(){
    return this.m_conceptDisp;
};

/**
 * Retrieves CPM's proposed by name
 * @returns {string} - name of the user that proposed the cpm
 */
CPMResource.prototype.getProposedByName = function(){
    return this.m_proposedByName;
};

/**
 * Retrieves the diagnosis nomenclature id that triggered the CPM
 * @returns {number} - diagnosis nomenclature id
 */
CPMResource.prototype.getTriggeringDxNomenclatureId = function(){
    return this.m_triggeringDxNomenclatureId;
};

/**
 * Retrieves description of the trigger that triggered the CPM
 * EX: Diagnosis nomenclature text
 * @returns {string} - trigger description
 */
CPMResource.prototype.getTriggerDescription = function(){
    return this.m_triggerDescription;
};

/**
 * Retrieves the type of the trigger that suggested the CPM
 * Should match an ENUM from CPMResource.TRIGGER_TYPES
 * @returns {string} - trigger type
 */
CPMResource.prototype.getTriggerType = function(){
    return this.m_triggerType;
};

/**
 * Sets CPMResource's id
 * Throws error if id is not a string or a number
 * @param {string | number} id - unique id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setId = function(id){
    if (typeof id !== "string" && typeof id !== "number"){
        throw new Error("Type Error: id passed into CPMResource method setId not a string or number");
    }
    this.m_id = id;
};

/**
 * Sets CPMResource's pathway name
 * Throws error if name is not a string
 * @param {string} name - pathway name
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setPathwayName = function(name){
    if (typeof name !== "string"){
        throw new Error("Type Error: name passed into CPMResource method setPathwayName not a string");
    }
    this.m_pathwayName = name;
};

/**
 * Sets CPMResource's auto add indicator
 * Throws error if wasAutoAdded is not a boolean
 * @param {boolean} wasAutoAdded - indicates if the CPM was automatically added
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setWasAutoAdded = function(wasAutoAdded){
    if (typeof wasAutoAdded !== "boolean"){
        throw new Error("Type Error: wasAutoAdded passed into CPMResource method setWasAutoAdded not a boolean");
    }
    this.m_autoAddedInd = wasAutoAdded;
};

/**
 * Sets CPMResource's comment text
 * Throws error if comment text is not a string
 * @param {string} commentText - comment text
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setCommentText = function(commentText){
    if (typeof commentText !== "string"){
        throw new Error("Type Error: commentText passed into CPMResource method setCommentText not a string");
    }
    this.m_commentText = commentText;
};

/**
 * Sets the CPMResource's pathway activity id
 * Throws error if pathwayActivityId is not a number
 * @param {number} pathwayActivityId - pathway activity id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setPathwayActivityId = function(pathwayActivityId){
    if (typeof pathwayActivityId !== "number"){
        throw new Error("Type Error: pathwayActivityId passed into CPMResource method setPathwayActivityId not a number");
    }
    this.m_cpPathwayActivityId = pathwayActivityId;
};

/**
 * Sets the CPMResource's pathway id
 * Throws error if pathwayId is not a number
 * @param {number} pathwayId - pathway id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setPathwayId = function(pathwayId){
    if (typeof pathwayId !== "number"){
        throw new Error("Type Error: pathwayId passed into CPMResource method setPathwayId not a number");
    }
    this.m_cpPathwayId = pathwayId;
};

/**
 * Sets the CPMResource's pathway instance id
 * Throws error if pathwayInstanceId is not a number
 * @param {number} pathwayInstanceId - pathway instance id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setPathwayInstanceId = function(pathwayInstanceId){
    if (typeof pathwayInstanceId !== "number"){
        throw new Error("Type Error: pathwayInstanceId passed into CPMResource method setPathwayInstanceId not a number");
    }
    this.m_pathwayInstanceId = pathwayInstanceId;
};

/**
 * Sets the CPMResource's encounter Id
 * Throws error if encounterId is not a number
 * @param {number} encounterId - encounter id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setEncounterId = function(encounterId){
    if (typeof encounterId !== "number"){
        throw new Error("Type Error: encounterId passed into CPMResource method setEncounterId not a number");
    }
    this.m_encntrId = encounterId;
};

/**
 * Sets CPMResource's status mean
 * Throws error if status mean is not a string
 * @param {string} statusMean - status mean
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setStatusMean = function(statusMean){
    if (typeof statusMean !== "string"){
        throw new Error("Type Error: statusMean passed into CPMResource method setStatusMean not a string");
    }
    this.m_statusMean = statusMean;
};

/**
 * Sets CPMResource's status code value
 * Throws error if status code value is not a number
 * @param {number} statusCd - status code value
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setStatusCd = function(statusCd){
    if (typeof statusCd !== "number"){
        throw new Error("Type Error: statusCd passed into CPMResource method setStatusCd not a number");
    }
    this.m_statusCd = statusCd;
};

/**
 * Sets CPMResource's concept code value
 * Throws error if concept code value not a number
 * @param {number} conceptCd - concept code value
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setConceptCd = function(conceptCd){
    if (typeof conceptCd !== "number"){
        throw new Error("Type Error: conceptCd passed into CPMResource method setConceptCd not a number");
    }
    this.m_conceptCd = conceptCd;
};

/**
 * Sets CPMResource's concept mean
 * Throws error if concept mean not a string
 * @param {string} conceptMean - concept mean
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setConceptMean = function(conceptMean){
    if (typeof conceptMean !== "string"){
        throw new Error("Type Error: conceptMean passed into CPMResource method setConceptMean not a string");
    }
    this.m_conceptMean = conceptMean;
};

/**
 * Sets CPMResource's concept display
 * Throws error if concept display not a string
 * @param {string} conceptDisp - concept display
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setConceptDisp = function(conceptDisp){
    if (typeof conceptDisp !== "string"){
        throw new Error("Type Error: conceptDisp passed into CPMResource method setConceptDisp not a string");
    }
    this.m_conceptDisp = conceptDisp;
};

/**
 * Sets CPMResource's proposed by name
 * Throws error if name not a string
 * @param {string} name - name of user that proposed the cpm
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setProposedByName = function(name){
    if (typeof name !== "string"){
        throw new Error("Type Error: name passed into CPMResource method setProposedByName not a string");
    }
    this.m_proposedByName = name;
};

/**
 * Sets CPMResource's triggering dx nomenclature id
 * Throws error if nomenclatureId is not a number
 * @param {number} nomenclatureId - triggering dx nomenclature id
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setTriggeringDxNomenclatureId = function(nomenclatureId){
    if (typeof nomenclatureId !== "number"){
        throw new Error("Type Error: nomenclatureId passed into CPMResource method setTriggeringDxNomenclatureId not a number");
    }
    this.m_triggeringDxNomenclatureId = nomenclatureId;
};

/**
 * Sets CPMResource's trigger description
 * Throws error if description is not a string
 * @param {string} description - trigger description
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setTriggerDescription = function(description){
    if (typeof description !== "string"){
        throw new Error("Type Error: description passed into CPMResource method setTriggerDescription not a string");
    }
    this.m_triggerDescription = description;
};

/**
 * Sets CPMResource's trigger type
 * @param {string} type - ENUMERABLE from CPMResource.TRIGGER_TYPES
 * @returns {undefined} - undefined
 */
CPMResource.prototype.setTriggerType = function(type){
    this.m_triggerType = type;
};

/**
 * Returns whether the CPMResource is meant to be suggested
 * @returns {boolean} - true if the CPMResource is suggested
 */
CPMResource.prototype.isSuggested = function(){
    //If the trigger type of a CPM is not 'PATHWAY_STATUS', then automatically return true
    //The only PATHWAY_STATUS that should be suggested is 'PROPOSED'
    if (CPMResource.TRIGGER_TYPES[this.getTriggerType()] && this.getTriggerType() !== CPMResource.TRIGGER_TYPES.PATHWAY_STATUS){
        return true;
    }
    if (this.getStatusMean() === CPMResource.STATUSES.PROPOSED){
        return true;
    }
    if (this.wasAutoAdded()){
        return true;
    }
    return false;
};/* global CPMResource */
/**
 * CPMResourceManager
 * Manages a collection of CPMResource objects
 * @constructor
 */
function CPMResourceManager(){
    this.m_cpmResourceMap = null;
}

(function(){
    //BASE_ID and count are private and inaccessible to modification except within the generateId function
    var BASE_ID = "CPMRESOURCE";
    var count = 0;
    /**
     * Generates a unique ID
     * @returns {string} - unique id
     */
    CPMResourceManager.generateId = function(){
        return BASE_ID + ++count;
    };
})();

/**
 * Creates a CPMResource given a CPM JSON object
 * Throws an error if cpmJSON is not a non-empty object
 * @param {{}} cpmJSON - JSON representing a CPM
 * @returns {CPMResource} - A CPMResource object
 */
CPMResourceManager.createCPMResource = function(cpmJSON){
    if (!cpmJSON || typeof cpmJSON !== "object" || Array.prototype.isPrototypeOf(cpmJSON)){
        throw new Error("Type Error: cpmJSON passed into CPMResourceManager function createCPMResource not an object");
    }
    var cpmResource = new CPMResource();
    cpmResource.setId(CPMResourceManager.generateId());
    cpmResource.setPathwayName(cpmJSON.PATHWAY_NAME || "");
    cpmResource.setWasAutoAdded(!!cpmJSON.AUTO_ADDED_IND);
    cpmResource.setCommentText(cpmJSON.COMMENT_TXT || "");
    cpmResource.setPathwayActivityId(cpmJSON.CP_PATHWAY_ACTIVITY_ID || 0);
    cpmResource.setPathwayId(cpmJSON.CP_PATHWAY_ID || 0);
    cpmResource.setPathwayInstanceId(cpmJSON.PATHWAY_INSTANCE_ID || 0);
    cpmResource.setEncounterId(cpmJSON.ENCNTR_ID || 0);
    cpmResource.setStatusCd(cpmJSON.PATHWAY_ACTIVITY_STATUS_CD || 0);
    cpmResource.setStatusMean(cpmJSON.PATHWAY_ACTIVITY_STATUS_MEAN || "");
    cpmResource.setConceptCd(cpmJSON.CONCEPT_CD || 0);
    cpmResource.setConceptMean(cpmJSON.CONCEPT_MEAN || "");
    cpmResource.setConceptDisp(cpmJSON.CONCEPT_DISP || "");
    cpmResource.setProposedByName(cpmJSON.UPDT_NAME || "");
    cpmResource.setTriggeringDxNomenclatureId(cpmJSON.DX_NOMENCLATURE_ID || 0);
    cpmResource.setTriggerDescription(cpmJSON.TRIGGER_DESCRIPTION || "");
    cpmResource.setTriggerType(cpmJSON.TRIGGER_TYPE || "");
    return cpmResource;
};

/**
 * Generates an array of suggested CPMResource objects
 * Adding or removing CPMResources from the resulting array does not affect the CPMResourceManager's collection of CPMResources
 * @param {boolean} suggestedFlag - defaults to true, if set to false, will return an array of CPMResources that are not suggested
 * @returns {Array} - list of CPMResources
 */
CPMResourceManager.prototype.getSuggestedCPMResourceList = function(suggestedFlag){
    var resourceMap = this.m_cpmResourceMap;
    var resourceList = [];
    var id;
    var resource;
    //If no params passed in/non boolean passed in (i.e. undefined), then treat suggestedFlag as true
    if (typeof suggestedFlag !== 'boolean'){
        suggestedFlag = true;
    }

    for (id in resourceMap){
        if (!resourceMap.hasOwnProperty(id) || !CPMResource.prototype.isPrototypeOf(resourceMap[id])){
            continue;
        }
        resource = resourceMap[id];
        if (suggestedFlag && resource.isSuggested()){
            resourceList.push(resource);
        } else if (!suggestedFlag && !resource.isSuggested()){
            resourceList.push(resource);
        }
    }
    return resourceList;
};

/**
 * Generates an array of CPMResource objects
 * Adding or removing CPMResources from the resulting array does not affect the CPMResourceManager's collection of CPMResources
 * @param {string} [statusFilter] - Status to filter CPMResource objects by. Must be from CPMResource.STATUSES enumerable.
 * @param {boolean} [excludeStatus] - Indicates whether to include or exclude CPMResource objects with the provided statusFilter.
 * @returns {Array} - Array of CPMResource Objects
 */
CPMResourceManager.prototype.getCPMResourceList = function(statusFilter, excludeStatus){
    var resourceMap = this.m_cpmResourceMap;
    var resourceList = [];
    var id;
    var resource;

    for (id in resourceMap){
        if (!resourceMap.hasOwnProperty(id) || !CPMResource.prototype.isPrototypeOf(resourceMap[id])){
            continue;
        }
        if (!statusFilter){
            resourceList.push(resourceMap[id]);
        } else {
            resource = resourceMap[id];
            if (resource.getStatusMean() === statusFilter && !excludeStatus){
                resourceList.push(resource);
            } else if (resource.getStatusMean() !== statusFilter && excludeStatus){
                resourceList.push(resource);
            }
        }
    }
    return resourceList;
};

/**
 * Retrieves array of CPMResource objects that match the provided status
 * If the status is not valid, all CPMResources will be returned
 * Adding or removing CPMResources from the resulting array does not affect the CPMResourceManager's collection of CPMResources
 * @param {string} status - Status to filter CPMResource objects by. Must be from CPMResource.STATUSES enumerable.
 * @returns {Array} - Array of CPMResource objects
 */
CPMResourceManager.prototype.getCPMResourceListWithStatus = function(status){
    //Verify status exists
    if (!CPMResource.STATUSES[status]){
        logger.logWarning("Invalid status: " + status + " passed into CPMResourceManager method getCPMResourceListWithStatus. Filtering not applied.");
        return this.getCPMResourceList();
    }
    return this.getCPMResourceList(status, false);
};

/**
 * Retrieves array of CPMResource objects that do not match the provided status
 * If the status is not valid, all CPMResources will be returned
 * Adding or removing CPMResources from the resulting array does not affect the CPMResourceManager's collection of CPMResources
 * @param {string} status - Status to filter CPMResource objects by. Must be from CPMResource.STATUSES enumerable.
 * @returns {Array} - Array of CPMResource objects
 */
CPMResourceManager.prototype.getCPMResourceListWithoutStatus = function(status){
    //Verify status exists
    if (!CPMResource.STATUSES[status]){
        logger.logWarning("Invalid status: " + status + " passed into CPMResourceManager method getCPMResourceListWithoutStatus. Filtering not applied.");
        return this.getCPMResourceList();
    }
    return this.getCPMResourceList(status, true);
};

/**
 * Retrieves the CPMResourceManager's cpmResourceMap
 * @returns {null | {}} - cpmResourceMap or null
 */
CPMResourceManager.prototype.getCPMResourceMap = function(){
    return this.m_cpmResourceMap;
};

/**
 * Sets the CPMResourceManager's cpmResourceMap
 * Throws an error if map is not an object or null
 * @param {null | {}} map - a map of CPMResource object IDs to CPMResource objects
 * @returns {undefined} - undefined
 */
CPMResourceManager.prototype.setCPMResourceMap = function(map){
    if (typeof map !== "object" || Array.prototype.isPrototypeOf(map)){
        throw new Error("Type Error: map passed into CPMResourceManager method setCPMResourceMap not an object or null");
    }
    this.m_cpmResourceMap = map;
};

/**
 * Adds a CPMResource object to the CPMResourceManager's internal collection
 * Throws an error if cpmResource is not an instance of CPMResource
 * @param {CPMResource} cpmResource - A CPMResource object
 * @returns {undefined} - undefined
 */
CPMResourceManager.prototype.addCPMResource = function(cpmResource){
    if (!CPMResource.prototype.isPrototypeOf(cpmResource)){
        throw new Error("Type Error: cpmResource passed into CPMResourceManager method addCPMResource not instance of CPMResource");
    }

    var resourceMap = this.m_cpmResourceMap;
    if (!resourceMap){
        resourceMap = {};
        this.setCPMResourceMap(resourceMap);
    }
    //Since all IDs should be unique (though not guaranteed), going to overwrite existing entry if one exists
    resourceMap[cpmResource.getId()] = cpmResource;
};

/**
 * Retrieves a CPMResource object from the CPMResourceManager's internal collection by the provided id
 * Throws an error if id is not a string or number
 * @param {string | number} id - id of a CPMResource object
 * @returns {undefined | CPMResource} - A CPMResource object, or undefined if one is not found based on the provided id
 */
CPMResourceManager.prototype.getCPMResourceById = function(id){
    if (typeof id !== "string" && typeof id !== "number"){
        throw new Error("Type Error: id passed into CPMResourceManager method getCPMResourceById not a string or number");
    }
    var resource;
    var resourceMap = this.m_cpmResourceMap;
    if (resourceMap){
        resource = resourceMap[id];
    }
    return resource;
};

/**
 * Removes all CPMResource objects from the CPMResourceManager's internal collection
 * @returns {undefined} - undefined
 */
CPMResourceManager.prototype.removeAllCPMResources = function(){
    this.setCPMResourceMap({});
};

/**
 * Removes a CPMResource object from the CPMResourceManager's internal collection based on provided id
 * Throws an error if id is not a string or number
 * @param {string | number} id - CPMResource id
 * @returns {undefined} - undefined
 */
CPMResourceManager.prototype.removeCPMResourceById = function(id){
    if (typeof id !== "string" && typeof id !== "number"){
        throw new Error("Type Error: id passed into CPMResourceManager method removeCPMResourceById not a string or number");
    }
    var resourceMap = this.m_cpmResourceMap;
    if (resourceMap){
        resourceMap[id] = null;
        delete resourceMap[id];
    }
};
// moment.js
// version : 2.0.0
// author : Tim Wood
// license : MIT
// momentjs.com
(function(e){function O(e,t){return function(n){return j(e.call(this,n),t)}}function M(e){return function(t){return this.lang().ordinal(e.call(this,t))}}function _(){}function D(e){H(this,e)}function P(e){var t=this._data={},n=e.years||e.year||e.y||0,r=e.months||e.month||e.M||0,i=e.weeks||e.week||e.w||0,s=e.days||e.day||e.d||0,o=e.hours||e.hour||e.h||0,u=e.minutes||e.minute||e.m||0,a=e.seconds||e.second||e.s||0,f=e.milliseconds||e.millisecond||e.ms||0;this._milliseconds=f+a*1e3+u*6e4+o*36e5,this._days=s+i*7,this._months=r+n*12,t.milliseconds=f%1e3,a+=B(f/1e3),t.seconds=a%60,u+=B(a/60),t.minutes=u%60,o+=B(u/60),t.hours=o%24,s+=B(o/24),s+=i*7,t.days=s%30,r+=B(s/30),t.months=r%12,n+=B(r/12),t.years=n}function H(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}function B(e){return e<0?Math.ceil(e):Math.floor(e)}function j(e,t){var n=e+"";while(n.length<t)n="0"+n;return n}function F(e,t,n){var r=t._milliseconds,i=t._days,s=t._months,o;r&&e._d.setTime(+e+r*n),i&&e.date(e.date()+i*n),s&&(o=e.date(),e.date(1).month(e.month()+s*n).date(Math.min(o,e.daysInMonth())))}function I(e){return Object.prototype.toString.call(e)==="[object Array]"}function q(e,t){var n=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),i=0,s;for(s=0;s<n;s++)~~e[s]!==~~t[s]&&i++;return i+r}function R(e,t){return t.abbr=e,s[e]||(s[e]=new _),s[e].set(t),s[e]}function U(e){return e?(!s[e]&&o&&require("./lang/"+e),s[e]):t.fn._lang}function z(e){return e.match(/\[.*\]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function W(e){var t=e.match(a),n,r;for(n=0,r=t.length;n<r;n++)A[t[n]]?t[n]=A[t[n]]:t[n]=z(t[n]);return function(i){var s="";for(n=0;n<r;n++)s+=typeof t[n].call=="function"?t[n].call(i,e):t[n];return s}}function X(e,t){function r(t){return e.lang().longDateFormat(t)||t}var n=5;while(n--&&f.test(t))t=t.replace(f,r);return C[t]||(C[t]=W(t)),C[t](e)}function V(e){switch(e){case"DDDD":return p;case"YYYY":return d;case"YYYYY":return v;case"S":case"SS":case"SSS":case"DDD":return h;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":case"a":case"A":return m;case"X":return b;case"Z":case"ZZ":return g;case"T":return y;case"MM":case"DD":case"YY":case"HH":case"hh":case"mm":case"ss":case"M":case"D":case"d":case"H":case"h":case"m":case"s":return c;default:return new RegExp(e.replace("\\",""))}}function $(e,t,n){var r,i,s=n._a;switch(e){case"M":case"MM":s[1]=t==null?0:~~t-1;break;case"MMM":case"MMMM":r=U(n._l).monthsParse(t),r!=null?s[1]=r:n._isValid=!1;break;case"D":case"DD":case"DDD":case"DDDD":t!=null&&(s[2]=~~t);break;case"YY":s[0]=~~t+(~~t>68?1900:2e3);break;case"YYYY":case"YYYYY":s[0]=~~t;break;case"a":case"A":n._isPm=(t+"").toLowerCase()==="pm";break;case"H":case"HH":case"h":case"hh":s[3]=~~t;break;case"m":case"mm":s[4]=~~t;break;case"s":case"ss":s[5]=~~t;break;case"S":case"SS":case"SSS":s[6]=~~(("0."+t)*1e3);break;case"X":n._d=new Date(parseFloat(t)*1e3);break;case"Z":case"ZZ":n._useUTC=!0,r=(t+"").match(x),r&&r[1]&&(n._tzh=~~r[1]),r&&r[2]&&(n._tzm=~~r[2]),r&&r[0]==="+"&&(n._tzh=-n._tzh,n._tzm=-n._tzm)}t==null&&(n._isValid=!1)}function J(e){var t,n,r=[];if(e._d)return;for(t=0;t<7;t++)e._a[t]=r[t]=e._a[t]==null?t===2?1:0:e._a[t];r[3]+=e._tzh||0,r[4]+=e._tzm||0,n=new Date(0),e._useUTC?(n.setUTCFullYear(r[0],r[1],r[2]),n.setUTCHours(r[3],r[4],r[5],r[6])):(n.setFullYear(r[0],r[1],r[2]),n.setHours(r[3],r[4],r[5],r[6])),e._d=n}function K(e){var t=e._f.match(a),n=e._i,r,i;e._a=[];for(r=0;r<t.length;r++)i=(V(t[r]).exec(n)||[])[0],i&&(n=n.slice(n.indexOf(i)+i.length)),A[t[r]]&&$(t[r],i,e);e._isPm&&e._a[3]<12&&(e._a[3]+=12),e._isPm===!1&&e._a[3]===12&&(e._a[3]=0),J(e)}function Q(e){var t,n,r,i=99,s,o,u;while(e._f.length){t=H({},e),t._f=e._f.pop(),K(t),n=new D(t);if(n.isValid()){r=n;break}u=q(t._a,n.toArray()),u<i&&(i=u,r=n)}H(e,r)}function G(e){var t,n=e._i;if(w.exec(n)){e._f="YYYY-MM-DDT";for(t=0;t<4;t++)if(S[t][1].exec(n)){e._f+=S[t][0];break}g.exec(n)&&(e._f+=" Z"),K(e)}else e._d=new Date(n)}function Y(t){var n=t._i,r=u.exec(n);n===e?t._d=new Date:r?t._d=new Date(+r[1]):typeof n=="string"?G(t):I(n)?(t._a=n.slice(0),J(t)):t._d=n instanceof Date?new Date(+n):new Date(n)}function Z(e,t,n,r,i){return i.relativeTime(t||1,!!n,e,r)}function et(e,t,n){var i=r(Math.abs(e)/1e3),s=r(i/60),o=r(s/60),u=r(o/24),a=r(u/365),f=i<45&&["s",i]||s===1&&["m"]||s<45&&["mm",s]||o===1&&["h"]||o<22&&["hh",o]||u===1&&["d"]||u<=25&&["dd",u]||u<=45&&["M"]||u<345&&["MM",r(u/30)]||a===1&&["y"]||["yy",a];return f[2]=t,f[3]=e>0,f[4]=n,Z.apply({},f)}function tt(e,n,r){var i=r-n,s=r-e.day();return s>i&&(s-=7),s<i-7&&(s+=7),Math.ceil(t(e).add("d",s).dayOfYear()/7)}function nt(e){var n=e._i,r=e._f;return n===null||n===""?null:(typeof n=="string"&&(e._i=n=U().preparse(n)),t.isMoment(n)?(e=H({},n),e._d=new Date(+n._d)):r?I(r)?Q(e):K(e):Y(e),new D(e))}function rt(e,n){t.fn[e]=t.fn[e+"s"]=function(e){var t=this._isUTC?"UTC":"";return e!=null?(this._d["set"+t+n](e),this):this._d["get"+t+n]()}}function it(e){t.duration.fn[e]=function(){return this._data[e]}}function st(e,n){t.duration.fn["as"+e]=function(){return+this/n}}var t,n="2.0.0",r=Math.round,i,s={},o=typeof module!="undefined"&&module.exports,u=/^\/?Date\((\-?\d+)/i,a=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,f=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,l=/([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,c=/\d\d?/,h=/\d{1,3}/,p=/\d{3}/,d=/\d{1,4}/,v=/[+\-]?\d{1,6}/,m=/[0-9]*[a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF]+\s*?[\u0600-\u06FF]+/i,g=/Z|[\+\-]\d\d:?\d\d/i,y=/T/i,b=/[\+\-]?\d+(\.\d{1,3})?/,w=/^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,E="YYYY-MM-DDTHH:mm:ssZ",S=[["HH:mm:ss.S",/(T| )\d\d:\d\d:\d\d\.\d{1,3}/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],x=/([\+\-]|\d\d)/gi,T="Month|Date|Hours|Minutes|Seconds|Milliseconds".split("|"),N={Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6},C={},k="DDD w W M D d".split(" "),L="M D H h m s w W".split(" "),A={M:function(){return this.month()+1},MMM:function(e){return this.lang().monthsShort(this,e)},MMMM:function(e){return this.lang().months(this,e)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(e){return this.lang().weekdaysMin(this,e)},ddd:function(e){return this.lang().weekdaysShort(this,e)},dddd:function(e){return this.lang().weekdays(this,e)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return j(this.year()%100,2)},YYYY:function(){return j(this.year(),4)},YYYYY:function(){return j(this.year(),5)},a:function(){return this.lang().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.lang().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return~~(this.milliseconds()/100)},SS:function(){return j(~~(this.milliseconds()/10),2)},SSS:function(){return j(this.milliseconds(),3)},Z:function(){var e=-this.zone(),t="+";return e<0&&(e=-e,t="-"),t+j(~~(e/60),2)+":"+j(~~e%60,2)},ZZ:function(){var e=-this.zone(),t="+";return e<0&&(e=-e,t="-"),t+j(~~(10*e/6),4)},X:function(){return this.unix()}};while(k.length)i=k.pop(),A[i+"o"]=M(A[i]);while(L.length)i=L.pop(),A[i+i]=O(A[i],2);A.DDDD=O(A.DDD,3),_.prototype={set:function(e){var t,n;for(n in e)t=e[n],typeof t=="function"?this[n]=t:this["_"+n]=t},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(e){return this._months[e.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(e){return this._monthsShort[e.month()]},monthsParse:function(e){var n,r,i,s;this._monthsParse||(this._monthsParse=[]);for(n=0;n<12;n++){this._monthsParse[n]||(r=t([2e3,n]),i="^"+this.months(r,"")+"|^"+this.monthsShort(r,""),this._monthsParse[n]=new RegExp(i.replace(".",""),"i"));if(this._monthsParse[n].test(e))return n}},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(e){return this._weekdays[e.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(e){return this._weekdaysShort[e.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(e){return this._weekdaysMin[e.day()]},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},longDateFormat:function(e){var t=this._longDateFormat[e];return!t&&this._longDateFormat[e.toUpperCase()]&&(t=this._longDateFormat[e.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e]=t),t},meridiem:function(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[last] dddd [at] LT",sameElse:"L"},calendar:function(e,t){var n=this._calendar[e];return typeof n=="function"?n.apply(t):n},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(e,t,n,r){var i=this._relativeTime[n];return typeof i=="function"?i(e,t,n,r):i.replace(/%d/i,e)},pastFuture:function(e,t){var n=this._relativeTime[e>0?"future":"past"];return typeof n=="function"?n(t):n.replace(/%s/i,t)},ordinal:function(e){return this._ordinal.replace("%d",e)},_ordinal:"%d",preparse:function(e){return e},postformat:function(e){return e},week:function(e){return tt(e,this._week.dow,this._week.doy)},_week:{dow:0,doy:6}},t=function(e,t,n){return nt({_i:e,_f:t,_l:n,_isUTC:!1})},t.utc=function(e,t,n){return nt({_useUTC:!0,_isUTC:!0,_l:n,_i:e,_f:t})},t.unix=function(e){return t(e*1e3)},t.duration=function(e,n){var r=t.isDuration(e),i=typeof e=="number",s=r?e._data:i?{}:e,o;return i&&(n?s[n]=e:s.milliseconds=e),o=new P(s),r&&e.hasOwnProperty("_lang")&&(o._lang=e._lang),o},t.version=n,t.defaultFormat=E,t.lang=function(e,n){var r;if(!e)return t.fn._lang._abbr;n?R(e,n):s[e]||U(e),t.duration.fn._lang=t.fn._lang=U(e)},t.langData=function(e){return e&&e._lang&&e._lang._abbr&&(e=e._lang._abbr),U(e)},t.isMoment=function(e){return e instanceof D},t.isDuration=function(e){return e instanceof P},t.fn=D.prototype={clone:function(){return t(this)},valueOf:function(){return+this._d},unix:function(){return Math.floor(+this._d/1e3)},toString:function(){return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._d},toJSON:function(){return t.utc(this).format("YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var e=this;return[e.year(),e.month(),e.date(),e.hours(),e.minutes(),e.seconds(),e.milliseconds()]},isValid:function(){return this._isValid==null&&(this._a?this._isValid=!q(this._a,(this._isUTC?t.utc(this._a):t(this._a)).toArray()):this._isValid=!isNaN(this._d.getTime())),!!this._isValid},utc:function(){return this._isUTC=!0,this},local:function(){return this._isUTC=!1,this},format:function(e){var n=X(this,e||t.defaultFormat);return this.lang().postformat(n)},add:function(e,n){var r;return typeof e=="string"?r=t.duration(+n,e):r=t.duration(e,n),F(this,r,1),this},subtract:function(e,n){var r;return typeof e=="string"?r=t.duration(+n,e):r=t.duration(e,n),F(this,r,-1),this},diff:function(e,n,r){var i=this._isUTC?t(e).utc():t(e).local(),s=(this.zone()-i.zone())*6e4,o,u;return n&&(n=n.replace(/s$/,"")),n==="year"||n==="month"?(o=(this.daysInMonth()+i.daysInMonth())*432e5,u=(this.year()-i.year())*12+(this.month()-i.month()),u+=(this-t(this).startOf("month")-(i-t(i).startOf("month")))/o,n==="year"&&(u/=12)):(o=this-i-s,u=n==="second"?o/1e3:n==="minute"?o/6e4:n==="hour"?o/36e5:n==="day"?o/864e5:n==="week"?o/6048e5:o),r?u:B(u)},from:function(e,n){return t.duration(this.diff(e)).lang(this.lang()._abbr).humanize(!n)},fromNow:function(e){return this.from(t(),e)},calendar:function(){var e=this.diff(t().startOf("day"),"days",!0),n=e<-6?"sameElse":e<-1?"lastWeek":e<0?"lastDay":e<1?"sameDay":e<2?"nextDay":e<7?"nextWeek":"sameElse";return this.format(this.lang().calendar(n,this))},isLeapYear:function(){var e=this.year();return e%4===0&&e%100!==0||e%400===0},isDST:function(){return this.zone()<t([this.year()]).zone()||this.zone()<t([this.year(),5]).zone()},day:function(e){var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return e==null?t:this.add({d:e-t})},startOf:function(e){e=e.replace(/s$/,"");switch(e){case"year":this.month(0);case"month":this.date(1);case"week":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return e==="week"&&this.day(0),this},endOf:function(e){return this.startOf(e).add(e.replace(/s?$/,"s"),1).subtract("ms",1)},isAfter:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)>+t(e).startOf(n)},isBefore:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)<+t(e).startOf(n)},isSame:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)===+t(e).startOf(n)},zone:function(){return this._isUTC?0:this._d.getTimezoneOffset()},daysInMonth:function(){return t.utc([this.year(),this.month()+1,0]).date()},dayOfYear:function(e){var n=r((t(this).startOf("day")-t(this).startOf("year"))/864e5)+1;return e==null?n:this.add("d",e-n)},isoWeek:function(e){var t=tt(this,1,4);return e==null?t:this.add("d",(e-t)*7)},week:function(e){var t=this.lang().week(this);return e==null?t:this.add("d",(e-t)*7)},lang:function(t){return t===e?this._lang:(this._lang=U(t),this)}};for(i=0;i<T.length;i++)rt(T[i].toLowerCase().replace(/s$/,""),T[i]);rt("year","FullYear"),t.fn.days=t.fn.day,t.fn.weeks=t.fn.week,t.fn.isoWeeks=t.fn.isoWeek,t.duration.fn=P.prototype={weeks:function(){return B(this.days()/7)},valueOf:function(){return this._milliseconds+this._days*864e5+this._months*2592e6},humanize:function(e){var t=+this,n=et(t,!e,this.lang());return e&&(n=this.lang().pastFuture(t,n)),this.lang().postformat(n)},lang:t.fn.lang};for(i in N)N.hasOwnProperty(i)&&(st(i,N[i]),it(i.toLowerCase()));st("Weeks",6048e5),t.lang("en",{ordinal:function(e){var t=e%10,n=~~(e%100/10)===1?"th":t===1?"st":t===2?"nd":t===3?"rd":"th";return e+n}}),o&&(module.exports=t),typeof ender=="undefined"&&(this.moment=t),typeof define=="function"&&define.amd&&define("moment",[],function(){return t})}).call(this);// moment.js
// version : 2.0.0
// author : Tim Wood
// license : MIT
// momentjs.com
(function(e){function O(e,t){return function(n){return j(e.call(this,n),t)}}function M(e){return function(t){return this.lang().ordinal(e.call(this,t))}}function _(){}function D(e){H(this,e)}function P(e){var t=this._data={},n=e.years||e.year||e.y||0,r=e.months||e.month||e.M||0,i=e.weeks||e.week||e.w||0,s=e.days||e.day||e.d||0,o=e.hours||e.hour||e.h||0,u=e.minutes||e.minute||e.m||0,a=e.seconds||e.second||e.s||0,f=e.milliseconds||e.millisecond||e.ms||0;this._milliseconds=f+a*1e3+u*6e4+o*36e5,this._days=s+i*7,this._months=r+n*12,t.milliseconds=f%1e3,a+=B(f/1e3),t.seconds=a%60,u+=B(a/60),t.minutes=u%60,o+=B(u/60),t.hours=o%24,s+=B(o/24),s+=i*7,t.days=s%30,r+=B(s/30),t.months=r%12,n+=B(r/12),t.years=n}function H(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}function B(e){return e<0?Math.ceil(e):Math.floor(e)}function j(e,t){var n=e+"";while(n.length<t)n="0"+n;return n}function F(e,t,n){var r=t._milliseconds,i=t._days,s=t._months,o;r&&e._d.setTime(+e+r*n),i&&e.date(e.date()+i*n),s&&(o=e.date(),e.date(1).month(e.month()+s*n).date(Math.min(o,e.daysInMonth())))}function I(e){return Object.prototype.toString.call(e)==="[object Array]"}function q(e,t){var n=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),i=0,s;for(s=0;s<n;s++)~~e[s]!==~~t[s]&&i++;return i+r}function R(e,t){return t.abbr=e,s[e]||(s[e]=new _),s[e].set(t),s[e]}function U(e){return e?(!s[e]&&o&&require("./lang/"+e),s[e]):t.fn._lang}function z(e){return e.match(/\[.*\]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function W(e){var t=e.match(a),n,r;for(n=0,r=t.length;n<r;n++)A[t[n]]?t[n]=A[t[n]]:t[n]=z(t[n]);return function(i){var s="";for(n=0;n<r;n++)s+=typeof t[n].call=="function"?t[n].call(i,e):t[n];return s}}function X(e,t){function r(t){return e.lang().longDateFormat(t)||t}var n=5;while(n--&&f.test(t))t=t.replace(f,r);return C[t]||(C[t]=W(t)),C[t](e)}function V(e){switch(e){case"DDDD":return p;case"YYYY":return d;case"YYYYY":return v;case"S":case"SS":case"SSS":case"DDD":return h;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":case"a":case"A":return m;case"X":return b;case"Z":case"ZZ":return g;case"T":return y;case"MM":case"DD":case"YY":case"HH":case"hh":case"mm":case"ss":case"M":case"D":case"d":case"H":case"h":case"m":case"s":return c;default:return new RegExp(e.replace("\\",""))}}function $(e,t,n){var r,i,s=n._a;switch(e){case"M":case"MM":s[1]=t==null?0:~~t-1;break;case"MMM":case"MMMM":r=U(n._l).monthsParse(t),r!=null?s[1]=r:n._isValid=!1;break;case"D":case"DD":case"DDD":case"DDDD":t!=null&&(s[2]=~~t);break;case"YY":s[0]=~~t+(~~t>68?1900:2e3);break;case"YYYY":case"YYYYY":s[0]=~~t;break;case"a":case"A":n._isPm=(t+"").toLowerCase()==="pm";break;case"H":case"HH":case"h":case"hh":s[3]=~~t;break;case"m":case"mm":s[4]=~~t;break;case"s":case"ss":s[5]=~~t;break;case"S":case"SS":case"SSS":s[6]=~~(("0."+t)*1e3);break;case"X":n._d=new Date(parseFloat(t)*1e3);break;case"Z":case"ZZ":n._useUTC=!0,r=(t+"").match(x),r&&r[1]&&(n._tzh=~~r[1]),r&&r[2]&&(n._tzm=~~r[2]),r&&r[0]==="+"&&(n._tzh=-n._tzh,n._tzm=-n._tzm)}t==null&&(n._isValid=!1)}function J(e){var t,n,r=[];if(e._d)return;for(t=0;t<7;t++)e._a[t]=r[t]=e._a[t]==null?t===2?1:0:e._a[t];r[3]+=e._tzh||0,r[4]+=e._tzm||0,n=new Date(0),e._useUTC?(n.setUTCFullYear(r[0],r[1],r[2]),n.setUTCHours(r[3],r[4],r[5],r[6])):(n.setFullYear(r[0],r[1],r[2]),n.setHours(r[3],r[4],r[5],r[6])),e._d=n}function K(e){var t=e._f.match(a),n=e._i,r,i;e._a=[];for(r=0;r<t.length;r++)i=(V(t[r]).exec(n)||[])[0],i&&(n=n.slice(n.indexOf(i)+i.length)),A[t[r]]&&$(t[r],i,e);e._isPm&&e._a[3]<12&&(e._a[3]+=12),e._isPm===!1&&e._a[3]===12&&(e._a[3]=0),J(e)}function Q(e){var t,n,r,i=99,s,o,u;while(e._f.length){t=H({},e),t._f=e._f.pop(),K(t),n=new D(t);if(n.isValid()){r=n;break}u=q(t._a,n.toArray()),u<i&&(i=u,r=n)}H(e,r)}function G(e){var t,n=e._i;if(w.exec(n)){e._f="YYYY-MM-DDT";for(t=0;t<4;t++)if(S[t][1].exec(n)){e._f+=S[t][0];break}g.exec(n)&&(e._f+=" Z"),K(e)}else e._d=new Date(n)}function Y(t){var n=t._i,r=u.exec(n);n===e?t._d=new Date:r?t._d=new Date(+r[1]):typeof n=="string"?G(t):I(n)?(t._a=n.slice(0),J(t)):t._d=n instanceof Date?new Date(+n):new Date(n)}function Z(e,t,n,r,i){return i.relativeTime(t||1,!!n,e,r)}function et(e,t,n){var i=r(Math.abs(e)/1e3),s=r(i/60),o=r(s/60),u=r(o/24),a=r(u/365),f=i<45&&["s",i]||s===1&&["m"]||s<45&&["mm",s]||o===1&&["h"]||o<22&&["hh",o]||u===1&&["d"]||u<=25&&["dd",u]||u<=45&&["M"]||u<345&&["MM",r(u/30)]||a===1&&["y"]||["yy",a];return f[2]=t,f[3]=e>0,f[4]=n,Z.apply({},f)}function tt(e,n,r){var i=r-n,s=r-e.day();return s>i&&(s-=7),s<i-7&&(s+=7),Math.ceil(t(e).add("d",s).dayOfYear()/7)}function nt(e){var n=e._i,r=e._f;return n===null||n===""?null:(typeof n=="string"&&(e._i=n=U().preparse(n)),t.isMoment(n)?(e=H({},n),e._d=new Date(+n._d)):r?I(r)?Q(e):K(e):Y(e),new D(e))}function rt(e,n){t.fn[e]=t.fn[e+"s"]=function(e){var t=this._isUTC?"UTC":"";return e!=null?(this._d["set"+t+n](e),this):this._d["get"+t+n]()}}function it(e){t.duration.fn[e]=function(){return this._data[e]}}function st(e,n){t.duration.fn["as"+e]=function(){return+this/n}}var t,n="2.0.0",r=Math.round,i,s={},o=typeof module!="undefined"&&module.exports,u=/^\/?Date\((\-?\d+)/i,a=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,f=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,l=/([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,c=/\d\d?/,h=/\d{1,3}/,p=/\d{3}/,d=/\d{1,4}/,v=/[+\-]?\d{1,6}/,m=/[0-9]*[a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF]+\s*?[\u0600-\u06FF]+/i,g=/Z|[\+\-]\d\d:?\d\d/i,y=/T/i,b=/[\+\-]?\d+(\.\d{1,3})?/,w=/^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,E="YYYY-MM-DDTHH:mm:ssZ",S=[["HH:mm:ss.S",/(T| )\d\d:\d\d:\d\d\.\d{1,3}/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],x=/([\+\-]|\d\d)/gi,T="Month|Date|Hours|Minutes|Seconds|Milliseconds".split("|"),N={Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6},C={},k="DDD w W M D d".split(" "),L="M D H h m s w W".split(" "),A={M:function(){return this.month()+1},MMM:function(e){return this.lang().monthsShort(this,e)},MMMM:function(e){return this.lang().months(this,e)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(e){return this.lang().weekdaysMin(this,e)},ddd:function(e){return this.lang().weekdaysShort(this,e)},dddd:function(e){return this.lang().weekdays(this,e)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return j(this.year()%100,2)},YYYY:function(){return j(this.year(),4)},YYYYY:function(){return j(this.year(),5)},a:function(){return this.lang().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.lang().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return~~(this.milliseconds()/100)},SS:function(){return j(~~(this.milliseconds()/10),2)},SSS:function(){return j(this.milliseconds(),3)},Z:function(){var e=-this.zone(),t="+";return e<0&&(e=-e,t="-"),t+j(~~(e/60),2)+":"+j(~~e%60,2)},ZZ:function(){var e=-this.zone(),t="+";return e<0&&(e=-e,t="-"),t+j(~~(10*e/6),4)},X:function(){return this.unix()}};while(k.length)i=k.pop(),A[i+"o"]=M(A[i]);while(L.length)i=L.pop(),A[i+i]=O(A[i],2);A.DDDD=O(A.DDD,3),_.prototype={set:function(e){var t,n;for(n in e)t=e[n],typeof t=="function"?this[n]=t:this["_"+n]=t},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(e){return this._months[e.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(e){return this._monthsShort[e.month()]},monthsParse:function(e){var n,r,i,s;this._monthsParse||(this._monthsParse=[]);for(n=0;n<12;n++){this._monthsParse[n]||(r=t([2e3,n]),i="^"+this.months(r,"")+"|^"+this.monthsShort(r,""),this._monthsParse[n]=new RegExp(i.replace(".",""),"i"));if(this._monthsParse[n].test(e))return n}},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(e){return this._weekdays[e.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(e){return this._weekdaysShort[e.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(e){return this._weekdaysMin[e.day()]},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D YYYY",LLL:"MMMM D YYYY LT",LLLL:"dddd, MMMM D YYYY LT"},longDateFormat:function(e){var t=this._longDateFormat[e];return!t&&this._longDateFormat[e.toUpperCase()]&&(t=this._longDateFormat[e.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e]=t),t},meridiem:function(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[last] dddd [at] LT",sameElse:"L"},calendar:function(e,t){var n=this._calendar[e];return typeof n=="function"?n.apply(t):n},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(e,t,n,r){var i=this._relativeTime[n];return typeof i=="function"?i(e,t,n,r):i.replace(/%d/i,e)},pastFuture:function(e,t){var n=this._relativeTime[e>0?"future":"past"];return typeof n=="function"?n(t):n.replace(/%s/i,t)},ordinal:function(e){return this._ordinal.replace("%d",e)},_ordinal:"%d",preparse:function(e){return e},postformat:function(e){return e},week:function(e){return tt(e,this._week.dow,this._week.doy)},_week:{dow:0,doy:6}},t=function(e,t,n){return nt({_i:e,_f:t,_l:n,_isUTC:!1})},t.utc=function(e,t,n){return nt({_useUTC:!0,_isUTC:!0,_l:n,_i:e,_f:t})},t.unix=function(e){return t(e*1e3)},t.duration=function(e,n){var r=t.isDuration(e),i=typeof e=="number",s=r?e._data:i?{}:e,o;return i&&(n?s[n]=e:s.milliseconds=e),o=new P(s),r&&e.hasOwnProperty("_lang")&&(o._lang=e._lang),o},t.version=n,t.defaultFormat=E,t.lang=function(e,n){var r;if(!e)return t.fn._lang._abbr;n?R(e,n):s[e]||U(e),t.duration.fn._lang=t.fn._lang=U(e)},t.langData=function(e){return e&&e._lang&&e._lang._abbr&&(e=e._lang._abbr),U(e)},t.isMoment=function(e){return e instanceof D},t.isDuration=function(e){return e instanceof P},t.fn=D.prototype={clone:function(){return t(this)},valueOf:function(){return+this._d},unix:function(){return Math.floor(+this._d/1e3)},toString:function(){return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._d},toJSON:function(){return t.utc(this).format("YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var e=this;return[e.year(),e.month(),e.date(),e.hours(),e.minutes(),e.seconds(),e.milliseconds()]},isValid:function(){return this._isValid==null&&(this._a?this._isValid=!q(this._a,(this._isUTC?t.utc(this._a):t(this._a)).toArray()):this._isValid=!isNaN(this._d.getTime())),!!this._isValid},utc:function(){return this._isUTC=!0,this},local:function(){return this._isUTC=!1,this},format:function(e){var n=X(this,e||t.defaultFormat);return this.lang().postformat(n)},add:function(e,n){var r;return typeof e=="string"?r=t.duration(+n,e):r=t.duration(e,n),F(this,r,1),this},subtract:function(e,n){var r;return typeof e=="string"?r=t.duration(+n,e):r=t.duration(e,n),F(this,r,-1),this},diff:function(e,n,r){var i=this._isUTC?t(e).utc():t(e).local(),s=(this.zone()-i.zone())*6e4,o,u;return n&&(n=n.replace(/s$/,"")),n==="year"||n==="month"?(o=(this.daysInMonth()+i.daysInMonth())*432e5,u=(this.year()-i.year())*12+(this.month()-i.month()),u+=(this-t(this).startOf("month")-(i-t(i).startOf("month")))/o,n==="year"&&(u/=12)):(o=this-i-s,u=n==="second"?o/1e3:n==="minute"?o/6e4:n==="hour"?o/36e5:n==="day"?o/864e5:n==="week"?o/6048e5:o),r?u:B(u)},from:function(e,n){return t.duration(this.diff(e)).lang(this.lang()._abbr).humanize(!n)},fromNow:function(e){return this.from(t(),e)},calendar:function(){var e=this.diff(t().startOf("day"),"days",!0),n=e<-6?"sameElse":e<-1?"lastWeek":e<0?"lastDay":e<1?"sameDay":e<2?"nextDay":e<7?"nextWeek":"sameElse";return this.format(this.lang().calendar(n,this))},isLeapYear:function(){var e=this.year();return e%4===0&&e%100!==0||e%400===0},isDST:function(){return this.zone()<t([this.year()]).zone()||this.zone()<t([this.year(),5]).zone()},day:function(e){var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return e==null?t:this.add({d:e-t})},startOf:function(e){e=e.replace(/s$/,"");switch(e){case"year":this.month(0);case"month":this.date(1);case"week":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return e==="week"&&this.day(0),this},endOf:function(e){return this.startOf(e).add(e.replace(/s?$/,"s"),1).subtract("ms",1)},isAfter:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)>+t(e).startOf(n)},isBefore:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)<+t(e).startOf(n)},isSame:function(e,n){return n=typeof n!="undefined"?n:"millisecond",+this.clone().startOf(n)===+t(e).startOf(n)},zone:function(){return this._isUTC?0:this._d.getTimezoneOffset()},daysInMonth:function(){return t.utc([this.year(),this.month()+1,0]).date()},dayOfYear:function(e){var n=r((t(this).startOf("day")-t(this).startOf("year"))/864e5)+1;return e==null?n:this.add("d",e-n)},isoWeek:function(e){var t=tt(this,1,4);return e==null?t:this.add("d",(e-t)*7)},week:function(e){var t=this.lang().week(this);return e==null?t:this.add("d",(e-t)*7)},lang:function(t){return t===e?this._lang:(this._lang=U(t),this)}};for(i=0;i<T.length;i++)rt(T[i].toLowerCase().replace(/s$/,""),T[i]);rt("year","FullYear"),t.fn.days=t.fn.day,t.fn.weeks=t.fn.week,t.fn.isoWeeks=t.fn.isoWeek,t.duration.fn=P.prototype={weeks:function(){return B(this.days()/7)},valueOf:function(){return this._milliseconds+this._days*864e5+this._months*2592e6},humanize:function(e){var t=+this,n=et(t,!e,this.lang());return e&&(n=this.lang().pastFuture(t,n)),this.lang().postformat(n)},lang:t.fn.lang};for(i in N)N.hasOwnProperty(i)&&(st(i,N[i]),it(i.toLowerCase()));st("Weeks",6048e5),t.lang("en",{ordinal:function(e){var t=e%10,n=~~(e%100/10)===1?"th":t===1?"st":t===2?"nd":t===3?"rd":"th";return e+n}}),o&&(module.exports=t),typeof ender=="undefined"&&(this.moment=t),typeof define=="function"&&define.amd&&define("moment",[],function(){return t})}).call(this);var MPageEntity = {
    "protocol": {},
    "generators": {},
    "entities": {}
};

/**
 * Stores configuration functions to be executed before any entity
 * is created. These configurations are executed only once. Add
 * new configurations by using the configure function:
 *
 * Entity.configure(function() {
 *   MPageEntity.meta.user = "something";
 * });
 *
 * @type {Array}
 */
MPageEntity.configurations = [];

/**
 * Adds a new function that will be executed before any entity is
 * created. Those functions will only be executed once.
 * @type {MPageEntity.XmlHttpRequest}
 */
MPageEntity.configure = function (fun) {
    MPageEntity.configurations.push(fun);
};


/**
 * Runs all the registered configurations. Will run only once.
 */
MPageEntity.startup = function () {
    if (MPageEntity.isConfigured) {
        return;
    }
    for (var i = MPageEntity.configurations.length; i--;) {
        MPageEntity.configurations[i]();
    }
    MPageEntity.isConfigured = true;
};

/**
 * Whether the configure function was executed already or not.
 * Do not change this unless you know what you are doing.
 * @type {boolean}
 */
MPageEntity.isConfigured = false;(function() {

    /**
     * Abstract class from where all the protocols will inherit.
     */
    MPageEntity.protocol.EntityProtocol = function() {
    };

    var EntityProtocol = MPageEntity.protocol.EntityProtocol;
    var prot = EntityProtocol.prototype;

    prot.generateRequestStr = function(entity, action, values) {
        throw "generateRequestStr is abstract and needs to be implemented.";
    };

    prot.handleResponseStr = function(entity, action, response) {
        throw "handleResponseStr is abstract and needs to be implemented.";
    };

    /**
     * Transforms the provided json into a json that is suitable to be passed
     * as a parameter to a CCL script.
     */
    prot.sanitizeJson = function(json) {
        var self = this;

        // quit on null
        if (json == null) { return null; }

         // check if it's a string
        if ( typeof (json) == 'string') {
            var strField = new MPageEntity.String();
            json = strField.toCcl(json);
            return json;
        }

        // check if it's an entity
        if (json.mEntityClass) {
            return json.getCclJson();
        }

        // check if it's a number
        if (json.toFixed) {
            var numField = new MPageEntity.Number();
            json = numField.toCcl(json);
            return json;
        }

        // if it gets here, then is either an array or a generic object
        $.each(json, function(k, v) {
           json[k] = self.sanitizeJson(v);
        });
        return json;
    };

    /*
     * Converts a jsonObject to a string that can be used in a request.
     * We didn't use the native stringify because the CCL service is sometimes
     * picky on what it accepts as json (ex.: ^ as string delimiters), so
     * we have to do some sanitizing.
     */
    prot.serializeJson= function(json) {
        var values = [];
        var self = this;

        // We don't like null values for our json
        if (json === null || typeof(json) == 'undefined') {
            return "''";
        }

        // Check for string and escape single quotes
        if ( typeof (json) == 'string') {
            json = json.replace("'", "\'");
            return json;
        }

        // Check for array
        if (json.push) {
            $.each(json, function(k, v) {
                values.push(self.serializeJson(v));
            });
            return "[" + values.join(",") + "]";
        }

        // Check for number
        if (json.toFixed) {
            return "'" + json + "'";
        }

        // Defaults to object if not string or array
        $.each(json, function(k, v) {
            var val = "'" + k + "':";
            val += self.serializeJson(v);
            values.push(val);
        });
        return "{" + values.join(',') + "}";
    };

})();(function() {
    var attribute = MPageOO.attribute;
    var ns = MPageEntity.protocol;

    MPageEntity.protocol.EntityProtocolError = function(msg) {
        Error.call(this, msg);
        this.name = "Entity Protocol Error";
        this.message = msg;
    };

    ns.EntityProtocolError.prototype = new Error();

})();(function () {
    var ns = MPageEntity.protocol;

    ns.EntityProtocolV1 = function() {
        ns.EntityProtocol.call(this);
    };

    ns.EntityProtocolV1.prototype = new ns.EntityProtocol();

    var prot = ns.EntityProtocolV1.prototype;

    prot.generateRequestStr = function(entity, action, values) {
        var json = {"jsonRequest": {
            "action": "'" + action + "'",
            "meta": entity.getMeta(),
            "values": values
        }};

        return this.serializeJson(json);
    };

    prot.handleResponseStr = function(entity, action, response) {
        var recordData = JSON.parse(response);

        if (recordData == null
            || recordData.RECORD_DATA == undefined
            || recordData.RECORD_DATA.VALUES == undefined) {
            throw new ns.EntityProtocolError("Response from the service does not match the entity protocol version 1");
        }

        if (recordData.RECORD_DATA.META.STATUS == "error") {
            throw new ns.EntityProtocolError(recordData.RECORD_DATA.META.STATUSMESSAGE);
        }

        if (recordData.RECORD_DATA.META.STATUS == "empty" || recordData.RECORD_DATA.VALUES.length == 0) {
            return {
                values: [],
                meta: recordData.RECORD_DATA.META
            };
        }

        var vals = recordData.RECORD_DATA.VALUES;
        if (!$.isArray(vals)) {
            vals = [vals];
        }

        return {
            values: vals,
            meta: recordData.RECORD_DATA.META
        };
    };
})();(function () {
    var ns = MPageEntity.protocol;

    /**
     * The V2 protocol accepts requests in the following format:
     *
     * request: {
     *  protocolVersion: 2,
     *  action: <string>,
     *  meta: { ... },
     *  valueCount: <integer>,
     *  values: [ {...}, ...]
     * }
     *
     * The reply follows the same format, except it is named reply.
     */
    ns.EntityProtocolV2 = function() {
        ns.EntityProtocol.call(this);
    };

    ns.EntityProtocolV2.prototype = new ns.EntityProtocol();

    var prot = ns.EntityProtocolV2.prototype;

    prot.generateRequestStr = function(entity, action, values) {
        if (!values.push) {
            values = [values];
        }

        var json = {"request": {
            "protocolVersion": 2,
            "action": "'" + action + "'",
            "meta": entity.getMeta(),
            "valueCount": values.length,
            "values": values
        }};

        return this.serializeJson(json);
    };

    prot.handleResponseStr = function(entity, action, response) {
        var resp = JSON.parse(response);

        // compatibility with CCL cnvtrectojson()
        if (resp != null && resp.RECORD_DATA) {
            resp = resp.RECORD_DATA;
        } else {
            resp = resp.REPLY;
        }

        if (resp == null || resp == undefined || resp.VALUES == undefined) {
            throw new ns.EntityProtocolError("Response from the service does not match the entity protocol version 2");
        }

        if (resp.META.STATUS == "error") {
            throw new ns.EntityProtocolError(resp.META.STATUSMESSAGE);
        }

        var vals = resp.VALUES;

        return {
            values: vals,
            meta: resp.META
        };
    };
})();MPageEntity.CodeSets = {
    "ACTIVITYTYPE": 106,
    "CATALOGTYPE": 6000,
    "CONTRIBUTORSYSTEM": 89,
    "DCPCLINICALCATEGORY": 16389,
    "LANGUAGE": 36,
    "MEDORDERTYPE": 18309,
    "NOMENCLATUREIDENTIFIERSOURCE": 12100,
    "ORDERCATALOG": 200,
    "ORDERSOURCETYPES": 6500,
    "ORDERSTATUS": 6004,
    "PHARMACYDISCONTINUETYPES": 4038,
    "PHASTOPTYPE": 4009,
    "POSITNCODE": 88,
    "PRINCIPLETYPE": 401,
    "SOURCEVOCABULARY": 400,
    "STRINGSTATUS": 12103,
    "SOURCEVOCABULARYAXIS": 15849
};(function() {
    
    var attribute = MPageOO.attribute;
    var EntityProtocolError = MPageEntity.protocol.EntityProtocolError;
    
    /**
     * Base class for any class that aims to connect to the database using the
     * entity standards. Entities make it seamless to persist data without having
     * to handle requests and responses, and by imposing a communication standard
     * that aims to facilitate relationships between tables.
     */
    MPageEntity.Entity = function () {
        MPageEntity.startup();
        this.id = null;
        Entity.meta.userId = MPageEntity.Request.user;
        Entity.meta.pprCd = MPageEntity.Request.ppr;
        Entity.meta.positionCd = MPageEntity.Request.position;
        this.setMeta(Entity.meta);
        this.setData({});
        this.setCachedEntityRelations({});
    };

    var Entity = MPageEntity.Entity;
    var prot = Entity.prototype;
    
    attribute(Entity, "CurrentRequest");

    /**
     * The name of the entity as a string
     */
    attribute(Entity, "EntityName");

    /**
     * Metadata to be sent to the service
     */
    attribute(Entity, "Meta");

    /**
     * Metadata received from the service
     */
    attribute(Entity, "ResponseMeta");

    /**
     * The actual contents of the entity
     */
    attribute(Entity, "Data");

    /**
     * Caching related entities (one-to-one and one-to-many relationships)
     */
    attribute(Entity, "CachedEntityRelations");

    // ========================================================================
    // Private Methods
    // ========================================================================

    var asyncRequest = function (action, scriptName, data, callback) {
        var self = this;
        var requestInst = this.getCurrentRequest();
        requestInst.setOnSuccess(function () {
            var resp = requestInst.getResponseStr();
            var error = null;
            var handledResp = null;

            handledResp = self.handleResponse(action, resp, function (e) {
                error = e
            });
            if (callback) {
                callback(handledResp, resp, error);
            }
        });
        requestInst.open(scriptName, data, true);
    };

    // ________________________________________________________________________

    var syncRequest = function (action, scriptName, data, callback) {
        var requestInst = this.getCurrentRequest();
        requestInst.requestStr = data; // for latter use in ScriptRunner
        requestInst.open(scriptName, data, false);
        var response = requestInst.getResponseStr();
        var error = null;
        var handled = this.handleResponse(action, response, function (e) {
            error = e
        });
        if (callback) {
            callback(handled, response, error);
        }
        return handled;
    };

    // ________________________________________________________________________



    // ========================================================================
    // Static Methods
    // ========================================================================
    
    /**
     * Static method that creates fields for an entity class 
     * @param {Object} entityClass
     * @param {Object} fields
     */
    Entity.initialize = function(entityClass, entityJson) {
        entityClass.fields = {};
        entityClass.entityJson = entityJson;
        entityClass.fieldsJson = entityJson.fields;
        entityClass.listQuals = entityJson.listQuals;
        entityClass.actions = entityJson.actions;
        
        // initializes the fields
        $.each(entityJson.fields, function(k,v) {
            v.setName(k);
            entityClass.fields[k.toUpperCase()] = v;
            v.initialize(entityClass, k);
        });

        // entityClass static methods
        entityClass.list = Entity.list;
        entityClass.supportsAction = Entity.supportsAction;
        entityClass.defaultEntityListClass = MPageEntity.EntityList;
		
        if (!entityJson.doNotRegister) {
            Entity.allEntities.push(entityClass);
        }
    };

    /**
     * By default, we use XmlHttpRequest. This can be changed at runtime
     * to XmlCclRequest if one plans to use this inside millenium apps.
     *
     * Detection of CERN_BROWSERDEV_IND or similar should not be done here.
     * Instead, detect that on the script that consumes the entities, and
     * set this variable accordingly. This improves class reusability and
     * decoupling.
     */
    Entity.defaultRequestClass = MPageEntity.XmlHttpRequest;

    /**
     * This defines what object will be used to handle the protocol - the translation
     * between values to a request string, and response string to array of values
     */
    Entity.protocol = new MPageEntity.protocol.EntityProtocolV1();

    /**
     * When set to TRUE, errors originating from CCL script calls will be thrown
     * directly to the browser/interpreter.
     */
    Entity.throwRequestErrors = true;

    /**
     * The transaction, if any, that is currently taking place.
     * @type {null}
     */
    Entity.currentTransaction = null;

    /** All entity classes created must be placed inside this variable so that
     * they can be initialized by other scripts.
     */
    Entity.allEntities = [];

    /**
     * Set to true if you want to see extra information about requests
     */
    Entity.debug = false;

    /**
     * Constants for the default actions
     * @type {string}
     */
    Entity.CCL_ERROR_STATUS = "error";
    Entity.CCL_EMPTY_STATUS = "empty";
    Entity.ACT_CREATE = "create";
    Entity.ACT_READ = "read";
    Entity.ACT_LIST = "list";
    Entity.ACT_UPDATE = "update";
    Entity.ACT_REMOVE = "remove";

    Entity.meta = {};

    // The log defaults to the console if executed standalone, or the logger,
    // when executed inside unified content. Change this to any custom logger 
    // during inclusion into the final artifact.
    Entity.log = function(msg) {
         if (typeof logger !== "undefined" && logger && logger.logMessage) {
            logger.logMessage(msg);
        } else if (typeof console !== "undefined" && console && console.log) {
            console.log(msg);    
        }
    };

    // ________________________________________________________________________
    
    /**
     * Creates an entity class called entityName in the specified namespace.
     * For example, Entity.create(MPageEntity, "Person", {...}) will create
     * the MPageEntity.Person entity class with the fields specified by the
     * "fields" parameter, and the list qualifications in array form.
     */
    Entity.create = function(namespace, entityName, entityJson) {

        // Class constructor
        namespace[entityName] = function() {
            Entity.call(this);
            this.init(namespace[entityName]);
        };
        var entityClass = namespace[entityName];
        
        // Inheritance and field initialization
        MPageOO.inherits(entityClass, Entity);
        entityClass.entityName = entityName;
        Entity.initialize(entityClass, entityJson);
    };
    
    // ________________________________________________________________________
    
    /**
     * Creates a new entity class by extending an existing base entity class.
     * The fields of the new one will be merge with the base. Equal keys will
     * be overwritten. 
     */
    Entity.extend = function(baseClass, namespace, entityName, entityJson) {

        // Class constructor
        namespace[entityName] = function() {
            baseClass.call(this);
            this.init(namespace[entityName]);
        };
        var entityClass = namespace[entityName];
        
        // Inheritance
        MPageOO.inherits(entityClass, baseClass);
        entityClass.entityName = entityName;

        // Merge the json and initialize
        entityJson.fields = $.extend({}, baseClass.entityJson.fields, entityJson.fields);
        Entity.initialize(entityClass, entityJson);
    };
    
    // ________________________________________________________________________
    
    /**
     * Creates a new entity class based on the definition (provided as a json),
     * and then sets its values according to the "values" attribute, provided as
     * a field/value map.
     *
     * @param definition the JSON definition for the entity
     * @param values a map of values
     * @returns {Entity}
     */
    Entity.createInstanceFromValues = function(definition, values) {

        // Builds only the fields present in values. If the value
        // doesn't have an equivalent field definition, it creates a String field
        var definedFields = {};
        var data = {};
        $.each(values, function(k, v) {
            if (definition.fields[k]) {
                definedFields[k] = definition.fields[k];
            } else {
                definedFields[k] = new MPageEntity.String();
            }
            data[k.toUpperCase()] = v;
        });
        definition.fields = definedFields;

        // creates the entity class
        var ns = {};
        Entity.create(ns, "TempEntity", definition);

        // instantiates the class and sets the data
        var inst = new ns.TempEntity();
        inst.setData(data);
        return inst;
    };

    // ________________________________________________________________________
    
    /*
     * DEPRECATED: use EntityProtocol.serializeJson() instead.
     *
     * Converts a jsonObject to a string that can be used in a request.
     * We didn't use the native stringify because the CCL service is sometimes
     * picky on what it accepts as json (ex.: ^ as string delimiters), so
     * we have to do some sanitizing.
     */ 
    Entity.serializeJson = function(json) {
        var p = new MPageEntity.protocol.EntityProtocol();
        return p.serializeJson(json);
    };

    // ________________________________________________________________________

    /**
     * True or false if the specified action was defined during entity creation
     */
    Entity.supportsAction = function(actionName) {

        if (!this.actions) {
            return false;
        }

        for (var i=this.actions.length; i--;) {
            if (this.actions[i] == actionName) {
                return true;
            }
        }
        return false;
    };

    // ________________________________________________________________________
    
    Entity.makeEmptyList = function() {
        return new this.defaultEntityListClass(this);
    };

    // ________________________________________________________________________

    /**
     * DEPRECATED. Use EntityProtocol's sanitize json instead.
     *
     * Remaining here just for compatibility reasons.
     */
    Entity.sanitizeJson = function(json) {
        var p = new MPageEntity.protocol.EntityProtocol();
        return p.sanitizeJson(json);

    };

    // ________________________________________________________________________

    Entity.list = function(params, callback) {
        var instance = new this();
        return instance.list(params, callback);
    };
    
    // ________________________________________________________________________
    
    Entity.action = function(actionName, params, callback) {
       var instance = new this();
       return instance.action(actionName, params, callback);  
    };
    
    // ========================================================================
    // CRUD Methods
    // ========================================================================
    prot.create = function(callback) {
        return this.action(Entity.ACT_CREATE, this, callback);
    };
    
    prot.read = function(id, callback) {
        this.clearFieldCaches();
        return this.action(Entity.ACT_READ,{"id": id}, callback);
    };
    
    prot.update = function(callback) {
        return this.action(Entity.ACT_UPDATE, this, callback);
    };
    
    prot.remove = function(callback) {
        return this.action(Entity.ACT_REMOVE,{id: this.getId()}, callback);
    };
    
    prot.list = function(params, callback) {
        return this.action(Entity.ACT_LIST, params, callback);
    };  
        
        
    // ========================================================================
    // Member Methods
    // ========================================================================
    
    /**
     * Initializes the entity class and name of the instance.
     * This method should be called in the constructor of derived
     * classes. If entityName is not provided, it will try to guess it from
     * the entityName attribute in the entityClass.
     */
    prot.init = function(entityClass, entityName) {
        var self = this;
        this.mEntityClass = entityClass;
        
        if (!entityName && entityClass.entityName) {
            this.setEntityName(entityClass.entityName);
        } else {
            this.setEntityName(entityName);
        }

        // initializes fields with null
        $.each(this.mEntityClass.fields, function(k,v) {
            self.getData()[v.getName().toUpperCase()] = null;
        });
    };
    
    // ________________________________________________________________________
    
    prot.refresh = function() {
        this.read(this.getId());
    };

    // ________________________________________________________________________

    prot.throwException = function(action, msg) {
        var out = "Entity name: " + this.entityName + "\r\n";
        out += "Action: " + action;

        if (msg.message) {
            msg.message = msg.message + "\r\n" + out;
            throw msg;
        }

        if (Entity.debug) {
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.log("EXCEPTION");
            console.log(msg);
            console.log(out);
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        }

        throw (msg + "\r\n" + out);
    };

    // ________________________________________________________________________

    /**
     * Returns the EntityProtocol used to manage this entity. Protocols can be
     * defined per entity class by setting [whateverEntity].protocol = obj
     *
     * Ex.: Person.protocol = new EntityProtocolV2();
     *
     * If a protocol is not set for an entity class, it will use the default
     * set at Entity.
     */
    prot.getProtocol = function() {
        if (!this.mEntityClass.protocol) {
            return Entity.protocol;
        }
        return this.mEntityClass.protocol;
    };

    // ________________________________________________________________________

    /**
     * Some fields might use caches for performance reasons. This forces them
     * to clean the cache.
     *
     * Example: OneToOne field will store the entity it has retrieved from the
     * relationship on the first getWhatever() function call. If you clean its
     * cache, then it will perform the query again.
     */
     prot.clearFieldCaches = function() {
        var keys = Object.keys(this.mEntityClass.fields);
        for (var i=keys.length; i--;) {
            var field = this.mEntityClass.fields[keys[i]];
            field.emptyCache(this);
        }
     };

    // ________________________________________________________________________
    
    /**
     * Returns an array of strings with all the field names for the current
     * entity 
     */
    prot.getFieldNames = function() {
        var fields = [];
        $.each(this.mEntityClass.fields, function(k, v) {
            fields.push(v.getName());
        });
        return fields;  
    };
    
    // ________________________________________________________________________
    
    /**
     * Converts all the fields of the current entity instance into a CCL 
     * compatible JSON that can be passed to the request() function 
     */
    prot.getCclJson = function() {
        var self = this;
        var result = {};
        $.each(this.mEntityClass.fields, function(k,v) {
            var fieldName = v.getName();
            result[fieldName] = v.toCcl(self.getProperty(fieldName), self);
        });
        return result;
    };
    
    // ________________________________________________________________________
    
    /**
     * Returns the value of fieldName converted to its equivalent CCL value 
     */
    prot.getCclValue = function(fieldName) {
        var field = this.mEntityClass.fields[fieldName.toUpperCase()];
        return field.toCcl(this[fieldName], this);
    };
    
    // ________________________________________________________________________
    
    /**
     * Sets the property of the entity to a specified value. This differs from
     * just assigning to data directly because it does a case insensitive
     * search for the property.
     * 
     */
    prot.setProperty = function(property, value) {
        var self = this;
        
        $.each(self.getData(), function(k,v) {
            var upperK = k.toUpperCase();
            if (upperK == property.toUpperCase()) {
                self.getData()[upperK] = value;
                return true;
            }
        });
    };
    
    // ________________________________________________________________________

    /**
     * Returns the value of a property by giving its name as a string
     */
    prot.getProperty = function(property) {
        var data = this.getData()[property.toUpperCase()];
        if (data === undefined) {
            return this.getData()[property];
        }
        return data;
    };

    // ________________________________________________________________________

    /**
     * Returns the Field instance for the specified property
     */
    prot.getField = function (property) {
        return this.mEntityClass.fields[property.toUpperCase()];
    };

    // ________________________________________________________________________

    /**
     * Updates the entity fields with the values present in the json.
     * The key names in the json must match the field names.
     *  
     * @param {Object} json
     */
    prot.updateEntity = function(json) {
        this.clearFieldCaches();
        var self = this;
        var data = this.getData();
        $.each(json, function(k,v) {
            var field = self.mEntityClass.fields[k.toUpperCase()];
            if (typeof(field) != "undefined"){
                data[k.toUpperCase()] = field.toJs(v, self);
            } else if (Entity.debug) {
              Entity.log("WARNING: Could not find field " + k + " in " + self.mEntityClass.entityName + ".");
              Entity.log("This means that the server and client entities are out of synch.");
            }
        });
    };
    
    // ________________________________________________________________________
    
    /**
     * DEPRECATED. Use handleResponse instead.
     *
     * Handles the JSON that comes back from a CCL request. 
     */
    prot.handleCclResponse = function(recordData) {
       return this.handleResponse("unknown", JSON.stringify(recordData));
    };

    // ________________________________________________________________________

    prot.handleResponse = function(action, responseStr, onError) {
        if (Entity.debug) {
            Entity.log("");
            Entity.log("RESPONSE:");
            Entity.log(responseStr);
        }

        // tells the protocol to convert the response into an array of values, and
        // calls onError if any EntityProtocolError is thrown.
        var protocol = this.getProtocol();
        var response = null;
        try {
            response = protocol.handleResponseStr(this, action, responseStr);
        } catch (e) {
            if (Entity.throwRequestErrors || !(e instanceof EntityProtocolError)) {
                this.throwException(action, e);
            }
            if (onError) {
                onError(e);
                return;
            } else {
                this.throwException(action, e);
            }
        }

        // checks if we have valid values
        var values = response.values;
        if (values === null || typeof(values) == "undefined" || typeof(values.length) == "undefined") {
            var msg = this.getEntityName() + "." + action + ": could not generate valid values";
            msg += " from the provided JSON response\r\n";
            msg += "Response: " + responseStr;
            this.throwException(action, msg);
        }

        // always update the current entity with the first value
        if (values.length) {
            this.updateEntity(values[0]);
            this.setResponseMeta(response.meta);
        }

        // generate list for all values
        var Class = this.mEntityClass;
        var ListClass = Class.defaultEntityListClass;
        var result = new ListClass(Class);
        result.setResponseMeta(response.meta);

        for (var i=0; i<values.length; i++) {
            var ent = new Class();
            ent.updateEntity(values[i]);
            ent.setResponseMeta(response.meta);
            result.push(ent);
        }
        return result;
    };
    
    // ________________________________________________________________________
    
    /**
     * Generates a standard request json with the provided action and invokes 
     * the CCL script with the same name as the current entity, such as
     * mp_ent_person.
     * 
     * If callback is provided, an asynchronous call will be performed. If not,
     * it will default to synchronous. In the later case, the result of the 
     * request will be returned.
     */
    prot.request = function(action, params, callback, async) {
        var requestInst = new Entity.defaultRequestClass();
        this.setCurrentRequest(requestInst);
        var scriptName = "mp_ent_" + this.getEntityName().toLowerCase();
        var self = this;
        
        // Create request data
        params = this.getProtocol().generateRequestStr(this, action, params);
        var data = '"mine",' + '"' + params + '"';

        if (Entity.debug) {
            Entity.log('---------------------------------------');
            Entity.log("STARTING SCRIPT REQUEST: " + scriptName);
            Entity.log("REQUEST:");
            Entity.log(params);
        }
        // Performs Asynch Request
        if (async) {
            return asyncRequest.call(this, action, scriptName, data, callback);
        }
        
        // Performs Synchronous request
        return syncRequest.call(this, action, scriptName, data, callback);
    };

    // ________________________________________________________________________

    prot.setEntityName = function(name) {
        this.mEntityName = name;
    };

    prot.getEntityName = function() {
        return this.mEntityName;
    };

    // ________________________________________________________________________
    
    /**
     * Same as request, except it does some sanitizing of the data for us.
     * If only the callback is provided, it will default to an async request,
     * unless the last parameter is set to false.
     *
     * @param {Object} action
     * @param {Object} params
     * @param {Object} callback
     */
    prot.action = function(action, params, callback, async) {

        // if the action has fields defined, we create a new
        // instance of an entity with those fields and pass as the data.
        if (this.mEntityClass.actions && this.mEntityClass.actions[action]) {
            params = Entity.createInstanceFromValues({
                doNotRegister: true,
                fields: this.mEntityClass.actions[action]
            }, params);
        }

        params = Entity.sanitizeJson(params);

        if (Entity.currentTransaction !== null) {
            Entity.currentTransaction.add({
                actionName: action,
                params: params,
                callback: callback,
                entity: this
            });
            return;
        }

        if ((async === undefined && callback) || async) {
            return this.request(action, params, callback, true);
        }
        return this.request(action, params, callback, false);
    };
    
    // ________________________________________________________________________
    
    /**
     * Automatically detects if a insert or update should be called depending
     * on whether id is null or not.
     *  
     * @param {Object} callback if provided, request will be asynchronous
     */
    prot.save = function(callback) {
        if (this.getId && this.getId() !== null) {
            this.update(callback);
        } else {
            this.create(callback);
        }
    };

    // ________________________________________________________________________

    /**
     * Copies the data from the current entity to another entity. Will not
     * fire any lazy load operations.
     */
    prot.copyTo = function(dest) {
        var data = this.getData();
        var keys = Object.keys(data);
        for (var i=keys.length; i--;) {
            dest.getData()[keys[i]] = data[keys[i]]
        }
    };

    /**
     * Sets the data of an entity to be the same as another. Will reset all
     * field caches.
     */
    var origSetData = prot.setData;
    prot.setData = function(data) {
    	// set data can be called before initialization, hence the check
		if (this.mEntityClass) {
			this.clearFieldCaches();
		}
		origSetData.call(this, data);
    };

    // ________________________________________________________________________

    /**
     * Calls the "define" action for the entity, and checks the response with
     * the fields declared for this entity. If there is any discrepancy, it
     * will return an array of strings with the names of all the discrepant fields
     * that are present on the server, but not on the client. Otherwise, it
     * will return an empty array.
     *
     * The server definition is always a subset of the client, but never the
     * opposite. In other words, all the fields in the server have to be
     * contained into the client, but not all fields in the client need to
     * be declared in the server.
     *
     * This is due to the fact that some client fields are dynamically
     * generated, or customized by the developer.
     */
    prot.validateFields = function() {
        var data = this.getProtocol().generateRequestStr("define");

        if (values.length === 0) {
            return [];
        }

        var fields = this.getFieldNames();
        var notmatched = values.slice(0);

        // cycles through the server response checking if all fields are
        // present in the client
        for (var i=values.length; i--;) {
            var server = values[i];
            var matched = false;
            for (var ii=fields.length; ii--;) {
                var client = fields[ii];
                matched = (client.toUpperCase() == server.toUpperCase());
                if (matched) {
                  break;  
                } 
            }

            if (!matched) {
                notmatched.push(server);
            }
        }
        return notmatched;


    };
})();
    
(function() {
    var ns = MPageEntity;
    var attribute =  MPageOO.attribute;

    /**
     * Allows perfomring actions in a group of entities with a single request.
     * For example:
     *
     * var people = new EntityList(MPageEntity.Person);
     * people.push(person1);
     * people.push(person2);
     * people.save();
     *
     * That would call the action "saveall" on the Person entity while passing person1 and
     * person2 as action parameters. Person1 and person2 MUST be of type Person.
     *
     * EntityList inherits from Array, therefore all array methods will be available,
     * including accessors (such as people[0], people[1] ...)
     */
    ns.EntityList = function(cls) {
        if (cls) {
            this.setEntityClass(cls);
        }
        this.setMeta(null);
        this.setEntityListClass(ns.EntityList);
    };

    ns.EntityList.prototype = new Array();

    ns.EntityList.SORTING = {
        ASC: 1,
        DESC: 2
    };

    /**
     * If this EntityList is extended, this has to be set to the extended class
     * so that methods that depend on creating new lists will create the correct
     * type.
     */
    attribute(ns.EntityList, "EntityListClass");

    /**
     * The class which this entity list will operate on
     */
    attribute(ns.EntityList, "EntityClass");

    /**
     * Meta attributes that will be passed to all contained entities when performing
     * actions on a group of entities.
     */
    attribute(ns.EntityList, "Meta");

    /**
     * Meta attributes returned by the server, when this entity list was created
     * as a result of a backend call.
     */
    attribute(ns.EntityList, "ResponseMeta");

    var prot = ns.EntityList.prototype;

    // ...................................................................................

    /**
     * Returns a new instance of the entity list - or whatever EntityListClass is set to,
     * and passes the Entity class to it.
     */
    prot.makeEmptyList = function() {
        var list = new (this.getEntityListClass())();
        list.setEntityClass(this.getEntityClass());
        return list;
    };

    // ...................................................................................

    /**
     * Executes an entity action, but passes the list as the parameter so that the
     * action is taken on all entities in the list.
     */
    prot.action = function(action, callback) {
        if (this.getMeta() != null) {
            this.runMethodOnChildren("setMeta", getMeta());
        }
        var Class = this.getEntityClass();
        var inst = new Class();
        return inst.action(action, this, callback);
    };

    // ...................................................................................

    /**
     * Runs the specified method on all items in the list
     */
    prot.runMethod = function(methodName) {
        var args = [].splice.call(arguments, 1, arguments.length - 1);
        for (var i=this.length; i--;) {
            var obj = this[i];
            obj[methodName].apply(obj, args);
        }
    };

    // ...................................................................................

    /**
     * Inserts items from the specified entity array into the entity list
     */
    prot.fromArray = function(arr) {
        var self = this;
        $.each(arr, function(k,v) {
            self.push(v);
        });
    };

    // ...................................................................................

    /**
     * Returns only entities that have a property that matches a value
     */
    prot.filter = function(field, value) {
        // if the first arg is a function call filterFunction instead
        if (field.call) {
            return this.filterFunction(field);
        }

        var result = this.makeEmptyList();
        for (var i=0; i<this.length; i++) {
	    var data = this[i].getData()[field.toUpperCase()];

	    // retrieve the ID if it has it
	    data = data && data.id ? data.id : (data && data.ID ? data.ID : data);
	    
            if (data == value) {
                result.push(this[i]);
            }
        }
        return result;
    };

    // ...................................................................................

    prot.filterFunction = function(fun) {
        var result = this.makeEmptyList();
        for (var i=0; i<this.length; i++) {
            if (fun(this[i])) {
                result.push(this[i]);
            }
        }
        return result;
    };

    // ...................................................................................

    /**
     * Returns a new list where the the specified fields are matching on both sides.
     * If the fields are not set, it defaults to id.
     */
    prot.intersect = function(list, myfield, theirfield) {
        var result = this.makeEmptyList();

        if (!myfield) myfield = "id";
        if (!theirfield) theirfield = "id";
        var upperMyfield = myfield.toUpperCase();
        var upperTheirfield = theirfield.toUpperCase();
        this.each(function(i) {
            if (list.filter(theirfield, i.getData()[upperMyfield]).length > 0) {
                result.push(i);
            }
        });
        return result;
    };

    // ...................................................................................

    prot.splice = function(a, b) {
        var result = this.makeEmptyList();
        result.fromArray(Array.prototype.splice.call(this, a, b));
        return result;
    };

    // ...................................................................................

    prot.concat = function(arr) {
        var result = this.makeEmptyList();
        result.fromArray(this);
        result.fromArray(arr);
        return result;
    };

    // ...................................................................................

    /**
     * Executes a function for every item in the list
     */
    prot.each = function(f) {
        for (var i=0; i<this.length; i++) {
            f(this[i]);
        }
    };

    // ...................................................................................

    /**
     * Returns the items in this list minus the ones in the provided list, whenever the
     * specified fields match. If the name of the fields are not specified, id will be
     * used by default.
     */
     prot.subtract = function(list, myfield, theirfield) {
        var result = this.makeEmptyList();

        if (!myfield) myfield = "id";
        if (!theirfield) theirfield = "id";
        var upperMyfield = myfield.toUpperCase();
        var upperTheirfield = theirfield.toUpperCase();
        this.each(function(i) {
            if (list.filter(theirfield, i.getData()[upperMyfield]).length == 0) {
                result.push(i);
            }
        });
        return result;
     };

    // ...................................................................................

    /**
     * Either updates or creates the entities based on their id value.
     * IMPORTANT: if some entities are created and others updated, the callback will be
     * executed twice, once for each action.
     */
    prot.save = function(callback) {
        // separate entities that need update from the ones that need creation
        var needUpdate = this.makeEmptyList();
        var needCreate = this.makeEmptyList();
        for (var i=this.length; i--;) {
            var entity = this[i];
            if (entity.id === null) {
                needCreate.push(entity);
            } else {
                needUpdate.push(entity);
            }
        }

        // calls both actions separately
        if (needUpdate.length) needUpdate.action("update", callback);
        if (needCreate.length) needCreate.action("create", callback);
    };

    // ...................................................................................

    /**
     * Sorts the array list by the list specified. Will be ascending by default, or
     * descending if direction is set to EntityList.SORTING.DESC
     *
     * @param fieldName
     * @param direction
     * @return {Array.<T>|*|Array}
     */
    prot.sortBy = function(fieldName, direction) {
        if (!direction) {
            direction = ns.EntityList.SORTING.ASC;
        }

        var entityClass = this.getEntityClass();
        var ucaseFieldName = fieldName.toUpperCase();
        var field = entityClass.fields[ucaseFieldName];

        if (!field) {
            throw new Error("sortBy(): Cannot find entity field '" + fieldName + "'");
        }

        var sortFunction = function(a, b) {
            if (direction == ns.EntityList.SORTING.ASC) {
                return field.compareValues(a.getData()[ucaseFieldName], b.getData()[ucaseFieldName]);
            }
            return -1 * field.compareValues(a.getData()[ucaseFieldName], b.getData()[ucaseFieldName]);
        };

        return this.sort(sortFunction);
    };

})();
(function() {
    
    var attribute = MPageOO.attribute;
    
    MPageEntity.Field = function() {
        
    };
    
    /**
     * The name of the field. 
     */
    attribute(MPageEntity.Field, "Name");

    var prot = MPageEntity.Field.prototype;
    
    prot.toCcl = function(val, entity) {
        return val;
    };
    
    prot.toJs = function(val, entity) {
        return val;
    };
    
    prot.initialize = function(entityClass, fieldName) {
        // creates the getter field for lazy loading
        var ucaseField = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
        entityClass.prototype["get" + ucaseField] = function(){
            return this.getData()[fieldName.toUpperCase()];
        };
        entityClass.prototype["set" + ucaseField] = function(value){
            this.getData()[fieldName.toUpperCase()] = value;
        }
        return;  
    };
    
    prot.getEntityClass = function() {
        if (typeof(this.m_EntityClass) != 'string') {
            return this.m_EntityClass;
        }
        
        // if it is a string, then try to resolve it
        var className = this.m_EntityClass;
        var pieces = this.m_EntityClass.split(".");
        var obj = window[pieces[0]];
        for (var i = 1; i < pieces.length; i++) {
            obj = obj[pieces[i]];
        }
        this.m_EntityClass = obj;

        if (obj == undefined || obj == null) {
            throw new Error("The following class could not be resolved: " + className);
        }

        return obj;
      
    };
    
    prot.setEntityClass = function(entityClass) {
        if (entityClass === null || entityClass === undefined) {
            throw "The entity class for this field is" +
                  " undefined. If you want to associate to a class that" +
                  " has not yet been loaded, use a string to declare" +
                  " it, such as 'MPageEntity.Person'";
            return;
        }
        this.m_EntityClass = entityClass;
    };

    prot.emptyCache = function(entityInstance) {
        // Abstract.
    };

    /**
     * Returns 1 if a comes before b, -1 if b comes before a, and 0 if they are equal.
     * This is used inside sorting functions. Can and should be overriden for the
     * different field types.
     */
    prot.compareValues = function(a, b) {
        if (a == b) {
            return 0;
        }
        if (a > b) {
            return 1;
        }
        if (a < b) {
            return -1;
        }
    };

})();
(function() {
    
    var attribute = MPageOO.attribute;
    
    MPageEntity.Request = function(xmlHttpRequestInstance) {
        var self = this;
        
        this.setRequestInstance(xmlHttpRequestInstance);
        this.getRequestInstance().onreadystatechange = function() {
            self.handleStateChange();
        };
        this.setOnReadyStateChange(function() {});
        this.setOnSuccess(function(){});
    };
    
    var Request = MPageEntity.Request;
    
    // Called globally for all requests
    Request.onOpen = function(requestInstance) {};
    Request.onSuccess = function(requestInstance) {};
	Request.userId = 0;
	Request.pprCd = 0;
    Request.positionCd = 0;
    Request.encounterId = 0;
    Request.personId = 0;

	Request.cclGroup = null;

    // Static members
    Request.LOG_AS_FILE_NAME = "mpage_entity/core/request.js";
    Request.LOG_AS_FUNCTION = "open";

    attribute(Request, "RequestInstance");
    attribute(Request, "OnReadyStateChange");
    attribute(Request, "OnSuccess");
    attribute(Request, "Data");
    attribute(Request, "Asynch");
    attribute(Request, "Url");
	
	// ________________________________________________________________________
    
    var prot = MPageEntity.Request.prototype;
    
    prot.open = function(url, data, isAsynch) {
        this.setUrl(url);
        this.setData(data);
        this.setAsynch(isAsynch);
        this.logRequestOpen();
        Request.onOpen(this);
    };
    
	// ________________________________________________________________________
	
    prot.getJsonResponse = function() {
        return JSON.parse(this.getResponseStr());
    };

    // ________________________________________________________________________

    prot.getResponseStr = function() {
        return this.getRequestInstance().responseText;
    };
    
	// ________________________________________________________________________
	
    prot.handleStateChange = function() {
        var reqInstance = this.getRequestInstance();
        
        this.getOnReadyStateChange()();
        
        if (reqInstance.readyState == 4 && reqInstance.status == 200) {
            this.logSuccess();
            this.handleSuccess();
        } else if (reqInstance.readyState == 4) {
            this.logError();
            throw new Error("Entity request failed. HTTP status: "
              + reqInstance.status + ". Response: " + reqInstance.responseText);
        }
    };

    // ________________________________________________________________________

    prot.logError = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logErrors) {
            logger.logErrors(["Entity Request Error: ",
                                "Script: " + this.getUrl(),
                                "Request: " + this.getData(),
                                "Status: " + request.status,
                                "Response: " + request.responseText]);
        }
    };

    // ________________________________________________________________________
    
    prot.logRequestOpen = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logMessages) {
            logger.logMessages(["Entity Request Start: ",
                                "Script: " + this.getUrl(), 
                                "Request: " + this.getData()]);
        }
    };

    // ________________________________________________________________________

    prot.logSuccess = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logMessages) {
            logger.logMessages(["Entity Request Success: ",
                                "Script: " + this.getUrl(), 
                                "Request: " + this.getData(),
                                "ReadyState: " + request.readyState,
                                "Status: " + request.status,
                                "Response: " + request.responseText]);
        }
    };

	// ________________________________________________________________________
    
    prot.handleSuccess = function() {
        Request.onSuccess(this);
        this.getOnSuccess()();
    };
    
})();
var MPageScriptRunner = MPageScriptRunner ? MPageScriptRunner : {};

(function() {
    
    var attribute = MPageOO.attribute;
    
    MPageScriptRunner.ScriptRunner = function() {
        // --------------------------------------------------------------------
        // Sets up the templates
        // --------------------------------------------------------------------
        var te = TemplateEngine;
        var div = te.tag("div");
        var li = te.tag("li");
        var a = te.tag("a")
        
        this.templates = new TemplateEngine.TemplateFactory({
           message: function(context) {
            return li({"class":"message " + context.loadingClass,"id":context._elementId},
                div({"class":"ccl-script-name"}, context.url),
                div({"class":"ccl-action"}, context.action),
                div({"class":"ccl-request"}, context.request),
                div({"class":"ccl-response"},"&nbsp;")   
            );       
           },
           
           listItem: function(context) {
            return li({"class":"script-item","id":context._elementId},
                a({"class":"ccl-script-name"}, context.name)                   
            );       
           }
        });
        
        this.setFailClass("fail");
        this.setLoadingClass("loading");
        this.setSuccessClass("success");
    };
    
    var ScriptRunner = MPageScriptRunner.ScriptRunner;
    
    ScriptRunner.msgCount = 0;
    
    attribute(ScriptRunner, "ElScriptList");
    attribute(ScriptRunner, "ElLoadedScriptName");
    attribute(ScriptRunner, "ElLoadedScriptDesc");
    attribute(ScriptRunner, "ElRunScriptBtn");
    attribute(ScriptRunner, "ElMessagesContainer");
    attribute(ScriptRunner, "DefaultMessageTemplate");
    attribute(ScriptRunner, "FailClass");
    attribute(ScriptRunner, "LoadingClass");
    attribute(ScriptRunner, "SuccessClass");
    attribute(ScriptRunner, "ScriptListCtrl");
    
    var prot = MPageScriptRunner.ScriptRunner.prototype;
    
    prot.init = function() {
        var self = this;
        
        // --------------------------------------------------------------------
        // Request events
        // --------------------------------------------------------------------
        MPageEntity.Request.onOpen = function(reqInst) {
            self.onRequestOpen(reqInst);
        };
        
        MPageEntity.Request.onSuccess = function(reqInst) {
            self.onRequestSuccess(reqInst);
        };
        
        // --------------------------------------------------------------------
        // Script list control
        // --------------------------------------------------------------------
        var list = new MPageControls.List(this.getElScriptList());
        list.setItemTemplate(this.templates.listItem);
        list.setOnSelect(function() {
            self.loadScript(list.getSelectedItem());
        });
        this.setScriptListCtrl(list);
    };
    
    prot.readScripts = function(scriptsArr) {
        this.getScriptListCtrl().renderItems(scriptsArr);
    };
    
    prot.loadScript = function(scriptJson) {
        var self = this;
        
        this.getElLoadedScriptName().html(scriptJson.name);
        this.getElLoadedScriptDesc().html(scriptJson.description);
        this.getElRunScriptBtn().click(function() {
            self.run(scriptJson);
        });
    };
    
    prot.run = function(scriptJson) {
        this.clearMessages();
        scriptJson.action(this);
    };
    
    prot.clearMessages = function() {
        this.getElMessagesContainer().empty();
    };
    
    prot.onRequestOpen = function(requestInstance) {
        var elId = "script_runner_msg_" + ScriptRunner.msgCount;
        ScriptRunner.msgCount++;
        requestInstance._elementId = elId;
        
        /*this.message({
            _elementId: elId,
            loadingClass: this.getLoadingClass(),
            url: requestInstance.getUrl(),
            action: requestInstance.requestJson.jsonRequest.action,
            request: requestInstance.getData()
        }, this.templates.message); */
    };
    
    prot.onRequestSuccess = function(requestInstance) {
        /*var reqEl = $("#" + requestInstance._elementId);
        var requestEl = reqEl.find(".ccl-request");
        var responseEl = reqEl.find(".ccl-response");
        
        requestEl.html(requestInstance.getData());
        responseEl.html(requestInstance.getRequestInstance().responseText);
        reqEl.removeClass(this.getLoadingClass());
        
        var jsonResponse = requestInstance.getJsonResponse();
        
        if (jsonResponse.RECORD_DATA && jsonResponse.RECORD_DATA.META &&
            jsonResponse.RECORD_DATA.META.STATUS == MPageEntity.Entity.CCL_ERROR_STATUS) {
            reqEl.addClass(this.getFailClass());
            return;
        }
        
        reqEl.addClass(this.getSuccessClass()); */
    };
    
    prot.message = function(context, template) {
        var msgc = this.getElMessagesContainer();
        msgc.append(template.render(context));
    };
})();
    (function() {
    var Entity = MPageEntity.Entity;

    MPageEntity.Transaction = function() {
        this.queue = {};
        this.mActionsLength = 0;
        this.isEmpty = true;
    };

    // ...................................................................................

    MPageEntity.Transaction.Action = function(act, params, callback, ent) {
        this.actionName = act;
        this.params = params;
        this.callback = callback;
        this.entity = ent;
    };

    var prot = MPageEntity.Transaction.prototype;

    // ...................................................................................

    /**
     * Anything executed within the track() method will be intercepted as a single
     * transaction.
     *
     * @param {function} The logic that manipulates entities and which will be intercepted
     *                   by the transaction.
     */
    prot.track = function(fun) {
        var oldtr = Entity.currentTransaction;
        MPageEntity.Entity.currentTransaction = this;
        fun();
        MPageEntity.Entity.currentTransaction = oldtr;
    };

    // ...................................................................................

    /**
     * Adds the provided Transaction.Action object into the queue so that action can be
     * executed when calling commit().
     *
     * @param {Transaction.Action} The Transaction.Action instance to be queued
     */
    prot.add = function(actionJson) {
        var entityName = actionJson.entity.mEntityName;
        var actName = actionJson.actionName;
        this.isEmpty = false;

        // Check if we have an entry in the queue for the entity
        if (this.queue[entityName] === undefined) {
            this.queue[entityName] = {};
        }

        // Check if we have an entry in the queue for the entity action
        var act = this.queue[entityName][actName];
        if (act === undefined) {
            act = {};
            this.queue[entityName][actName] = act;
            act.params = [];
            act.callbacks = [];
            act.entities = [];
            this.mActionsLength++;
        }

        // Add the action to the queue
        act.params.push(actionJson.params);
        act.callbacks.push(actionJson.callback);
        act.entities.push(actionJson.entity);
    };

    // ...................................................................................

    prot.commit = function(callback, isAsync) {
        var errors = [];
        var pendingRequests = this.mActionsLength;
        
        if(this.isEmpty){
            callback(errors);
        }

        var commitCallback = function(entities, values, error) {
            pendingRequests--;
            if (error != null) {
                errors.push(error);
            }
            if (pendingRequests == 0 && callback) {
                callback(errors);
            }
        };

        var ents = Object.keys(this.queue);
        for (var i=ents.length; i--;) {
            var entName = ents[i];
            var actions = Object.keys(this.queue[entName]);
            for (var ii=actions.length; ii--;) {
                var action = actions[ii];
                isAsync = (isAsync === undefined && callback) || isAsync;
                this.commitSingle(entName, action, commitCallback, isAsync);
            }

        }
    };

    // ...................................................................................

    prot.commitSingle = function(entityName, action, callback, isAsync) {
        var Cls = this.queue[entityName][action].entities[0].mEntityClass;
        var inst = new Cls();
        var self = this;

        var commitSingleCallback = function(handledResp, resp, error) {
            var respJson = inst.getProtocol().handleResponseStr(inst, action, resp);
            var values = respJson.values;
            for (var i=values.length; i--;) {
                self.queue[entityName][action].entities[i].updateEntity(values[i]);
            }
            if (callback) {
                callback(self.queue[entityName][action].entities, values, error);
            }
        };

        var params = this.queue[entityName][action].params;

        // if async is not defined but we have a callback, default to true
        isAsync = ((isAsync === undefined && callback) || isAsync);

        return inst.request(action, params, commitSingleCallback, isAsync);
    };

})();
(function() {
    var attribute = MPageOO.attribute;
    var inherits = MPageOO.inherits;
    
    MPageEntity.XmlCclRequest = function() {
        MPageEntity.Request.call(this, new XMLCclRequest());
    };
    
    inherits(MPageEntity.XmlCclRequest, MPageEntity.Request);
    
    var prot = MPageEntity.XmlCclRequest.prototype;

    prot.open = function(url, data, isAsynch) {
       MPageEntity.Request.prototype.open.call(this, url, data, isAsynch);
       var reqInst = this.getRequestInstance();

       if (MPageEntity.Request.cclGroup) {
            url = url + ":" +  MPageEntity.Request.cclGroup;
       }

       reqInst.open("GET", url, isAsynch);
       reqInst.send(data);
       
       if (!isAsynch && reqInst.readyState == 4 && reqInst.status == 200) {
            this.handleSuccess();
       }
    };
})();
(function() {
    var attribute = MPageOO.attribute;
    var inherits = MPageOO.inherits;
    
    MPageEntity.XmlHttpRequest = function() {
        MPageEntity.Request.call(this, new XMLHttpRequest());
    };
    
    inherits(MPageEntity.XmlHttpRequest, MPageEntity.Request);
    
    MPageEntity.XmlHttpRequest.baseUrl = "";
    
    var prot = MPageEntity.XmlHttpRequest.prototype;
    
    prot.open = function(scriptName, data, isAsynch) {
       MPageEntity.Request.prototype.open.call(this, scriptName, data, isAsynch);
       var reqInst = this.getRequestInstance();
       
       var url = MPageEntity.XmlHttpRequest.baseUrl + scriptName + "?parameters=" + data; 
       
       reqInst.open("GET", url, isAsynch);
       reqInst.send(null);
       
       if (!isAsynch && reqInst.readyState == 4 && reqInst.status == 200) {
            this.handleSuccess();
       }
    };
})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    
    var getIdFromData = function(data) {
	return data && data.id ? data.id
	       : (data && data.ID ? data.ID : data);
    }
    
    MPageEntity.OneToOne = function(entityClass, options) {
        this.setEntityClass(entityClass);
        this.setDefaultValue(0);
        this.setSendFullObject(false);
        
        if (options && !options.toFixed && !options.substr) {
            this.loadOptionsFromJson(options);
        }
        else if (options) {
            this.setDefaultValue(options);
        }
    };
    
    inherits(MPageEntity.OneToOne, MPageEntity.Field);

    /**
     * The value to be returned if the field is not populated
     */
    attribute(MPageEntity.OneToOne, "DefaultValue");

    /**
     * When set to true, sends the serialized entity in the request
     * instead of sending just the ID.
     */
    attribute(MPageEntity.OneToOne, "SendFullObject");

    var prot = MPageEntity.OneToOne.prototype;

    // ________________________________________________________________________
    
    prot.toCcl = function(val, entity) {

        // send the full json if the sendFullObject is true
        if (this.getSendFullObject()) {
            return this.getForeignJson(entity);
        }

        // if it's null, then just return the default value
        if (val === undefined || val === null) {
            return "'" + this.getDefaultValue().toFixed() + "'";
        }
        
        // value is a number
        if (val.toFixed) {
            var numberField = new MPageEntity.Number();
            return numberField.toCcl(val);
        }
        
        // value is a string
        if (typeof(val) == 'string') {
            var stringField = new MPageEntity.String();
            return stringField.toCcl(val);
        }
        
	// value is a JSON with an ID field
	var dataId = getIdFromData(val);
	if (dataId !== null) {
		var numberField = new MPageEntity.Number();
		return numberField.toCcl(dataId);
	}

        // anything else, return the default value
        return "'" + this.getDefaultValue().toFixed() + "'";
    };

    // ________________________________________________________________________

    /**
     * Returns the JSON representation of the foreign entity instance
     */
    prot.getForeignJson = function(entity) {
        var foreignEntity = entity.getCachedEntityRelations()[this.getName() + "_entity"];
        if (!foreignEntity) {
            throw new Error("The " + entity.getEntityName() + " entity requires the '"
                + this.getName() + "' field to be filled with an instance of '"
                + this.getEntityClass().entityName + "'");
        }
        return foreignEntity.getCclJson();
    };
    
	prot.createCachedInstance = function(val, entity) {
		var foreignEntity = new(this.getEntityClass())();
		foreignEntity.updateEntity(val);
		entity.getCachedEntityRelations()[this.getName() + "_entity"] = foreignEntity;
		return foreignEntity;
	};

    // ________________________________________________________________________
    
    prot.toJs = function(val, entity) {
        
        // We have lazy loading going on. In this case
        // we'll return the id and let the getter handle
        // the actual loading of the object.
        if (typeof(val) == 'string') {
            var numberField = new MPageEntity.Number();
            return numberField.toJs(val);
        }
        
        // We already have the data. Create the entity, and cache the result
		this.createCachedInstance(val, entity);
        
		var foreignEntity = new (this.getEntityClass())();
        foreignEntity.updateEntity(val);
        entity.getData()[this.getName() + "_entity"] = foreignEntity;
        
        return foreignEntity.getId();
    };
    
    // ________________________________________________________________________

    /**
     * Parses the options JSON and sets internal attributes accordingly.
     */
    prot.loadOptionsFromJson = function(json) {
        if (json.sendFullObject) {
            this.setSendFullObject(json.sendFullObject);
        }
        if (json.defaultValue) {
            this.setDefaultValue(json.defaultValue);
        }
    };

    // ________________________________________________________________________
    
    prot.initialize = function(entityClass, fieldName) {
        var self = this;
        var ucaseField = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
        this.m_fieldName = fieldName;

        // --------------------------------------------------------------------
        // Getter
        // --------------------------------------------------------------------
        entityClass.prototype["get"+ucaseField] = function(callback) {
          var cachedRelatedEntites = this.getCachedEntityRelations();
          var data = this.getData();
			var fieldData = data[fieldName.toUpperCase()];

          // return cached entity if present in cache
          if (cachedRelatedEntites[fieldName + "_entity"]) {
              return cachedRelatedEntites[fieldName + "_entity"];
          }

			// create a cached one if we have data for it
			if (fieldData && !fieldData.toFixed) {
				return self.createCachedInstance(fieldData, this);
			}

			// nulls shall return nulls
			if (fieldData === null) {
				return fieldData;
			}

			// lazy load as a last resource
          var entity = new (self.getEntityClass())();
          entity.read(this.getData()[fieldName.toUpperCase()], callback);
          cachedRelatedEntites[fieldName + "_entity"] = entity;
          return entity;
      };

        // --------------------------------------------------------------------
        // Setter
        // --------------------------------------------------------------------
        entityClass.prototype["set"+ucaseField] = function(value) {
            var cachedRelatedEntites = this.getCachedEntityRelations();
            var data = this.getData();
            //Update the value in the related entity cache
            cachedRelatedEntites[fieldName + "_entity"] = value;
            //Update the data cache
            if (value.getId){
                data[fieldName.toUpperCase()] = value.getId();
            }
            else if (value.id){
                data[fieldName.toUpperCase()] = value.id;
            }
        };
        // Add corresponding primitive getters and setters
        entityClass.prototype["get" + ucaseField + "Value"] = function(){
			var data = this.getData()[fieldName.toUpperCase()];
			return getIdFromData(data); 
        };
        entityClass.prototype["set" + ucaseField + "Value"] = function(value){
            this.getData()[fieldName.toUpperCase()] = value;
        }

    };

    prot.emptyCache = function(entity) {
        entity.getCachedEntityRelations()[this.m_fieldName + "_entity"] = null;
    };
    
})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.CclBool = function() {
    };
    
    inherits(MPageEntity.CclBool, MPageEntity.Field);
    
    var prot = MPageEntity.CclBool.prototype;
    
    prot.toCcl = function(val) {
        if (val === true) {
            return "'1'";
        }
        return "'0'";
    };
    
    prot.toJs = function(val) {
        if (val === "1") {
            return true;
        }
        return false;
    };
    
})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;

    MPageEntity.CodeValueField = function(codeSetId) {
		MPageEntity.OneToOne.call(this, "MPageEntity.CodeValue");
		this.codeSetId = codeSetId;
		this.codeSet = null;
    };
    
    MPageEntity.cachedCodeValues = {};
    
    inherits(MPageEntity.CodeValueField, MPageEntity.OneToOne);

    var prot = MPageEntity.CodeValueField.prototype;
    
    // ________________________________________________________________________

    prot.getCodeSet = function() {
        if (this.codeSet != null) {
            return this.codeSet;
        }

        this.codeSet = new MPageEntity.CodeSet();
        this.codeSet.read(this.codeSetId);
    };

    // ________________________________________________________________________

    prot.listCodeValues = function() {
        return this.getCodeSet().getCodeValues();
    };

})();
(function() {

    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    var ns = MPageEntity;

    /**
     * A field which gets automatically updated based on the values of other fields.
     * Useful for utilizing in entities that have a composite primary key.
     * Note that the field itself only gets update during a reply, but never a request.
     *
     * @param {fieldNames} An array of strings with the names of the fields of the entity
     */
    ns.Composite = function(fieldNames) {
        this.setFieldNames(fieldNames);
    };

    inherits(ns.Composite, ns.Field);
    attribute(ns.Composite, "FieldNames");

    var prot = ns.Composite.prototype;

    // ..................................................................................

    prot.toCcl = function(val, ent) {
        var result = {};

        if (val == null) return result;

        $.each(this.getFieldNames(), function(i, fieldName) {
            var field = ent.mEntityClass.fields[fieldName.toUpperCase()];
            result[fieldName] = field.toCcl(val[fieldName], ent);
        });
        return result;
    };

    // ..................................................................................

    /**
     * Will ignore any values returned in the value field and use the entity values.
     */
    prot.toJs = function(val, ent) {
        var result = {};
        $.each(this.getFieldNames(), function(i, fieldName) {
            var field = ent.mEntityClass.fields[fieldName.toUpperCase()];
            result[fieldName] = field.toJs(val[fieldName], ent);
        });
        return result;
    };

    // ..................................................................................


})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    
    MPageEntity.DateTime = function(format) {
        if (format) {
            this.setFormat(format);
        } else {
            this.setFormat("DD-MMM-YYYY HH:mm:ss");
        }
    };
    
    var DateTime = MPageEntity.DateTime;
    
    inherits(DateTime, MPageEntity.Field);
    attribute(DateTime, "Format");
    
    var prot = DateTime.prototype;
    
    prot.toCcl = function(val) {
        if (val === undefined || val === null || val == "") {
            return "'0'";
        }
        
        // if it's a string, try to parse it to date
        if (typeof val == "string") {
            val = this.toJs(val);
        }
        
        return "'" + moment(val).format(this.getFormat()).toUpperCase() + "'";
    };
    
    prot.toJs = function(val) {
        var valMoment = moment(val, this.getFormat());
        if (valMoment === null) {
            return null;
        }
        
        return valMoment.toDate();
    };
    

})();
(function() {

    var inherits = MPageOO.inherits;

    MPageEntity.EncodedString = function() {};

    inherits(MPageEntity.EncodedString, MPageEntity.Field);

    var prot = MPageEntity.EncodedString.prototype;

    prot.toCcl = function(val) {
        if (val === null || val === undefined) {
            val = "";
        }
        //Ensure string delimiters are html-encoded before being sent to ccl
        val = val.replace(/%/g, "%25");
        var encoded = val.replace(/[\/\\~'"<^&#\r\n]/g, function(m){
            var charCode = m.charCodeAt(0).toString(16).toUpperCase();
            if (charCode.length < 2) {
                charCode = "0" + charCode;
            }
            return "%" + charCode;
        });

        return "'" + encoded + "'";
    };

    /**
     * Ensures html-encoded characters are decoded on the javascript side
     *
     * @param val
     * @return {String}
     */
    prot.toJs = function(val) {
         var decoded = val;
         try {
            decoded = val.replace(/%([0-9A-F]{2})/g, function(m, n) {
                var code = parseInt(n, 16);
                return String.fromCharCode(code);
            });
        }
        catch(e){
            return decoded; 
        }
        return decoded;
    };


})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    
    /**
     * The iso8601 has been copied here to avoid dependency on locale.js.
     * It also avoids forcing consumers to polute the global Date scope, as
     * is necessary with the current summary/workflow locale.js definition.
     */
    var setISO8601 = function(targetdate, string) {
        var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\.([0-9]+))?)?Z?)?)?)?";
        var d = string.match(new RegExp(regexp));
        var date = new Date(d[1], 0, 1);
        if (d[7]) {
            date.setUTCHours(d[7]);
        } else {
            date.setUTCHours(0);
        } if (d[8]) {
            date.setUTCMinutes(d[8]);
        } else {
            date.setUTCMinutes(0);
        } if (d[10]) {
            date.setUTCSeconds(d[10]);
        } else {
            date.setUTCSeconds(0);
        } if (d[12]) {
            date.setUTCMilliseconds(Number("0." + d[12]) * 1000);
        } else {
            date.setUTCMilliseconds(0);
        } if (d[1]) {
            date.setUTCFullYear(d[1]);
        }
        if (d[5]) {
            date.setUTCDate(d[5]);
        }
        if (d[3]) {
            date.setUTCMonth(d[3] - 1);
        }
        targetdate.setTime(date.getTime());
    };


    MPageEntity.Iso8601DateTime = function() {};
    
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    
    inherits(Iso8601DateTime, MPageEntity.Field);
    
    var prot = Iso8601DateTime.prototype;
    
    prot.toCcl = function(val) {
        if (val === undefined || val === null || val == "") {
            return "'0'";
        }
        
        // if it's a string, try to parse it to date
        if (typeof val == "string") {
            val = this.toJs(val);
        }
        if (!val.toISOString) {
            (function () {
                function f(n) {
                    // Format integers to have at least two digits.
                    return n < 10 ? '0' + n : n;
                }
                Date.prototype.toISOString = function(){
                    return this.getUTCFullYear()   + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z';
                };
            }());
       }
        
        return "'" + val.toISOString() + "'";
    };
    
    prot.toJs = function(val) {
        if (val == "" || val == "0") {
            return null;
        }

        var d = new Date();
        setISO8601(d, val);
        return d;
    };
    
})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.Number = function(precision, defaultValue) {
        if (!precision) {
            precision = 4;
        }
        this.precision = precision;
        this.defaultValue = defaultValue;
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
    };
    
    inherits(MPageEntity.Number, MPageEntity.Field);
    
    var prot = MPageEntity.Number.prototype;
    
    prot.toCcl = function(val) {
		
        if (val === null || val === undefined) {
			if (this.defaultValue !== undefined) {
				val = this.defaultValue;
			} else {
				val = 0;
			}
        }
        
		if (val.toFixed) {
			return "'" + val.toFixed(this.precision) + "'";
		}
		return "'" + val + "'";
    };
    
    prot.toJs = function(val) {
        var num = parseFloat(val);
        if (isNaN(num)) {
            return null;
        }
        return num;
    };
    

})();
(function() {
	var inherits = MPageOO.inherits;
	var attribute = MPageOO.attribute;

	MPageEntity.OneToMany = function(entityClass, listField) {
		this.setEntityClass(entityClass);
		this.setListField(listField);
	};

	inherits(MPageEntity.OneToMany, MPageEntity.Field);
	attribute(MPageEntity.OneToMany, "ListField");

	var prot = MPageEntity.OneToMany.prototype;

	prot.toCcl = function(val) {
	    
	    // if it's not an array, return nothing
	    if (val === null || !(val.push)) {
	        return "''";
	    }
	    
		var result = [];
		$.each(val, function(i, entity) {
      if (entity.getCclValue) {
        result.push(entity.getCclValue("id"));
      } else if (entity.id) {
        result.push(entity.id);
      }
    });
		return result;
	};

	// ________________________________________________________________________

	prot.toJs = function(val, ent) {
		var result = [];
		var self = this;

		if (val.length === 0) {
			return result;
		}

		return val;
	};

	// ________________________________________________________________________

	prot.initialize = function(entityClass, fieldName) {
		var self = this;

		// creates the getter field for lazy loading
		var ucaseField = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
		entityClass.prototype["get" + ucaseField] = function(callback) {
			var data = this.getData();
			var cachedRelatedEntites = this.getCachedEntityRelations();
			//Return cached entities if present in cache
			if (cachedRelatedEntites[fieldName + "_entities"]) {
				return cachedRelatedEntites[fieldName + "_entities"];
			}
			var upperName = self.getName().toUpperCase();
            // if we have an array, convert them to entities
            if (data[upperName] && data[upperName].push) {

                var cls = self.getEntityClass();
                if (cls == undefined || cls == null) {
                    throw "The field \"" + self.getName() + "\" for the " + ent.mEntityName +
                    " entity is invalid: could not find the many to many class";
                }
                var result = new MPageEntity.EntityList(cls);

                $.each(data[fieldName.toUpperCase()], function(i, entityJson) {
                    var entity = new cls();
                    entity.updateEntity(entityJson);
                    result.push(entity);
                });
                cachedRelatedEntites[fieldName + "_entities"] = result;
                return result;
            }

            // if it gets here, we lazy load them
			var entity = new (self.getEntityClass())();
			var selfEntity = this;
            var qualification = {};
            qualification[self.getListField()] = this.getId(); 

			if (callback) {
				entity.list(qualification, function(entities, response) {
					cachedRelatedEntites[fieldName + "_entities"] = entities;
					callback(entities, response);
				});
				return;
			}

			var entities = entity.list(qualification);
			cachedRelatedEntites[fieldName + "_entities"] = entities;
			return entities;
		};

		entityClass.prototype["set" + ucaseField] = function(value) {
			var cachedRelatedEntites = this.getCachedEntityRelations();
			cachedRelatedEntites[fieldName + "_entities"] = value;
		};
	};

    prot.emptyCache = function(instance) {
      instance.getCachedEntityRelations()[this.getName() + "_entities"] = null;
    };
})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.SelfOneToMany = function(listField) {
        this.setListField(listField);
    };
    
    inherits(MPageEntity.SelfOneToMany, MPageEntity.OneToMany);
    
    var prot = MPageEntity.SelfOneToMany.prototype;
    
    prot.initialize = function(entityClass, fieldName) {
        this.setEntityClass(entityClass);
        OneToMany.prototype.initialize.call(this, entityClass, fieldName);
        
    };
})();

(function() {
    var inherits = MPageOO.inherits;
    var OneToOne = MPageOO.OneToOne;
    
    MPageEntity.SelfOneToOne = function() {
        this.setEntityClass(entityClass);
    };
    
    inherits(MPageEntity.SelfOneToOne, MPageEntity.OneToOne);
    
    var prot = MPageEntity.SelfOneToOne.prototype;
    
    prot.initialize = function(entityClass, fieldName) {
        this.setEntityClass(entityClass);
        OneToOne.prototype.initialize.call(this, entityClass, fieldName);
        
    };
})();(function() {
    
    var inherits = MPageOO.inherits;
    
    MPageEntity.String = function() {
        
    };
    inherits(MPageEntity.String, MPageEntity.Field);
    
    var prot = MPageEntity.String.prototype;

    prot.toCcl = function(val) {
        if (val === null || val === undefined) {
            val = "";
        }
        
        return "'" + val + "'";
    };
    
    prot.toJs = function(val) {
        return val;
    };

})();
(function() {
	MPageEntity.BedrockConfig = function() {
		var thisVisitVocab = 0;
		var chronicVocab = 0;
		var defaultSearchVocab = 0;
		var diagnosisClassification = 0;
		var diagnosisConfirmation = 0;
		var problemClassification = 0;
		var problemConfirmation = 0;
		var diagnosisType = 0;
		var infoButtonInd = 0;
		var modifyInd = 0;
		var problemListFlag = 2;

		this.getProblemListFlag = function(){
			return problemListFlag;
		};

		this.setProblemListFlag = function(value){
			problemListFlag = value;
		};

		this.getDefaultSearchVocab = function() {
			return defaultSearchVocab;
		};

		this.setDefaultSearchVocab = function(value) {
			defaultSearchVocab = value;
		};

		this.getThisVisitVocab = function() {
			return thisVisitVocab;
		};

		this.setThisVisitVocab = function(value) {
			thisVisitVocab = value;
		};

		this.getChronicVocab = function() {
			return chronicVocab;
		};

		this.setChronicVocab = function(value) {
			chronicVocab = value;
		};

		this.getDiagnosisClassification = function() {
			return diagnosisClassification;
		};

		this.setDiagnosisClassification = function(value) {
			diagnosisClassification = value;
		};

		this.getDiagnosisConfirmation = function() {
			return diagnosisConfirmation;
		};

		this.setDiagnosisConfirmation = function(value) {
			diagnosisConfirmation = value;
		};

		this.getProblemClassification = function() {
			return problemClassification;
		};

		this.setProblemClassification = function(value) {
			problemClassification = value;
		};

		this.getProblemConfirmation = function() {
			return problemConfirmation;
		};

		this.setProblemConfirmation = function(value) {
			problemConfirmation = value;
		};

		this.getDiagnosisType = function() {
			return diagnosisType;
		};

		this.setDiagnosisType = function(value) {
			diagnosisType = value;
		};

		this.getInfoButtonInd = function() {
			return infoButtonInd;
		};

		this.setInfoButtonInd = function(value) {
			infoButtonInd = value;
		};

		this.setModifyInd = function(value) {
			modifyInd = value;
		};

		this.getModifyInd = function() {
			return modifyInd;
		};
	};
})(); 
(function() {

	var CclString     = MPageEntity.String;
	var CclNumber     = MPageEntity.Number;
	var Entity        = MPageEntity.Entity;
	var OneToOne      = MPageEntity.OneToOne;
	var OneToMany     = MPageEntity.OneToMany;

	Entity.create(MPageEntity, "CodeSet", {
	    "fields": {
	        "id"         : new CclNumber(),
            "display"    : new CclNumber(),
            "description": new CclString(),
            "displayKey" : new CclString(),
            "codeValues" : new OneToMany("MPageEntity.CodeValue", "codeSet")
	    },

	    "listQuals": ["display", "displayKey"],

	    "actions": ["read", "list"]
	});

})(); (function() {
    var ns = MPageEntity.entities;
	var CclString     = MPageEntity.String;
	var CclNumber     = MPageEntity.Number;
	var Entity        = MPageEntity.Entity;
	var OneToOne      = MPageEntity.OneToOne;
	var SelfOneToOne  = MPageEntity.SelfOneToOne;
	var SelfOneToMany = MPageEntity.SelfOneToMany;
    var attribute     = MPageOO.attribute;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;

	Entity.create(MPageEntity, "CodeValue", {
	    "fields": {
	        "id"         : new CclNumber(),
            "codeSet"    : new OneToOne("MPageEntity.CodeSet"),
            "meaning"    : new CclString(),
            "display"    : new CclString(),
            "description": new CclString(),
            "definition" : new CclString(),
            "cki"        : new CclString()
	    },

	    "listQuals": ["meaning", "displayKey", "display", "codeSet"],

	    "actions": ["read", "list"]
	});

    // ------------------------------------------------------------------------
    // Override the read() method to support fastRead action
    //
    // Set CodeValue.setUseFastRead(false) or instance.setUseFastRead(false) to
    // disable using fast read.
    // ------------------------------------------------------------------------

    var CodeValue = MPageEntity.CodeValue;
    CodeValue.protocol = new EntityProtocolV2();
	CodeValue.setUseFastRead = function(fastread) {
	    MPageEntity.CodeValue.m_useFastRead = fastread;
	};

	CodeValue.getUseFastRead = function() {
	    return MPageEntity.CodeValue.m_useFastRead;
	};

    attribute(CodeValue, "UseFastRead");

	MPageEntity.CodeValue.prototype.read = function(id, callback) {
	    var fread = CodeValue.getUseFastRead();
	    var instPref = this.getUseFastRead();

	    if (instPref !== undefined && instPref !== null) {
            fread = this.getUseFastRead();
	    }

        if (fread) {
            this.clearFieldCaches();
            return this.action("fastRead", {"id": id}, callback);
        }
        return MPageEntity.Entity.prototype.read.call(this, id, callback);
	};


})(); 
(function () {
    var ns = MPageEntity.entities;
    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var CclBool = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity = MPageEntity.Entity;
    var OneToOne = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;
    var Problem = "MPageEntity.entities.Problem";
    var Diagnosis = "MPageEntity.entities.Diagnosis";
    var Nomenclature = "MPageEntity.entities.Nomenclature";

    Entity.create(ns, "Condition", {
        "fields": {
            "id": new CclNumber(),
            "lastUpdate": new Iso8601DateTime(),
            "problemDriver": new OneToOne(Problem),
            "diagnosisDriver": new OneToOne(Diagnosis),
            "display": new CclString(),
            "nomenclature": new OneToOne(Nomenclature),
            "targetNomenclature": new OneToOne(Nomenclature),
            "transitionNomenclature": new OneToOne(Nomenclature),
            "descriptionFreeText": new CclString(),
            "encounter": new OneToOne("MPageEntity.Encounter"),
            "onset": new Iso8601DateTime(),
            "onsetPrecision": new CclNumber(),
            "person": new OneToOne("MPageEntity.Person"),
            "problems": new OneToMany(Problem, "problemId"),
            "diagnoses": new OneToMany(Diagnosis, "diagnosisId"),
            "lifeCycleStatus": new CodeValueField(12030),
            "isThisVisit": new CclBool(),
            "isChronic": new CclBool(),
            "isHistorical": new CclBool(),
            "isInactive": new CclBool(),
            "isCernerNKP": new CclBool(),
            "diagnosisType": new CodeValueField(17),
            "classification": new CodeValueField(12033),
            "confirmationStatus": new CodeValueField(12031),
            "clinicalPriority": new CclNumber(),
            "contributorSystem": new CodeValueField(89),
            "clinicalService": new CodeValueField(29741),
            "responsibleProvider": new OneToOne("MPageEntity.Person"),
            "responsibleProviderName": new CclString(),
            "activeInd": new CclBool(),
            "comments": new OneToMany("MPageEntity.entities.ConditionComment"),
            "isSpecific" : new CclBool()
        },
        "listQuals": ["personId", "encounterId", "nomenclatureId", "origNomenId"],
        "actions": ["list", "insert"]
    });

    ns.Condition.protocol = new EntityProtocolV2();

    ns.Condition.TYPES = {
        THIS_VISIT: 0,
        THIS_VISIT_AND_CHRONIC: 1,
        NKP: 2,
        CHRONIC: 3,
        HISTORICAL: 4,
        INACTIVE: 5,
        THIS_VISIT_AND_INACTIVE: 6
    };

    var prot = ns.Condition.prototype;
    prot.getNomenConverter = function() {
        if (this.nomenConverter) {
            return this.nomenConverter;
        }
    if (MPageEntity.Win32NomenclatureConverter) {
            this.nomenConverter = new MPageEntity.Win32NomenclatureConverter(Entity.meta.pprCd, Entity.meta.positionCd);
    }
        return this.nomenConverter;
    };

    prot.setNomenConverter = function(converter) {
        this.nomenConverter = converter;
    };

    /**
     * Returns the problem driver by looking it up in the problems array
     */
    prot.getProblemDriverFromArray = function() {
        return this.getProblems().filter("id", this.getProblemDriverValue())[0];
    };

    /**
     * Returns the diagnosis driver by looking it up in the diagnosis array
     */
    prot.getDiagnosisDriverFromArray = function() {
        return this.getDiagnoses().filter("id", this.getDiagnosisDriverValue())[0];
    };

    /**
     * Whether the user has the necessary privs to modify the condition.
     * Takes into account whether a condition is this visit or chronic, and exceptions.
     * @return {boolean}
     */
    prot.canModify = function() {

        // this visit and chronic
        if (this.getProblemDriverValue() > 0 && this.getDiagnosisDriverValue() > 0) {
            return this.canModifyChronic() && this.canModifyThisVisit();
        }

        // chronic
        if (this.getProblemDriverValue() > 0) {
            return this.canModifyChronic();
        }

        // this visit
        if (this.getDiagnosisDriverValue() > 0) {
            return this.canModifyThisVisit();
        }

        return false;
    };
    
    prot.isResolved = function() {
    	return this.getIsHistorical() && this.getProblems().length > 0;
    }

    prot.canModifyChronic = function() {
        return this.getProblemDriverValue() > 0
            && this.getProblemDriverFromArray().getCanCondModify();
    };
    
    prot.canModifyThisVisit = function() {
        return this.getDiagnosisDriverValue() > 0
            && this.getDiagnosisDriverFromArray().getCanCondModify();
    };
    
    prot.getCrossMapping = function(bedrockConfig) {
    	try {
	        var converter = this.getNomenConverter();
	        	        
	        this.setTargetNomenclatureValue(converter.convert(this, bedrockConfig));
		}
		catch(err) {
			throw new Error("Condition.js (getCrossMapping) - " + err); 
		}
    };

	prot.moveToThisVisit = function(bedrockConfig, callback, async) {
		if (!this.getEncounterValue()) {
			throw new Error("Encounter is required for moveToThisVisit.");
		}

    	this.setIsThisVisit(1);
    	this.setIsChronic(0);
    	this.getCrossMapping(bedrockConfig);
        
		return this.action("moveToThisVisit", this, callback, async);
    };

    prot.removeFromThisVisit = function(callback) {
        return this.action("removeFromThisVisit", this, callback);
    };

    prot.activate = function(callback){
        return this.action("activate", this, callback);
    };

    prot.inactivate = function(callback) {
        return this.action("inactivate", this, callback);
    };

    prot.moveToChronic = function(bedrockConfig, callback) {
    	this.setIsThisVisit(0);
    	this.setIsChronic(1);
        this.getCrossMapping(bedrockConfig);
        
         return this.action("moveToChronic", this, callback);
    };

    function inVocabList(vocab, vocabList){
        var vocabCnt = vocabList.length;
        for (var i = 0; i < vocabCnt; i++){
            if (vocab === vocabList[i].VOCAB_CD){
                return true;
            }
        }
        return false;
    }

    /**
     * ProblemFlaggingType - Enum to store possible flagging settings
     * MATCHING_SEARCH_VOCAB - Flag if condition source nomenclature different thatn search nomenclature
     * NONE - Don't flag conditions
     * VALID_VOCAB - Flag if condition not IMO, SNOMED, MAYO, or HLIPFT
     */
    var ProblemFlaggingType = {
        "MATCHING_SEARCH_VOCAB" : 1,
        "NONE" : 2,
        "VALID_VOCAB" : 3
    };

    prot.isFlagged = function(bedrockConfig){
        var metaObj = this.getResponseMeta();
        var problemTypeFlag;
        var pregnancyFlag = 2;

        var problemListFlag = parseInt(bedrockConfig.getProblemListFlag(), 10);
        var defaultSearchVocab = parseInt(bedrockConfig.getDefaultSearchVocab(), 10);

        var validVocabs = metaObj.VALID_SOURCE_VOCAB_CDS;

        var isICD10 = function(codeValue) {
            return inVocabList(codeValue, metaObj.ICD10_VOCAB_CDS);
        };

        var condition = this;
        var problemDriver = condition.getProblemDriverFromArray();
        if (problemDriver){
            problemTypeFlag = problemDriver.getProblemTypeFlag();
        }
        if (!condition.getProblemDriverValue() || defaultSearchVocab <= 0 || problemTypeFlag === pregnancyFlag){
            return false;
        }
        switch(problemListFlag) {
            case ProblemFlaggingType.NONE:
                return false;
            case ProblemFlaggingType.MATCHING_SEARCH_VOCAB:
                //map from bedrock setting to actual vocabulary
                var condSearchVocab = condition.getNomenclature().getSourceVocabularyValue();
                if (!isICD10(defaultSearchVocab)){
                    return (defaultSearchVocab !== condSearchVocab);
                }
                else if (isICD10(defaultSearchVocab)){
                    //Flag condition if it doesn't have an icd10 vocab
                    return !isICD10(condSearchVocab);
                }
                else{
                    return false;
                }
            case ProblemFlaggingType.VALID_VOCAB:
                var targetVocab = problemDriver.getNomenclature().getSourceVocabularyValue();
                var searchVocab = condition.getNomenclature().getSourceVocabularyValue();
                if (!validVocabs){
                    return false;
                }

                var hasValidTargetVocab = inVocabList(targetVocab, validVocabs);
                var hasValidSourceVocab = inVocabList(searchVocab, validVocabs);
                //Flag condition if it doesn't have valid target vocab or source vocab
                return !(hasValidTargetVocab || hasValidSourceVocab);
            default:
                return false;
        }
    };

    prot.moveToHistorical = function(callback) {
        return this.action("moveToHistorical", this, callback);
    };

    prot.cancel = function(callback) {
        return this.action("cancel", this, callback);
    };

    prot.unresolve = function(callback) {
        return this.action("unresolve", this, callback);
    };         
    /**
     * Checks whether the condition is of free text type 
     */ 
    prot.isFreeText = function(){
    	return (this.getNomenclatureValue() === 0.0 || this.getNomenclatureValue() === null);
    };
    
    /**
     * Overrides the base list method so that we can monitor load times
     */
    prot.list = function(params, callback) {

        if (typeof(RTMSTimer) !== 'undefined') {
    	   var loadTimer = new RTMSTimer("ENG:MPG.CONDITION_ENTITY - list");
    	   loadTimer.addMetaData("key");
    	   loadTimer.start();
        }

    	if(callback){
	    	return Entity.prototype.list.call(this, params, function(conditions) {
	    		try {
                    conditions.retrieveSpecificities();
	    			callback.apply(window, arguments);
	    		} catch(err) {
			   		if(loadTimer) {
			   			loadTimer.fail();
			   		}
			   		throw(err);
			   	} finally {
			   		if(loadTimer){
			   			loadTimer.stop();
			   		}
			   	}
	    	});
	}else {
		return Entity.prototype.list.call(this, params, callback);
	}
    };

    /**
     * Returns comments with the current condition associated to them.
     */
    prot.getCommentsWithAssociation = function(callback) {
        var self = this;
        if (callback) {
            self.getComments(function(comments) {
                self.associateComments(comments);
                callback.apply(this, arguments);
            });
        } else {
            var comments = this.getComments();
            self.associateComments(comments);
            return comments;
        }
    };

    /**
     * Sets the conditions of a comment list to the current condition
     * instance.
     */
    prot.associateComments = function(comments) {
        var self = this;
        comments.each(function(comment) {
            comment.setCondition(self);
        });
    };

    /**
     * Whether mapping has been performed on the condition or not.
     */
    prot.isMapped = function() {
      return this.getTargetNomenclatureValue() ? true : false;
    };

    /**
     * Whether the target nomenclature is ICD10
     */
     prot.isTargetICD10 = function() {
        if (!this.getResponseMeta() || !this.getResponseMeta().ICD10_VOCAB_CDS) {
            throw new Error('Condition instance does not have an associated' +
             ' ICD10 vocabulary list.');
        }

        var icd10vocabs = this.getResponseMeta().ICD10_VOCAB_CDS;
        for (var i=icd10vocabs.length;i--;){
            var targetVocab = this.getTargetNomenclature().getSourceVocabularyValue();
            if (icd10vocabs[i].VOCAB_CD == targetVocab) {
                return true;
            }
        }
        return false;
     };
})();

(function(ns, inherits, attribute) {

    var EntityList = MPageEntity.EntityList;
    var SORTING = MPageEntity.EntityList.SORTING;

    ns.ConditionList = function() {
        EntityList.call(this, ns.Condition);

        // this ensures generator methods like splice() will
        // create the correct class.
        this.setEntityListClass(ns.ConditionList);
    };

    MPageEntity.entities.Condition.defaultEntityListClass = ns.ConditionList;

        inherits(ns.ConditionList, EntityList);

    var prot = ns.ConditionList.prototype;

    /**
     * Performs the moveToHistoric action on all entities.
     */
    prot.moveToHistoric = function() {
        this.action("moveToHistoric");
    };

    /**
     * Performs the cancel action on all the entities
     */
    prot.cancel = function() {
        this.action("cancel");
    };

    /**
     * Retrieve the value of the highest priority found in the condition list
     * @return {Integer} Highest priority present in the condition list
     */
    prot.getHighestPriority = function(){
        var conditionList = this;
        var highestPriority = 0;
        var conditionCnt = this.length;
        var priority = 0;
        var condition = null;
        for (var i = 0; i < conditionCnt; i++){
            condition = conditionList[i];
            priority = condition.getClinicalPriority() || 0;			            
            if (condition.getIsThisVisit() && priority > highestPriority){				
                highestPriority = priority;
            }
        }
        return highestPriority;
    };

    /**
     * Returns a new ConditionList where the conditions are ordered
     * according to the order array. The types are specified on Condition.TYPES.
     *
     * ex:
     * var thisAndChron = mylist.sortByType([Condition.TYPES.THIS_VISIT, Condition.TYPES.CHRONIC]);
     *
     * Additionally, the internal alpha sorting can be specified by setting the alphaSort parameter:
     *
     * var thisVisit = mylist.sortByType([Condition.TYPES.THIS_VISIT], EntityList.SORTING.DESC);
     */
    prot.sortByType = function(order, alphaSort) {
        var result = this.makeEmptyList();
        var types = MPageEntity.entities.Condition.TYPES;

        for (var i=0; i<order.length; i++) {
            var filterName = "";
            var filtered;

            switch(order[i]) {
                case types.THIS_VISIT: {
                    filtered = this.filter("isThisVisit", true);
                    break;
                }
                case types.CHRONIC: {
                    filtered = this.filter("isChronic", true)
                        .filter("isThisVisit", false)
                        .filter("isCernerNKP", false);
                    break;
                }
                case types.HISTORICAL: {
                    filtered = this.filter("isHistorical", true)
                    .filter("isThisVisit", false)
                    .filter("isChronic", false)
                    .filter("isCernerNKP", false);
                    break;
                }
                case types.NKP: {
                    filtered = this.filter("isCernerNKP", true)
                    .filter("isThisVisit", false);
                    break;
                }
                default:
                    throw new Error("Invalid Condition type provided in sortByType()");
            }

            // apply alpha sorting
            alphaSort = alphaSort ? alphaSort : MPageEntity.EntityList.SORTING.ASC;
            filtered.sortBy("display", alphaSort);

            result = result.concat(filtered);
        }
        return result;
    };

    /**
     * Returns a ConditionList where the conditions are ordered by priority.
     * Only this visit conditions will be sorted and returned. Conditions with
     * no priorities (priority of 0) will be placed at the bottom.
     *
     * The order parameter can be asceding or descending by passing the
     * correspondent EntityList.SORTING value.
     *
     * @param {EntityList.SORTING|null} order
     * @return {T[]|Array.<any>|*[]}
     */
    prot.sortByPriority = function(order) {
        if (!order) {
            order = SORTING.ASC;
        }

        var thisVisits = this.filter("isThisVisit", true);
        var priorityNotSet = thisVisits.filter(function(cond) {
           return cond.getClinicalPriority() <= 0 || !cond.getClinicalPriority();
        });
        var prioritySet = thisVisits.getPrioritizedOnly();
        prioritySet.sortBy("clinicalPriority", order);

        return prioritySet.concat(priorityNotSet);
    };

    /**
     * Returns only the conditions which have a priority set
     * @return {*}
     */
    prot.getPrioritizedOnly = function() {
        return this.filter(function(condition) {
            return condition.getClinicalPriority() > 0 && condition.getIsThisVisit()
        });
    };

    /**
     * Resequences conditions according to their priority. Will return a new
     * condition list with only the conditions that need update.
     *
     * @param condition
     * @param newPriority
     * @param removeConditionFlag
     */
    prot.updatePriorityAndResequence = function(condition, newPriority, removeConditionFlag) {

		var toSave = this.makeEmptyList();
		var prioritized = null;
		var priorityOfCondition = condition.getClinicalPriority();

		//Prioritize only the subset of conditions whose priorities are being changed.
		//priority of the condition is being updated to -- or 0,
		//prioritize only conditions that have clinical priority greater than the current condition.
		if (newPriority === 0 || removeConditionFlag) {
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= priorityOfCondition && cond.getIsThisVisit()
			});
		} else if (priorityOfCondition < newPriority && priorityOfCondition) {//priority of the condition is set to a higher/lower numerical value, grab all conditions between current value and new value
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= priorityOfCondition && cond.getClinicalPriority() <= newPriority && cond.getIsThisVisit()
			});
		} else if (priorityOfCondition > newPriority) {
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() <= priorityOfCondition && cond.getClinicalPriority() >= newPriority && cond.getIsThisVisit()
			});
		} else if (priorityOfCondition === 0 && newPriority <= this.getHighestPriority()) {//condition with no priority is set to value that exists in the list, grab all conditions with priority greater and equal to the new priority
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= newPriority && cond.getIsThisVisit() || cond == condition
			});
		} else if (priorityOfCondition === 0 && newPriority > this.getHighestPriority()) {//condition with no priority is set to a value greater than the current highest priority, then we need to just update this condition.
			condition.setClinicalPriority(newPriority);
			toSave.push(condition);
		}

		if (!toSave.length) {
			prioritized = prioritized.sortBy("clinicalPriority", SORTING.ASC);
			//Since we are going to prioritize from the beginning of the subset of conditions between the new and the previous priority,
			//grab the very first one in the list.
			var firstCondition = prioritized[0].getClinicalPriority();

			//Since the conditions are being sorted, the condition with 0 priority will be at the top of the list.
			var priority = ( firstCondition ? firstCondition : prioritized[1].getClinicalPriority()) - removeConditionFlag;
			prioritized.each(function(cond) {

				// will not resequence conditions we do not have permission
				if (!cond.canModify()) {
					return;
				}
				toSave.push(cond);
				// Change the priority of the current condition to the new priority
				if (cond == condition) {
					cond.setClinicalPriority(newPriority);
					return;
				}
				if (priority >= newPriority && newPriority > 0) {
					cond.setClinicalPriority(priority + 1);
				} else {
					cond.setClinicalPriority(priority);
				}
				priority++;

			});
		}
		return toSave;
    };

    /**
    * Removes the specified condition from the list and resequences the remaining
    * conditions. Will return a list of conditions that have had their priorities changed.
    *
    * @param condition
    */
    prot.removeAndResequence = function(condition) {

        // we don't resequence if it is the last prioritized condition
        var priority = condition.getClinicalPriority();		
		var removeConditionFlag = 1;
        if (priority === 0 || priority === this.getHighestPriority()) {
            this.remove(condition);
            return this.makeEmptyList();
        }		
        var prioritized = this.getPrioritizedOnly().sortBy("clinicalPriority", SORTING.ASC);				        
		var nextCondition = prioritized[priority - 1];
        this.remove(condition);
        
        if(!nextCondition){
        	return this.makeEmptyList();
        }
        return this.updatePriorityAndResequence(nextCondition,
            nextCondition.getClinicalPriority() - 1, removeConditionFlag);
    };

    prot.remove = function(condition) {
        var index = this.indexOf(condition);
        return this.splice(index, 1);
    };

    /**
     * Performs an update on all conditions in the list
     * @param callback
     */
    prot.update = function(callback) {
        return this.action('update', callback);
    };

    prot.getUnspecified = function(){
       return this
        .filter("isThisVisit", true)
        .filter("isSpecific", false);
    };

    /**
     * Returns a dx assistant instance for the currently running
     * platform. The instance will have two methods:
     *
     * launch(list, callback): opens up a dx assistant window and calls callback when done
     * populateSpecificities(list): sets the isSpecific flag of the conditions
     */
    prot.createDxAssistant = function() {
      if (CERN_Platform && CERN_Platform.inMillenniumContext()) {
        return new MPageEntity.entities.Condition.Win32DxAssistant();
      }

      // implement a dummy interface for when not in win32. If
      // we ever implement a web only DxAssistant, it shall be
      // instantiated here.
      return {
        launch: function() {},
        populateSpecificities: function() {}
      };
    };

    /**
     * Runs the dx assistant generated by createDxAssistant and
     * executes the provided callback when closed.
     */
    prot.launchDxAssistant = function(callback) {
      var dxAss = this.createDxAssistant();
      dxAss.launch(this, callback);
    };

    /**
     * Populates the isSpecific fields of all the conditions in
     * the list
     */
    prot.retrieveSpecificities = function(){
      var dxAss = this.createDxAssistant();
      dxAss.populateSpecificities(this);
    };

    /**
     * Fires the dx assistant in order to specify the unspecified conditions
     * in the list
     */
    prot.resolveUnspecified = function(callback) {
      var conditions = this
        .filter("isSpecific", false)
        .filter(function (c) { return c.hasDxAssistant(); })
        .launchDxAssistant(callback);
    };

    /**
     * Returns an array with the code values as provided in the meta
     * object.
     *
     * @returns {*}
     */
    prot.getICD10CodeValuesFromMeta = function() {
        var vocabs = this.getResponseMeta().ICD10_VOCAB_CDS;
        var result = [];
        for (var i=vocabs.length; i--;) {
            result.push(vocabs[i].VOCAB_CD);
        }
        return result;
    };

})(
    MPageEntity.entities,
    MPageOO.inherits,
    MPageOO.attribute
);
(function() {

    var ns = MPageEntity.entities;

    var EncodedString = MPageEntity.EncodedString;
    var EntNumber = MPageEntity.Number;
    var EntBool = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity = MPageEntity.Entity;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;
    var OneToOne = MPageEntity.OneToOne;
    var attribute = MPageOO.attribute;

    Entity.create(ns, "ConditionComment", {
        "fields": {
            "id": new EntNumber(),
            "author": new OneToOne("MPageEntity.entities.Prsnl"),
            "text": new EncodedString(),
            "createdDateTime": new Iso8601DateTime(),
            "condition": new OneToOne("MPageEntity.entities.Condition", {sendFullObject: true}),
            "originalCreatedDateTime": new MPageEntity.String()
        }
    });

     ns.ConditionComment.protocol = new EntityProtocolV2();

    /**
     * The date and personnel name as extracted from the comment text, if the comment
     * was identified as having a header by the splitDxComments method.
     */
     attribute(ns.ConditionComment, "Header");

     ns.ConditionComment.protocol = new EntityProtocolV2();

     // IE8 compatible trim function
     var trim = function(text) {
        return text.replace(/^\s+|\s+$/g, '');
     };

     ns.ConditionComment.splitDxComments = function(comments) {
        var result = this.makeEmptyList();
        var self = this;

        comments.each(function(comment) {
            var individualComment;
            var newComment;
            var header;
            var firstLine;
            var newlinePos;

            // if it doesn't start with a date, then it is most likely a problem
            if (!comment.startsWithDate()) {
                result.push(comment);
                return;
            }

            // splits two consecutive newlines into its separate comments.
            // this will not care about the style of line endings (\n versus \r\n)
            var individualComments = comment.getText().split(/\n\s*\r?\n/gm);

            // loops over the individual comments and parse dates/personnel names
            for (var i=0; i<individualComments.length; i++) {
                individualComment = individualComments[i];
                newlinePos = individualComment.indexOf("\n");
                firstLine = individualComment.substr(0, newlinePos);

                newComment = new self();
                comment.copyTo(newComment);
                newComment.setText(trim(individualComment.substr(newlinePos + 1)));
                newComment.setHeader(trim(firstLine));
                result.push(newComment);
            }
        });
        return result;
     };

     ns.ConditionComment.prototype.getFormattedHeader = function() {
        if (this.getHeader()) { return this.getHeader(); }

        var dt = this.getCreatedDateTime();
        var formattedDate = "";
        if (dt) {
            var format = dateFormat.masks.shortDate2 + " " + dateFormat.masks.shortTime;
            formattedDate = dt.format(format);
        }

        return formattedDate + " - " + this.getAuthor().getPerson().getNameFullFormatted();
     };

     ns.ConditionComment.prototype.startsWithDate = function() {
        var txt = this.getText();

        if (!txt) return false;

        var startOfFirstLine = txt.substr(0, txt.indexOf(" "));
        var dt = Date.parse(startOfFirstLine);
        return dt ? true : false;
     };

     /**
      * Override the standard create in order to force updating the most recent diagnosis
      * if we are updating this visit only (just diagnosis driver)
      */
     ns.ConditionComment.prototype.create = function(cb) {
        var cond = this.getCondition();

        if (!cond.getDiagnoses().length || !cond.getDiagnosisDriverValue() || cond.getProblemDriverValue()) {
            MPageEntity.Entity.prototype.create.call(this, cb);
            return;
        }

        var mostRecentDx = cond
            .getDiagnoses()
            .sortBy("diagDtTm", MPageEntity.EntityList.SORTING.DESC)[0];

        // copy the condition to avoid changing the driver of the original
        var condCopy = new MPageEntity.entities.Condition();
        cond.copyTo(condCopy);
        condCopy.setDiagnosisDriver(mostRecentDx);
        this.setCondition(condCopy);
        MPageEntity.Entity.prototype.create.call(this, cb);
     };
})();
(function() {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
	var CclBool   = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;

    Entity.create(MPageEntity.entities, "Diagnosis", {
        "fields": {
			"id"                  : new CclNumber(),
			"display"             : new CclString(),
			"attestation"         : new Iso8601DateTime(),
			"certainty"           : new CodeValueField(12035),
			"classification"      : new CodeValueField(12033),
			"clinicalDiagPriority": new CclNumber(),
			"clinicalService"     : new CodeValueField(29741),
			"conditionalQual"     : new CodeValueField(29740),
			"confidLevel"         : new CodeValueField(87),
			"confirmationStatus"  : new CodeValueField(12031),
			"contributorSystem"   : new CodeValueField(89),
			"diagnosticCategory"  : new CodeValueField(1314),
			"diagClass"           : new CodeValueField(12033),
			"diagDtTm"            : new Iso8601DateTime(),
			"ftdesc"              : new CclString(),
			"note"                : new CclString(),
			"encounter"           : new OneToOne("MPageEntity.Encounter"),
			"hac"                 : new CclBool(),
			"laterality"          : new CodeValueField(4002375),
			"person"              : new OneToOne("MPageEntity.Person"),
			"priority"            : new CclNumber(),
			"originatingNomen"    : new OneToOne("MPageEntity.Nomenclature"),
			"nomenclature"        : new OneToOne("MPageEntity.Nomenclature"),
			"presentOnAdmit"      : new CodeValueField(4002009),
			"probability"         : new CclNumber(),
			"ranking"             : new CodeValueField(12034),
			"referenceNbr"        : new CclString(),
			"severity"            : new CodeValueField(12022),
			"severityClass"       : new CodeValueField(29743),
			"severityFtDesc"      : new CclString(),
			"type"                : new CodeValueField(17),
			"updateDtTm"          : new Iso8601DateTime(),
			"isHistorical"		  : new CclBool(),
			"canCondModify"       : new CclBool(),
			"begEffectiveDtTm"	: new Iso8601DateTime()
        },

        "listQuals": ["personId", "encounterId", "nomenclatureId", "originatingNomenId"],

        "actions": ["insert", "read", "update", "list"]

    });

    MPageEntity.entities.Diagnosis.protocol = new MPageEntity.protocol.EntityProtocolV2();

})();
(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var CodeValue = "MPageEntity.CodeValue";
    var Person    = "MPageEntity.Person";
    var CodeValueField = MPageEntity.CodeValueField;
    
    Entity.create(MPageEntity, "Encounter", {
        "fields": {
            "id"              : new CclNumber(),
            "financialId"     : new CclNumber(), // should be transformed into an entity
            "person"          : new OneToOne(Person),
            "personnel"       : new OneToOne(Person),
            "type"            : new CodeValueField(71),
            "typeClass"       : new CodeValueField(69),
            "status"          : new CodeValueField(261),
            "arrive"          : new DateTime(),
            "depart"          : new DateTime(),
            "begEffective"    : new DateTime(),
            "admitType"       : new CodeValueField(3),
            "admitMode"       : new CodeValueField(68),
            "dataStatus"      : new CodeValueField(8),
            "admitSrc"        : new CodeValueField(2),
            "referringComment": new CclString(),
            "organization"    : new CclNumber(),
            "facility"        : new OneToOne("MPageEntity.Facility"),
            "location"        : new CclNumber(),
            "class"           : new CodeValueField(321),
            "reasonForVisit"  : new OneToOne(CodeValue)
        },

        "listQuals": ["personId"],

        "actions": ["insert", "read", "update", "list"]
    });

})();(function() {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    var CodeSets = MPageEntity.CodeSets;
    var CclBool = MPageEntity.CclBool;
    var EncodedString = MPageEntity.EncodedString;

    Entity.create(MPageEntity.entities, "Nomenclature", {
        "fields": {
            "id": new CclNumber(),
            "cmti": new CclString(),
            "conceptCki": new CclString(),
            "conceptIdentifier": new CclString(),
            "conceptSource": new CodeValueField(CodeSets.NOMENCLATUREIDENTIFIERSOURCE),
            "contributorSystem": new CodeValueField(CodeSets.CONTRIBUTORSYSTEM),
            "language": new CodeValueField(CodeSets.LANGUAGE),
            "mnemonic": new CclString(),
            "primaryCTerm": new CclBool(),
            "primaryVTerm": new CclBool(),
            "principleType": new CodeValueField(CodeSets.PRINCIPLETYPE),
            "shortString": new CclString(),
            "sourceIdentifier": new CclString(),
            "sourceIdentifierKeycap": new CclString(),
            "sourceString": new CclString(),
            "sourceStringKeycap": new CclString(),
            "sourceVocabulary": new CodeValueField(CodeSets.SOURCEVOCABULARY),
            "stringIdentifier": new CclString(),
            "stringSource": new CodeValueField(CodeSets.NOMENCLATUREIDENTIFIERSOURCE),
            "stringStatus": new CodeValueField(CodeSets.STRINGSTATUS),
            "vocabAxis": new CodeValueField(CodeSets.SOURCEVOCABULARYAXIS),
            "isSpecific": new CclBool()
        },

        "actions": {

            "search": {
                'searchTerm' : new EncodedString(),
                'sourceFlag' : new CclNumber(),
                'resultLimit' : new CclNumber()
            },

            "list": {
                'sourceStringEquals': new CclString(),
                'sourceStringContains': new CclString(),
                'mnemonicContains': new CclString(),
                'languageId': new CclNumber(),
                'idGreaterThan': new CclNumber()
            }
        }
    });

    MPageEntity.entities.Nomenclature.protocol = new MPageEntity.protocol.EntityProtocolV2();
    
    // backwards compatibility - shall be removed soon
    MPageEntity.Nomenclature = MPageEntity.entities.Nomenclature;
    
    MPageEntity.entities.Nomenclature.search = function(params, callback, async) {
    	return MPageEntity.entities.Nomenclature.action("search", params, callback, async);
    };
})();(function() {
    var ns = MPageEntity.entities;
    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var Problem = "MPageEntity.entities.Problem";

    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;

    var CodeValue = "MPageEntity.CodeValue";
    var Person    = "MPageEntity.Person";
    var CodeValueField = MPageEntity.CodeValueField;
    var Problem        = "MPageEntity.entities.Problem";
    var Nomenclature   = "MPageEntity.entities.Nomenclature";
    var PatientRequestModifyField = "MPageEntity.entities.PatientRequestModifyField";
    
    Entity.create(ns, "PatientRequestComment", {
        "fields": {
            "comment"   : new CclString()
        }
    });


    Entity.create(ns, "PatientRequestModifyField", {
        "fields": {
            "id"                : new CclNumber(),
            "display"           : new CclString(),
            "modifiedDisplay"   : new CclString(),
            "modifyStatus"      : new OneToOne(CodeValue)
        }
    });

    Entity.create(ns, "PatientProblemRequest", {
        "fields": {
            "id"              : new CclNumber(),
            "healthIssue"     : new CclString(),
            "problem"         : new OneToOne(Problem),
            "person"          : new OneToOne(Person),
            "managingProvider": new OneToOne(PatientRequestModifyField),
            "nomenclature"    : new OneToOne(Nomenclature),
            "requestType"     : new OneToOne(CodeValue),
            "submissionDate"  : new Iso8601DateTime(),
            "submittedBy"     : new CclString(),
            "submittedByType" : new OneToOne(CodeValue),
            "onsetDate"       : new OneToOne(PatientRequestModifyField),
            "comments"        : new OneToMany("MPageEntity.entities.PatientRequestComment")
        },

        "listQuals": ["personId"],

        "actions": ["insert", "acknowledge", "list"]
    });

    ns.PatientProblemRequest.protocol = new EntityProtocolV2();

})();(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var CodeValue = "MPageEntity.CodeValue";
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    
    Entity.create(MPageEntity, "Person", {
        "fields": {
            "id"               : new CclNumber(),
            "nameFirst"        : new CclString(),
            "nameLast"         : new CclString(),
            "updateDateTime"   : new DateTime(),
            "nameFullFormatted": new CclString(),
            "sex"              : new CodeValueField(57),
            "mrn"              : new CclString(),
            "organization"     : new CclNumber(),
            "encounters"       : new OneToMany("MPageEntity.Encounter","personId"),
            "privileges"       : new OneToMany("MPageEntity.Privilege","person"),
            "dob"              : new DateTime()
        },

        "listQuals": ["nameFirstKey", "nameLastKey"],

        "actions": ["insert", "update", "read", "list"]

        
    });

    // One can add functions for the Person class here by referencing its
    // prototype, such as:
    //
    // var prot = MPageEntity.Person.prototype;

})();(function () {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var CclBool = MPageEntity.CclBool;
    var DateTime = MPageEntity.DateTime;
    var Entity = MPageEntity.Entity;
    var OneToOne = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var CodeValueField = MPageEntity.CodeValueField;
    var Nomenclature = "MPageEntity.entities.Nomenclature";
    var Person = "MPageEntity.Person";

    Entity.create(MPageEntity.entities, "Problem", {
        "fields": {
            "id":                   new CclNumber(),
            "annotatedDisplay":     new CclString(),
            "begEffectiveDateTime": new Iso8601DateTime(),
            "classificationCd":     new CodeValueField(12033),
            "confirmationStatus":   new CodeValueField(12031),
            "endEffectiveDateTime": new Iso8601DateTime(),
            "lifeCycleStatusCd":    new CodeValueField(12030),
            "onsetDateTime":        new Iso8601DateTime(),
            "onsetPrecision":       new CclNumber(),
            "problemTypeFlag":      new CclNumber(),
            "showInPMHxInd":        new CclBool(),
            "originatingNome":      new OneToOne(Nomenclature),
            "person":               new OneToOne(Person),
            "nomenclature":         new OneToOne(Nomenclature),
            "severity":             new CodeValueField(12022),
            "severityClass":        new CodeValueField(29743),
            "severityFtDesc":       new CclString(),
            "descriptionFtDesc":    new CclString(),
            "sourceVocabularyCd":   new CclNumber(),
            "sourceIdentifier":     new CclString(),
            "problemFtDesc":        new CclString(),
            "qualifierCd":          new CclNumber(),
            "persistenceCd":        new CclNumber(),
            "certainityCd":         new CclNumber(),
            "rankingCd":            new CclNumber(),
            "contributorSystemCd":  new CclNumber(),
            "updateDtTm":           new Iso8601DateTime(),
            "organization":         new CclNumber(),
            "isHistorical":         new CclBool(),
            "canCondModify":        new CclBool()
          },
        "listQuals": ["personId", "nomenclatureId", "originatingNomenId"],
        "actions": ["insert", "read", "update", "list"]
    });
})();
(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var Person    = "MPageEntity.Person";
    var OneToOne = MPageEntity.OneToOne;
	var CodeValue = "MPageEntity.CodeValue";
	var CodeValueField = MPageEntity.CodeValueField;
	var CodeSets = MPageEntity.CodeSets;

    MPageEntity.Entity.create(MPageEntity.entities, "Prsnl", {
        "fields": {
            "id"               : new CclNumber(),
            "person"           : new OneToOne("MPageEntity.Person", {sendFullObject:true}),
            "userName"         : new CclString(),
            "email"            : new CclString(),
            "title"            : new CclString(),
            "posCd"            : new CodeValueField(CodeSets.POSITNCODE)
        },

        "listQuals": ["userName"],

        "actions": ["read", "insert", "update", "list"]
    });


    MPageEntity.entities.Prsnl.protocol = new MPageEntity.protocol.EntityProtocolV2();

    // One can add functions for the Prsnl class here by referencing its
    // prototype, such as:
    //
    // var prot = MPageEntity.Prsnl.prototype;

})();

(function() {
    var probDxUtils;
    
    MPageEntity.getProbDxUtils = function() {
        if(!probDxUtils){
            probDxUtils = CERN_Platform.getDiscernObject("PROBDXUTILS");
        }
        return probDxUtils;
    };
    MPageEntity.Win32ConditionModifier = function(entity, callback, calledFrom, forceInvokeProblemModify) {
    	var probDxUtils = MPageEntity.getProbDxUtils();
    	var condition = entity;
    	var encounterId = condition.getEncounterValue();
        var personId = condition.getPersonValue();
    	var drivingDx = condition.getDiagnosisDriverValue();
    	var drivingProblem = condition.getProblemDriverValue();
        var modifyConditionTimer = new CapabilityTimer("CAP:MPG Condition Entity Modify", calledFrom);
        if (modifyConditionTimer) {
            modifyConditionTimer.capture();
        }
    	if (drivingDx && condition.getIsThisVisit() && condition.canModifyThisVisit() && !(forceInvokeProblemModify)){
            probDxUtils.LoadDiagnosisAndInvokeModify(drivingDx, personId, encounterId, true);
    	}
    	else if (drivingProblem && condition.canModifyChronic()){
            probDxUtils.LoadProblemAndInvokeModify(drivingProblem, personId, true);
    	}
        else{
            throw new Error("Condition has no valid diagnosis or problem");
        }
        // Execute callback after Synchronous Win32 session is completed
    	callback();
    };
})();
(function() {

	/**
	 * Launch Win32DxAssistant based on the passed condition entities
	 * @param {Array}    conditionList Array of condition entities
	 * @param {Function} callback      Function to perform after Win32 diagnosis assistant has closed if a diagnosis has been modified
	 * @param {String}   calledFrom    String containing logging information about where the utility is launched from (category mean/component name)
	 */
	MPageEntity.entities.Condition.Win32DxAssistant = function() {};

	var Class = MPageEntity.entities.Condition.Win32DxAssistant;
	var method = Class.prototype;

	// ---------------------------------------------------------------------------
	// Private
	// ---------------------------------------------------------------------------

	var logError = function(msg, exception) {
		if (typeof(logger) !== 'undefined' && logger) {
			logger.logError(msg + ": " + exception);
			return;
		}
		throw msg;
	};

	/**
	 * Generates a win32 clinical diagnosis object based on passed condition entity
	 * @param  {MPageEntity.Condition} condition  Condition Entity to create corresponding win32 object for
	 * @return {CLINICALDIAGNOSIS} Win32 clinical diagnosis object
	 */
	var populateClinicalDiagnosisObj = function(condition) {
		if (!condition) return null;

		var clinicalDiagnosis = CERN_Platform.getDiscernObject("CLINICALDIAGNOSIS");
		var diagnosis = condition.getDiagnosisDriverFromArray();

		if (!clinicalDiagnosis) return null;

		clinicalDiagnosis.DiagnosisID = condition.getDiagnosisDriverValue();
		clinicalDiagnosis.DiagnosisGroupID = condition.getDiagnosisDriverValue();
		clinicalDiagnosis.EncounterID = condition.getEncounterValue();
		clinicalDiagnosis.DiagnosisDisplay = condition.getDisplay(); //clinicalDiagnosis.DiagnosisDisplay is the win32 field for annotated_display
		clinicalDiagnosis.NomenclatureID = condition.getTargetNomenclatureValue(); //diagnosis.TARGET_NOMENCLATURE_ID is the target nomenclature id
		
		//DATE will be stored as double value in COM. for example "1899/12/30 00:00:00" will be stored as 0.0 and calculating difference from origin date
		var startDateTime = new Date(1899, 11, 30, 00, 00, 00);
		var begDateTime = new Date();
		var begEffectiveDtTm = null;
		var timeDiff = null;
		if (diagnosis.getBegEffectiveDtTm() != undefined) {
			begDateTime = diagnosis.getBegEffectiveDtTm();
			timeDiff = begDateTime.getTime() - startDateTime.getTime();
			begEffectiveDtTm = timeDiff / (1000 * 60 * 60 * 24);
		}
		if (clinicalDiagnosis.BegEffectiveDtTm != undefined) {
			clinicalDiagnosis.BegEffectiveDtTm = begEffectiveDtTm;
		}

		if (clinicalDiagnosis.ClinicalPriority != undefined && condition.getClinicalPriority()) {
			clinicalDiagnosis.ClinicalPriority = condition.getClinicalPriority();
		}

		//Need to validate OriginatingSourceString exists on the object to prevent crash on pre 2010.02 code lines
		if (clinicalDiagnosis.OriginatingSourceString != undefined) {
			clinicalDiagnosis.OriginatingSourceString = condition.getDisplay(); //condition.DISPLAY is from the source_string						
		}
		//Need to validate OriginatingNomenclatureID exists on the object to prevent crash on pre 2010.02 code lines
		if (clinicalDiagnosis.OriginatingNomenclatureID != undefined && clinicalDiagnosis.OriginatingNomenclatureID === 0) {
			clinicalDiagnosis.OriginatingNomenclatureID = condition.getNomenclatureValue(); //condition.NOMENCLATURE_ID is the source nomenclature id
		}

		return clinicalDiagnosis;
	};
	/**
	 * Adds Win32 Clinical Diagnosis Objects to the passed dxCollection corresponding
	 * to condition entities from the passed conditionList
	 * @param {DISPATCHCOLLECTION} dxCollection  collection to add clinical diagnosis objects to
	 * @param {Array}              conditionList array of condition entities
	 */
	var addConditionsToDxCollection = function(dxCollection, conditionList) {
		conditionList.each(function(condition) {
			if (!condition.getIsThisVisit()) return;
			var dxobj = populateClinicalDiagnosisObj(condition);

			// Only add diagnoses with valid nomenclature id
			if (dxobj && dxobj.NomenclatureID > 0) {
				dxCollection.Add(dxobj);
			}
		});
		return dxCollection;
	};

	/**
	 * Returns the Win32 dx assistant object
	 */
	var getDxAssistantFromWin32 = function() {
		var dxass = CERN_Platform.getDiscernObject("DIAGNOSISASSISTANT");
		if (!dxass) {
			logError("Could not instantiate dx assistant");
		}
		return dxass;
	};

	/**
	 * Creates a new Win32 collection object
	 */
	var convertListToWin32Collection = function(conditionList) {
		var collection = CERN_Platform.getDiscernObject("DISPATCHCOLLECTION");
		if (!collection) {
			logError("Could not create the dx assistant collection");
		}
		addConditionsToDxCollection(collection, conditionList);
		return collection;
	};

	// ---------------------------------------------------------------------------
	// Public
	// ---------------------------------------------------------------------------

	/**
	 * Launch the dx assistant with the selected conditions
	 */
	method.launch = function(conditionList, callback) {

		if (!conditionList.length) {
			logError("Tried to launch Dx assistant, but no conditions were passed.");
			return;
		};

		// filter out non ICD10 conditions
		conditionList = conditionList.filter(function(c) { return c.isTargetICD10(); });

		// retrieve authentication info from the first condition's meta
		var cond = conditionList[0];
		var meta = cond.getMeta();

		var providerId = meta.userId;
		var pprCd = meta.pprCd;
		var positionCd = meta.positionCd;
		var patientId = cond.getPersonValue();
		var encounterId = cond.getEncounterValue();

		var dxAssistantTimer = new CapabilityTimer("CAP:MPG Condition Entity Launch Dx Assistant", "condition entity");
		if (dxAssistantTimer) {
			dxAssistantTimer.capture();
		}

		var dxAssistant = getDxAssistantFromWin32();
		var dxCollection = convertListToWin32Collection(conditionList);

		var dxCollectionWithPrivs = dxAssistant.IsDxAssistantNeeded(providerId,
			pprCd,
			positionCd,
			dxCollection);

		// if our list is now empty, we didn't have privs to use dx assistant.
		if (!dxCollectionWithPrivs || dxCollectionWithPrivs.GetCount() < 1) {
			return;
		}

		var result;
		try {
			var dxAssistantCriteriaObj = CERN_Platform.getDiscernObject("DXASSISTANTCRITERIA");
			dxAssistantCriteriaObj.SetParentWnd(0.0);
			dxAssistantCriteriaObj.SetUserID(providerId);
			dxAssistantCriteriaObj.SetPPRCD(pprCd);
			dxAssistantCriteriaObj.SetPatientID(patientId);
			dxAssistantCriteriaObj.SetEncounterID(encounterId);
			dxAssistantCriteriaObj.SetCrossMapModeByEnum(0);
			dxAssistantCriteriaObj.SetDialogType(0);
			dxAssistantCriteriaObj.SetReturnEffectiveDtTmByEnum(0);
			dxAssistantCriteriaObj.SetEnableEarlyTransitionDx(false);
			result = dxAssistant.LaunchDiagnosisAssistantByCriteria(dxAssistantCriteriaObj, dxCollection);
		}
		catch (err) {
			logError("Failed to create DXASSISTANTCRITERIA. Reverting back to old API.", err);
			result = dxAssistant.LaunchDiagnosisAssistant(0.0, providerId, pprCd, patientId, encounterId, dxCollection);
		}

		// Call callback if a condition was modified from the diagnosis assistant
		if (result) {
			this.populateSpecificities(conditionList, dxCollection);
			callback();
		}
	};

	/**
	 * Sets the isSpecific field of the conditions specified in the
	 * condition list.
	 */
	method.populateSpecificities = function(conditionList, collection) {
		var dxAss = getDxAssistantFromWin32();

		if (!collection) {
			collection = convertListToWin32Collection(conditionList);
		}

		var specificities = dxAss.GetNomenclatureSpecificityInfo(collection);

		if (!specificities) { //We were unable to grab the specificities info for the passed in diagnoses
			return;
		}

		var dxObj = null;
		for (var i = 0; i < collection.GetCount(); i++) {
			dxObj = collection.GetAt(i);
			conditionList
				.filter("diagnosisDriver", dxObj.DiagnosisID)
				.each(function(condition) {
					if (!condition.isTargetICD10()) {
						condition.setIsSpecific(null);
						return;
					}
					condition.setIsSpecific(dxObj.NomenclatureSpecific ? true : false);
				});
		}
	};
})();(function() {
    MPageEntity.Win32NomenclatureConverter = function(pprCd, positionCd){
        this.pprCd = pprCd;
        this.positionCd = positionCd;
    };

    /**
     * Method will call KiaCrossMapping Win32 dll in order to launch cross mapping window and return diagnosis/problem target Vocabulary code
     * 
     * @param {object} condition : The specified condition that cross mapping is being performed on
     * @param {object} bedrockConfig : The Bedrock settings class from the Condition Entity
     */ 
    MPageEntity.Win32NomenclatureConverter.prototype.convert = function(condition, bedrockConfig) {
        var crossMapping;
        var diagnosisTargetVocabCd = bedrockConfig.getThisVisitVocab();
        var problemTargetVocabCd = bedrockConfig.getChronicVocab();
        var visitLabelDisplay = "This Visit";
        var activeLabelDisplay = "Active";
        var historicalLabelDisplay = "Historical";
        
        if (condition) {
            try {
                crossMapping = CERN_Platform.getDiscernObject("KIACROSSMAPPING");
                if(!crossMapping){
                    //Log error
                    throw new Error("Win32NomenclatureConverter : An error occured when trying to get the cross mapping object");
                    return;
                }
                else {
                	var convertedNomenclatureId = 0.0;
                	var thisVisitInd = condition.getIsThisVisit();
                	var chronicInd = condition.getIsChronic();
                	var historicInd = condition.getIsHistorical();
                	var thisVisitMapMode = 4;
                    var chronicMapMode = 5;
                    var historicMapMode = 6;
                    
                    if(thisVisitInd) {
                    	// Condition/Diagnosis is This Visit
                    	convertedNomenclatureId = crossMapping.GetDxProbMapping(condition.getPersonValue(), condition.getEncounterValue(), thisVisitMapMode, condition.getNomenclatureValue(), diagnosisTargetVocabCd, this.pprCd, this.positionCd, visitLabelDisplay, activeLabelDisplay, historicalLabelDisplay);
                    }
                    else if(chronicInd) {
                    	// Condition/Problem is Chronic
                    	convertedNomenclatureId = crossMapping.GetDxProbMapping(condition.getPersonValue(), condition.getEncounterValue(), chronicMapMode, condition.getNomenclatureValue(), problemTargetVocabCd, this.pprCd, this.positionCd, visitLabelDisplay, activeLabelDisplay, historicalLabelDisplay);
                    }
                    else if(historicInd) {
                    	// Condition/Problem is Historic
						convertedNomenclatureId = crossMapping.GetDxProbMapping(condition.getPersonValue(), condition.getEncounterValue(), historicMapMode, condition.getNomenclatureValue(), problemTargetVocabCd, this.pprCd, this.positionCd, visitLabelDisplay, activeLabelDisplay, historicalLabelDisplay);
                    }
                    else {
                    	// Somehow cross mapping got called on a condition that is none of the above types. Throw an error
                    	throw new Error("Win32NomenclatureConverter : Cross mapping failed - No valid condition type found.");
                    }
                    
                    return convertedNomenclatureId;
                }
            } catch (err) {
				throw new Error("Win32NomenclatureConverter : Error performing cross mapping - " + err);
            }
        }
    };
})();/**
 * Configuration to be executed when included in an mpage view
 */

MPageEntity.configure(function() {
    if (typeof m_criterionJSON === "undefined" || !m_criterionJSON) {
        return; // we're not in an mpage
    }

    if (typeof CERN_BrowserDevInd !== "undefined" && CERN_BrowserDevInd) {
        MPageEntity.Entity.defaultRequestClass = MPageEntity.XmlHttpRequest;
    } else {
        MPageEntity.Entity.defaultRequestClass = MPageEntity.XmlCclRequest;
    }

    var criterion = JSON.parse(m_criterionJSON).CRITERION;
    MPageEntity.Request.user = criterion.PRSNL_ID;
    MPageEntity.Request.ppr = criterion.PPR_CD;
    MPageEntity.Request.position = criterion.POSITION_CD;
    MPageEntity.Entity.throwRequestErrors = false;
});
/**
 * MPgaeIFrame
 * This class will be utilized in creating and managing iframes within the document.
 * @constructor
 */
function MPageIFrame() {
	this.m_contentXHtml = "";
	this.m_source = "";
	this.m_namespace = "";
	this.m_cssRules = [];
	this.m_cssSources = [];
}

/**
 * Set the content to be displayed within the iframe.  Update the iframe to display added content.
 * @param {String} contentXHtml HTML string to be rendered within iframe
 * @return {undefined}
 */
MPageIFrame.prototype.setContent = function(contentXHtml){
	if (typeof contentXHtml !== "string"){
		throw new Error("Called MPageIFrame.setContent with invalid paramater");
	}
	this.m_contentXHtml = contentXHtml;
};

/**
 * Returns the html content that should be displayed in an iframe
 * @return {String} HTML string to be rendered within iframe
 */
MPageIFrame.prototype.getContent = function(){
	return this.m_contentXHtml;
};

/**
 * Sets the absolute path of static content
 * @param {String} staticContent String representing absolute path to static content
 * @return {undefined}
 */
MPageIFrame.prototype.setStaticContentPath = function(staticContent){
	if (typeof staticContent !== "string"){
		throw new Error("Called MPageIFrame.setStaticContentPath with invalid paramater");
	}
	this.m_staticContent = staticContent;
};

/**
 * Gets the absolute path of the static content
 * @return {String} absolute path of the static content
 */
MPageIFrame.prototype.getStaticContentPath = function(){
	return this.m_staticContent;
};

/**
 * Sets the source to be referenced by the iframe
 * @param {String} src Source (URL) to be pointed towards from the iframe
 * @return {undefined}
 */
MPageIFrame.prototype.setSource = function(src){
	if (typeof src !== "string"){
		throw new Error("Called MPageIFrame.setSource with invalid paramater");
	}
	this.m_source = src;
};

/**
 * Returns the source to be reference by the iframe
 * @return {String} Source (URL) to be pointed towards from the iframe
 */
MPageIFrame.prototype.getSource = function(){
	return this.m_source;
};

/**
 * Namespace utilized to ensure the id of the generated iframe is unique
 * @param {String} namespace Namespace string utilized within the iframe id
 * @return {undefined}
 */
MPageIFrame.prototype.setNamespace = function(namespace){
	if (typeof namespace !== "string"){
		throw new Error("Called MPageIFrame.setNamespace with invalid paramater");
	}
	this.m_namespace = namespace;
};

/**
 * Returns the namespace of the MPageIFrame
 * @return {String} namespace string utilized within iframe id
 */
MPageIFrame.prototype.getNamespace = function(){
	return this.m_namespace;
};

/**
 * Sets a finalize function (takes document as paramater) utilized for attaching event handlers to iframe document
 * <pre>
 * {@code
 * 	mpageIframe.setFinalizeFn(function(iframeDoc){
 * 		$(iframeDoc.body).on("click", function(){
 * 			alert("hi");
 * 		});
 * 	});
 * }
 * </pre>
 * @param {Function} finalizeFn Function (taking iframe document node as paramater) handling attaching event handlers
 * @return {undefined}
 */
MPageIFrame.prototype.setFinalizeFn = function(finalizeFn){
	if (typeof finalizeFn !== "function"){
		throw new Error("Called MPageIFrame.setFinalizeFn with invalid paramater");
	}
	this.m_finalizeFn = finalizeFn;
};

/**
 * Adds a css rule to be associated to the iframe document
 * <pre>
 * {@code
 * 	mpageIframe.addCssRule("body{background-color:red;}");
 * }
 * </pre>
 * @param {String} rule String representing CSS rule
 * @return {undefined}
 */
MPageIFrame.prototype.addCssRule = function(rule){
	if (typeof rule !== "string"){
		throw new Error("Called MPageIFrame.addCssRule with invalid paramater");
	}
	this.m_cssRules.push(rule);
};

/**
 * Adds a css source to be linked to from the iframe document
 * The added css source is expected to live in the 'css' folder of the static content
 * @param {String} cssSource String representing file-name of css file
 * @return {undefined}
 */
MPageIFrame.prototype.addCssSource = function(cssSource){
	if (typeof cssSource !== "string"){
		throw new Error("Called MPageIFrame.addCssSource with invalid paramater");
	}
	this.m_cssSources.push(cssSource);
};

/**
 * Generates HTML string for the iframe element
 * If no source is defined, iframe points to empty "about:blank" source
 * @return {String} HTML string for iframe
 */
MPageIFrame.prototype.render = function(){
	var src = this.getSource() || "about:blank";
	return "<iframe id='mpageIframe" + this.getNamespace() + "' src='" + src + "' scrolling='no' frameborder='0'></iframe>";
};

/**
 * Returns the HTML element for the created iframe
 * @return {HTMLNode} iframe node generated by class
 */
MPageIFrame.prototype.getRootElement = function(){
	return document.getElementById("mpageIframe" + this.getNamespace());
};

/**
 * Writes the associated content into the generated iframe document
 * @return {undefined}
 */
MPageIFrame.prototype.updateContent = function(){
	var doc = this.getRootElement().contentWindow.document;
	doc.open();
	//Add doctype to follow w3c standards
	doc.write("<!DOCTYPE HTML>");
	doc.write(this.getContent());
	doc.close();
};

/**
 * Resizes the iframe to take up full height of internal content (height + margins)
 * @return {undefined}
 */
MPageIFrame.prototype.resize = function(){
	var docFrame = this.getRootElement();
	var doc = docFrame.contentWindow.document;
	//Set width to default during initial height and content width calculations
	docFrame.style.width = "";
	var marginHeight = $(doc.body).outerHeight(true) - $(doc.body).outerHeight();
	var marginWidth = $(doc.body).outerWidth(true) - $(doc.body).outerWidth();
	docFrame.style.height = doc.body.scrollHeight + marginHeight + "px";
	//Update width if content is wider than iframe
	var contentWidth = doc.body.scrollWidth + marginWidth;
	if (contentWidth > $(docFrame).width()){
		docFrame.style.width = contentWidth + "px";
	}
};


/**
 * Appends a style to head of iframe document containing associated custom CSS rules
 * @return {undefined}
 */
MPageIFrame.prototype.updateCss = function(){
	var cssRuleCnt = this.m_cssRules.length;
	//Append custom css rules if defined
	if (cssRuleCnt){
		var doc = this.getRootElement().contentWindow.document;
		var head = $(doc).find("head");
		var css = '<style type="text/css">';
		for (var i = 0; i < cssRuleCnt; i++){
			var cssRule = this.m_cssRules[i];
			css += cssRule;
		}
		css += "</style>";
		$(head).append(css);
	}
};

/**
 * Finalizes the iframe object after creation.
 * Updates CSS, Adds event handlers, resizes iframe
 * @return {undefined}
 */
MPageIFrame.prototype.finalize = function(){
	var docFrame = this.getRootElement();
	var doc = docFrame.contentWindow.document;
	//Update the content
	this.updateContent();
	//Perform finalize postprocessing
	if(this.m_finalizeFn){
		this.m_finalizeFn(doc);
	}
	//Append CSS style sheets
	this.addCssStyleSheets();
	//Append custom css rules if defined
	this.updateCss();
	//Update height to full content height
	this.resize();
};

/**
 * Sets a base path in the head of the iframe document
 * @return {undefined}
 */
MPageIFrame.prototype.addBasePath = function(){
	var docFrame = this.getRootElement();
	var doc = docFrame.contentWindow.document;
	var staticLocation = this.getAbsoluteStaticContentPath();
	var head = $(doc).find("head");
	var base = '<base href="' + staticLocation + '"></base>';
	$(head).append(base);
};

/**
 * Return the static content path
 * @return {String} The path to the static content (compressed-resources) folder
 */
MPageIFrame.prototype.getAbsoluteStaticContentPath = function(){
	var docFrame = this.getRootElement();
	var staticContent = this.getStaticContentPath();
	var staticLocation = "";
	if(CERN_Platform.inMillenniumContext()){
		staticLocation = staticContent;
	}
	else{
		var parentWindowLocation = docFrame.contentWindow.parent.document.location;
		staticLocation = parentWindowLocation.origin + parentWindowLocation.pathname + "/../" + staticContent;
	}
	return staticLocation;
};

/**
 * Links to all associated style sets from the head of the iframe document
 * @returns {undefined}
 */
MPageIFrame.prototype.addCssStyleSheets = function(){
	var self = this;
	var docFrame = this.getRootElement();
	var staticContentPath = this.getAbsoluteStaticContentPath();
	var cssFiles = this.m_cssSources;
	var cssFileCnt = cssFiles.length;
	var doc = docFrame.contentWindow.document;
	var head = $(doc).find("head");
	var absoluteCssFileSrc = "";
	var $cssLinkTag = null;
	for (var i = 0; i < cssFileCnt; i++){
		absoluteCssFileSrc = staticContentPath + "/css/iframe/" + cssFiles[i];
		//Append link tags to head for each CSS source to add to iframe
		(function(cssHref){
			//Attach empty link tag to head before loading CSS content
			$cssLinkTag = $('<link rel="stylesheet" type="text/css" />');
			$(head).append($cssLinkTag);
			//Resize the iframe on css content load to account for updated height
			$cssLinkTag.load(function(){
				self.resize();
			}).attr("href", cssHref);
		})(absoluteCssFileSrc);
	}
};
/**
 * A collection of functions which can be used to maintain, create, destroy and update menus.
 * The MP_MenuManager function keeps a copy of all of the Menu objects that have been created
 * for the current view.  If a Menu object is updated outside of these functions, the updated
 * version of the object should replace the stale version that is stored here by using the
 * updateMenuObject functionality.
 * @constructor
 */
var MenuManager = function() {
	//A collection of menu objects references by a unique i
	this.menuCollection = {};
	//Active Menu Stack
	this.menuStack = [];
	//Root menu offsetParent which will be used by submenus to attach their content
	this.offsetParent = null;
};

/**
 * This function will be used to add Menu objects to the collection of Menu objects.  This collection of
 * Menu objects will be the one source of this type of object and will be used when showing menus.
 * @param {Menu} menuObj An instance of the Menu object
 * @return {boolean} true if the object was added successfully, false otherwise
 */
MenuManager.prototype.addMenuObject = function(menuObj) {
	var menuId = "";
	//Check that he object is not null and that the object type is Menu
	if(!(Menu.prototype.isPrototypeOf(menuObj))) {
		logger.logError("MenuManager.addMenuObject only accepts objects of type Menu or any object that uses Menu.prototype");
		return false;
	}

	//Check for a valid id.
	menuId = menuObj.getId();
	if(!menuId) {
		//Menu id is not populated
		logger.logError("MenuManager.addMenuObject: no/invalid menu id given");
		return false;
	}
	else if(this.menuCollection[menuId]) {
		//Menu id is already in use
		logger.logError("MenuManager.addMenuObject: menu id" + menuId + " is already in use");
		return false;
	}

	//Add the Menu Object to the list of Menu objects
	this.menuCollection[menuId] = menuObj;
	return true;
};

/**
 * Closes the menus based on the elements currently in the menuStack.  If the forceClose flag is set to true, all menus will be
 * closed regardless of where a user is hovering.  If the forceClose flag is set to true all menus will be closed up to the first menu
 * that is being hovered over by the user.
 * @param {boolean} forceClose A flag which determines if all menus should be closed or if if we should stop closing menus when we find one
 * that the user is still hovering over.
 * @return {boolean} True if the top menu was closed successfully, false otherwise
 */
MenuManager.prototype.closeMenuStack = function(forceClose) {
	var anchorActiveClass = "";
	var topMenuItem = null;

	try {
		//Check to see if there are any menus on the stack
		topMenuItem = this.menuStack.pop();
		if(topMenuItem) {
			//Check to see if the cursor is still over this menu, if so return
			if(!forceClose) {
				if(topMenuItem.isMouseOverMenu()) {
					//Push the menu back on the stack since we aren't closing it
					this.menuStack.push(topMenuItem);
					return true;
				}
			}

			//Delete the menu DOM elements
			$("#" + topMenuItem.getContentElementId()).remove();
			topMenuItem.setContentElementId("");

			//Remove the active class for the anchor element if supplied
			anchorActiveClass = topMenuItem.getAnchorActiveClass();
			if(anchorActiveClass) {
				$("#" + topMenuItem.getAnchorElementId()).removeClass(anchorActiveClass);
			}

			//Mark the menu as inactive so it can update all of its MenuItems with the proper active indicator
			topMenuItem.setIsActive(false);
			topMenuItem.setIsVisible(false);

			//Reset the mouse hover flag
			topMenuItem.setIsMouseOverMenu(false);

			//Clear the hover timeout since we are forcing the menu closed
			topMenuItem.clearHoverTimeout();

			//Close the next menu on stack and close it.
			return this.closeMenuStack(forceClose);
		}
		//Reset the offset parent since we have closed all menus down to the root
		this.offsetParent = null;
		return true;
	}
	catch(err) {
		logger.logJSError(err, null, "MenuManager", "closeMenu");
		return false;
	}
};

/**
 * Deletes the Menu object with the associated id of menuId from the collection of Menu objects.
 * @param {string} menuId The id of the Menu item to be deleted
 * @param {boolean} True if the menu was removed from the collection
 */
MenuManager.prototype.deleteMenuObject = function(menuId) {
	return delete this.menuCollection[menuId];
};

/**
 * Retrieves the Menu object with the associated id of menuId.
 * @param {string} menuId The id of the Menu object to retrieve
 * @return {Menu} The Menu object if it exists, null otherwise
 */
MenuManager.prototype.getMenuObject = function(menuId) {
	return this.menuCollection[menuId] || null;
};

/**
 * Render and show the menu based on the settings applied in the Menu object referenced by the menuId parameter.  This function will
 * create the container for the menu and have the menu populate the contents for that container.
 * @param {string} menuId The id of the Menu object to render
 * @return {boolean} True if the menu was rendered successfully, false otherwise.
 */
MenuManager.prototype.showMenu = function(menuId) {
	var anchorActiveClass = "";
	var anchorElement = null;
	var contentParentElement = null;
	var menuClass = "";
	var menuControl = null;
	var menuEle = null;
	var menuItems = null;
	var menuObj = null;

	//Get the Menu object
	menuObj = this.getMenuObject(menuId);
	if(!menuObj) {
		logger.logError("Menu " + menuId + " does not exist");
		return false;
	}

	//See if the menu already exists, if so delete it
	$("#menuContent" + menuId).remove();

	//See if this is a root menu.  If so close all other open menus
	if(menuObj.isRootMenu()) {
		this.closeMenuStack(true);
	}

	//Create the main container for the menu
	menuClass = (menuObj.isRootMenu()) ? "menu-container-root" : "menu-container-submenu";
	menuEle = $("<div></div>").attr("id", "menuContent" + menuId).addClass(menuClass + " " + menuObj.getTypeClass());
	
	//Check to see if the menu should be persistent.  If it is persistent ignore the hover events else create the hover events.
	if(!(menuObj.isPersistent() && menuObj.isRootMenu())){  
		//Setup the hover actions so we know which menu item the user is hovering over
		menuEle.hover(function() {
			//Set the flag to indicate that the user is hovering over the menu content
			menuObj.setIsMouseOverMenu(true);
			//Clear the timeout since we are back in the menu
			menuObj.clearHoverTimeout();
		}, function() {
			//Set the flag to indicate that the user is not hovering over the menu content
			menuObj.setIsMouseOverMenu(false);
			//Set the timeout since we have left the menu
			menuObj.startHoverTimeout();
		});
	}
	//Set the id for the menu's content section
	menuObj.setContentElementId("menuContent" + menuId);

	//Tell the menu object to create its own content
	menuItems = menuObj.generateMenuContent();
	$(menuItems).each(function(index, element) {
		$(menuEle).append(element);
	});

	//Apply the active class for the anchor element if supplied
	anchorActiveClass = menuObj.getAnchorActiveClass();
	if(anchorActiveClass) {
		$("#" + menuObj.getAnchorElementId()).addClass(anchorActiveClass);
	}

	//Append the menu to the offsetParent for the anchor so it will scroll correctly
	anchorElement = $("#" + menuObj.getAnchorElementId());
	//If the developer has defined a content parent element id then append the content to that location
	contentParentElement = $("#" + menuObj.getContentParentId());
	if(contentParentElement.length){
		$(contentParentElement).append(menuEle);
	}
	else{
		$(document.body).append(menuEle);
	}

	//We must explicitly set the width of the menu element for the controls framework
	$(menuEle).width($(menuEle).outerWidth());
	//Create the controls DetailDialog for our menu visuals
	menuControl = new MPageControls.DetailDialog(anchorElement, menuEle);
	menuControl.setAutoFlipHorizontal(menuObj.autoFlipHorizontal());
	menuControl.setAutoFlipVertical(menuObj.autoFlipVertical());
	menuControl.setElementCorner(menuObj.getAnchorConnectionCorner());
	menuControl.setContentsCorner(menuObj.getContentConnectionCorner());
	menuControl.show();

	//Push this menu onto the stack and update all of the necessary identifiers
	menuObj.setIsActive(true);
	menuObj.setIsVisible(true);
	if(menuObj.isRootMenu() && !menuObj.isPersistent()) {
		menuObj.startHoverTimeout(3000);
	}
	this.menuStack.push(menuObj);
};

/**
 * This function will update the visuals of the top menu currently being shown.  This function is typically
 * called when visual elements of a menu are being changed, such as the label for a menu item.
 * @param {string} menuId The id of the menu that needs to be refreshed.
 */
MenuManager.prototype.refreshMenuDisplay = function(menuId) {
	var menuObj = null;
	var topMenuIndex = 0;

	//Get the Menu object
	menuObj = this.getMenuObject(menuId);
	if(!menuObj) {
		logger.logError("Menu " + menuId + " does not exist");
		return false;
	}

	//Check to see if the menu is on top of the menu stack
	topMenuIndex = this.menuStack.length - 1;
	if(topMenuIndex >= 0 && menuObj === this.menuStack[topMenuIndex]) {
		this.showMenu(menuId);
	}
};

/**
 * Updates the existing Menu with a new instance of the object.  If the menu object does not exist it is added to the
 * collection
 * @param {Menu} menuObj The updated instance of the Menu object.
 * @return {boolean} True if the menu object was added/updated successfully, false otherwise.
 */
MenuManager.prototype.updateMenuObject = function(menuObj) {
	//Check that the object is not null and that the object type is Menu
	if(!Menu.prototype.isPrototypeOf(menuObj)) {
		logger.logError("MenuManager.updateMenuObject only accepts objects of type Menu");
		return false;
	}

	//Blindly update the Menu object.  If it didn't previously exist, it will now.
	this.menuCollection[menuObj.getId()] = menuObj;
	return true;
};

//This should only be instantiated once
/*eslint-disable no-unused-vars*/
var MP_MenuManager = new MenuManager();
/*eslint-enable no-unused-vars*//**
 * The MenuItem object contains all of the basic information needed for the various menu item elements.  Depending on how these
 * variables are set the menu will flex accordingly.  All elements that will be displayed within a menu will inherit from this
 * base class.
 * @constructor
 */
function MenuItem(menuId) {

	//A boolean to determine if this MenuItem is active or not
	this.m_activeInd = false;

	//This is the developer defined click function that can be created to handle any custom logic that needs to occur when the menu item
	// is selected
	this.m_clickFunc = function() {};

	//This flag will determine if the containing menu should be closed when the item is clicked
	this.m_closeOnClick = true;

	//This is the default function that will be executed when the MenuItem is clicked
	this.m_defaultClickFunction = function() {};

	//This flag will determine if the menu item is disabled or not.
	this.m_disabledInd = false;

	//This will be the id of the DOM element associated with this MenuItem
	this.m_elementId = "";

	//This will be the label used when the MenuItem is shown within a menu
	this.m_label = "";

	//The id given to the MenuItem object.  This id should be unique and will be used to set/retrieve the
	//MenuItem object
	this.m_menuItemId = menuId;

	//This type CSS class will be used to style the different types of menu item elements
	this.m_menuItemTypeClass = "";

}

/** Checkers **/

/**
 * A check to see if this MenuItem object will force the containing Menu to close when clicked
 * @return {boolean} True if the containing menu should close, false otherwise
 */
MenuItem.prototype.closeOnClick = function() {
	return this.m_closeOnClick;
};

/**
 * Checks to see if this MenuItem is actively being used or shown to the user
 */
MenuItem.prototype.isActive = function() {
	return this.m_activeInd;
};

/**
 * A check to see if this MenuItem object is disabled or not
 * @return {boolean} True if the menu item is disabled, false otherwise
 */
MenuItem.prototype.isDisabled = function() {
	return this.m_disabledInd;
};

/** Getters **/

/**
 * Returns the click function assigned to this MenuItem object.
 * @return {function} The function to be assigned to the click action for this MenuItem
 */
MenuItem.prototype.getClickFunction = function() {
	return this.m_clickFunc;
};

/**
 * Retrieves the default onClick function for the MenuItem object.  This default functionality should be created for each object
 * that uses the MenuItem prototype if special actions need to occur when the element is clicked.  The developer will still be able
 * to define custom actions in the standard onClick function.
 * @return {function} The default function to execute when an element is clicked.
 */
MenuItem.prototype.getDefaultClickFunction = function() {
	return this.m_defaultClickFunction;
};

/**
 * Retrieves the DOM element id associated with the visuals for this MenuItem object
 * @return {string} The DOM element id given to this MenuItem object
 */
MenuItem.prototype.getElementId = function() {
	return this.m_elementId;
};

/**
 * Retrieves the id given to this MenuItem object
 * @return {string} The id given to this MenuItem object
 */
MenuItem.prototype.getId = function() {
	return this.m_menuItemId;
};

/**
 * Retrieves the menu item label for this MenuItem object
 * @return {string} The label given to this MenuItem object
 */
MenuItem.prototype.getLabel = function() {
	return this.m_label;
};

/**
 * Retrieves the menu item type class given to this MenuItem object for visual styling purposes
 * @return {string} The type class given to this MenuItem object
 */
MenuItem.prototype.getTypeClass = function() {
	return this.m_menuItemTypeClass;
};

/** Setters **/

/**
 * Sets the function to execute when the MenuItem item is clicked within the context of a menu
 * @param {function} clickFunc The function that will be executed when the MenuItem item is clicked
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setClickFunction = function(clickFunc) {
	if(typeof clickFunc === "function") {
		this.m_clickFunc = clickFunc;
	}
	return this;
};

/**
 * Sets the flag which determines if the menu which contains this MenuItem should be closed when the user selects this item.
 * @param {boolean} closeFlag The boolean that identifies whether the containing menu will be closed or not.
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setCloseOnClick = function(closeFlag) {
	if(typeof closeFlag === "boolean") {
		this.m_closeOnClick = closeFlag;
	}
	return this;
};

/**
 * Retrieves the default onClick function for the MenuItem object.  This default functionality should be created for each object
 * that uses the MenuItem prototype if special actions need to occur when the element is clicked.  The developer will still be able
 * to define custom actions in the standard onClick function.
 * @param {function} The default function to execute when an element is clicked.
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setDefaultClickFunction = function(clickFunc) {
	if(typeof clickFunc === "function") {
		this.m_defaultClickFunction = clickFunc;
	}
	return this;
};

/**
 * Sets the id which will be used to identify the DOM element associated with this MenuItem
 * @param {string} elementId The id that will be assigned to this MenuItem object
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setElementId = function(elementId) {
	if(typeof elementId === "string") {
		this.m_elementId = elementId;
	}
	return this;
};

/**
 * Sets the id which will be used to identify a particular MenuItem object.
 * @param {string} id The id that will be assigned to this MenuItem object
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setId = function(id) {
	if(id && typeof id === "string") {
		this.m_menuItemId = id;
	}
	return this;
};

/**
 * Sets the active flag for this MenuItem indicating that the containing menu is being shown
 * @param {boolean} activeInd The indicator which will be used to determine if the menu is active or not
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setIsActive = function(activeInd) {
	if( typeof activeInd === "boolean") {
		this.m_activeInd = activeInd;
	}
	return this;
};

/**
 * Sets the flag which determines if the menu item should be disabled or not.
 * @param {boolean} disabled The boolean that identifies whether the menu item should be disabled or not
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setIsDisabled = function(disabled) {
	if(typeof disabled === "boolean") {
		this.m_disabledInd = disabled;
	}
	return this;
};

/**
 * Sets the label used when showing the MenuItem within the context of a menu.  The display of the menu will be updated if the menu
 * is currently being shown
 * @param {string} label The label that will be shown within the menu for this menu item
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setLabel = function(label) {
	var menuContainerId = "";

	if(label && typeof label === "string") {
		this.m_label = label;

		//Update the label if this menu item is acive
		if(this.isActive()) {
			//Refresh the menu contents
			menuContainerId = this.getElementId().replace(/menuSel[0-9]+-/, "");
			MP_MenuManager.refreshMenuDisplay(menuContainerId);
		}
	}

	return this;
};

/**
 * Sets the specific css class for this type of MenuItem object.  This class will be used for styling purposes
 * @param {string} typeClass The CSS class that will be assigned to this MenuItem object for styling purposes
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setTypeClass = function(typeClass) {
	if(typeof typeClass === "string") {
		this.m_menuItemTypeClass = typeClass;
	}
	return this;
};

/**
 * This function is used to generate the default HTML for the MenuItem.  This includes a selection indicator and the label.  Any
 * object which inherits the MenuItem prototype can override this function and create its own selection content.
 * @return {[jQuery]} An array of jQuery objects which will be appended to the menu.
 */
MenuItem.prototype.generateSelectionContent = function() {
	return [$("<span>&nbsp;</span>").addClass("menu-selection-ind"), $("<span></span>").addClass("menu-selection").html(this.getLabel())];
};
/**
 * The Menu object inherits from the MenuItem object and adds additional functionality used to create standard menus.
 * Specifically the developer can define the individual items that will be displayed within the menu.  Those elements
 * must be an object that inherits from the MenuItem object.
 * @constructor
 */
function Menu(menuId) {
	//Set the id for this object
	this.setId(menuId);

	//Set the close on click flag to false
	this.setCloseOnClick(false);

	//Set the default on click function for this element.  This function will be run regardless of the existence of the
	//developer defined click function.  This function is used when a menu items is defined as a submenu.  If the menu is
	//defined as a root menu, this will be ignored.
	/*eslint-disable no-unused-vars*/
	this.setDefaultClickFunction(function(clickEvent) {
		MP_MenuManager.showMenu(this.getId());
	});
	/*eslint-enable no-unused-vars*/
	
	//This following flags are used to allow the menu content to flip horizontally and vertically when there isn't room on the screen to 
	//accommodate them based on the anchor/content connection corners.
	this.m_autoFlipVertical = true;
	this.m_autoFlipHorizontal = true;
	
	//This string identifies the CSS class to add to the anchor element when the menu it is
	//associated with is active
	this.m_anchorActiveClass = "";

	//This string identifies the id of the anchor element that this menu will be attached to
	this.m_anchorElementId = "";

	//This object defines which corners of the content section and the anchor will be connected.  The default
	//values attach the bottom right corner of the anchor with the top right corner of the content
	this.anchorCorner = null;
	this.contentCorner = null;

	//This string identifies the id of the content element that will be created when the menu is opened.  This id
	//will be created on the fly when the menu is opened.
	this.m_contentElementId = "";
	
	//This string will identify the id of the element to append the menu to.  If this is not defined the menu will be appended to the body
	this.m_contentParentId = "";
	
	//This flag will determine if the menu can be shown as persistent.  If set, no hover timeout or mouseleave will cause the 
	//menu to disappear.  This setting is only valid for root menus
	this.m_isPersistent = false;

	//This this the timeout reference we are using to determine if the menu contents should still be displayed or not
	this.m_hoverTimout = null;

	//This array contains the list of MenuItem objects which will make up the contents of the Menu.  This element starts off
	//as null to ensure each instance of the Menu object gets its own list of MenuItem objects.
	this.m_menuItemArr = null;

	//This will be the function which gets executed when the menu is being closed
	this.m_onCloseFunction = null;

	//This boolean will be used to determine if this menu item is the root or a submenu item
	this.m_rootMenuInd = false;

	//This boolean indicates if the user is hovering over the menu or not
	this.m_mouseOverContent = false;

	//This boolean indicated whether the user has their mouse over the MenuItem selection within a menu
	this.m_mouseOverAnchor = false;

	//This boolean indicates if the menu contents are visible to the user or not
	this.m_visibleInd = false;

}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
Menu.prototype = new MenuItem();
Menu.prototype.constructor = MenuItem;

/** Checkers **/

/**
 * Checks to see if the menu should be auto flipped horizontally by the detailed dialog controls.
 * @return {boolean} True if this Menu should be auto flipped horizontally
 */
Menu.prototype.autoFlipHorizontal = function() {
	return this.m_autoFlipHorizontal;
};

/**
 * Checks to see if the menu should be auto flipped vertically by the detailed dialog controls.
 * @return {boolean} True if this Menu should be auto flipped vertically
 */
Menu.prototype.autoFlipVertical = function() {
	return this.m_autoFlipVertical;
};

/**
 * Checks to see if the MenuItem with the passed in id is already defined within the context of this menu.
 */
Menu.prototype.containsMenuItem = function(menuItemId) {
	var x = 0;
	var itemArr = this.m_menuItemArr;
	if(!itemArr) {
		return false;
	}
	for( x = itemArr.length; x--; ) {
		if(itemArr[x].getId() === menuItemId) {
			return true;
		}
	}
	return false;
};

/**
 * Checks to see if the menu is a root menu or a sub menu element
 * @return {boolean} True if this Menu is considered a root menu, false otherwise
 */
Menu.prototype.isRootMenu = function() {
	return this.m_rootMenuInd;
};

/**
 * Checks to see if the user is hovering over the menu or not
 * @return {boolean} True if the mouse is currently over the menu content
 */
Menu.prototype.isMouseOverMenu = function() {
	return this.m_mouseOverContent;
};

/**
 * Checks to see if the user is hovering over the menu anchor or not.
 * @return {boolean} True if the mouse is hovering over the menu anchor, false otherwise
 */
Menu.prototype.isMouseOverAnchor = function() {
	return this.m_mouseOverAnchor;
};

/**
 * Checks to see if the menu should be persistent or not.  A persistent menu does not have a hover timeout nor does the menu 
 * disappear when the user hovers outside of the menu's area.  The menu can only be closed programatically or when another menu
 * is opened.
 * @return {boolean} True if the menu should be shown as persistent, false otherwise
 */
Menu.prototype.isPersistent = function() {
	return this.m_isPersistent;
};

/**
 * Checks to see if the menu contents are visible to the user or not.
 * @return {boolean} True if the menu is currently visible, false otherwise
 */
Menu.prototype.isVisible = function() {
	return this.m_visibleInd;
};

/** Getters **/

/**
 * Gets the CSS class to apply to the menu's anchor element when the menu is active
 * @return {string} The CSS class to apply to the anchor element when the associated menu is active
 */
Menu.prototype.getAnchorActiveClass = function() {
	return this.m_anchorActiveClass;
};

/**
 * Gets the corner of the anchor element which the content section should connect with.
 * @return {[string]} An array of two strings which identify which corner of the anchor element should connect with the content
 * element.
 */
Menu.prototype.getAnchorConnectionCorner = function() {
	if(!this.anchorCorner){
		return ["bottom", "right"];
	}
	return this.anchorCorner;
};

/**
 * Gets the id of the DOM element that this menu is attached to.
 * @return {string} The id of the DOM element that this menu is attached to
 */
Menu.prototype.getAnchorElementId = function() {
	return this.m_anchorElementId;
};

/**
 * Gets the function to call when the Menu is closed
 * @return {function} The function to execute when the Menu is closed
 */
Menu.prototype.getCloseFunction = function() {
	return this.m_onCloseFunction;
};

/**
 * Gets the corner of the content section which the anchor element should connect with.
 * @return {[string]} An array of two strings which identify which corner of the content element should connect with the anchor
 * element.
 */
Menu.prototype.getContentConnectionCorner = function() {
	if(!this.contentCorner){
		return ["top", "right"];
	}
	return this.contentCorner;
};

/**
 * Gets the id of the content container element that is created when the menu is active.
 * @return {string} The id of the DOM element that contains all of the menus contents.
 */
Menu.prototype.getContentElementId = function() {
	return this.m_contentElementId;
};

/**
 * Gets the id of the parent element where the content will be appended.  If this is not set the the document.body will be used
 * @return {string} The id of the DOM element where the menu content will be appended.
 */
Menu.prototype.getContentParentId = function() {
	return this.m_contentParentId;
};

/**
 * Gets the array of MenuItem elements that are set to show within this menu.
 * @return {[MenuItem]} An array of MenuItem object that will be used when creating the menu
 */
Menu.prototype.getMenuItemArray = function() {
	return this.m_menuItemArr;
};

/** Setters **/

/**
 * Sets the corner of the anchor element which should connect with the content section.  The cornerArr should only contain two
 * strings.  The first string will determine the top or bottom edge of the anchor element and the second string will determine the
 * left or right edge of the anchor element.  For example, ["top", "left"].
 * @param {[string]} cornerArr The string array identifying the corner of the anchor element which should connect with the content
 * section
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorConnectionCorner = function(cornerArr) {
	if( typeof cornerArr === "object" && cornerArr.length) {
		this.anchorCorner = cornerArr;
	}
	return this;
};

/**
 * Sets the CSS class to apply to the anchor element when it's associated menu is active
 * @param {string} activeClass The CSS class to apply to the anchor element when the menu is active
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorActiveClass = function(activeClass) {
	if( typeof activeClass === "string") {
		this.m_anchorActiveClass = activeClass;
	}
	return this;
};

/**
 * Sets the id of the DOM element that this menu is anchored to
 * @param {string} anchorId The id of the DOM element that this menu is attached to
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorElementId = function(anchorId) {
	if( typeof anchorId === "string") {
		this.m_anchorElementId = anchorId;
	}
	return this;
};

/**
 * Sets the flag to allow/disallow the horizontal repositioning of menus based on available space.
 * @param {boolean} horizontalFlip A flag used to set the horizontal flip indicator of the detail dialog that is used to house the menu contents
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAutoFlipHorizontal = function(horizontalFlip) {
	if( typeof horizontalFlip === "boolean") {
		this.m_autoFlipHorizontal = horizontalFlip;
	}
	return this;
};

/**
 * Sets the flag to allow/disallow the vertical repositioning of menus based on available space.
 * @param {boolean} verticalFlip A flag used to set the vertical flip indicator of the detail dialog that is used to house the menu contents
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAutoFlipVertical = function(verticalFlip) {
	if( typeof verticalFlip === "boolean") {
		this.m_autoFlipVertical = verticalFlip;
	}
	return this;
};

/**
 * Sets the function that will be called when this menu is closed
 * @param {function} closeFunc The function to execute when the menu is closed
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setCloseFunction = function(closeFunc) {
	if(typeof closeFunc === "function") {
		this.m_onCloseFunction = closeFunc;
	}
	return this;
};

/**
 * Sets the corner of the content container element which should connect with the anchor element.  The cornerArr should only contain
 * two strings. The first string will determine the top or bottom edge of the content container element and the second string will
 * determine the left or right edge of the content container element.  For example, ["top", "left"].
 * @param {[string]} cornerArr The string array identifying the corner of the anchor element which should connect with the content
 * section
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentConnectionCorner = function(cornerArr) {
	if( typeof cornerArr === "object" && cornerArr.length) {
		this.contentCorner = cornerArr;
	}
	return this;
};

/**
 * Sets the id of the DOM element that contains this menu's content.  This id will be set when the menu is being shown and removed
 * with it is closed.
 * @param {[string]} elementId The id of the DOM element that contains all of the menus contents.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentElementId = function(elementId) {
	if( typeof elementId === "string") {
		this.m_contentElementId = elementId;
	}
	return this;
};

/**
 * Sets the id of the DOM element where the menu contents will be appended.  If this value is set in the root menu 
 * all submenus will also be appended to the same parent.  If no value is supplied then the menu content will be
 * appended to the document.body
 * @param {[string]} parentId The id of the DOM element where the menu content will be appended
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentParentId = function(parentId) {
	if( typeof parentId === "string") {
		this.m_contentParentId = parentId;
	}
	return this;
};

/**
 * Sets the element id for the sub menu selection.  This element is only used when creating sub menus
 * @param {string} elementId The element id for the sub menu selection
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setElementId = function(elementId) {
	if(typeof elementId === "string") {
		this.m_elementId = elementId;
		this.m_anchorElementId = elementId;
	}
	return this;
};

/**
 * Sets the active flag for this menu item indicating that the menu is being shown.  Setting a Menu item as active also sets all of
 * the MenuItems that are contained within it to active
 * @param {boolean} activeInd The indicator which will be used to determine if the menu is active or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsActive = function(activeInd) {
	var menuItems = null;
	var x = 0;

	if( typeof activeInd === "boolean") {
		this.m_activeInd = activeInd;
	}

	//Set all of the menuItems as active/inactive as well
	menuItems = this.getMenuItemArray();
	if(menuItems && menuItems.length) {
		for( x = menuItems.length; x--; ) {
			menuItems[x].setIsActive(activeInd);
		}
	}

	return this;
};

/**
 * Sets the flag which determines if this menu is a root menu or not
 * @param {boolean} rootMenuInd The indicator which will be used to determine if the menu is a root menu or a submenu
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsRootMenu = function(rootMenuInd) {
	if( typeof rootMenuInd === "boolean") {
		this.m_rootMenuInd = rootMenuInd;
	}
	return this;
};

/**
 * Sets the flag which indicates if the mouse is hovering over the menu's contents or not.
 * @param {boolean} mouseOver The indicator which indicates if the mouse if over the menu's contents or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsMouseOverMenu = function(mouseOver) {
	if( typeof mouseOver === "boolean") {
		this.m_mouseOverContent = mouseOver;
	}
	return this;
};

/**
 * Sets the flag which indicates if the mouse is hovering over the menu's anchor or not.
 * @param {boolean} mouseOver The indicator which indicates if the mouse if over the menu's anchor or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsMouseOverAnchor = function(mouseOver) {
	if( typeof mouseOver === "boolean") {
		this.m_mouseOverAnchor = mouseOver;
	}
	return this;
};


/**
 * Sets the flag which indicates if the menu is persistent or not.  A persistent menu does not have a hover timeout nor does the menu 
 * disappear when the user hovers outside of the menu's area.  The menu can only be closed programatically or when another menu
 * is opened.
 * @param {boolean} persistent The boolean which indicates if the menu should be persistent or not.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsPersistent = function(persistent) {
	if( typeof persistent === "boolean") {
		this.m_isPersistent = persistent;
	}
	return this;
};

/**
 * Sets the visible flag for this menu item indicating that the menu is being shown
 * @param {boolean} visibleInd The indicator which will be used to determine if the menu is being shown or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsVisible = function(visibleInd) {
	if( typeof visibleInd === "boolean") {
		this.m_visibleInd = visibleInd;
	}
	return this;
};

/** Helper Functions **/

/**
 * Adds a MenuItem object to the list of menu items that will be shown within this menu
 * @param {MenuItem} menuItem The MenuItem object to add to the Menu.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.addMenuItem = function(menuItem) {
	//Verify that this element is a MenuItem
	if(MenuItem.prototype.isPrototypeOf(menuItem)) {
		if(!this.m_menuItemArr) {
			this.m_menuItemArr = [];
		}
		this.m_menuItemArr.push(menuItem);
		
		//Add the menu to the collection within MP_MenuManager so we can reference it later when attempting to render the menu
		if(Menu.prototype.isPrototypeOf(menuItem)) {
			//Make sure we append the submenu to the same parent as the root
			menuItem.setContentParentId(this.m_contentParentId);
			MP_MenuManager.updateMenuObject(menuItem);
		}
	}
	return this;
};

/**
 * Sets the hover timeout for the menu contents.  This hover timeout will be used when moving the mouse over and out of the menu's
 * content.  This can be set to a specific time or default to 250 ms.
 * @param {number} setTime The time in milliseconds before the menu will atempt to close itself
 */
Menu.prototype.startHoverTimeout = function(setTime) {
	var that = this;
	setTime = setTime || 250;
	this.clearHoverTimeout();
	this.m_hoverTimout = window.setTimeout(function() {
		//Get the close function and execute it
		var closeFunc = that.getCloseFunction();
		if(closeFunc) {
			closeFunc.call(that);
		}
		MP_MenuManager.closeMenuStack(false);
	}, setTime);

};

/**
 * Clears the hover timeout for the menu.  This happens when the user hovers over the menu's content or when the user hovers
 * over the menu's anchor.
 */
Menu.prototype.clearHoverTimeout = function() {
	window.clearTimeout(this.m_hoverTimout);
};

/**
 * This function will insert a MenuItem object into the list of MenuItems that will be shown within the menu.
 * @param {MenuItem} menuItem The MenuItem object to insert
 * @param {number} index The index where the MenuItem will be inserted
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.insertMenuItem = function(menuItem, index) {
	//create the menu item array if it is null
	if(!this.m_menuItemArr) {
		this.m_menuItemArr = [];
	}

	if(typeof index !== "number") {
		return this;
	}

	//Verify that this element is a MenuItem and the index is valid
	if(MenuItem.prototype.isPrototypeOf(menuItem) && index <= this.m_menuItemArr.length && index >= 0) {
		this.m_menuItemArr.splice(index, 0, menuItem);
		//Add the menu to the collection so we can reference it later when attempting to render the menu
		if(Menu.prototype.isPrototypeOf(menuItem)) {
			MP_MenuManager.updateMenuObject(menuItem);
		}
	}
	return this;
};

/**
 * This function removes a specific MenuItem element from the menu item array
 * @param {MenuItem} menuItem The MenuItem object to remove from the Menu's list of menu items.
 * @return {boolean} True if a MenuItem was removed, false otherwise
 */
Menu.prototype.removeMenuItem = function(menuItem) {
	var x = 0;
	var menuItemArr = this.m_menuItemArr;

	if(!menuItemArr) {
		return false;
	}
	//Verify that this element is a MenuItem
	if(MenuItem.prototype.isPrototypeOf(menuItem) && !this.isActive()) {
		for( x = menuItemArr.length; x--; ) {
			if(menuItemArr[x] === menuItem) {
				menuItemArr.splice(x, 1);
				//Remove the menu from  the collection
				if(Menu.prototype.isPrototypeOf(menuItem)) {
					MP_MenuManager.deleteMenuObject(menuItem);
				}
				return true;
			}
		}
	}
	return false;
};

/**
 * This function is used to generate the HTML content for this menu.  It examines each MenuItem that is contained within
 * the m_menuItemArray and generates the content for each item, applies the hover events, applies the click events and returns an
 * array of jQuery objects which will make up the contents of the menu.
 * @return {[jQuery]} An array of jQuery object which make of the menu contents.
 */
Menu.prototype.generateMenuContent = function() {
	var disabledClass = "";
	var element = null;
	var elementArr = [];
	var itemArr = this.getMenuItemArray();
	var itemArrCnt = (itemArr) ? itemArr.length : 0;
	var menuItem = null;
	var menuItemId = "";
	var selectorEle = null;
	var x = 0;

	function generateClickFunction(menuItemObj) {
		return function(ele) {
			var clickFunc = null;
			if(!menuItemObj.isDisabled()) {
				//Check to see if the element should close on click
				if(menuItemObj.closeOnClick()) {
					//Close the entire menu
					MP_MenuManager.closeMenuStack(true);
				}
				else {
					//Close any menus above this item
					MP_MenuManager.closeMenuStack(false);
				}

				//Perform the default MenuItem click event
				clickFunc = menuItemObj.getDefaultClickFunction();
				clickFunc.call(menuItemObj, ele);

				//Perform the specialized MenuItem click action
				clickFunc = menuItemObj.getClickFunction();
				if(clickFunc) {
					clickFunc.call(menuItemObj, ele);
				}

			}
		};

	}

	function generateHoverOverFunction(menuItemObj) {
		return function() {
			//If the MenuItem is a Menu
			if(Menu.prototype.isPrototypeOf(menuItemObj)) {
				//Set the flag to indicate that the user is hovering over the menu anchor
				menuItemObj.setIsMouseOverAnchor(true);
				//Check to see if the menu is currently active
				if(menuItemObj.isVisible()) {
					//Clear the hover timeout so it doesn't disappear
					menuItemObj.clearHoverTimeout();
				}
				else {
					//Show the menu after a quarter of a second
					//Need to make sure we don't open this menu item too soon
					window.setTimeout(function() {
						//If we are still hovering over this menu item selector, show the menu
						if(menuItemObj.isMouseOverAnchor()) {
							MP_MenuManager.showMenu(menuItemObj.getId());
						}
					}, 251);

				}
			}
		};

	}

	function generateHoverOutFunction(menuItemObj) {
		return function() {
			//If the MenuItem is a Menu
			if(Menu.prototype.isPrototypeOf(menuItemObj)) {
				//Set the flag to indicate that the user is no longer hovering over the menu anchor
				menuItemObj.setIsMouseOverAnchor(false);
				//Check to see if the menu is currently active
				if(menuItemObj.isVisible()) {
					//Start the hover timeout so the menu will disappear if we dont go back
					menuItemObj.startHoverTimeout();
				}
			}
		};

	}

	//Loop through each MenuItem and have it generate its menu selection content
	for( x = 0; x < itemArrCnt; x++) {
		menuItem = itemArr[x];
		//Create and store the dom element id for the menu item
		menuItemId = "menuSel" + x + "-" + this.getId();
		menuItem.setElementId(menuItemId);
		//Create the menu item html container
		disabledClass = (menuItem.isDisabled()) ? "menu-item-disabled" : "";
		element = $("<div></div>").addClass("menu-item " + disabledClass + " " + menuItem.getTypeClass()).attr("id", menuItemId);

		//Hover logic for the menu items
		$(element).hover(generateHoverOverFunction(menuItem), generateHoverOutFunction(menuItem));
		selectorEle = menuItem.generateSelectionContent();
		/*eslint-disable no-loop-func*/
		$(selectorEle).each(function(index, selector) {
			$(element).append(selector);
		});
		/*eslint-enable no-loop-func*/

		//Add the default and custom click event to the action
		$(element).click(generateClickFunction(menuItem));

		elementArr.push(element);
	}
	return elementArr;
};

/**
 * This function is in charge of generating the selection content when it is defined as a submenu.  This content will make up the
 * anchor of the submenu.
 * @return {[jQuery]} An array of jQuery elements which will make up the menu selection HTML content.
 */
Menu.prototype.generateSelectionContent = function() {
	return [$("<span>&nbsp;</span>").addClass("menu-selection-ind"), $("<span></span>").addClass("menu-selection").html(this.getLabel()), $("<span>&nbsp;</span>").addClass("menu-submenu-ind")];
};
/**
 * The DynamicMenu object inherits from the Menu object and adds additional functionality used when creating dynamic menus.
 * Specifically the developer can define the content creation function which will be in charge of generating the HTML content
 * to show within the menu display.
 * @constructor
 */
function DynamicMenu(menuId) {
	//Set the id for this object
	this.setId(menuId);

	//Set the close on click flag to false
	this.setCloseOnClick(false);

	//This will be the function used to generate the dynamic menu's content
	this.m_contentCreationFunc = function() {};

}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
DynamicMenu.prototype = new Menu();
DynamicMenu.prototype.constructor = Menu;

/** Checkers **/

/** Getters **/

/**
 * Returns the function that will be used to create the dynamic menu content.
 * @return {function} The function to call when the dynamic menu should create its content
 */
DynamicMenu.prototype.getContentCreationFunction = function() {
	return this.m_contentCreationFunc;
};

/** Setters **/

/**
 * Sets the function to execute when the DynamicMenu should render its contents.
 * @param {function} creationFunc The function that will be executed when the MenuSelection items is clicked for this DynamicMenu
 * @return {DynamicMenu} The DynamicMenu object calling this function so chaining can be used
 */
DynamicMenu.prototype.setContentCreationFunction = function(creationFunc) {
	if(typeof creationFunc === "function") {
		this.m_contentCreationFunc = creationFunc;
	}
	return this;
};

/** Helper Functions **/
/**
 * Call the function defined to create the dynamic menu's content and passes the results back to the caller.  If no function
 * is defined it will simply return null.
 * @return {[jQuery]} An array of jQuery object which will be used as the dynamic menu content.  Null of the content creation
 * function is not defined.
 */
DynamicMenu.prototype.generateMenuContent = function() {
	var contentCreationFunct = this.getContentCreationFunction();
	if(contentCreationFunct) {
		return contentCreationFunct.call(this);
	}
	return null;
};
/*global DynamicMenu*/
/**
 * @constructor
 * The AdvancedFilterMenu object will be used by component developers creating specialized filter menus for components.
 * This menu creates dialog for the developer so that advanced filter menus are consistent across all uses.
 */
function AdvancedFilterMenu(menuId) {

	//Set the id for the menu element
	this.setId(menuId);

	//Set the type class for this type of menu
	this.setTypeClass("adv-filter-menu-override");
	
	//Prevent the vertical flipping of the advanced filter menu
	this.setAutoFlipVertical(false);
	
	//Default settings for the Advanced Filter Menu
	this.settings = {
		//Settings for the cancel button
		cancel : {
			enabled : false,
			onclick : function() {
				return false;
			},

			label : i18n.CANCEL
		},
		//Settings for the options checkbox
		checkbox : {
			enabled : false,
			isChecked : false,
			onclick : function() {
				return false;
			},

			label : ""
		},
		//Settins for the sction link
		actionLink : {
			enabled : false,
			onclick : function() {
				return false;
			},

			label : ""
		},
		//This is the function that will be called when attempting to populate the advanced filter menu content
		advancedFilterCreationFunction : function() {
			return null;
		},
		//This is the width that will be applied to the menu when rendering
		dimensions : {
			width : 600
		},
		//Settings for the save button
		save : {
			enabled : false,
			onclick : function() {
				return false;
			},

			label : i18n.SAVE
		}
	};
	//Set the content creation function for this instance of the AdvnacedFilterMenu
	this.setContentCreationFunction(function() {
		var checkbox = this.settings.checkbox;
		var actionLink = this.settings.actionLink;
		var save = this.settings.save;
		var cancel = this.settings.cancel;
		//Create the main container for all of the AdvancedFilterMenu
		var menuContent = $("<div class='adv-filter-menu'></div>").width(this.settings.dimensions.width);
		//Create the inner container for the AdvancedFilterMenu
		var innerContainer = $("<div class='adv-filter-menu-inner-container'></div>").appendTo(menuContent);
		//Create the label based on the label defined in the object and append to the innerContainer
		$("<div class='adv-filter-menu-label'>" + this.getLabel() + "</div>").appendTo(innerContainer);
		//Add the custom content into a pre-defined section by calling the advancedFilterCreationFunction
		$("<div class='adv-filter-menu-custom-content'></div>").html(this.settings.advancedFilterCreationFunction()).appendTo(innerContainer);
		//If we do not have any of the controls enabled, just return the menu without any controls
		if(!(checkbox.enabled || save.enabled || cancel.enabled || actionLink.enabled)) {
			return menuContent;
		}

		//At this point, we have at least one control
		var controlContainer = $("<div class='adv-filter-menu-control-container'></div>").appendTo(menuContent);
		var buttonContainer = $("<span class='adv-filter-menu-button-container'></span>");
		var savePadding = 0;
		//Check to see if we should create a check box or an action link
		if(checkbox.enabled && checkbox.label) {
			var checkBoxContainer = $("<span class='adv-filter-menu-checkbox-container'></span>");
			//Create the contents for the checkbox and label and apply the click events
			var checkboxEle = $("<input type='checkbox'>");
			checkboxEle[0].checked = checkbox.isChecked;
			checkboxEle.click(checkbox.onclick).appendTo(checkBoxContainer);
			$("<span class='adv-filter-menu-checkbox-label'>" + checkbox.label + "</span>").appendTo(checkBoxContainer);
			checkBoxContainer.appendTo(controlContainer);
		}
		else if(actionLink.enabled && actionLink.label) {
			//Create the content for the action link and apply the click events
			var actionLinkContainer = $("<span class='adv-filter-menu-action-container'></span>");
			$("<span class='adv-filter-menu-action-label'>" + actionLink.label + "</span>").click(actionLink.onclick).appendTo(actionLinkContainer);
			actionLinkContainer.appendTo(controlContainer);
		}
		//If the cancel button is enabled
		if(cancel.enabled) {
			$("<button type='button' class='adv-filter-menu-button'>").html(cancel.label).click(cancel.onclick).appendTo(buttonContainer);
			savePadding = 6;
			buttonContainer.appendTo(controlContainer);
		}
		//If the save button has been enabled
		if(save.enabled) {
			$("<button type='button' class='adv-filter-menu-button'>").html(save.label).css("margin-right", savePadding).click(save.onclick).appendTo(buttonContainer);
			buttonContainer.appendTo(controlContainer);
		}
		return menuContent;
	});

}

AdvancedFilterMenu.prototype = new DynamicMenu();
AdvancedFilterMenu.prototype.constructor = DynamicMenu;

/**
 * Sets the function that will inject the custom menu content for the AdvancedFilterMenu
 * @param {function} contentFunction The function used to inject the custom content into this menu
 */
AdvancedFilterMenu.prototype.setAdvancedFilterCreationFunction = function(contentFunction) {
	if(contentFunction && typeof contentFunction === "function") {
		this.settings.advancedFilterCreationFunction = contentFunction;
	}
};

/**
 * Sets the label to appear on the Cancel button
 * @param {string} lebel The string used as the label
 */
AdvancedFilterMenu.prototype.setCancelButtonLabel = function(label) {
	if(label && typeof label === "string") {
		//If the user is setting the label, assume they want the button enabled
		this.setIsCancelButtonEnabled(true);
		this.settings.cancel.label = label;
	}
};

/**
 * Sets the function to occur when the user clicks the cancel button
 * @param {function} cancelFunction The function to execute when the user clicks the cancel button
 */
AdvancedFilterMenu.prototype.setCancelFunction = function(cancelFunction) {
	if(cancelFunction && (typeof cancelFunction === "function")) {
		//If the user is setting the cancel function, assume they want the button enabled
		this.setIsCancelButtonEnabled(true);
		this.settings.cancel.onclick = cancelFunction;
	}
};

/**
 * Sets the function for when the user clicks the check box
 * @param {function} checkboxClickFunction the function to execute when the user clicks the check box
 */
AdvancedFilterMenu.prototype.setCheckboxClickFunction = function(checkboxClickFunction) {
	if(checkboxClickFunction && (typeof checkboxClickFunction === "function")) {
		//If the user defines the checkbox click function, assume they want it enabled
		this.setIsCheckboxEnabled(true);
		this.settings.checkbox.onclick = checkboxClickFunction;
	}
};

/**
 * Sets the label to the right of the checkbox
 * @param {string} label The label to the right of the checkbox
 */
AdvancedFilterMenu.prototype.setCheckboxLabel = function(label) {
	if(typeof label === "string") {
		this.settings.checkbox.label = label;
	}
};

/**
 * Sets the function to execute when you click on the action link
 * @param {function} linkFunc The function to execute when the action link is clicked
 */
AdvancedFilterMenu.prototype.setActionLinkFunction = function(linkFunc) {
	if(linkFunc && typeof linkFunc === "function") {
		//If the user is setting the action label assume they are wanting it to show
		this.setIsActionLinkEnabled(true);
		this.settings.actionLink.onclick = linkFunc;
	}
};

/**
 * Sets the label for the action link
 * @param {string} label The label for the action link
 */
AdvancedFilterMenu.prototype.setActionLinkLabel = function(label) {
	if(typeof label === "string") {
		this.settings.actionLink.label = label;
	}
};

/**
 * Function to set if the cancel button is enabled
 * @param {boolean} isEnabled True if the cancel button is to be enabled, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCancelButtonEnabled = function(isEnabled) {
	if(typeof isEnabled === "boolean") {
		this.settings.cancel.enabled = isEnabled;
	}
};

/**
 * Sets whether or not the check box is checked by default
 * @param {boolean} isChecked True if the check box is checked by default, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCheckboxChecked = function(isChecked) {
	if(typeof isChecked === "boolean") {
		this.settings.checkbox.isChecked = isChecked;
	}
};

/**
 * Sets whether or not the check box for the menu is enabled
 * @param {boolean} isEnabled True if the check box should be enabled, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCheckboxEnabled = function(isEnabled) {
	if(typeof isEnabled === "boolean") {
		this.settings.checkbox.enabled = isEnabled;
	}
};

/**
 * Sets whether or not the action link for the menu is enabled
 * @param {boolean} isEnabled True if the action link should be enabled or not
 */
AdvancedFilterMenu.prototype.setIsActionLinkEnabled = function(isEnabled) {
	if(typeof isEnabled === "boolean") {
		this.settings.actionLink.enabled = isEnabled;
	}
};

/**
 * Function to set if the save button is enabled
 * @param {boolean} isEnabled True if the save button should be enabled or not
 */
AdvancedFilterMenu.prototype.setIsSaveButtonEnabled = function(isEnabled) {
	if(typeof isEnabled === "boolean") {
		this.settings.save.enabled = isEnabled;
	}
};

/**
 * Sets the label to appear on the Save button
 * @param {string} label The string used as the label
 */
AdvancedFilterMenu.prototype.setSaveButtonLabel = function(label) {
	if(label && typeof label === "string") {
		this.setIsSaveButtonEnabled(true);
		this.settings.save.label = label;
	}
};

/**
 * Sets the function to occur when the user clicks the save button
 * @param {function} saveFunction The function to execute when the user clicks the save button
 */
AdvancedFilterMenu.prototype.setSaveFunction = function(saveFunction) {
	if(saveFunction && (typeof saveFunction === "function")) {
		//If the user is setting the save function, assume they want the button enabled
		this.setIsSaveButtonEnabled(true);
		this.settings.save.onclick = saveFunction;
	}
};

/**
 * Sets the width of the AdvancedFilterMenu
 * @param {number} width How wide the menu is to be when first rendered
 */
AdvancedFilterMenu.prototype.setWidth = function(width) {
	if(width && typeof width === "number") {
		this.settings.dimensions.width = width;
	}
};

function ContextMenu(menuId) {
	//Set the id for this object
	this.setId(menuId);
	//The is the x offset of the cursor at the time of the context menu creation
	this.m_xOffset = 0;
	//The is the x offset of the cursor at the time of the context menu creation
	this.m_yOffset = 0;
}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
ContextMenu.prototype = new Menu();
ContextMenu.prototype.constructor = Menu;

/** Checkers **/

/** Getters **/

ContextMenu.prototype.getXOffset = function() {
	return this.m_xOffset;
};


ContextMenu.prototype.getYOffset = function() {
	return this.m_yOffset;
};


/** Setters **/


ContextMenu.prototype.setXOffset = function(xOffset) {
	if(typeof xOffset === "number") {
		this.m_xOffset = xOffset;
	}
	return this;
};


ContextMenu.prototype.setYOffset = function(yOffset) {
	if(typeof yOffset === "number") {
		this.m_yOffset = yOffset;
	}
	return this;
};

/** Helper Functions **/

ContextMenu.prototype.setAnchorElement = function() {
	$(document.body).append($("<div id='" + this.getId() + "Anchor' class='context-menu'></div>").css({
		"top": this.getYOffset(),
		"left": this.getXOffset()
	}));
};

ContextMenu.prototype.removeAnchorElement = function(){
	$("#" + this.getId() + "Anchor").remove();
};
/**
 * The MenuSelection object inherits from the MenuItem object and is used as a basic selection option for a menu.  
 * The MenuSelection object does have the power to determine if the parent Menu will closed or not when it is clicked.
 * Additional options for this menu item include showing a custom selection icon in front of the menu item.
 * @constructor
 */
function MenuSelection(selectionId) {
	//Set the id for this object
	this.setId(selectionId);
	
	//Set the default on click function for this element.  This function will be run regardless of the existence of the 
	//developer defined click function.
	/*eslint-disable no-unused-vars*/
	this.setDefaultClickFunction(function(clickEvent){
		//Toggle the selection indicator if we aren't supposed to close the menu and this item isn't disabled
		if(!this.closeOnClick() && !this.isDisabled()){
			this.toggleSelection();
		}
	});
	/*eslint-enable no-unused-vars*/
	
	//This flag determines if the menu selection should show as being selected or not.
	this.m_selectedInd = false;
	
	//The selection class will be used to style item which have been selected within the menu
	this.m_selectedClass = "menu-item-selected";
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSelection.prototype = new MenuItem();
MenuSelection.prototype.constructor = MenuItem;

/** Checkers **/
/**
 * Checks to see if this MenuSelection should be shown as selected or not
 * @return {boolean} True if this MenuSelection has been selected or should default to being selected
 */
MenuSelection.prototype.isSelected = function(){
	return this.m_selectedInd;
};

/** Getters **/
/**
 * Returns the class to apply to items which have been selected within the menu or are defaulted to being selected
 * @return {string} The class which will be applied to selected menu selection items
 */
MenuSelection.prototype.getSelectedClass = function(){
	return this.m_selectedClass;
};

/** Setters **/
/**
 * Sets the indicator which determines if this MenuSelection should be shown as selected or not within the menu
 * @param {boolean} selected A boolean which indicates if this MenuSelection item should show up as selected within the menu
 * @return {MenuSelection}
 */
MenuSelection.prototype.setIsSelected = function(selected){
	var selectedClass = "";
	var element = null;
	if(typeof selected === "boolean"){
		this.m_selectedInd = selected;
	
		//If the MenuSelection element is active update the visuals
		if(this.isActive()){
			selectedClass = this.getSelectedClass();
			element = $("#" + this.getElementId() + " :first-child");
			if(selected){
				$(element).addClass(selectedClass);
			}
			else{
				$(element).removeClass(selectedClass);
			}
		}
	}
		
	return this;
};

/**
 * Sets the class which will be applied to the menu item element which indicates an item has been selected.
 * @param {string} selectedClass The CSS class to apply to a selected menu item
 * @return {MenuSelection} The MenuSelection object calling this function so chaining can be used
 */
MenuSelection.prototype.setSelectedClass = function(selectedClass){
	if(typeof selectedClass === "string"){
		this.m_selectedClass = selectedClass;
	}
	return this;
};

/** Helper Functions **/

/**
 * This function is used to toggle the isSelected flag for the MenuSelection item
 */
MenuSelection.prototype.toggleSelection = function(){
	this.setIsSelected(!this.isSelected());
};

/**
 * This function is used to generate the HTML which will be shown within the menu when it is rendered
 */
MenuSelection.prototype.generateSelectionContent = function(){
	var selectedClass = this.getSelectedClass();
	if(!this.isSelected()){
		selectedClass = "";
	}
	return [$("<span>&nbsp;</span>").addClass("menu-selection-ind " + selectedClass), $("<span></span>").addClass("menu-selection").html(this.getLabel())];
};/* This object is used to easily place a separator within the context of a menu */
function MenuSeparator(seperatorId) {
	//Set the id for this object
	this.setId(seperatorId);

	//Set the type class for this item since it requires special styling
	this.setTypeClass("menu-separator");
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSeparator.prototype = new MenuItem();
MenuSeparator.prototype.constructor = MenuItem;

/**
 * Returns a non-breaking space so the container element will always show.
 */
MenuSeparator.prototype.generateSelectionContent = function() {
	return ["&nbsp;"];
};/* This object is used to easily place a separator within the context of a menu */
function MenuSeparator(seperatorId) {
	//Set the id for this object
	this.setId(seperatorId);
	
	//Set the type class for this item since it requires special styling
	this.setTypeClass("menu-separator");
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSeparator.prototype = new MenuItem();
MenuSeparator.prototype.constructor = MenuItem;

/**
 * Returns a non-breaking space so the container element will always show.
 */
MenuSeparator.prototype.generateSelectionContent = function(){
	return ["&nbsp;"];
};/**
 * The ThemeSelector object inherits from the DynamicMenu object and adds additional functionality used when choosing a theme color.
 * @param themeSelectorId This is the id of the MenuItem
 * @param compId This theme selector should be tied to a component, this component id is for that component
 * @param fullId Used to specify the anchor element of this menu
 * @param ns Used the specify the namespace for the component, e.g. "cust" for custom components (available in getStyles())
 * @constructor
 */
function ThemeSelector(themeSelectorId, compId, fullId, ns) {

    this.m_componentId = compId;
    this.m_styleId = ns + compId;

	//Set the id for this object
	this.setId(themeSelectorId);
    this.setLabel(i18n.discernabu.COLOR_THEME);
    this.setAnchorElementId(fullId);
    this.setAnchorConnectionCorner(["top", "left"]);
    this.setContentConnectionCorner(["top", "right"]);
    this.setContentCreationFunction(function() {
        var themeSelectorHtml = "";
        var i18nCore = i18n.discernabu;
        var themeSelectorColors = [
            { "title": i18nCore.COLOR_STANDARD, "name": "lightgrey", "capsName": "LightGrey" },
            { "title": i18nCore.COLOR_BROWN, "name": "brown", "capsName": "Brown" },
            { "title": i18nCore.COLOR_CERNER_BLUE, "name": "cernerblue", "capsName": "CernerBlue" },
            { "title": i18nCore.COLOR_DARK_GREEN, "name": "darkgreen", "capsName": "DarkGreen" },
            { "title": i18nCore.COLOR_GREEN, "name": "green", "capsName": "Green" },
            { "title": i18nCore.COLOR_GREY, "name": "grey", "capsName": "Grey" },
            { "title": i18nCore.COLOR_LIGHT_BLUE, "name": "lightblue", "capsName": "LightBlue" },
            { "title": i18nCore.COLOR_NAVY, "name": "navy", "capsName": "Navy" },
            { "title": i18nCore.COLOR_ORANGE, "name": "orange", "capsName": "Orange" },
            { "title": i18nCore.COLOR_PINK, "name": "pink", "capsName": "Pink" },
            { "title": i18nCore.COLOR_PURPLE, "name": "purple", "capsName": "Purple" },
            { "title": i18nCore.COLOR_YELLOW, "name": "yellow", "capsName": "Yellow" }
        ];
        var titleMarkup;
        var idMarkup;
        var classMarkup;
        var dataMarkup;
        var componentIdMarkup;
        var styleIdMarkup;

        for (var i = 0; i < themeSelectorColors.length; i++) {
            titleMarkup = ' title="' + themeSelectorColors[i].title + '"';
            idMarkup = ' id="optConfigMnu' + themeSelectorColors[i].capsName + '"';
            classMarkup = ' class="opts-menu-config-item opt-config-mnu-' + themeSelectorColors[i].name + '"';
            dataMarkup = ' data-color="' + themeSelectorColors[i].name + '"';
            componentIdMarkup = ' component-id="' + this.m_componentId + '"';
            styleIdMarkup = ' style-id="' + this.m_styleId + '"';

            themeSelectorHtml += '<div' + titleMarkup + classMarkup + dataMarkup + componentIdMarkup + styleIdMarkup + idMarkup + '></div>';
        }
        themeSelectorHtml = '<div class="opts-menu-config-content-custom" id="optMenuConfig' + this.m_componentId + '">' + themeSelectorHtml + '</div>';

        return [ $("<span>&nbsp;</span>").html(themeSelectorHtml).click(this.themeSelectorClickHandler) ];
    });

}

/**
 * Setup the prototype and constructor to inherit from the base DynamicMenu object
 */
ThemeSelector.prototype = new DynamicMenu();
ThemeSelector.prototype.constructor = DynamicMenu;


/**
 * This function will handle the click events on the menu colors
 * @param e
 */
ThemeSelector.prototype.themeSelectorClickHandler = function(e) {
    var color = e.target.getAttribute("data-color");
    var section = _g(e.target.getAttribute("style-id"));
    if (section) {
        var colorString = "brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow";
        //a color is found in the class name so replace it with ""
        if (colorString.indexOf(color) >= 0) {
            var colorRegExp = /brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow/;
            section.className = section.className.replace(colorRegExp, "");
        }

        //add the new color so it changes for the user
        Util.Style.acss(section, color);
        var componentId = Number(e.target.getAttribute("component-id"));
        var component = MP_Util.GetCompObjById(componentId);
        component.setCompColor(color);
        //add the color to the component properties
        setTimeout(function() {
            MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, color, null, false);
        }, 0);
    }
};


/** Checkers **/

/** Getters **/
/*global DynamicMenu*/
/**
 * @constructor
 * The UtilitiesMenu object will be used by component developers to create utilities drop down dialogs which are persistent.
 * This means that there will be no timeout when the user hovers over and hovers our of the menus content area.  These menus 
 * will need to be closed programitically or will be closed automatically when another menu is opened.
 */
function UtilitiesMenu(menuId) {

	//Set the id for the menu element
	this.setId(menuId);

	//Set the type class for this type of menu
	this.setTypeClass("utilities-menu-override");

	//Set the default active anchor class
	this.setAnchorActiveClass("vwp-util-active");
	//Set the menu as persistent
	this.setIsPersistent(true);
	
	//Set the root menu flag
	this.setIsRootMenu(true);
	
	//Default settings for the Utilities Menu
	this.settings = {
		//This is the function that will be called when attempting to populate the Utilities Menu content
		utilitiesContentCreationFunction : function() {
			return null;
		},
		//This is the width that will be applied to the menu when rendering
		dimensions : {
			width : 300,
			maxHeight: ""
		}
	};
	//Set the content creation function for this instance of the UtilitiesMenu
	this.setContentCreationFunction(function() {
		//Create the main container for all of the UtilitiesMenu
		var menuContent = $("<div class='utilities-menu'></div>").width(this.settings.dimensions.width);
		//Create the inner container for the UtilitiesMenu
		var innerContainer = $("<div class='utilities-menu-inner-container'></div>").appendTo(menuContent);
		//Create the label based on the label defined in the object and append to the innerContainer
		$("<div class='utilities-menu-label'>" + this.getLabel() + "</div>").appendTo(innerContainer);
		//Add the custom content into a pre-defined section by calling the utilitiesContentCreationFunction
		$("<div class='utilities-menu-custom-content'></div>").css("max-height", this.settings.dimensions.maxHeight || "").html(this.settings.utilitiesContentCreationFunction()).appendTo(innerContainer);
		return menuContent;
	});

}

UtilitiesMenu.prototype = new DynamicMenu();
UtilitiesMenu.prototype.constructor = DynamicMenu;

UtilitiesMenu.prototype.setIsRootMenu = function(isRoot){
	if(typeof isRoot === "boolean") {
		if(!isRoot){
			throw new Error("UtilitiesMenu can only be used as root menus");
		}
		else{
			this.m_rootMenuInd = isRoot;
		}
	}
};

UtilitiesMenu.prototype.setIsPersistent = function(isPersistent){
	if(typeof isPersistent === "boolean") {
		if(!isPersistent){
			throw new Error("UtilitiesMenu can only be used as a persistent menu");
		}
		else{
			this.m_isPersistent = isPersistent;
		}
	}
};

/**
 * Sets the function that will inject the custom menu content for the UtilitiesMenu
 * @param {function} contentFunction The function used to inject the custom content into this menu
 */
UtilitiesMenu.prototype.setUtilitiesContentCreationFunction = function(contentFunction) {
	if(contentFunction && typeof contentFunction === "function") {
		this.settings.utilitiesContentCreationFunction = contentFunction;
	}
};

/**
 * Sets the width of the UtilitiesMenu
 * @param {number} width How wide the menu is to be when first rendered
 */
UtilitiesMenu.prototype.setWidth = function(width) {
	if(width && typeof width === "number") {
		this.settings.dimensions.width = width;
	}
};
/**
 * Sets the maxHeight of the utilities menu
 * @param {number} width How wide the menu is to be when first rendered
 */
UtilitiesMenu.prototype.setMaxHeight = function(maxHeight) {
	if(maxHeight && typeof maxHeight === "number") {
		this.settings.dimensions.maxHeight = maxHeight;
	}
};
/**
 * Polyfill for Object.keys so we can start using it in
 * IE8. This will help when we transition to IE10, since that 
 * method will yield better performance.
 */

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnPropertyMet = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnPropertyMet.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnPropertyMet.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}


MPageOO = {

	/**
	* Allows inheriting two classes without having to call the constructor.
	* Can be replaced with Object.create() once we go over supporting IE10+.
	*/
	inherits: function (clazz, parent) {
		var Dummy = function() {};
		Dummy.prototype = parent.prototype;
		clazz.prototype = new Dummy();
		
		// static methods
		var methods = Object.keys(parent);
		for (var i=methods.length;i--;) {
		    var m = methods[i];
		    clazz[m] = parent[m];
		}
	},

	attribute: function(clazz, name) {

		clazz.prototype["set" + name] = function(value) {
			this["m_"+name] = value;
		};

		clazz.prototype["get" + name] = function() {
			return this["m_" + name];
		};
	}
};
/**
 * preview_pane.js
 * @author Sean Turk
 *
 * PreviewPane class
 * ============================================================================
 *
 * Creates generic rectangular area to display whatever is necessary for a particular component.
 * For example, it could display document text or event details.
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var oo = MPageObjectOriented;
	var inherits = oo.inherits;
	var attribute = oo.createAttribute;

	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * Instantiates a new preview pane object
	 * @param {string} dataId - unique ID for the data being displayed.  Could be an event_id, notification_uid, etc.
	 * @param {string} compId - unique ID for the object containing containing the pane.  Likely the component ID.
	 * @param {Object} containerElement - the JQuery element that will contain the preview pane.
	 * @param {Object} renderFunc - the function that will populate the HTML of the preview pane.
	 */
	ns.PreviewPane = function(dataId, compId, containerElement, renderFunc){

		this.setDataId(dataId);
		this.setPaneId('pp_' + compId + '_'+ dataId);
		this.setContainerElement(containerElement);
		this.setRenderFunction(renderFunc);
		this.setPaneLoaded(false);

		//set a default pane size just in case
		this.setHorzSize(300);
		this.setVertSize(300);

		ns.Control.call(this, containerElement);
	};
	
	inherits(ns.PreviewPane, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	/**
	 * The horizontal size of the pane
	 */
	attribute(ns.PreviewPane, "HorzSize");
	/**
	 * The vertical size of the pane
	 */
	attribute(ns.PreviewPane, "VertSize");
	/**
	 * The data ID of the pane
	 */
	attribute(ns.PreviewPane, "DataId");
	/**
	 * The ID of the pane
	 */
	attribute(ns.PreviewPane, "PaneId");
	/**
	 * The HTML element that will contain this preview pane
	 */
	attribute(ns.PreviewPane, "ContainerElement");
	/**
	 * The function that will render the customized HTML inside the preview pane object
	 */
	attribute(ns.PreviewPane, "RenderFunction");
	/**
	 * A flag that indicates if the pane has been loaded or not
	 */
	attribute(ns.PreviewPane, "PaneLoaded");
	
	var prot = ns.PreviewPane.prototype;

	prot.init = function() {
	};
	
	/**
	 * Renders HTML in the preview pane, based on the RenderFunction attribute 
	 */
	prot.renderPane = function(){
		var paneDivHTML = "<div id='" + this.getPaneId() + "' class='preview_pane'><div class='loading'></div>";
		var paneInsert = this.getContainerElement();
		paneInsert.html(paneDivHTML);
		var paneDiv = $("#"+this.getPaneId());
		if(this.getRenderFunction() != null){
			paneDiv.html(this.getRenderFunction()());
		}
		this.setSize(this.getHorzSize(), this.getVertSize());
	};
	
	/**
	 * Sets the size of the preview pane.  Invalid values result in the previous size being retained
	 * @param {int} xLen - the width of the preview pane
	 * @param {int} yLen - the length of the preview pane
	 */
	prot.setSize = function(xLen, yLen){
		if (xLen > 0) {
			this.setHorzSize(xLen);
		}
		if (yLen > 0) {
			this.setVertSize(yLen);
		}
		var paneEl = $("#"+this.getPaneId());
		if(paneEl){
			paneEl.css({
				width: this.getHorzSize(),
				height: this.getVertSize()
			});
		}
	};
})(jQuery);
var MP_DocumentViewerDialog = function () {
	var docViewerModalI18n = i18n.discernabu.document_viewer_modal;
	var DocumentViewerTabsIndex = {
		DOCUMENTS : 0,
		IMAGES : 1
	};
	var currentPage = DocumentViewerTabsIndex.DOCUMENTS;
	var tabNames = [];
	var eventGlobalId = 0;
	var docContentHTML = [];
	var reply = null;
	var patEncounterDetails = null;
	var image = "";
	var imageSelect = false;
	var enabled = false;
	var creds = "";
	var username = "";
	var pwd = "";
	var dm = "";
	var ajo;
	var ajo2;
	var patName = "";
	var patMRN = "";
	var patDOB = "";
	var resultType = "";
	var resultDate = "";
	var resultTitle = "";
	var performedBy = "";
	var resultStatus = "";
	var verifiedBy = "";
	var encounterInfo = "";
	var encntrFin = "";
	var encntrFacility = "";
	var encntrType = "";
	var encntrAdmitDate = "";
	var encntrDischargeDate = "";
	var printedBy = "";
	var emptyData = "--";
	var verifyCd = 0;
	var performCd = 0;
	var alteredCd = 0;
	var modifiedCd = 0;
	var unauthCd = 0;
	var authCd = 0;
	var docCd = 0;
	return {
		initDocumentViewer : function (patient_Id, enctr_Id, event_Id, display, docViewerType, pevent_Id, image_Url, provider_Id, image_Ind) {
			var docType = (docViewerType) ? docViewerType : "STANDARD";
			eventGlobalId = event_Id + ".0";
			patient_Id = patient_Id + ".0";
			provider_Id = provider_Id + ".0";
			image = image_Url;
			if(image_Ind == 1) {
				imageSelect = true;
			} else {
				imageSelect = false;
			}
			var docLoading = [];
			var docModalDialog = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
			if (!docModalDialog) {
				docModalDialog = new ModalDialog("docModalDialog");
				docModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
				docModalDialog.setHeaderCloseFunction();
				docModalDialog.setHeaderTitle("<span class='documentwindow-title'>" + docViewerModalI18n.DOCUMENT_VIEWER + "</span>");
				MP_ModalDialog.addModalDialogObject(docModalDialog);
			}
			docModalDialog.setBodyDataFunction(function (docViewDlg) {
				var cclParams = [];
				cclParams.push("^MINE^", eventGlobalId, patient_Id, provider_Id, "^" + docType + "^");
				MP_DocumentViewerDialog.loadWithCBParameters("mp_get_doc_viewer_data", cclParams, MP_DocumentViewerDialog.renderDocViewer);
			});
			MP_ModalDialog.updateModalDialogObject(docModalDialog);
			MP_ModalDialog.showModalDialog(docModalDialog.getId());
			docLoading.push("<div class='doc-body-loading'><span class='document-loading'></span></div>");
			docModalDialog.setBodyHTML(docLoading.join(""));
			$("#docModalDialogbody").css("overflow", "hidden");
			$("#docModalDialogbody").css("height", "100%");
			$("#vwpModalDialogdocModalDialog").css("height", "100%");
			$("#vwpModalDialogdocModalDialog").css("position", "absolute");
		},
		init : function () {
			var url = "../../mpages/creds";
			ajo = MP_DocumentViewerDialog.getXMLHttpRequest();
			ajo.open("GET", url, false);
			ajo.onreadystatechange = MP_DocumentViewerDialog.processRequest;
			ajo.send();
		},
		getXMLHttpRequest : function () {
			var xmlHttp = null;
			try {
				if (window.XMLHttpRequest) {
					xmlHttp = new XMLHttpRequest();
				}
			} catch (e) {
				try {
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} catch (e2) {
					xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
				}
			}
			return xmlHttp;
		},
		processRequest : function () {
			try {
				if (ajo.readyState == 4) {
					if (ajo.status == 200) {
						var jObj = JSON.parse(ajo.responseText);
						username = jObj.un;
						pwd = jObj.pw;
						dm = jObj.dm;
						MP_DocumentViewerDialog.locateCmvWebapp();
					}
				} else {
					MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "processRequest");
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "processRequest");
			}
		},
		webkit : function () {
			return new RegExp(" AppleWebKit/").test(navigator.userAgent);
		},
		ie8BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE8 = isIE && check(/msie 8/);
			return isIE8;
		},
		ie9BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE9 = isIE && check(/msie 9/);
			return isIE9;
		},
		ie10BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE10 = isIE && check(/msie 10/);
			return isIE10;
		},
		locateCmvWebapp : function () {
			try {
				var fullCanonicalDomainName = reply.FULLCANONICALDOMAINNAME;
				ajo2 = MP_DocumentViewerDialog.getXMLHttpRequest();
				var userDomain = "";
				var url = window.location.protocol + "//" + window.location.host + "/mediaviewer/"+ fullCanonicalDomainName +"/mom";
				if (MP_DocumentViewerDialog.webkit() === true) {
					userDomain = username + "%40" + dm;		 //Safari only accepts %40
				} else {
					userDomain = username + "@" + dm;		//IE only accepts @, but Chrome and FF do as well
				}					
				ajo2.open("GET", url, false, userDomain, pwd);				
				ajo2.send();
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "locateCmvWebapp");
			}
		},
		loadWithCBParameters : function (programName, cclParams, callBack) {
			try {
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "loadWithCBParameters");
			}
		},
		buildDocHeaderInformation : function (replyRBList) {
			try {
				var actionListLen = replyRBList.EVENT_PRSNL_LIST.length;
				var actionListItem = null;
				var performedDate = null;
				var verifiedDate = null;
				var dateTime = new Date();
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);	
				
				patName = (patEncounterDetails.NAME_FULL_FORMATTED) ? patEncounterDetails.NAME_FULL_FORMATTED : "";
				patMRN = (patEncounterDetails.PAT_ALIAS) ? patEncounterDetails.PAT_ALIAS : emptyData;
				patDOB = (patEncounterDetails.BIRTH_DT_TM) ? df.formatISO8601(patEncounterDetails.BIRTH_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR) : emptyData;
				resultType = (patEncounterDetails.RESULT_TYPE) ? patEncounterDetails.RESULT_TYPE : emptyData;
				resultDate = (patEncounterDetails.RESULT_DATE) ? df.formatISO8601(patEncounterDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;
				resultTitle = (patEncounterDetails.RESULT_TITLE) ? patEncounterDetails.RESULT_TITLE : emptyData;
				if(resultTitle !==  emptyData ) { 
					resultTitle = resultTitle.replace(/'/g, "&#39").replace(/</g, "&#60").replace(/>/g, "&#62");
				}
				
				for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
					actionListItem = replyRBList.EVENT_PRSNL_LIST[alIndex];
					if(actionListItem.ACTION_TYPE_CD === performCd)
					{
						performedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
					if(actionListItem.ACTION_TYPE_CD === verifyCd)
					{
						verifiedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
				}
				
				if (patEncounterDetails.PERFORMED_PRSNLID > 0) {
					performedBy = patEncounterDetails.PERFORMED_FULL;
					if (performedDate) {							
						performedBy = performedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + performedDate;
					}
				} else {
					performedBy = emptyData;
				}
				resultStatus = (patEncounterDetails.RESULT_STATUS) ? patEncounterDetails.RESULT_STATUS : emptyData;
				if (patEncounterDetails.VERIFIED_PRSNLID > 0) {
					verifiedBy = patEncounterDetails.VERIFIED_FULL;
					if (verifiedDate) {							
						verifiedBy = verifiedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + verifiedDate;
					}
				} else {
					verifiedBy = emptyData;
				}
				encntrFin = (patEncounterDetails.ENCNTR_ALIAS) ? patEncounterDetails.ENCNTR_ALIAS : "";
				encntrFacility = (patEncounterDetails.FACILITY_DISP) ? patEncounterDetails.FACILITY_DISP : "";
				encntrType = (patEncounterDetails.ENCNTR_TYPE) ? patEncounterDetails.ENCNTR_TYPE : "";					
				var admitDate = patEncounterDetails.REG_DT_TM.substr(6, 4);
				if (admitDate > 0) {						
					dateTime.setISO8601(patEncounterDetails.REG_DT_TM);
					encntrAdmitDate = dateTime.format("mm/dd/yyyy");
				}
				else {
					encntrAdmitDate = "";
				}	
				var dischargeDate = patEncounterDetails.DISCH_DT_TM.substr(6, 4);
				if(dischargeDate > 0) {
					dateTime.setISO8601(patEncounterDetails.DISCH_DT_TM);
					encntrDischargeDate = dateTime.format("mm/dd/yyyy");
				}
				else {
					encntrDischargeDate = "";
				}
				if (patEncounterDetails.REG_DATE && patEncounterDetails.DISCH_DATE === "") {
					encntrDischargeDate = "-";
				}
				if (patEncounterDetails.DISCH_DATE === "" && patEncounterDetails.REG_DATE === "") {
					encntrDischargeDate = "";
				}
				if (patEncounterDetails.DISCH_DATE && patEncounterDetails.REG_DATE === "") {
					encntrDischargeDate = "";
				}
				if (encntrFin === "" && encntrFacility === "" && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "") {
					encounterInfo = emptyData;
				}
				else if(encntrFin && encntrFacility && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "")
				{
					encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType;
				}
				else 
				{
					encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType + ", " + encntrAdmitDate + ", " + encntrDischargeDate;
				}
				printedBy = (patEncounterDetails.PROVIDER_NAME !== "") ? patEncounterDetails.PROVIDER_NAME : "";				
			}
			catch(e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "buildHeaderInformation");
			}
		},
		buildDocBodyInformation : function (replyRBList) {
			try {
				var docNoteBlobListLength = reply.NOTE_BLOB.length;
				var docBlobContentLength = reply.BLOBS.length;
				var docBlobText = "";
				var docEventText = "";
				var docEventNoteText = "";
				var signLine = "";
				var docEventContent = [];
				docContentHTML = [];
				if ((replyRBList.RESULT_STATUS_CD === modifiedCd) || (replyRBList.RESULT_STATUS_CD === unauthCd)) {						
					for( var b = 0; b < docBlobContentLength; b++) {
						docEventText = reply.BLOBS[b].EVENT_TITLE_TEXT;							
						var blobHtmlItem = reply.BLOBS[b].BLOB_HTML;
						if (replyRBList.EVENT_CLASS_CD === docCd) {										
							while (blobHtmlItem.indexOf('text-decoration: line-through') !== -1) {
								blobHtmlItem = blobHtmlItem.replace('text-decoration: line-through', 'display: none');
							}
							docBlobText = blobHtmlItem;								
						} else {
							docBlobText = blobHtmlItem;								
						}
						docEventContent.push("<br><span class='document_event_title'> " + docEventText + " </span><br><span class='document_blob_text'> " + docBlobText + " </span>");
						if (reply.NOTE_BLOB[b]) {
							signLine = reply.NOTE_BLOB[b].NOTE_TITLE_TEXT;
							docEventNoteText = reply.NOTE_BLOB[b].NOTE_BLOB_HTML;									
							docEventContent.push("<br><br><span class='document_event_title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
						}
					}
				} else {
					for( var bc = 0; bc < docBlobContentLength; bc++) {
						docEventText = reply.BLOBS[bc].EVENT_TITLE_TEXT;
						docBlobText = reply.BLOBS[bc].BLOB_HTML;
						docEventContent.push("<br><span class='document_event_title'> " + docEventText + " </span><br><span class='document_blob_text'> " + docBlobText + " </span>");
					}
					for (var nb = 0; nb < docNoteBlobListLength; nb++) {
						signLine = reply.NOTE_BLOB[nb].NOTE_TITLE_TEXT;
						docEventNoteText = reply.NOTE_BLOB[nb].NOTE_BLOB_HTML;									
						docEventContent.push("<br><br><span class='document_event_title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
					}
				}	
				if (docEventContent.length) {
					docContentHTML.push(docEventContent.join(""));
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "buildDocBodyInformation");
			}
		},
		renderDocViewer : function (replyObj) {
			try {
				var docModalDialogObject = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var documentsTab = docViewerModalI18n.DOCUMENTS;
				var imagesTab = docViewerModalI18n.IMAGES;
				var docRenderHtml = [];		
				var codesLength = 0;					
				reply = replyObj.getResponse();				
				
				if(reply && replyObj.getStatus() === "F") {						
					MP_Util.LogScriptCallError(null, this, "document_viewer.js", "renderDocViewer");							
					return;						
				}	
				
				tabNames[DocumentViewerTabsIndex.DOCUMENTS] = documentsTab;
				tabNames[DocumentViewerTabsIndex.IMAGES] = imagesTab;
				var codeArray = MP_Util.LoadCodeListJSON(reply.CODES);
				var replyRBList = reply.RB_LIST[0];	
				patEncounterDetails = reply.PAT_ENCNTR_DETAILS;
				
				//Establish code_values for action_type_cd and result_status_cd
				codesLength = codeArray.length;
				for (var cdIndex = 0;cdIndex < codesLength;cdIndex++) {
					if (codeArray[cdIndex].value.codeSet === 21) {
						if (codeArray[cdIndex].value.meaning === "VERIFY") {
							verifyCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "PERFORM") {
								performCd = codeArray[cdIndex].value.codeValue;
						}
					} else if (codeArray[cdIndex].value.codeSet === 8) {
						if (codeArray[cdIndex].value.meaning === "ALTERED") {
							alteredCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "MODIFIED") {
								modifiedCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "UNAUTH") {
								unauthCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "AUTH") {
								authCd = codeArray[cdIndex].value.codeValue;
						}
					} else if (codeArray[cdIndex].value.codeSet === 53) {
							if (codeArray[cdIndex].value.meaning === "DOC") {
								docCd = codeArray[cdIndex].value.codeValue;
							}
						}
				}
				MP_DocumentViewerDialog.buildDocHeaderInformation(replyRBList);
				MP_DocumentViewerDialog.buildDocBodyInformation(replyRBList);

				if (imageSelect === false) {
					currentPage = DocumentViewerTabsIndex.DOCUMENTS;
				} else if (imageSelect === true) {
						currentPage = DocumentViewerTabsIndex.IMAGES;
				}
				
				docRenderHtml.push(MP_DocumentViewerDialog.switchTab(currentPage));
				docModalDialogObject.setBodyHTML(docRenderHtml.join(""));
				$("#docModalDialogheader").css("border", "0px");
				$("#docModalDialogbody").css("border-bottom", "1px solid #ABADB3");
				$("#docModalDialogbody").css("border-left", "1px solid #ABADB3");
				$("#docModalDialogbody").css("border-right", "1px solid #ABADB3");
				if (imageSelect === true) {
					MP_DocumentViewerDialog.ImagesTabContent();
				}
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				$(allTabs).on("click", function () {
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;
					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");
					$("#curTabId").show();
					if (curTabId === "tabHeader_0") {
						MP_DocumentViewerDialog.DocumentsTabContent();
					} else if (curTabId === "tabHeader_1") {
							MP_DocumentViewerDialog.ImagesTabContent();
					}					
				});
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "renderDocumentViewer");
			}
		},
		switchTab : function (tabIndex) {
			try {
				var docSwitchHTML = [];
				var numTabs;
				var showDetails = docViewerModalI18n.SHOW_DETAILS;
				var windowSize = $(window).width();
				docSwitchHTML.push("<div class='document-header'><div class='document-type-date'><dl class='document-note-type'><dt class='document-res-type'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='document-res-value'>" + resultType + "</dd></dl><dl class='document-note-type'><dt class='document-res-date'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='document-res-value'>" + resultDate + "</dd></dl></div><div class='document-showdetails-link'><a onclick='javascript:MP_DocumentViewerDialog.ShowDetailsLink(); return false;' href='#'>" + showDetails + "</a></div><div class='document-separator'><dl class='document-note-type'><span class='doc-separator'>&nbsp;</span></dl></div><div class='document-print' id='printId'><dl class='document-note-type'><span class='document-print-icon' onmouseover='javascript:MP_DocumentViewerDialog.PrintMouseOver();' onmouseout='javascript:MP_DocumentViewerDialog.PrintMouseoff();' onclick='javascript:MP_DocumentViewerDialog.PrintDocument();'>&nbsp;</span></dl></div><div class='document-hdr-details'><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='document-res-value'>" + resultTitle + "</dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='document-res-value'>" + performedBy + "</dd></dl><br><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='document-res-value'>" + resultStatus + "</dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='document-res-value'>" + verifiedBy + "</dd></dl><br><dl class='document-note-type'><dt class='document-name'></dt><dd class='document-res-value'></dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='document-res-value'>" + encounterInfo + "</dd></dl></div></div>");
				docSwitchHTML.push('<div class="doc-main-container" id="tabContainer">');
				if (image) {
					docSwitchHTML.push('<div class="reachview-tabs"><ul>');
					numTabs = tabNames.length;
				} else {
					numTabs = 0;
				}
				if (typeof tabIndex === "number") {
					currentPage = tabIndex;
				} else {
					tabIndex = currentPage;
				}
				var i;
				var iTabName,
				iCount;
				for (i = 0; i < numTabs; i++) {
					iTabName = tabNames[i];
					docSwitchHTML.push('<li id="tabHeader_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
				}
				if (image) {
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie8-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie9-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie10-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.webkit()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-sfr-high-resolution" id="tabContent">');
						} else {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-oth-high-resolution" id="tabContent">');
						}
					} else {
						if (windowSize > 768 && windowSize <= 1024) {
							if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie8-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie9-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie10-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.webkit()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-sfr-low-resolution" id="tabContent">');
							} else {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-oth-low-resolution" id="tabContent">');
							}
						}
					}
					docSwitchHTML.push("</br>", docContentHTML, "</div><iframe id='image-section' class='doc-document-tab' src='" + image + "' width='100%'></iframe>");
					docSwitchHTML.push("</div>");
					MP_DocumentViewerDialog.init();
				} else {
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie8-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie9-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie10-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.webkit()) {
							docSwitchHTML.push('<div class="doc-notabs-content-sfr-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else {
							docSwitchHTML.push('<div class="doc-notabs-content-oth-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						}
					} else {
						if (windowSize > 768 && windowSize <= 1024) {
							if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie8-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie9-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie10-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.webkit()) {
								docSwitchHTML.push('<div class="doc-notabs-content-sfr-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else {
								docSwitchHTML.push('<div class="doc-notabs-content-oth-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							}
						}
					}
				}				
				return docSwitchHTML.join("");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "switchTab");
			}
		},
		PrintMouseOver : function () {
			try {
				$("#docModalDialogbody").find(".document-header").find(".document-print").find(".document-print-icon").removeClass("document-print-icon").addClass("document-print-mouseover");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "PrintMouseOver");
			}
		},
		PrintMouseoff : function () {
			try {
				$("#docModalDialogbody").find(".document-header").find(".document-print").find(".document-print-mouseover").removeClass("document-print-mouseover").addClass("document-print-icon");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "PrintMouseoff");
			}
		},
		PrintDocument : function () {
			var iframeObj = "";
			try {
				var htmlText = [];
				var $style = $("<style type='text/css'>.document-print-label{display:inline;width:20%;}.document-print-font{font-size:14px;font-family:Arial;}.document-content-font{font-size:16px;font-family:Arial;}.document-print-bold{font-weight:bold;}.document-print-value {margin-right:10px;margin-left:4px;display:-moz-inline-stack;vertical-align:top;display:inline-block;zoom:1;*display:inline;}</style>");
				htmlText.push("<div id='printDiv' class='document-print-font'>");
				htmlText.push("<dl><dd class='document-print-value document-print-bold'>" + patName + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + docViewerModalI18n.MRN + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + patMRN + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + docViewerModalI18n.DOB + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + patDOB + "</dd></dl>");
				htmlText.push("<dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='document-print-value'>" + resultType + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='document-print-value'>" + resultDate + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='document-print-value'>" + resultStatus + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='document-print-value'>" + resultTitle + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='document-print-value'>" + performedBy + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='document-print-value'>" + verifiedBy + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='document-print-value'>" + encounterInfo + "</dd></dl></div></br></br>");
				htmlText.push("<div class='document-content-font'>" + docContentHTML.join("") + "</div>");
				htmlText.push("</br></br></br></br><div class='document-print-font'><span>" + docViewerModalI18n.PRINTED_BY + "</span><span>&nbsp" + printedBy + "</span></div>");
				iframeObj = document.createElement("iframe");
				$(iframeObj).css("display", "none");
				document.body.appendChild(iframeObj);
				var printWindow = iframeObj.contentWindow;
				var docObject = printWindow ? printWindow.document : null;
				if (docObject) {
					docObject.write(htmlText.join(""));
					docObject.close();
					$(iframeObj).show().contents().find("head").append($style);
					printWindow.focus();
					printWindow.print();
					printWindow.location.reload();
					printWindow.close();
				}
			} catch (err) {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "PrintDocument");
				throw err;
			}
			finally {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
			}
		},
		DocumentsTabContent : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				$("#docModalDialogbody").find("#tabContent").show();
				$("#image-section").removeClass("doc-image-tab");
				$("#image-section").addClass("doc-document-tab");
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "DocumentsTabContent");
			}
		},
		ImagesTabContent : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				$("#docModalDialogbody").find("#tabContent").hide();
				$("#image-section").removeClass("doc-document-tab");
				$("#image-section").addClass("doc-image-tab");
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "ImagesTabContent");
			}
		},
		ShowDetailsLink : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				var windowSize = $(window).width();
				var docModalDialogBodyObj = $("#docModalDialogbody");
				if (docModalDialogBodyObj.find(".document-showdetails-link").children("a").text() === "" + docViewerModalI18n.SHOW_DETAILS + "") {
					docModalDialogBodyObj.find(".document-showdetails-link").children("a").text("" + docViewerModalI18n.HIDE_DETAILS + "");
					docModalDialogBodyObj.find(".document-header").children("div").removeClass("document-hdr-details").addClass("document-hdr-show");
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "53%");
							$("#noTabContent").css("height", "395px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "445px");
							$("#noTabContent").css("height", "470px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "480px");
							$("#noTabContent").css("height", "515px");
						} else if (MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "455px");
							$("#noTabContent").css("height", "480px");
						} else {
							$("#tabContent").css("height", "71%");
							$("#noTabContent").css("height", "400px");
						}
					} else if (windowSize > 768 && windowSize <= 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "43%");
							$("#noTabContent").css("height", "230px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "310px");
							$("#noTabContent").css("height", "350px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "350px");
							$("#noTabContent").css("height", "385px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "310px");
							$("#noTabContent").css("height", "360px");
						} else {
							$("#tabContent").css("height", "62%");
							$("#noTabContent").css("height", "370px");
						}
					}
				} else {
					docModalDialogBodyObj.find(".document-showdetails-link").children("a").text("" + docViewerModalI18n.SHOW_DETAILS + "");
					docModalDialogBodyObj.find(".document-header").children("div").removeClass("document-hdr-show").addClass("document-hdr-details");
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "65%");
							$("#noTabContent").css("height", "480px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "530px");
							$("#noTabContent").css("height", "560px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "545px");
							$("#noTabContent").css("height", "580px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "520px");
							$("#noTabContent").css("height", "550px");
						} else {
							$("#tabContent").css("height", "82%");
							$("#noTabContent").css("height", "460px");
						}
					} else if (windowSize > 768 && windowSize <= 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "61%");
							$("#noTabContent").css("height", "360px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "425px");
							$("#noTabContent").css("height", "460px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "435px");
							$("#noTabContent").css("height", "470px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "410px");
							$("#noTabContent").css("height", "440px");
						} else {
							$("#tabContent").css("height", "80%");
							$("#noTabContent").css("height", "450px");
						}
					}
				}
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "ShowDetailsLink");
			}
		}
	};
}
();
 MD_microViewerDialog = function () {
	var micViewModalI18n = i18n.discernabu.micro_viewer_modal;
	var jsonResponse = null;
	var specimenFound = false;
	var commentsFound = false;
	var reportsFound = false;
	var suscepFound = false;
	var dateFormatter = null;
	var personnelArray = [];
	var resultType = 0;
	function AntibioticDetails() {
		this.m_description = "";
		this.m_footNoteInd = false;
		this.m_footNoteText = "";
	}
	AntibioticDetails.prototype.getAntiDescription = function () {
		return this.m_description;
	};

	AntibioticDetails.prototype.setAntiDescription = function (desc) {
		this.m_description = desc;
	};
	AntibioticDetails.prototype.getFootNoteInd = function () {
		return this.m_footNoteInd;
	};

	AntibioticDetails.prototype.setFootNoteInd = function (ftInd) {
		this.m_footNoteInd = ftInd;
	};
	AntibioticDetails.prototype.getFootNoteText = function () {
		return this.m_footNoteText;
	};

	AntibioticDetails.prototype.setFootNoteText = function (ftText) {
		this.m_footNoteText = ftText;
	};
	return {

		initMicroViewer : function (eventId, resultName) {
			var microViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("microViewer");
			if (!microViewerModalObj) {
				microViewerModalObj = new ModalDialog("microViewer");
				var micViewerCloseBtn = new ModalButton("micViewerCloseBtn");
				micViewerCloseBtn.setText(micViewModalI18n.CLOSE);
				micViewerCloseBtn.setFocusInd(true);
				microViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(15).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
				microViewerModalObj.setHeaderTitle(micViewModalI18n.MIC_RESULT_DETAILS);
				microViewerModalObj.addFooterButton(micViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(microViewerModalObj);
			}

			microViewerModalObj.setBodyDataFunction(function (micModalObj) {
				MD_microViewerDialog.attachListeners();
				var cclParam = [];
				cclParam.push("^MINE^", eventId + ".0", 0, 1, 1);
				$("#microViewerbody").addClass("micview-loading");
				$("#microViewerbody").html("<div class = 'micview-jj'></div>");
				MD_microViewerDialog.loadWithCBParameters("mp_get_result_viewer_data", cclParam, MD_microViewerDialog.renderMicroViewer);
			});
			MP_ModalDialog.updateModalDialogObject(microViewerModalObj);
			MP_ModalDialog.showModalDialog("microViewer");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		alertError : function (message, title, buttonText) {
			var modalObj = MP_Util.generateModalDialogBody("micViewerFailureAlert", "error", message, "");
			var modalButton = modalObj.getFooterButton("modalOkBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalOkBtn");
				modalButton.setText(buttonText);
				modalButton.setFocusInd(true).setOnClickFunction(function () {MP_ModalDialog.closeModalDialog("microViewer");});
				modalObj.addFooterButton(modalButton);
				modalObj.setShowCloseIcon(false);
			}
			modalObj.setHeaderTitle(title);
			modalObj.setFooterButtonText("modalOkBtn", buttonText);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("micViewerFailureAlert");
		},
		alertMicFootNoteWindow : function (message) {
			var modalObj = MP_Util.generateModalDialogBody("micMicFootNoteAlert", "", message, "");
			var modalButton = modalObj.getFooterButton("modalCloseBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalCloseBtn");
				modalButton.setText(micViewModalI18n.CLOSE);
				modalButton.setFocusInd(true).setOnClickFunction(function () {});
				modalObj.addFooterButton(modalButton);

			}
			modalObj.setHeaderTitle(micViewModalI18n.MIC_FOOTNOTE);
			modalObj.setFooterButtonText("modalCloseBtn", micViewModalI18n.CLOSE);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("micMicFootNoteAlert");
		},
		buildEventDetailSectionHTML : function (eventRBListObj) {
			var eventDetailHTML = [];
			eventDetailHTML.push("<div class='micview-detail' id='micViewDetail'>");
			eventDetailHTML.push("<div class='micview-controls' id='micViewControls'>");
			eventDetailHTML.push(MD_microViewerDialog.buildTabSectionHTML());
			eventDetailHTML.push("</div><div class='micview-tab-body ' id='micViewBody'>");
			eventDetailHTML.push("<div class='micview-body-container' id='micViewTabBodyId'>");
			if (reportsFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildMicroRepotsTabHTML(eventRBListObj));
			}
			if (suscepFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildSuscepTabHTML(eventRBListObj));
			}
			if (specimenFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildSpecimenTabHTML(eventRBListObj));
			}			
			if (commentsFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildCommentsTabHTML(eventRBListObj));
			}
			eventDetailHTML.push(MD_microViewerDialog.buildActionListTabHTML(eventRBListObj));

			eventDetailHTML.push("</div></div></div>");
			return eventDetailHTML.join("");
		},
		buildTabSectionHTML : function () {
			var tabHTML = [];
			var activeTabHTML = "<span class = 'micview-tab-active-left'></span><span class = 'micview-tab-active-center'>";
			var activeCloseHTML = "</span><span class = 'micview-tab-active-right'></span>";
			var tabActivateClass = " micview-tab-active";
			var tabActivateLbl = "micview-tab-active-label";
			var micSepVisible = " hidden";

			tabHTML.push("<span class = 'micview-tab-bg-left micview-tab-container'></span>");

			if (reportsFound) {

				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab1' tabtext = '", micViewModalI18n.MIC_REPORT, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.MIC_REPORT, "</div>", activeCloseHTML, "</div><span id = 'rvDetSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";

			}

			if (suscepFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "'  id='micViewTab2' tabtext = '", micViewModalI18n.SUSCEPTABILITIES,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SUSCEPTABILITIES, "</div>", activeCloseHTML, "</div><span id = 'rvSuscepSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";
			}

			if (specimenFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab3' tabtext = '", micViewModalI18n.SPECIMEN,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SPECIMEN, "</div>", activeCloseHTML, "</div><span id = 'rvSpecimenSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";
			}		

			if (commentsFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab5' tabtext = '", micViewModalI18n.COMMENTS,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.COMMENTS, "</div>", activeCloseHTML, "</div><span id = 'rvCommentsSepId' class='micview-tab-sep", micSepVisible, "'></span>");
			}
			tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab4' tabtext = '", micViewModalI18n.ACTION_LIST,
				"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.ACTION_LIST, "</div>", activeCloseHTML, "</div><span id = 'rvActionSepId' class='micview-tab-sep", micSepVisible, "'></span>");
			return tabHTML.join("");
		},

		buildMicroRepotsTabHTML : function (eventRBListObj) {
			var micReportsTabHTML = [];

			var micListItem = null;
			micReportsTabHTML.push("<div class ='micview-comments-info' id = 'rvMicRepoInfoId'>");
			micRptListLen = eventRBListObj.CHILD_EVENT_LIST.length;
			for (var rptIndex = 0;
				rptIndex < micRptListLen;
				rptIndex++) {
				micListItem = eventRBListObj.CHILD_EVENT_LIST[rptIndex];
				micReportsTabHTML.push("<div class = 'micview-comment-text1'>", micListItem.EVENT_CD_DISP, " - ", dateFormatter.formatISO8601(micListItem.VERIFIED_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), " - </div>");
				micReportsTabHTML.push("<div class = 'micview-comment-pad'>", micListItem.BLOB_RESULT[0].BLOB[0].BLOB_TEXT, "</div>");
			}
			micReportsTabHTML.push("</div>");

			return micReportsTabHTML.join("");
		},
		buildSuscepTabHTML : function (eventRBListObj) {
			var suscepTabHTML = [];
			var micListItem = null;
			var micSuscepListItem = null;
			var micListLen = 0;
			var suscepFTLen = 0;
			var suscepFTItem = null;
			var micSuscepListLen = 0;
			var firstColIndx = 1;
			var suscepColHeaders = [];
			var suscepTableHeaderCols = 0;
			var antibioticArray = [];
			var alphaChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
			var suscepVisible = reportsFound ? " hidden" : "";
			suscepTabHTML.push("<div class ='micview-comments-info", suscepVisible, "' id = 'rvSuscepInfoId'>");
			suscepTabHTML.push("<div class = 'micview-table-div'><table class='micview-suscep-table'><tr><th></th>");

			micListLen = eventRBListObj.MICROBIOLOGY_LIST.length;
			suscepColHeaders = new Array(micListLen);
			antibioticArray = new Array(micListLen);

			for (var micIndex = 0; micIndex < micListLen; micIndex++) {

				micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
				micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
				var tempArray = [];
				var tempAntibioticArray = [];
				var tempAntibioticObjectArr = [];

				for (var micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

					micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

					var colName = micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP;
					var antiBioticDisp = micSuscepListItem.ANTIBIOTIC_CD_DESC;
					if (tempArray.indexOf(colName) === -1) {
						tempArray.push(colName);
					}
					if (tempAntibioticArray.indexOf(antiBioticDisp) === -1) {
						var antibioticObject = new AntibioticDetails();
						antibioticObject.setAntiDescription(antiBioticDisp);
						suscepFTLen = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST.length;
						for (var suscepFTIndex = 0; suscepFTIndex < suscepFTLen; suscepFTIndex++) {
							suscepFTItem = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST[suscepFTIndex];
							var ftLen = suscepFTItem.SUSCEP_FOOTNOTE.length;
							for (var ftIndex = 0; ftIndex < ftLen; ftIndex++) {
								var ftItem = suscepFTItem.SUSCEP_FOOTNOTE[ftIndex];
								if (suscepFTItem.SUSCEP_SEQ_NBR === micSuscepListItem.SUSCEP_SEQ_NBR) {
									antibioticObject = new AntibioticDetails();
									antibioticObject.setFootNoteInd(true);
									antibioticObject.setAntiDescription(antiBioticDisp);
									antibioticObject.setFootNoteText(ftItem.LONG_TEXT);
								}

							}

						} //suscepFoot note
						tempAntibioticArray.push(antiBioticDisp);
						tempAntibioticObjectArr.push(antibioticObject);
					}

				} // end for suscep

				suscepColHeaders[micIndex] = tempArray;

				antibioticArray[micIndex] = tempAntibioticObjectArr;
				if (suscepColHeaders[micIndex].length > suscepTableHeaderCols) {
					suscepTableHeaderCols = suscepColHeaders[micIndex].length;
				}

			} //end for micro

			//Adding Suscep table coloumn headers
			for (suscepColIdx = 0; suscepColIdx < suscepTableHeaderCols + 1; suscepColIdx++) {
				suscepTabHTML.push("<th>", alphaChars.charAt(suscepColIdx), "</th>");
			}
			suscepTabHTML.push("</tr>");

			for (var micIndex = 0; micIndex < micListLen; micIndex++) {
				micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
				var micItemOrganismCDDesc = (micListItem.ORGANISM_OCCURRENCE_NBR === 1) ? micListItem.ORGANISM_CD_DESC : micListItem.ORGANISM_CD_DESC + " #" + micListItem.ORGANISM_OCCURRENCE_NBR;
				suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-section'>", micItemOrganismCDDesc, "</td>");

				for (var i = 0; i < suscepColHeaders[micIndex].length; i++) {
					suscepTabHTML.push("<td  class = 'micview-suscep-section'></td>");
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
				}
				suscepTabHTML.push("</tr>");

				suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-subsection'></td>");

				for (var i = 0; i < suscepColHeaders[micIndex].length; i++) {
					suscepTabHTML.push("<td  class = 'micview-suscep-subsection'>", suscepColHeaders[micIndex][i], "</td>");
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
				}
				suscepTabHTML.push("</tr>");

				micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;

				for (var k = 0; k < antibioticArray[micIndex].length; k++) {
					var antobioticHTML = [];
					for (var j = 0; j < suscepColHeaders[micIndex].length; j++) {
						var suscepFound = false;

						for (var micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

							micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

							if (antibioticArray[micIndex][k].getAntiDescription() === micSuscepListItem.ANTIBIOTIC_CD_DESC &&
								suscepColHeaders[micIndex][j] === micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP) {
								antobioticHTML.push("<td class = 'micview-suscep-cell'>", micSuscepListItem.RESULT_CD_DISP ? micSuscepListItem.RESULT_CD_DISP : micSuscepListItem.RESULT_NUMERIC_VALUE, "</td>");
								suscepFound = true;

								break;
							}
						}
						if (!suscepFound) {
							antobioticHTML.push("<td class = 'micview-suscep-cell'></td>");
						}

					}
					var footNoteClass = "'";
					var footNoteInd = antibioticArray[micIndex][k].getFootNoteInd();

					var antibioticText = footNoteInd ? antibioticArray[micIndex][k].getAntiDescription() + "*" : antibioticArray[micIndex][k].getAntiDescription();

					var micViewFNText = "\"" + antibioticArray[micIndex][k].getFootNoteText() + "\"";
					var micViewFNHeader = "\"" + micItemOrganismCDDesc + "\"";
					var micViewFNAnti = "\"" + antibioticArray[micIndex][k].getAntiDescription() + "\"";
					if (footNoteInd) {
						footNoteClass = " micview-footnote' onclick = 'MD_microViewerDialog.buildFootNoteHTML(" + micViewFNHeader + "," + micViewFNAnti + "," + micViewFNText + ")'";
					}
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						antobioticHTML.push("<td  class = 'micview-suscep-cell'></td>");
					}

					suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-cell'", footNoteClass,
						">", antibioticText, "</td>", antobioticHTML.join(""), "</tr>");

				}
				if (micIndex !== micListLen - 1) {
					suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th>");
					for (var i = 0; i <= suscepTableHeaderCols; i++) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
					suscepTabHTML.push("</tr>");
				}
			}

			suscepTabHTML.push("</table></div></div>");

			return suscepTabHTML.join("");
		},

		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var requestedByName = "";
			var requestedBy = null;
			var proxyName = "";
			var proxy = null;
			var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";
			actionListTabHTML.push("<div class = 'micview-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'micview-table-div'><table class='micview-actionlist-table'><tr><th>", micViewModalI18n.ACTION, "</th><th>", micViewModalI18n.PERFORMED_BY, "</th><th>", micViewModalI18n.PERFORMED_DATE, "</th><th>", micViewModalI18n.ACTION_STATUS, "</th><th>", micViewModalI18n.COMMENT, "</th><th>", micViewModalI18n.PROXY_PERSONNEL, "</th><th>", micViewModalI18n.REQUESTED_BY, "</th><th>", micViewModalI18n.REQUESTED_DATE, "</th><th>", micViewModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
				actionDtTm="";
				requestDtTm="";
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				if (actionListItem.ACTION_DT_TM !== invalidDate) {
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if (actionListItem.REQUEST_DT_TM !== invalidDate) {
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		buildSpecimenTabHTML : function (eventRBListObj) {
			var specimenTabHTML = [];
			var specimenCollObj = null;
			var specimenCollectedDtTm = "";
			var emptyCell = " --";
			var specimenVisible = (reportsFound || suscepFound) ? " hidden" : "";

			specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
			specimenCollectedDtTm = dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			specimenTabHTML.push("<div class ='micview-specimen-info", specimenVisible, "' id = 'rvSpecimenInfoId'><div class = 'micview-tt'><span><h2 class='micview-resval'><span class = 'micview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='micview-pad", "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'micview-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP ? specimenCollObj.SOURCE_TYPE_CD_DISP : emptyCell, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'micview-event-data'>", specimenCollectedDtTm ? specimenCollectedDtTm : emptyCell, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.BODY_SITE, ":</dd><dd class = 'micview-event-data'>", specimenCollObj.BODY_SITE_CD_DISP ? specimenCollObj.BODY_SITE_CD_DISP : emptyCell, "</dd></dl>");

			specimenTabHTML.push("</div>");
			return specimenTabHTML.join("");
		},
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='micview-comments-info hidden' id = 'rvCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			for (var noteIndex = 0;
				noteIndex < noteListLen;
				noteIndex++) {
				noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
				provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
				commentProviderName = (provider === null) ? "" : provider.fullName;
				commentsTabHTML.push("<div class = 'micview-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", micViewModalI18n.BY, " ", commentProviderName, " ", micViewModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
				commentsTabHTML.push("<div class = 'micview-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
			}
			commentsTabHTML.push("</div>");
			return commentsTabHTML.join("");
		},
		renderMicroViewer : function (response) {
			var micViewModalBodyHTML = [];
			var micViewModalObject = MP_ModalDialog.retrieveModalDialogObject("microViewer");
			var micViewModalId = micViewModalObject.getBodyElementId();
			dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			jsonResponse = response.getResponse();
			if (jsonResponse) {
				if (response.getStatus() === "F") {
					MP_Util.LogScriptCallError(null, this, "micro_viewer.js", "renderMicroViewer");
					MD_microViewerDialog.alertError(micViewModalI18n.ERROR_RETRIEVE, micViewModalI18n.ERROR_TITLE, micViewModalI18n.OK);
					return;
				}
			}
			personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);
			specimenFound = false;
			commentsFound = false;
			suscepFound = false;
			reportsFound = false;
			if (jsonResponse.RB_LIST[0].SPECIMEN_COLL.length) {
				specimenFound = true;
			}
			if (jsonResponse.RB_LIST[0].EVENT_NOTE_LIST.length) {
				commentsFound = true;
			}
			if (jsonResponse.RB_LIST[0].CHILD_EVENT_LIST.length) {
				reportsFound = true;
			}
			if (jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST.length) {
				for (var micIndex = 0; micIndex < jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST.length; micIndex++) {
					var micListItem = jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST[micIndex];
					var micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
					if (micSuscepListLen) {
						suscepFound = true;
					}
				}
			}

			micViewModalBodyHTML.push("<div class='micview-container'>");
			micViewModalBodyHTML.push("<div class = 'micview-tt'><span><h2 class='micview-resval'><span class = 'micview-resname'>", jsonResponse.RB_LIST[0].EVENT_CD_DISP, " - ", micViewModalI18n.ACCESSION_NUMBER, ":</span><span><span class='micview-pad", "'>", jsonResponse.RB_LIST[0].ACCESSION_NBR, "</span></span></h2></span></div>");
			micViewModalBodyHTML.push(MD_microViewerDialog.buildEventDetailSectionHTML(jsonResponse.RB_LIST[0]));
			micViewModalBodyHTML.push("</div>");
			$("#microViewerbody").removeClass("micview-loading");
			$("#" + micViewModalId).html(micViewModalBodyHTML.join(""));
		},
		buildFootNoteHTML : function (fnOrganismDesc, fnAntiDesc, fnText) {

			var modalFootNoteHTML = "";
			modalFootNoteHTML = "<div><span class = 'micview-resname'>" + fnOrganismDesc + "<span><span class = 'micview-footnote-txt'> - " +
				fnAntiDesc + "</span></div><br><div class = 'micview-footnote-div'>" + fnText + "</div>";
			MD_microViewerDialog.alertMicFootNoteWindow(modalFootNoteHTML);

		},
		onTabChange : function (selectedTabObj) {
			var objTabActive = $(selectedTabObj).parent().find(".micview-tab-active");
			if (objTabActive.length) {
				if ($(objTabActive).attr("id") === $(selectedTabObj).attr("id")) {
					return;
				}
				$(objTabActive).empty();
				$(objTabActive).html("<div class='micview-tab-inactive-label'>" + $(objTabActive).attr("tabText") + "</div>");
				objTabActive.removeClass("micview-tab-active");
				objTabActive.addClass("micview-tab-inactive");
				$(objTabActive).next().removeClass("hidden");
				$(objTabActive).prev().removeClass("hidden");
			}
			$(selectedTabObj).removeClass("micview-tab-inactive");
			$(selectedTabObj).next().addClass("hidden");
			$(selectedTabObj).prev().addClass("hidden");
			$(selectedTabObj).addClass("micview-tab-active");
			$(selectedTabObj).html("<span class = 'micview-tab-active-left'></span><span class = 'micview-tab-active-center'><span class='micview-tab-active-label'>" + $(selectedTabObj).attr("tabText") + "</span></span><span class = 'micview-tab-active-right'></span>");
			$(selectedTabObj).removeClass("micview-tab-inactive");
			$(selectedTabObj).addClass("micview-tab-active");
		},
		attachListeners : function () {

			$(document).on("click", "#micViewTab1", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").removeClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab2", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").removeClass("hidden");
			});
			$(document).on("click", "#micViewTab3", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").removeClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab4", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").removeClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab5", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").removeClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
		}
	};
}
();
var MP_PathologyViewerDialog = function(){	
	var pathViewerModalI18n = i18n.discernabu.pathology_viewer_modal;
	var jsonResponse = null;
	var PathologyViewerTabsIndex = {
			REPORT: 0,
			IMAGES:1,
			ACTION_LIST: 2,
			COMMENTS: 3			
			};
	var currentPage = PathologyViewerTabsIndex.REPORT;
	var image = "";
	var imageFlag = false;
	var tabNames = [];	
	var enabled = false;
	var creds = "";
	var username = "";
	var pwd = "";
	var dm = "";
	var ajo;	
	var ajo2;
	var eventGlobalId = 0;
	var dateFormatter = null;
	var personnelArray = [];
	var requestedBy = "";
	var receivedDate = "";
	var verifiedDate = "";
	
	return {
		
		initPathologyViewer: function (patient_Id, event_Id, docViewerType) {		
				var docType = (docViewerType) ? docViewerType : "STANDARD";
				var pathLoading = [];								
				eventGlobalId = event_Id + ".0";
				patient_Id = patient_Id + ".0";			

				var pathModalDialog = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
				if(!pathModalDialog)
				{
					pathModalDialog = new ModalDialog("pathModalDialog");
					pathModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
					pathModalDialog.setHeaderCloseFunction();
					pathModalDialog.setHeaderTitle("<span class='visitswindow-title'>"+ pathViewerModalI18n.PATHOLOGY_TITLE +"</span>"); 
					MP_ModalDialog.addModalDialogObject(pathModalDialog);					
				}		
										  
				pathModalDialog.setBodyDataFunction(function(pathViewDlg)
				{
					var cclParams = [];
					cclParams.push("^MINE^", eventGlobalId, patient_Id, "^"+ docType +"^");
					MP_PathologyViewerDialog.loadWithCBParameters("mp_get_path_viewer_data", cclParams, MP_PathologyViewerDialog.renderPathViewer);																	
				});						
				  
				MP_ModalDialog.updateModalDialogObject(pathModalDialog);
				MP_ModalDialog.showModalDialog(pathModalDialog.getId());				
				pathLoading.push("<div class='path-body-loading'><span class='path-loading'></span>" +								
								"</div>");				
				pathModalDialog.setBodyHTML ( pathLoading.join(""));								
				$('#pathModalDialogbody').css("overflow","hidden");
				$("#pathModalDialogbody").css("height", "100%");			
				$("#vwpModalDialogpathModalDialog").css("height", "100%");
				$("#vwpModalDialogpathModalDialog").css("position", "absolute");
		},

		loadWithCBParameters : function(programName, cclParams, callBack) {
			try{
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);				
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
				}
				catch(err)
				{
					MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "loadWithCBParameters");
				}
		},
		
		renderPathViewer : function(response) {
			try
			{					
				var pathModalBodyHTML = [];
				var pathModalObject = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
				var pathModalId = pathModalObject.getBodyElementId();				
				var actionListTab = pathViewerModalI18n.ACTION_LIST;
				var commentsTab = pathViewerModalI18n.COMMENTS;
				var imagesTab = pathViewerModalI18n.IMAGES;
				dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

				jsonResponse = response.getResponse();
				if(jsonResponse) {
					if(response.getStatus() === "F") {
						MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "renderPathViewer");							
						return;
					}
				}			
			
				tabNames[PathologyViewerTabsIndex.REPORT] = (jsonResponse.PAT_ENCNTR_DETAILS.RESULT_TITLE) ? jsonResponse.PAT_ENCNTR_DETAILS.RESULT_TITLE : "";
				tabNames[PathologyViewerTabsIndex.IMAGES] = imagesTab;
				tabNames[PathologyViewerTabsIndex.ACTION_LIST] = actionListTab;
				tabNames[PathologyViewerTabsIndex.COMMENTS] = commentsTab;				

				personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);
				pathModalBodyHTML.push(MP_PathologyViewerDialog.switchTab(currentPage));

				pathModalObject.setBodyHTML (pathModalBodyHTML.join(""));
				$('#pathModalDialogheader').css("border","0px");
				$("#pathModalDialogbody").css("border-bottom", "1px solid #ABADB3");
				$("#pathModalDialogbody").css("border-left", "1px solid #ABADB3");
				$("#pathModalDialogbody").css("border-right", "1px solid #ABADB3");
				
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				
				$(allTabs).on("click", function () {				
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;

					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");									
					$("#curTabId").show();
					var pathModalDialogBodyObj = $('#pathModalDialogbody');
					
					if (curTabId === "pathViewerTab_0") 
					{
						imageFlag = false;
						pathModalDialogBodyObj.find(".path-report-tab").show();
						pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
						pathModalDialogBodyObj.find(".path-comments-tab").hide();
						pathModalDialogBodyObj.find(".path-image-tab").hide();
						$("#iframeImageId").css("visibility", "hidden");
					}
					else if (curTabId === "pathViewerTab_3") 
					{
						imageFlag = false;
						pathModalDialogBodyObj.find(".path-comments-tab").show();
						pathModalDialogBodyObj.find("path-comments-info").show();
						$("#pathCommentsInfoId").removeClass("hidden");
						pathModalDialogBodyObj.find(".path-report-tab").hide();
						pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
						pathModalDialogBodyObj.find(".path-image-tab").hide();
						$("#iframeImageId").css("visibility", "hidden");
					}
					if(image)
					{
						if (curTabId === "pathViewerTab_1") 
						{
							if(imageFlag)
							{
								var iframeObj = document.getElementById('iframeImageId');								
								iframeObj.src = image;
								var url0 = iframeObj.src.split('?')[0];
								var q = "?";								
								var urlLen = iframeObj.src.split('?')[1].length;
								var url1 = iframeObj.src.split('?')[1].slice(1,urlLen);
								iframeObj.src=url0+q+url1;
							}							
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").show();
							$("#iframeImageId").css("visibility", "visible");
						}
						else if (curTabId === "pathViewerTab_2") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-actionlist-tab").show();
							pathModalDialogBodyObj.find("path-actionlist-info").show();
							$("#pathActionListInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
					}
					else
					{
						if (curTabId === "pathViewerTab_1") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-actionlist-tab").show();
							pathModalDialogBodyObj.find("path-actionlist-info").show();
							$("#pathActionListInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
						else if (curTabId === "pathViewerTab_2") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-comments-tab").show();
							pathModalDialogBodyObj.find("path-comments-info").show();
							$("#pathCommentsInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
					}					
				});
				}
				catch(err)
				{
					MP_Util.LogJSError(err, this, "pathology_viewer_modal.js", "renderPathologyViewer");
				}
			},
		
		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var actionListRequestedBy = null;
			var actionListRequestedByName = "";
			var proxy = null;
			var proxyName = "";
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			
			actionListTabHTML.push("<div class ='path-actionlist-info hidden' id = 'pathActionListInfoId'><div class = 'path-table-div'><table class='path-actionlist-table'><tr><th>", pathViewerModalI18n.ACTION, "</th><th>", pathViewerModalI18n.ACTION_PERFORMED_BY, "</th><th>", pathViewerModalI18n.PERFORMED_DATE, "</th><th>", pathViewerModalI18n.ACTION_STATUS, "</th><th>", pathViewerModalI18n.COMMENT, "</th><th>", pathViewerModalI18n.PROXY_PERSONNEL, "</th><th>", pathViewerModalI18n.ACTION_REQUESTED_BY, "</th><th>", pathViewerModalI18n.REQUESTED_DATE, "</th><th>", pathViewerModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;
				alIndex < actionListLen;
				alIndex++) {
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				actionDtTm = "";
				requestDtTm = "";
				var actionDate = actionListItem.ACTION_DT_TM.substr(6,4);
				var reqDate = actionListItem.REQUEST_DT_TM.substr(6,4);				
				if(actionDate > 0){					
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if(reqDate > 0)
				{					
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);					
				}
				
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				actionListRequestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				actionListRequestedByName = (actionListRequestedBy === null) ? "" : actionListRequestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", actionListRequestedByName ? actionListRequestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
				if(actionListItem.ACTION_TYPE_CD === jsonResponse.ACTION_TYPE_CDS.ORDER_CD)
				{
					requestedBy = actionProviderName;
					receivedDate = actionDtTm;
				}
				if(actionListItem.ACTION_TYPE_CD === jsonResponse.ACTION_TYPE_CDS.VERIFY_CD)
				{
					verifiedDate = actionDtTm;
				}
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='path-comments-info hidden' id = 'pathCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			if(noteListLen > 0)
			{
				for (var noteIndex = 0;
					noteIndex < noteListLen;
					noteIndex++) {
					noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
					provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
					commentProviderName = (provider === null) ? "" : provider.fullName;				
					commentsTabHTML.push("<div class = 'path-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", pathViewerModalI18n.BY, " ", commentProviderName, " ", pathViewerModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
					commentsTabHTML.push("<div class = 'path-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
				}
			}
			else
			{
				commentsTabHTML.push("<div class = 'path-nocomments-text'>"+ pathViewerModalI18n.NO_COMMENTS +"</div>");
			}
			return commentsTabHTML.join("");
		},
		
		init : function () {
			var url = "../../mpages/creds";
			ajo = MP_PathologyViewerDialog.getXMLHttpRequest();
			ajo.open("GET", url, false);
			ajo.onreadystatechange = MP_PathologyViewerDialog.processRequest;
			ajo.send();
		},
		
		getXMLHttpRequest : function () {
			var xmlHttp = null;
			try {
				if (window.XMLHttpRequest) {
					xmlHttp = new XMLHttpRequest();
				}
			} catch (e) {
				try {
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} catch (e2) {
					xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
				}
			}
			return xmlHttp;
		},
		
		processRequest : function () {
			try {
				if (ajo.readyState == 4) {
					if (ajo.status == 200) {
						var jObj = JSON.parse(ajo.responseText);
						username = jObj.un;
						pwd = jObj.pw;
						dm = jObj.dm;
						MP_PathologyViewerDialog.locateCmvWebapp();
					}
				} else {
					MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "processRequest");
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "processRequest");
			}
		},
		
		webkit : function () {
			return new RegExp(" AppleWebKit/").test(navigator.userAgent);
		},
		
		locateCmvWebapp : function () {
			try {
				var fullCanonicalDomainName = jsonResponse.FULL_CANONICAL_DOMAIN_NAME; 			
				ajo2 = MP_PathologyViewerDialog.getXMLHttpRequest();
				var userDomain = "";
				var url = window.location.protocol + "//" + window.location.host + "/mediaviewer/"+ fullCanonicalDomainName +"/mom";
				if (MP_PathologyViewerDialog.webkit() === true) {
					userDomain = username + "%40" + dm;
				} else {
					userDomain = username + "@" + dm;
				}
				ajo2.open("GET", url, false, userDomain, pwd);			
				ajo2.send();
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "locateCmvWebapp");
			}
		},			
		
		switchTab : function(tabIndex) {
		try{
			var htmlArray = [];
			var jsonRBList = jsonResponse.RB_LIST[0];
			var pathReportDetailsLength = jsonRBList.CHILD_EVENT_LIST.length;
			var blobsLength = jsonResponse.BLOBS.length;
			var noteBlobLength = jsonResponse.NOTE_BLOB.length;
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);			
			var reportHTML = [];
			var reportTitleLine = "";
			var reportNoteLine = "";
			var reportHTMLDisplay = [];
			var emptyData = "--";
			var rptCase = "";
			var rptRequestedBy = "";
			var rptCollected = "";
			var rptLocation = "";
			var rptReport = "";
			var rptPerformedBy = "";
			var rptReceived = "";
			var rptStatus = "";
			var rptVerified = "";
			var rptActionList = [];
			var rptComments = [];
			image = (jsonResponse.PATH_IMAGES.IMAGE_URL) ? jsonResponse.PATH_IMAGES.IMAGE_URL : "";
			imageFlag = true;
			
			if(pathReportDetailsLength > 0)
			{				
				var jsonChildEventList = jsonRBList.CHILD_EVENT_LIST[0];
				var jsonResultDetails = jsonResponse.PAT_ENCNTR_DETAILS;				
				
				rptActionList = MP_PathologyViewerDialog.buildActionListTabHTML(jsonRBList);
				rptComments = MP_PathologyViewerDialog.buildCommentsTabHTML(jsonRBList);
				
				rptCase = (jsonChildEventList.EVENT_TAG) ? jsonChildEventList.EVENT_TAG : emptyData;				
				rptRequestedBy = (requestedBy) ? requestedBy : emptyData;
				rptCollected = (jsonResultDetails.RESULT_DATE) ? df.formatISO8601(jsonResultDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;				
				rptLocation = (jsonResultDetails.INSTITUTION_DISP) ? jsonResultDetails.INSTITUTION_DISP : emptyData;				
				rptReport = (jsonResultDetails.RESULT_TITLE) ? jsonResultDetails.RESULT_TITLE : emptyData;				
				rptPerformedBy = (jsonResultDetails.VERIFIED_FULL) ? jsonResultDetails.VERIFIED_FULL : emptyData;				
				rptReceived = (receivedDate) ? receivedDate : emptyData;
				rptStatus = (jsonResultDetails.RESULT_STATUS) ? jsonResultDetails.RESULT_STATUS : emptyData;				
				rptVerified = (verifiedDate) ? verifiedDate : emptyData;
			}
			
			if(blobsLength > 0)
			{
				for (var b = 0; b < blobsLength; b++) 
				{
					var childNoteListLen = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST.length;
					reportTitleLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_TITLE_TEXT;
					reportHTML.push("<br><span class='path-blob-title'>" + reportTitleLine + "</span><br>");				
					reportHTML.push(jsonResponse.BLOBS[b].BLOB_HTML);
					
					if(childNoteListLen > 0)
					{
						for(var n = 0; n < childNoteListLen; n++)
						{
							reportNoteLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST[0].LONG_BLOB_TXT;
							reportHTML.push("<br><span>" + reportNoteLine + "</span><br>");
						}
					}
					reportHTMLDisplay = reportHTML.join("");
				}
			}
			
			htmlArray.push("<div class='path-header'>"+								
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.CASE +"</dt><dd class='path-res-value'>"+ rptCase +"</dd></dl>"+
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.REQUESTED_BY +"</dt><dd class='path-res-value'>"+ rptRequestedBy +"</dd></dl>"+	
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.COLLECTED +"</dt><dd class='path-res-value'>"+ rptCollected +"</dd></dl>"+
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.VERIFIED +"</dt><dd class='path-res-value'>"+ rptVerified +"</dd></dl>"+								
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.REPORT +"</dt><dd class='path-res-value'>"+ rptReport +"</dd></dl>"+
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.PERFORMED_BY +"</dt><dd class='path-res-value'>"+ rptPerformedBy +"</dd></dl>"+
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.RECEIVED +"</dt><dd class='path-res-value'>"+ rptReceived +"</dd></dl>"+
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.LOCATION +"</dt><dd class='path-res-value'>"+ rptLocation +"</dd></dl>"+								
								"<dl class='path-note-type'><dt class='path-name'>"+ pathViewerModalI18n.STATUS +"</dt><dd class='path-res-value'>"+ rptStatus +"</dd></dl>"+								
							"</div>");	
			
			htmlArray.push('<div class="path-tabs-container" id="tabContainer"><div class="reachview-tabs"><ul>');

			var numTabs;
			if (image) {				
				numTabs = tabNames.length;
			} else {								
				tabNames.splice(1,1);
				numTabs = tabNames.length;
			}
			
			if(typeof tabIndex ==="number"){
				currentPage = tabIndex;
			}else{
				tabIndex= currentPage;
			}
		
			var i;
			var iTabName;
			for ( i = 0; i < numTabs; i++) {				
				iTabName = tabNames[i];
				htmlArray.push('<li id="pathViewerTab_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
			}
			htmlArray.push('</ul></div><hr /><div class="path-tabs-content">');
			if(image){
				htmlArray.push("<div class='tabs'>"+
									"<ul>"+
										"<li id='tab1'></li>"+
										"<li id='tab2'></li>"+
										"<li id='tab3'></li>"+
										"<li id='tab4'></li>"+
									"</ul>"+
								"</div>"+
								
								"<div class='path-report-tab' id='tab-sec-1'>"+	
									"<dl class='path-smry-data'><dt class='path-res-type'></dt><dd class='path-smry-value'>" + reportHTMLDisplay + "</dd></dl>"+
								"</div>"+
								"<div class='path-image-tab' id='tab-sec-2'>"+
									"<iframe id='iframeImageId' style= 'visibility:hidden;' src='" + image + "' width='100%' height='700'></iframe>"+
								"</div>"+
								"<div class='path-actionlist-tab' id='tab-sec-3'>" , rptActionList, "</div>"+
								"<div class='path-comments-tab' id='tab-sec-4'>" , rptComments, "</div></div>");

				htmlArray.push('</div>');				
				htmlArray.push("</div></div>");				
				MP_PathologyViewerDialog.init();
			}
			else
			{
				htmlArray.push("<div class='tabs'>"+
								"<ul>"+
									"<li id='tab1'></li>"+
									"<li id='tab3'></li>"+
									"<li id='tab4'></li>"+									
								"</ul>"+
							"</div>"+
														
							"<div class='path-report-tab' id='tab-sec-1'>"+	
								"<dl class='path-smry-data'><dt class='path-res-type'></dt><dd class='path-smry-value'>" + reportHTMLDisplay + "</dd>"+
							"</div>"+
							
							"<div class='path-actionlist-tab' id='tab-sec-3'>"+								
								"<span class='path-tab-content'>"+ rptActionList +"</span>"+
							"</div>"+
							
							"<div class='path-comments-tab' id='tab-sec-4'>"+
								"<span class='path-tab-content'>"+ rptComments +"</span>"+	
							"</div>");
							
			htmlArray.push('</div>');			
			htmlArray.push("</div></div>");
			}
			var hxHTML = htmlArray.join("");
			return hxHTML;
		}
		catch(err)
		{
			MP_Util.LogJSError(err, this, "pathology_viewer_modal.js", "switchTab");
		}
		}		
	};
}();/* The namespace MD_reachViewerDialog has functions for Reach Viewer */	
	var MD_reachViewerDialog = function () {
		var m_personId = 0;
		var m_encounterId = 0;
		var m_peventId =0;
		var m_providerId = 0;
		var m_eventId = 0;
		var m_viewerType = "";
		var m_imageUrl = "";
		var m_resultName = "";
		var m_imageClicked = 0;
		var m_docDisplay = "";
		var m_posCd = 0;
		var m_visitDate = "";		
				
	return {	
		LaunchReachGraphViewer: function(params){
		try{					
			MD_trendingGraphDialog.initTrendGraph(params);
		
		}
		catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachClinNoteViewer");
		
			}
		
		},
		
		/**
		 * Retrieves a document/result for viewing via the MPages Modal viewer
		 */		
		LaunchReachClinNoteViewer: function(m_personId,m_encounterId,m_eventId,m_docDisplay,m_viewerType,m_peventId,m_imageUrl,m_providerId,m_imageClicked,m_resultName) {		
			
			try {	
			
				switch (m_viewerType) {					
					case 'DOC':						
						MP_DocumentViewerDialog.initDocumentViewer(m_personId,m_encounterId,m_eventId,m_docDisplay,m_viewerType,m_peventId,m_imageUrl,m_providerId,m_imageClicked);
						break;
					case 'EVENT':						
						MD_resultViewerDialog.initResultViewer(m_eventId,m_resultName);
						break;					
					case 'MICRO':						
						MD_microViewerDialog.initMicroViewer(m_eventId,m_resultName);
						break;						
					case 'AP':
						MP_PathologyViewerDialog.initPathologyViewer(m_personId, m_eventId, m_viewerType);
						break;
				}
			}
			catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachClinNoteViewer");
		
			}

		},
		
		LaunchReachVisitsDetailViewer : function(m_personId, m_encounterId, m_providerId, m_posCd, m_visitDate) {
			try {					
					MP_VisitDetailDialog.initVisitViewer(m_personId, m_encounterId, m_providerId, m_posCd, m_visitDate);
				}
			catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachVisitsDetailViewer");		
			}
		}
		
	};
}
();

var MD_resultViewerDialog = function () {
	var resViewModalI18n = i18n.discernabu.result_viewer_modal;
	var jsonResponse = null;
	var specimenFound = false;
	var commentsFound = false;
	var dateFormatter = null;
	var personnelArray = [];
	var resultType = 0;
	return {
		initResultViewer : function (eventId, resultName) {
			var resultViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
			if (!resultViewerModalObj) {
				resultViewerModalObj = new ModalDialog("resultViewer");
				var resViewerCloseBtn = new ModalButton("resViewerCloseBtn");
				resViewerCloseBtn.setText(resViewModalI18n.CLOSE);
				resViewerCloseBtn.setFocusInd(true);
				resultViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(15).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
				resultViewerModalObj.setHeaderTitle(resultName?resultName:resViewModalI18n.RESULT_DETAILS);
				resultViewerModalObj.addFooterButton(resViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(resultViewerModalObj);
			}
		
			resultViewerModalObj.setHeaderTitle(resultName?resultName:resViewModalI18n.RESULT_DETAILS);
			resultViewerModalObj.setBodyDataFunction(function (resultModalObj) {
				MD_resultViewerDialog.attachListeners();
				var cclParam = [];
				cclParam.push("^MINE^", eventId + ".0", 0, 1);
				$("#resultViewerbody").addClass("resview-loading");
				$("#resultViewerbody").html("<div class = 'resview-jj'></div>");
				MD_resultViewerDialog.loadWithCBParameters("mp_get_result_viewer_data", cclParam, MD_resultViewerDialog.renderResultViewer);
			});
			MP_ModalDialog.updateModalDialogObject(resultViewerModalObj);
			MP_ModalDialog.showModalDialog("resultViewer");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		alertError : function (message, title, buttonText) {
			var modalObj = MP_Util.generateModalDialogBody("resViewerFailureAlert", "error", message, "");
			var modalButton = modalObj.getFooterButton("modalOkBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalOkBtn");
				modalButton.setText(buttonText);
				modalButton.setFocusInd(true).setOnClickFunction(function () {MP_ModalDialog.closeModalDialog("resultViewer");});
				modalObj.addFooterButton(modalButton);
				modalObj.setShowCloseIcon(false);
			}
			modalObj.setHeaderTitle(title);
			modalObj.setFooterButtonText("modalOkBtn", buttonText);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("resViewerFailureAlert");
		},
		buildEventHistorySectionHTML : function () {
			var eventHistoryHTML = [];
			var validFromDtTm = "";
			var validUntilDtTm = "";
			var normalcyClass = "";					 
			eventHistoryHTML.push("<div class = 'resview-history-label' id = 'resViewHistLblId'>", resViewModalI18n.HISTORY, "</div>");
			eventHistoryHTML.push("<div class ='resview-event-hist-info' id = 'resViewHistLblId'><div class = 'resview-hist-table-div'>");
			eventHistoryHTML.push("<table class='resview-actionlist-table'><tr><th>", resViewModalI18n.VALUE, "</th><th>", resViewModalI18n.VALID_FROM, "</th><th>", resViewModalI18n.VALID_UNTIL, "</th></tr>");
			var eventHistLength = jsonResponse.EVENT_HIST_LIST.length;
			var zebraClass = "odd ";
			var firstRow = "";
			var resultValColorClass = "";
			var resVal = "";
			for (var ehIndex = 0;
				ehIndex < eventHistLength;
				ehIndex++) {
				var eventHistItem = jsonResponse.RB_LIST[ehIndex];
				if (ehIndex === 0) {

					firstRow = "resview-hist-select resview-wht-text";
					resultValColorClass = "resview-wht-text ";
				} else {
					firstRow = "";
					resultValColorClass = "";
				}
				if (ehIndex % 2) {
					zebraClass = "even ";
				} else {
					zebraClass = "odd ";
				}
			
				validFromDtTm = dateFormatter.formatISO8601(eventHistItem.VALID_FROM_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				validUntilDtTm = dateFormatter.formatISO8601(eventHistItem.VALID_UNTIL_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				if (ehIndex === 0) {
					validUntilDtTm = "Current";
				}
				if (eventHistItem.DATE_RESULT.length) {
					resVal = dateFormatter.formatISO8601(eventHistItem.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				} else {
					resVal = MD_resultViewerDialog.formatNumber(eventHistItem.RESULT_VAL);
				}
				normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventHistItem.NORMALCY_CD_MEAN);
				eventHistoryHTML.push("<tr class = 'resview-hist-info ", zebraClass, firstRow, "' eventRowIndex = ", ehIndex, "><td><span class='", resultValColorClass, normalcyClass, "'><span class='res-ind'></span>", resVal, "</span></td><td>", validFromDtTm, "</td><td>", validUntilDtTm, "</td>");
			}
			eventHistoryHTML.push("</table></div></div>");
			return eventHistoryHTML.join("");
		},
		
GetNormalcyClass : function(resultNormalcy) { 
	var normalcy = "res-normal";
	var normalcyMeaning = resultNormalcy;
	if (normalcyMeaning) {
		switch (normalcyMeaning) {
			case "NORMAL":
				normalcy = "res-normal";
				break;
			case "LOW":
				normalcy = "res-low";
				break;
			case "HIGH":
				normalcy = "res-high";
				break;
			case "ABNORMAL":
				normalcy = "res-abnormal";
				break;
			case "CRITICAL":
			case "EXTREMEHIGH":
			case "PANICHIGH":
			case "EXTREMELOW":
			case "PANICLOW":
			case "VABNORMAL":
			case "POSITIVE":
				normalcy = "res-severe";
				break;
		}
	}
	return normalcy;
},
formatNumber :function (value) {
	var nf = MP_Util.GetNumericFormatter();
	return mp_formatter._isNumber(value) ? nf.format(value, "^." + MP_Util.CalculatePrecision(value)) : value;
},


		buildEventDetailSectionHTML : function (eventRBListObj) {
			var eventDetailHTML = [];
			eventDetailHTML.push("<div class='resview-detail' id='resViewDetail'>");
			eventDetailHTML.push("<div class='resview-controls' id='resViewControls'>");
			eventDetailHTML.push(MD_resultViewerDialog.buildTabSectionHTML());			
			eventDetailHTML.push("</div><div class='resview-tab-body ' id='resViewBody'>");
			eventDetailHTML.push("<div class='resview-body-container' id='resViewTabBodyId'>");
			eventDetailHTML.push(MD_resultViewerDialog.buildDetailsTabHTML(eventRBListObj));
			eventDetailHTML.push(MD_resultViewerDialog.buildActionListTabHTML(eventRBListObj));
			if (specimenFound) {
				eventDetailHTML.push(MD_resultViewerDialog.buildSpecimenTabHTML(eventRBListObj));
			}
			if (commentsFound) {
				eventDetailHTML.push(MD_resultViewerDialog.buildCommentsTabHTML(eventRBListObj));
			}
			eventDetailHTML.push("</div></div></div>");
			return eventDetailHTML.join("");
		},
		buildTabSectionHTML : function () {
			var tabHTML = [];
			tabHTML.push("<span class = 'resview-tab-bg-left resview-tab-container'></span><div  class='resview-tab-container resview-tab-active' id='resViewTab1' tabtext = '", resViewModalI18n.DETAILS, "'><span class = 'resview-tab-active-left'></span><span class = 'resview-tab-active-center'><div class='resview-tab-active-label'>", resViewModalI18n.DETAILS, "</div></span><span class = 'resview-tab-active-right'></span></div><span id = 'rvDetSepId' class='resview-tab-sep hidden'></span>");
			if (specimenFound) {
				tabHTML.push("<div  class='resview-tab-container resview-tab-inactive' id='resViewTab2' tabtext = '", resViewModalI18n.SPECIMEN, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.SPECIMEN, "</div></div><span id = 'rvSpecimenSepId' class='resview-tab-sep'></span>");
			}
			tabHTML.push("<div class='resview-tab-container resview-tab-inactive' id='resViewTab3' tabtext = '", resViewModalI18n.ACTION_LIST, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.ACTION_LIST, "</div></div><span id = 'rvActionSepId' class='resview-tab-sep'></span>");
			if (commentsFound) {
				tabHTML.push("<div  class='resview-tab-container resview-tab-inactive' id='resViewTab4' tabtext = '", resViewModalI18n.COMMENTS, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.COMMENTS, "</div></div><span id = 'rvCommentsSepId' class='resview-tab-sep'></span>");
			}
			
			return tabHTML.join("");
		},
		buildDetailsTabHTML : function (eventRBListObj) {
			var detailsTabHTML = [];
			var eventDtTm = "";
			var resVal = "";
			var normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);	
			eventDtTm = dateFormatter.formatISO8601(eventRBListObj.EVENT_END_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			if (eventRBListObj.DATE_RESULT.length) {
				resVal = dateFormatter.formatISO8601(eventRBListObj.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			} else {
				resVal = this.formatNumber(eventRBListObj.RESULT_VAL);
			}
			detailsTabHTML.push("<div class ='resview-details-info' id = 'rvDetailsInfoId'><div class = 'resview-tt'><span><h2 class='resview-resval'><span class = 'resview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span class='resview-pad ", normalcyClass, "'><span class = 'res-ind'></span>", resVal, " ", "</span><span>", eventRBListObj.RESULT_UNITS_CD_DISP ? eventRBListObj.RESULT_UNITS_CD_DISP : "", "</span></h2></span></div>");
			detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.DATE_TIME, ":</dd><dd class = 'resview-event-data'>", eventDtTm, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.NORMAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.NORMAL_LOW, "</dd></dl>");
			detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.CONTRIBUTE_SYSTEM, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.CONTRIBUTOR_SYSTEM_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.NORMAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.NORMAL_HIGH, "</dd></dl>");
			if (specimenFound) {
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.ACCESSION_NUMBER, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.ACCESSION_NBR, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.SERVICE_RESOURCE, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESOURCE_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd>");
			} else {
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'></dd><dd class = 'resview-event-data'></dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
			}
			detailsTabHTML.push("</div>");
			return detailsTabHTML.join("");
		},
		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var requestedByName = "";
			var requestedBy = null;
			var proxyName = "";
			var proxy = null;
			var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";

			actionListTabHTML.push("<div class ='resview-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'resview-table-div'><table class='resview-actionlist-table'><tr><th>", resViewModalI18n.ACTION, "</th><th>", resViewModalI18n.PERFORMED_BY, "</th><th>", resViewModalI18n.PERFORMED_DATE, "</th><th>", resViewModalI18n.ACTION_STATUS, "</th><th>", resViewModalI18n.COMMENT, "</th><th>", resViewModalI18n.PROXY_PERSONNEL, "</th><th>", resViewModalI18n.REQUESTED_BY, "</th><th>", resViewModalI18n.REQUESTED_DATE, "</th><th>", resViewModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
				actionDtTm="";
				requestDtTm="";
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				if (actionListItem.ACTION_DT_TM !== invalidDate) {
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if (actionListItem.REQUEST_DT_TM !== invalidDate) {
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);

				}
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		buildSpecimenTabHTML : function (eventRBListObj) {
			var specimenTabHTML = [];
			var specimenCollObj = null;
			var specimenCollectedDtTm = "";
			var normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);
			specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
			specimenCollectedDtTm = dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			specimenTabHTML.push("<div class ='resview-specimen-info hidden' id = 'rvSpecimenInfoId'><div class = 'resview-tt'><span><h2 class='resview-resval'><span class = 'resview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='resview-pad ", normalcyClass, "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
			specimenTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'resview-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'resview-event-data'>", specimenCollectedDtTm, "</dd></dl>");
			specimenTabHTML.push("</div>");
			return specimenTabHTML.join("");
		},
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='resview-comments-info hidden' id = 'rvCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			for (var noteIndex = 0;
				noteIndex < noteListLen;
				noteIndex++) {
				noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
				provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
				commentProviderName = (provider === null) ? "" : provider.fullName;
				commentsTabHTML.push("<div class = 'resview-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", resViewModalI18n.BY, " ", commentProviderName, " ", resViewModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
				commentsTabHTML.push("<div class = 'resview-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
			}
			return commentsTabHTML.join("");
		},
		renderResultViewer : function (response) {
			var resViewModalBodyHTML = [];
			var resViewModalObject = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
			var resViewModalId = resViewModalObject.getBodyElementId();
			dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			jsonResponse = response.getResponse();
			if (jsonResponse) {
				if (response.getStatus() === "F") {
					MP_Util.LogScriptCallError(null, this, "result_viewer_modal.js", "renderResultViewer");
					MD_resultViewerDialog.alertError(resViewModalI18n.ERROR_RETRIEVE, resViewModalI18n.ERROR_TITLE, resViewModalI18n.OK);
					return;
				}
			}
			personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);	
			specimenFound = false;
			commentsFound = false;
			if (jsonResponse.RB_LIST[0].SPECIMEN_COLL.length) {
				specimenFound = true;
			}
			if (jsonResponse.RB_LIST[0].EVENT_NOTE_LIST.length) {
				commentsFound = true;
			}
			resViewModalBodyHTML.push("<div class='resview-container'>");
			resViewModalBodyHTML.push(MD_resultViewerDialog.buildEventHistorySectionHTML());
			resViewModalBodyHTML.push(MD_resultViewerDialog.buildEventDetailSectionHTML(jsonResponse.RB_LIST[0]));
			resViewModalBodyHTML.push("</div>");
			$("#resultViewerbody").removeClass("resview-loading");
			$("#" + resViewModalId).html(resViewModalBodyHTML.join(""));
		},
		onTabChange : function (selectedTabObj) {
			var objTabActive = $(selectedTabObj).parent().find(".resview-tab-active");
			if (objTabActive.length) {
				if ($(objTabActive).attr("id") === $(selectedTabObj).attr("id")) {
					return;
				}
				$(objTabActive).empty();
				$(objTabActive).html("<div class='resview-tab-inactive-label'>" + $(objTabActive).attr("tabText") + "</div>");

				objTabActive.removeClass("resview-tab-active");
				objTabActive.addClass("resview-tab-inactive");
				$(objTabActive).next().removeClass("hidden");
				$(objTabActive).prev().removeClass("hidden");
			}
			$(selectedTabObj).removeClass("resview-tab-inactive");
			$(selectedTabObj).next().addClass("hidden");
			$(selectedTabObj).prev().addClass("hidden");
			

			$(selectedTabObj).addClass("resview-tab-active");
			$(selectedTabObj).html("<span class = 'resview-tab-active-left'></span><span class = 'resview-tab-active-center'><span class='resview-tab-active-label'>" + $(selectedTabObj).attr("tabText") + "</span></span><span class = 'resview-tab-active-right'></span>");
			$(selectedTabObj).removeClass("resview-tab-inactive");
			$(selectedTabObj).addClass("resview-tab-active");
		},
		attachListeners : function () {
			$(document).on("click", ".resview-hist-info", function () {
				var objSelRow = $(this).parent().find(".resview-hist-select");
				var objSelRowResInd = $(objSelRow).find(".res-ind").parent();
				var eventRowIndex = $(this).attr("eventRowIndex");
				var eventRBListObj = null;
				var newTabHTML = [];
				if (objSelRow.length) {
					objSelRow.removeClass("resview-hist-select");
					objSelRow.removeClass("resview-wht-text");
					$(objSelRowResInd).removeClass("resview-wht-text");
				}
				$(this).addClass("resview-hist-select");
				$(this).addClass("resview-wht-text");
				$(this).find(".res-high").addClass("resview-wht-text");
				if (objSelRow.attr("eventRowIndex") !== eventRowIndex) {
					eventRBListObj = jsonResponse.RB_LIST[eventRowIndex];
					specimenFound = false;
					commentsFound = false;
					if (eventRBListObj.SPECIMEN_COLL.length) {
						specimenFound = true;
					}
					if (eventRBListObj.EVENT_NOTE_LIST.length) {
						commentsFound = true;
					}
					$("#resViewControls").html(MD_resultViewerDialog.buildTabSectionHTML());
					newTabHTML.push(MD_resultViewerDialog.buildDetailsTabHTML(eventRBListObj));
					newTabHTML.push(MD_resultViewerDialog.buildActionListTabHTML(eventRBListObj));
					if (specimenFound) {
						newTabHTML.push(MD_resultViewerDialog.buildSpecimenTabHTML(eventRBListObj));
					}
					if (commentsFound) {
						newTabHTML.push(MD_resultViewerDialog.buildCommentsTabHTML(eventRBListObj));
					}
					$("#resViewTabBodyId").html(newTabHTML.join(""));
					MD_resultViewerDialog.onTabChange($("#resViewTab1"));
					
				$("#rvDetailsInfoId").removeClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				}
			});
			$(document).on("click", "#resViewTab1", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").removeClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
			$(document).on("click", "#resViewTab2", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").removeClass("hidden");
			});
			$(document).on("click", "#resViewTab3", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").removeClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
			$(document).on("click", "#resViewTab4", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").removeClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
		}
	};
}
();
var MD_trendingGraphDialog = function () {
	var trendGraphModalI18n = i18n.discernabu.trend_graph_modal;
	var iFrameTrendGraphObj = null;
	return {
		initTrendGraph : function (params) {
			var trendGraphModalObj = MP_ModalDialog.retrieveModalDialogObject("trendGraphModal");
			if (!trendGraphModalObj) {
				trendGraphModalObj = new ModalDialog("trendGraphModal");
				var trendGraphCloseBtn = new ModalButton("trendGraphCloseBtn");
				trendGraphCloseBtn.setText(trendGraphModalI18n.CLOSE).setFocusInd(true).setOnClickFunction(function () {
					MD_trendingGraphDialog.removeTrendGraphIframeObject();
				}).setCloseOnClick(true);
				trendGraphModalObj.setTopMarginPercentage(10).setRightMarginPercentage(9).setBottomMarginPercentage(15).setLeftMarginPercentage(9).setIsBodySizeFixed(false);
				trendGraphModalObj.setHeaderTitle("<span>" + trendGraphModalI18n.RESULT_TREND + "</span>").setHeaderCloseFunction(MD_trendingGraphDialog.removeTrendGraphIframeObject);
			}
			trendGraphModalObj.setBodyDataFunction(function (trendGraphObj) {
				var sendAr = [params];
				trendGraphObj.setBodyHTML(MD_trendingGraphDialog.loadWithCBParameters("mp_retrieve_graph_results", sendAr, MD_trendingGraphDialog.buildGraphHTML));
			});
			trendGraphModalObj.addFooterButton(trendGraphCloseBtn);
			MP_ModalDialog.addModalDialogObject(trendGraphModalObj);
			MP_ModalDialog.showModalDialog("trendGraphModal");
			$("#trendGraphModalbody").addClass("trend-graph-loading");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			request.setRequiresRawData(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		buildGraphHTML : function (response) {
			var responseHTML = response.getResponse();
			var iFrameHeight = "100%";
			var iFrameWidth = "98%";
			var graphModalContent = null;
			var docObject = null;
			iFrameTrendGraphObj = document.createElement("iframe");
			iFrameTrendGraphObj.setAttribute("id", "iframeGraph");
			iFrameTrendGraphObj.setAttribute("height", iFrameHeight);
			iFrameTrendGraphObj.setAttribute("width", iFrameWidth);
			iFrameTrendGraphObj.setAttribute("frameborder", 0);
			$("#trendGraphModalbody").html(iFrameTrendGraphObj);
			graphModalContent = iFrameTrendGraphObj.contentWindow;
			docObject = graphModalContent ? graphModalContent.document : null;
			if (docObject) {
				docObject.write(responseHTML);
				docObject.close();
			}
			$("#trendGraphModalbody").removeClass("trend-graph-loading");
			setTimeout(function () {
				$("#iframeGraph").contents().find("#printGraph").remove();
				document.getElementById('iframeGraph').height  = 
					document.getElementById('iframeGraph').contentWindow.document.body.scrollHeight+80+"px";
					document.getElementById("iframeGraph").width = 
					document.getElementById("iframeGraph").contentWindow.document.body.scrollWidth+100+"px";
			    $("#trendGraphModalbody").removeClass("trend-graph-loading");
			}, 1100);
		},
		removeTrendGraphIframeObject : function () {
			$(iFrameTrendGraphObj).remove();
		}
	};
}
();
var MP_VisitDetailDialog = function () {
	var visitDetailModalI18n = i18n.discernabu.visit_detail_modal;
	var jsonResponse = null;
	var VisitsDetailTabsIndex = {
		SUMMARY : 0,
		INSURANCE : 1,
		GUARANTOR : 2
	};
	var currentPage = VisitsDetailTabsIndex.SUMMARY;
	var tabNames = [];
	var secHPFlag = false;
	var terHPFlag = false;
	var secGuaFlag = false;
	var terGuaFlag = false;
	return {
		initVisitViewer : function (patient_Id, encntr_Id, provider_Id, pos_cd, visitDate) {			
			var visitLoading = [];
			var closebtn = visitDetailModalI18n.CLOSE;
			patient_Id = patient_Id + ".0";
			encntr_Id = encntr_Id + ".0";
			provider_Id = provider_Id + ".0";
			pos_cd = pos_cd + ".0";
			var encntrInd = 0;
			var visitModalDialog = MP_ModalDialog.retrieveModalDialogObject("visitModalDialog");
			if (!visitModalDialog) {
				visitModalDialog = new ModalDialog("visitModalDialog");
				visitModalDialog.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(5).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
				visitModalDialog.setHeaderCloseFunction();
				visitModalDialog.setHeaderTitle("<span class='visitswindow-title'>" + visitDetailModalI18n.VISIT_DETAIL + "</span>");
				var visitViewerCloseBtn = new ModalButton("visitViewerCloseBtn");
				visitViewerCloseBtn.setText(closebtn);
				visitViewerCloseBtn.setFocusInd(true);
				visitModalDialog.addFooterButton(visitViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(visitModalDialog);
			}			
			visitModalDialog.setBodyDataFunction(function (visitViewDlg) {
				var cclParams = [];
				cclParams.push("^MINE^", patient_Id, provider_Id, pos_cd, encntrInd, "^" + visitDate + "^");
				MP_VisitDetailDialog.loadWithCBParameters("mp_get_visit_detail_data", cclParams, MP_VisitDetailDialog.renderVisitDetail);
			});
			MP_ModalDialog.updateModalDialogObject(visitModalDialog);
			MP_ModalDialog.showModalDialog(visitModalDialog.getId());
			visitLoading.push("<div class='visits-body-loading'><span class='visits-loading'></span></div>");
			visitModalDialog.setBodyHTML(visitLoading.join(""));
			$("#visitModalDialogbody").css("overflow", "hidden");			
		},
		
		loadWithCBParameters : function (programName, cclParams, callBack) {
			try {
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "loadWithCBParameters");
			}
		},
		renderVisitDetail : function (response) {
			try {
				var visitDetailModalBodyHTML = [];
				var visitDetailModalObject = MP_ModalDialog.retrieveModalDialogObject("visitModalDialog");
				var visitDetailModalId = visitDetailModalObject.getBodyElementId();
				var summaryTab = visitDetailModalI18n.SUMMARY;
				var insuranceTab = visitDetailModalI18n.INSURANCE;
				var guarantorTab = visitDetailModalI18n.GUARANTOR;
				jsonResponse = response.getResponse();
				if (jsonResponse) {
					if (response.getStatus() === "F") {
						MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "renderVisitDetail");
						return;
					}
				}
				tabNames[VisitsDetailTabsIndex.SUMMARY] = summaryTab;
				tabNames[VisitsDetailTabsIndex.INSURANCE] = insuranceTab;
				tabNames[VisitsDetailTabsIndex.GUARANTOR] = guarantorTab;
				visitDetailModalBodyHTML.push(MP_VisitDetailDialog.switchTab(currentPage));
				visitDetailModalObject.setBodyHTML(visitDetailModalBodyHTML.join(""));
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				$(allTabs).on("click", function () {
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;
					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");
					$("#curTabId").show();
					var visitModalDialogBodyObj = $("#visitModalDialogbody");
					if (curTabId === "tabHeader_0") {
						visitModalDialogBodyObj.find(".visit-summary-tab-container").show();
						visitModalDialogBodyObj.find(".visit-insurance-tab-container").hide();
						visitModalDialogBodyObj.find(".visit-guarantor-tab-container").hide();
					} else {
						if (curTabId === "tabHeader_1") {
							if (secHPFlag === true) {
								visitModalDialogBodyObj.find("#secondaryIns").removeClass("visit-disp-none");
							}
							if (terHPFlag === true) {
								visitModalDialogBodyObj.find("#tertiaryIns").removeClass("visit-disp-none");
							}
							visitModalDialogBodyObj.find(".visit-insurance-tab-container").show();
							visitModalDialogBodyObj.find(".visit-summary-tab-container").hide();
							visitModalDialogBodyObj.find(".visit-guarantor-tab-container").hide();
						} else {
							if (curTabId === "tabHeader_2") {
								if (secGuaFlag === true) {
									visitModalDialogBodyObj.find("#secondaryGua").removeClass("visit-disp-none");
								}
								if (terGuaFlag === true) {
									visitModalDialogBodyObj.find("#tertiaryGua").removeClass("visit-disp-none");
								}
								visitModalDialogBodyObj.find(".visit-guarantor-tab-container").show();
								visitModalDialogBodyObj.find(".visit-summary-tab-container").hide();
								visitModalDialogBodyObj.find(".visit-insurance-tab-container").hide();
							}
						}
					}
				});
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "renderVisitDetail");
			}
		},
		switchTab : function (tabIndex) {
			try {
				var emptyData = "--";
				var encntrFin = jsonResponse.FIN;
				var encntrlocation = emptyData;
				var encntrOrg = emptyData;
				var encntrRegDt = emptyData;
				var encntrDischDt = emptyData;
				var encntrMedSer = emptyData;
				var admitProvider = emptyData;
				var attendProvider = emptyData;
				var primaryHealthPlan = emptyData;
				var primaryPolicy = emptyData;
				var primaryGuaName = emptyData;
				var primaryMemberNum = emptyData;
				var primaryType = emptyData;
				var primaryGroupNum = emptyData;
				var primaryFinClass = emptyData;
				var secHealthPlan = "";
				var secPolicy = "";
				var secGuaName = "";
				var secMemberNum = "";
				var secType = "";
				var secGroupNum = "";
				var secFinClass = "";
				var terHealthPlan = "";
				var terPolicy = "";
				var terGuaName = "";
				var terMemberNum = "";
				var terType = "";
				var terGroupNum = "";
				var terFinClass = "";
				var priPhonetest = emptyData;
				var priRltnspToPat = emptyData;

				var secPhonetest = "";
				var secRltnspToPat = "";

				var terPhonetest = "";
				var terRltnspToPat = "";
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
				var encntrHPLen = jsonResponse.HP_LIST.length;
				var encntrGuaLen = jsonResponse.GUARANTOR.length;
				var encounterSummary = jsonResponse.E_LIST[0];
				var encounterPriHPList = jsonResponse.HP_LIST[0];
				var encounterSecHPList = jsonResponse.HP_LIST[1];
				var encounterTerHPList = jsonResponse.HP_LIST[2];
				var encounterPriGuaList = jsonResponse.GUARANTOR[0];
				var encounterSecGuaList = jsonResponse.GUARANTOR[1];
				var encounterTerGuaList = jsonResponse.GUARANTOR[2];
				var addressListLen = "";
				var phoneListLen = "";
				var priAddHtml = [];
				var secAddHtml = [];
				var terAddHtml = [];
				var priPhoneHtml = [];
				var secPhoneHtml = [];
				var terPhoneHtml = [];
				secHPFlag = false;
				terHPFlag = false;
				secGuaFlag = false;
				terGuaFlag = false;
				priAddHtml = emptyData;
				priPhoneHtml = emptyData;
				if (jsonResponse.E_LIST.length > 0) {
					encntrRegDt = (encounterSummary.REG_DATE !== "") ? df.formatISO8601(encounterSummary.REG_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR) : emptyData;
					encntrDischDt = (encounterSummary.DISCH_DATE !== "") ? df.formatISO8601(encounterSummary.DISCH_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR) : emptyData;
					encntrlocation = (encounterSummary.LOCATION !== "") ? encounterSummary.LOCATION : emptyData;
					encntrOrg = (encounterSummary.ORG_NAME !== "") ? encounterSummary.ORG_NAME : emptyData;
					encntrMedSer = (encounterSummary.MED_SERVICE !== "") ? encounterSummary.MED_SERVICE : emptyData;
					admitProvider = (encounterSummary.ADMITTING_PROVIDER !== "") ? encounterSummary.ADMITTING_PROVIDER : emptyData;
					attendProvider = (encounterSummary.ATTENDING_PROVIDER !== "") ? encounterSummary.ATTENDING_PROVIDER : emptyData;
				}
				if (encntrHPLen > 0) {
					for (var h = 0;
						h < encntrHPLen;
						h++) {
						if (h === 0) {
							primaryHealthPlan = (encounterPriHPList.NAME !== "") ? encounterPriHPList.NAME : emptyData;
							primaryPolicy = (encounterPriHPList.POLICY_NUM !== "") ? encounterPriHPList.POLICY_NUM : emptyData;
							primaryMemberNum = (encounterPriHPList.MEMBER_NUM !== "") ? encounterPriHPList.MEMBER_NUM : emptyData;
							primaryType = (encounterPriHPList.TYPE !== "") ? encounterPriHPList.TYPE : emptyData;
							primaryGroupNum = (encounterPriHPList.GROUP_NUM !== "") ? encounterPriHPList.GROUP_NUM : emptyData;
							primaryFinClass = (encounterPriHPList.FIN_CLASS !== "") ? encounterPriHPList.FIN_CLASS : emptyData;
						}
						if (h === 1) {
							secHealthPlan = (encounterSecHPList.NAME !== "") ? encounterSecHPList.NAME : emptyData;
							secPolicy = (encounterSecHPList.POLICY_NUM !== "") ? encounterSecHPList.POLICY_NUM : emptyData;
							secMemberNum = (encounterSecHPList.MEMBER_NUM !== "") ? encounterSecHPList.MEMBER_NUM : emptyData;
							secType = (encounterSecHPList.TYPE !== "") ? encounterSecHPList.TYPE : emptyData;
							secGroupNum = (encounterSecHPList.GROUP_NUM !== "") ? encounterSecHPList.GROUP_NUM : emptyData;
							secFinClass = (encounterSecHPList.FIN_CLASS !== "") ? encounterSecHPList.FIN_CLASS : emptyData;
							secHPFlag = true;
						}
						if (h === 2) {
							terHealthPlan = (encounterTerHPList.NAME !== "") ? encounterTerHPList.NAME : emptyData;
							terPolicy = (encounterTerHPList.POLICY_NUM !== "") ? encounterTerHPList.POLICY_NUM : emptyData;
							terMemberNum = (encounterTerHPList.MEMBER_NUM !== "") ? encounterTerHPList.MEMBER_NUM : emptyData;
							terType = (encounterTerHPList.TYPE !== "") ? encounterTerHPList.TYPE : emptyData;
							terGroupNum = (encounterTerHPList.GROUP_NUM !== "") ? encounterTerHPList.GROUP_NUM : emptyData;
							terFinClass = (encounterTerHPList.FIN_CLASS !== "") ? encounterTerHPList.FIN_CLASS : emptyData;
							terHPFlag = true;
						}
					}
				}
				if (encntrGuaLen > 0) {
					for (var g = 0;
						g < encntrGuaLen;
						g++) {
						if (g === 0) {
							primaryGuaName = (encounterPriGuaList.NAME !== "") ? encounterPriGuaList.NAME : emptyData;
							priRltnspToPat = (encounterPriGuaList.TYPE !== "") ? encounterPriGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[g].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[g].PHONE_LIST.length;
							var priAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							priAddHtml = "";
							if (priAddress !== "") {
								for (var ap = 0;
									ap < addressListLen;
									ap++) {
									priAddHtml += "<span>" + priAddress[ap].LINE1 + "</span></br><span>" + priAddress[ap].LINE2 + "</span></br>";
								}
							} else {
								priAddHtml = emptyData;
							}
							var priPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							priPhoneHtml = "";
							if (priPhone !== "") {
								for (var pp = 0;
									pp < phoneListLen;
									pp++) {
									priPhoneHtml += "<span>" + priPhone[pp].NUMBER + "</span></br>";
								}
							} else {
								priPhoneHtml = emptyData;
							}
						}
						if (g === 1) {
							secGuaFlag = true;
							secGuaName = (encounterSecGuaList.NAME !== "") ? encounterSecGuaList.NAME : emptyData;
							secRltnspToPat = (encounterSecGuaList.TYPE !== "") ? encounterSecGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[1].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[1].PHONE_LIST.length;
							var secAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							secAddHtml = "";
							if (secAddress !== "") {
								for (var as = 0;
									as < addressListLen;
									as++) {
									secAddHtml += "<span class='visit-gua-address'>" + secAddress[as].LINE1 + "</span></br><span class='visit-gua-address'>" + secAddress[as].LINE2 + "</span></br>";
								}
							} else {
								secAddHtml = emptyData;
							}
							var secPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							secPhoneHtml = "";
							if (secPhone !== "") {
								for (var ps = 0;
									ps < phoneListLen;
									ps++) {
									secPhoneHtml += "<span>" + secPhone[ps].NUMBER + "</span></br>";
								}
							} else {
								secPhoneHtml = emptyData;
							}
						}
						if (g === 2) {
							terGuaFlag = true;
							terGuaName = (encounterTerGuaList.NAME !== "") ? encounterTerGuaList.NAME : emptyData;
							terRltnspToPat = (encounterTerGuaList.TYPE !== "") ? encounterTerGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[2].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[2].PHONE_LIST.length;
							var terAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							terAddHtml = "";
							if (terAddress !== "") {
								for (var at = 0;
									at < addressListLen;
									at++) {
									terAddHtml += "<span>" + terAddress[at].LINE1 + "</span></br><span>" + terAddress[at].LINE2 + "</span></br>";
								}
							} else {
								terAddHtml = emptyData;
							}
							var terPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							terPhoneHtml = "";
							if (terPhone !== "") {
								for (var pt = 0;
									pt < phoneListLen;
									pt++) {
									terPhoneHtml += "<span>" + terPhone[pt].NUMBER + "</span></br>";
								}
							} else {
								terPhoneHtml = emptyData;
							}
						}
					}
				}
				var htmlArray = ['<div class="reachview-tab-container" id="tabContainer"><div class="reachview-tabs"><ul>'];
				var numTabs = tabNames.length;
				if (typeof tabIndex === "number") {
					currentPage = tabIndex;
				} else {
					tabIndex = currentPage;
				}
				var i;
				var iTabName,
				iCount;
				for (i = 0;
					i < numTabs;
					i++) {
					iTabName = tabNames[i];
					htmlArray.push('<li id="tabHeader_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
				}
				htmlArray.push('</ul></div><hr /><div class="visit-tabs-content">');
				var visitDiagLen = jsonResponse.DIAG.length;
				var visitDiags = (visitDiagLen > 0) ? jsonResponse.DIAG : "";
				var visitDiagHtml = "";
				if (visitDiags !== "") {
					for (var d = 0;
						d < visitDiagLen;
						d++) {
						visitDiagHtml += "<span>" + visitDiags[d].TEXT + "&nbsp</span><span class='visit-diag-code'>(" + visitDiags[d].CODE + ")</span><br>";
					}
				} else {
					visitDiagHtml = emptyData;
				}
				htmlArray.push("<div class='tabs'><ul><li id='tab1'></li><li id='tab2'></li><li id='tab3'></li></ul></div><div class='visit-summary-tab-container' id='tab-sec-1'><dl class='visit-smry-data'><dt class='visit-res-type'></dt><dd class='visit-smry-value'></dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.FIN + "&nbsp</dt><dd class='visit-smry-value'>" + encntrFin + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.REG_DATE + "&nbsp</dt><dd class='visit-smry-value'>" + encntrRegDt + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.DISCH_DATE + "&nbsp</dt><dd class='visit-smry-value'>" + encntrDischDt + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.LOCATION + "&nbsp</dt><dd class='visit-smry-value'>" + encntrlocation + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ORG_NAME + "&nbsp</dt><dd class='visit-smry-value'>" + encntrOrg + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.MED_SER + "&nbsp</dt><dd class='visit-smry-value'>" + encntrMedSer + "</dd></dl><dl class='visit-smry-separator'></dl><dl class='visit-smry-empty'></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ADMIT_PROVIDER + "&nbsp</dt><dd class='visit-smry-value'>" + admitProvider + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ATTEND_PROVIDER + "&nbsp</dt><dd class='visit-smry-value'>" + attendProvider + "</dd></dl><dl class='visit-smry-separator'></dl><dl class='visit-smry-empty'></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.VISIT_DIAG + "&nbsp</dt><dd class='visit-smry-value'>" + visitDiagHtml + "</dd></dl></div><div class='visit-insurance-tab-container' id='tab-sec-2'><div class='visit-hp-primary' id='primaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.PRIMARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryFinClass + "</dd></dl></div><div class='visit-disp-none' id='secondaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.SECONDARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secFinClass + "</dd></dl></div><div class='visit-disp-none' id='tertiaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.TERTIARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terFinClass + "</dd></dl></div></div><div class='visit-guarantor-tab-container' id='tab-sec-3'><div class='visit-gr-primary' id='primaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.PRIMARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + primaryGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + priAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + priPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + priRltnspToPat + "</dd></dl></div><div class='visit-disp-none' id='secondaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.SECONDARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + secRltnspToPat + "</dd></dl></div><div class='visit-disp-none' id='tertiaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.TERTIARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + terRltnspToPat + "</dd></dl></div></div>");
				htmlArray.push("</div></div>");
				var hxHTML = htmlArray.join("");
				return hxHTML;
			} catch (err) {
				MP_Util.LogJSError(err, this, "visit_detail_modal.js", "switchTab");
			}
		}
	};
}
();
(function($) {
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	var mockCounter = 0;

	/**
	 * Selector control for generating a selector based on the provided options
	 * @param {DOM element} element The DOM element where the selector will be rendered
	 * @param {Array} options Array of objects to show in the selector
	 */
	Selector = function(element, options){
		this.setControlId(MPageControls.Control.idCounter);
	    MPageControls.Control.idCounter++;
		this.setElement(element);
		this.setOnSelect(function(){});
		this.setOptions(options);
		this.setDefaultValue(null);
		this.setDefaultSelected(null);
	};

	inherits(Selector, MPageControls.Control);

	attribute(Selector, "Options");
	attribute(Selector, "Data");
	attribute(Selector, "DisplayField");
	attribute(Selector, "DefaultDisplay");
	attribute(Selector, "ValueField");
	attribute(Selector, "OnSelect");
	attribute(Selector, "DefaultValue");
	attribute(Selector, "DefaultSelected");
	attribute(Selector, "Namespace");
	attribute(Selector, "SelectElement");

	/**
	 * Generates a Data object to map values to objects
	 */
	Selector.prototype.initData = function(){
		var data = {};
		var options = this.getOptions();
		var optionCnt = options.length;
		var valueField = this.getValueField();
		var option;
		var value;
		for (var i = 0; i < optionCnt; i++){
			option = options[i];
			value = option[valueField];
			data[value] = option;
		};
		this.setData(data);
	};

	/**
	 * Generates a function that can create a template given a list of option objects
	 * @return {Function} Function taking a list of options and outputing a Template
	 * Template will create selector if multiple items are present, or a div styled as a selector
	 * when only one result is present
	 */
	Selector.prototype.generateSelectorTemplateFunction = function(){
		//generate arguments to use to create the select tag
		var namespace = this.getControlId();
		var displayField = this.getDisplayField();
		var valueField = this.getValueField();
		var defaultDisplay = this.getDefaultDisplay() || "";
		var div = TemplateEngine.tag("div");
		var select = TemplateEngine.tag('select');
		var option = TemplateEngine.tag('option');
		return function(optionList){
			var args = [];
			args.push({"id": 'control_' + namespace + '_select'});
			var optionCnt = optionList.length;
			var optionItem;
			var optionDisplay;
			var optionValue;
			var optionDiv;
			if (optionCnt === 1){
				optionItem = optionList[0];
				optionDisplay = optionItem[displayField];
				optionValue = optionItem[valueField];
				optionDiv = div({
					"class": 'single-item-dropdown'
				}, optionDisplay || defaultDisplay);
				return optionDiv;			
			}
			else{
				for (var i = 0; i < optionCnt; i++){
					//generate an option tag for each option
					optionItem = optionList[i];
					optionDisplay = optionItem[displayField];
					optionValue = optionItem[valueField];
					optionDiv = option({
						"value": optionValue
					}, optionDisplay || defaultDisplay);
					//add the created option tag to the arguments
					args.push(optionDiv);
				}
				//Generate a selector html using the passed arguments
				var selectorTemplate = select.apply(this, args);
				return selectorTemplate;
			}
		}
	};

	/**
	 * Renders the selector within its element
	 * @return {Jquery Object} Returns jQuery object of the rendered HTML
	 */
	Selector.prototype.render = function(){
		var element = this.getElement();
		var selectionList = this.getOptions();
		var selectorTemplate = new TemplateEngine.Template(this.generateSelectorTemplateFunction());
		var selectorElement = $(selectorTemplate.render(selectionList));
		element.html(selectorElement);
		return selectorElement;
	};

	/**
	 * Renders the Selector and attaches a selection event
	 */
	Selector.prototype.init = function(){
		var self = this;
		this.initData();
		//render selector
		var selector = this.render();
		var onSelect = this.getOnSelect();
		var defaultValue;
		var initialSelectedObj;
		this.setSelectElement(selector);
		//attach events on selection
		selector.on('change', function(){
			var selectedValue = $(this).val();
			var selectedObject = self.getData()[selectedValue];
			if (onSelect && selectedObject){
				onSelect(selectedObject);
			}
		});
		//Select the default option
		defaultValue = this.getDefaultValue();
		if (defaultValue){
			this.selectByValue(defaultValue);
		}
		//Perform onSelect action on default selected option
		if(onSelect){
			initialSelectedObj = self.getData()[selector.val()];
			onSelect(initialSelectedObj);
		};
	};

	/**
	 * Select the option within the selector with the passed value
	 * @param  {String} value The value of the option to select
	 */
	Selector.prototype.selectByValue = function(value){
		var selector = this.getSelectElement();
		$(selector).val(value);
	};


})(jQuery);
/**
 * The StructureOrganizerBuilder class.
 * @constructor
 * @author Will Reynolds
 * @description This class is used to help construct StructureOrganizer objects as the process is very complex. It
 * benefits by separating the construction logic from the StructureOrganizer object itself.
 */
function StructureOrganizerBuilder() {
    this.m_structureOrganizer = null;                 //The StructureOrganizer object being constructed.
    this.m_nodeCount = 0;                             //The number of nodes that belong to the StructureOrganizer object.
    this.m_namespace = "";                            //A DOM namespace for the StructureOrganizer object.
}

/**
 * Get the namespace used when constructing the StructureOrganizer object.
 * @return {string} the namespace for the StructureOrganizer objects being created.
 */
StructureOrganizerBuilder.prototype.getNamespace = function() {
    return this.m_namespace;
};

/**
 * Sets the namespace used when constructing the StructureOrganizer object. This namespace must be unique as it
 * will provide the objects with a unique DOM id.
 * @param namespace the namespace to be used when constructing the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.setNamespace = function(namespace) {
	if(typeof namespace !== "string") {
		throw new Error("Attempted to call StructureOrganizerBuilder.prototype.setNamespace with invalid parameter.");
	}
    this.m_namespace = namespace;
	return this;
};

/**
 * Gets the node count for the StructureOrganizer object.
 * @return {number} the number of nodes in the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.getNodeCount = function(){
    return this.m_nodeCount;
};

/**
 * Sets the node count for the StructureOrganizer object.
 * @param nodeCount the number of nodes belonging to the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.setNodeCount = function(nodeCount) {
    if(typeof nodeCount !== "number") {
        throw new Error("Attempted to call StructureOrganizerBuilder.prototype.setNodeCount with invalid parameter.");
    }
    this.m_nodeCount = nodeCount;
	return this;
};

/**
 * Gets the StructureOrganizer object that has been constructed. Note that this method must be called after
 * the construct method has been called.
 * @return {StructureOrganizer} the StructureOrganizer object that was built.
 */
StructureOrganizerBuilder.prototype.getStructureOrganizer = function () {
    return this.m_structureOrganizer;
};

/**
 * Starts a new instance of a StructureOrganizer object. This method must be called before beginning construction
 * of a StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.startNewStructureOrganizer = function () {
    this.m_structureOrganizer = new StructureOrganizer();
    this.m_structureOrganizer.setNamespace(this.getNamespace());
    this.m_structureOrganizer.setId(""+this.m_nodeCount++);
};

/**
 * Interface method for building the navigator object.
 */
StructureOrganizerBuilder.prototype.buildNavigator = function() {
	throw new Error("Attempted to call StructureOrganizerBuilder.prototype.buildNavigator. This function must be implemented by a sub-class");
};

/**
 * The JSONStructureOrganizerBuilder class.
 * @constructor
 * @description This class extends the StructureOrganizerBuilder class. This class specifically uses JSON to create
 * the StructureOrganizer system.
 */
function JSONStructureOrganizerBuilder() {
    this.m_structureJSON = null;                      //The JSON being used to create the StructureOrganizer object.
}
JSONStructureOrganizerBuilder.prototype = new StructureOrganizerBuilder();
JSONStructureOrganizerBuilder.prototype.constructor = StructureOrganizerBuilder;

/**
 * Gets the JSON being used to construct the StructureOrganizer object.
 * @return {Object} the JSON being used to construct the StructureOrganizer object.
 */
JSONStructureOrganizerBuilder.prototype.getStructureJSON = function () {
    return this.m_structureJSON;
};

/**
 * Sets the JSON being used to construct the StructureOrganizer object.
 * @param structureJSON the JSON being used to construct the StructureOrganizer object.
 */
JSONStructureOrganizerBuilder.prototype.setStructureJSON = function (structureJSON) {
    this.m_structureJSON = structureJSON;
	return this;
};

/**
 * Constructs a structured documentation tree data structure based on the JSON that was retrieved by the
 * dynamic documentation services. It first constructs a root (SECTION -> StructureOrganizer) node, then parses
 * through the JSON, building the necessary objects and adding them to the tree.
 * @returns {StructureOrganizer} The root structured documentation node.
 */
JSONStructureOrganizerBuilder.prototype.buildStructureTree = function() {
    this.m_nodeCount = 0;
    var structureJSON = this.m_structureJSON;
    var root = new StructureOrganizer();
    this.m_structureOrganizer = root;
    root.setTemplateRelations(structureJSON.template_rltns);
    root.setReferenceSectionId(structureJSON.dd_sref_section_id);
    root.setNamespace(this.getNamespace());
    root.setId(""+this.m_nodeCount++);
    root.setOrganizer(root);
    this.traverse(structureJSON, root);
    this.handleMultiSectionStructure();
    //Only build the navigator for the root if it is not a multi-section tree.
    if(!root.isMultiSection()) {
        root.setNavigator(this.buildNavigatorForSection(root));
    }
    return root;
};

/**
 * Helper function that handles the possibility of a structure tree containing multiple sections (subsections). When
 * this occurs, a flag is set indicating that the root section is a multi-section tree. Additionally, a navigator
 * is built for each sub-section. The first subsection is set as the active section of the root.
 */
JSONStructureOrganizerBuilder.prototype.handleMultiSectionStructure = function() {
    var root = this.m_structureOrganizer;
    var children = root.getChildren();
    var childrenCount = children.length;
    var child = null;
    for(var i = 0; i < childrenCount; i++) {
        child = children[i];
        if(StructureOrganizer.prototype.isPrototypeOf(child)) {
            //You have multiple sections
            root.setIsMultiSection(true);
            child.setNavigator(this.buildNavigatorForSection(child));
            //Keep track of the active section (it starts as the first section).
            if(!root.m_activeSection) {
                root.setActiveSection(child);
            }
        }
    }
};

/**
 * Constructs a structured documentation navigator for the provided section (StructureOrganizer) node.
 * @param {StructureOrganizer} section - The section for which a navigator object will be constructed.
 * @returns {Navigator} The navigator that was constructed for the provided section.
 */
JSONStructureOrganizerBuilder.prototype.buildNavigatorForSection = function(section) {
    var navigator = new Navigator();
    navigator.setId(this.getNamespace() + ":structureNavigator:" + section.getId());
    var groups = section.getChildren();
    var group = null;
    var groupCount = groups.length;
    var namespace = this.m_namespace;
    for(var i = 0; i < groupCount; i++) {
        group = groups[i];
        var navigation = new StructureNavigation();
        navigation.setContainerId(namespace + ":organizer:CONTENT:" + section.getId());
        navigation.setAnchorId(namespace + ":group:ROOT:" + group.getId());
        navigation.setLabel(group.getTitle().replace(":", ""));
        navigation.setId(namespace + ":structureNavigation:" + group.getId());
        navigation.setNode(group);
        navigator.addNavigation(navigation);
    }
    return navigator;
};

/**
 * Builds the navigator object that represents the navigation section of the structured documentation view.
 * 
 * @returns {Navigator} navigator object that represents the navigation section
 */
JSONStructureOrganizerBuilder.prototype.buildNavigator = function() {
	var navigator = new Navigator();
	navigator.setId(this.getNamespace()+":structureNavigator");
	var groups = this.m_structureOrganizer.getChildren();
	var group = null;
	var groupCount = groups.length;
	for(var i = 0; i < groupCount; i++) {
		group = groups[i];
		var navigation = new StructureNavigation();
		navigation.setContainerId(this.getNamespace() + ":organizer:CONTENT:" + this.m_structureOrganizer.getId());
		navigation.setAnchorId(this.getNamespace() + ":group:ROOT:" + group.getId());
		navigation.setLabel(group.getTitle().replace(":", ""));
		navigation.setId(this.getNamespace()+":structureNavigation:"+group.getId());
		navigator.addNavigation(navigation);
	}
	return navigator;
};



/**
 * This is a recursive method that traverses the structure JSON, creating the associated JavaScript objects and
 * creating the necessary tree structure.
 * @param node the JSON node we are processing.
 * @param owner The parent JavaScript object is passed down a level of recursion so the new nodes can be correctly
 * added to their corresponding parent.
 */
JSONStructureOrganizerBuilder.prototype.traverse = function (node, owner) {
    var child;
    //We don't care about non-object types, so skip them.
    if (!(node instanceof Object)) {
        return;
    }
    //Go through the child JSON nodes
    for (child in node) {
        //If this is a valid node.
        if (node.hasOwnProperty(child)) {
            //Skip any non-object JSON nodes.
            if (!(node[child] instanceof  Object)) {
                continue;
            }
            //If we found an array, go through each item, processing it accordingly
            if (Array.prototype.isPrototypeOf(node[child])) {
                var childArr = node[child];
                for (var i = 0; i < childArr.length; i++) {
                    //Create a node based on the JSON
                    var structureNode = this.buildNode(child, childArr[i], owner);
                    
                    	// Check if the child node has items to expand.
					if (child === "attribute_menu_items" && (childArr[i].ui_type === "EXPAND" || childArr[i].ui_type === "TABLE")) {
						// Extract the matching children.
						this.extractMatchingChildren(childArr, i);
					}
                    //Go a level deeper, using the newly created structureNode as the new owner.
                    this.traverse(childArr[i], structureNode);
                }
            } else {
                //If we didn't find an array, just go down a level deeper, passing through the owner.
                this.traverse(node[child], owner);
            }
        }
    }
};

/**
 * This function extracts the children by CHILD_LABELID and add it to the node which has the same LABELID.
 * @param attrMenuItems - parent of the node which contains the attribute menu items
 * @param index - current node's index  in attrMenuItems.
 */
JSONStructureOrganizerBuilder.prototype.extractMatchingChildren = function(attrMenuItems, index) {
    var childIndex = 0;
    var node = attrMenuItems[index];
    var totalItems = attrMenuItems.length;
    // Iterate through the attribute items. Start validating from the next node from current node.
    for (var i = index + 1; i < totalItems; i++) {
        // Check if the node has children with same labelId and group all child nodes together.
        var attrMenuItem = attrMenuItems[i];
        if (node.label_id && attrMenuItem.child_label_id && (node.label_id === attrMenuItem.child_label_id)) {
            
            // The child node may have children, so recursively validate and group them.
            if(attrMenuItem.label_id){
                totalItems = this.extractMatchingChildren(attrMenuItems, i);
            }

            // The node has children, so initialize "attribute_menu_items".
            if ( typeof node.attribute_menu_items === "undefined") {
                node.attribute_menu_items = [];
            }
            //Add matched children into "attribute_menu_items".
            node.attribute_menu_items[childIndex++] = attrMenuItem;
            //Remove matched children from the attrMenuItems
            attrMenuItems.splice(i, 1);
            totalItems--;
            i--;
        }
    }
    return totalItems;
}; 

/**
 * A big nasty builder method that creates JavaScript structure objects based on their node type.
 * @param nodeType the type of node.
 * @param nodeJSON the corresponding node JSON.
 * @param owner the parent of this new StructureNode object.
 * @return {StructureNode} the newly created StructureNode.
 */
JSONStructureOrganizerBuilder.prototype.buildNode = function(nodeType, nodeJSON, owner) {
    var node = null;
    if(nodeType === "subsections") {
        node = new StructureOrganizer();
        node.setReferenceSectionId(nodeJSON.dd_sref_section_id);
        node.setTemplateRelations(nodeJSON.template_rltns);
    } else if(nodeType === "groupbys") {
        node = new StructureGroup();
    } else if(nodeType === "subgroupbys") {
        node = new StructureSubGroup();
    } else if(nodeType === "items") {
        node = new StructureItemGroup();
    } else if(nodeType === "attributes") {
        node = this.buildStructureTermGroupNode(nodeJSON);
    } else if(nodeType === "attribute_menu_items") {
        if(nodeJSON.user_input) {
            if(nodeJSON.ui_type === "FREE_TEXT") {
                node = this.buildFreeTextNode(nodeJSON);
            } else {
                node = this.buildInputNode(nodeJSON);
            }
        } else {
            if(nodeJSON.ui_type ==="LINE") {
                node = new LineStructureTerm();
            } else if(nodeJSON.ui_type ==="EXPAND") {
            	node =  new ExpandStructureTermGroup();
            	this.addNormality(node, nodeJSON);
            } else if(nodeJSON.ui_type ==="TABLE") {
                node = this.buildTableStructureTermGroupNode(nodeJSON);
            } else {
                node = this.buildCycleNode(nodeJSON, owner);
            }
        }
        node.setCaption(nodeJSON.caption || "");
        node.setDisplayPosition(nodeJSON.display_seq);
        node.setUIValue(nodeJSON.ui_value);
        node.setPriority(nodeJSON.priority);
    } else {
        // the traverse function checks every attribute on the JSON
        // so there will be times where it will be called on something that doesn't
        // translate into a node that can be built, like "CODE"
        return null;
    }
    //Set the display flag for the node
    if(typeof nodeJSON.displayflag !== "undefined") {
        node.setShouldRender(nodeJSON.displayflag ? true : false);
    }
    //Give the node the namespace so it will have a unique DOM existence
    node.setNamespace(this.getNamespace());
    //Set the OCID for the node if it has one, otherwise it's null
    //TODO: Figure out if no OCID means "" or null
    node.setOCID(nodeJSON.ocid || "");
    //Store the node type
    node.setType(nodeType);
    //Set the title of the node, this is either the value or name property in the JSON
    node.setTitle(nodeJSON.label || nodeJSON.value || nodeJSON.name || nodeJSON.section_label || "");
    //Use a count variable to give each node a unique numerical identifier
    node.setId((this.m_nodeCount++)+"");
    //Associate the current organizer to the node
    node.setOrganizer(this.getStructureOrganizer());
    //Add the node to the lookup so we can access it later via the DOM id
    this.m_structureOrganizer.addTermToLookup(node);
    //Add the new node to the parent
    owner.addChild(node);
    return node;
};

/**
 * Creates a StructureTermGroup object based on the attrib_type json field. This will either construct a
 * Single, Multiple, or YesNo grouping.
 * @param nodeJSON the node's JSON.
 * @return {StructureTermGroup} a "Single" -> SingleStructureTermGroup, "Multiple" -> MultiStructureTermGroup,
 * "YesNo" -> YesNoStructureTermGroup.
 */
JSONStructureOrganizerBuilder.prototype.buildStructureTermGroupNode = function(nodeJSON) {
    switch(nodeJSON.attrib_type) {
        case "Single":
            return new SingleStructureTermGroup();
        case "Multiple":
            return new MultiStructureTermGroup();
        case "YesNo":
            return new YesNoStructureTermGroup();
        default:
            throw new Error("Attempted to call JSONStructureOrganizerBuilder.prototype.buildStructureTermGroupNode with" +
				" unsupported ATTRIB_TYPE");
    }
};

/**
 * Creates an InputStructureTerm object. Based on the data type, the object will be given validators to verify correct
 * input has been provided.
 * @param nodeJSON
 * @return {InputStructureTerm}
 */
JSONStructureOrganizerBuilder.prototype.buildInputNode = function(nodeJSON) {
    var node = new InputStructureTerm();
    node.setDataType(nodeJSON.data_type);
    node.setActiveState(new TermState().setCSSClass((nodeJSON.normalfinding === "Abnormal") ? "documented-abnormal" : "documented").setValue(true));
    node.setInactiveState(new TermState().setCSSClass("undocumented").setValue(null));
    node.setInitialState(node.getInactiveState());
    if(nodeJSON.data_type === "NUMERIC") {
        if(nodeJSON.min_value === 0.0 && nodeJSON.max_value === 0.0) {
            //Just add the default since it accepts any number
            node.addValidator(new DataRangeValidator());
        } else {
            node.addValidator(new DataRangeValidator().setMinValue(nodeJSON.min_value).setMaxValue(nodeJSON.max_value));
        }
    }

    node.addValidator(new DataTypeValidator().setDataType(nodeJSON.data_type));

    return node;
};

/**
 * Creates a FreeTextStructureTerm object. This object is always an ALPHA (plus more).
 * @return {FreeTextStructureTerm} the FreeTextStructureTerm object that was constructed.
 */
JSONStructureOrganizerBuilder.prototype.buildFreeTextNode = function(nodeJSON) {
    var node = new FreeTextStructureTerm();
    node.setDataType(nodeJSON.data_type);
    node.setActiveState(new TermState().setCSSClass(nodeJSON.normalfinding === "Abnormal" ? "documented-abnormal" : "documented").setValue(true));
    node.setInactiveState(new TermState().setCSSClass("undocumented").setValue(null));
    node.setInitialState(node.getInactiveState());
    return node;
};

/**
 * Creates a TableStructureTermGroup object.
 * @param  {JSON} nodeJSON JSON representation of the Table Group to be generated
 * @return {TableStructureTermGroup} the TableStructureTermGroup object what was constructed.
 */
JSONStructureOrganizerBuilder.prototype.buildTableStructureTermGroupNode = function(nodeJSON) {
    var node = new TableStructureTermGroup();
    this.addNormality(node, nodeJSON);
    return node;
};


/**
 * Creates a CycleStructureTerm object.
 * @param nodeJSON the JSON representation of the node.
 * @param owner the parent of this CycleStructureTerm. It is necessary to know the owner of this term because
 * if it exists within a YesNo StructureTermGroup, it will be given an additional no-state.
 * @return {CycleStructureTerm} the CycleStructureTerm object that was created.
 */
JSONStructureOrganizerBuilder.prototype.buildCycleNode = function(nodeJSON, owner) {
    var node = null;
    var nodeUIType = nodeJSON.ui_type;
    // Yes/No terms have 2 documented states. The first documented state is "Yes", the second documented state is "No". It should not be NONE term.
    var isYesNo = YesNoStructureTermGroup.prototype.isPrototypeOf(owner) && nodeUIType !== "NONE";
    if(isYesNo) {
        node = new YesNoStructureTerm();
    } else if(nodeUIType === "NONE"){
		node = new NoneStructureTerm();			
	} else if(TableStructureTermGroup.prototype.isPrototypeOf(owner)){
        node = new TableStructureTerm();
    }
    else {
        node = new CycleStructureTerm();
    }
    this.addNormality(node, nodeJSON);

    return node;
};

/**
 * Adds states to the passed node based on the normality
 * @param {StructureNode}  node  The node to associate the normality to
 * @param {JSON}  nodeJSON JSON containing node details (including normality)
 */
JSONStructureOrganizerBuilder.prototype.addNormality = function(node, nodeJSON) {
    // Check if node is a YesNo node (to determine whether or not to add 3rd state)
    var isYesNo = YesNoStructureTerm.prototype.isPrototypeOf(node);
    var normality = nodeJSON.normalfinding;
    // add the undocumented state
    node.addState(new TermState().setCSSClass("undocumented").setValue(null));

    // add the documented state(s)
    // Yes/No terms have 2 documented states. The first documented state is "Yes", the second documented state is "No".
    switch(normality) {
        case "Neutral":
            node.addState(new TermState().setCSSClass("documented").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term
                node.addState(new TermState().setCSSClass("documented").setValue(false));
            }
            break;
        case "Normal":
            node.addState(new TermState().setCSSClass("documented").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term... where answering "No" to something normal = abnormal
                node.addState(new TermState().setCSSClass("documented-abnormal").setValue(false));
            }
            break;
        case "Abnormal":
            node.addState(new TermState().setCSSClass("documented-abnormal").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term... where answersing "No" to something abnormal = normal
                node.addState(new TermState().setCSSClass("documented").setValue(false));
            }
            break;
        default:
            throw new Error("Unexpected normal finding value in the JSON: " + normality);
    }

    node.setInitialState(node.getStates()[0]);
    return node;
};


/**
 * Overrides the StructureOrganizerBuilder update method. It initiates the update process by starting a
 * recursive travel through the JSON, updating the associated JavaScript objects.
 *
 * @param organizer The StrutureOrganizer being updated.
 * @param activityJson the JSON object that contains activity data.
 */
JSONStructureOrganizerBuilder.prototype.update = function (organizer, activityJson) {
	organizer.setActivityId(activityJson.dd_section_id);
	this.updateTraverse(activityJson, organizer);
};

/**
 * This is a recursive method that traverses the structure JSON, creating the associated JavaScript objects and
 * creating the necessary tree structure.
 * @param node the JSON node we are processing.
 * @param owner The parent JavaScript object is passed down a level of recursion so the new nodes can be correctly
 * added to their corresponding parent.
 */
JSONStructureOrganizerBuilder.prototype.updateTraverse = function (node, owner) {
    var child;
    //We don't care about non-object types, so skip them.
    if (!(node instanceof Object)) {
        return;
    }
    //Go through the child JSON nodes
    for (child in node) {
        //If this is a valid node.
        if (node.hasOwnProperty(child)) {
            //Skip any non-object JSON nodes.
            if (!(node[child] instanceof  Object)) {
                continue;
            }
            //If we found an array, go through each item, processing it accordingly
            if (Array.prototype.isPrototypeOf(node[child])) {
                var childArr = node[child];
                for (var i = 0; i < childArr.length; i++) {
                    //Create a node based on the JSON
                    var structureNode = this.updateNode(child, childArr[i], owner);

                    if (structureNode) {
                        //Go a level deeper, using the newly created structureNode as the new owner.
                        this.updateTraverse(childArr[i], structureNode);
                    }
                }
            } else {
                //If we didn't find an array, just go down a level deeper, passing through the owner.
                this.updateTraverse(node[child], owner);
            }
        }
    }
};

/**
 * A big nasty update method that updates JavaScript structure objects based on their node type.
 * @param nodeType the type of node.
 * @param nodeJSON the corresponding node JSON.
 * @param owner the parent of this new StructureNode object.
 * @return {StructureNode} the newly created StructureNode.
 */
JSONStructureOrganizerBuilder.prototype.updateNode = function(nodeType, nodeJSON, owner) {
	var node = null;
	var children = owner.getChildren();
	var i;
	var currentNode;
	// find the correct node
	// and set its activity id
	if(nodeType === "subsections") {
		for(i = 0; i < children.length; i++) {
			currentNode = children[i];
			if(this.matchesSubsection(children[i], nodeJSON)) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_section_id);
				break;
			}
		}
	} else if(nodeType === "groupbys") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.label === currentNode.getTitle()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_groupby_id);
				break;
			}
		}
	} else if(nodeType === "subgroupbys") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.label === currentNode.getTitle()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_sgroupby_id);
				break;
			}
		}
	} else if(nodeType === "items") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.ocid === currentNode.getOCID()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_item_id);
				break;
			}
		}
	} else if(nodeType === "attributes") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.ocid === currentNode.getOCID()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_attribute_id);
				break;
			}
		}
	} else if(nodeType === "attribute_menu_items") {
		// Loop through to find the correct JSON child
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];

            // Ensure to search lower levels if this is an attribute_menu_item with children (Expand/Table)
            if (currentNode.getChildren().length > 0) {
                this.updateNode(nodeType, nodeJSON, currentNode);
            }

			if (nodeJSON.ocid === currentNode.getOCID() && nodeJSON.display_seq === currentNode.getDisplayPosition()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_attr_menu_item_id);
				//builds and displays comment if the node JSON has comment
				if(nodeJSON.comment) {				
					node.displayComment(nodeJSON.comment);
				}
				// update state/value based on type of term
				if (node instanceof InputStructureTerm) {
					//Store the current text value on the term
					node.setCurrentValue(nodeJSON.value_text ? node.unescapePlaintextAsHtml(nodeJSON.value_text) : nodeJSON.value_number + "");
					//Update the term (may have a visual update as well)
					node.update();
				} else if (node instanceof CycleStructureTerm) {
					node.jumpToState(nodeJSON.truth_state_mean === "T" ? 1 : 2);
				}

				break;
			}
		}
	}

	return node;
};

/**
 * Determines if an existing subsection structure node matches the provided subsection JSON. This is so we can match up
 * activity data to the corresponding subsection object. The subsection node and JSON are considered a match only if all
 * of the template_rltns match.
 * @param {StructureOrganizer} subsectionNode - The subsection structure node against which we are comparing the
 * provided JSON to determine if it matches.
 * @param { { "dd_section_id" : number, ..., "template_rltns" : [ ... ]} } subsectionJSON - A subsection JSON against
 * which we are comparing the provided subsection node to determine if it matches.
 * @returns {boolean} True if the subsection node matches the subsection JSON, otherwise false.
 */
JSONStructureOrganizerBuilder.prototype.matchesSubsection = function(subsectionNode, subsectionJSON) {
	var subsectionTemplateRelations = subsectionNode.getTemplateRelations();
	var activityTemplateRelations = subsectionJSON.template_rltns;
	var subsectionTemplateRelationCount = subsectionTemplateRelations.length;
	var activityTemplateRelationCount = activityTemplateRelations.length;
	var subsectionTemplateRelation = null;
	var activityTemplateRelation = null;
	var matchedRelation = false;
	if(subsectionTemplateRelationCount !== activityTemplateRelationCount) {
		return false;
	}
	for(var i = 0; i < subsectionTemplateRelationCount; i++) {
		subsectionTemplateRelation = subsectionTemplateRelations[i];
		matchedRelation = false;
		for(var j = 0; j < activityTemplateRelationCount; j++) {
			activityTemplateRelation = activityTemplateRelations[j];
			if(subsectionTemplateRelation.dd_sref_chf_cmplnt_crit_id === activityTemplateRelation.dd_sref_chf_cmplnt_crit_id &&
				subsectionTemplateRelation.dd_sref_templ_instance_ident === activityTemplateRelation.dd_sref_templ_instance_ident &&
				subsectionTemplateRelation.parent_entity_id === activityTemplateRelation.parent_entity_id &&
				subsectionTemplateRelation.parent_entity_name === activityTemplateRelation.parent_entity_name) {
				matchedRelation = true;
				break;
			}
		}
		if(!matchedRelation) {
			return false;
		}
	}
	return true;
};

/**
 * Generates the question set object which is used to display structure template questions.
 * @param {Object} questionData - The JSON question data which is translated into the associated
 * StructureQuestionSet object.
 * @returns {StructureQuestionSet} The structure question set object generated from the provided JSON.
 */
JSONStructureOrganizerBuilder.prototype.buildQuestionSet = function(questionData) {
	var rawQuestion = null;
	var rawAnswers = null;
	var rawAnswer = null;
	var rawAnswerCount = null;

	var questionCount = questionData.length;
	var questionSet = new StructureQuestionSet();
	var question = null;
	var answer = null;

	var nodeCount = 0;

	questionSet.setNamespace(this.m_namespace);
	var lookup = questionSet.getLookup();

	//Loop through the data and generate the question objects
	for(var i = 0; i < questionCount; i++) {
		rawQuestion = questionData[i];
		question = new StructureQuestion();
		question.setId(++nodeCount + "");
		question.setNamespace(this.m_namespace);
		question.setQuestionDisplay(rawQuestion.label);
		question.setParentEntityId(rawQuestion.parent_entity_id);
		question.setParentEntityName(rawQuestion.parent_entity_name);

		rawAnswers = rawQuestion.choices;
		rawAnswerCount = rawAnswers.length;
		for(var j = 0; j < rawAnswerCount; j++) {
			rawAnswer = rawAnswers[j];
			answer = new StructureAnswer();
			answer.setAnswerDisplay(rawAnswer.label);
			answer.setTemplateId(rawAnswer.dd_sref_chf_cmplnt_crit_id);
			answer.setId(++nodeCount + "");
			answer.setNamespace(this.m_namespace);
			//Add the answer to the lookup.
			lookup[answer.getId()] = answer;
			question.addChild(answer);
		}
		questionSet.addChild(question);
	}
	return questionSet;
};

/**
 * This argument will be used to have individual methods of a child class inherit from a parent class
 * @param  {Class} childClass  The class that will 'inherit' methods
 * @param  {Class} parentClass The class that's methods will be 'inherited'
 * @param  {Array<String>} methods An array of methods (as strings) to inherit.  Will be added to child class to call parent method.
 * @return {undefined}
 */
JSONStructureOrganizerBuilder.extendClassMethods = function(childClass, parentClass, methods) {
    var methodCnt = methods.length;
    for (var i = 0; i < methodCnt; i++){
        (function(x){
            //Create method on child class that calls the parent class method with child context.
            childClass.prototype[methods[x]] = function(args) {
                return parentClass.prototype[methods[x]].apply(this, arguments);
            };
        })(i);
    }
};
/**
 * StructureNode
 * This class represents the very base level node concept for structure documentation. This node allows for
 * construction of an (n)ary tree. All base functionality, within reason, for structure nodes is encapsulated in
 * this base class.
 * @constructor
 */
function StructureNode() {
	this.m_activityId = 0.0;			//The id that links to activity data, as opposed to reference data
	this.m_children = null;				//The child nodes of this node
	this.m_dirty = false;				//The dirty status of the node (whether is has been modified since load)
	this.m_displayPosition = 0;			//The display position of the node
	this.m_id = "";						//A unique identifier for the node.
	this.m_initialState = null;			//The starting state of the node (on creation)
	this.m_namespace = "";				//The namespace for the node (useful for giving unique DOM ids)
	this.m_numberDocumented = 0;		//The number of child nodes that have been documented
	this.m_ocid = "";					//The OCID of the node (not always present)
	this.m_parent = null;				//The parent of this node (root node will have null parent)
	this.m_previousState = null;		//The previous state of the node
	this.m_rootElement = null;			//The root element of the node (if available)
	this.m_shouldRender = true;			//Whether the node should ever be rendered or not.
	this.m_isDefaultDisplayed = true;	//Whether the node should be displayed (rendered) initially
	this.m_state = null;				//What state the node is in (documented or not, etc)
	this.m_title = "";					//The title of the node (not always visible)
	this.m_type = "";					//The node type (json key value)
	this.m_inNavigateStructureTree = true; //The node should be default searched for in the structure tree
	this.m_shouldSave = true;			//The node will be defaulted to be included when saving
}

/**
 * Returns the activityId of the StructureNode.
 * @returns {number} activity id
 */
StructureNode.prototype.getActivityId = function () {
	return this.m_activityId;
};
/**
 * Sets the activityId of the StructureNode.
 * @param {string} id - The id of the StructureNode.
 */
StructureNode.prototype.setActivityId = function (activityId) {
	if (typeof activityId !== "number") {
		throw new Error("Called setActivityId on StructureNode with invalid parameter for activityId");
	}
	this.m_activityId = activityId;
	return this;
};

/**
 * Returns the Array of children for this StructureNode.
 * @returns {Array<StructureNode>}
 */
StructureNode.prototype.getChildren = function () {
	if (!this.m_children) {
		this.m_children = [];
	}
	return this.m_children;
};

/**
 * Returns the dirty state of this StructureNode.
 * @returns {boolean}
 */
StructureNode.prototype.isDirty = function () {
	return this.m_dirty;
};

/**
 * Sets the dirty state of this StructureNode.
 * @param {boolean} dirty - The dirty state of this StructureNode. True if dirty, otherwise false.
 * @returns {StructureNode}
 */
StructureNode.prototype.setIsDirty = function (dirty) {
	if (typeof dirty !== "boolean") {
		throw new Error("Called setIsDirty on StructureNode with invalid dirty parameter.");
	}
	this.m_dirty = dirty;
	return this;
};

/**
 * Returns the displayPosition value of the StructureNode.
 * @returns {number}
 */
StructureNode.prototype.getDisplayPosition = function () {
	return this.m_displayPosition;
};

/**
 * Sets the displayPosition value of the StructureNode.
 * @param {number} displayPosition - The displayPosition value of the StructureNode.
 */
StructureNode.prototype.setDisplayPosition = function (displayPosition) {
	if(typeof displayPosition !== "number") {
		throw new Error("Attempted to call StructureNode.prototype.setDisplayPosition with invalid parameter.");
	}
	this.m_displayPosition = displayPosition;
	return this;
};

/**
 * Returns the id of the StructureNode.
 * @return {string}
 */
StructureNode.prototype.getId = function () {
	return this.m_id;
};
/**
 * Sets the id of the StructureNode.
 * @param {string} id - The id of the StructureNode. This will give the node a unique presence on the DOM.
 * @returns {StructureNode}
 */
StructureNode.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Called setId on StructureNode with invalid parameter for id");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the initial TermState of this StructureNode. This is the state since the last save.
 * @returns {TermState}
 */
StructureNode.prototype.getInitialState = function () {
	return this.m_initialState;
};

/**
 * Sets the initial TermState of this StructureNode. This is the state since the last save.
 * @param {TermState} initialState - The TermState since the last save operation.
 * @returns {StructureNode}
 */
StructureNode.prototype.setInitialState = function (initialState) {
	if (!TermState.prototype.isPrototypeOf(initialState)) {
		throw new Error("Called setInitialState on StructureNode with invalid initialState parameter.");
	}
	this.m_initialState = initialState;
	return this;
};

/**
 * Returns the namespace of this StructureNode. Namespaces are used to provide unique html identification across
 * multiple instances of structured documentation.
 * @returns {string}
 */
StructureNode.prototype.getNamespace = function () {
	return this.m_namespace;
};

/**
 * Sets the namespace of this StructureNode. Namespaces are used to provide unique html identification across
 * multiple instances of structured documentation.
 * @param {string} namespace - The namespace of this StructureNode.
 * @returns {StructureNode}
 */
StructureNode.prototype.setNamespace = function (namespace) {
	if (typeof namespace !== "string") {
		throw new Error("Called setNamespace on StructureNode with invalid namespace parameter.");
	}
	this.m_namespace = namespace;
	return this;
};

/**
 * Returns the number of children that are documented.
 * @returns {number}
 */
StructureNode.prototype.getNumberOfDocumentedChildren = function () {
	return this.m_numberDocumented;
};

/**
 * Returns the OCID of this StructureNode.
 * @returns {string}
 */
StructureNode.prototype.getOCID = function () {
	return this.m_ocid;
};

/**
 * Sets the OCID of this StructureNode.
 * @param {string} ocid - The OCID of this StructureNode.
 */
StructureNode.prototype.setOCID = function (ocid) {
	if(typeof ocid !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setOCID with invalid parameter.");
	}
	this.m_ocid = ocid;
	return this;
};

/**
 * Returns the parent of this StructureNode, if there is one.
 * @returns {StructureNode}
 */
StructureNode.prototype.getParent = function () {
	return this.m_parent;
};

/**
 * Sets the parent of this StructureNode.
 * @param {StructureNode} parent - The StructureNode that is the parent of this StructureNode.
 * @returns {StructureNode}
 */
StructureNode.prototype.setParent = function (parent) {
	if (!StructureNode.prototype.isPrototypeOf(parent)) {
		throw new Error("Called setParent on StructureNode with invalid parent parameter.");
	}
	this.m_parent = parent;
	return this;
};

/**
 * Returns the previous TermState of this StructureNode. This is the TermState since the last state change.
 * @returns {TermState}
 */
StructureNode.prototype.getPreviousState = function () {
	return this.m_previousState;
};

/**
 * Sets the previous TermState of this StructureNode.
 * @param {TermState} previousState - The TermState since the last state change.
 */
StructureNode.prototype.setPreviousState = function (previousState) {
	if(!TermState.prototype.isPrototypeOf(previousState) && previousState !== null) {
		throw new Error("Attempted to call StructureNode.prototype.setPreviousState with invalid parameter.");
	}
	this.m_previousState = previousState;
	return this;
};

StructureNode.prototype.getRootElement = function () {
	return this.m_rootElement;
};

/**
 * Returns whether or not this StructureNode should render its contents. This is simply a display flag.
 * @returns {boolean}
 */
StructureNode.prototype.getShouldRender = function () {
	return this.m_shouldRender;
};

/**
 * Sets whether or not this StructureNode should render its contents. This is simply a display flag. Note that
 * this flag has no effect on the children. If this node is invisible, its children may still render.
 * @param {boolean} shouldRender - Whether this StructureNode should render its contents.
 */
StructureNode.prototype.setShouldRender = function (shouldRender) {
	if (typeof shouldRender !== "boolean") {
		throw new Error("Called setShouldRender on StructureNode with invalid shouldRender parameter.");
	}
	this.m_shouldRender = shouldRender;
	return this;
};


/**
 * Method used for determining whether or not a node is in the correct position in the navigation-data coming from cernstructure plugin.
 * This is utilized to handle how the nodes heirarchy is searched to match a node based on label/ocid details from the cernstructure.
 * Certain nodes (Table/Expand) are not in the correct tree structure in the structured plugin due to linearization of AMIs there.
 * Nodes that should be ignored when searching (due to the linearized AMIs from cernstructure node heirarchy) will return false here.
 * By default, Nodes will be included when searching through the structure tree.
 * @return {Boolean} Returns true if the node should be considered when searching the structure tree
 */
StructureNode.prototype.inNavigationStructureTree = function() {
	return this.m_inNavigateStructureTree;
};

/**
 * Returns whether or not the details of the current node should be added to the JSON on save
 * @return {Boolean} Whether the current node should be included in the JSON to save
 */
StructureNode.prototype.shouldSave = function() {
	return this.m_shouldSave;
};

/**
 * Returns whether or not this StructureNode should render on initial structure render.  
 * This differs from getShouldRender as it only affects whether the node is rendered on the initial render.
 * The intent of this function is to limit the nodes that are displayed (and rendered) initially for performance reasons.
 * @return {Boolean} Returns true if the node should be displayed on the initial page load
 */
StructureNode.prototype.isDefaultDisplayed = function() {
	return this.m_isDefaultDisplayed;
};

/**
 * Sets whether or not this StructureNode should render on the initial structure tab render
 * @param {Boolean} defaultDisplayed - Whether this StructureNode should render initially
 */
StructureNode.prototype.setIsDefaultDisplayed = function(defaultDisplayed){
	if (typeof defaultDisplayed !== "boolean") {
		throw new Error("Called setIsDefaultDisplayed on StructureNode with invalid defaultDisplayed paramater");
	}
	this.m_isDefaultDisplayed = defaultDisplayed;
	return this;
};

/**
 * Method to be implemented by child nodes.  Returns whether or not the node is currently displayed on the page.
 * This function is intended to be used to ensure that a node is visible on the page before performing certain operations
 * @return {Boolean} Returns true if the node is currently displayed on the page
 */
StructureNode.prototype.isCurrentlyDisplayed = function() {
	return true;
};

/**
 * Method to be implemented by child nodes.  Performs updates to ensure that the node is displayed on the page.
 */
StructureNode.prototype.displayNode = function() {
	throw new Error("displayNode is abstract, to be implemented by children");
};

/**
 * Returns the TermState this StructureNode is in.
 * @returns {TermState}
 */
StructureNode.prototype.getState = function () {
	return this.m_state;
};

/**
 * Sets the TermState this StructureNode is in.
 * @param {TermState} state - The current TermState this StructureNode is in.
 */
StructureNode.prototype.setState = function (state) {
	if(!TermState.prototype.isPrototypeOf(state)) {
		throw new Error("Attempted to call StructureNode.prototype.setState with invalid parameter.");
	}
	this.m_state = state;
	return this;
};

/**
 * Returns the title of this StructureNode. This is the value that will display in the markup.
 * @returns {string}
 */
StructureNode.prototype.getTitle = function () {
	return this.m_title;
};

/**
 * Sets the title of this StructureNode. This is the value that will display in the markup.
 * @param {string} title - The title of this StructureNode.
 */
StructureNode.prototype.setTitle = function (title) {
	if(typeof title !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setTitle with invalid parameter.");
	}
	this.m_title = title;
	return this;
};

/**
 * Returns the type of this StructureNode.
 * @returns {string}
 */
StructureNode.prototype.getType = function () {
	return this.m_type;
};

/**
 * Sets the type of this StructureNode.
 * @param {string} type - The type of this StructureNode.
 */
StructureNode.prototype.setType = function (type) {
	if(typeof type !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setType with invalid parameter.");
	}
	this.m_type = type;
	return this;
};

/**
 * This method allows a node to notify another node that it is dirty. The base implementation is to simply pass
 * this notification up the chain of parents. If a sub-class needs to perform some functionality, this method should
 * be overridden.
 * @param {StructureNode} node - The StructureNode that is informing of a dirty change.
 */
StructureNode.prototype.notifyDirty = function (node) {
	if (this.getParent()) {
		this.getParent().notifyDirty(node);
	}
};

/**
 * This method simply restores the StructureNode to a non-dirty state by setting the dirty member variable to false.
 */
StructureNode.prototype.resetDirty = function () {
	this.m_dirty = false;
};

/**
 * This turns a StructureNode into the JSON necessary for the save function
 * @return {string} a JSON string representation of the activity data of the node
 */
StructureNode.prototype.convertToJSON = function () {
	return {};
};

/**
 * This returns the parent organizer (SectionNode) of the current node (or null if not found)
 * @return {StructureOrganizer} The parent StructureOrganizer of the current node
 */
StructureNode.prototype.getOrganizer = function() {
	return this.m_organizer;
};

/**
 * Sets the StructureOrganizer associated with the current node
 * @param {StructureOrganizer} organizer - StructureOrganizer associated with the node
 */
StructureNode.prototype.setOrganizer = function(organizer) {
	if(!StructureOrganizer.prototype.isPrototypeOf(organizer)) {
		throw new Error("StructureOrganizer.prototype.setOrganizer expects a StructureOrganizer object.");
	}
	this.m_organizer = organizer;
};

/**
 * Returns the closest StructureOrganizer ancestor of the current node
 * @return {StructureOrganizer} The StructureOrganizer node that the current node descends from
 */
StructureNode.prototype.getParentSectionNode = function() {
	var currentNode = this;
	var sectionNode = null;
	//Find the section node that is the parent to the provided node
	while(currentNode !== null && !StructureOrganizer.prototype.isPrototypeOf(currentNode)) {
		currentNode = currentNode.getParent();
	}
	sectionNode = currentNode;
	return sectionNode;
};

/**
 * Returns the element that should be updated when the node should be highlighted
 * @return {undefined}
 */
StructureNode.prototype.getHighlightElement = function() {
	return this.getRootElement();
};

/**
 * Handles actions necessary after the initial rendering of a Structured tab.
 * @return {undefined} 
 */
StructureNode.prototype.postProcessing = function () {
	//Allow to be overwritten by children
};

/**
 * Add the children's json into the supplied array.
 *
 * @param {Array<JSON>} jsonArray - The array to push the children's json into
 */
StructureNode.prototype.addChildrenJSON = function (jsonArray) {
	// prep children json
	var children = this.getChildren();
	this.addNodesToJSON(children, jsonArray);
};

/**
 * Adds specified nodes to the given JSON
 * @param {Array<StructureNode>} nodes  StructureNodes to add to JSON
 * @param {Array<JSON>} jsonArray The array to push the children's json into
 */
StructureNode.prototype.addNodesToJSON = function (nodes, jsonArray) {
	var childrenMap = {};
	// map the children's json to their type, eg. "ITEM" => ["{....}", ... ]
	for (var i = 0; i < nodes.length; i++) {
		var child = nodes[i];
		var stateTruth = (child.getState() ? child.getState().getValue() : null);
		//If the node is not in a documented state then skip it unless it is a subsection node.
		//Subsection nodes must always be added, regardless of documented state.
		//Nodes that shouldn't be saved will be skipped
		if (stateTruth === null && child.getType() !== "subsections" || !child.shouldSave()) {
			continue;
		}

		// create the initial array if it doesn't exist
		if (!childrenMap[child.getType()]) {
			childrenMap[child.getType()] = [];
		}

		// convert the child into a json string and push into the array
		var childJSON = child.convertToJSON();
		childrenMap[child.getType()].push(childJSON);
	}

	// push the child into the section json
	for (var type in childrenMap) {
		jsonArray.push('"' + type + '": [' + childrenMap[type].join(',') + ']');
	}
};

/**
 * Adds all descendents of the current node to a passed array
 * @param  {Array} childList Array to add descendent StructureNodes to
 * @return {Array} Returns the passed array with added descendents
 */
StructureNode.prototype.getAllDescendents = function(childList) {
	var children = this.getChildren();
	var childCnt = children.length;
	var child;
	for (var i = 0; i < childCnt; i++){
		child = children[i];
		childList.push(child);
		child.getAllDescendents(childList);
	}
	return childList;
};

/**
 * Adds the descendent's json into the supplied array.  This is utilized when children AMI nodes 
 * exist at multiple levels in the structure tree (i.e. EXPAND/TABLE).  This handles adding converting
 * the tree structure into a linear JSON array.
 * @param {Array<JSON>} jsonArray The array to push the descendents' json into
 */
StructureNode.prototype.addDescendentJSON = function(jsonArray) {
	var descendents = this.getAllDescendents([]);
	this.addNodesToJSON(descendents, jsonArray);
};

/**
 * Escapes the special characters in the supplied string as HTML to make it safe for CCL and JSON.
 *
 * Special characters escaped:
 *	& - &#38;
 *	" - &#34;
 *	' - &#39;
 *	< - &#60;
 *	> - &#62;
 *	\ - &#92;
 *	^ - &#94;
 *	~ - &#126;
 *	\t - "&#9;
 *	\r - &#10;
 * 	\n - &#13;
 *
 * @param {string} plaintext - plain text, could be something like a free text comment
 * @returns {string} plain text that is represented as html, and is safe for to be handled by CCL and as part of a JSON string
 */
StructureNode.prototype.escapePlaintextAsHtml = function (plaintext) {
	// NOTE: always replace ampersand (&) first!
	return plaintext.replace(/\&/g, "&#38;").replace(/\"/g, "&#34;").replace(/\'/g, "&#39;").replace(/\</g, "&#60;").replace(/\>/g, "&#62;")
		.replace(/\\/g, "&#92;").replace(/\^/g, "&#94;").replace(/\~/g, "&#126;").replace(/\t/g, "&#9;").replace(/\r/g, "&#10;").replace(/\n/g, "&#13;");
};

/**
 * Converts HTML escapes back to plain text by
 * undoing the escapes performed by the escapePlaintextAsHtml() method.
 *
 * Special characters un-escaped:
 *	& - &#38;
 *	" - &#34;
 *	' - &#39;
 *	< - &#60;
 *	> - &#62;
 *	\ - &#92;
 *	^ - &#94;
 *	~ - &#126;
 *	\t - "&#9;
 *	\r - &#10;
 * 	\n - &#13;
 * 
 * @param {string} html - text as html with special character that needs to be unescaped back into plain text
 * @returns {string} regular plain text without any escapes for HTML/CCL/JSON
 */
StructureNode.prototype.unescapePlaintextAsHtml = function (html) {
	// NOTE: always unescape ampersand (&) last!
	return html.replace(/\&\#34\;/g, '"').replace(/\&\#39\;/g, "'").replace(/\&\#60\;/g, '<').replace(/\&\#62\;/g, '>').replace(/\&\#92\;/g, "\\")
		.replace(/\&\#94\;/g, "^").replace(/\&\#126\;/g, "~").replace(/\&\#9\;/g, "\t").replace(/\&\#10\;/g, "\r").replace(/\&\#13\;/g, "\n").replace(/\&\#38\;/g, "&");
};


/**
 * This method acts as a notification of a state change in a child node. Certain parent nodes need to know the
 * state of their children and perform actions accordingly. This base method simply keeps track of the number of
 * children nodes that are documented.
 * @param {StructureNode} node - The StructureNode child that is informing of a state change event.
 */
StructureNode.prototype.notifyStateChange = function (node) {
	var currentState = node.getState();
	var previousState = node.getPreviousState();
	if (previousState && currentState.getValue() === previousState.getValue()) {
		return;
	}
	var previousNumber = this.m_numberDocumented;
	if (currentState.getValue() === null) {
		this.m_numberDocumented = Math.max(0, this.m_numberDocumented - 1);
	} else if ((!node.getPreviousState() || node.getPreviousState().getValue() === null) && currentState.getValue() !== null) {
		this.m_numberDocumented = Math.min(this.m_children.length, this.m_numberDocumented + 1);
	}
	if (this.m_numberDocumented === 0) {
		this.updateState(new TermState().setValue(null).setKey("NULL"));
	} else if (this.m_numberDocumented > 0 && previousNumber === 0) {
		this.updateState(new TermState().setValue(true).setKey("TRUE"));
	}
};

/**
 * This method performs the necessary actions to update the state of the StructureNode. If the state being updated
 * to is different than the current state, a notification of state change is sent to the parent. The node is then
 * refreshed and the new state is stored.
 * @param {TermState} state - The state the StructureNode should be updated to.
 */
StructureNode.prototype.updateState = function (state) {
	var currentState = this.getState();
	if (state !== currentState) {
//		this.m_state = state;
		this.setState(state);
		this.setPreviousState(currentState);
		//If the node has a parent, notify of the state change
		if (this.getParent()) {
			this.getParent().notifyStateChange(this);
		}
	}

	// refresh anyways, something else (like whether the node is valid) may have changed while keeping the state the same
	this.refresh();
};

/**
 * Base refresh method for a StructureNode. This is simply an interface. This method should be implemented by
 * sub-classes of StructureNode.
 */
StructureNode.prototype.refresh = function () {
};

/**
 * Adds a child node to this StructureNode. This also performs the necessary operation of linking the child to this
 * node as the parent.
 * @param {StructureNode} child - The StructureNode that is to become a child of this StructureNode.
 */
StructureNode.prototype.addChild = function (child) {
	if (child.getParent() !== this) {
		child.setParent(this);
	}
	this.getChildren().push(child);
};

/**
 * The base render method. Any subclasses of StructureNode should provide their implementation of the render method.
 * @param {StructureHtml} structureHtml - The StructureHtml package to which any html content will be appended.
 */
StructureNode.prototype.render = function (structureHtml) {
	return;
};

/**
 * Clears the node and its decendents of all data, effectively resetting them to the state of being freshly created.
 *
 */
StructureNode.prototype.clear = function () {
	var children = this.getChildren();
	var i;
	for (i = 0; i < children.length; i++) {
		children[i].clear();
	}

	this.clearSelf();
};

/**
 * Clears only this node, effectively resetting itself to the state of being freshly created.
 *
 * Subclasses are to override this method as the implementation will vary with each subclass.
 * Generally, for all subclasses, clearing the activity id is the first thing that needs to happen.
 */
StructureNode.prototype.clearSelf = function () {
	this.setActivityId(0);
	this.m_previousState = null;
	this.m_state = null;
	this.m_numberDocumented = 0;
};
/**
 * StructureHtml
 * A very simple class which just encapsulates an html string. This is necessary as structured documentation html
 * is recursively generated. A string is pass-by-value, thus it is impossible to recursively generate a string using
 * a string object. This encapsulation allows for said recursive html generation.
 * @constructor
 */
function StructureHtml() {
	this.m_html = "";
}

/**
 * Returns the html package.
 * @returns {string} the html string
 */
StructureHtml.prototype.getHtml = function () {
	return this.m_html;
};

/**
 * Appends the provided html string to the current html member variable.
 * @param {string} html - An html string to be appended.
 * @returns {StructureHtml} self, for chaining
 */
StructureHtml.prototype.append = function (html) {
	this.m_html += html;
	return this;
};
/**
 * StructureOrganizer
 * This class represents a structured documentation SECTION node. This class is largely responsible for providing
 * the interface between the user and the underlying object structure. This class should eventually be refactored
 * into something called StructureSection, serving only as a data object. The rendering, navigation, and event
 * attachment should then be moved into a true StructureOrganizer object.
 * @constructor
 */
function StructureOrganizer() {
	this.m_lookup = null;
	this.m_navigator = null;
	this.m_referenceSectionId = null;
	this.m_type = "SECTION";

	this.m_templateIds = {};
	this.m_templateRelations = null;
	this.m_rootElement = null;
	this.m_contentElement = null;
	this.m_navigatorElement = null;
	this.m_resizeFunction = null;
	this.m_dirtyNodeList = null;
	this.m_onDirtyChangeCallback = null;
	this.m_previousHighlightedNode = null;
	this.m_rendered = false;
	this.m_isPriorityEnabled = true;
	
	//Multi-section variables
	this.m_isMultiSection = false;
	this.m_activeSection = null;
}
StructureOrganizer.prototype = new StructureNode();
StructureOrganizer.prototype.constructor = StructureNode;

/**
 * Sets whether or not the section has been rendered.
 * @param {boolean} rendered - A boolean indicating whether the section has been rendered or not.
 * @returns {StructureOrganizer} Returns self to allow chainin.
 */
StructureOrganizer.prototype.setIsRendered = function(rendered) {
	if(typeof rendered !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsRendered expects a boolean.");
	}
	this.m_rendered = rendered;
	return this;
};

/**
 * Retrieves whether or not the section has been rendered.
 * @returns {boolean} True if the section has been rendered, otherwise false.
 */
StructureOrganizer.prototype.isRendered = function() {
	return this.m_rendered;
};

/**
 * Sets the template relations for the section.
 * @param {Array<Object>} templateRelations - The template relations for the section.
 */
StructureOrganizer.prototype.setTemplateRelations = function(templateRelations) {
	this.m_templateRelations = templateRelations;
	return this;
};

/**
 * Retrieves the list of template relations for the section.
 * @returns {Array<Object>} The template relations for the section.
 */
StructureOrganizer.prototype.getTemplateRelations = function() {
	return this.m_templateRelations;
};


/**
 * Sets the active section for the parent
 * @param {StructureOrganizer} activeSection - Sets the active section.
 * @returns {StructureOrganizer} The active section.
 */
StructureOrganizer.prototype.setActiveSection = function(activeSection) {
	if(!StructureOrganizer.prototype.isPrototypeOf(activeSection)) {
		throw new Error("StructureOrganizer.prototype.setActiveSection expects a jQuery element.");
	}
	this.m_activeSection = activeSection;
	return this;
};

/**
 * Retrieves the active section.
 * @returns {StructureOrganizer} Retrieves the active section.
 */
StructureOrganizer.prototype.getActiveSection = function() {
	return this.m_activeSection;
};

/**
 * Retrieves whether or not the section has subsections (multi section).
 * @returns {boolean} True if this section is multi section (has subsection children).
 */
StructureOrganizer.prototype.isMultiSection = function() {
	return this.m_isMultiSection;
};

/**
 * Sets whether the organizer is considered multi-section or not.
 * @param {boolean} multiSection - An indicator specifying whether an organizer is considered multi-section or not.
 * @returns {StructureOrganizer} Returns self to allow chaining.
 */
StructureOrganizer.prototype.setIsMultiSection = function(multiSection) {
	if(typeof multiSection !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsMultiSection expects a boolean.");
	}
	this.m_isMultiSection = multiSection;
	return this;
};

/**
 * Returns whether AMI prioritization is enabled
 * @return {Boolean} Returns true if AMI priotization is enabled for child nodes
 */
StructureOrganizer.prototype.isPriorityEnabled = function(){
	return this.m_isPriorityEnabled;
};

/**
 * Sets whether the AMI prioritization is enabled
 * @param {Boolean} priorityEnabled True if AMI priotiziation (Show More) is on, False otherwise
 */
StructureOrganizer.prototype.setIsPriorityEnabled = function(priorityEnabled){
	if(typeof priorityEnabled !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsPriorityEnabled expects a boolean.");
	}
	this.m_isPriorityEnabled = priorityEnabled;
};

/**
 * Sets the function that is called when the dirty state changes at the organizer level.
 * @param {function} onDirtyChangeCallback - The function to be called when the dirty state changes at
 * the organizer level.
 */
StructureOrganizer.prototype.setOnDirtyChangeCallback = function (onDirtyChangeCallback) {
	if (typeof onDirtyChangeCallback !== "function") {
		throw new Error("Attempted to call StructureOrganizer.prototype.setOnDirtyChangeCallback with invalid parameter.");
	}
	this.m_onDirtyChangeCallback = onDirtyChangeCallback;
	return this;
};

/**
 * Overrides the base notifyDirty method from the StructureNode class. The organizer keeps track of a list of
 * dirty nodes via a hashmap.
 * @param {StructureNode} node - The structure node that has sent the notification about it's dirty state.
 */
StructureOrganizer.prototype.notifyDirty = function (node) {
	var parent = this.getParent();
	//A section can potentially have a parent section...
	if(parent) {
		parent.notifyDirty(node);
	}
	//If this is the root element, handle the dirty node list
	if(!parent) {
		if (node.isDirty()) {
			this.addNodeToDirtyList(node);
		}
		else {
			this.removeNodeFromDirtyList(node);
		}
		this.updateDirty();
	}
};

/**
 * Overrides the base resetDirty method. This will go through the stored dirty nodes and call their resetDirty method.
 * This will also clear out the mapping of dirty nodes.
 */
StructureOrganizer.prototype.resetDirty = function () {
	StructureNode.prototype.resetDirty.call(this);
	var dirtyNodeList = this.getDirtyNodeList();
	for (var key in dirtyNodeList) {
		if (dirtyNodeList.hasOwnProperty(key)) {
			this.m_lookup[key].resetDirty();
		}
	}
	this.m_dirtyNodeList = {};
};

/**
 * Returns the dirty node list which is a mapping of node id to true/false values. The advantage of this
 * over a flat array is that when a node updates its dirty state, the cost to update this list is
 * essentially nothing.
 * @returns {Map<string,boolean>} a map/object of node id and their dirty state as boolean
 */
StructureOrganizer.prototype.getDirtyNodeList = function () {
	if (!this.m_dirtyNodeList) {
		this.m_dirtyNodeList = {};
	}
	return this.m_dirtyNodeList;
};

/**
 * Removes a node from the dirty list by updating its true/false value in the map.
 * @param {StructureNode} node - The node to be removed from the dirty list.
 */
StructureOrganizer.prototype.removeNodeFromDirtyList = function (node) {
	this.getDirtyNodeList()[node.getId()] = false;
};

/**
 * Adds a node to the dirty list by updating its true/false value in the map to true.
 * @param {StructureNode} node - The node to be added to the dirty list.
 */
StructureOrganizer.prototype.addNodeToDirtyList = function (node) {
	this.getDirtyNodeList()[node.getId()] = true;
};

/**
 * Returns the root element of the structure organizer and caches it.
 * @returns {object} jQuery object of the organizer root element
 */
StructureOrganizer.prototype.getRootElement = function () {
	if (!this.m_rootElement || !this.m_rootElement.length) {
		if(this.m_isMultiSection) {
			this.m_rootElement = $("#" + this.getNamespace() + "\\:parentOrganizer\\:ROOT\\:" + this.getId());
		} else {
			this.m_rootElement = $("#" + this.getNamespace() + "\\:organizer\\:ROOT\\:" + this.getId());
		}
	}
	return this.m_rootElement;
};

/**
 * Returns the custom resize function to be called when the organizer is resized. This should be provided by
 * the consumer as there is no guarantee where this artifact will exist.
 * @returns {function} resize function
 */
StructureOrganizer.prototype.getResizeFunction = function () {
	return this.m_resizeFunction;
};

/**
 * Sets the custom resize function to be called when the organizer is resized. This should be provided by the
 * consumer as there is not guarantee where this artifact will exist.
 * @param {function} resizeFunction - The custom resize function.
 */
StructureOrganizer.prototype.setResizeFunction = function (resizeFunction) {
	if (typeof resizeFunction !== "function") {
		throw new Error("Called setResizeFunction on StructureOrganizer with invalid parameter resizeFunction");
	}
	this.m_resizeFunction = resizeFunction;
	return this;
};

/**
 * Returns the structure navigator element and caches it.
 * @returns {object} jQuery object of the navigator html element
 */
StructureOrganizer.prototype.getNavigatorElement = function () {
	if (!this.m_navigatorElement) {
		this.m_navigatorElement = $("#" + this.getNamespace() + "\\:navigatorPanel\\:" + this.getId());
	}
	return this.m_navigatorElement;
};

/**
 * Navigates to the particular element in the structure view
 * @param navigationData - JSON data which contains the element details to navigate to
 */
StructureOrganizer.prototype.navigateToNode = function(navigationData) {
	var desiredString = "";
	var jsonData = JSON.parse(navigationData);
	//Build a navigation string that uniquely identifies the node we are searching for.
	for (var i = 0; i < jsonData.length; i++) {
		var value = jsonData[i];
		if (value.label) {
			desiredString = desiredString + "label:" + value.label;
		} else if (value.ocid) {
			desiredString = desiredString + ", ocid:" + value.ocid;
		}
	}
	//Using the identification string, find the corresponding structure node in the tree
	var returnNode = this.findNode(this, this.m_ocid, desiredString);
	this.goToNode(returnNode, true, true);
};

/**
 * Updates the scroll position to navigate to the given node on the page.  No navigation is performed if already visible.
 * @param destinationNode {StructureNode} The node to navigate to 
 * @param highlightNode {Boolean} True iff the node to navigate to should be highlighted
 * @param alwaysNavigate {Boolean} True iff the scroll postion should always be updated to navigate to the selected node
 */
StructureOrganizer.prototype.goToNode = function(destinationNode, highlightNode, alwaysNavigate){
	var sectionNode = null;
	var contentOffsetTop;
	var nodeOffsetTop;
	var nodeOffsetBottom;
	var contentHeight;
	var $contentElement;
	var $nodeRootElement;
	//If the desired node could not be found in the structure tree, log an error and exit.
	if(!destinationNode) {
		logger.logWarning("StructureOrganizer.prototype.navigateToNode: unable to find the specified node");
		return;
	}

	//Find the section node that is the parent to the provided node
	sectionNode = destinationNode.getParentSectionNode();

	//If a section node was not found as an ancestor to the node we are navigating to.
	if(!sectionNode || !StructureOrganizer.prototype.isPrototypeOf(sectionNode)) {
		logger.logWarning("StructureOrganizer.prototype.navigateToNode: unable to find a section node that is parent to the node that was navigated to.");
		return;
	}

	//If this is a multi-section tree, first navigate to the appropriate tab
	if(this.isMultiSection() && (this.getActiveSection() !== sectionNode)) {
		$("#" + this.getNamespace() + "\\:tab\\:" + sectionNode.getId()).click();
	}

	//If node is not currently displayed on the page, update accordingly before attempting to scroll
	if(!destinationNode.isCurrentlyDisplayed()){
		destinationNode.displayNode();
	}
	
	//The body element of the active section
	$contentElement = sectionNode.getContentElement();
	//The first rendered element out of the node and its ancestors
	$nodeRootElement = this.findRenderedRootHighlightElement(destinationNode);
	//If an element was successfully found, navigate the content body (via scroll) to the node and highlight it.
	if($nodeRootElement && $nodeRootElement.length) {
		//Updating highlighting if turned on 
		if(highlightNode){
			$nodeRootElement.addClass('highlight-navigation');
			this.m_previousHighlightedNode = $nodeRootElement;
		}

		contentOffsetTop = $contentElement.offset().top;
		nodeOffsetTop = $nodeRootElement.offset().top;
		nodeOffsetBottom = nodeOffsetTop + $nodeRootElement.height();
		contentHeight = $contentElement.height();
		//Only update scroll positioning if the node is not in view
		if(alwaysNavigate || !((nodeOffsetBottom - contentOffsetTop > 0) && (nodeOffsetBottom - contentOffsetTop <= contentHeight))){
			$contentElement.scrollTop((nodeOffsetTop - contentOffsetTop + $contentElement.scrollTop()) - ((contentHeight / 2) - $nodeRootElement.height() / 2));
		}
	}
};

/**
 * Function to find the node from Organizer tree which matches the navigation data
 * @param currentNode - current node - intially the organizer
 * @param currentString - contains the formation of ocids and label of the node
 * @param desiredString - which contains the formation of ocids and labels of the node navigates to
 */
StructureOrganizer.prototype.findNode = function(currentNode, currentString, desiredString) {
	if (desiredString === currentString) {
		return currentNode;
	} else {
		for (var i = 0; i < currentNode.getChildren().length; i++) {
			var childNode = currentNode.m_children[i];
			var node;
			//If the Node is not in its correct position in the cern-structure plugin tree, check children
			if(!childNode.inNavigationStructureTree()){
				node = this.findNode(childNode, currentString, desiredString);
			}
			else {
				var labelText = currentString + "label:" + childNode.m_title;
				var ocidText = childNode.m_ocid ? currentString + ", ocid:" + childNode.m_ocid : currentString;
				node = this.findNode(childNode, childNode.m_type === "groupbys" || childNode.m_type === "subgroupbys" || childNode.m_type === "subsections" ? labelText : ocidText, desiredString);
			}
			if (node) {
				return node;
			}
		}
		return null;
	}
};

/**
* returns the rendered root highlight element
* @returns(rootElement)- rendered Root Element
*/
StructureOrganizer.prototype.findRenderedRootHighlightElement = function(returnedNode) {
	if (returnedNode.getShouldRender()) {
		return returnedNode.getHighlightElement();
	}
	var rootElement = this.findRenderedRootHighlightElement(returnedNode.getParent());
	if (rootElement) {
		return rootElement;
	} else {
		return null;
	}
};

/**
 * Function to clear the highliter for the previous selected elements on navigation to structure view
 */
StructureOrganizer.prototype.clearHighlighter = function () {
	var node = this.m_previousHighlightedNode;
	if(node) {
		node.removeClass('highlight-navigation');
	}	
};

/**
 * Wraps the resize functionality of the structure organizer. It checks to see if the
 * consumer has provided a custom resize function. If so, call that function and pass the
 * necessary elements.
 */
StructureOrganizer.prototype.resize = function () {
	if (this.m_resizeFunction) {
		this.m_resizeFunction({
			"rootElement": this.getRootElement(),
			"navigatorElement": this.getNavigatorElement(),
			"contentElement": this.getContentElement()
		});
	}
};

/**
 * Returns the content element and caches it.
 * @returns {object} jQuery object of the content html element
 */
StructureOrganizer.prototype.getContentElement = function () {
	if (!this.m_contentElement) {
		this.m_contentElement = $("#" + this.getNamespace() + "\\:organizer\\:CONTENT\\:" + this.getId());
	}
	return this.m_contentElement;
};

/**
 * Returns the navigator object associated to the StructureOrganizer.
 * @returns {Navigator} the navigator object/model that represents the navigator pane
 */
StructureOrganizer.prototype.getNavigator = function () {
	return this.m_navigator;
};

/**
 * Sets the navigator object associated to the StructureOrganizer.
 * @param {Navigator} navigator - The navigator associated to the StructureOrganizer.
 */
StructureOrganizer.prototype.setNavigator = function (navigator) {
	if (!Navigator.prototype.isPrototypeOf(navigator)) {
		throw new Error("Attempted to call StructureOrganizer.prototype.setNavigator with invalid parameter.");
	}
	this.m_navigator = navigator;
	return this;
};

/**
 * This method performs the check to see if the StructureOrganizer is in a dirty state. The StructureOrganizer
 * is considered dirty when at least one child, or term, is dirty.
 * @returns {boolean} true, if the organizer is dirty
 */
StructureOrganizer.prototype.checkIsDirty = function () {
	var dirtyNodeList = this.getDirtyNodeList();
	for (var key in dirtyNodeList) {
		if (dirtyNodeList.hasOwnProperty(key)) {
			if (dirtyNodeList[key]) {
				return true;
			}
		}
	}
	return false;
};

/**
 * Overrides the base updateDirty method. If the dirty state of the organizer has changed, there is a callback
 * provided, and the organizer has at least 1 documented child, the m_onDirtyChangeCallback function is called.
 */
StructureOrganizer.prototype.updateDirty = function () {
	var wasDirty = this.m_dirty;
	this.m_dirty = this.checkIsDirty();
	if (wasDirty !== this.m_dirty && this.m_onDirtyChangeCallback) {
		this.m_onDirtyChangeCallback(this.m_dirty);
	}
	// clears the previous highlighted node when a change happen to the structure
	if(this.m_previousHighlightedNode) {
		this.clearHighlighter();
	}
};

/**
 * Returns a list of template ids associated with the StructureOrganizer.
 * @returns {List<string>} a list of ids of the templates associated with the organizer
 */
StructureOrganizer.prototype.getTemplateIds = function () {
	return this.m_templateIds;
};

/**
 * Sets the list of template ids associated with the StructureOrganizer.
 * @param {List<string>} templateIds - The list of template ids associated with the StructureOrganizer.
 */
StructureOrganizer.prototype.setTemplateIds = function (templateIds) {
	if (!Array.prototype.isPrototypeOf(templateIds)) {
		throw new Error("Attempted to call StructureOrganizer.prototype.setTemplateIds with invalid parameter");
	}
	this.m_templateIds = templateIds;
	return this;
};

/**
 * Returns the reference section id associated with the StructureOrganizer.
 * @returns {number} reference section id
 */
StructureOrganizer.prototype.getReferenceSectionId = function () {
	return this.m_referenceSectionId;
};

/**
 * Sets the reference section id associated with the StructureOrganizer.
 * @param {number} referenceId - The reference section id associated with the StructureOrganizer.
 */
StructureOrganizer.prototype.setReferenceSectionId = function (referenceId) {
	if (typeof referenceId !== "number") {
		throw new Error("Attempted to call StructureOrganizer.prototype.setReferenceSectionId with invalid parameter");
	}
	this.m_referenceSectionId = referenceId;
	return this;
};

/**
 * Helper method to parse a structure element id and obtain the node id.
 * @param {string} id - The DOM element id of the StructureNode to be parsed.
 * @returns {string} the node id
 */
StructureOrganizer.prototype.parseIdForLookup = function (id) {
	return id.split(":")[3];
};

/**
 * Adds a StructureNode (typically a StructureTerm) to a lookup hashmap.
 * @param {StructureNode} term - The StructureNode to be added to the lookup.
 */
StructureOrganizer.prototype.addTermToLookup = function (term) {
	this.getLookup()[term.getId()] = term;
};

/**
 * Returns the StructureNode lookup hashmap. This is a hashmap that maps the StructureNode id to the actual
 * StructureNode object.
 * @returns {Map<string, StructureNode>} a map of the node id to the node object
 */
StructureOrganizer.prototype.getLookup = function () {
	if (!this.m_lookup) {
		this.m_lookup = {};
	}
	return this.m_lookup;
};

/**
 * Overrides the base render method. This will render the StructureOrganizer object as an html string and return
 * the html.
 * @returns {string} the organizer rendered as html string
 */
StructureOrganizer.prototype.render = function (structureHtml) {
	var children = this.getChildren();
	var childrenCount = children.length;
	var namespace = this.m_namespace;
	var child = null;
	var childId = "";
	var tabDisplay = "";
	var id = this.getId();
	//If this is a multi-section node, the child sections (subsections) must be rendered into tabs.
	if(this.m_isMultiSection) {
		structureHtml.append("<div id='" + namespace + ":parentOrganizer:ROOT:" + this.getId() + "' class='structure-organizer-parent structure-multi-section'>");
		structureHtml.append("<div id='" + namespace + "StructureTabParent' class='structure-tab-parent'>");
		structureHtml.append("<div id='" + namespace + "StructureTabBlock' class='structure-tab-block'>");
		structureHtml.append("<div id='" + namespace + "StructureTabGroupWrapper' class='structure-tab-wrapper'>");
		//Tabs for each sub-section
		structureHtml.append("<ul id='" + namespace + "StructureTabGroup' class='structure-tab-group'>");
		for(var i = 0; i < childrenCount; i++) {
			child = children[i];
			childId = child.getId();
			structureHtml.append(
				"<li class='structure-tab'>" +
					"<span id='" + namespace + ":tab:" + childId + "' data-lookup='"+childId+"' class='structure-tab-display" + ((i === 0) ? " structure-tab-active" : "") + "' title='" + child.getTitle().replace(":", "") + "'>" + child.getTitle().replace(":", "") + "</span>" +
				"</li>"
			);
		}
		structureHtml.append("</ul></div><li id='" + namespace + "StructureTabMenuButton' class='structure-tab structure-add-tab'><span>&nbsp;</span></li></div><div class='structure-tab-bottom'></div></div>");
		structureHtml.append("<div id='" + namespace + "StructureTabContents' class='structure-tab-contents'>");
		//Loop through the sub-sections and create a tab container for each of them. Only the first is displayed.
		for(var i = 0; i < childrenCount; i++) {
			//Only show the first tab by default.
			if(i > 0) {
				tabDisplay = "style='display:none;'";
			}
			structureHtml.append("<div id='" + namespace + ":tabContent:" + children[i].getId() + "' class='structure-tab-content' "+tabDisplay+">");
			if(i === 0) {
				children[i].render(structureHtml, true);
				children[i].setIsRendered(true);
			}
			structureHtml.append("</div>");
		}
		structureHtml.append("</div>");
		structureHtml.append("</div>");
	} else {
		structureHtml.append("<div id='" + namespace + ":organizer:ROOT:" + id + "' class='structure-organizer' data-lookup='" + id + "'>" +
			"<div id='" + namespace + ":navigatorPanel:" + id + "' class='structure-navigator-panel'>" +
			"<div class='structure-navigator-label'>" + i18n.discernabu.mpage_structured_documentation.NAVIGATION + "</div>" +
			this.getNavigator().render() + "</div><div id='" + namespace + ":organizer:CONTENT:" + id + "' class='structure-body structure-section-body' data-lookup='" + id + "'>"
		);
		//Force the organizer to render all of the children
		for (var i = 0; i < childrenCount; i++) {
			children[i].render(structureHtml, true);
		}
		//Close off any remaining elements
		structureHtml.append("<div id='" + namespace + ":structureHeightAdjust:" + id + "' class='structure-height-adjust'></div></div></div>");
	}
	return structureHtml.getHtml();
};

/**
 * This function renders the StructureOrganizer as an HTML string.
 * @returns {string} The StructureOrganizer rendered as an HTML string.
 */
StructureOrganizer.prototype.renderHtml = function() {
	var html = new StructureHtml();
	this.render(html);
	return html.getHtml();
};

/**
 * This finalize method will attach the event handlers. This must be called after render.
 */
StructureOrganizer.prototype.finalize = function () {
	var now = new Date().getTime();
	var last = new Date().getTime();
	var threshold = 150; //(milliseconds)
	var self = this;
	var scrollTimeout = null;
	var groupInView = null;

	/**
	 * Helper function which attempts to find the group in view and activate it, if found.
	 */
	function attemptGroupActivation() {
		groupInView = self.findGroupInView();
		if (groupInView) {
			self.updateActiveGroup(groupInView);
		}
	}
	//If the section has subsections, finalize each of them separately
	if(this.m_isMultiSection) {
		var children = this.getChildren();
		var childrenCount = children.length;
		for(var i = 0; i < childrenCount; i++) {
			if(children[i].isRendered()) {
				children[i].finalize();
			}
		}
	} else {
		$("#" + this.getNamespace() + "\\:organizer\\:CONTENT\\:" + this.getId()).on("scroll", function () {
			now = new Date().getTime();
			if (scrollTimeout) {
				clearTimeout(scrollTimeout);
			}
			//Use a timeout to ensure that after scrolling has stopped, we perform at least one more update.
			scrollTimeout = setTimeout(function () {
				last = now;
				attemptGroupActivation();
			}, 200);
			//If we have hit our threshold, then process the scroll event. This throttles the event to prevent rapid
			//DOM querying.
			if ((now - last) >= threshold) {
				last = now;
				attemptGroupActivation();
			}
		});
		this.getNavigator().finalize();
		this.adjustContentHeight();
		//If the organizer has children, activate the first child (group).
		if (this.getChildren().length) {
			this.updateActiveGroup(this.getChildren()[0]);
		}
		//Perform any additional post-processing necessary
		this.performNodePostProcessing();
	}
};

/**
 * Perfoms post-processing on all organizer child nodes after node finalized
 * @return {undefined}
 */
StructureOrganizer.prototype.performNodePostProcessing = function () {
	var postProcess = function(node){
		if(node){
			node.postProcessing();
		}
		//Recursively process children
		var childNodes = node.getChildren();
		var childCnt = childNodes.length;
		for(var i = 0; i < childCnt; i++){
			postProcess(childNodes[i]);
		}
	}
	postProcess(this);
};

/**
 * This method will adjust the height of the content within the scrollable area to ensure that the last
 * group can scroll up to its header.
 */
StructureOrganizer.prototype.adjustContentHeight = function () {
	var groups = this.getChildren();
	if (!groups.length) {
		return;
	}
	var $contentElement = this.getContentElement();
	if(!$contentElement || !$contentElement.length) {
		return;
	}
	var rawContentElement = $contentElement[0];
	var contentHeight = rawContentElement.offsetHeight;
	var $heightAdjustElement = $("#" + this.getNamespace() + "\\:structureHeightAdjust\\:" + this.getId());
	var lastGroup = groups[groups.length - 1];
	var lastGroupHeight = lastGroup.getRootElement().height();
	var miscPadding = 12;
	$heightAdjustElement.height(Math.max(0, (contentHeight - lastGroupHeight) - miscPadding));
};

/**
 * This method will update the currently active group. It calls on the Navigator object to ensure the
 * navigation item corresponding to the group is highlighted.
 * @param {StructureGroup} group - The currently active group.
 */
StructureOrganizer.prototype.updateActiveGroup = function (group) {
	this.m_navigator.updateActiveNavigation(this.getNamespace() + ":structureNavigation:" + group.getId());
};

/**
 * This method will iterate over the groups (the children of the organizer) to determine which group is in view.
 * The logic assumes a viewport that is broken into 2 zones, an upper and lower zone. If the top of the group lies
 * within the upper zone, it is assumed to be in view. If the top of the group lies within the bottom zone, it is
 * then assumed that the group above it is in view. Finally, if the group encompasses the entire viewport (both the
 * upper and lower zones) it is also assumed to be in view.
 * @returns {StructureGroup} If a group is found to be in view, that group is returned. If no group is found,
 * null is returned.
 */
StructureOrganizer.prototype.findGroupInView = function () {
	var group = null;
	var rootGroupElement = null;
	var rootGroupTop = null;
	var groups = this.getChildren();
	var groupCount = groups.length;
	var $contentElement = this.getContentElement();
	var rawContentElement = $contentElement[0];
	var contentHeight = rawContentElement.offsetHeight;
	var contentTop = $contentElement.position().top;
	var totalContentHeight = rawContentElement.scrollHeight;
	var scrollPosition = rawContentElement.scrollTop;
	var scrollPercentage = scrollPosition / totalContentHeight;
	var groupInView = null;

	/**
	 * Helper function to check if groupTop lies between zoneTop and zoneBottom
	 * @param {Number} zoneTop - The top y position of the zone.
	 * @param {Number} zoneBottom - The bottom y position of the zone.
	 * @param {Number} groupTop - The y position of the top of the group.
	 * @returns {boolean} True if the groupTop lies between zoneTop and zoneBottom, otherwise false.
	 */
	function isWithinZone(zoneTop, zoneBottom, groupTop) {
		return groupTop >= zoneTop && groupTop <= zoneBottom;
	}

	/**
	 * Helper function to determine if a group takes up the entire zone.
	 * @param {Number} zoneTop - The top y position of the zone.
	 * @param {Number} zoneBottom - The bottom y position of the zone.
	 * @param {Number} groupTop - The top y position of the group.
	 * @param {Number} groupBottom - The bottom y position of the group.
	 * @returns {boolean} True if the group takes up the entire viewable area.
	 */
	function isCompletelyInView(zoneTop, zoneBottom, groupTop, groupBottom) {
		return groupTop <= zoneTop && groupBottom >= (zoneBottom - 12);
	}

	/**
	 * Helper function which performs the necessary boundary checks to see if a group is in view.
	 * @param {Number} index - The index in the list of groups at which we are checking.
	 * @returns {StructureGroup|false} - If the group at the specified index is in view, returns that group. Otherwise
	 * false is returned.
	 */
	function isGroupInView(index) {
		group = groups[index];
		rootGroupElement = group.getRootElement();
		rootGroupTop = rootGroupElement.position().top;
		if (isWithinZone(contentDimensions.midpoint, contentDimensions.bottom, rootGroupTop)) {
			return groups[i - 1];
		}
		if (isWithinZone(contentDimensions.top, contentDimensions.midpoint, rootGroupTop)) {
			return group;
		}
		if (isCompletelyInView(contentDimensions.top, contentDimensions.bottom, rootGroupTop, rootGroupTop + rootGroupElement.height())) {
			return group;
		}
		return null;
	}

	var contentDimensions = { top: contentTop, midpoint: (contentTop + contentHeight / 2), bottom: contentTop + contentHeight };

	for (var i = 0; i < groupCount; i++) {
		groupInView = isGroupInView(i);
		if (groupInView) {
			return groupInView;
		}
	}
	//If this is reached, no group was found (this should never occur)
	return null;
};

/**
 * Generates a JSON string representation of the activity data.
 *
 * @returns {string} a JSON string representation of the activity data that is safe and compatible with CCL.
 * Example:
 * section_act: {
 * 		"dd_section_id" : 123.0,
 * 		"dd_sref_section_id" : 456.0,
 *		"template_rltns" : [],
 		"subsections" : [],
 		"groupbys": []
 * }
 */
StructureOrganizer.prototype.convertToJSON = function () {
	var saveJSON = [];
	//Begin section json
	saveJSON.push('"section_act": {');

	var sectionJson = [];
	sectionJson.push('"dd_section_id": ' + this.getActivityId() + '.0');
	sectionJson.push('"dd_sref_section_id": ' + this.getReferenceSectionId() + '.0');

	//Add templates json
	var templateRelations = this.getTemplateRelations() || [];
	var templateRelationJSON = [];
	for (var i = 0; i < templateRelations.length; i++) {
		templateRelationJSON.push(
			'{' +
			'"dd_sref_chf_cmplnt_crit_id": ' + templateRelations[i].dd_sref_chf_cmplnt_crit_id + ".0" +
			',"dd_sref_templ_instance_ident": "' + templateRelations[i].dd_sref_templ_instance_ident + '"' +
			',"parent_entity_id": ' + templateRelations[i].parent_entity_id + ".0" +
			',"parent_entity_name": "' + templateRelations[i].parent_entity_name +
			'"}'
		);
	}
	//Push template relations JSON
	sectionJson.push('"template_rltns": [' + templateRelationJSON.join(',') + ']');

	this.addChildrenJSON(sectionJson);

	//If this is a subsection node, some additional fields must be populated. Furthermore, just short-circuit and
	//return the basic JSON. The parent section is responsible for packaging up the entire contents as the section_act
	//JSON.
	if(this.getType() === "subsections") {
		sectionJson.push('"parent_section_id": ' + this.getParent().getActivityId() + '.0');
		return '{' + sectionJson.join(',') + '}';
	}

	//Finalize and add in section json
	saveJSON.push(sectionJson.join(','));

	//End save json
	saveJSON.push('}');

	return saveJSON.join('');
};
/**
 * StructureGroup
 * This class represents the concept of a structure documentation group. It is simply a node which has child nodes.
 * @constructor
 */
function StructureGroup() {
}

StructureGroup.prototype = new StructureNode();
StructureGroup.prototype.constructor = StructureNode;

/**
 * This method retrieves the root element of the StructureGroup.
 * @returns {*|jQuery|HTMLElement}
 */
StructureGroup.prototype.getRootElement = function () {
	if (!this.m_rootElement) {
		this.m_rootElement = $("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId());
	}
	return this.m_rootElement;
};

/**
 * Overrides the parent convertToJSON method.
 * @return {string} the save/activity JSON representation of the group.
 */
StructureGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_groupby_id": ' + this.getActivityId() + '.0');
	json.push('"label": "' + this.getTitle() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * This method handles notification of a state change in a child node.
 * Updates the corresponding navigational item in the navigation pane to reflect the documented status of this StructureGroup.
 *
 * @param {StructureNode} node - The StructureNode child that is informing of a state change event.
 */
StructureGroup.prototype.notifyStateChange = function (node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	var navigationElement = $("#" + this.getNamespace() + "\\:structureNavigation\\:" + this.getId());
	if(this.getType() !== "groupbys") {
		return;
	}
	//If this is a top-level group and has children documented, add a documented class to the associated navigation
	//element, otherwise remove the documented class from the navigator element.
	(this.m_numberDocumented) && (navigationElement.addClass("navigation-documented")) || (navigationElement.removeClass("navigation-documented"));
};

/**
 * Overrides the base refresh method.
 */
StructureGroup.prototype.refresh = function () {
	if (this.getState() && this.getState().getValue()) {
		$("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId()).addClass("documented");
	} else {
		$("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId()).removeClass("documented");
	}
};

/**
 * Retrieve the children nodes that should be rendered on initial load
 * @return {Array<StructureNode>} Array of children nodes that should be rendered
 */
StructureGroup.prototype.getDefaultRenderChildren = function() {
	var children = this.getChildren();
	var childCnt = children.length;
	var defaultChildren = [];
	var child = null;
	// Gather child nodes that should be initially rendered
	for (var i = 0; i < childCnt; i++){
		child = children[i];
		if(child.isDefaultDisplayed()){
			defaultChildren.push(child);
		}
	}
	return defaultChildren;
};

/**
 * Handles rendering of children for StructureGroup objects. It determines the rendering strategy. Children should
 * either be rendered into columns, or simply rendered. This is to handle maximizing the use of the white-space and
 * ensure columns are created at the best level in the tree.
 * @param {StructureHtml } structureHtml - The structure html package object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureGroup.prototype.renderChildren = function (structureHtml, shouldRenderColumns) {
	var children = this.getDefaultRenderChildren();
	var childrenCount = children.length;
	//If columns should be created at this level in the tree, otherwise just render the children.
	if (shouldRenderColumns && childrenCount > 1) {
		var maxColumns = 3;
		var numberColumns = (childrenCount / maxColumns) >= 1 ? maxColumns : childrenCount;
		var childrenPerColumn = Math.floor(childrenCount / numberColumns);
		var remainingChildren = childrenCount % numberColumns;
		var currentIndex = 0;
		var columnWidth = (100 / numberColumns) + "%";
		//Distribute the children of the group evenly among the columns.
		for (var i = 0; i < numberColumns; i++) {
			structureHtml.append("<div class='structure-column' style='width: " + columnWidth + ";'>");          //Open column
			var numberToRender = remainingChildren ? (childrenPerColumn + 1) : childrenPerColumn;
			for (var j = 0; j < numberToRender; j++) {
				var child = children[j + currentIndex];
				//Don't create additional subcolumns for children
				child.render(structureHtml, false);
			}
			currentIndex = currentIndex + j;
			remainingChildren = Math.max(0, remainingChildren - 1);
			structureHtml.append("</div>");                                 //Close column
		}
	} else {
		for (var i = 0; i < childrenCount; i++) {
			//If only one column exists at current level, allow possibility of rendering columns for children
			children[i].render(structureHtml, shouldRenderColumns);
		}
	}
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	//If this node should render, render the header grouping, otherwise skip it
	//TODO: stop forcing groups to render when WK updates their content
	if (true || this.getShouldRender()) {
		structureHtml.append(
			"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group group expanded'>"+
			"<div class='structure-group-header'>" +
			"<div class='structure-group-title-wrapper'>" +
			"<span class='structure-group-title'>" + this.getTitle().replace(":", "") + "</span>" +
			"</div>" +
			"</div>" +
			"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	// TODO: stop forcing groups to render when WK updates their content
	if (true || this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};

/**
 *Checks whether the current Group node is expanded or not. 
 */
StructureGroup.prototype.isExpanded = function () {
	var root = this.getRootElement();
	return root.hasClass("expanded");
};

/*
 * Toggles the state of a html node between expand and collapse.
 */
StructureGroup.prototype.toggleExpand = function(){
	var root = this.getRootElement();
	var addRemoveClass = root.hasClass("expanded") ? {"add" : "collapsed", "remove" : "expanded"} : {"add" : "expanded", "remove" : "collapsed"};
    root.addClass(addRemoveClass.add).removeClass(addRemoveClass.remove);
    this.onToggleExpand();
};

/**
 * Method that gets executed when a group is expand toggled.  To be implemented by children.
 * @return {undefined}
 */
StructureGroup.prototype.onToggleExpand = function() {
	return;
};

/**
 * StructureItemGroup
 * This class represents a sub-level structure documentation group. Its function is almost exactly identical to
 * that of a StructureGroup but has slightly different html markup when rendered.
 * @constructor
 */
function StructureItemGroup() {
}
StructureItemGroup.prototype = new StructureGroup();
StructureItemGroup.prototype.constructor = StructureGroup;

/**
 * Overrides the parent convertToJSON method. This is the JSON used when saving.
 * @return {string} a save/activity JSON representation
 */
StructureItemGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureItemGroup.prototype.getRootElement = function() {
   if(!this.m_rootElement || !this.m_rootElement.length) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureItemGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group item expanded'>" +
				"<div class='structure-group-header item'>" +
				"<span class='structure-component-toggle'></span>" +
				"<span class='structure-group-title'>" + this.getTitle().replace(":", "") + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};

/**
 * StructureSubGroup
 * This class represents a sub-level structure documentation group. Its function is almost exactly identical to
 * that of a StructureGroup but has slightly different html markup when rendered.
 * @constructor
 */
function StructureSubGroup() {
}
StructureSubGroup.prototype = new StructureGroup();
StructureSubGroup.prototype.constructor = StructureGroup;
/**
 * Overrides the parent convertToJSON method. This is the JSON used when saving.
 * @returns {string} a JSON representation of the activity data
 */
StructureSubGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_sgroupby_id": ' + this.getActivityId() + '.0');
	json.push('"label": "' + this.getTitle() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureSubGroup.prototype.getRootElement = function() {
   if(!this.m_rootElement) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:subgroup\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureSubGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":subgroup:ROOT:" + this.getId() + "' class='structure-group sub-group expanded'>" +
				"<div class='structure-group-header'>" +
				"<span class='structure-group-title sub-group'>" + this.getTitle().replace(":", "") + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};
/**
 * A model that represents a group of StructureTerms.
 */
function StructureTermGroup() {
	this.m_activeTerm = null;
	this.m_previousActiveTerm = null;
	this.m_isShowMore = false; // Default to Show Less
	return this;
}
StructureTermGroup.prototype = new StructureGroup();
StructureTermGroup.prototype.constructor = StructureGroup;

/**
 * Gets the active term.
 * @returns {StructureTerm} the active term
 */
StructureTermGroup.prototype.getActiveTerm = function () {
	return this.m_activeTerm;
};
/**
 * Sets the active term.
 * @param {StructureTerm} activeTerm - the active term
 */
StructureTermGroup.prototype.setActiveTerm = function (activeTerm) {
	if (!StructureTerm.prototype.isPrototypeOf(activeTerm)) {
		throw new Error("Called setActiveTerm on StructureTermGroup with invalid activeTerm parameter.");
	}
	this.m_activeTerm = activeTerm;
	return this;
};

/**
 * Gets the previous active term.
 * @returns {StructureTerm} the active term
 */
StructureTermGroup.prototype.getPreviousActiveTerm = function () {
	return this.m_previousActiveTerm;
};
/**
 * Sets the previous active term.
 * @param {StructureTerm} activeTerm - the active term
 */
StructureTermGroup.prototype.setPreviousActiveTerm = function (activeTerm) {
	if (!StructureTerm.prototype.isPrototypeOf(activeTerm)) {
		throw new Error("Called setPreviousActiveTerm on StructureTermGroup with invalid activeTerm parameter.");
	}
	this.m_previousActiveTerm = activeTerm;
	return this;
};


/**
 * Returns a JSON string representation of the StructureTermGroup used for saving purposes
 * @returns {string} JSON string representation of the activity data
 */
StructureTermGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_attribute_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"truth_state_mean": "T"');

	this.addDescendentJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * Returns a Boolean indicating whether the term group is showing all terms
 * @return {Boolean} True iff the term group should be showing all terms
 */
StructureTermGroup.prototype.isShowMore = function() {
	return this.m_isShowMore;
};

/**
 * Sets the indicator for whether a term group should be displaying all terms
 * @param {Boolean} showMore True if all terms should be displayed, false if only prioritized terms should show
 */
StructureTermGroup.prototype.setIsShowMore = function(showMore) {
	if (typeof showMore !== "boolean") {
		throw new Error("Called setIsShowMore on StructureNode with invalid showMore paramater");
	}
	this.m_isShowMore = showMore;
};

/**
 * Returns a Boolean indicating whether or not this term group has previously shown all terms.
 * Utilized to avoid re-rendering if the unprioritized terms have previously been rendered
 * @return {Boolean} True if all terms have been previously displayed (Show More has been clicked)
 */
StructureTermGroup.prototype.hasShownMore = function(){
	return this.m_hasShownMore;
};

/**
 * Sets the indicator for whether a term group has previously displayed all terms
 * @param {Boolean} hasShownMore True if all terms have been displayed
 */
StructureTermGroup.prototype.setHasShownMore = function(hasShownMore){
	if (typeof hasShownMore !== "boolean") {
		throw new Error("Called setHasShownMore on StructureNode with invalid hasShownMore paramater");
	}
	this.m_hasShownMore = hasShownMore;
};

/**
 * Retrieves an array of StructureTerms with the given priority
 * @param  {Number} priority - The priority of terms to retireve
 * @return {Array<StructureTerm>} Array of StructureTerms with the given priority
 */
StructureTermGroup.prototype.getChildrenWithPriority = function(priority){
	var children = this.getChildren();
	var childrenWithPriority = [];
	childrenWithPriority = $.grep(children, (function(term, i){
		return term.getPriority && (term.getPriority() === priority);
	}));
	return childrenWithPriority;
};

/**
 * This method acts as a notification of a state change in a child node. Certain parent nodes need to know the
 * state of their children and perform actions accordingly. This base method simply keeps track of the number of
 * children nodes that are documented.
 * @param {StructureNode} node - The node that is informing of a state change event.
 */
StructureTermGroup.prototype.notifyStateChange = function (node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	this.handleTermActivity(node);
};

/*
 * Method to handle activity on a term group only if it has a None term as the first child and
 * if the current selected term has a valid state.
 * @param {StructureTerm} term - the term being switched to, or being selected
*/
StructureTermGroup.prototype.handleTermActivity = function (term) {	
	//Perform updates related to None-term functionality
	this.performNoneTermUpdates(term);
};

StructureTermGroup.prototype.performNoneTermUpdates = function (term) {
	var noneTerm = this.getNoneTerm();
	var freeTextTerms = null;
	var stateOfFreeText = null;
	var self = this;
	var noneTermHasValidState = null;
	// Don't perform any actions if none-term not found
	if (!noneTerm) {
		return;
	}
	noneTermHasValidState = noneTerm.getState() && noneTerm.getState().getValue();
	//If term other than none term has been documented, deactive the none term
	if (term !== noneTerm && term.getState() && term.getState().getValue() && noneTermHasValidState){
		noneTerm.deactivate();
	}
	else if (noneTermHasValidState){
		//Filter the free text object from the current term group
		//If free text object exists within the current active terms.
		//call the launchRemoveFreeTextWarning
		freeTextTerms = this.getActiveFreeTextTerm();
		if (!freeTextTerms.length) {//if free text object does not exist, just loop over all the active terms and deactivate them
			this.deactivateTerms();
		} else {
			var stateOfFreeText = freeTextTerms[0].getState().getValue();
			if (stateOfFreeText) {
				this.setPreviousActiveTerm(this.m_activeTerm);
				this.launchRemoveFreeTextWarning(function() {
					self.deactivateTerms();
				});
			}
		}	
	}
	this.m_activeTerm = term;
};

/**
 * Returns the number of document terms that are not currently being displayed due to prioritization
 * @return {Number} Number of undocumented terms that are not being displayed by default
 */
StructureTermGroup.prototype.getUnshownDocumentedCount = function() {
	var unshownChildren = this.getChildrenWithPriority(2);
	var unshownChildCnt = unshownChildren.length;
	var unshownDocumentedCount = 0;
	// Add up number of documented children for all unshown descendents
	for(var i = 0; i < unshownChildCnt; i++){
		var unshownChild = unshownChildren[i];
		//If term has children return number of documented children
		if(unshownChild.getChildren().length){
			unshownDocumentedCount += unshownChild.getNumberOfDocumentedChildren();
		}
		//Otherwise check if current term is documented
		else if(unshownChild.getState() && unshownChild.getState().getValue()){
			unshownDocumentedCount++;
		}
	}
	return unshownDocumentedCount;
};

/**
 * Updates the documented count for the term group
 * @return {undefined}
 */
StructureTermGroup.prototype.updateUnshownDocumentedCount = function() {
	var $undocumentedCount = this.getDocumentedCountContainer();
	var undocumentedCount = this.getUnshownDocumentedCount();
	// Display documented count when "Show Less" and has documented terms
	if (undocumentedCount && !this.isShowMore()){
		$undocumentedCount.html(undocumentedCount);
		$undocumentedCount.addClass("shown");
	}
	else {
		$undocumentedCount.empty();
		$undocumentedCount.removeClass("shown");
	}
};

/**
 * Returns the container for the documented count
 * @return {jQuery} jQuery element container of the documented
 */
StructureTermGroup.prototype.getDocumentedCountContainer = function() {
	if (!this.m_documentedCountContainer || !this.m_documentedCountContainer.length){
		this.m_documentedCountContainer = $("#documentedCountContainer" + this.getId());
	}
	return this.m_documentedCountContainer;
};


/**
 *Gets the currently active FreeText term in the section/term group. 
 */
StructureTermGroup.prototype.getActiveFreeTextTerm = function (term) {	
		var freeTextTerms = this.filterTerms(function(obj){
			return FreeTextStructureTerm.prototype.isPrototypeOf(obj) && obj.getState() ? obj.getState().getValue() !== null : false;
		});
		return freeTextTerms;
};

/**
 *Gets the none term from the current section/term group. 
 */
StructureTermGroup.prototype.getNoneTerm = function(term) {
	if (!this.m_noneTerm){
		this.m_noneTerm = this.filterTerms(function(obj){
			return NoneStructureTerm.prototype.isPrototypeOf(obj);
		})[0];
	}
	return this.m_noneTerm;
};
/**
 * Changes the state of all the active/documented terms in the group 
 * to undocumented by calling deactivate method on non input type terms and 
 * setting the current value of the free text term to  empty string.
 */
StructureTermGroup.prototype.deactivateTerms = function(){
	var activeTerms = this.filterTerms(function(obj) {
		return !NoneStructureTerm.prototype.isPrototypeOf(obj) && obj.getState() ? obj.getState().getValue() !== null : false;
	});
	for (var t = 0; t < activeTerms.length; t++) {
		var currentTerm = activeTerms[t];
		currentTerm.deactivate();
	}
};

/**
 * Method to filter terms based on the filter function provided. 
 */
StructureTermGroup.prototype.filterTerms = function(func) {
	if(typeof func !== "function") {
		throw new Error("Called filterTerms on the StructureTermGroup with an invalid callback function");
	}
	var terms = [];
	var childrenTerms = this.getAllDescendents([]);
	for(var i=0;i<childrenTerms.length;i++){
		if(func(childrenTerms[i])){
			terms.push(childrenTerms[i]);			
		}
	}
	return terms;
};

/**
 * Builds and launches a Modal Dialog that will act as a prompt when 
 * a active free text term is being cleared by clicking a None term. It prompts with two actions
 * 1. Remove to continue clearing the free text
 * 2. Cancel to prevent clearing of the free text and other active terms. 
 */
StructureTermGroup.prototype.launchRemoveFreeTextWarning = function(removeBtnClickFunc){
		
		if(typeof removeBtnClickFunc !== "function"){
			throw new Error("Called launchRemoveFreeTextWarning on the StructureTermGroup with an invalid callback function");
		}
		var self = this;
		var modalId = "removeFreeText" + this.getId();
		var cancelModalBtn = null;
		var removeModalBtn = null;
		var removeFreeTextModal = MP_ModalDialog.retrieveModalDialogObject(modalId);		
		if(!removeFreeTextModal){
			removeFreeTextModal = new ModalDialog(modalId);		
			removeFreeTextModal.setShowCloseIcon(false);
			removeFreeTextModal.setHeaderTitle(i18n.discernabu.mpage_structured_documentation.REMOVE_FREE_TEXT_HEADER);
			//Apply the proper margins for User informational messages
			removeFreeTextModal.setLeftMarginPercentage(35).setRightMarginPercentage(35).setTopMarginPercentage(20).setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);
			//Create the modal remove button
			removeModalBtn = new ModalButton("removeModal");
			removeModalBtn.setFocusInd(true).setCloseOnClick(true);
			removeModalBtn.setOnClickFunction(removeBtnClickFunc);			
			removeModalBtn.setText(i18n.discernabu.mpage_structured_documentation.REMOVE);
			removeFreeTextModal.addFooterButton(removeModalBtn);		
			//Create the modal cancel button
			cancelModalBtn = new ModalButton("cnlModal");
			cancelModalBtn.setText(i18n.discernabu.mpage_structured_documentation.CANCEL);
			
			cancelModalBtn.setOnClickFunction(function(){
				self.cancelFreeTextBtnCallback();
			});			
			removeFreeTextModal.addFooterButton(cancelModalBtn);			
			removeFreeTextModal.setBodyDataFunction(function(modalObj){
					modalObj.setBodyHTML("<div class='structure-remove-free-text-warning'><span>"+i18n.discernabu.mpage_structured_documentation.REMOVE_FREE_TEXT_WARNING+"</span>" + "</div>");
			});			
			MP_ModalDialog.addModalDialogObject(removeFreeTextModal);
		}					
		MP_ModalDialog.showModalDialog(modalId);
};

/**
 * Handles canceling a remove free text action
 * @return {[type]} [description]
 */
StructureTermGroup.prototype.cancelFreeTextBtnCallback = function(){
	var modalId = "removeFreeText" + this.getId();
	this.getActiveTerm().jumpToState(0);
	this.setActiveTerm(this.getPreviousActiveTerm());
	MP_ModalDialog.closeModalDialog(modalId);
	MP_ModalDialog.deleteModalDialogObject(modalId);
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureTermGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group item expanded'>" +
				"<div class='structure-group-header item'>" +
				"<span class='structure-group-title'>" + this.getTitle() + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		//Handle rendering Show More link/Unprioritized terms if necessary
		structureHtml.append("</div>");
		this.renderShowMore(structureHtml);
		structureHtml.append("</div>");
	}
};

/**
 * Renders the 'Show More' link html as well as unprioritized API terms if the 
 * current term group should show more terms
 * @param  {StructureHtml} structureHtml - The structure html package object
 */
StructureTermGroup.prototype.renderShowMore = function(structureHtml){
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var organizer = this.getOrganizer();
	if (organizer.isPriorityEnabled()){
		var showMoreText = docI18n.SHOW_MORE;
		// Display link only when unprioritized terms exist
		if(this.getChildrenWithPriority(2).length){
			structureHtml.append("<div class='show-more-link-container'><a id='showMoreLink" + this.getId() + "' class='show-more-link'>" + showMoreText + "</a>" + "<div id='documentedCountContainer" + this.getId() + "' class='documented-count'></div></div>");
		}		
	}
	else{
		//All terms are shown if API prioritization is off
		this.setIsShowMore(true);
	}
};

StructureTermGroup.prototype.getUnprioritizedContentContainer = function() {
	if (!this.m_unprioritizedContent || !this.m_unprioritizedContent.length){
		this.m_unprioritizedContent = $("#unprioritizedContent" + this.getId());
	}
	return this.m_unprioritizedContent;
};

StructureTermGroup.prototype.getShowMoreLinkContainer = function() {
	if (!this.m_showMoreLinkContainer || !this.m_showMoreLinkContainer.length){
		this.m_showMoreLinkContainer = $("#showMoreLink" + this.getId());
	}
	return this.m_showMoreLinkContainer;
};
/**
 * Displays all terms in the term group independent of priority
 */
StructureTermGroup.prototype.showMore = function () {
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var $root = $(this.getRootElement());
	var $unprioritizedTerms = this.getUnprioritizedContentContainer();
	var defaultRenderedChildren = this.getDefaultRenderChildren();
	var defaultChildrenLen = defaultRenderedChildren.length;
	var lastTerm = defaultChildrenLen ? defaultRenderedChildren[defaultChildrenLen-1] : null;
	var $lastTerm =  null;
	
	if (lastTerm){
		$lastTerm = $(lastTerm.getRootElement());	
	}
	if($root.length){
		if (this.hasShownMore()){
			$unprioritizedTerms.show();
		}
		else{		
			var structureHtml = new StructureHtml();
			this.renderUnprioritizedSectionHtml(structureHtml);
			if($lastTerm && $lastTerm.length){
				$lastTerm.after(structureHtml.getHtml());
			}
			else{				
				$root.find('.structure-group-children').prepend(structureHtml.getHtml());
			}
			this.setHasShownMore(true);
		}	
		this.getShowMoreLinkContainer().text(docI18n.SHOW_LESS);
		this.setIsShowMore(true);
	}
};

/**
 * Hides unprioritized (priority 2) terms within the term group
 */
StructureTermGroup.prototype.showLess = function () {
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var $unprioritizedTerms = this.getUnprioritizedContentContainer();

	$unprioritizedTerms.hide();
	this.getShowMoreLinkContainer().text(docI18n.SHOW_MORE);
	this.setIsShowMore(false);
	var organizer = this.getOrganizer();
	//Navigate to node if out of view
	organizer.goToNode(this, false);
};

/**
 * Toggles whether all terms are shown or only prioritized terms
 */
StructureTermGroup.prototype.toggleShowMore = function () {
	if (this.isShowMore()){
		this.showLess();
	}
	else{
		this.showMore();
	}
	//Update whether or not the documented count is displayed
	this.updateUnshownDocumentedCount();
};

/**
 * Renders the section containing unprioritized (priority 2) API terms when all terms should be shown
 * @param  {StructureHtml} structureHtml - The structure html package object
 */
StructureTermGroup.prototype.renderUnprioritizedSectionHtml = function(structureHtml){
	var children = this.getChildrenWithPriority(2);
	var childrenCnt = children.length;
	var hasOtherShownClass = "";
	if (childrenCnt !== this.getChildren().length){
		hasOtherShownClass = "structured-has-shown-terms";
	}
	if(childrenCnt){
		structureHtml.append("<div id='unprioritizedContent" + this.getId() + "' class='unprioritized-terms " + hasOtherShownClass + "'>");

		for (var i = 0; i < childrenCnt; i++){
			children[i].render(structureHtml, false);
		}
		structureHtml.append("</div>");
	}
};


/**
 * A model that represents a group of terms that is single-select.
 */
function SingleStructureTermGroup() {
}
SingleStructureTermGroup.prototype = new StructureTermGroup();
SingleStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * Handles additional process on the group when the user chooses a different term in the term group.
 * @param {StructureTerm} term - the term being switched to, or being selected
 */
SingleStructureTermGroup.prototype.handleTermActivity = function (term) {
	StructureTermGroup.prototype.handleTermActivity.call(this, term);
	var isValidState = term.getState().getValue();
	var self = this;
	var freeTextTerm = this.getActiveFreeTextTerm();
	if(isValidState) {
		if (term !== this.m_activeTerm && this.m_activeTerm) {
			if(freeTextTerm.length && freeTextTerm[0] === this.m_activeTerm) {
				this.setPreviousActiveTerm(this.m_activeTerm);		
				self.launchRemoveFreeTextWarning(function() {
					freeTextTerm[0].deactivate();
				});
			} else {
				this.m_activeTerm.deactivate();		
			}
		}
		this.m_activeTerm = term;	
	}
};

/**
 * Clears only this SingleStructureTermGroup by resetting its active term to null.
 */
SingleStructureTermGroup.prototype.clearSelf = function () {
	StructureTermGroup.prototype.clearSelf.call(this);
	this.m_activeTerm = null;
};

/**
 * A model that represents a multi-select group of terms
 */
function MultiStructureTermGroup() {
}
MultiStructureTermGroup.prototype = new StructureTermGroup();
MultiStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * A model that represents a group of Yes/No terms
 */
function YesNoStructureTermGroup() {
}
YesNoStructureTermGroup.prototype = new StructureTermGroup();
YesNoStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * A model that represents a table containing multiple cycle terms.
 * Inherits from SingleStructureTermGroup for allowing only a single child term to be selected at time.
 * Inherits CycleStructureterm methods for allowing 'states' and 'comments' and other AMI functionality
 */
function TableStructureTermGroup() {
	this.m_comment = "";						//Ensure no comment is associated by default
	this.m_inNavigateStructureTree = false; 	// Don't search for Table node when searching tree from cern-structured
	this.m_shouldSave = false;					// Table grouping terms are not saved.  Child terms are saved.
	SingleStructureTermGroup.call(this);
	CycleStructureTerm.call(this);
}

TableStructureTermGroup.prototype = new SingleStructureTermGroup();
TableStructureTermGroup.prototype.constructor = TableStructureTermGroup;
JSONStructureOrganizerBuilder.extendClassMethods(TableStructureTermGroup, CycleStructureTerm, ["setCaption", "getCaption", "addState", "getCurrentState", "setCurrentState", "getStates", "cycleState", "jumpToState", "deactivate", "refresh", "getComment", "setComment", "setSavedComment", "buildTextArea", "displayComment", "checkIsDirty", "getRootElement", "getSavedComment", "resetDirty", "setPriority", "getPriority", "setUIValue", "getUIValue", "displayNode", "isDefaultDisplayed", "isCurrentlyDisplayed"]);

/**
 * Overrides checkIsDirty to ensure that the TableStructureTermGroup isn't marked as dirty. Only child terms can be dirty.
 * @return {Boolean}  False as "TABLE" alone cannot be dirty
 */
TableStructureTermGroup.prototype.checkIsDirty = function () {
	return false;
};

/**
 * Returns JSON representation of TableStructureTerm.  Doesn't return JSON as the "TABLE" term is not saved (only child terms are).
 * @return {undefined}
 */
TableStructureTermGroup.prototype.convertToJSON = function() {
	return;
};

/**
 * Override default render method to render out table group.
 * Handles rendering child terms and associated comment.
 * @param  {StructureHtml} structureHtml The StructureHtml object to append "html" string to
 * @return {undefined} 
 */
TableStructureTermGroup.prototype.render = function(structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item table-group-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-table-group-terms'>"
	);
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>"  + commentHTML + "</div>");
};


/**
 * Handles additional process on the group when the user chooses a different term in the term group.
 * Updates styling of the table appropriately.
 * @param {StructureTerm} term - the term being switched to, or being selected
 */
TableStructureTermGroup.prototype.handleTermActivity = function (term) {
	SingleStructureTermGroup.prototype.handleTermActivity.call(this, term);
	var activeTerm = this.getActiveTerm();
	var termGroupState = activeTerm ? activeTerm.getState() : null;
	if (termGroupState){
		//Use the active child term's state if present
		this.updateState(termGroupState);		
	}
	else{
		//If no active term, use default undocumented state
		this.jumpToState(0);
	}
	this.refresh();
};


/**
 * Override notifyStateChange to notify parent group of updated child terms.
 * This is used so that the parent group can handle Single Select and None terms.
 * @param  {SturctureNode} node The StructureNode that has been updated
 * @return {undefined}
 */
TableStructureTermGroup.prototype.notifyStateChange = function(node) {
	StructureTermGroup.prototype.notifyStateChange.call(this, node);
	if (this.getParent()){
		this.getParent().notifyStateChange(node);
	}
};


/**
 * Overriding updateState as to not trigger parent notification on updates
 * @param {TermState} state - The state the StructureNode should be updated to.
 */
TableStructureTermGroup.prototype.updateState = function (state) {
	var currentState = this.getState();
	if (state !== currentState) {
		this.setState(state);
		this.setPreviousState(currentState);
	}
	// refresh anyways, something else (like whether the node is valid) may have changed while keeping the state the same
	this.refresh();
};

/**
 * Overriding clearSelf to ensure that both state is updated for both active term and styling
 * @return {undefined}
 */
TableStructureTermGroup.prototype.clearSelf = function() {
	SingleStructureTermGroup.prototype.clearSelf.call(this);
	CycleStructureTerm.prototype.clearSelf.call(this);
};

/**
 * A model that represents the expand attribute menu item. It functions likes a TermGroup 
 * and has children terms grouped together. 
 * Inherits attribute level grouping logic from StructureTermGroup
 * Extends some methods from the CycleStructureTerm model in order to perform interactive term(AMI) level functionality 
 * and TableStructureTermGroup model which overrides parent (attribute level) term group logic.
 * @constructor
 */
function ExpandStructureTermGroup() {
	this.m_inNavigateStructureTree = false; 	// Don't search for Table node when searching tree from cern-structured
	this.m_shouldSave = false;
	StructureTermGroup.call(this);
	CycleStructureTerm.call(this);
}
ExpandStructureTermGroup.prototype = new StructureTermGroup();
ExpandStructureTermGroup.prototype.constructor = ExpandStructureTermGroup;
JSONStructureOrganizerBuilder.extendClassMethods(ExpandStructureTermGroup, CycleStructureTerm, ["setCaption", "getCaption", "addState", "getCurrentState", "setCurrentState", "getStates", "cycleState", "jumpToState", "deactivate", "refresh", "checkIsDirty", "getRootElement", "resetDirty", "setPriority", "getPriority","displayNode", "isDefaultDisplayed", "isCurrentlyDisplayed","setUIValue", "getUIValue","postProcessing"]);
JSONStructureOrganizerBuilder.extendClassMethods(ExpandStructureTermGroup, TableStructureTermGroup, ["convertToJSON", "updateState", "notifyStateChange", "checkIsDirty"]);

/**
 * Overrides the base StructureTermGroup render method. It renders the ExpandStructureTermGroup object as an html string
 * and appends it to the structure html parameter.
 * @param {StructureHtml} structureHtml Ta- A StructureHtml package object. All html shall be appended to this object.
 */
ExpandStructureTermGroup.prototype.render = function (structureHtml) {	
	structureHtml.append(
			"<div class ='structure-group expand-group collapsed' id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "'>" +
			"<div class ='structure-group-header'> " + 
			"<span class='structure-component-toggle'></span>" +
			"<span class='structure-group-title' title ='"+this.getCaption()+"'>"+ this.getTitle() + "</span>" +
			"<div id='documentedExpandCountContainer" + this.getId() + "' class='documented-count'></div></div>" +
			"<div class='structure-group-children'>"
			);
	// passing false to make sure it does not create a new column for the children
	this.renderChildren(structureHtml, false); 	
	if (this.getShouldRender() && this.getDefaultRenderChildren() !== this.getChildren()) {
		//Handle rendering Show More link/Unprioritized terms if necessary		
		this.renderShowMore(structureHtml);		
	}
	structureHtml.append("</div></div>");
};

/**
 * Overrides the base getDefaultRenderChildren method and returns all the children with the priority 2 
 * if there only priortiy 2 terms. If it contains a mixture of both priorities, it returns only priority 1 terms.
 */
ExpandStructureTermGroup.prototype.getDefaultRenderChildren = function(){
	var defaultRenderedChildren = StructureGroup.prototype.getDefaultRenderChildren.call(this);
	if(!defaultRenderedChildren.length){
		defaultRenderedChildren = this.getChildren();
		this.setIsShowMore(true);
	}
	return defaultRenderedChildren;
};



/**
 * Updates the count displayed next to the expand title
 * @return {undefined}
 */
ExpandStructureTermGroup.prototype.updateExpandDocumentedCount = function() {
	var $documentedCntContainer = this.getDocumentedExpandCountContainer();
	var documentedCnt = this.getNumberOfDocumentedChildren();
	// Don't display count if no documented terms within or if expanded
	if (this.isExpanded() || !documentedCnt){
		$documentedCntContainer.empty();
		$documentedCntContainer.removeClass("shown");
	}
	else{
		$documentedCntContainer.html(documentedCnt);
		$documentedCntContainer.addClass("shown");
	}
};

/**
 * Returns the container for the expand documented count
 * @return {jQuery} jQuery element container of the expand documented count
 */
ExpandStructureTermGroup.prototype.getDocumentedExpandCountContainer = function() {
	if (!this.m_documentedExpandCountContainer || !this.m_documentedExpandCountContainer.length){
		this.m_documentedExpandCountContainer = $("#documentedExpandCountContainer" + this.getId());
	}
	return this.m_documentedExpandCountContainer;
};

/**
 * Override onToggleExpand to update the documented count next to expand (displays only when collapsed and documented terms present)
 * @return {undefined}
 */
ExpandStructureTermGroup.prototype.onToggleExpand = function() {
	this.updateExpandDocumentedCount();
};
/**
 * The TermState object
 * @return {TermState} returns self to allow chaining
 * @constructor
 * @author Will Reynolds
 */
function TermState() {
	this.m_value = null;                          //The state value (true / false / null)
	this.m_cssClass = "";                         //The associated css class for the state (not always necessary)
	this.m_key = "";                              //An identifier for the state ("NEUTRAL", "NULL", "TRUE", "FALSE")
	this.m_data = {};                             //Any additional data can be stored in the state
	return this;                                //Return a reference to self so you can do constructor chaining
}

/**
 * Get the state value (true / false / null)
 * @return {*} returns the value of the state, either (true / false / null)
 */
TermState.prototype.getValue = function () {
	return this.m_value;
};

/**
 * Sets the value of the state, either (true / false / null)
 * @param value the value of the state
 * @return {TermState} returns self.
 */
TermState.prototype.setValue = function (value) {
	this.m_value = value;
	return this;
};

/**
 * Gets the CSS class for the state (if any). This is used for StructureTerm objects as they have styling based
 * on which state they are in.
 * @return {string} the css class associated with the state.
 */
TermState.prototype.getCSSClass = function () {
	return this.m_cssClass;
};

/**
 * Sets the CSS class for the state (if any). This is used for StructureTerm objects as they have styling based
 * on which state they are in.
 * @param cssClass the css class associated with the state (if any).
 * @return {TermState} returns self
 */
TermState.prototype.setCSSClass = function (cssClass) {
	if(typeof cssClass !== "string") {
		throw new Error("Attempted to call TermState.prototype.setCSSClass with invalid parameter.");
	}
	this.m_cssClass = cssClass;
	return this;
};

/**
 * Get the state key. This is a string identifier for the state.
 * @return {string} the string identifier for the state.
 */
TermState.prototype.getKey = function () {
	return this.m_key;
};

/**
 * Set the state key. This is a string identifier for the state.
 * @param key the string identifier for the state.
 * @return {TermState} returns self.
 */
TermState.prototype.setKey = function (key) {
	this.m_key = key;
	return this;
};

/**
 * Gets the data package tied to the state. This is not always necessary.
 * @return {Object} a JSON data package tied to the state.
 */
TermState.prototype.getData = function () {
	return this.m_data;
};

/**
 * Sets the data package tied to the state. This is not always necessary.
 * @param data the JSON data package tied to the state.
 * @return {TermState} returns self.
 */
TermState.prototype.setData = function (data) {
	this.m_data = data;
	return this;
};

/**
 * Adds a piece of data to the JSON data package tied to the state.
 * @param key the key value in which to store the new data.
 * @param dataPack the piece of data to be added into the state data at the key value. (ex. { key : dataPack })
 * @return {TermState} returns self.
 */
TermState.prototype.addData = function (key, dataPack) {
	this.m_data[key] = dataPack;
	return this;
};

/**
 * Get a piece of data at the key value.
 * @param key the key at which to obtain the data. (ex. { key : value}). You are retrieving value.
 * @return {Object} the data at the key value.
 */
TermState.prototype.getDataValue = function (key) {
	if (!this.m_data[key]) {
		this.m_data[key] = {};
	}
	return this.m_data[key];
};
/**
 * StructureTerm
 * The base StructureTerm object. This represents the individual answers users can interract with inside
 * structured documentation. Any new answer types should inherit from this base class.
 * @returns {StructureTerm}
 * @constructor
 */
function StructureTerm() {
	this.m_caption = "";
	this.m_comment = "";
	//stores already saved comment
	this.m_savedComment = "";
	return this;
}

StructureTerm.prototype = new StructureNode();
StructureTerm.prototype.constructor = StructureNode;

/**
 * Gets the comment of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getComment = function () {
	return this.m_comment;
};

/**
 * Sets the comment of the StructureTerm.
 * @param {string} comment - The comment of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setComment = function (comment) {
	if (typeof comment !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setComment with invalid parameter.");
	}
	this.m_comment = comment;
	return this;
};

/**
 * Returns the priority of a StructureTerm (API)
 * @return {Number} 1 - If term should be shown, 2 - If should be hidden on initial load
 */
StructureTerm.prototype.getPriority = function () {
	return this.m_priority;
};

/**
 * Returns whether or not a term is shown by default based on its priority
 * @return {Boolean} True iff the term should be shown by default
 */
StructureTerm.prototype.isDefaultDisplayed = function () {
	var DONT_SHOW_PRIORITY = 2;
	var priority = this.getPriority();
	var organizer = this.getOrganizer();
	//Always display if AMI prioritization is off
	if(organizer && organizer.isPriorityEnabled()){
		//Default terms to be displayed if priority not 2
		return ( priority === DONT_SHOW_PRIORITY) ? false : true;
	}
	else{
		return true;
	}
};

/**
 * Returns whether or not the term is currently displayed based on API prioritization or whether it is already displayed
 * @return {Boolean} True iff the term is currently displayed on the page
 */
StructureTerm.prototype.isCurrentlyDisplayed = function() {
	var termGroup = this.getParent();
	var DONT_SHOW_PRIORITY = 2;
	var priority = this.getPriority();	
	//Validates on the parent's visibility or its siblings based on the value returned by isCurrentlyDisplayed or showMore of the parent. 	
	//For terms within an expand, checks whether the expanded it is expanded or collapsed.
	if ((StructureTermGroup.prototype.isPrototypeOf(termGroup) && 
		(!termGroup.isCurrentlyDisplayed() || !termGroup.isShowMore()) && 
			priority === DONT_SHOW_PRIORITY)|| 
			(ExpandStructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isExpanded())){
		return false;
	}
	else{
		return true;
	}
};

/**
 * Ensure that the current node is displayed by displaying hidden unprioritized nodes.
 * @return {[type]} [description]
 */
StructureTerm.prototype.displayNode = function() {
	var termGroup = this.getParent();
	if (StructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isShowMore()) {
		termGroup.toggleShowMore();
	}
	if (!termGroup.isCurrentlyDisplayed()) {
		termGroup.displayNode();
	}
	if (ExpandStructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isExpanded()) {
		termGroup.toggleExpand();
	}
};

/**
 * Ensure that the node is displayed after postProcessing is completed
 * @return {undefined}
 */
StructureTerm.prototype.postProcessing = function () {
	var node = this;
    // If there is documented value for a term, ensure it is displayed
    if (node.getState() && node.getState().getValue() && !node.isCurrentlyDisplayed()){
    	node.displayNode();
    }
};

/**
 * Sets the priority of the structure term 
 * @param {Number} priority The priority to set the API term as
 */
StructureTerm.prototype.setPriority = function (priority) {
	if (typeof priority !== "number") {
		throw new Error("Attempted to call StructureTerm.prototype.setPriority with invalid paramater.");
	}
	this.m_priority = priority;
};

/**
 * Sets the UI Value of the structure term (e.g. Expand/Table)
 * @param {String} uiValue The UI value to be associated with the structure term
 */
StructureTerm.prototype.setUIValue = function(uiValue){
	this.m_uiValue = uiValue;
};

/**
 * Returns the UI value associated to the structure term
 * @return {String} The term's associated UI value
 */
StructureTerm.prototype.getUIValue = function() {
	return this.m_uiValue;
};

/**
 * Gets the comment of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getSavedComment = function () {
	return this.m_savedComment;
};

/**
 * Sets the comment of the StructureTerm.
 * @param {string} comment - The comment of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setSavedComment = function (comment) {
	if (typeof comment !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setComment with invalid parameter.");
	}
	this.m_savedComment = comment;
	return this;
};

/**
 * Builds the text area
 * @returns {HTML String}- raw HTMl string of the text area
 */	
StructureTerm.prototype.buildTextArea = function() {
	var textArea = "<textarea id='" + "comment" + this.getNamespace() + this.getId() + "' class='term-textarea textarea-fill' type='text' title='Add Comment' placeholder='Add Comment'>" + this.getComment() + "</textarea>";
	return textArea;
};

/**
 * Displays comment for the term
 * @param {string} comment - The comment of the StructureTerm.
 */
StructureTerm.prototype.displayComment = function(comment) {
	// validates the comment received and covert them to the actual text
	var validatedComment = comment ? this.unescapePlaintextAsHtml(comment) : comment + "";
	// sets comment to the term
	this.setComment(validatedComment);
	this.setSavedComment(validatedComment);
	//builds the comment section with comment
	var termContainer = this.getRootElement();
	var commentSection = termContainer.children("div.structure-term-comment-wrapper");
	//checks if the comment section is not already build then build the comment section
	if (termContainer.length > 0 && commentSection.length < 1) {
		commentSection = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		termContainer.append(commentSection);
	}
	termContainer.addClass("comment");
};
	
/**
 * Gets the caption (html title) of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getCaption = function () {
	return this.m_caption;
};

/**
 * Sets the caption (html title) of the StructureTerm.
 * @param {string} caption - The html title of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setCaption = function (caption) {
	if (typeof caption !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setCaption with invalid parameter.");
	}
	this.m_caption = caption;
	return this;
};

/**
 * Returns a JSON string representation of the StructureTerm used for saving purposes
 * @returns {string}
 */
StructureTerm.prototype.convertToJSON = function () {
	var comment = this.getComment();
	var json = [];
	json.push('"dd_attr_menu_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"display_seq": ' + this.getDisplayPosition());
	json.push('"truth_state_mean": "' + ((this.getState().getValue()) ? "T" : "F") + '"');
	json.push('"comment": "' 
		//escape special characters in comment
		+ (comment ? this.escapePlaintextAsHtml(comment) : comment) 
		+ '"');
	json.push('"comment_format_mean": "XHTML"');
	json.push('"value_text": ""');
	json.push('"value_text_format_mean": "XHTML"');
	json.push('"value_number": 0.0');

	return '{' + json.join(',') + '}';
};


/**
 * Updates the StructureTerm to the specified state.
 * @param {TermState} state - The state the StructureTerm is in.
 */
StructureTerm.prototype.updateState = function (state) {
	StructureNode.prototype.updateState.call(this, state);
	this.updateDirty();
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureTerm.prototype.getRootElement = function() {
   if(!this.m_rootElement || !this.m_rootElement.length) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Performs a check to see if the StructureTerm is considered dirty. This simply checks if the
 * current state is not equal to the initial state.
 * @returns {boolean}
 */
StructureTerm.prototype.checkIsDirty = function () {
	return this.getState() !== this.getInitialState();
};

/**
 * Updates the dirty state of the StructureTerm. First, we set the dirty state based on the check
 * for dirty. After this occurs, a dirty class is added to the structure term root level. Finally,
 * the organizer node is found and informed that a term's dirty state has changed.
 */
StructureTerm.prototype.updateDirty = function () {
	var wasDirty = this.m_dirty;
	this.m_dirty = this.checkIsDirty();
	if (wasDirty !== this.m_dirty) {
		this.getParent().notifyDirty(this);
	}
};

/**
 * This simply resets the dirty state of the StructureTerm by setting the initial state to the current state.
 * This occurs when the tree is saved.
 */
StructureTerm.prototype.resetDirty = function () {
	StructureNode.prototype.resetDirty.call(this);
	this.setInitialState(this.getState());
};

/**
 * Renders the StructureTerm as an html string. Currently this base StructureTerm is just a div with a title. It is
 * up to sub-classes of StructureTerm to override this method and provide html.
 * @param {StructureHtml} structureHtml - The structure html package to which this term will be appended.
 */
StructureTerm.prototype.render = function (structureHtml) {
	structureHtml.append("<div>" + this.getTitle() + "</div>");
};

/**
 * Base deactivate method for the StructureTerm. This method should be implemented by any sub-classes of StructureTerm.
 */
StructureTerm.prototype.deactivate = function () {
	return;
};

/**
 * The base refresh method for StructureTerm objects. This removes the CSS class of the previous state and adds the
 * CSS class of the current state.
 */
StructureTerm.prototype.refresh = function () {
	if (this.m_state !== this.m_previousState) {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).removeClass((this.m_previousState) ? this.m_previousState.getCSSClass() : "").addClass(this.m_state.getCSSClass());
	}
};

/**
 * LineStructureTerm
 * This term has no user-interaction and is simply a placeholder term, designed to delineate regions within
 * structured documentation.
 * @returns {LineStructureTerm}
 * @constructor
 */
function LineStructureTerm() {
	this.m_type = "LINE";
	return this;
}
LineStructureTerm.prototype = new StructureTerm();
LineStructureTerm.prototype.constructor = StructureTerm;

/**
 * Overrides the base StructureTerm render method. It renders the LineStructureTerm object as an html string
 * and appends it to the structure html parameter.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
LineStructureTerm.prototype.render = function (structureHtml) {
	structureHtml.append("<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item line-term'></div>");
};

/**
 * CycleStructureTerm
 * This term represents a structured documentation answer with multiple states that can be cycled through via clicking.
 * This term can have any number of states.
 * @returns {CycleStructureTerm}
 * @constructor
 */
function CycleStructureTerm() {
	this.m_currentState = 0;                  //A state counter to know which state index we sit at
	this.m_states = null;                     //A list of states that will be cycled through
	return this;                            //Return a reference to self to allow chaining
}
CycleStructureTerm.prototype = new StructureTerm();
CycleStructureTerm.prototype.constructor = StructureTerm;

/**
 * Returns the index of the current state.
 * @returns {number}
 */
CycleStructureTerm.prototype.getCurrentState = function () {
	return this.m_currentState;
};

/**
 * Sets the state index.
 * @param {number} currentState - The current state of the term. This value must be within the bounds of the
 * number of states. (0 -> # states).
 * @return {CycleStructureTerm}
 */
CycleStructureTerm.prototype.setCurrentState = function (currentState) {
	if (typeof currentState !== "number") {
		throw new Error("Called setCurrentState on CycleStructureTerm with invalid currentState parameter.");
	}
	if (currentState < 0 || currentState >= this.m_states.length) {
		throw new Error("Called setCurrentState on CycleStructureTerm with an invalid state index.");
	}
	this.m_currentState = currentState;
	return this;
};

/**
 * Adds a TermState to the list of available states for the CycleStructureTerm.
 * @param {TermState} state - A TermState to be added to the CycleStructureTerm.
 * @returns {CycleStructureTerm}
 */
CycleStructureTerm.prototype.addState = function (state) {
	if (!TermState.prototype.isPrototypeOf(state)) {
		throw new Error("Called addState on CycleStructureTerm with invalid state parameter.");
	}
	this.getStates().push(state);
	return this;
};

/**
 * Returns the list of states available on the CycleStructureTerm.
 * @return {List<TermState>}
 */
CycleStructureTerm.prototype.getStates = function () {
	if (!this.m_states) {
		this.m_states = [];
	}
	return this.m_states;
};

/**
 * Increments the state by one and calls the updateState method which will handle state change functionality.
 */
CycleStructureTerm.prototype.cycleState = function () {
	this.m_currentState = (this.m_currentState + 1) % this.m_states.length;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Jumps immediately to the specified state. If the number provided is out of bounds, it will
 * mod the number to make it work.
 * @param {number} stateNumber - The index of the state to jump to.
 */
CycleStructureTerm.prototype.jumpToState = function (stateNumber) {
	this.m_currentState = stateNumber % this.m_states.length;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Overrides the deactivation method. This will simply jump to the 0 state, which is expected to be the NULL
 * state.
 */
CycleStructureTerm.prototype.deactivate = function () {
	this.m_currentState = 0;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
CycleStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}	
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item cycle-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-documented-icon-area'></div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Clear the term of activity data and restores its state back to a freshly created state
 */
CycleStructureTerm.prototype.clearSelf = function () {
	StructureTerm.prototype.clearSelf.call(this);
	this.deactivate();
};

/**
 * YesNoStructureTerm
 * This represents a structured documentation answer which has two state; Yes and No. Thus, this class
 * inherits from the CycleStructureTerm and enforces the use of a yes and no state.
 * @returns {YesNoStructureTerm}
 * @constructor
 */
function YesNoStructureTerm() {
	return this;
}
YesNoStructureTerm.prototype = new CycleStructureTerm();
YesNoStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
YesNoStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? (this.m_state.getCSSClass() + " " + this.getYesNoValue()) : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}	
	structureHtml.append("<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item cycle-term yes-no " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div id='" + this.getNamespace() + ":term:YES:" + this.getId() + "' class='structure-yes-no-icon structure-yes'>Y</div>" +
			"<div id='" + this.getNamespace() + ":term:NO:" + this.getId() + "' class='structure-yes-no-icon structure-no'>N</div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Simply returns the yes or no string value of the term. If the state value is true, return yes, otherwise return false.
 * @returns {string}
 */
YesNoStructureTerm.prototype.getYesNoValue = function () {
	if (!this.m_state || this.m_state.getValue() === null) {
		return "";
	}
	if (this.m_state.getValue()) {
		return "yes";
	}
	return "no";
};

/**
 * Overrides the refresh method, handling the 'Y' and 'N' displays.
 */
YesNoStructureTerm.prototype.refresh = function () {
	StructureTerm.prototype.refresh.call(this);
	var root = $("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId());
	if (this.getState() && this.getState().getValue() === true) {
		root.addClass("yes").removeClass("no");
	} else if (this.getState() && this.getState().getValue() === false) {
		root.addClass("no").removeClass("yes");
	} else {
		root.removeClass("yes").removeClass("no");
	}
};

/**
 * InputStructureTerm
 * This represents a structured documentation answer which allows user input via a textbox.
 * @returns {InputStructureTerm}
 * @constructor
 */
function InputStructureTerm() {
	this.m_dataType = "";                 //Which types of data the input term accepts (alpha/alphanumeric, or numeric)
	this.m_currentValue = "";             //The value the user has currently entered in the available input
	this.m_previousValue = "";            //The value since the last save
	this.m_validators = null;
	this.m_activeState = null;
	this.m_inactiveState = null;
	// indicates whether the input is valid, true by default/blank
	this.m_isValid = true;

	return this;
}

InputStructureTerm.prototype = new StructureTerm();
InputStructureTerm.prototype.constructor = StructureTerm;

/**
 * Gets the data type for the InputStructureTerm.
 * @return {string} the data type for the InputStructureTerm.
 */
InputStructureTerm.prototype.getDataType = function () {
	return this.m_dataType;
};

/**
 * Sets the data type for the InputStructureTerm.
 * @param dataType the data type for the InputStructureTerm.
 * @return {InputStructureTerm} returns self.
 */
InputStructureTerm.prototype.setDataType = function (dataType) {
	if (typeof dataType !== "string") {
		throw new Error("Called setDataType on InputStructureTerm with invalid dataType parameter.");
	}
	this.m_dataType = dataType;
	return this;
};

/**
 * Returns the previous text value that was input in the InputStructureTerm.
 * @returns {string}
 */
InputStructureTerm.prototype.getPreviousValue = function () {
	return this.m_previousValue;
};

/**
 * Overrides the resetDirty method. This calls the base resetDirty method, then sets the previousValue to the
 * currentValue.
 */
InputStructureTerm.prototype.resetDirty = function () {
	StructureTerm.prototype.resetDirty.call(this);
	this.m_previousValue = this.m_currentValue;
};

/**
 * Overrides the checkIsDirty method. InputSructureTerm has a complicated system for determining dirty state. There
 * are three scenarios which guarantee dirty state.
 * 1). If the term was active and is currently inactive.
 * 2). If the term was inactive and is currently active.
 * 3). If the term was active, is currently active, but the previousValue and currentValue are not equal.
 * @returns {boolean}
 */
InputStructureTerm.prototype.checkIsDirty = function () {
	var currentlyActive = this.getState() === this.getActiveState();
	var wasInactive = this.getInitialState() === this.getInactiveState();
	var currentValue = this.getCurrentValue();
	var previousValue = this.getPreviousValue();
	//If it was not active and is currently active, it's dirty. If it was active and is currently inactive, it's dirty. Or
	//if it was active and is still currently active, but the text value is different, it's dirty.
	return (wasInactive && currentlyActive) || (!wasInactive && currentlyActive && currentValue !== previousValue) || (!wasInactive && !currentlyActive);
};

/**
 * Overrides the convertToJSON method.
 * @return {Object} the JSON version of this term.
 */
InputStructureTerm.prototype.convertToJSON = function () {
	var currentValue = this.getCurrentValue();
	var comment = this.getComment();

	var json = [];
	json.push('"dd_attr_menu_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"display_seq": ' + this.getDisplayPosition());
	json.push('"truth_state_mean": "' + ((this.getState().getValue()) ? "T" : "F") + '"');
	json.push('"comment": "' 
		//escape special characters in comment
		+ (comment ? this.escapePlaintextAsHtml(comment) : comment) 
		+ '"');
	json.push('"comment_format_mean": "XHTML"');
	json.push('"value_text": "'
		// escape value text
		+ (currentValue ? this.escapePlaintextAsHtml(currentValue) : currentValue)
		+ '"');
	json.push('"value_text_format_mean": "XHTML"');

	if (this.m_dataType === "NUMERIC") {
		currentValue = parseFloat(this.getCurrentValue());

		// append a .0 if it is a whole number
		if (currentValue % 1 === 0) {
			currentValue = currentValue + ".0";
		}

		json.push('"value_number": ' + currentValue);

	} else {
		json.push('"value_number": 0.0');
	}

	return '{' + json.join(',') + '}';
};


/**
 * Gets the current value (in the textbox) for the InputStructureTerm.
 * @return {string} the current value in the textbox.
 */
InputStructureTerm.prototype.getCurrentValue = function () {
	return this.m_currentValue;
};

/**
 * Updates the validity and the state of the term based on the current value of the term.
 * Should be called after a change in the current value of the term.
 */
InputStructureTerm.prototype.update = function () {
	if (this.validate()) {
		this.m_isValid = true;

		if (this.m_currentValue !== "") {
			this.getActiveState().addData("value", this.m_currentValue);
			this.updateState(this.m_activeState);
		} else {
			this.updateState(this.m_inactiveState);
		}
	} else {
		this.m_isValid = false;

		this.updateState(this.m_inactiveState);
	}
};

/**
 * Overrides the refresh method to update the input displays/UI based on the current value.
 */
InputStructureTerm.prototype.refresh = function () {
	StructureTerm.prototype.refresh.call(this);

	// update input value with the current value
	var input = $("#" + this.getNamespace() + "\\:term\\:INPUT\\:" + this.getId());
	if (this.getCurrentValue() !== input.val()) {
		input.val(this.getCurrentValue());
	}

	// if the input is in an invalid state, we are going to add an "invalid" class to the term
	if (!this.m_isValid) {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).addClass("invalid");
	} else {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).removeClass("invalid");
	}
};


/**
 * Sets the current text value within the InputStructureTerm.
 * @param {string} currentValue - The current value within the InputStructureTerm.
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.setCurrentValue = function (currentValue) {
	if (typeof currentValue !== "string") {
		throw new Error("Called setCurrentValue on InputStructureTerm with invalid type: expected {String}");
	}
	this.m_currentValue = currentValue;
	return this;
};

/**
 * This method forces the InputStructureTerm into the inactive state.
 */
InputStructureTerm.prototype.deactivate = function () {
	this.setCurrentValue("");
	this.updateState(this.m_inactiveState);
};

/**
 * Clear the term of activity data and restores its state back to a freshly created state
 */
InputStructureTerm.prototype.clearSelf = function () {
	StructureTerm.prototype.clearSelf.call(this);
	this.deactivate();
};

/**
 * Returns a list of validators associated to the InputStructureTerm.
 * @returns {Array<InputValidator>}
 */
InputStructureTerm.prototype.getValidators = function () {
	if (!this.m_validators) {
		this.m_validators = [];
	}
	return this.m_validators;
};

/**
 * Add an InputValidator to the InputStructureTerm.
 * @param {InputValidator} validator - A validator to be associated to the InputStructureTerm.
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.addValidator = function (validator) {
	if (!InputValidator.prototype.isPrototypeOf(validator)) {
		throw new Error("Called addValidator on InputStructureTerm with invalid type, expected InputValidator");
	}
	this.getValidators().push(validator);
	return this;
};

/**
 * Simply returns a boolean as for whether or not the currentValue on the InputStructureTerm matches the data type
 * required.
 * @return {Boolean}
 */
InputStructureTerm.prototype.validate = function () {
	//If nothing has been entered, we consider that valid (nothing entered)
	var currentValue = this.getCurrentValue();
	if (currentValue == "") {
		return true;
	}
	//Iterate over each of the validators and ensure they evaluate to true
	var validators = this.getValidators();
	var numberValidators = validators.length;
	for (var i = 0; i < numberValidators; i++) {
		if (!validators[i].validate(currentValue)) {
			return false;
		}
	}
	//If we have made it this far, the input term has successfully validated
	return true;
};

/**
 * Renders the InputStructureTerm object as an html string.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
InputStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var titleText = this.getTitle();
	var itemWidth = "45%";

	// escape current value plain text to be safe for html
	var currentValueHtml = this.escapePlaintextAsHtml(this.m_currentValue);

	var inputElement = "<input style='width: " + itemWidth + ";' type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "'>";
	//If somehow the input term does not contain the _ character, add one at the end by default.
	if(titleText.indexOf("_") === -1) {
		titleText += "_";
	}
	if (titleText.indexOf("_") === 0) {
		titleText = inputElement + "<span class='structure-term-title' style='width: " + itemWidth + ";'>" + titleText.replace(/_/g, "") + "</span>";
	} else if (titleText.lastIndexOf("_") === (titleText.length - 1)) {
		titleText = "<span class='structure-term-title' style='width: " + itemWidth + ";'>" + titleText.replace(/_/g, "") + "</span>" + inputElement;
	} else {
		var textSplit = titleText.split(/_+/g);
		var numberOfNonBlank = 0;
		var i = 0;
		for (i = 0; i < textSplit.length; i++) {
			(textSplit[i]) && numberOfNonBlank++;
		}
		itemWidth = (90 / (numberOfNonBlank + 1)) + "%";
		inputElement = "<input style='width: " + itemWidth + ";' type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "'>";
		for (i = 0; i < textSplit.length; i++) {
			if (textSplit[i]) {
				textSplit[i] = ("<span class='structure-term-title' style='width: " + itemWidth + ";'>" + textSplit[i] + "</span>");
			}
		}
		titleText = textSplit.join(inputElement);
	}
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item input-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			titleText +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-documented-icon-area'></div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Gets the active state for the term
 * @returns {TermState} a TermState object that represents the active state
 */
InputStructureTerm.prototype.getActiveState = function () {
	return this.m_activeState;
};

/**
 * Sets the active state for the term
 * @param {TermState} activeState - a TermState object that represents the active state
 */
InputStructureTerm.prototype.setActiveState = function (activeState) {
	if(!TermState.prototype.isPrototypeOf(activeState)) {
		throw new Error("Attempted to call InputStructureTerm.prototype.setActiveState with invalid parameter");
	}
	this.m_activeState = activeState;
	return this;
};

/**
 * Gets the inactive state for the term
 * @returns {TermState} a TermState object that represents the inactive state
 */
InputStructureTerm.prototype.getInactiveState = function () {
	return this.m_inactiveState;
};

/**
 * Sets the inactive state for the term.
 * @param {TermState}inactiveState
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.setInactiveState = function (inactiveState) {
	if(!TermState.prototype.isPrototypeOf(inactiveState)) {
		throw new Error("Attempted to call InputStructureTerm.prototype.setInactiveState with invalid parameter.");
	}
	this.m_inactiveState = inactiveState;
	return this;
};

/**
 * FreeTextStructureTerm
 * @returns {FreeTextStructureTerm}
 * @constructor
 */
function FreeTextStructureTerm() {
	return this;
}

FreeTextStructureTerm.prototype = new InputStructureTerm();
FreeTextStructureTerm.prototype.constructor = InputStructureTerm;

/**
 * Renders the freetext term as html and appends it to the supplied html
 * @param {StructureHtml} structureHtml - existing html to append the rendered freetext term onto
 */
FreeTextStructureTerm.prototype.render = function (structureHtml) {
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";

	// escape current value plain text to be safe for html
	var currentValueHtml = this.escapePlaintextAsHtml(this.m_currentValue);

	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item input-term freetext-term " + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<input type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "' placeholder='" + i18n.discernabu.mpage_structured_documentation.ADD_FREE_TEXT_TERM + "'>" +
			"</div>" +
			"</div>"
	);
};

/**
 * NoneStructureTerm
 * This represents a structured documentation answer that reflects None
 * @returns {NoneStructureTerm}
 * @constructor 
 */
function NoneStructureTerm (){
	return this;
}
NoneStructureTerm.prototype = new CycleStructureTerm();
NoneStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * TableStructureTerm
 * This represents a structured documentation term within a Table (R/L/Bi)
 * @returns {TableStructureTerm}
 * @constructore
 */
function TableStructureTerm () {
	return this;
}

TableStructureTerm.prototype = new CycleStructureTerm();
TableStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
TableStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	var columnWidth = (100 / this.getParent().getChildren().length) + "%";

	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='table-term " + stateClass + "' title='" + this.getCaption() +  "'  style='width: " + columnWidth + ";'>" +
			"<div class='structure-documented-icon-area'>" + this.getUIValue() + "</div>" +
			"</div>"
	);
};

/**
 * Implements isDefaultDisplayed term for TableStructureTerm.  Returns true as the term should always
 * be displayed independent of priority if that parent Table is displayed
 * @return {Boolean} Returns true if the node should be rendered by default
 */
TableStructureTerm.prototype.isDefaultDisplayed = function() {
	return true;
};

/**
 * Override the getComment function, to retrieve comment from the Table level. 
 * This is because the comment on the front-end is associated to the table, but to the term on the back-end.
 * @return {String} The comment associated to the term/table
 */
TableStructureTerm.prototype.getComment = function() {
	var tableGroupTerm = this.getParent();
	var tableGroupTermComment = tableGroupTerm.getComment();
	//If current tem is active, return associated comment
	if(tableGroupTerm.getActiveTerm() === this){
		this.setComment(tableGroupTermComment);
		return tableGroupTermComment;
	}
	//Otherwise, remove comment from current table item
	else {
		this.setComment("");
		return "";
	}
};

/**
 * Override getSaveComment to return parent table's saved comment
 * @return {String} The comment saved in the table
 */
TableStructureTerm.prototype.getSavedComment = function() {
	var tableGroupTerm = this.getParent();
	return tableGroupTerm.getSavedComment();
};

/**
 * Displays comment for the term
 * @param {string} comment - The comment of the StructureTerm.
 */
TableStructureTerm.prototype.displayComment = function(comment) {
	// validates the comment received and covert them to the actual text
	var validatedComment = comment ? this.unescapePlaintextAsHtml(comment) : comment + "";
	// sets comment to the term
	this.setComment(validatedComment);
	this.setSavedComment(validatedComment);

	var tableTermGroup = this.getParent();
	tableTermGroup.displayComment(comment);
};

/**
 * Override default getHighlightElement to return highLightElement of parent table.
 * @return {undefined}
 */
TableStructureTerm.prototype.getHighlightElement = function() {
	var tableGroupTerm = this.getParent();
	return tableGroupTerm.getHighlightElement();
};

/**
 * Overiding isDefaultDisplayed such that term is always default rendered when parent is rendered
 * @return {Boolean} True iff the term should be shown by default
 */
TableStructureTerm.prototype.isDefaultDisplayed = function () {
	return true;
};

/**
 * Overiding isCurrentlyDisplayed as term will always be displayed if parent table is displayed
 * @return {Boolean} True iff the term is currently displayed on the page
 */
TableStructureTerm.prototype.isCurrentlyDisplayed = function() {
	var parentTable = this.getParent();
	return parentTable.isCurrentlyDisplayed();
};

/**
 * Overriding displayNode to display parent table when node is not displayed
 * @return {[type]} [description]
 */
TableStructureTerm.prototype.displayNode = function() {
	var table = this.getParent();
	table.displayNode();
};
/**
 * Navigator
 * This class serves as a standard navigation bar which simply displays a list of navigation options
 * @returns {Navigator}
 * @constructor
 */
function Navigator() {
	this.m_activeNavigation = null;
	this.m_clickCallback = null;
	this.m_id = "";
	this.m_navigationMap = null;
	this.m_navigations = null;
	this.m_skin = "";
	return this;
}

/**
 * Returns the click callback function. To execute the callback, it must be called as getClickCallback()().
 * @returns {null | function}
 */
Navigator.prototype.getClickCallback = function () {
	return this.m_clickCallback;
};

/**
 * Sets the callback that is executed when a navigation item is selected.
 * @param {function} callback - The callback function to be executed when a navigation item is selected from the
 * navigator. This function must be in the following format.
 * function(navigationItem) { ... }.
 */
Navigator.prototype.setClickCallback = function (callback) {
	if (typeof callback !== "function") {
		throw new Error("Attempted to call setClickCallback with invalid parameter");
	}
	this.m_clickCallback = callback;
	return this;
};

/**
 * Applies a custom CSS skin to the root level of the navigator.
 * @param {string} skin - The CSS skin to be applied to the root level of the navigator.
 * @returns {Navigator}
 */
Navigator.prototype.applyCustomSkin = function (skin) {
	if (typeof skin !== "string") {
		throw new Error("Attempted to call applyCustomSkin with invalid parameter.");
	}
	this.m_skin = skin;
	return this;
};

/**
 * Returns the custom CSS skin that will be applied to the root level of the navigator.
 * @returns {string}
 */
Navigator.prototype.getCustomSkin = function () {
	return this.m_skin;
};

/**
 * Returns the Navigation item that is currently active within the Navigator.
 * @returns {null|Navigation}
 */
Navigator.prototype.getActiveNavigation = function () {
	return this.m_activeNavigation;
};

/**
 * Sets the Navigation item that is currently active within the Navigator.
 * @param {Navigation} activeNavigation - The Navigation item that is currently active within the Navigator.
 * @returns {Navigator}
 */
Navigator.prototype.setActiveNavigation = function (activeNavigation) {
	if (!Navigation.prototype.isPrototypeOf(activeNavigation)) {
		throw new Error("Attempted to call setActiveNavigation with invalid parameter.");
	}
	this.m_activeNavigation = activeNavigation;
	return this;
};

/**
 * Returns the id of the Navigator element.
 * @returns {string}
 */
Navigator.prototype.getId = function () {
	return this.m_id;
};

/**
 * Sets the id of the Navigator element.
 * @param {string} id - The id of the Navigator element.
 * @returns {Navigator}
 */
Navigator.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Attempted to call setId with invalid parameter.");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the list of Navigation items associated to the Navigator.
 * @returns {Array<Navigation>}
 */
Navigator.prototype.getNavigations = function () {
	if (!this.m_navigations) {
		this.m_navigations = [];
	}
	return this.m_navigations;
};

/**
 * Sets the list of Navigation items associated to the Navigator.
 * @param {Array<Navigation>} navigations - The list of Navigation items to be associated to the Navigator
 * @returns {Navigator}
 */
Navigator.prototype.setNavigations = function (navigations) {
	if (!Array.prototype.isPrototypeOf(navigations)) {
		throw new Error("Attempted to call setNavigations with invalid parameter.");
	}
	this.m_navigations = navigations;
	return this;
};

/**
 * Adds a Navigation item to the list of Navigation items associated to the Navigator.
 * The Navigation item is put in a flat list as well as a map which maps from the Navigation id to the object.
 * @param {Navigation} navigation - A single Navigation item to be associated to the Navigator.
 * @returns {Navigator}
 */
Navigator.prototype.addNavigation = function (navigation) {
	if (!Navigation.prototype.isPrototypeOf(navigation)) {
		throw new Error("Attempted to call addNavigation with invalid parameter.");
	}
	this.getNavigations().push(navigation);
	this.getNavigationMap()[navigation.getId()] = navigation;
	return this;
};

/**
 * Returns the Navigation map which is an association of Navigation ids to objects.
 * @returns {null|Object}
 */
Navigator.prototype.getNavigationMap = function () {
	if (!this.m_navigationMap) {
		this.m_navigationMap = {};
	}
	return this.m_navigationMap;
};

/**
 * Renders the Navigator object as an html string which is to be appended to the DOM. This method will render the
 * shell of the Navigator as well as render each individual Navigation item.
 * @returns {string}
 */
Navigator.prototype.render = function () {
	var html = "";
	var navigationList = this.getNavigations();
	var navigationCount = navigationList.length;
	html += "<div id='" + this.getId() + "' class='" + this.getCustomSkin() + " structure-navigator'>";
	for (var i = 0; i < navigationCount; i++) {
		html += navigationList[i].render();
	}
	html += "</div>";
	return html;
};

/**
 * Finalizes the Navigator object. This attaches a click delegate at the root level to listen for click events
 * on the individual Navigation items. When an item is clicked, it is activated and the onSelect method is called.
 * The currently active Navigation item is deselected.
 */
Navigator.prototype.finalize = function () {
	var self = this;
	var elementId = this.getId().replace(/:/g, "\\:");
	//Attach a delegate and listen for clicks on any of the navigation items
	$("#" + elementId).on('click', '.navigator-button', function () {
		self.handleNavigationSelection(this.id);
	});
};

Navigator.prototype.updateActiveNavigation = function (navigationId) {
	var navigationItem = this.getNavigationMap()[navigationId];
	if (!navigationItem || navigationItem === this.getActiveNavigation()) {
		return;
	}
	//If there is a currently active Navigation item, deselect it first
	if (this.getActiveNavigation()) {
		this.getActiveNavigation().deselect();
	}
	navigationItem.getElement().addClass("active");
	this.setActiveNavigation(navigationItem);
};

Navigator.prototype.handleNavigationSelection = function (navigationId) {
	//Using the id of the element, look up the Navigation object in the navigation map
	var navigationItem = this.getNavigationMap()[navigationId];
	if (!navigationItem || navigationItem === this.getActiveNavigation()) {
		return;
	}
	//If there is a currently active Navigation item, deselect it first
	if (this.getActiveNavigation()) {
		this.getActiveNavigation().deselect();
	}
	this.setActiveNavigation(navigationItem);
	navigationItem.onSelect();
	if (this.m_clickCallback) {
		this.m_clickCallback(navigationItem);
	}
};


/**
 * Navigation
 * This class serves as the base Navigation object which is meant to be added into a Navigator.
 * @returns {Navigation}
 * @constructor
 */
function Navigation() {
	this.m_id = "";
	this.m_label = "";
	this.m_element = null;
	return this;
}

/**
 * Returns the Navigation DOM element.
 * @returns {Object}
 */
Navigation.prototype.getElement = function () {
	if (!this.m_element) {
		this.m_element = $("#" + this.getId().replace(/\:/g, "\\:"));
	}
	return this.m_element;
};

/**
 * Returns the id of the Navigation element.
 * @returns {string}
 */
Navigation.prototype.getId = function () {
	return this.m_id;
};

/**
 * Sets the id of the Navigation element.
 * @param {string} id - The id of the Navigation element.
 * @returns {Navigation}
 */
Navigation.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Attempted to call Navigation.prototype.setId with invalid parameter.");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the label of the Navigation element.
 * @returns {string}
 */
Navigation.prototype.getLabel = function () {
	return this.m_label;
};

/**
 * Sets the label of the Navigation element.
 * @param {string} label - The label of the Navigation element.
 * @returns {Navigation}
 */
Navigation.prototype.setLabel = function (label) {
	if (typeof label !== "string") {
		throw new Error("Attempted to call Navigation.prototype.setLabel with invalid parameter.");
	}
	this.m_label = label;
	return this;
};

/**
 * This method performs the base onSelect operations. Any sub-class that overrides this method should call this
 * base method.
 */
Navigation.prototype.onSelect = function () {
	this.getElement().addClass("active");
};

/**
 * This method deselects the Navigation item.
 */
Navigation.prototype.deselect = function () {
	this.getElement().removeClass("active").blur();
};

/**
 * This method renders the Navigation item. Note that it uses the standard button implementation and applies a custom
 * skin to the button.
 * @returns {string}
 */
Navigation.prototype.render = function () {
	return "<button id='" + this.getId() + "' class='navigator-button'>" + this.getLabel() + "</button>";
};

/**
 * ScrollNavigation
 * This class inherits from the base Navigation item. Its purpose is to scroll some other element to a specified
 * anchor.
 * @returns {ScrollNavigation}
 * @constructor
 */
function ScrollNavigation() {
	this.m_anchorId = "";
	this.m_anchorElement = null;
	this.m_containerId = "";
	this.m_containerElement = null;
	return this;
}
ScrollNavigation.prototype = new Navigation();
ScrollNavigation.prototype.constructor = Navigation;

/**
 * Returns the id of the anchor element. The anchor element is the anchor to which the container element will be
 * scrolled.
 * @returns {string}
 */
ScrollNavigation.prototype.getAnchorId = function () {
	return this.m_anchorId;
};

/**
 * Sets the id of the anchor element. The anchor element is the anchor to which the container element will be scrolled.
 * @param {string} anchorId - The id of the element to which the container element will be scrolled.
 * @returns {ScrollNavigation}
 */
ScrollNavigation.prototype.setAnchorId = function (anchorId) {
	if (typeof anchorId !== "string") {
		throw new Error("Attempted to call ScrollNavigation.prototype.setAnchorId with invalid parameter.");
	}
	this.m_anchorId = anchorId;
	return this;
};

/**
 * Returns the anchor element jQuery object. The anchor element is the anchor to which the container element will be
 * scrolled.
 * @returns {Object}
 */
ScrollNavigation.prototype.getAnchorElement = function () {
	if (!this.m_anchorElement) {
		this.m_anchorElement = $("#" + this.getAnchorId().replace(/:/g, "\\:"));
	}
	return this.m_anchorElement;
};

/**
 * Returns the id of the container element. The container element is the element which will be scrolled to the specified
 * anchor.
 * @returns {string}
 */
ScrollNavigation.prototype.getContainerId = function () {
	return this.m_containerId;
};

/**
 * Sets the id of the container element. The container element is the element which will be scrolled to the specified
 * anchor.
 * @param {string} containerId - The id of the container element.
 * @returns {ScrollNavigation}
 */
ScrollNavigation.prototype.setContainerId = function (containerId) {
	if (typeof containerId !== "string") {
		throw new Error("Attempted to call ScrollNavigation.prototype.setContainerId with invalid parameter.");
	}
	this.m_containerId = containerId;
	return this;
};

/**
 * Returns the container element jQuery object. The container element is the element which will be scrolled to the
 * specified anchor.
 * @returns {Object}
 */
ScrollNavigation.prototype.getContainerElement = function () {
	if (!this.m_containerElement) {
		this.m_containerElement = $("#" + this.getContainerId().replace(/:/g, "\\:"));
	}
	return this.m_containerElement;
};

/**
 * This method overrides the base Navigation onSelect method. It calls the base onSelect method then scrolls the
 * container element to the anchor element.
 */
ScrollNavigation.prototype.onSelect = function () {
	Navigation.prototype.onSelect.call(this);
	var containerElement = this.getContainerElement();
	var anchorElement = this.getAnchorElement();
	containerElement.scrollTop(anchorElement.offset().top - containerElement.offset().top + containerElement.scrollTop());
};

/**
 * CallbackNavigation
 * This class inherits from the base Navigation item. Its purpose is to provide a simple entry point to a Navigation
 * item which allows a user to provide a callback when the item is selected. The functionality is mostly left to the
 * developer.
 * @returns {CallbackNavigation}
 * @constructor
 */
function CallbackNavigation() {
	this.m_onSelect = null;
	return this;
}
CallbackNavigation.prototype = new Navigation();
CallbackNavigation.prototype.constructor = Navigation;

/**
 * Sets the callback function to be run when the CallbackNavigation item is selected in the Navigator.
 * @param {function} onSelect - The callback function to be run when the CallbackNavigation item is selected in the
 * Navigator.
 * @returns {CallbackNavigation}
 */
CallbackNavigation.prototype.setOnSelect = function (onSelect) {
	if(typeof onSelect !== "function") {
		throw new Error("Attempted to call CallbackNavigation.prototype.setOnSelect with invalid parameter.");
	}
	this.m_onSelect = onSelect;
	return this;
};

/**
 * Overrides the base onSelect method. This will call the on select callback if one is provided.
 */
CallbackNavigation.prototype.onSelect = function () {
	Navigation.prototype.onSelect.call(this);
	if (this.m_onSelect) {
		this.m_onSelect();
	}
};

/**
 * StructureNavigation
 * This class inherits from the CallbackNavigation item. Its purpose is to integrate with structured documentation.
 * The structured documentation functionality requires a navigation item for each group. When a navigation item
 * is selected, it is necessary to know which StructureNode it is associated with. Thus, this class keeps a reference
 * to the associated StructureNode.
 * @constructor
 */
function StructureNavigation() {
	this.m_node = null;
}
StructureNavigation.prototype = new ScrollNavigation();
StructureNavigation.prototype.constructor = ScrollNavigation;

/**
 * Set the node that the navigation is associated to.
 * @param {StructureNode} node - The node that the navigation is associated to.
 * @returns {StructureNavigation} Returns self to allow chaining.
 */
StructureNavigation.prototype.setNode = function(node) {
	this.m_node = node;
	return this;
};

/**
 * Renders the structure navigation as an html string
 * @returns {string} structure navigation html string
 */
StructureNavigation.prototype.render = function () {
	var documentedClass = (this.m_node && this.m_node.getNumberOfDocumentedChildren() > 0) ? " navigation-documented" : "";
	return "<div id='" + this.getId() + "' class='navigator-button structure-navigator-button" + documentedClass + "'><span>" + this.getLabel() + "</span><div class='navigation-documented-icon'></div></div>";
};
/**
 * The StructureQuestionSet class.
 * This class is used to group a set of structure questions so they can be handled as a unit.
 * @constructor
 */
function StructureQuestionSet() {
	this.m_onCompleteCallback = null;
	this.m_lookup = null;
}

StructureQuestionSet.prototype = new StructureGroup();
StructureQuestionSet.prototype.constructor = StructureGroup;

/**
 * Gets the lookup hashmap for child nodes of the StructureQuestionSet. This should only contain StructureAnswer
 * objects.
 * @returns {HashMap<string, StructureNode>} A hashmap of node ids to StructureNode objects.
 */
StructureQuestionSet.prototype.getLookup = function() {
	if(!this.m_lookup) {
		this.m_lookup = {};
	}
	return this.m_lookup;
};

/**
 * Goes through the answers and finds all that have been answered (or checked). The answers are pushed into an array
 * then serialized as a JSON string.
 * @returns {string} The answers as a serialized array (in string format).
 */
StructureQuestionSet.prototype.getAnswers = function() {
	var answered = [];

	var questions = this.getChildren();
	var questionCount = questions.length;
	var question = null;

	var answers = null;
	var answerCount = null;
	var answer = null;
	for(var i = 0; i < questionCount; i++) {
		question = questions[i];
		answers = question.getChildren();
		answerCount = answers.length;
		for(var j = 0; j < answerCount; j++) {
			answer = answers[j];
			//This answer has been chosen
			if(answer.getState().getValue()) {
				answered.push({
					"parent_entity_id" : question.getParentEntityId() + ".0",
					"parent_entity_name" : question.getParentEntityName(),
					"dd_sref_chf_cmplnt_crit_id" : answer.getTemplateId() + ".0"
				});
			}
		}
	}
	return JSON.stringify(answered);
};

/**
 * Sets the callback function that is triggered when all questions in the set have been answered.
 * @param {function} onCompleteCallback - The callback function.
 * @returns {StructureQuestionSet} Returns self to allow chaining.
 */
StructureQuestionSet.prototype.setOnCompleteCallback = function(onCompleteCallback) {
	if(typeof onCompleteCallback !== "function") {
		throw new Error("StructureQuestionSet.prototype.setOnCompleteCallback expects a function");
	}
	this.m_onCompleteCallback = onCompleteCallback;
	return this;
};

/**
 * Retrieves the root element of the question set.
 * @returns {jQuery|HTMLElement} The root element of the question set.
 */
StructureQuestionSet.prototype.getRootElement = function() {
	if(!this.m_rootElement || !this.m_rootElement.length) {
		this.m_rootElement = $("#" + this.m_namespace + "StructureQuestionSet");
	}
	return this.m_rootElement;
};

/**
 * Override the notifyStateChange function. For a structure question set, we need to know when all questions of the
 * question set have been answered in some fashion. When this occurs, we can trigger the callback.
 * @param {StructureQuestion} node - The StructureQuestion (or node) that changed state.
 */
StructureQuestionSet.prototype.notifyStateChange = function(node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	if(this.m_numberDocumented === this.m_children.length) {
		if(this.m_onCompleteCallback) {
			this.m_onCompleteCallback(true);
		}
	} else {
		this.m_onCompleteCallback(false);
	}
};

/**
 * First assign unique ids and namespace to the nodes then create the HTML representation of the question set.
 * @returns {string} The question set rendered as an HTML string.
 */
StructureQuestionSet.prototype.render = function() {
	var structureHtml = new StructureHtml();
	structureHtml.append("<div id='"+this.m_namespace+"StructureQuestionSet' class='structure-question-set' data-lookup='"+this.m_id+"'>");
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>");
	return structureHtml.getHtml();
};

/**
 * The StructureQuestion class.
 * This represents a single structure question. It inherits from the MultiStructureTermGroup which means that any number
 * of its children can be documented at once.
 * @constructor
 */
function StructureQuestion() {
	this.m_questionDisplay = "";
	this.m_diagnosisGroup = 0.0;

	//Question data
	this.m_parentEntityId = 0.0;
	this.m_parentEntityName = "";
}

StructureQuestion.prototype = new MultiStructureTermGroup();
StructureQuestion.prototype.constructor = MultiStructureTermGroup;

/**
 * Sets the parent entity id of the structure question.
 * @param {number} parentEntityId - The parent entity id of the structure question.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setParentEntityId = function(parentEntityId) {
	if(typeof parentEntityId !== "number") {
		throw new Error("StructureQuestion.prototype.setParentEntityId expects a number.");
	}
	this.m_parentEntityId = parentEntityId;
	return this;
};

/**
 * Sets the parent entity name of the structure question.
 * @param {string} parentEntityName - The parent entity name of the structure question.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setParentEntityName = function(parentEntityName) {
	if(typeof parentEntityName !== "string") {
		throw new Error("StructureQuestion.prototype.setParentEntityName expects a string.");
	}
	this.m_parentEntityName = parentEntityName;
	return this;
};

/**
 * Retrieves the structure question parent entity id.
 * @returns {number} The structure question parent entity id.
 */
StructureQuestion.prototype.getParentEntityId = function() {
	return this.m_parentEntityId;
};

/**
 * Retrieves the structure question parent entity name.
 * @returns {string} The structure question parent entity name.
 */
StructureQuestion.prototype.getParentEntityName = function() {
	return this.m_parentEntityName;
};

/**
 * Sets the question display.
 * @param {string} questionDisplay - The question display.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setQuestionDisplay = function(questionDisplay) {
	if(typeof questionDisplay !== "string") {
		throw new Error("StructureQuestion.prototype.setQuestionDisplay expects a string.");
	}
	this.m_questionDisplay = questionDisplay;
	return this;
};

/**
 * Sets the diagnosis group for the structure question.
 * @param {number} diagnosisGroup - The (double) diagnosis group value.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setDiagnosisGroup = function(diagnosisGroup) {
	if(typeof diagnosisGroup !== "number") {
		throw new Error("StructureQuestion.prototype.setDiagnosisGroup expects a number.");
	}
	this.m_diagnosisGroup = diagnosisGroup;
	return this;
};

/**
 * Renders the StructureQuestion out as an HTML string.
 * @param {StructureHtml} structureHtml - The packaged HTML passed through the recursive rendering.
 * @param {boolean} shouldRenderColumns - Unused boolean determining if the node should render columns.
 */
StructureQuestion.prototype.render = function(structureHtml, shouldRenderColumns) {
	structureHtml.append("<div class='structure-question' data-lookup='"+this.m_id+"'>");
	structureHtml.append("<div>" + this.m_questionDisplay + "</div>");
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>");
};

/**
 * The StructureAnswer class.
 * This represents an answer to a StructureQuestion. A StructureAnswer always has two states: undocumented (null)
 * and documented (true). The default state is undocumented.
 * @returns {StructureAnswer} Returns self to allow chaining.
 * @constructor
 */
function StructureAnswer() {
	this.m_answerDisplay = "";
	this.m_templateId = 0.0;
	this.addState(new TermState().setValue(null).setCSSClass(""));
	this.addState(new TermState().setValue(true).setCSSClass("structure-answer-yes"));
	this.setInitialState(this.m_states[0]);
	this.m_state = this.m_states[0];
	return this;
}
StructureAnswer.prototype = new CycleStructureTerm();
StructureAnswer.prototype.constructor = CycleStructureTerm;

/**
 * Sets tha id of the answer, this id must be unique.
 * @param {number} templateId - The id of the answer.
 * @returns {StructureAnswer} Returns self to allow chaining.
 */
StructureAnswer.prototype.setTemplateId = function(templateId) {
	if(typeof templateId !== "number") {
		throw new Error("StructureAnswer.prototype.setAnswerId expects a number.");
	}
	this.m_templateId = templateId;
	return this;
};

/**
 * Retrieves the answer template id.
 * @returns {number} The answer template id.
 */
StructureAnswer.prototype.getTemplateId = function() {
	return this.m_templateId;
};

/**
 * Returns the root rendered HTML element of a single structure answer.
 * @returns {jQuery|HTMLElement} The root HTML element of the structure answer.
 */
StructureAnswer.prototype.getRootElement = function() {
	if(!this.m_rootElement || !this.m_rootElement.length) {
		this.m_rootElement = $("#" + this.m_namespace + "Answer" + this.m_id);
	}
	return this.m_rootElement;
};

/**
 * Handles the refresh of the structure answer.
 */
StructureAnswer.prototype.refresh = function() {
	if(this.m_state !== this.m_previousState) {
		this.getRootElement().removeClass(this.m_previousState.getCSSClass()).addClass(this.m_state.getCSSClass());
	}
};

/**
 * Sets the answer display of the StructureAnswer.
 * @param {string} answerDisplay - The answer disaplay.
 * @returns {StructureAnswer} Returns self to allow chaining.
 */
StructureAnswer.prototype.setAnswerDisplay = function(answerDisplay) {
	if(typeof answerDisplay !== "string") {
		throw new Error("");
	}
	this.m_answerDisplay = answerDisplay;
	return this;
};

/**
 * Renders the StructureAnswer as an HTML string.
 * @param {StructureHtml} structureHtml - The packaged HTML passed through the recursive rendering.
 * @param {boolean} shouldRenderColumns - Unused boolean determining if the node should render columns.
 */
StructureAnswer.prototype.render = function(structureHtml, shouldRenderColumns) {
	structureHtml.append(
		"<div id='"+this.m_namespace +"Answer"+this.m_id+"' class='structure-answer' data-lookup='"+this.m_id+"'>" +
			"<input class='structure-answer-box' type='checkbox' data-lookup='"+this.m_id+"'>"+
			"<span class='structure-answer-display' data-lookup='" + this.m_id + "'>" + this.m_answerDisplay + "</span>"+
		"</div>"
	);
};


/**
 * StructureTermController
 * This class represents the base interface for a StructureTermController. It simply encapsulates the necessary
 * event attachment which allows for StructureTerms to behave correctly.
 * @constructor
 */
function StructureTermController() {
}

/**
 * This is an interface method in which you will attach events to the root of the organizer.
 * @param organizer the organizer for which you are attaching the events.
 */
StructureTermController.prototype.attach = function(organizer) {
    throw new Error("Attempted to call StructureTermController.prototype.attach, method must be implemented by sub-class");
};

/**
 * InputStructureTermController
 * This is the controller for the InputStructureTerm object. It attaches and handles event delegation
 * for input terms.
 * @constructor
 */
function InputStructureTermController() {
}
InputStructureTermController.prototype = new StructureTermController();
InputStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach both a keyup and a click event to the inputs in order to handle
 * user interaction with them.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
InputStructureTermController.prototype.attach = function(organizer) {
    //Cache the root object since we're going to call it twice.
    var organizerRoot = organizer.getRootElement();
    //Handle keyup events on input terms
    organizerRoot.on("keyup", "div.input-term input", function(){
        //Grab the term from the organizer lookup table
        var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
        //Store the current text value on the term
        term.setCurrentValue($(this).val());
        //Update the term (may have a visual update as well)
        term.update();
    });
    //Handle click events on the input terms.
    organizerRoot.on("click", "div.input-term input", function(){
        //Grab the term from the organizer lookup table
        var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
        //If there is nothing in the text field, do nothing
        if(!$(this).val()) {
            return;
        }
        term.update();
    });
};

/**
 * CycleStructureTermController
 * This is the controller for the CycleStructureTerm object. It attaches and handles event delegation for any
 * CycleStructureTerm objects.
 * @constructor
 */
function CycleStructureTermController(){
}
CycleStructureTermController.prototype = new StructureTermController();
CycleStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking on CycleStructureTerm elements. When
 * the event is triggered, cycleState will be called on the associated CycleStructureTerm object.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
CycleStructureTermController.prototype.attach = function(organizer) {
	var rootElement = organizer.getRootElement();
	//Handle click events on cycle structure terms.
	rootElement.on("click", "div.cycle-term >.structure-documented-icon-area, div.cycle-term >.structure-term-info-wrapper", function(event) {
		// ignore click events originating from comment icon
		if ($(event.target).hasClass('structure-comment')) {
			return;
		}
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
		//Cycle the state of the term
		term.cycleState();
		var termContainer = $(this).closest(".structure-term-item");
		//display/create the comments section if term has comment.
		if (term.getComment()) {
			// checking if the comment section is already available for the term. 
			var commentSection = $(this).siblings("div.structure-term-comment-wrapper");
			termContainer.addClass("comment");		
			if (commentSection.length < 1) {
				commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
				termContainer.append(commentSection);
			}				
		} else {
			termContainer.removeClass("comment");	
		}	
	});
	//Handles the click event on structure comment icon
	rootElement.on("click", "span.structure-comment", function(event) {
		var termInfoSection = $(this).closest(".structure-term-info-wrapper");
		var commentSection = $(termInfoSection).siblings("div.structure-term-comment-wrapper");
		var termContainer = $(this).closest(".structure-term-item");
		termContainer.addClass("comment");
		// builds comment section if it is not available for the particular term
		if (commentSection.length < 1) {
			// create new comment section
			var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
			commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
			termContainer.append(commentSection);
		}
		//setting on focus to the comment section text area
		$(termContainer).find('textarea')[0].focus();		
		});
	//Handles the focus out event on text area of the comment section
	rootElement.on("focusout", "div.structure-term-comment-wrapper", function(event) {
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
		var comment = $(this).find("textarea").val();
		var termContainer = $(this).closest(".structure-term-item");
		//check if the text input is empty, if empty then hide the comment section by removing comment class, if it has a value set it to the concern term(AMI)
		if (comment === "") {
			termContainer.removeClass("comment");			
		}
		// setting comment to the term 
		term.setComment(comment);
		// notify the term as dirty to enable the save button
		if (!term.checkIsDirty()) {
			if (term.getComment() !== term.getSavedComment()) {
				term.m_dirty = true;
				term.notifyDirty(term);
			} else {
				term.m_dirty = false;
				term.notifyDirty(term);
			}
		}
	});
}; 

/**
 * YesNoStructureTermController
 * This is the controller for the YesNoStructureTerm object. It attaches and handles event delegation for any
 * YesNoStructureTerm objects.
 * @constructor
 */
function YesNoStructureTermController(){
}
YesNoStructureTermController.prototype = new StructureTermController();
YesNoStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking the 'Y' and 'N' on
 * YesNoStructureTerm elements. This allows users to quickly jump from a 'Y' and 'N' state without having to rely
 * on cycling the state.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
YesNoStructureTermController.prototype.attach = function(organizer) {
	organizer.getRootElement().on("click", "div.structure-yes, div.structure-no", function(event) {
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
		//Cycle the state of the term
		var parent = term.getParent();
		var noneTerm = parent.getChildren()[0];
		
		if(NoneStructureTerm.prototype.isPrototypeOf(noneTerm) && noneTerm === term){
			noneTerm.jumpToState(0);
		}
		var jumpTo = $(this).hasClass("structure-yes") ? 1 : 2;
		var current = term.getCurrentState();
		term.jumpToState(jumpTo === current ? 0 : jumpTo);
		var termContainer = $(this).closest(".structure-term-item");
		if (term.getComment()) {
			//create or display the comments sections if the term has comment
			var commentSection = $(this).siblings("div.structure-term-comment-wrapper");
			//add class comment to display the comment section			
			termContainer.addClass("comment");
			// builds comment section if it is not available for the particular term
			if (commentSection.length < 1) {
				commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
				termContainer.append(commentSection);
			}
		} else {
			termContainer.removeClass("comment");	
		}	
	});
};

/**
 * StructureGroupController
 * This is the controller for the StructureGroup object. It attaches and handles event delegation for any
 * StructureGroup objects.
 * @constructor
 */
function StructureGroupController(){
}
StructureGroupController.prototype = new StructureTermController();
StructureGroupController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking the toggle controls on
 * StructureGroup elements.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
StructureGroupController.prototype.attach = function(organizer){
    organizer.getRootElement().on("click", ".structure-component-toggle, .structure-component-toggle + .structure-group-title", function(event){
        var group = $(this).parents(".structure-group").first();
        var groupNode = organizer.getLookup()[organizer.parseIdForLookup($(group).attr("id"))];
		groupNode.toggleExpand();
    });
};

/**
 * TableTermConstructor
 * This is the controller for the TableStructureTerm object. It attaches and handles event delegation for any
 * TableStructureTerm objects.
 * @constructor
 */
function TableTermController(){
}
TableTermController.prototype = new StructureTermController();
TableTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking on TableStructureTerm elements. When
 * the event is triggered, cycleState will be called on the associated TableStructureTerm object.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
TableTermController.prototype.attach = function(organizer) {
	var rootElement = organizer.getRootElement();
	//Handle click events on cycle structure terms.
	rootElement.on("click", "div.table-term >.structure-documented-icon-area", function(event) {
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".table-term").attr("id"))];
		//Cycle the state of the term
		term.cycleState();
	});

}; 
/**
 * The StructureTabControll class.
 * This will handle attaching events for structured documentation tabs. This occurs when there are subsections
 * present in a section.
 * @constructor
 */
function StructureTabController() {
	this.m_scrollMap = {};
	this.m_organizer = null;

	this.m_$structureTabGroup = null;
	this.m_$structureTabParent = null;
	this.m_$structureTabWrapper = null;
	this.m_$structureTabMenuButton = null;
}

StructureTabController.prototype = new StructureTermController();
StructureTabController.prototype.constructor = StructureTermController;

/**
 * Retrieves the tab group jQuery element.
 * @returns {jQuery} The tab group jQuery element.
 */
StructureTabController.prototype.getStructureTabGroup = function () {
	if (!this.m_$structureTabGroup || !this.m_$structureTabGroup.length) {
		this.m_$structureTabGroup = $("#" + this.m_organizer.getNamespace() + "StructureTabGroup");
	}
	return this.m_$structureTabGroup;
};

/**
 * Retrieves the tab parent jQuery element.
 * @returns {jQuery} The tab parent element.
 */
StructureTabController.prototype.getStructureTabParent = function () {
	if (!this.m_$structureTabParent || !this.m_$structureTabParent.length) {
		this.m_$structureTabParent = $("#" + this.m_organizer.getNamespace() + "StructureTabParent");
	}
	return this.m_$structureTabParent;
};

/**
 * Retrieves the tab wrapper jQuery element.
 * @returns {jQuery} The tab group wrapper element.
 */
StructureTabController.prototype.getStructureTabWrapper = function () {
	if (!this.m_$structureTabWrapper || !this.m_$structureTabWrapper.length) {
		this.m_$structureTabWrapper = $("#" + this.m_organizer.getNamespace() + "StructureTabGroupWrapper");
	}
	return this.m_$structureTabWrapper;
};

/**
 * Retrieves the structure tab menu button jQuery element.
 * @returns {jQuery} The structure tab menu button jQuery element.
 */
StructureTabController.prototype.getStructureTabMenuButton = function () {
	if (!this.m_$structureTabMenuButton || !this.m_$structureTabMenuButton.length) {
		this.m_$structureTabMenuButton = $("#" + this.m_organizer.getNamespace() + "StructureTabMenuButton");
	}
	return this.m_$structureTabMenuButton;
};

/**
 * Resize function to handle hiding/showing the tab menu icon.
 */
StructureTabController.prototype.resize = function () {
	var $structureTabParent = this.getStructureTabParent();
	var $structureTabWrapper = this.getStructureTabWrapper();
	var structureTabWrapperRaw = $structureTabWrapper[0];
	var $structureTabMenuButton = this.getStructureTabMenuButton();
	var miscPadding = 8;
	structureTabWrapperRaw.style.width = (($structureTabParent[0].offsetWidth - $structureTabMenuButton[0].offsetWidth) - miscPadding) + "px";
};

/**
 * Disables the active tab.
 * @param {StructureOrganizer} organizer - The organizer to which this controller is bound.
 * @param {jQuery} $activeTab - The active tab jQuery element.
 */
StructureTabController.prototype.disableActiveTab = function (organizer, $activeTab) {
	$activeTab.removeClass("structure-tab-active");
	var activeNode = organizer.getLookup()[$activeTab.attr("data-lookup")];
	//If we find the active node, find the closest tab contents (a direct ancestor to the node's root element) and hide it.
	if (activeNode) {
		//Remember the scroll position so it can be restored later
		this.m_scrollMap[activeNode.getId()] = activeNode.getContentElement().scrollTop();
		activeNode.getRootElement().closest(".structure-tab-content").hide();
	}
};

/**
 * Restores the scroll position for the specified node. This is expected to be a StructureOrganizer (section) node.
 * @param {StructureOrganizer} node - The node for which the scroll position is to be restored.
 */
StructureTabController.prototype.restoreScrollPosition = function (node) {
	var scrollTop = this.m_scrollMap[node.getId()];
	//If the scroll-top has not been stored for the node, just return.
	if (typeof scrollTop === "undefined") {
		return;
	}
	node.getContentElement().scrollTop(scrollTop);
};

/**
 * Overrides the attach function in the base StructureTermController class.
 * @param {StructureOrganizer} organizer - The organizer object which is considered the root of the structured
 * documentation tree.
 */
StructureTabController.prototype.attach = function (organizer) {
	this.m_organizer = organizer;
	var namespace = organizer.getNamespace();
	var menuItem = null;
	var $structureTabGroup = $("#" + namespace + "StructureTabGroup");
	var $structureTabs = $structureTabGroup.find(".structure-tab-display");
	var $structureTabWrapper = this.getStructureTabWrapper();
	var previousSelection = null;
	var self = this;
	var tabSelectionMenu = null;
	var menuItemArray = null;
	var selectedTabIndex = 0;
	var $contentBody = organizer.getRootElement().closest(".structured-documentation-view");
	var miscPadding = 8;

	//Make sure to resize up-front.
	this.resize();

	//This function is used when an element is selected in the component selection menu.
	var createSelectionFunc = function (index) {
		return function () {
			var $selectedTab = $structureTabs.eq(index);
			$selectedTab.click();

			var tabPosition = $selectedTab.closest(".structure-tab").position().left + $structureTabWrapper.scrollLeft();
			$structureTabWrapper.scrollLeft(tabPosition - miscPadding);
		};
	};
	//Attach a click event for the structure tabs.
	organizer.getRootElement().on("click", ".structure-tab-group .structure-tab .structure-tab-display", function (event) {
		var node = organizer.getLookup()[$(this).attr("data-lookup")];
		if (!node) {
			return;
		}
		if(node === organizer.getActiveSection()) {
			return;
		}
		//Prevent overflow when switching tabs (it will create a scrollbar on the right and throw off widths)
		$contentBody.css("overflow-y", "hidden");
		//If the section has not been rendered (lazy rendering of tabs)
		if(!node.isRendered()) {
			var $tabContentContainer = $("#" + namespace + "\\:tabContent\\:" + node.getId());
			$tabContentContainer.html(node.renderHtml());
			node.finalize();
			node.setIsRendered(true);
			node.getParent().resize();
		}
		//Show the content of the selected tab
		node.getRootElement().closest(".structure-tab-content").show();
		//Disable the currently active tab.
		self.disableActiveTab(organizer, $structureTabGroup.find(".structure-tab-active"));

		$(this).addClass("structure-tab-active");

		//The height adjustment can become invalid when switching views and resizing, so adjust.
		node.adjustContentHeight();

		//Store off the active section.
		organizer.setActiveSection(node);

		//Attempt to restore the scroll position.
		self.restoreScrollPosition(node);

		//Find the tab in the menu and make sure it is selected.
		selectedTabIndex = $(this).closest(".structure-tab").index();

		//Check that the menu and menu items exist (user may switch tabs before loading the menu).
		if(tabSelectionMenu && menuItemArray) {
			menuItemArray[selectedTabIndex].setIsSelected(true);
			if(previousSelection) {
				previousSelection.setIsSelected(false);
			}
			previousSelection = menuItemArray[selectedTabIndex];
		}
		$contentBody.css("overflow-y", "auto");
	});
	//Attach the click event for the extra tab menu. On first click, the menu will be created.
	organizer.getRootElement().on("click", ".structure-add-tab", function (event) {
		tabSelectionMenu = MP_MenuManager.getMenuObject(namespace + "structureAddTab");
		//Make sure this is a fresh menu. The organizer may have added children, so we cannot cache the menu.
		if(tabSelectionMenu) {
			MP_MenuManager.deleteMenuObject(namespace + "structureAddTab");
		}
		tabSelectionMenu = new Menu(namespace + "structureAddTab");
		tabSelectionMenu.setTypeClass("menu-page-menu structure-tab-menu");
		tabSelectionMenu.setIsRootMenu(true);
		tabSelectionMenu.setAnchorElementId(namespace + "StructureTabMenuButton");
		tabSelectionMenu.setAnchorConnectionCorner(["bottom", "right"]);
		tabSelectionMenu.setContentConnectionCorner(["top", "right"]);
		tabSelectionMenu.setLabel("");

		var children = organizer.getChildren();
		var childrenCount = children.length;
		var child = null;
		for (var i = 0; i < childrenCount; i++) {
			child = children[i];
			menuItem = new MenuSelection(namespace + "structureSectionTab" + child.getId());
			menuItem.setLabel(child.getTitle());
			menuItem.setCloseOnClick(true);
			menuItem.setClickFunction(createSelectionFunc(i));
			//Default the selected menu item to the tab that is currently selected.
			if(i === selectedTabIndex) {
				menuItem.setIsSelected(true);
				previousSelection = menuItem;
			}
			tabSelectionMenu.addMenuItem(menuItem);
		}
		//Keep reference to the array of menu items.
		menuItemArray = tabSelectionMenu.getMenuItemArray();
		MP_MenuManager.addMenuObject(tabSelectionMenu);
		MP_MenuManager.showMenu(namespace + "structureAddTab");
	});
};/**
 * StructureTermGroupController
 * This class represents the base interface for a StructureTermGroupController. It simply encapsulates the necessary
 * event attachment which allows for StructureTermGroups to behave correctly.
 * @constructor
 */
function StructureTermGroupController() {
}

/**
 * This is an interface method in which you will attach events to the root of the organizer.
 * @param {StructureOrganizer} organizer the organizer for which you are attaching the events.
 */
StructureTermGroupController.prototype.attach = function(organizer) {
	var organizerRoot = organizer.getRootElement();
	//Handle click event on Show More/Show Less link
	organizerRoot.on("click", "a.show-more-link", function(){
		var $sourceTermGroup = $(this).closest(".structure-group");
		var termGroup = organizer.getLookup()[organizer.parseIdForLookup($sourceTermGroup.attr("id"))];
		termGroup.toggleShowMore();
	});
};function StructureManager() {
	//JSON data
	this.m_replyData = null;
	this.m_referenceData = null;
	this.m_activityData = null;
	this.m_questionData = null;
	this.m_status = "";

	//Structure objects
	this.m_organizer = null;
	this.m_resizeFunction = null;
	this.m_tabController = null;
	this.m_questionSet = null;
	this.m_openExistingCheckFunction = null;
	this.m_answers = null;
	this.m_openExistingFunction = null;
	this.m_queryTemplateFunction = null;
	this.m_onDirtyChangeCallback = null;

	//Element cache
	this.m_$structureManagerContainer = null;
	this.m_$structureContainer = null;
	this.m_$structureOrganizerContents = null;
	this.m_$questionContainer = null;
	this.m_$questionContents = null;
	this.m_$messageContainer = null;
	this.m_$addTemplateButton = null;

	this.m_namespace = "";
}

/**
 * Sets the namespace of the structured documentation manager. This will provide unique DOM ids for any generated
 * elements.
 * @param {string} namespace - The namespace for all generated DOM elements.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setNamespace = function(namespace) {
	if(typeof namespace !== "string") {
		throw new Error("StructureManager.prototype.setNamespace expects a string.");
	}
	this.m_namespace = namespace;
	return this;
};

/**
 * Sets the dirty change callback function that is triggered when the structure organizer is considered dirty.
 * @param {function} dirtyChangeCallback - The callback function to be triggered when the structured documentation
 * content changes dirty state.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOnDirtyChangeCallback = function(dirtyChangeCallback) {
	if(typeof dirtyChangeCallback !== "function") {
		throw new Error("StructureManager.prototype.setOnDirtyChangeCallback expects a function.");
	}
	this.m_onDirtyChangeCallback = dirtyChangeCallback;
	return this;
};

/**
 * Sets the callback function which is expected to perform the open existing operation. This will flex depending on the
 * consumer of the artifact.
 * @param {function} openExistingFunction - The provided callback function which is expected to perform the open
 * existing operation. This function must be of the form...
 * exampleManager.setOpenExistingFunction(function(structureData, postOpenCallback){
 * 		//Perform open existing operation
 * 		//After open existing operation, call callback with response data...
 * });
 * The consumer must call the postQueryCallback function with the following information...
 * postOpenCallback({
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...]
 * 		"section_act" : [...],
 * 		"user_options" : [...]
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOpenExistingFunction = function(openExistingFunction) {
	if(typeof openExistingFunction !== "function") {
		throw new Error("StructureManager.prototype.setOpenExistingFunction expects a function.");
	}
	this.m_openExistingFunction = openExistingFunction;
	return this;
};

/**
 * Sets the callback function which is expected to perform the query template operation. This will flex depending on the
 * consumer of the artifact.
 * @param {function} queryTemplateFunction - The provided callback function which is expected to perform the query
 * template operation. This function must be of the form...
 * exampleManager.setQueryTemplateFunction(function(structureData, postQueryCallback){
 * 		//Perform query template operation
 * 		//After query template operation, call callback with response data...
 * });
 * The consumer must call the postQueryCallback function with the following information...
 * postQueryCallback({
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...]
 * 		"section_act" : [...],
 * 		"user_options" : [...]
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setQueryTemplateFunction = function(queryTemplateFunction) {
	if(typeof queryTemplateFunction !== "function") {
		throw new Error("StructureManager.prototype.setQueryTemplateFunction expects a function.");
	}
	this.m_queryTemplateFunction = queryTemplateFunction;
	return this;
};

/**
 * Sets the callback function which is expected to determine if the StructureManager needs to perform the open existing
 * operation. If this function returns true, the manager will open-existing on refresh, otherwise it will perform the
 * query template operation.
 * @param {function} openExistingCheckFunction - The callback function which will determine if the manager should perform
 * the open existing or query template operation. It must be of the form...
 * manager.setOpenExistingCheckFunction(function(){
 * 		//Perform necessary checks to determine if open existing should be performed.
 * 		return true/false;
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOpenExistingCheckFunction = function(openExistingCheckFunction) {
	if(typeof openExistingCheckFunction !== "function") {
		throw new Error("StructureManager.prototype.setOpenExistingCheckFunction expects a function.");
	}
	this.m_openExistingCheckFunction = openExistingCheckFunction;
	return this;
};

/**
 * Sets the resize function which is passed to the m_organizer object (when built).
 * @param resizeFunction
 * @returns {StructureManager}
 */
StructureManager.prototype.setOrganizerResizeFunction = function(resizeFunction) {
	if(typeof resizeFunction !== "function") {
		throw new Error("StructureManager.prototype.setResizeFunction expects a function");
	}
	this.m_resizeFunction = resizeFunction;
	return this;
};

/**
 * Resizes structured documentation. First calls resize on the organizer then subsequently resizes
 * the tab controller if there is one.
 */
StructureManager.prototype.resize = function() {
	var self = this;
	setTimeout(function(){
		if(self.m_organizer) {
			self.m_organizer.resize();
		}
		if(self.m_tabController) {
			self.m_tabController.resize();
		}
	}, 100);
};

/**
 * Handles the event when the user clicks the Add Template(s) button. This will obtain and store the set of answers that
 * the user chose from the question set and make a call to refresh the structure manager.
 */
StructureManager.prototype.onAddTemplateClick = function() {
	this.m_$addTemplateButton.prop("disabled", true);
	this.m_answers = this.m_questionSet.getAnswers();
	this.completeRefresh();
};

/**
 * Determines if structured documentation should make a call to open existing structured content or not. This
 * relies on the m_openExistingCheckFunction which is provided by the consumer of this artifact. The aforementioned
 * callback function must return a boolean indicating true or false.
 * @returns {boolean} True if the callback function indicates, otherwise false.
 */
StructureManager.prototype.shouldOpenExisting = function() {
	if(!this.m_openExistingCheckFunction) {
		throw new Error("StructureManager.prototype.shouldOpenExisting function expects you to have set an open existing check function.");
	}
	return this.m_openExistingCheckFunction();
};

/**
 * Performs a complete refresh of the structured documentation. It will either make the call to open existing or
 * query template.
 */
StructureManager.prototype.completeRefresh = function() {
	this.resetReplyData();
	if(this.shouldOpenExisting()) {
		this.openExisting();
	} else {
		this.queryTemplate();
	}
};

/**
 * This renders the shell of the structure manager.
 * @returns {*|jQuery|HTMLElement} The structure manager shell.
 */
StructureManager.prototype.render = function() {
	var self = this;
	var namespace = this.m_namespace;

	//Wrapper
	var $structureView = $("<div id='" + namespace +"StructureView' class='structured-documentation-view content-body'></div>");
	this.m_$structureManagerContainer = $structureView;

	//Questions
	var $questionContainer = $("<div id='" + namespace + "QuestionContainer' class='structure-question-container'></div>").hide();
	this.m_$questionContainer = $questionContainer;
	var $addTemplateButton = $("<button id='" + namespace + "AddTemplateButton' class='structure-add-template-btn' disabled>Add Template(s)</button>");
	$addTemplateButton.click(function(){
		self.onAddTemplateClick();
	});
	this.m_$addTemplateButton = $addTemplateButton;
	$questionContainer.append($addTemplateButton);
	$questionContainer.append($("<div class='structure-question-info-icon'></div>"));
	var $questionContents = $("<div id='" + namespace + "QuestionContents' class='structure-question-contents'></div>");
	$questionContainer.append($questionContents);
	this.m_$questionContents = $questionContents;
	$structureView.append($questionContainer);

	//Structure Organizer
	//The structure content container, structure content is injected here.
	var $structureContainer = $("<div id='" + namespace + "StructureContainer'></div>").hide();
	this.m_$structureContainer = $structureContainer;

	var $structureOrganizerContents = $("<div id='" + namespace + "StructureOrganizerContents'></div>");
	this.m_$structureOrganizerContents = $structureOrganizerContents;
	$structureContainer.append($structureOrganizerContents);

	$structureView.append($structureContainer);

	//Message
	var $messageContainer = $("<div id='" + namespace + "StructureMessageContainer'></div>").hide();
	this.m_$messageContainer = $messageContainer;
	$structureView.append($messageContainer);

	//Perform initial render based on the reply data we were supplied.
	if(this.m_status !== "S") {
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_DOC_UNAVAILABLE);
		return $structureView;
	}
	if(this.hasQuestions()) {
		this.showQuestions();
	} else if(this.hasStructuredContent()) {
		this.showStructure();
	} else {
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_TEMPLATES_NOT_FOUND);
	}
	return $structureView;
};

/**
 * Renders the structured content into the specified element.
 * @param {jQuery} $destinationElement - The element into which structure shall be rendered.
 */
StructureManager.prototype.renderInto = function($destinationElement) {
	$destinationElement.append(this.render());
	this.attachQuestionDelegates();
	this.mergeActivity();
	this.finalizeStructure();
};

/**
 * This function attaches the necessary question delegates. This currently attaches events for
 * clicking on the checkbox or the title of an answer.
 */
StructureManager.prototype.attachQuestionDelegates = function() {
	var self = this;
	//Attach the delegate for answering questions.
	this.m_$questionContainer.on("change", ".structure-answer-box", function(event){
		var nodeId = $(this).attr("data-lookup");
		var node = self.m_questionSet.getLookup()[nodeId];
		if(!node) {
			logger.logWarning("StructureDocumentationView.prototype.finalizeQuestions: could not find answer node with id = " + nodeId);
			return;
		}
		node.cycleState();
	});
	//Attach a delegate for clicking on the answer display which will trigger the click event on the checkbox.
	this.m_$questionContainer.on("click", ".structure-answer-display", function(event){
		var nodeId = $(this).attr("data-lookup");
		var node = self.m_questionSet.getLookup()[nodeId];
		if(!node) {
			logger.logWarning("StructureDocumentationView.prototype.finalizeQuestions: could not find answer node with id = " + nodeId);
			return;
		}
		node.cycleState();
		//Now ensure that the checkbox is updated according to the state of the answer.
		$(this).siblings(".structure-answer-box").prop("checked", (node.getState().getValue() ? true : false));
	});
};

/**
 * This function refresh the structure manager. This must only be called post-render, in other words, structure has
 * already been shown and is being refreshed.
 */
StructureManager.prototype.refresh = function() {
	if(this.m_status !== "S") {
		this.m_$structureContainer.hide();
		this.m_$questionContainer.hide();
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_DOC_UNAVAILABLE);
		return;
	}
	if(this.hasQuestions()) {
		this.m_$structureContainer.hide();
		this.m_$messageContainer.hide();
		this.showQuestions();
	} else if(this.hasStructuredContent()) {
		this.m_$questionContainer.hide();
		this.m_$messageContainer.hide();
		this.showStructure();
		this.mergeActivity();
		this.finalizeStructure();
	} else {
		this.m_$structureContainer.hide();
		this.m_$questionContainer.hide();
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_TEMPLATES_NOT_FOUND);
	}
};

/**
 * Wrapper call to navigate structured documentation to the specified node.
 * @param {Object} navigationData - The navigation data that is used to find a node within the structured
 * documentation tree and navigate to it.
 */
StructureManager.prototype.navigateToNode = function(navigationData) {
	if(!navigationData) {
		logger.logWarning("StructureManager.prototype.navigateToNode expects navigation data.");
		return;
	}
	if(!this.m_organizer) {
		logger.logWarning("StructureManager.prototype.navigateToNode: attempted to navigate to node without a structure organizer object.");
		return;
	}
	this.m_organizer.navigateToNode(navigationData);
};

/**
 * Attaches necessary controllers to the structure organizer as well as other customized events such as the dirty handler
 * and a resize function.
 */
StructureManager.prototype.finalizeStructure = function() {
	var organizer = this.m_organizer;
	if(!organizer) {
		return;
	}
	//Set the resize function on the organizer
	organizer.setResizeFunction(this.m_resizeFunction);
	//Set the dirty change callback.
	organizer.setOnDirtyChangeCallback(this.m_onDirtyChangeCallback);
	//Finalize the structure object.
	organizer.finalize();
	//Attach the interaction controllers.
	(new CycleStructureTermController()).attach(organizer);
	(new InputStructureTermController()).attach(organizer);
	(new StructureGroupController()).attach(organizer);
	(new YesNoStructureTermController()).attach(organizer);
	(new TableTermController()).attach(organizer);
	(new StructureTermGroupController()).attach(organizer);
	//Only attach the tab controller if it is a multi-section structure.
	if(organizer.isMultiSection()) {
		var tabController = new StructureTabController();
		tabController.attach(organizer);
		//Keep reference to the tab controller since it requires some resize logic later.
		this.m_tabController = tabController;
	}
};

/**
 * Simple check to determine if the data received from the server has provided reference data for structured documentation.
 * This should come back from the server in the form of section_ref[].
 * @returns {boolean} True if the data received contains structured reference data, otherwise false.
 */
StructureManager.prototype.hasStructuredContent = function() {
	return (this.m_referenceData !== null) && this.m_referenceData.length > 0;
};

/**
 * Determines if the data received from the server has provided question data. This should come back from the server
 * in the form of user_options: [].
 * @returns {boolean} True if the data received contains questions, otherwise false.
 */
StructureManager.prototype.hasQuestions = function() {
	return this.m_questionData !== null;
};

/**
 * Uses the JSONStructureOrganizerBuilder to build a set of questions.
 * @returns {StructureQuestionSet} A question set built from the question data received.
 */
StructureManager.prototype.generateQuestionSet = function() {
	var self = this;
	var questionData = this.m_questionData;
	this.m_questionSet = (new JSONStructureOrganizerBuilder().setNamespace(this.m_namespace)).buildQuestionSet(questionData);
	this.m_questionSet.setOnCompleteCallback(function(complete){
		self.m_$addTemplateButton.prop("disabled", !complete);
	});
	return this.m_questionSet;
};

/**
 * Helper function to attach necessary events.
 */
StructureManager.prototype.finalize = function() {
	this.finalizeStructure();
	this.attachQuestionDelegates();
};

/**
 * Shows the question container and injects the question set into the question contents wrapper. It also defaults the
 * add templates button to being disabled until the question set is considered complete.
 */
StructureManager.prototype.showQuestions = function() {
	var $questionContainer = this.m_$questionContainer;
	$questionContainer.show();
	//Generate the question set
	var questionSet = this.generateQuestionSet();
	this.m_$questionContents.html(questionSet.render());
	this.m_$addTemplateButton.prop("disabled", true);
};

/**
 * Shows the structure container and injects the structured documentation html into the contents wrapper. It first builds
 * the structure content based on the data retrieved from the server.
 */
StructureManager.prototype.showStructure = function() {
	this.m_$structureContainer.show();
	var $structureOrganizerContents = this.m_$structureOrganizerContents;
	var builder = new JSONStructureOrganizerBuilder();
	builder.setNamespace(this.m_namespace);
	builder.setStructureJSON(this.m_referenceData[0]);
	var organizer = builder.buildStructureTree();
	this.m_organizer = organizer;
	//Append the organizer html
	$structureOrganizerContents.html(organizer.renderHtml());
};

/**
 * Shows a structured documentation error message in the message container element.
 * @param {string} message - The message to be shown.
 */
StructureManager.prototype.showStructureErrorMessage = function(message) {
	this.m_$messageContainer.html(message);
	this.m_$messageContainer.show();
};


/**
 * Sets the reply information based on the data retrieval response. This data must be of the form...
 * {
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...],
 * 		"section_act" : {},
 		"user_options" : [...]
 * }
 * @param replyData - The information received from a call to retrieve structured documentation data. This information
 * can be retrieved by either query template or open existing.
 */
StructureManager.prototype.setReplyData = function(replyData) {
	this.setStatus(replyData.status || "F");
	this.setReferenceData(replyData.section_ref || null);
	this.setActivityData(replyData.section_act || null);
	if(replyData.user_options && replyData.user_options.length) {
		this.setQuestionData(replyData.user_options);
	} else {
		this.setQuestionData(null);
	}
};

/**
 * Simple passthrough function which calls resetDirty on the structure organizer.
 */
StructureManager.prototype.resetDirty = function() {
	if(this.m_organizer) {
		this.m_organizer.resetDirty();
	}
};

/**
 * Resets all of the service-retrieved field back to their defauls. Take note that the status is
 * defaulted to 'F', so failure is assumed until proven otherwise by the services that retrieve the
 * data.
 */
StructureManager.prototype.resetReplyData = function() {
	this.m_replyData = null;
	this.m_referenceData = null;
	this.m_activityData = null;
	this.m_questionData = null;
	this.m_status = "F";
};

/**
 * Sets the status of the service call to query template or open existing.
 * @param {string} status - The status of the service call. This is either successful, failure,
 * or a Z status.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setStatus = function(status) {
	if(typeof status !== "string") {
		throw new Error("StructureManager.prototype.setStatus expects a string (S/F/Z)");
	}
	this.m_status = status;
	return this;
};

/**
 * Sets the reference data retrieved from the call to query template or open existing.
 * @param {Object} referenceData - The reference data (section_ref) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} returns self to allow chaining.
 */
StructureManager.prototype.setReferenceData = function(referenceData) {
	this.m_referenceData = referenceData;
	return this;
};

/**
 * Sets the activity data retrieved from the call to query template or open existing.
 * @param {Object} activityData - The activity data (section_act) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setActivityData = function(activityData) {
	this.m_activityData = activityData;
	return this;
};

/**
 * Sets the question data retrieved from the call to query template or open existing.
 * @param {Object} questionData - The user options (user_options) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setQuestionData = function(questionData) {
	this.m_questionData = questionData;
	return this;
};

/**
 * Handles merging activity data (section_act) into the pre-constructed structure tree. This function
 * will do nothing if there is no structure tree (structure organizer) or there is no activity data.
 */
StructureManager.prototype.mergeActivity = function() {
	if(!this.m_organizer || !this.m_activityData) {
		return;
	}
	var updater = new JSONStructureOrganizerBuilder();
	updater.update(this.m_organizer, this.m_activityData);
	this.resetDirty();
};

/**
 * Exposes a function for querying template in structured documentation. It is expected that the consumer has provided
 * the m_queryTemplateFunction which makes a call to query template and calls the callback with the response data.
 */
StructureManager.prototype.queryTemplate = function() {
	if(!this.m_queryTemplateFunction) {
		logger.logError("StructureManager.prototype.queryTemplate: No query template function provided.");
		return;
	}
	var self = this;
	var requestData = {
		"USER_OPTION_RESPONSES" : this.m_answers
	};
	this.m_queryTemplateFunction(requestData, function(reply){
		self.m_answers = null;
		self.setReplyData(reply);
		self.refresh();
	});
};

/**
 * Exposes a function for opening existing structured documentation sections. It is expected that the consumer has
 * provided the m_openExistingFunction which makes a call to open existing and calls the callback with the response
 * data.
 */
StructureManager.prototype.openExisting = function() {
	if(!this.m_openExistingFunction) {
		logger.logError("StructureManager.prototype.openExisting: No open existing function provided.");
		return;
	}
	var self = this;
	var requestData = {
		"USER_OPTION_RESPONSES" : this.m_answers
	};
	this.m_openExistingFunction(requestData, function(reply){
		self.m_answers = null;
		self.setReplyData(reply);
		self.refresh();
	});
};
/**
 * Base class for validators that validates input
 */
function InputValidator() {
}

InputValidator.prototype.validate = function (input) {
	return true;
};

InputValidator.prototype.getMessage = function () {
	return "";
};

/**
 * DataTypeValidator
 * This class is for validating specified data types. The supported data types are ALPHA,
 * NUMERIC. Depending on the data type, a specific regular expression will
 * be created.
 * @returns {DataTypeValidator}
 * @constructor
 */
function DataTypeValidator() {
	this.m_dataType = DataTypeValidator.ALPHA_TYPE;
	this.m_dataRegex = DataTypeValidator.ALPHA_REGEX;
	return this;
}

/**
 * The string constant that denotes an alpha data type
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.ALPHA_TYPE = "ALPHA";

/**
 * The regular expression regular expression for validating the alpha data type.
 * The alpha type consists of alphanumerics and symbols.
 * 
 * Allowed symbols: `~!@#$%^&*()_+-=,.<>?;:''"{}|\/[]
 * 
 * TODO: revisit to support other languages/regions
 * 
 * @constant {RegExp}
 * @static
 */
DataTypeValidator.ALPHA_REGEX = /^[a-zA-Z0-9 `~!@#$%^&*()_+-=,.<>?;:''"{}|\\\/\[\]]*$/;

/**
 * The string constant that denotes an numeric data type
 * 
 * TODO: revisit to support other languages/regions
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.NUMERIC_TYPE = "NUMERIC";

/**
 * The regular expression regular expression for validating the numeric data type.
 * The numeric type allows for positive and negative integers.
 *  
 * @constant {RegExp}
 * @static
 */
DataTypeValidator.NUMERIC_REGEX = /^[-]?[0-9]*[.]?[0-9]*$/;

/**
 * The string constant that denotes an alpha data type
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.prototype = new InputValidator();
DataTypeValidator.prototype.constructor = InputValidator;

/**
 * Gets the data type for this validator.
 * 
 * @returns {string} The data type for this validator
 */
DataTypeValidator.prototype.getDataType = function () {
	return this.m_dataType;
};

/**
 * Sets the data type for the DataTypeValidator. This data type will determine the regular
 * expression that is created.
 * 
 * @param {string} dataType - The data type that this DataTypeValidator should expect. This can
 * be "ALPHA" or "NUMERIC". The default is "ALPHA" values.
 * @returns {DataTypeValidator}
 */
DataTypeValidator.prototype.setDataType = function (dataType) {
	this.m_dataType = dataType;
	switch (dataType) {
		case DataTypeValidator.NUMERIC_TYPE:
			this.m_dataRegex = DataTypeValidator.NUMERIC_REGEX;
			break;
		// ALPH includes alphanumerics and it is the default as well
		case DataTypeValidator.ALPHA_TYPE:
		default:
			this.m_dataType = DataTypeValidator.ALPHA_TYPE;
			this.m_dataRegex = DataTypeValidator.ALPHA_REGEX;
	}
	return this;
};

/**
 * Overrides the base getMessage function. This generates a message informing
 * what values this validator expects.
 * @returns {string} The message explaining what types this validator accepts.
 */
DataTypeValidator.prototype.getMessage = function () {
	var message = '';
	
	switch (this.m_dataType) {
		case DataTypeValidator.NUMERIC_TYPE:
			message = "Number (+- 0-9)";
			break;
		case DataTypeValidator.ALPHA_TYPE:
		default:
			message = "Alphabetical and Numeric";
	}

	return "<span class='term-info-item'>This field accepts only {0} characters</span>".replace("{0}", message);
};

DataTypeValidator.prototype.validate = function (input) {
	return this.m_dataRegex.test(input);
};

DataTypeValidator.prototype.getDataRegex = function () {
	return this.m_dataRegex;
};

DataTypeValidator.prototype.setDataRegex = function (dataRegex) {
	if (!RegExp.prototype.isPrototypeOf(dataRegex)) {
		throw new Error("Cannot set regex with non regex type");
	}
	this.m_dataRegex = dataRegex;
	return this;
};

function DataRangeValidator() {
	this.m_minValue = Number.NEGATIVE_INFINITY;
	this.m_maxValue = Number.POSITIVE_INFINITY;
	return this;
}

DataRangeValidator.prototype = new InputValidator();
DataRangeValidator.prototype.constructor = InputValidator;

DataRangeValidator.prototype.getMessage = function () {
	return "<span class='term-info-item'>Number must be between {0} and {1}</span>".replace("{0}", this.m_minValue).replace("{1}", this.m_maxValue);
};

DataRangeValidator.prototype.validate = function (input) {
	try {
		var numericValue = parseFloat(input);
		if (isNaN(numericValue)) {
			throw new Error("Input is not a number type, cannot validate");
		}
		return (numericValue <= this.m_maxValue && numericValue >= this.m_minValue);
	} catch (exe) {
		return false;
	}
};

DataRangeValidator.prototype.setMinValue = function (minValue) {
	if (typeof minValue !== "number") {
		throw new Error("Cannot setMinValue with non number type");
	}
	if (minValue > this.m_maxValue) {
		throw new Error("Cannot set a minValue greater than the max value");
	}
	this.m_minValue = minValue;
	return this;
};

DataRangeValidator.prototype.setMaxValue = function (maxValue) {
	if (typeof maxValue !== "number") {
		throw new Error("Cannot setMaxValue with non number type");
	}
	if (maxValue < this.m_minValue) {
		throw new Error("Cannot set a maxValue less than the min value");
	}
	this.m_maxValue = maxValue;
	return this;
};

TemplateEngine={};
(function(ns,$){ns.getHtmlTags=function(){var tags=["html","span","head","body","pre","h1","h2","h3","h4","h5","h6","b","i","em","strong","font","a","p","br","dl","dt","dd","ol","ul","li","div","img","hr","table","th","tr","td","tbody","thead","form","option","input","textarea","button"];
var result={};
result=ns.getTags(tags);
return result;
};
ns.getTags=function(tags){var result={};
$.each(tags,function(i,tagname){result[tagname]=ns.tag(tagname);
});
return result;
};
ns.tag=function(tagname){return function(){var args=[].slice.call(arguments);
args.unshift(tagname);
var tagObj=new ns.Tag(tagname);
ns.Tag.apply(tagObj,args);
return tagObj;
};
};
ns.button=function(attributes){attributes.type="button";
return new ns.Tag("input",attributes,null);
};
ns.textbox=function(attributes){attributes.type="text";
return new ns.Tag("input",attributes,null);
};
ns.Tag=function(name,args){this.name=name;
this.parent=null;
this.element=null;
this.content="";
this.attributes={};
if(arguments.length==1){return;
}var arg2=arguments[1];
var contentOffset=1;
if(arg2 instanceof Object&&!(arg2 instanceof ns.Tag)&&!(arg2 instanceof String)&&!(arg2 instanceof Array)){this.attributes=arg2;
contentOffset=2;
}if(arguments.length==2&&contentOffset==2){return;
}var contentArr=[];
for(var i=contentOffset;
i<arguments.length;
i++){if(arguments[i] instanceof Array){$.merge(contentArr,arguments[i]);
}else{contentArr.push(arguments[i]);
}}this.content=contentArr;
};
ns.Tag.prototype.render=function(){this.makeElement();
this.makeContent();
return this.element;
};
ns.Tag.prototype.makeElement=function(){var element=$("<"+this.name+"></"+this.name+">");
$.each(this.attributes,function(key,value){if(!value){value="";
}element.attr(key,value);
});
this.element=element;
return element;
};
ns.Tag.traverse=function(content,parentTag){if(!content){return;
}if(content instanceof ns.Tag){content.parent=parentTag;
parentTag.element.append(content.render());
return;
}if(!(content instanceof Array)){parentTag.element.append(content);
return;
}$.each(content,function(key,value){ns.Tag.traverse(value,parentTag);
});
};
ns.Tag.prototype.makeContent=function(){ns.Tag.traverse(this.content,this);
};
ns.Template=function(templateFunction){this.m_function=templateFunction;
this.m_factory=null;
};
ns.Template.prototype.render=function(context){var scope=new ns.ScopeManager();
if(this.m_factory){this.m_factory.before(scope);
}var rootTag=this.m_function(context);
if(!(rootTag instanceof ns.Tag)){alert("The template function does not return a Tag instance.");
}var rendered=rootTag.render();
scope.clean();
if(this.m_factory){this.m_factory.after(scope);
}return rendered;
};
ns.TemplateFactory=function(templates){var self=this;
$.each(templates,function(k,v){if(k!="before"&&k!="after"){self[k]=new ns.Template(v);
self[k].m_factory=self;
}else{self[k]=v;
}});
};
ns.TemplateFactory.prototype.before=function(){};
ns.TemplateFactory.prototype.after=function(){};
ns.ScopeManager=function(){this.m_originalScope={};
};
ns.ScopeManager.prototype.use=function(objects){var self=this;
$.each(objects,function(k,v){if(window[k]!==undefined){self.m_originalScope[k]=window[k];
}window[k]=v;
});
};
ns.ScopeManager.prototype.clean=function(){var self=this;
$.each(this.m_originalScope,function(k,v){window[k]=v;
});
};
}(TemplateEngine,jQuery));
/**
 * @class
 * This class wraps the checkpoint system. It allows developers to make use of the RTMS V4 API.
 * @returns {CheckpointTimer}
 * @constructor
 */
function CheckpointTimer() {
	this.m_checkpointObject = null;
	try {
		this.m_checkpointObject = CERN_Platform.getDiscernObject("CHECKPOINT");
	} catch (exe) {
		logger.logError("Unable to create checkpoint object via window.external.DiscernObjectFactory('CHECKPOINT')");
		return this;
	}
	return this;
}

/**
 * Sets the ClassName parameter on the checkpoint object, if it exists. The class name identifies which class
 * this checkpoint originates from.
 * @param {string} className - The ClassName parameter for the checkpoint object.
 * @returns {CheckpointTimer}
 */
CheckpointTimer.prototype.setClassName = function (className) {
	if (this.m_checkpointObject) {
		this.m_checkpointObject.ClassName = className;
	}
	return this;
};

/**
 * Sets the ProjectName parameter on the checkpoint object. The project name identifies the project that this
 * checkpoint originates from.
 * @param {string} projectName - The ProjectName parameter for the checkpoint object.
 * @returns {CheckpointTimer}
 */
CheckpointTimer.prototype.setProjectName = function (projectName) {
	if (this.m_checkpointObject) {
		this.m_checkpointObject.ProjectName = projectName;
	}
	return this;
};

/**
 * Sets the EventName on the checkpoint object. The event name identifies which event the checkpoint originates
 * from.
 * @param {string} eventName - The EventName for the checkpoint object.
 * @returns {CheckpointTimer}
 */
CheckpointTimer.prototype.setEventName = function (eventName) {
	if (this.m_checkpointObject) {
		this.m_checkpointObject.EventName = eventName;
	}
	return this;
};

/**
 * Sets the SubEventName on the checkpoint object. The sub event name identifies which sub-event the checkpoint
 * originates from.
 * @param {string} subEventName - The SubEventName for the checkpoint object.
 * @returns {CheckpointTimer}
 */
CheckpointTimer.prototype.setSubEventName = function (subEventName) {
	if (this.m_checkpointObject) {
		this.m_checkpointObject.SubEventName = subEventName;
	}
	return this;
};

/**
 * Calls Publish on the checkpoint object. This will publish the checkpoint out to the timer system.
 */
CheckpointTimer.prototype.publish = function () {
	if (this.m_checkpointObject) {
		this.m_checkpointObject.Publish();
	}
};

/**
 * This will add a metadata value to the checkpoint object with the specified key and value.
 * @param {string} key - The key value for the metadata.
 * @param {string} value - The value for the metadata.
 */
CheckpointTimer.prototype.addMetaData = function(key, value) {
	if(this.m_checkpointObject && key && value) {
		try {
			//Check where the code is being run (Millennium vs Web) so we can call the appropriate 
			//metadata function.  
			if(CERN_Platform.inMillenniumContext()){
				//Call the win32 implementation of MetaData (Millennium)
				this.m_checkpointObject.MetaData(key) = value; 
			}else{
				//Call the web enabled implementation of metaData (Web Enabled)
				this.m_checkpointObject.MetaData(key,value);
			}
		} catch (e) {
			logger.logError("Error adding MetaData [" + key + "] = " + value + "; on CheckpointTimer");
			return this;
		}
	}
	return this;
};
/**
 * @class
 * This class handles the classic use of timers in our system. This version of the timer makes use of the
 * Checkpoint system rather than the traditional Start and Stop methods.
 * @param {string} timerName - The name of the timer. This maps to the original TimerName of the old timer system.
 * @param {string} subTimerName - The name of the sub timer. This maps to the original SubTimerName of the old timer system.
 * @returns {RTMSTimer}
 * @constructor
 */
function RTMSTimer(timerName, subTimerName) {
	this.m_checkpointTimer = new CheckpointTimer();
	this.m_checkpointTimer.setEventName(timerName);
	this.m_checkpointTimer.addMetaData("rtms.legacy.subtimerName", subTimerName);
	return this;
}

/**
 * Adaptor method that simply passes through to the checkpoint object and adds metadata.
 * @param {String} key - the metadata key.
 * @param {String} value - the metadata value.
 */
RTMSTimer.prototype.addMetaData = function(key, value) {
	this.m_checkpointTimer.addMetaData(key, value);
	return this;
};

/**
 * Starts the timer by setting the SubEventName on the checkpoint and calling publish.
 */
RTMSTimer.prototype.start = function() {
	this.checkpoint("Start");
};

/**
 * @deprecated
 * This method has been deprecated. Use RTMSTimer.prototype.start instead.
 * @constructor
 */
RTMSTimer.prototype.Start = function() {
	this.start();
};

/**
 * Stops the timer by setting the SubEventName on the checkpoint and calling publish.
 */
RTMSTimer.prototype.stop = function() {
	this.checkpoint("Stop");
};

/**
 * @deprecated
 * This method has been deprecated. Use RTMSTimer.prototype.stop instead.
 * @constructor
 */
RTMSTimer.prototype.Stop = function() {
	this.stop();
};

/**
 * Fails the timer by setting the SubEventName on the checkpoint and calling publish.
 */
RTMSTimer.prototype.fail = function() {
	this.checkpoint("Fail");
};

/**
 * @deprecated
 * This method has been deprecated. Use RTMSTimer.prototype.fail instead.
 * @constructor
 */
RTMSTimer.prototype.Abort = function() {
	this.fail();
};

/**
 * Publishes a checkpoint for the timer.
 * @param {string} subEventName - The sub event name of the checkpoint.
 */
RTMSTimer.prototype.checkpoint = function(subEventName) {
	this.m_checkpointTimer.setSubEventName(subEventName);
	this.m_checkpointTimer.publish();
};/**
 * @class
 * @param {string} timerName - The name of the timer. This maps to the original TimerName of the old timer system.
 * @param {string} subTimerName - The name of the sub timer. This maps to the original SubTimerName of the old timer system.
 * @returns {CapabilityTimer} - Returns self.
 * @constructor
 */
function CapabilityTimer(timerName, subTimerName) {
	this.m_checkpointTimer = new CheckpointTimer();
	this.m_checkpointTimer.setEventName(timerName);
	this.m_checkpointTimer.addMetaData("rtms.legacy.subtimerName", subTimerName);
	return this;
}

/**
 * Adaptor method that simply passes through to the checkpoint object and adds metadata.
 * @param {String} key - the metadata key.
 * @param {String} value - the metadata value.
 */
CapabilityTimer.prototype.addMetaData = function(key, value) {
	this.m_checkpointTimer.addMetaData(key, value);
	return this;
};

/**
 * This method will perform a capability capture. This is meant to capture a piece of functionality
 * in order to determine how often something is used. Notice that is makes use of the checkpoint system
 * and simply calls Start followed by Stop immediately.
 */
CapabilityTimer.prototype.capture = function () {
	this.m_checkpointTimer.setSubEventName("Start-Stop");
	this.m_checkpointTimer.publish();
};/**
 * @class
 * This class helps measure the time spent on a sequence of tasks.
 * Its designed to track a list of tasks and automatically stops the timer when all the tasks are completed.
 * When the tasks are not completed before the failure time out, it will automatically abort the timer.
 * @param {string} timerName - The name of the timer.
 * @param {string} subTimerName - The name of the sub timer.
 * @returns {AggregateTimer}
 * @constructor
 */
function AggregateTimer(timerName, subTimerName) {
	this.m_rtmsTimer = new RTMSTimer(timerName, subTimerName);
	this.m_timerStatus = AggregateTimer.Status.NOT_STARTED;
	this.m_isRegistrationOpen = true;
	this.m_taskList = [];
	//set the time out to be 120 seconds
	this.m_failureTimeoutSeconds = 120;

	return this;
};

/**
 * Enumeration type that represents the AggregateTimer's status
 * Not started: The timer is not started yet.
 * Started: The timer is started.
 * Terminated: The timer is stopped or aborted.
 */
AggregateTimer.Status = {
	NOT_STARTED: 0,
	STARTED: 1,
	TERMINATED: 2
};

/**
 * Adaptor method that simply passes through to the RTMSTimer object and adds metadata.
 * @param {String} key - the metadata key.
 * @param {String} value - the metadata value.
 * @returns {undefined} undefined
 */
AggregateTimer.prototype.addMetaData = function(key, value) {
	this.m_rtmsTimer.addMetaData(key, value);
	return this;
};

/**
 * It marks the timer as already being started and begins waiting for the failure time out.
 * If the tasks fail to complete before the time out, it will call abortTimer to abort the timer.
 * It is used in the scenario when a timer is started before access to the AggregateTimer API is made available.
 * Otherwise the startTimer function should be used.
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.markTimerStarted = function() {
	if(this.m_timerStatus === AggregateTimer.Status.NOT_STARTED){
		this.m_timerStatus = AggregateTimer.Status.STARTED;
		//at this point the timer is already started.
		// It will check if the timer has been stopped (when all tasks are completed) after the specified time.
		// Otherwise it will log an error message and include the tasks that are not completed yet.
		var self = this;
		setTimeout(function(){
			if(self.m_timerStatus === AggregateTimer.Status.STARTED){
				self.abortTimer();
			}
		}, this.m_failureTimeoutSeconds * 1000);
	}else{
		logger.logWarning("AggregateTimer is not in a valid status to mark the timer as being started.");
	}
	return this;
};


/**
 * It registers a tasks in the aggregate timer object by putting it in the task list.
 * @param {string} taskId The ID/name of the task
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.registerTask = function(taskId) {
	if(this.m_isRegistrationOpen){
		this.m_taskList.push(taskId);
	}else{
		logger.logWarning("AggregateTimer can't register task "+ taskId + " becaues registration is locked.");
	}
	return this;
};

/**
 * It locks the registration so no other tasks can be registered.
 * Only after closing the registration, AggregateTimer can be stopped when the last task completes.
 * In the rare scenarios when all components finish loading before registration is locked, this function will stop the timer.
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.lockRegistration = function() {
	this.m_isRegistrationOpen = false;
	//if all tasks are completed, it should stop the timer
	if(this.m_taskList.length === 0){
		this.stopTimer();
	}
	return this;
};

/**
 * It crosses off a task off the task list. When the task list becomes empty, it will automatically stop the timer.
 * @param {string} taskId The ID/name of the task
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.completeTask = function(taskId) {
	if(this.isTerminated()){
		logger.logWarning("AggregateTimer is attempting to complete the task " + taskId + " when the timer is already terminated. ");
		return;
	}

	var taskArray = this.m_taskList;
	//remove the completed task from the task list
	var taskIndex = $.inArray(taskId, taskArray);
	if(taskIndex > -1){
		taskArray.splice(taskIndex,1);
	}

	//if all tasks are completed after registration is closed, it should stop the timer
	if(!this.m_isRegistrationOpen && taskArray.length === 0){
		this.stopTimer();
	}

	return this;
};

/**
 * It starts the timer by calling the RTMSTimer's start function.
 * It also calls markTimerStarted to change the internal status to "started".
 * If a timer with the same name and subtimer name is already started outside of the API,
 * function markTimerStarted should be called instead.
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.startTimer = function() {
	if(this.m_timerStatus === AggregateTimer.Status.NOT_STARTED){
		this.m_rtmsTimer.start();
		this.m_timerStatus = AggregateTimer.Status.STARTED;
		this.markTimerStarted();
	}else{
		logger.logWarning("AggregateTimer is not in a valid status to start the timer. ");
	}
	return this;
};

/**
 * It stops the timer and changes the internal status to "terminated" so it cannot be stopped/aborted again.
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.stopTimer = function() {
	if(this.m_timerStatus === AggregateTimer.Status.STARTED){
		this.m_rtmsTimer.stop();
		this.m_timerStatus = AggregateTimer.Status.TERMINATED;
	}else{
		logger.logWarning("AggregateTimer is not in a valid status to stop the timer. ");
	}
	return this;
};

/**
 * It aborts the timer and changes the internal status to "terminated" so it cannot be stopped/aborted again.
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.abortTimer = function() {
	if(this.m_timerStatus === AggregateTimer.Status.STARTED){
		this.m_rtmsTimer.fail();
		this.m_timerStatus = AggregateTimer.Status.TERMINATED;
		var taskListString = this.m_taskList.join(",");
		logger.logWarning("AggregateTimer has timed out with incompleted task(s): " + taskListString);
	}else{
		logger.logWarning("AggregateTimer is not in a valid status to abort the timer. ");
	}
	return this;
};

/**
 * It specifies the tasks failure time out.
 * If not set, the default value is 120 seconds because most MPages are expected to finish loading within the time frame.
 * @param {number} timeInSeconds The failure timer out in seconds
 * @returns {AggregateTimer}
 */
AggregateTimer.prototype.setFailureTimeoutSeconds = function (timeInSeconds){
	if(typeof timeInSeconds !== "number"){
		throw new Error("Function setFailureTimeoutSeconds is expecting a number.");
	}
	this.m_failureTimeoutSeconds = timeInSeconds;
	return this;
};

/**
 * It returns whether the timer has been stopped or aborted.
 * @returns {boolean} The flag that indicates whether the timer is terminated
 */
AggregateTimer.prototype.isTerminated = function() {
	return (this.m_timerStatus === AggregateTimer.Status.TERMINATED);
};
(function($) {
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	/**
	 * A HealthPlanSelector to be created within a given element if health plans found
	 */
	HealthPlanSelector = function(){
		this.setOnSelect(null);
		this.setPatient(0.0);
		this.setRetrievalHasTriggered(false);
		this.setHealthPlans([]);
		this.setNamespace(null);
		this.setElement(null);
		this.setEncounterId(0.0);
		this.setErrorContainer(null);
		this.setCurrentPlan(null);
		this.setI18n(i18n.discernabu.health_plan_selector);
		this.setAlertMessageControl(null);
	};
	// Create static attributes to cache initial eligibility trigger / pref retrieval at an encounter level
	HealthPlanSelector.eligibilityHasTriggered = false;
	HealthPlanSelector.eligibilityEnabled = 0;
	HealthPlanSelector.eligibilityAcuteEnabled = 0;
	HealthPlanSelector.isAcuteEncounter = 0;

	attribute(HealthPlanSelector, "HealthPlans");
	attribute(HealthPlanSelector, "OnSelect");
	attribute(HealthPlanSelector, "Namespace");
	attribute(HealthPlanSelector, "RetrievalHasTriggered");
	attribute(HealthPlanSelector, "Patient");
	attribute(HealthPlanSelector, "Element");
	attribute(HealthPlanSelector, "UserId");
	attribute(HealthPlanSelector, "EncounterId");
	attribute(HealthPlanSelector, "ErrorContainer");
	attribute(HealthPlanSelector, "CurrentPlan");
	attribute(HealthPlanSelector, "I18n");
	attribute(HealthPlanSelector, "AlertMessageControl");
	attribute(HealthPlanSelector, "IsAcute");
	attribute(HealthPlanSelector, "SharedResource");
	
	/**
	 * renderButton render a button to trigger search for available health plans
	 * @param  {DOM element} element The element in which to render the button
	 */
	HealthPlanSelector.prototype.renderButton = function(element){
		var healthPlanSelector = this;
		var namespace = this.getNamespace() || "";
		var buttonId = namespace + "healthPlanButton";
		var buttonElement = $('#' + buttonId);
		if (!buttonElement || !buttonElement.length){
			buttonElement = $("<a id='" + buttonId + "' class='health-plan-selector-anchor'>" + this.getI18n().CHECK_HEALTH_PLANS +"</a>");
			element.html(buttonElement);
			buttonElement.click(function(){
				healthPlanSelector.checkHealthPlanClickFunc();
			});
		}
		else{
			buttonElement.removeClass('health-plan-loading');
			buttonElement.text(this.getI18n().CHECK_HEALTH_PLANS);
		}
	};

	/**
	 * Function to be performed when check health plans is cliekced. Updates styling and requests health plans
	 */
	HealthPlanSelector.prototype.checkHealthPlanClickFunc = function(){
		var element = this.getElement();
		$('.health-plan-selector-anchor', element).addClass('health-plan-loading').text(this.getI18n().CHECKING_HEALTH_PLANS);
		$("#"+this.getNamespace()+"healthPlanRetryBtn").addClass('health-plan-loading');
		this.requestHealthPlans(element, null);
	};

	/**
	 * Handle the mp_get_trans_details reply to render the desired
	 * @param  {DOM element} element DOM element to render into
	 * @param  {[type]} reply 	Reply to mp_get_patient_trans_details
	 */
	HealthPlanSelector.prototype.handleHealthPlanReply = function(element, reply){
		$('.loading', element).hide();
		var elContainer = $('.health-plan-content', element);
		var self = this;
		var namespace = this.getNamespace() || "";
		var response;
		var messageType;
		var message;
		var TRANSACTION_STATUSES = {
			"NONE": 0,
			"SUCCESS": 1,
			"PENDING": 2,
			"ERROR": 3
		};

		response = reply.RECORD_DATA;
		var status = response.STATUS_DATA.STATUS;
		var venueType = response.ENCNTR_GRP_DISP;
		var acutePreference = HealthPlanSelector.eligibilityAcuteEnabled;
		var isAcute = HealthPlanSelector.isAcuteEncounter;
		var sharedResource = this.getSharedResource();
		var defaultValue = "1";
		if (isAcute && !acutePreference){
			// If acute encounter without preferences, display acute message
			messageType = MPageControls.AlertMessage.MessageTypes.INFORMATION;
			message = "<span>" + this.getI18n().HEALTH_PLAN_ACUTE_MSG + " " + this.getI18n().HEALTH_PLAN_ACUTE_MSG_SEC + "</span>";
			this.displayMessage(message, messageType);
		} else {
			// If status is succesful, health plans have been returned!
			if (status === "S"){
				var healthPlanReply = response.HEALTH_PLAN;
				var healthPlanCnt = healthPlanReply.length;
				this.setHealthPlans(healthPlanReply);				
				var dropDownContainer = $("<div class='health-plan-selector-container' id='"  + namespace + "PlanSelectorContainer'><div class='health-plan-selector-label'>" + this.getI18n().HEALTH_PLAN + ":</div><div class='health-plan-selector-dropdown' id='" + namespace +"PlanSelectorDropdown'></div></div>");			
				$(elContainer).html(dropDownContainer);
				var selectorContainer = $('#' + namespace + "PlanSelectorDropdown");
				var healthSelector = new Selector(selectorContainer, healthPlanReply);
				healthSelector.setValueField('INTERCHANGE_SEQ');
				healthSelector.setDisplayField('DISPLAY');
				healthSelector.setDefaultDisplay(this.getI18n().PLAN_WITHOUT_NAME);
				healthSelector.setOnSelect(function(plan){
					self.getOnSelect()(plan);
					self.setCurrentPlan(plan);	
					if(self.getAlertMessageControl()){
						self.getAlertMessageControl().close();
					}
				});
				//Ensure the first health plan is selected if at least one health plan is returned
				if (healthPlanReply && healthPlanReply[0]){
					defaultValue = healthPlanReply[0].INTERCHANGE_SEQ;
				}
				healthSelector.setDefaultValue(defaultValue);
				healthSelector.init();
			}
			//If no health plans have been retrieved, base actions off of transaction status
			else if(status==="Z"){
				var transactionStatus = response.TRANSACTION_STATUS;
				//No transactions found for the patinet
				if (transactionStatus === TRANSACTION_STATUSES.NONE){
					this.displayError();
				}
				//Transaction is pending - health plans have not been retrieved yet
				else if (transactionStatus === TRANSACTION_STATUSES.PENDING) {
					var retryBtnId = namespace + "healthPlanRetryBtn";
					message = "<span>" + this.getI18n().STILL_PROCESSING+" <a id='"+retryBtnId+"' class='health-plan-retry-anchor'>"+this.getI18n().RETRY+"</a></span>";	
					messageType = MPageControls.AlertMessage.MessageTypes.INFORMATION;
					this.displayMessage(message,messageType);
					$("#"+retryBtnId).on('click', function(){
						self.checkHealthPlanClickFunc();
					});
					this.renderButton(elContainer);
					// Ensure resource data is not marked as available when transaction is pending
					sharedResource.setIsAvailable(false);
				}
				// Display message for no health plans found
				else{
					message = this.getI18n().NO_HEALTH_PLANS_FOUND;
					var noHealthPlansEle = "<span class ='no-health-plan-found'>" + message + "</span>";
					this.getElement().html(noHealthPlansEle);
					// We need to remove the processing health banner if it exists even after getting 'No health plans found' with status data 's'
					var stillProcessingMessage = this.getErrorContainer();
					if(stillProcessingMessage){
						 $(stillProcessingMessage).remove();
					}
				}	
			}
			else{ // Error
				this.displayError();
			}
		}
	};

	/**
	 * Creates and submits request to mp_get_patient_trans_details to obtain health plan information for selected patient
	 * @param  {HTML element}   element The element where the HealthPlanSelector will be rendered
	 * @param  {float}   patientId The Id of the patient to retrieve health plans for
	 */
	HealthPlanSelector.prototype.requestHealthPlans = function(element){
		var self = this;
		//If eligibilitychecking disabled, don't retrieve health plans
		if (!HealthPlanSelector.eligibilityEnabled){
			$(element).empty();
			return;
		}
		$('.loading', element).show();
		var patientId = this.getPatient();
		//Function to be called when healthplans are loaded
		var healthPlanLoadCallback = function(){
			var data = sharedPlanResource.getResourceData();
			data = JSON.parse(data);
			self.handleHealthPlanReply(element, data);
		};			
		//Generate a shared resource using the 'HEALTH-PLANS-LOADED' event to ensure that healthplans
		//are not loaded multiple times
		CERN_EventListener.addListener(this,EventListener.HEALTH_PLANS_RETRIEVED,healthPlanLoadCallback,this);
		var sharedPlanResource = MP_Resources.getSharedResource('available-health-plans');
		if (!sharedPlanResource){
			sharedPlanResource = new SharedResource('available-health-plans');
			sharedPlanResource.setCclProgram('mp_get_patient_trans_details');
			sharedPlanResource.setCclParams(["^MINE^", patientId+".0"]);
			sharedPlanResource.setEventListenerObject(this);
			sharedPlanResource.setEventListenerFlag(EventListener.HEALTH_PLANS_RETRIEVED);
			MP_Resources.addSharedResource(sharedPlanResource.getName(),sharedPlanResource);
		}
		this.setSharedResource(sharedPlanResource);
		if (sharedPlanResource.isResourceAvailable()){
			//If healthplans are already loaded, then handle healthplans using callback
			healthPlanLoadCallback();
		}
		else{
			sharedPlanResource.retrieveSharedResourceData();
		}
	};
	
	/**
	 * Trigger formulary eligibility based on the current encounter and user
	 */
	HealthPlanSelector.prototype.triggerFormularyEligibility = function(){
		//Create a ScriptRequest object
		var self = this;
		var scriptRequest = new ScriptRequest();
		scriptRequest.setProgramName("mp_trigger_formlry_eligiblty");
		scriptRequest.setParameterArray(["^MINE^",this.getUserId()+".0",this.getEncounterId() + ".0",0,0]);
		scriptRequest.setResponseHandler(function(reply){
			self.handleTriggerFormularyEligReply(reply);
		});
		scriptRequest.performRequest();
	};

	/**
	 * Handle the reply from trigger_formlry_eligiblty
	 * @param  {ScriptReply} reply ScriptReply from trigger_formlr_eligibility
	 */
	HealthPlanSelector.prototype.handleTriggerFormularyEligReply = function(reply){
		var response = reply.getResponse();
		var status = response.STATUS_DATA.STATUS;
		var errorStatus = response.ERROR_STATUS;
		var eligibilityEnabled;
		var eligibilityAcuteEnabled;
		var element = this.getElement();
		if(status === "S" || status === "Z"){
			HealthPlanSelector.eligibilityHasTriggered = true;
			HealthPlanSelector.eligibilityEnabled = response.ELIGIBILITY_ENABLED;
			HealthPlanSelector.eligibilityAcuteEnabled = response.ELIGIBILITY_ACUTE_ENABLED;
			HealthPlanSelector.isAcuteEncounter = response.ENCOUNTER_ACUTE;
			//Retrieve health plans only if eligibility enabled
			this.requestHealthPlans(element);
		}
		else if(status === "F"){ // Display error if no valid npi 
			if(errorStatus === "NO_NPI"){
				messageType = MPageControls.AlertMessage.MessageTypes.INFORMATION;
				message = "<span>"+this.getI18n().NO_NPI+"</span>";
				this.displayMessage(message, messageType);
				$(element).empty();
			}
			else{
				this.displayError();
				$(element).empty();
			} 
		}	
	};

	/**
	 * Displays a message within the error container
	 * @param  {String} message     Message to be displayed
	 * @param  {String} messageType Message type (Error, Information, Warning)
	 */
	HealthPlanSelector.prototype.displayMessage = function(message, messageType){
		var element = null;
		var control = null;
		var target = this.getErrorContainer();
		if(!target){
			return;
		}		
		var msgHTML = message;
		var template = MPageControls.getDefaultTemplates().messageBar;
		control = new MPageControls.AlertMessage(target, template, messageType);
		control.setIsClosable(true);
		control.render(msgHTML);
		this.setAlertMessageControl(control);
	};
	
	/**
	 * Displays an error message within the error container
	 */
	HealthPlanSelector.prototype.displayError = function(){
		var message = "<span>" + this.getI18n().HEALTH_PLAN_ERROR_MSG + "</span>" + " <span class='secondary-msg-text'>" + this.getI18n().HEALTH_PLAN_ERROR_MSG_SEC + "</span>";		
		var messageType = MPageControls.AlertMessage.MessageTypes.ERROR;
		this.displayMessage(message,messageType);
	};

	/**
	 * Initializes the health plan selector
	 */
	HealthPlanSelector.prototype.init = function(){
		//Render initial html of preloader and content container
		var element = this.getElement();
		var patientId = this.getPatient();
		$(element).html("<div class='loading health-plan-preloader'></div><div class='health-plan-content'></div>");
		// Only trigger eligibility and retrieve preferences if it hasn't been previously done in same session
		if (!HealthPlanSelector.eligibilityHasTriggered){
			this.triggerFormularyEligibility();
		}
		else{
			this.requestHealthPlans(element);
		};
	};

})(jQuery);
function NomenclatureSearchByName(searchTerm,terminologyCD,isContains,callback,failureCallback){var terminologyJson=[{terminology_cd:terminologyCD}];
var searchType=isContains?3:1;
var json={nomenclature_search_request:{search_type_flag:searchType,preferred_type_flag:1,search_string:searchTerm,terminology_cds:terminologyJson,terminology_axis_cds:[],principle_type_cds:[],max_results:20,effective_flag:0,active_flag:0}};
var sendAr=[];
sendAr.push("^MINE^","0.0","5","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",sendAr,true,function(status,recordData){if("S"===status){if(recordData){var drgResults=new Array();
for(var i=0,length=recordData.NOMENCLATURES.length;
i<length;
i++){var drg=recordData.NOMENCLATURES[i];
drgResults.push({NAME:drg.DESCRIPTION+" ("+drg.SOURCE_IDENTIFIER+")",VALUE:{SOURCEIDENTIFIER:drg.SOURCE_IDENTIFIER,NOMENCLATUREID:drg.NOMENCLATURE_ID},DETAILS:"<strong>Description</strong>: <dfn>"+drg.DESCRIPTION+"</dfn><br><strong>Code</strong>: <em>"+drg.SOURCE_IDENTIFIER+"</em>"});
}callback(drgResults);
}}else{if("Z"===status){callback();
}else{if("F"===status){failureCallback();
}}}});
}function NomenclatureSearchByCode(searchTerm,terminologyCD,callback,failureCallback){var terminologyJson=[{terminology_cd:terminologyCD}];
var json={nomenclature_search_request:{search_type_flag:1,preferred_type_flag:1,search_string:searchTerm,terminology_cds:terminologyJson,terminology_axis_cds:[],principle_type_cds:[],max_results:20,effective_flag:0,active_flag:0}};
var sendAr=[];
sendAr.push("^MINE^","0.0","6","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",sendAr,true,function(status,recordData){if("S"===status){if(recordData){var drgResults=new Array();
for(var i=0,length=recordData.NOMENCLATURES.length;
i<length;
i++){var drg=recordData.NOMENCLATURES[i];
drgResults.push({NAME:drg.DESCRIPTION+" ("+drg.SOURCE_IDENTIFIER+")",VALUE:{SOURCEIDENTIFIER:drg.SOURCE_IDENTIFIER,NOMENCLATUREID:drg.NOMENCLATURE_ID},DETAILS:"<strong>Description</strong>: <dfn>"+drg.DESCRIPTION+"</dfn><br><strong>Code</strong>: <em>"+drg.SOURCE_IDENTIFIER+"</em>"});
}callback(drgResults);
}}else{if("Z"===status){callback();
}else{if("F"===status){failureCallback();
}}}});
}
/**
 * nomenclature-search.js
 * @author Nick Root
 *
 * NomenclatureSearch Class
 * ============================================================================
 *
 * Extends the AutoSuggest class and allows the searching of nomenclature terms.
 *
 * This control utilizes the Nomenclature Entity along with MP_SEARCH_NOMENCLATURES and
 * ProcedureSearch (4174064) transaction of the Nomenclature Incremental Search Service
 *
 */
(function($) {
	// ------------------------------------------------------------------------
	// Import Shortcuts
	// ------------------------------------------------------------------------
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var ns = MPageControls;

	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	MPageControls.NomenclatureSearch = function(element) {
		ns.AutoSuggest.call(this, element);
        this.setICD10CodeValues([]);
	};

	inherits(ns.NomenclatureSearch, ns.AutoSuggest);

	// ----------------------------------------------------------------
	// Attributes
	// ----------------------------------------------------------------
	attribute(ns.NomenclatureSearch, "SuggestionLimit");
	attribute(ns.NomenclatureSearch, "SourceFlag");
	attribute(ns.NomenclatureSearch, "IsEnabled");
	attribute(ns.NomenclatureSearch, "ICD10CodeValues");
    attribute(ns.NomenclatureSearch, "SourceVocabCodeValue");

	//____________________________________________
	/* 	SourceFlag Valid Values
	 * 		1 - 	Condition ICD9
	 * 		2 - 	Condition SNOMED
	 * 		3 - 	Condition IMO
	 * 		4 - 	Condition IMO as synonyms of ICD-9
	 * 		5 - 	Condition HLI PFT
	 * 		6 - 	Condition Mayo Problems
	 * 		7 - 	Condition ICD-10
	 * 		8 - 	Procedure CPT-4
	 * 		9 -		Procedure ICD-9
	 * 		10 - 	Procedure ICD-10
	 * 		11 - 	Allergy MULTUM Drug, MULTUM Allergy, and Allergy source vocabularies
	 *		12 - 	Reaction SNOMED CT terminology (Clinical Findings, Context-dependent Categories, Events)     
	 *
	 * 	Note: 1-7 calls mp_ent_nomencalture while 8-10 calls the ProcedureSearch (4174064) transaction
	 * 		  11 calls AllergySearch (4174062)	transaction
	 * 		  12 calls ReactionSearch / SNOMED CT (4174062) transaction	
	 */
	//_____________________________________________

	var prot = MPageControls.NomenclatureSearch.prototype;

    var vocabMeaningToFlagMap = {
        'ICD9': 1,
        'SNMCT': 2,
        'IMO': 3,
        'HLI.PFT' : 5,
        'MAYO_PROB': 6,
        'ICD10-CM': 7
    };

    /**
     * Checks if the code value entity instance is an ICD10 vocabulary
     * by checking the ICD10CodeValues array.
     *
     * @param codevalue
     * @returns {boolean}
     */
    var isICD10Vocab = function(codevalue) {
        var icd10cvs = this.getICD10CodeValues();
        for (var i=icd10cvs.length; i--;) {
            if (icd10cvs[i] == codevalue.getId()) {
                return true;
            }
        }
        return false;
    };

    /**
     * Returns the meaning of the vocabulary. Will perform a call to the
     * code value entity if the meaning was not set. This has the side effect
     * of avoiding any future calls, since that field will now be populated.
     *
     * @param codevalue
     */
    var getVocabMeaning = function(codevalue) {
        if (!codevalue.getMeaning()) {
            codevalue.refresh();
        }
        return codevalue.getMeaning();
    };

    /**
     * Converts a vocabulary code value into a flag that is suitable to be
     * passed to the search service.
     *
     * @returns {number}
     */
    var retrieveSearchFlagFromCodeValue = function() {
        var sourceVocab = this.getSourceVocabCodeValue();

        if (isICD10Vocab.call(this, sourceVocab)) {
            return 7;
        }

        var meaning = getVocabMeaning.call(this, sourceVocab);
        var flag = vocabMeaningToFlagMap[meaning];

        if (!flag) {
			var err = new Error('The ' + meaning + ' vocabulary is not supported as a search target.');
			if (logger && logger.logJSError) {
				logger.logJSError(err, this, "nomenclature-search.js", "retrieveSearchFlagFromCodeValue");
			}
            throw err;
        }

        return flag;
    };

	/**
	 * Sets the template to render list items and attaches searchNomens()
	 * function to be triggered when the user types.
	 */
	prot.init = function() {
		MPageControls.AutoSuggest.prototype.init.call(this);
		var self = this;
		var list = this.getList();

		// If no limit is specified, default to 10 results
		if (!this.getSuggestionLimit()) {
			this.setSuggestionLimit(10);
		}

		this.setDelay(500);
		this.setListItemTemplate(MPageControls.getDefaultTemplates().nomenSearchItem);
		this.setListTemplate(MPageControls.getDefaultTemplates().autoSuggestList);
		this.setIsEnabled(true);
		
		this.setOnDelay(function() {
			self.searchNomens();
		});
		
		this.getList().getElement().hover(function() {
			// Removes highlight from other items
			list.getElement().find("." + list.getHighlightClass()).removeClass(list.getHighlightClass());
		});
	};
	
	/**
	 * Disables the nomenclature search box 
	 */
	prot.disable = function() {
		var inputWrapper = this.getElement().find(".auto-suggest.input");
		var textBox = this.getTextbox();
		
		//add disabled class to wrapper
		inputWrapper.toggleClass("disabled");
		
		//remove caption
		this.deactivateCaption();
		
		//disable the text box
		textBox.prop("disabled", true);
		
		this.setIsEnabled(false);
	};
	
	/**
	 * Enables the nomenclature search box 
	 */
	prot.enable = function() {
		var inputWrapper = this.getElement().find(".auto-suggest.input");
		var textBox = this.getTextbox();
		
		//add disabled class to wrapper
		inputWrapper.toggleClass("disabled");
		
		//remove caption
		this.activateCaption();
		
		//enable the text box
		textBox.prop("disabled", false);
		
		this.setIsEnabled(true);
	};

	/**
	 * Retrieves the necessary parameter values and calls the search function of the Nomenclature entity
	 */
	prot.searchNomens = function() {
		var searchTerm = this.getValue();
		var sourceFlag = this.getSourceFlag();
		var searchLimit = this.getSuggestionLimit();
		var closeBtnId = this.getClosebtnId();
		var closeBtn = $('#' + closeBtnId);
		var self = this;

		//Validate search parameters
		if (!sourceFlag) {
			throw "[*ERROR*] NomenSearch: No source flag specified.";
		}

		//show loading icon
		closeBtn.toggleClass('close-btn');
		closeBtn.toggleClass('loading-icon');

		//Make request
		MPageEntity.entities.Nomenclature.search({
			'searchTerm' : searchTerm,
			'sourceFlag' : sourceFlag,
			'resultLimit' : searchLimit
		}, function(hR, r, e) {
			self.handleReplyList(hR, r, e);
		}, true);
	};

	/**
	 * Send the resulting reply list to the base AutoSuggest function
	 * @param {Object} replyList : The processed JSON reply
	 * @param {Object} reply : The raw JSON reply from the back-end
	 * @param {Object} err : Error message if something went wrong
	 */
	prot.handleReplyList = function(replyList, reply, err) {
		var closeBtnId = this.getClosebtnId();
		var closeBtn = $('#' + closeBtnId);
		var list = this.getList();
		var detailDialog = this.getDetailDialog();
		if (!replyList) {
			throw (err);
		}

		closeBtn.toggleClass('close-btn');
		closeBtn.toggleClass('loading-icon');

		//handle no results
		if(replyList.length <= 0){
			this.setListTemplate(MPageControls.getDefaultTemplates().emptyList);
			
			var listHTML = list.getListTemplate().render();
			list.getElement().empty();
			list.getElement().append(listHTML);

			detailDialog.show();
			detailDialog.updatePosition();
		}
		else {
			this.setListTemplate(MPageControls.getDefaultTemplates().autoSuggestList);
			this.setSuggestions(replyList);
			list.setSelectedItem(replyList[0]);
		}
	};

    /**
     * Returns the source flag that was set using setSourceFlag, or - if a vocabulary
     * was set with setSourceVocabCodeValue -, converts the vocabulary to a flag and returns
     * that value.
     *
     * @returns {*}
     */
    prot.getSourceFlag = function() {
        if (this.m_SourceFlag) {
            return this.m_SourceFlag;
        }
        return retrieveSearchFlagFromCodeValue.call(this);
    };
})(jQuery);

/**
 *This OrderProfileOrderReview object extends the base class DailyOrderReview.
 * It implements functions of launching the daily orders review modal.
 * Launching Daily Orders Review requires the following fields:
 *   reviewId - Unique ID  (component Id)
 *   selectedFilter - Selected Filter (filtered applied to display the orders, by default it is All Active Orders)
 *					  This filter has been used to determine Daily Orders Review API to display Information header on top of the Review Modal
 *@constructor
 @param {number} reviewId - Unique ID  (component Id)
 */
function OrderProfileOrderReview(reviewId) {
	this.m_reviewId = reviewId;
	this.m_selectedFilter = "";
	this.m_i18nReview = i18n.discernabu.order_review;
	this.m_ordersReviewObj = new DailyOrderReview();
}
OrderProfileOrderReview.prototype = new DailyOrderReview();
OrderProfileOrderReview.prototype.constructor = DailyOrderReview;

/**
 * The setSelectedFilter function sets selectedFilter
 *@param {string} selectedFilter - stores selected filter value in order profile component
 */
OrderProfileOrderReview.prototype.setSelectedFilter = function (selectedFilter) {
	if (selectedFilter) {
		this.m_selectedFilter = selectedFilter;
	}
};

/**
 * The getSelectedFilter function is to retrieve selected filter
 * @returns {string} selected filter value in order profile component
 */
OrderProfileOrderReview.prototype.getSelectedFilter = function () {
	return this.m_selectedFilter;
};

/*
 *This function calls the order service to get all the qualified orders for active encounter of patient
 * @param {function} a callback function
*/
OrderProfileOrderReview.prototype.getQualifiedDailyOrders = function (callback) {
	var self = this;
	try {
		var APPLICATION_NUMBER = 560201;
		var TASK_NUMBER = 3202004;
		var REQUEST_NUMBER = 680851;
		var requestParam = self.getScriptRequestParams();
		var personId = (requestParam.PERSON_ID) ? requestParam.PERSON_ID : 0.0;
		var encounterId = (requestParam.ENCOUNTER_ID) ? requestParam.ENCOUNTER_ID : 0.0;
		var providerId = (requestParam.PRSNL_ID) ? requestParam.PRSNL_ID : 0.0;
		var DATE = new Date();
		
		var JSONParam = {daily_review_criterias:[{
				person_id : personId,
				daily_review_loading_criteria : {
					load_pending_ind : 1,
					load_overdue_ind : 1
				}
			}],
			daily_review_anchor_dt_tm : DATE,
			user_id : providerId
		};
		
		var replyObj = self.m_ordersReviewObj.makeScriptCall(JSONParam, APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER);
		var reviewData = replyObj.m_responseData;
		var status = reviewData.STATUS_DATA.STATUS;
		if(status === 'S' && reviewData.DAILY_REVIEW_RESPONSES.length){
			var dailyReviews = reviewData.DAILY_REVIEW_RESPONSES[0].DAILY_REVIEWS;
			var qualifiedOrders = [];
			for(var i=dailyReviews.length; i--; ){
				if(dailyReviews[i].ENCOUNTER_ID === encounterId){
					qualifiedOrders.push(dailyReviews[i]);
				}
			}
			self.setReviewOrders(qualifiedOrders);
			self.m_ordersReviewObj.setReviewOrders(qualifiedOrders);
			self.m_ordersReviewObj.setPendingOrders(qualifiedOrders.length);
		}
		if(callback){
			callback();
		}
		
	} catch (error) {
		logger.logJSError(error, null, "op-review.js", "getQualifiedDailyOrders");
	}
};

/**
 * It launches the Orders Review Modal Dialog.
 */
OrderProfileOrderReview.prototype.launchOrderReviewModal = function () {
	var self = this;
	//stores the request param values to daily order review base class object
	var requestParam = self.getScriptRequestParams();
	self.m_ordersReviewObj.setScriptRequestParams(requestParam);
	var userTimeZone = self.getTimeZone();
	self.m_ordersReviewObj.setTimeZone(userTimeZone);
	self.getQualifiedDailyOrders();
	var orderList = self.getReviewOrders();
	var modalElementId = "_" + this.m_reviewId;
	var orderReviewModal = MP_ModalDialog.retrieveModalDialogObject("ordersReview" + modalElementId);
	var actionButton = new ModalButton("ordersReviewActionButton" + self.m_reviewId);
	var closeButton = new ModalButton("ordersReviewCloseButton" + self.m_reviewId);
	if(!orderReviewModal){
		orderReviewModal = new ModalDialog("ordersReview" + modalElementId);
		actionButton.setOnClickFunction(function () {
			var time_zone = self.getTimeZone();
			var reviewButtonClass = "review-split-btn_" + self.m_reviewId;
			self.m_ordersReviewObj.markOrdersAsReviewed(self.m_reviewId, time_zone, reviewButtonClass);
		});
		var selectedCount = (orderList.length) ? " (" + orderList.length + ")" : "";
		actionButton.setText(this.m_i18nReview.REVIEW_BUTTON_LABEL + selectedCount);
		if (selectedCount === 0) {
			actionButton.setIsDithered(true);
		}
		orderReviewModal.addFooterButton(actionButton);
		closeButton.setOnClickFunction(function () {
			$(window).unbind(".ordersReviewCloseModal");
		});
		closeButton.setCloseOnClick(true);
		closeButton.setText(i18n.CANCEL);
		orderReviewModal.addFooterButton(closeButton);
	}
	orderReviewModal.setHeaderElementId("ordersReviewModalHeader" + modalElementId);
	orderReviewModal.setBodyElementId("ordersReviewModalBody" + modalElementId);
	orderReviewModal.setFooterElementId("ordersReviewFooter" + modalElementId);
	orderReviewModal.setHeaderTitle(this.m_i18nReview.REVIEW_MODAL_TITLE);
	var selectedFilter = self.getSelectedFilter();
	if (selectedFilter && selectedFilter !== self.m_i18nReview.ALL_ACTIVE) {
		self.m_ordersReviewObj.setMessageHeader(true);
	} else {
		self.m_ordersReviewObj.setMessageHeader(false);
	}
	orderReviewModal.setBodyDataFunction(function () {
		var modalElement = $("#vwpModalDialog" + orderReviewModal.getId());
		modalElement.addClass("wf");
		modalElement.addClass("dor-modal-dialog");
		var timerRenderComponent = MP_Util.CreateTimer("ENG:MPG.DAILYREVIEWORDERS.01 - render");
		var modalBody = $("#" + orderReviewModal.getBodyElementId());
		modalBody.html("<div class='dor-preloader-modal'></div><div class='dor-preloader-text'>" + self.m_i18nReview.LOADING_ORDERS + "</div>");	
		try {
			var orderDetails = self.getOrdersdetail(orderList);
			var modalDialogContent = self.m_ordersReviewObj.generateReviewHtmlContent(self.m_reviewId, orderDetails);
			modalBody.html(modalDialogContent);			
		} catch (error) {
			if (timerRenderComponent) {
				timerRenderComponent.Abort();
				timerRenderComponent = null;
			}
			var errorBannerHtml = self.m_ordersReviewObj.generateErrorBannerHtml();
			modalBody.html(errorBannerHtml);
			logger.logJSError(error, null, "op-review.js", "launchOrderReviewModal");
		}finally {
			if (timerRenderComponent) {
				timerRenderComponent.Stop();
			}
		}  
	});
	MP_ModalDialog.addModalDialogObject(orderReviewModal);
	MP_ModalDialog.showModalDialog(orderReviewModal.getId());
	self.m_ordersReviewObj.postRenderEventHandler(self.m_reviewId, actionButton.m_buttonId, orderReviewModal.getId());
};
/**
 * This DailyOrderReview object is the base implementation Daily Orders Review.
 * It defines the functions to generate the content of the review modal.
 * @constructor
 */
var isAllOrdersViewed = false;
function DailyOrderReview() {
	this.m_userTimeZone = null;
	this.m_isButton = false;
	this.m_isMessage = false;	
	this.m_reviewOrders = [];
	this.m_columnArray = [];
	this.m_requestParams = {};
	this.m_i18nReview = i18n.discernabu.order_review;
	this.m_reviewTable = null;
	this.m_pendingOrders = 0;
}

/**
 * The setScriptRequestParams function sets the personId and prsnlId
 *@param {object} requestParam - stores person id and personnel id
 */
DailyOrderReview.prototype.setScriptRequestParams = function (requestParam) {
	if (requestParam) {
		this.m_requestParams = requestParam;
	}
};

/**
 * The getScriptRequestParams function is to retrieve personId and prsnlId
 * @returns {JSON Object} request in params for calling the services
 */
DailyOrderReview.prototype.getScriptRequestParams = function () {
	return this.m_requestParams;
};

/**
 * The setReviewOrders function sets the qualified orders for review
 *@param {array} reviewOrders - orders record data to be reviewed
 */
DailyOrderReview.prototype.setReviewOrders = function (reviewOrders) {
	if (reviewOrders && reviewOrders.length !== 0) {
		this.m_reviewOrders = reviewOrders;
	}
};

/**
 * The getReviewOrders function is to retrieve the qualified orders for review
 * @returns {array} orders record data to be reviewed 
 */
DailyOrderReview.prototype.getReviewOrders = function () {
	return this.m_reviewOrders;
};

/**
 * The getColumnHeaderArray function is to retrieve column header array
 * @returns {array} column header array
 */
DailyOrderReview.prototype.getColumnHeaderArray = function () {
	if (this.m_columnArray.length !== 0) {
		return this.m_columnArray;
	} else {
		return [{
				ID : "ORDER_ID",
				CLASS : "det-hd",
				DISPLAY : "",
				SORTABLE : false,
				RENDER_TEMPLATE : "${ORDER_ID}"
			}, {
				ID : "ORDER_SYN_ID",
				CLASS : "det-hd",
				DISPLAY : "",
				SORTABLE : false,
				RENDER_TEMPLATE : "${SYNONYM_ID}"
			}, {
				ID : "MULTI_SELECT",
				CLASS : "dor-venue",
				DISPLAY : "&nbsp;",
				SORTABLE : false,
				RENDER_TEMPLATE : "${CHECKBOX_HTML}"
			}, {
				ID : "NOTIFICATIONS",
				CLASS : "dor-notifications",
				DISPLAY : "&nbsp;",
				SORTABLE : false,
				RENDER_TEMPLATE : "${NOTIFY_HTML}"
			}, {
				ID : "VENUE",
				CLASS : "dor-venue",
				DISPLAY : i18n.TYPE,
				SORTABLE : false,
				RENDER_TEMPLATE : "${VENUE_HTML}"
			}, {
				ID : "ORDER",
				CLASS : "dor-name",
				DISPLAY : this.m_i18nReview.ORDER,
				SORTABLE : false,
				RENDER_TEMPLATE : "<span class='op-ord-name'>${ORDER}</span> <span class='op-detail'>${ORD_DETAILS}</span>"
			},{
				ID : "STATUS",
				CLASS : "dor-status",
				DISPLAY : i18n.ORDER_STATUS,
				SORTABLE : false,
				RENDER_TEMPLATE : "${STATUS}"
			}, {
				ID : "LAST_UPDATED",
				CLASS : "dor-last-updated",
				DISPLAY : i18n.LAST_UPDATED,
				SORTABLE : true,
				PRIMARY_SORT : "STATUS_UPDT_DTTM_UTC",
				SECONDARY_SORT : "ORIGPROV",
				RENDER_TEMPLATE : "${LAST_UPDATED}"
			}/*, {
				ID : "LAST_REVIEWED",
				CLASS : "op-statusdt",
				DISPLAY : "Last Reviewed",
				SORTABLE : false,
				RENDER_TEMPLATE : "${ORIGPROV}"
			} */
		];
	}
};

/**
 * The setTimeZone function sets the client time zone
 *@param {number} timeZone -client time zone
 */
DailyOrderReview.prototype.setTimeZone = function (timeZone) {
	if (timeZone) {
		this.m_userTimeZone = timeZone;
	}
};

/**
 * The getTimeZone function is to retrieve client time zone
 * @returns {number} client time zone 
 */
DailyOrderReview.prototype.getTimeZone = function () {
	return this.m_userTimeZone;
};

/**
 * The setActionButton function sets a flag which indicates whether to include action buttons
 * @param {boolean} buttonFlag - This is an indicator indicating if the modal will have default action buttons
 */
DailyOrderReview.prototype.setActionButton = function (buttonFlag) {
	if (typeof buttonFlag === "boolean") {
		this.m_isButton = buttonFlag;
	}
};

/**
 * The isActionButton function gets a flag which indicates whether to include action buttons
 * @returns {boolean} 
 */
DailyOrderReview.prototype.isActionButton = function () {
	return this.m_isButton;
};

/**
 * The setMessageHeader function sets a flag which indicates whether to include message bar
 * @param {boolean} messsagFlag - This is an indicator indicating if the modal will have message bar
 */
DailyOrderReview.prototype.setMessageHeader = function (messsagFlag) {
	if (typeof messsagFlag === "boolean") {
		this.m_isMessage = messsagFlag;
	}
};

/**
 * The isMessageHeader function gets a flag which indicates whether to include message bar
 * @returns {boolean} 
 */
DailyOrderReview.prototype.isMessageHeader = function () {
	return this.m_isMessage;
};

/**
 * The setPendingOrders function sets number of pending orders to be reviewed
 *@param {number} pendingOrders - stores number of pending orders to be reviewed
 */
DailyOrderReview.prototype.setPendingOrders = function (pendingOrders) {
	if (pendingOrders) {
		this.m_pendingOrders = pendingOrders;
	}
};

/**
 * The getPendingOrders function is to retrieve number of pending orders to be reviewed
 * @returns {number} pendingOrders - stores number of pending orders to be reviewed
 */
DailyOrderReview.prototype.getPendingOrders = function () {
	return this.m_pendingOrders;
};

/*
 *This function builds the venue html 
 @param {object} order -  order object
 @returns {string} html string for displaying notify icon
*/
DailyOrderReview.prototype.buildNotifyHTML = function(order){
	var notifyHtml = [];
	var opi18n = i18n.discernabu.order_profile_o1;
	//build HTML string for displaying notification icons
	if (order.REVIEW_INFORMATION.PHYSICIAN_COSIGNATURE_STATUS.REQUIRED_IND) {
		notifyHtml.push("<span class='dorSprite dor-cosign' title='", opi18n.COSIGN_HOVER, "'></span>");
	}
	if (order.CARE_PLAN_INFORMATION.NAME) {
		notifyHtml.push("<span class='dorSprite dor-powerplan' title='", order.CARE_PLAN_INFORMATION.NAME, "'></span>");
	}
	if (order.COMMENTS.ORDER_COMMENT) {
		notifyHtml.push("<span class='dor-comments-icon'></span>");
	}
	return notifyHtml;
};

/*
 *This function builds the venue html 
 @param {object} order -  order object
 @returns {string} html string for displaying venue icon
*/
DailyOrderReview.prototype.buildVenueHTML = function(order){
	var venueHtml = [];
	var opi18n = i18n.discernabu.order_profile_o1;
	if (order.VENUE.ACUTE_IND) {
		venueHtml.push("<span class='dor-inpat-icon' title='", opi18n.INPATIENT, "'>&nbsp;</span>");
	} else if (order.VENUE.AMBULATORY_IND) {
		venueHtml.push("<span class='dor-amb-icon' title='", opi18n.AMBULATORY, "'>&nbsp;</span>");
	} else if (order.VENUE.PRESCRIPTION_IND) {
		venueHtml.push("<span class='dor-rx-icon' title='", opi18n.PRESCRIPTION, "'>&nbsp;</span>");
	} else {
		venueHtml.push("<span>&nbsp</span>");
	}
	return venueHtml;
};

/*
 *Creates last updated data value
 @param {string} action_dt_tm - last action performed date
 @param {string} provName - provider name
 @returns {string} - combination of last updated date and last updated provider name
*/
DailyOrderReview.prototype.createLastUpdatedValue = function(action_dt_tm, provName){
	var i18nReview = i18n.discernabu.order_review;
	var lastUpdated = "";
	var providerFullName = "";
	var noResult = "--";
	var df = MP_Util.GetDateFormatter();
	var fullDateTimeTwoYear = mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR;
	var fullDate4Year = mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR;
	var lastUpdatedDay = df.formatISO8601(action_dt_tm, fullDate4Year);
	var today = new Date();
	var todayDate = df.format(today, fullDate4Year);
	var yesterday = new Date(new Date().setDate(new Date().getDate()-1));
	var yesterdayDate = df.format(yesterday, fullDate4Year);
	if(lastUpdatedDay === todayDate){
		lastUpdatedDay = i18nReview.TODAY;
	}else if(lastUpdatedDay === yesterdayDate){
		lastUpdatedDay = i18nReview.YESTERDAY;
	}else{
		lastUpdatedDay = df.formatISO8601(action_dt_tm, fullDateTimeTwoYear);
	}
	// check if we have a valid provider name. If not, we will have double dashes.
	providerFullName = noResult;
	if (provName !== null && provName.fullName) {
		providerFullName = provName.fullName;
	}
	lastUpdated = lastUpdatedDay + " "  + providerFullName;
	return lastUpdated;
};

/**
 * Reads the struct returned by service and populates the orders array,
 * then builds the HTML for each row and pushes it onto the orders
 * @param {Number} reviewId : A unique Id -- can be the component ID number
 * @param {Object[]} reviewOrders : The array holding the data retrieved by service
 * @returns {Object[]} reviewOrders - The array holding the build JSON record data for the display
 */
DailyOrderReview.prototype.buildReviewDisplayobject = function (reviewId, reviewOrders){
	var opi18n = i18n.discernabu.order_profile_o1;
	var reviewOrdersDisplayObj = [];
	var ordProfile = reviewOrders.ORDERS;
	var prsnlArray = MP_Util.LoadPersonelListJSON(reviewOrders.PRSNL);
	var codesArray = MP_Util.LoadCodeListJSON(reviewOrders.CODES);
	var ordersLength = ordProfile.length;
	for(var i=0; i<ordersLength; i++){	
		var inactiveStatuses = ["DISCONTINUED", "CANCELED", "COMPLETED", "PENDING", "DELETED", "VOIDEDWRSLT", "TRANS/CANCEL"];
		var provName = "";
		var ordStatus = "";
		var medType = "";
		var deptStatus = "";
		var statusType = "";
		var ordVenue = "";
		var isRx = false;
		provName = MP_Util.GetValueFromArray(ordProfile[i].CORE.RESPONSIBLE_PROVIDER_ID, prsnlArray);
		ordStatus = MP_Util.GetValueFromArray(ordProfile[i].CORE.ORDER_STATUS_CD, codesArray);
		medType = MP_Util.GetValueFromArray(ordProfile[i].MEDICATION_INFORMATION.MEDICATION_ORDER_TYPE_CD, codesArray);
		deptStatus = MP_Util.GetValueFromArray(ordProfile[i].CORE.DEPARTMENT_STATUS_CD, codesArray);
				
		//check if the order is active or inactive
		if(inactiveStatuses.indexOf(ordStatus.meaning) > -1){
			//order is inactive
			statusType = "inactive";
		} else {
			//order is active
			statusType = "active";
		}
		var notifyHtml = this.buildNotifyHTML(ordProfile[i]);
		var venueHtml = this.buildVenueHTML(ordProfile[i]);
		var lastUpdated = this.createLastUpdatedValue(ordProfile[i].LAST_ACTION_INFORMATION.ACTION_DT_TM, provName);
		if (ordProfile[i].VENUE.PRESCRIPTION_IND) {
			ordVenue = opi18n.PRESCRIPTION;
		}
		isRx = (ordVenue === opi18n.PRESCRIPTION);
		
		//create the data structure for the row
		var reviewOrdersJSON = {
			ORDER : ordProfile[i].DISPLAYS.CLINICAL_NAME,
			ORDER_ID : ordProfile[i].CORE.ORDER_ID,
			STATUS : (isRx && ordStatus.meaning === "ORDERED") ? i18n.PRESCRIBED : ordStatus.display,
			STATUS_MEANING : ordStatus.meaning,
			STATUS_TYPE : statusType,
			ORD_DETAILS : (ordProfile[i].MEDICATION_INFORMATION.MEDICATION_ORDER_TYPE_CD !== 0) ? ordProfile[i].DISPLAYS.SIMPLIFIED_DISPLAY_LINE : ordProfile[i].DISPLAYS.CLINICAL_DISPLAY_LINE,
			LAST_UPDATED : lastUpdated,
			SELECTED : true,
			DAILY_REVIEW_DATE : ordProfile[i].DAILY_REVIEW_DATE,
			NOTIFY_HTML : notifyHtml.join(""),
			VENUE_HTML : venueHtml.join(""),
			CHECKBOX_HTML : "<input class='review-checkBox-" + reviewId + "' id='" + i + "_review_checkBox_" + reviewId + "' type='checkbox' checked='true'>"
		};
		reviewOrdersDisplayObj.push(reviewOrdersJSON);
	}
	return reviewOrdersDisplayObj;
};

/**
 * Set up the handler for events
 * @param {string} reviewId - a unique ID
 * @param {string} reviewButtonId - review action button id, it is passed to the function postRenderEventHandler()
 * as a parameter when the API is being consume by the order profile component
 */
DailyOrderReview.prototype.postRenderEventHandler = function (reviewId, reviewButtonId) {
	var checkedCount = 0;
	var buttonLabel = this.m_i18nReview.REVIEW_BUTTON_LABEL;
	
	//adds scrollbar in the table body content if number of rows exceeds the height of modal window
	var modalElement = $("#ordersReviewModalBody_"+reviewId);
	var modalElementNode = modalElement.get(0);
	var hasVerticalScrollbar = (modalElementNode.scrollHeight > modalElement.height());
	if(hasVerticalScrollbar){
		$("#review_"+reviewId+"tableBody").css('overflow-y','scroll');
		var tableHeaderHeight = $("#ordersReviewModalHeader_"+reviewId).height();
		var tableBodyHeight = $("#ordersReviewModalBody_"+reviewId).height();
		var alertMsgHeight = 0;
		if($(".dor-modal-dialog").find(".alert-msg")){
			alertMsgHeight = $(".alert-msg").height() + 10;
		}
		var tableScrollHeight = (tableBodyHeight - tableHeaderHeight - alertMsgHeight - 10) + "px";
		$("#review_"+reviewId+"tableBody").css('max-height', tableScrollHeight);
	}
	
	function updateReviewButtonText(count) {
		if (count === 0) {
			$("#" + reviewButtonId).html(buttonLabel);
			$("#" + reviewButtonId).attr("disabled", "disabled");
		} else {
			$("#" + reviewButtonId).html(buttonLabel + " (" + count + ")");
			$("#" + reviewButtonId).removeAttr("disabled");
		}
	}
	if (reviewButtonId) {
		$(".review-checkBox-" + reviewId).each(function () {
			var checkedStatus = $(this).attr("checked");
			if (checkedStatus === "checked") {
				checkedCount++;
			}
		});
		updateReviewButtonText(checkedCount);
		$(".review-checkBox-" + reviewId).click(function () {
			var checkedStatus = $(this).attr("checked");
			if (checkedStatus === "checked") {
				checkedCount++;
			} else {
				checkedCount--;
			}
			updateReviewButtonText(checkedCount);
		});
		
	}
};

/**
 * Set up the handler for the default action button click
 * @param {string} reviewId - a unique ID
 * @param {object} modalObj - review modal object
 */
DailyOrderReview.prototype.actionButtonClickHandler = function (reviewId, modalObj) {
	var self = this;
	var isButton = self.isActionButton();
	if (isButton) {
		$(".dor-review-modal-button" + reviewId).click(function () {
			var time_zone = self.getTimeZone();
			self.markOrdersAsReviewed(reviewId, time_zone);
		});
	}
};

/*
 *This function creates the error content to be displayed in the dialog 
 *if any error occured during any service call
*/
DailyOrderReview.prototype.generateErrorBannerHtml = function () {
	var errorBanner = new MPageUI.AlertBanner();
	errorBanner.setPrimaryText(this.m_i18nReview.ERROR_PRIMARY_TEXT);
	errorBanner.setSecondaryText("</br><div class='dor-alert-banner-secondary-info'>" + this.m_i18nReview.ERROR_SECONDARY_TEXT + "</div>");
	errorBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.ERROR);
	return errorBanner.render();
};

/*
 *This function call the mp_exec_std_request scripts and returns the reply object
 @param {object} JSONParam - JSON to be passed as blob in parameter
 @param {number} APPLICATION_NUMBER - application number
 @param {number} TASK_NUMBER - task number
 @param {number} REQUEST_NUMBER - request number of the service
*/
DailyOrderReview.prototype.makeScriptCall = function (JSONParam,APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER) {
	var replyObject = null;
	var orderReviewRequest = new ScriptRequest();
	orderReviewRequest.setProgramName("mp_exec_std_request");
	orderReviewRequest.setAsyncIndicator(false);
	orderReviewRequest.setDataBlob(MP_Util.enhancedStringify({
		REQUESTIN : JSONParam
	}));
	orderReviewRequest.setParameterArray(["^MINE^", "^^", APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER]);
	orderReviewRequest.setResponseHandler(function (replyObj) {
		replyObject = replyObj;
	});
	orderReviewRequest.performRequest();
	return replyObject;
};

/*
 *This function calls the order service to get all the qualified orders for active encounter of patient
 * @param {function} a callback function
*/
DailyOrderReview.prototype.getQualifiedDailyOrders = function (callback) {
	var self = this;
	try {
		var APPLICATION_NUMBER = 560201;
		var TASK_NUMBER = 3202004;
		var REQUEST_NUMBER = 680851;
		var requestParam = self.getScriptRequestParams();
		var personId = (requestParam.PERSON_ID) ? requestParam.PERSON_ID : 0.0;
		var providerId = (requestParam.PRSNL_ID) ? requestParam.PRSNL_ID : 0.0;
		var DATE = new Date();
		
		var JSONParam = {daily_review_criterias:[{
				person_id : personId,
				daily_review_loading_criteria : {
					load_pending_ind : 1,
					load_overdue_ind : 1
				}
			}],
			daily_review_anchor_dt_tm : DATE,
			user_id : providerId
		};
		
		var replyObj = self.makeScriptCall(JSONParam, APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER);
		var reviewData = replyObj.m_responseData;
		if(reviewData.DAILY_REVIEW_RESPONSES.length){
			var dailyReviews = reviewData.DAILY_REVIEW_RESPONSES[0].DAILY_REVIEWS;
			self.setReviewOrders(dailyReviews);
		}
		if(callback){
			callback();
		}
		
	} catch (error) {
		logger.logJSError(error, null, "op-review.js", "getQualifiedDailyOrders");
	}
};

/*
 *This function calls the order service to get the details of all the qualified orders for the sign in user
 * @param {array} ordersList - array of qualified orders for review 
 * @returns {array} array that stores details of qualified orders for review 
*/
DailyOrderReview.prototype.getOrdersdetail = function (orderList) {
	try {		
		var loadTimer = new RTMSTimer("USR:MPG.DAILYREVIEWORDERS.01 - load");
		var orderDetails = null;
		var requestParam = this.getScriptRequestParams();
		var encounterId = (requestParam.ENCOUNTER_ID) ? requestParam.ENCOUNTER_ID : 0.0;
		var orderIds = [];
		for(var i=orderList.length; i--; ){
			if(orderList[i].ENCOUNTER_ID === encounterId){
				orderIds.push({"order_id":orderList[i].ORDER_ID});
			}
		}
		var orderReviewRequest = new ScriptRequest();
		orderReviewRequest.setProgramName("mp_get_orders_review");
		var param = MP_Util.enhancedStringify({REQUESTIN : {orders: orderIds}});
		orderReviewRequest.setParameterArray(["^MINE^", "~"+param+"~"]);
		orderReviewRequest.setAsyncIndicator(false);
		orderReviewRequest.setResponseHandler(function (replyObj) {		
			var status = replyObj.m_status; 
			if(status === "S"){
				orderDetails = replyObj.m_responseData;
				//adding DAILY_REVIEW_DATE JSON attribute which store year, month, day of the review
				for(var x=orderList.length; x--; ){
					for(var y=orderDetails.ORDERS.length; y--; ){
						if(orderList[x].ORDER_ID === orderDetails.ORDERS[y].CORE.ORDER_ID){
							orderDetails.ORDERS[y].DAILY_REVIEW_DATE = orderList[x].DAILY_REVIEW_DATE;
						}			
					}
				}
			}else{
				var errorBannerHtml = self.generateErrorBannerHtml();
				return errorBannerHtml;
			}
			
		});
		orderReviewRequest.setLoadTimer(loadTimer);
		orderReviewRequest.performRequest();
		return orderDetails;
	} catch (error) {
		logger.logJSError(error, null, "order-review.js", "getOrdersdetail");
		var errorBannerHtml = self.generateErrorBannerHtml();
		return errorBannerHtml;
	}
};

/*This function creates the content of the Daily Orders Review Modal Dialog
 * @param {string} reviewId - a unique ID
 * @param {array} reviewData - array of review orders object
 * @returns {string} html string for the modal content
*/
DailyOrderReview.prototype.generateReviewHtmlContent = function (reviewId, reviewData) {
	var reviewTable = new ComponentTable();
	this.m_reviewTable = reviewTable;
	reviewTable.setNamespace("review_" + reviewId);
	reviewTable.setCustomClass("dor-table-class");
	var reviewJSONObj = this.buildReviewDisplayobject(reviewId, reviewData);
	var colArr = this.getColumnHeaderArray();
	var colLen = colArr.length;
	for (var y = 0;y < colLen;y++) {
		var curCol = colArr[y];
		var column = new TableColumn();
		column.setColumnId(curCol.ID);
		column.setCustomClass(curCol.CLASS);
		column.setColumnDisplay(curCol.DISPLAY);
		if (curCol.SORTABLE) {
			column.setPrimarySortField(curCol.PRIMARY_SORT);
			column.addSecondarySortField("ORIGPROV", TableColumn.SORT.DESCENDING);
			column.setIsSortable(curCol.SORTABLE);
		}
		column.setRenderTemplate(curCol.RENDER_TEMPLATE);
		reviewTable.addColumn(column);
	}
	reviewTable.bindData(reviewJSONObj);
	reviewTable.sortByColumnInDirection("LAST_UPDATED", TableColumn.SORT.DESCENDING);
	reviewTable.finalize();
	var modalBodyMsg = "";
	var isMessage = this.isMessageHeader();
	if (isMessage) {
		var infoBanner = new MPageUI.AlertBanner();
		infoBanner.setPrimaryText("<span class='dor-alert-banner'>" + this.m_i18nReview.MESSAGE_TEXT + "</span>");
		infoBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.INFO);
		modalBodyMsg = infoBanner.render();
	}
	var actionButtonHtml = "";
	var isActionButton = this.isActionButton();
	if (isActionButton) {
		actionButtonHtml = "<div class='dor-modal-button-container' id='ordersReviewFooter'" + reviewId + "'btnCont'><button class='dor-modal-button dor-review-modal-button" + reviewId + "' id='ordersReviewActionButton" + reviewId + "'>" + this.m_i18nReview.OP_BUTTON_LABEL + "</button><button class='dor-modal-button dor-close-modal-button" + reviewId + "' id='ordersReviewCloseButton" + reviewId + "'>" + i18n.CANCEL + "</button></div>";
	}
	var modalBodyContent = modalBodyMsg + reviewTable.render() + actionButtonHtml;
	return modalBodyContent;
};

/*
 *This function shows error dialog box if the review operation fails
*/
DailyOrderReview.prototype.showReviewErrorDialog = function () {
	var modalObj = MP_Util.generateModalDialogBody("reviewErrorMessage", "error", this.m_i18nReview.REVIEW_ERROR, "</br>" + this.m_i18nReview.REVIEW_ERROR_INFO);
	var closeButton = modalObj.getFooterButton("closeButton");
	if (!closeButton) {
		closeButton = new ModalButton("closeButton");
		closeButton.setText(i18n.discernabu.CONFIRM_OK);
		closeButton.setFocusInd(true).setOnClickFunction(function () {
			MP_ModalDialog.closeModalDialog("error");
		});
		modalObj.addFooterButton(closeButton);
		modalObj.setShowCloseIcon(true);
	}
	modalObj.setHeaderTitle(i18n.ERROR_OCCURED);
	modalObj.setFooterButtonText("closeButton", i18n.discernabu.CONFIRM_OK);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("reviewErrorMessage");
};

/*This function performs the operation of reviewing all the selected orders
 * @param {array} ordersArray - array of orders data to be reviewed
*/
DailyOrderReview.prototype.reviewSelectedOrders = function (ordersArray, userTimeZone, reviewButtonClass) {
	var self = this;
	var status = "Z";
	try {
		var APPLICATION_NUMBER = 560201;
		var TASK_NUMBER = 3202004;
		var REQUEST_NUMBER = 680800;
		var requestParam = self.getScriptRequestParams();
		var personId = (requestParam.PERSON_ID) ? requestParam.PERSON_ID : 0.0;
		var providerId = (requestParam.PRSNL_ID) ? requestParam.PRSNL_ID : 0.0;
		var DATE = new Date();
				
		var JSONParam = {
					resolution_provider_id: providerId,
					daily_review_resolutions: ordersArray,
					daily_review_anchor_dt_tm: DATE,
					user_tz: userTimeZone
				};
		
		var replyObj = self.makeScriptCall(JSONParam, APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER);
		if((replyObj.m_status === "S") && (replyObj.m_responseData.SUCCESSES.length && replyObj.m_responseData.FAILURES.length)){
			status = "PARTIAL_REVIEW";
		}else if(replyObj.m_status === "S" && replyObj.m_responseData.SUCCESSES.length){
			status = "SUCCESS";
		}else if(replyObj.m_status === "S" || replyObj.m_responseData.FAILURES.length){
			status = "NOT_DONE";
		}else if(replyObj.m_status === "F"){
			status = "FAILURE";
			self.showReviewErrorDialog();
		}
		
		if (reviewButtonClass) {
			var pendingOrders = self.getPendingOrders();
			var totalPendingOrders = self.getPendingOrders() - replyObj.m_responseData.SUCCESSES.length;
			self.setPendingOrders(totalPendingOrders);
			var count = (totalPendingOrders <= 0) ? "" : " (" + totalPendingOrders + ")";
			$("." + reviewButtonClass).first().html(self.m_i18nReview.OP_BUTTON_LABEL + count);
			if(totalPendingOrders === 0){
				$("." + reviewButtonClass).attr("disabled", true);
			}
		}
		
	} catch (error) {
		self.showReviewErrorDialog();
		logger.logJSError(error, null, "order-review.js", "reviewSelectedOrders");
	}
	return status;
};

/*This function performs the operation of reviewing all the qualified orders
 * @param {array} ordersArray - array of orders data to be reviewed
*/
DailyOrderReview.prototype.reviewAllOrders = function (ordersArray, userTimeZone, reviewButtonClass) {
	var self = this;
	try {
		var APPLICATION_NUMBER = 560201;
		var TASK_NUMBER = 3202004;
		var REQUEST_NUMBER = 680800;
		var requestParam = self.getScriptRequestParams();
		var personId = (requestParam.PERSON_ID) ? requestParam.PERSON_ID : 0.0;
		var providerId = (requestParam.PRSNL_ID) ? requestParam.PRSNL_ID : 0.0;
		var DATE = new Date();
				
		var JSONParam = {
					resolution_provider_id: providerId,
					daily_review_resolutions: ordersArray,
					daily_review_anchor_dt_tm: DATE,
					user_tz: userTimeZone
				};
				
		var replyObj = self.makeScriptCall(JSONParam, APPLICATION_NUMBER, TASK_NUMBER, REQUEST_NUMBER);
		if(replyObj.m_status === "S"){
			if (reviewButtonClass) {
				var pendingOrders = self.getPendingOrders();
				var totalPendingOrders = self.getReviewOrders().length - replyObj.m_responseData.SUCCESSES.length;
				self.setPendingOrders(totalPendingOrders);
				var count = (totalPendingOrders <= 0) ? "" : " (" + totalPendingOrders + ")";
				$("." + reviewButtonClass).first().html(self.m_i18nReview.OP_BUTTON_LABEL + count);
				if(totalPendingOrders === 0){
					$("." + reviewButtonClass).attr("disabled", true);
				}
			}
		}
		else if(replyObj.m_status === "F" || replyObj.m_responseData.FAILURES.length){
			self.showReviewErrorDialog();
		}
		
	} catch (error) {
		self.showReviewErrorDialog();
		logger.logJSError(error, null, "order-review.js", "reviewAllOrders");
	}
};

/*This function creates the JSON object of the review orders to be send orders resolve service
 * @param {array} ordersArray - array of orders data to be reviewed
 * @returns {array}
*/
DailyOrderReview.prototype.createReviewResolutionsArray = function (ordersList) {
	var reviewResolutionsArray = [];
	var ordersLength = ordersList.length;
	for(var i=ordersLength; i--; ){
		var reviewResolutionObj = {
			order_id : ordersList[i].ORDER_ID,
			daily_review_date: {
					year: ordersList[i].DAILY_REVIEW_DATE.YEAR,
					month: ordersList[i].DAILY_REVIEW_DATE.MONTH,
					day: ordersList[i].DAILY_REVIEW_DATE.DAY
				},
			user_resolution: {
				completed_by_user_ind: 1
			}
		};
		reviewResolutionsArray.push(reviewResolutionObj);
	}
	return reviewResolutionsArray;
};

/*This functions checks if all the orders in the list are viewed
 *@returns{boolean}
*/
DailyOrderReview.prototype.checkIfCompletOrdersListIsViewed = function () {	
	//check if scrollbar is present
	var hasVerticalScrollbar = $("body").height() > $(window).height();
	if(hasVerticalScrollbar){
		 if($(window).scrollTop() === ($(document).height() - $(window).height())){
			isAllOrdersViewed = true;
			return true;
		 }else{
			if(isAllOrdersViewed){
				return true;
			}else{
				return false;
			}
		 }
	}else{
		return true;
	}
};

/*
 *This function will be called to review the qualified orders
 * @param {string} reviewId - a unique ID
 * @param {number} userTimeZone - client time zone
*/
DailyOrderReview.prototype.markOrdersAsReviewed = function (reviewId, userTimeZone, opSplitButtonClass) {
	var self = this;
	var capTimer = null;
	var ordersToReview = [];
	var reviewResolutionsArray = [];
	if (reviewId) {
		var tableBodyId = "review_" + reviewId + "tableBody";
		$("#" + tableBodyId).find("input:checkbox").each(function () {
			var checkedStatus = $(this).attr("checked");
			if (checkedStatus === "checked") {
				var rowElem = $(this).closest(".result-info");
				var resultData = ComponentTableDataRetriever.getResultFromTable(self.m_reviewTable, rowElem);
				ordersToReview.push(resultData);
			}
		});
		reviewResolutionsArray = self.createReviewResolutionsArray(ordersToReview);
		var status = self.reviewSelectedOrders(reviewResolutionsArray, userTimeZone, opSplitButtonClass);
		return status;
	} else {
		 //Handles review button click from the order profile component
		 //to perform the silent review without opening the Daily Orders review Modal
		self.getQualifiedDailyOrders(function(){
			ordersToReview = self.getReviewOrders();
			reviewResolutionsArray = self.createReviewResolutionsArray(ordersToReview);
			var time_zone = self.getTimeZone();
			self.reviewAllOrders(reviewResolutionsArray, time_zone, opSplitButtonClass);
		});
	}
	capTimer = new CapabilityTimer("CAP:MPG DRO - mark_as_reviewed", "DOR");
	if (capTimer) {
		capTimer.addMetaData("rtms.legacy.metadata.1", "Mark As reviewed");
		capTimer.capture();
	}
};
/**
 * The Order Selection Control class
 * @author Matt Brown
 * @constructor
 * @param {number} uniqueId - Id unique to the caller, such as componentId.
 * @param {object} criterion - Criterion object.
 */
//TODO: Follow proper naming convention
function orderSelectionControl(uniqueId, criterion) {
	this.m_criterion = criterion;
	this.m_uniqueId = uniqueId;
	this.m_closeFunction = null;
	this.m_currentVenues = [];
	this.m_SPArr = [];
	this.m_actionButtonsHTML = "";
	this.m_nameSpace = "";
	this.m_orderTitle = "";
	this.m_containerId = "ordSelControlContainer" + this.m_uniqueId;
	this.m_folderId = 0.0;
	this.m_containerPercentageHeight = 0;
	this.m_containerHeight = 0;
	this.maxRulerWidth = 0;
	this.m_defaultVenue = -1;
	this.m_selectedVenue = -1;
	this.m_validEntry = false;
	this.m_isRenderOk = false;

	//Button controls (set in initButtons)
	this.m_submitButton = null;
	this.m_cancelButton = null;
	this.m_venueSelectButton = null;
}

/**
 * Sets the indicator showing that it is okay to render the API html.
 * @param {Boolean} value - The value that the m_isRenderOk indicator should be set to.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setIsRenderOk = function(value) {
	if (!this.m_validEntry) {
		throw new Error("orderSelectionControl.setIsRenderOk: The setIsRenderOk function should not be called directly by the user, ever.");
	}
	this.m_isRenderOk = value;
	//Reset the valid entry variable
	this.m_validEntry = false;
};

/**
 * Gets the indicator stating whether the API is okay to Render or not
 * @returns {Boolean} true if the API is okay to be rendered, otherwise false.
 */
orderSelectionControl.prototype.getIsRenderOk = function() {
	return this.m_isRenderOk;
};

/**
 * Sets a unique id (componentId, for example) for the API, this way html id's will not be duplicated.
 * Note that this shouldn't be a necessary call since the user will most likely add the id as a parameter upon instantiation of the API.
 * @param {number} value - The unique id for the API.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setUniqueId = function(value) {
	this.m_uniqueId = value;
};

/**
 * Gets the unique id of the API
 * @returns {Number} the unique id of the API
 */
orderSelectionControl.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets the criterion for the API
 * @param {number} value - The criterion of the page for the API to consume.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setCriterion = function(value) {
	this.m_criterion = value;
};

/**
 * Gets the API's criterion.
 * @returns {Object} the API's criterion.
 */
orderSelectionControl.prototype.getCriterion = function() {
	return this.m_criterion;
};

/**
 * Sets the folder id that the API will be pulling the orders from.
 * @param {number} value - The folder id.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setFolderId = function(value) {
	this.m_folderId = value;
};

/**
 * Gets the folder id where the orders will be pulled from
 * @returns {number} the folder id.
 */
orderSelectionControl.prototype.getFolderId = function() {
	return this.m_folderId;
};

/**
 * Sets the name space of the API.
 * @param {string} value - The namespace.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setNameSpace = function(value) {
	this.m_nameSpace = value + "-ord-sel-control";
};

/**
 * Gets the name space of the API
 * @return {string} the API's namespace.
 */
orderSelectionControl.prototype.getNameSpace = function() {
	return this.m_nameSpace;
};

/**
 * Sets the available venue types that can be selected from the dropdown menu.
 * @param {Array} value - An array of venue types {VALUE:{number}, DISPLAY:{string}}
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setVenueTypes = function(value) {
	//TODO: Use Array.prototype.isPrototypeOf(value) instead
	if (Object.prototype.toString.call(value) === "[object Array]") {
		this.m_currentVenues = value.slice(0);
	}
	else {
		this.m_currentVenues.push(value);
	}
};

/**
 * Gets the available venue types that can be selected from the dropdown menu.
 * @return {Array} An array of venue types {VALUE:{number}, DISPLAY:{string}}
 */
orderSelectionControl.prototype.getVenueTypes = function() {
	return this.m_currentVenues;
};

/**
 * Gets the container element that the API's main html is stored in. This excludes the actionButtonsHTML.
 * @return {Object} The html element containing the API's main html.
 */
orderSelectionControl.prototype.getContainer = function() {
	return $("#" + this.m_containerId);
};

/**
 * Sets the actions that should be performed when the API is closed.
 * If set, then the Cancel button will show, and the Submit button will call the function after submitting the order(s) to the scratchpad.
 * @param {Function} value - The Close function for the API instance.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setCloseFunction = function(value) {
	if (typeof value !== "function") {
		throw new Error("Value for orderSelectionControl.setCloseFunction must be a function.");
	}
	this.m_closeFunction = value;
};

/**
 * Gets the close function set on the API by the consumer.
 * @return {Function} The Close Function for the API.
 */
orderSelectionControl.prototype.getCloseFunction = function() {
	return this.m_closeFunction;
};

/**
 * Sets the defaulted venue that should be loaded and selected when the API is evoked.
 * @param {number} value - The value of the venue that needs to be loaded as default.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setDefaultVenue = function(value) {
	this.m_defaultVenue = value;
};

/**
 * Gets the defaulted venue set by the consumer.
 * @return {Number} The value of the default venue.
 */
orderSelectionControl.prototype.getDefaultVenue = function() {
	return this.m_defaultVenue;
};

/**
 * Sets the selected venue so the API can update the list of orders (only to be set by the venueType splitButton dropdown menu).
 * @param {number} value - The value of the venue that is selected.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setSelectedVenue = function(value) {
	if (!this.m_validEntry) {
		throw new Error("orderSelectionControl.setSelectedVenue: The setSelectedVenue function should not be called directly by the user.");
	}
	this.m_selectedVenue = value;
};

/**
 * Gets the selected (from the venueType splitButton dropdown menu) venue's value.
 * @returns {Number} The value of the selected venue.
 */
orderSelectionControl.prototype.getSelectedVenue = function() {
	return this.m_selectedVenue;
};

/**
 * Sets the order title text of the API. This will be in line with the venueType splitButton.
 * @param {string} value - The value of the order title.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setOrderTitle = function(value) {
	this.m_orderTitle = value;
};

/**
 * Gets the order title text of the API set by the consumer.
 * @returns {string} The value of the order title.
 */
orderSelectionControl.prototype.getOrderTitle = function() {
	return this.m_orderTitle;
};

/**
 * Sets the action buttons html. This includes the Submit button and, if applicable, the Cancel button.
 * @param {string} value - The action buttons html.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.setActionButtonsHTML = function(value) {
	this.m_actionButtonsHTML = value;
	var returnDetails = this.getActionButtonsContainer();
	if (returnDetails.container) {
		returnDetails.container.html(value);
	}
};

/**
 * Gets the action buttons html.
 * @returns {string} The html of the action buttons.
 */
orderSelectionControl.prototype.getActionButtonsHTML = function() {
	var returnDetails = this.getActionButtonsContainer();
	var containerHTML = returnDetails.containerHTML;
	if (returnDetails.container) {
		containerHTML = returnDetails.container.get(0).outerHTML;
	}
	return containerHTML;
};

/**
 * Checks to see if the actionButtonsContainer exists. If it does not, then it returns the html for the container and null for the container value.
 * If the container does exist, then the container is returned and the containerHTML is set to an empty string.
 * @returns {object} - Two return values in the object: container being the html element container, and containerHTML being the html for what the container should be.
 */
orderSelectionControl.prototype.getActionButtonsContainer = function() {
	var container = null;
	var containerHTML = "";

	if (!this.m_uniqueId) {
		return {containerHTML: containerHTML};
	}
	var containerId = "ordSelButtonsContainer" + this.m_uniqueId;
	container = $("#" + containerId);

	if (container.length === 0) {
		container = null;
		containerHTML = "<div class='ord-sel-control-buttons' id='ordSelButtonsContainer" + this.m_uniqueId + "'>" + this.m_actionButtonsHTML + "</div>";
	}

	return {
		container: container,
		containerHTML: containerHTML
	};
};

/**
 * Initializes the orderSelectionControl API and sends out log messages if key values are not set up on the API.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.init = function() {
	var self = this;
	var srObj = null;
	var dataObj = null;
	if (MP_Resources) {
		srObj = MP_Resources.getSharedResource("scratchpadSR");
	}
	if (srObj) {
		dataObj = srObj.getResourceData();
	}
	if (!self.m_uniqueId) {
		logger.logError("orderSelectionControl.init - m_uniqueId is not set up.");
		return;
	}
	if (!self.m_criterion) {
		logger.logError("orderSelectionControl.init - m_criterion is not set up.");
		return;
	}
	if (!self.m_nameSpace) {
		logger.logError("orderSelectionControl.init - m_nameSpace is not set up.");
		return;
	}
	if (!dataObj) {
		logger.logError("orderSelectionControl.init - scratchpadSR not found.");
		return;
	}
	self.getVenueTypeList();
	self.createButtons();
	self.setInitActions();
};

/**
 * Binds any events that require the order selection control to be present on the DOM.
 * @returns {undefined} Returns nothing.
 */
orderSelectionControl.prototype.finalize = function() {
	var self = this;
	if (this.m_submitButton) {
		this.m_submitButton.attachEvents();
	}
	if (this.m_cancelButton) {
		this.m_cancelButton.attachEvents();
	}
	//The split button is finalized on the renderBody function since it is not on the DOM until the initial load...
};

/**
 * This function does any cleanup in the case that the order selection control has been removed from the DOM, but
 * a reference to the object is retained for later rendering.
 * @returns {undefined} Returns nothing.
 */
orderSelectionControl.prototype.unload = function() {
	//Clean up the cached references to the buttons
	if (this.m_cancelButton) {
		this.m_cancelButton.clearElementCache();
	}
	if (this.m_submitButton) {
		this.m_submitButton.clearElementCache();
	}
	if (this.m_venueSelectButton) {
		this.m_venueSelectButton.getLabelButton().clearElementCache();
		this.m_venueSelectButton.getDropdownButton().clearElementCache();
	}
};

/**
 * By default, the venue type list will be built by a script call to mp_get_venue_list using the encounter id.
 * Note that the venue type list can be overwritten or added to after the .init() is called by the consumer.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.getVenueTypeList = function() {
	var self = this;
	var criterion = self.getCriterion();
	var sendAr = ["^MINE^", criterion.encntr_id + ".0"];
	var scriptRequest = new ScriptRequest();

	scriptRequest.setProgramName("mp_get_venue_list");
	scriptRequest.setParameterArray(sendAr);
	scriptRequest.setAsyncIndicator(false);
	scriptRequest.setResponseHandler(function(scriptReply) {
		if (scriptReply) {
			var reply = scriptReply.m_responseData;
			if (reply && reply.VENUE_TYPE_LIST) {
				if (reply.ENCNTR_VENUE_FLAG != 2) {
					reply.VENUE_TYPE_LIST.reverse();
				}
				self.setVenueTypes(scriptReply.m_responseData.VENUE_TYPE_LIST);
			}
		}
	});
	scriptRequest.performRequest();
};

/**
 * Handle the submit button click.
 * @returns {undefined} Returns nothing.
 */
orderSelectionControl.prototype.onSubmitClick = function() {
	var self = this;
	var closeFunc = self.getCloseFunction();
	var cellSubmitTimer = MP_Util.CreateTimer("CAP:MPG.OrderSelectionControl-Submit_Orders");
	if (cellSubmitTimer) {
		cellSubmitTimer.Start();
	}
	//We must obtain the scratchpad on the submit action to obtain all
	var srObj = MP_Resources.getSharedResource("scratchpadSR");
	var dataObj = srObj.getResourceData();

	dataObj.scratchpadObjArr = dataObj.scratchpadObjArr.concat(self.m_SPArr);
	self.m_SPArr.length = 0;

	//Update the scratchpad resource
	MP_Resources.setSharedResourceData(srObj.getName(), dataObj);
	srObj.notifyResourceConsumers();

	if (typeof closeFunc === "function") {
		closeFunc();
	}
	//Let other resources know we have data pending.
	self.checkPendingSR();
	if (cellSubmitTimer) {
		cellSubmitTimer.Stop();
	}
};

/**
 * Performs necessary logic to initialize the buttons used by the order selection control.
 * This will create a submit button. It will create a cancel button if a close function has been provided.
 * It will create a split button via the createSplitButton function.
 * @returns {undefined} Returns nothing.
 */
orderSelectionControl.prototype.initButtons = function() {
	var oi18n = i18n.discernabu.orderSelectionControl;
	var closeFunction = this.getCloseFunction();
	var self = this;

	var submitButton = new MPageUI.Button();
	var cancelButton = null;
	var venueSelectButton = this.createSplitButton();

	//Set up the submit button
	submitButton.setLabel(oi18n.SUBMIT.replace("{x}", "0"));
	submitButton.setOnClickCallback(this.onSubmitClick.bind(this));
	//Only create the cancel button if there is a close function
	if (closeFunction) {
		//Set up the cancel button
		cancelButton = new MPageUI.Button();
		cancelButton.setLabel(oi18n.CANCEL);
		cancelButton.setOnClickCallback(function() {
			self.m_SPArr.length = 0;
			closeFunction();
		});
	}

	//Store the buttons as member variables
	this.m_submitButton = submitButton;
	this.m_cancelButton = cancelButton;
	this.m_venueSelectButton = venueSelectButton;
};

/**
 * Creates the html for the venueType splitButton, as well as the actionable button(s): Submit and, if applicable, Cancel.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.createButtons = function() {
	var self = this;
	//Make the call to initialize the buttons (they have special initialization logic)
	this.initButtons();
	var submitButton = this.m_submitButton;
	var cancelButton = this.m_cancelButton;
	var splitButton = this.m_venueSelectButton;
	var ordSelControlI18n = i18n.discernabu.orderSelectionControl;

	//TODO: This applies styles to SplitButton that are non-compliant with MPages default styles. The purpose of MPageUI is to standardize visuals.
	var curTitle = "<div class='ord-sel-control-title' id='ordSelControlTitle" + self.m_uniqueId + "'>" +
		"<div class='documentwindow-title ord-sel-control-title-span'>" + self.getOrderTitle() + "</div>" +
		( splitButton ? "<div class='ord-sel-control-title-splitButton'>" + splitButton.render() + "</div>" : "") +
		"</div></div>";

	self.setOrderTitle(curTitle);

	/*
	 * There is an issue with the disabled state of the MPageUI.Button when the button changes states between modal dialog window instances AND
	 * if the button launches its click function. This seems like a rare case for the correct team to fix, so a fake submitButton is used that is
	 * always disabled, and a true submitButton that is always enabled. Then CSS is used to hide or show the correct button given the amount
	 * of orders selected.
	 */
	//TODO: Remove the usage of the fake button
	var fakeSubmitButton = new MPageUI.Button();
	fakeSubmitButton.setLabel(ordSelControlI18n.SUBMIT.replace("{x}", "0"));
	fakeSubmitButton.setDisabled(true);

	//Create the HTMl for the order selection control actions
	var actionButtonsHTML = "<span id='ordSelContFakeSubmit" + self.m_uniqueId + "'>" +
		fakeSubmitButton.render() + "</span><span id='ordSelContRealSubmit" + self.m_uniqueId + "' class='hidden'>" +
		submitButton.render() + "</span>" + ( cancelButton ? "<div class='ord-sel-control-separator'></div>" +
		cancelButton.render() : "");

	self.setActionButtonsHTML(actionButtonsHTML);
};

/**
 * Adds the actionable event(s) surrounding the initialization of the orderSelectionControl API, also sets the m_isRenderOk indicator to true upon exiting this function.
 * @returns {undefined} Returns nothing.
 */
orderSelectionControl.prototype.setInitActions = function() {
	var self = this;
	$(window).bind("resize", function() {
		//Give the window's resize events some time to execute before resizing the table.
		setTimeout(function() {
			self.resizeTable();
		}, 200);
	});

	this.m_validEntry = true;
	self.setIsRenderOk(true);
};

/**
 * Determines if a splitButton is to be created for the API's session and will create it if applicable.
 * @returns {MPageUI.SplitButton|null} The SplitButton object for the venue type list. If no venue types are provided
 * or there is only one venue type, null is returned.
 */
orderSelectionControl.prototype.createSplitButton = function() {
	var self = this;
	var venueTypes = self.getVenueTypes();
	var splitButton = null;
	var ordSelControlI18n = i18n.discernabu.orderSelectionControl;
	//If no venue types or there is only one venue type, return
	if (!venueTypes || venueTypes.length <= 1) {
		return splitButton;
	}
	var defaultVenue = self.getDefaultVenue();
	var defaultIdx = 0;
	var i = 0;
	var il = 0;

	if (defaultVenue > -1) {
		for (i = venueTypes.length; i--;) {
			if (venueTypes[i].VALUE === defaultVenue) {
				defaultIdx = i;
				break;
			}
		}
	}
	else {
		defaultIdx = 0;
	}
	var curOptions = [];
	var curOption = {};
	var menuOptionTypeEnum = MPageUI.MENU_OPTIONS.TYPE;
	var rulerId = "ordSelControlRuler" + self.m_uniqueId;
	var ruler = $("#" + rulerId);

	if (ruler.length === 0) {
		ruler = $("<div id='" + rulerId + "' class='ord-sel-control-ruler '></div>");
		$(document.body).append(ruler);
	}

	for (i = 0, il = venueTypes.length; i < il; i++) {
		if (i > 0) {
			curOptions.push({
				type: menuOptionTypeEnum.SEPARATOR
			});
		}
		var venueItem = venueTypes[i];
		ruler.html(venueItem.DISPLAY);

		if (ruler.width() > self.maxRulerWidth) {
			self.maxRulerWidth = ruler.width();
		}
		curOption = {
			venueItem: venueItem,
			label: venueItem.DISPLAY,
			onSelect: function() {
				//The splitButton has issues with updating its text if using a modal dialog and the dialog is evoked multiple times.
				self.m_venueSelectButton.setLabel(this.venueItem.DISPLAY);
				//The scratchpad array object must be set back to
				self.m_SPArr.length = 0;
				self.m_validEntry = true;
				self.setSelectedVenue(this.venueItem.VALUE);
				self.m_validEntry = false;
				self.render();
				self.m_submitButton.setLabel(ordSelControlI18n.SUBMIT.replace("{x}", "0"));
				//TODO: Remove usage of the fake button
				$("#ordSelContRealSubmit" + self.m_uniqueId).addClass("hidden");
				$("#ordSelContFakeSubmit" + self.m_uniqueId).removeClass("hidden");
			}

		};
		curOptions.push(curOption);
	}

	splitButton = new MPageUI.SplitButton();

	splitButton.setLabel(venueTypes[defaultIdx].DISPLAY);
	splitButton.addOptions(curOptions);
	splitButton.setStyle(MPageUI.BUTTON_OPTIONS.STYLE.SECONDARY);

	//Override the default behavior of the dropdown button and extend it to adjust the z-index and other stylings of the menu
	var splitButtonFunction = function() {
		//Toggle the menu as usual
		splitButton.toggle();
		//If the menu is open, adjust the z-index, width and position of the menu.
		if (splitButton.isOpen()) {
			$(".dropdown-standard-menu").addClass("ord-sel-control-dd-menu");
			var curButtonLeftPos = $("#ordSelControlTitle" + self.m_uniqueId + " .btn-group:first").offset().left;
			$(".dropdown-standard-menu").css("left", curButtonLeftPos + "px");
		}
	};

	var dropDownButton = splitButton.getDropdownButton();
	dropDownButton.setOnClickCallback(splitButtonFunction);
	splitButton.setLabelButtonClickCallback(splitButtonFunction);
	return splitButton;
};

/**
 * Creates the container object which will hold all of the html for the body of the orderSelectionControl API.
 * Calls the script mp_obtain_order_folders and then calls the renderBody function.
 * @returns {String} HTML - The html of the container object for the body of the orderSelectionControl API.
 * TODO: This function returns inconsistent values (sometimes string, sometimes undefined)
 */
orderSelectionControl.prototype.render = function() {
	var self = this;
	var callRenderBodyInd = true;
	var container = self.getContainer();
	var criterion = self.getCriterion();
	var curVenues = self.getVenueTypes();
	var folderId = self.getFolderId();

	if (container.length === 0) {
		container = $("<div id='" + self.m_containerId + "' class='ord-sel-loading'></div>");
	}

	if (self.getUniqueId() === 0) {
		logger.logError("orderSelectionControl.render - m_uniqueId is not set up.");
		callRenderBodyInd = false;
	}
	if (curVenues.length === 0) {
		logger.logError("orderSelectionControl.render - venueType list is empty.");
		callRenderBodyInd = false;
	}
	if (!folderId) {
		logger.logError("orderSelectionControl.render -  Order folder not set.");
		callRenderBodyInd = false;
	}
	if (!criterion) {
		logger.logError("orderSelectionControl.render - criterion not set up.");
		callRenderBodyInd = false;
	}
	if (!self.m_isRenderOk && callRenderBodyInd === true) {
		logger.logError("orderSelectionControl.render -  orderSelectionControl was not able to initialize correctly.");
		callRenderBodyInd = false;
	}

	if (callRenderBodyInd === true) {
		var curSelectedVenue = self.getSelectedVenue();
		var curDefaultVenue = self.getDefaultVenue();
		var curVenue = -1;
		var i = 0;

		//Checks the selected venue and determines if it matches a value from the available venues.
		if (curSelectedVenue >= 0) {
			for (i = curVenues.length; i--;) {
				if (curVenues[i].VALUE === curSelectedVenue) {
					curVenue = curSelectedVenue;
					break;
				}
			}
		}

		//Checks the default venue and determines if it matches a value from the available venues.
		if (curVenue === -1 && curDefaultVenue >= 0) {
			for (i = curVenues.length; i--;) {
				if (curVenues[i].VALUE === curDefaultVenue) {
					curVenue = curDefaultVenue;
					break;
				}
			}
			if (curVenue === -1) {
				logger.logError("orderSelectionControl.render - Default venue does not exist on the patient's encounter.");
			}
		}

		if (curVenue === -1) {
			curVenue = curVenues[0].VALUE;
		}

		self.m_validEntry = true;
		self.setSelectedVenue(-1);
		self.m_validEntry = false;
		//Reset the selected venue in the case that the user closes a window and needs to relaunch this using the default venue

		if (curVenue > -1) {
			var sendAr = [];
			var tableContainerDiv = $("#ordSelControlDiv" + self.m_uniqueId);
			if (tableContainerDiv.length > 0) {
				tableContainerDiv.addClass("ord-sel-loading");
				tableContainerDiv.empty();
			}
			sendAr.push("^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0", criterion.provider_id + ".0", criterion.position_cd + ".0", folderId, curVenue + ".0");
			var scriptRequest = new ScriptRequest();
			scriptRequest.setProgramName("mp_obtain_order_folders");
			scriptRequest.setParameterArray(sendAr);

			scriptRequest.setResponseHandler(function(scriptReply) {
				self.m_validEntry = true;
				self.renderBody(scriptReply, curVenue);
			});
			scriptRequest.performRequest();
		}
		else {
			container.html("<div class='ord-sel-control-error-display'>" + MP_Util.HandleErrorResponse(self.getNameSpace(), "Venues not set up correctly.") + "</div>");
		}
	}
	else {
		container.removeClass("ord-sel-loading");
		container.html("<div class='ord-sel-control-error-display'>" + MP_Util.HandleErrorResponse(self.getNameSpace(), "orderSelectionControl not set up correctly.") + "</div>");
	}
	return container.get(0).outerHTML;
};

/**
 * Creates the body of the orderSelectionControl API.
 * Creates a ComponentTable which will hold all of the orders and actionable items on the order rows. Writes the order title, venueType splitButton, and the componentTable to the body.
 * @param {object} scriptReply - JSON reply from mp_obtain_order_folders script.
 * @param {number} curVenue - 1 for inpatient, 2 for Discharge Meds, etc.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.renderBody = function(scriptReply, curVenue) {

	var self = this;
	var container = self.getContainer();
	var firstLoad = false;
	var curContainerDiv = $("#ordSelControlContainerDiv" + self.m_uniqueId);
	var tableContainerDiv = $("#ordSelControlDiv" + self.m_uniqueId);

	var curHTML = "";
	if (scriptReply && scriptReply.m_responseData) {
		var ordFolders = scriptReply.m_responseData.FOLDER;
		if (ordFolders && ordFolders.length > 0) {
			if (!self.m_validEntry) {
				container.html("<div class='ord-sel-control-error-display'>" + MP_Util.HandleErrorResponse(self.getNameSpace(), "Function cannot be called directly.") + "</div>");
				logger.logError("orderSelectionControl.renderBody: The renderBody function should not be called directly.  Please utilize the render function for starting data requests");
				return;
			}
			//Reset the valid entry variable.
			self.m_validEntry = false;

			//Initialize ComponentTable
			var curNameSpace = self.getNameSpace();
			var ordTable = new ComponentTable();
			if (curNameSpace) {
				ordTable.setNamespace(curNameSpace);
			}
			ordTable.setIsHeaderEnabled(false);
			ordTable.setCSSTemplate("");
			ordTable.setZebraStripe(false);

			//Create and add the order display column
			var favoriteDisplayCol = new TableColumn();
			favoriteDisplayCol.setColumnId("DISPLAY_NAME");
			favoriteDisplayCol.setCustomClass("ord-sel-control-rows");
			favoriteDisplayCol.setRenderTemplate("${ ITEM_DISPLAY }");
			ordTable.addColumn(favoriteDisplayCol);
			//Create and sort the order display data.
			var curFolder = null;
			var favoritesSort = scriptReply.m_responseData.FAVORITES_SORT;
			var hideSubfolder = 0;
			var folderGrp = null;
			var folderHdr = "";

			for (var i = 0, il = ordFolders.length; i < il; i++) {
				curFolder = ordFolders[i];
				//Style the row data and add the display and hover information.
				self.processResultsForRender(curFolder.ITEM, favoritesSort);

				if (curFolder.ROOT_LEVEL_IND && curFolder.ITEM.length === 0) {
					hideSubfolder = 1;
				}
				else {
					hideSubfolder = 0;
				}
				if (!hideSubfolder) {
					//Process the results so rendering becomes more trivial

					folderGrp = new TableGroup();
					folderHdr = curFolder.S_DESCRIP;
					folderGrp.setDisplay(folderHdr);
					folderGrp.setGroupId(curFolder.FOLD_ID);
					folderGrp.setShowCount(false);
					folderGrp.bindData(curFolder.ITEM);
					//Do not collapse the Root level favorites.
					if (!curFolder.ROOT_LEVEL_IND) {
						folderGrp.setIsExpanded(false);
					}
					ordTable.addGroup(folderGrp);
				}
			}

			//Add hover to the table rows.
			var ordSelTooltip = new MPageTooltip();
			ordSelTooltip.setShowDelay(0);
			ordSelTooltip.setContent = function(content) {
				this.content = $("<div class='mpage-tooltip ord-sel-control-row-hover'>").html(content).hide();
				return this;
			};

			var hoverExtension = new TableCellHoverExtension();
			hoverExtension.setTooltip(ordSelTooltip);
			hoverExtension.addHoverForColumn(favoriteDisplayCol, function(data) {
				return "<span>" + data.RESULT_DATA.ITEM_HOVER + "</span>";
			});
			hoverExtension.setHoverClass("mpage-tooltip-hover ord-sel-control-row-hover");
			ordTable.addExtension(hoverExtension);

			var tblToggleExtension = new TableGroupToggleCallbackExtension();
			tblToggleExtension.setGroupToggleCallback(function() {
				setTimeout(function() {
					self.resizeTable();
				}, 0);
			});
			ordTable.addExtension(tblToggleExtension);

			//Add cell click to table.
			self.addCellClickExtension(ordTable, curVenue);

			if (curContainerDiv.length === 0) {
				curHTML = self.getOrderTitle() + "<div id='ordSelControlDiv" + self.m_uniqueId + "' class='ord-sel-control-table'>" + ordTable.render() + "</div>";
				curContainerDiv = $("<div id='ordSelControlContainerDiv" + self.m_uniqueId + "' class='ord-sel-control-container'></div>").html(curHTML);
				container.removeClass("ord-sel-loading");
				firstLoad = true;
			}
			else {
				tableContainerDiv.html(ordTable.render());
				tableContainerDiv.removeClass("ord-sel-loading");
			}
			container.append(curContainerDiv);
			self.resizeTable();
			ordTable.finalize();
			//Remove all hovers from this API.
			$(".mpage-tooltip.ord-sel-control-row-hover").remove();
			var curButton = null;
		}
		else {
			if (curContainerDiv.length === 0) {
				curHTML = self.getOrderTitle() + "<div id='ordSelControlDiv" + self.m_uniqueId + "' class='ord-sel-control-table'><div class='ord-sel-control-no-data-display'><span class='res-none'>" + i18n.NO_RESULTS_FOUND + "</span></div></div>";
				curContainerDiv = $("<div id='ordSelControlContainerDiv" + self.m_uniqueId + "' class='ord-sel-control-container'></div>").html(curHTML);
				container.removeClass("ord-sel-loading");
				firstLoad = true;
			}
			else {
				tableContainerDiv.html("<div class='ord-sel-control-no-data-display'><span class='res-none'>" + i18n.NO_RESULTS_FOUND + "</span></div>");
				tableContainerDiv.removeClass("ord-sel-loading");
			}
			container.append(curContainerDiv);
		}
		if (firstLoad === true) {
			if (this.m_venueSelectButton) {
				this.m_venueSelectButton.attachEvents();
			}
			$(".ord-sel-control-title-splitButton").on("mouseover", "button", function() {
				curButton = $(this).parent().find("button");
				curButton.addClass("ord-sel-control-gray-background");
				curButton.css("background-color", "#E5E5E5");
			});
			$(".ord-sel-control-title-splitButton").on("mouseout", "button", function() {
				curButton = $(this).parent().find("button");
				curButton.removeClass("ord-sel-control-gray-background");
				curButton.css("background-color", "#FFF");
			});
		}
	}
	else {
		container.html("<div class='ord-sel-control-error-display'>" + MP_Util.HandleErrorResponse(self.getNameSpace(), "Script failure") + "</div>");
		logger.logError("orderSelectionControl.renderBody: The scriptReply or scriptReply.m_responseData is undefined");
	}
};

/**
 * Adds the clickable action to the order rows.
 * @param {Function} ordTable - ComponentTable storing the order rows.
 * @param {number} curVenue - 1 for Inpatient, 2 for Discharge Meds, etc.
 * @returns {undefined} - No return value
 */
orderSelectionControl.prototype.addCellClickExtension = function(ordTable, curVenue) {
	var self = this;
	var cellClickExtension = new TableCellClickCallbackExtension();
	var ordSelControlI18n = i18n.discernabu.orderSelectionControl;
	var submitButton = this.m_submitButton;

	cellClickExtension.setCellClickCallback(function(event, data) {
		self.addItemToPendingOrdersSP(event, data, curVenue);
		var selectedRowsCnt = $("#ordSelControlDiv" + self.m_uniqueId + " .ord-sel-control-selected-row").length;
		if (selectedRowsCnt > 0) {
			$("#ordSelContRealSubmit" + self.m_uniqueId).removeClass("hidden");
			$("#ordSelContFakeSubmit" + self.m_uniqueId).addClass("hidden");
			submitButton.setLabel(ordSelControlI18n.SUBMIT.replace("{x}", selectedRowsCnt));
		}
		else {
			$("#ordSelContRealSubmit" + self.m_uniqueId).addClass("hidden");
			$("#ordSelContFakeSubmit" + self.m_uniqueId).removeClass("hidden");
		}
	});
	ordTable.addExtension(cellClickExtension);
};

/**
 * Resizes the table to keep in accordance with the page and to ensure the body of the API's container does not exceed that of its container's limitations.
 * @returns {undefined} - No return value.
 */
orderSelectionControl.prototype.resizeTable = function() {
	var self = this;
	var container = self.getContainer();
	var includeMargins = true;

	$("#ordSelControlContainerDiv" + self.m_uniqueId).css("height", "auto");
	$("#ordSelControlDiv" + self.m_uniqueId).css("height", "auto");
	if (container.length > 0 && container.parent().length && $("#ordSelControlTitle" + self.m_uniqueId).length > 0 && $("#ordSelControlDiv" + self.m_uniqueId).length > 0) {
		var titleHeight = $("#ordSelControlTitle" + self.m_uniqueId).outerHeight(includeMargins);

		var extraChildrenHeight = 0;
		var siblingsHeight = 0;
		var outerHeights = [];
		if (container.children().length > 1) {
			container.children().each(function() {
				if ($(this).attr("id") !== "ordSelControlContainerDiv" + self.m_uniqueId) {
					extraChildrenHeight += $(this).outerHeight(includeMargins);
					outerHeights.push($(this).outerHeight(includeMargins));
				}
			});
		}
		if (container.siblings().length > 0) {
			container.siblings().each(function() {
				siblingsHeight += $(this).outerHeight(includeMargins);
				outerHeights.push($(this).outerHeight(includeMargins));
			});
		}
		var parentContainer = container.parent();

		var maxHeight = parseInt(parentContainer.css("max-height"), 10) || container.parent().outerHeight(includeMargins);
		var parentHeight = maxHeight - titleHeight - extraChildrenHeight - siblingsHeight;
		var containerHeight = container.outerHeight(includeMargins);
		var maxContainerHeight = Math.max(Math.min(parentHeight, containerHeight), 100);

		if (self.m_maxHeight < maxHeight || self.m_maxPercentageHeight === 0) {
			self.m_maxHeight = maxHeight;
			self.m_maxPercentageHeight = Math.ceil(maxHeight / document.body.clientHeight * 100);
		}

		if (self.m_containerHeight < maxContainerHeight || self.m_containerPercentageHeight === 0) {
			self.m_containerHeight = maxContainerHeight;
			self.m_containerPercentageHeight = Math.floor(maxContainerHeight / document.body.clientHeight * 100);
		}

		containerHeight = Math.floor(self.m_containerPercentageHeight * document.body.clientHeight / 100);
		maxHeight = Math.ceil(self.m_maxPercentageHeight * document.body.clientHeight / 100);
		if (containerHeight > self.m_containerHeight) {
			containerHeight = self.m_containerHeight;
		}
		containerHeight -= parseInt($("#ordSelControlContainerDiv" + self.m_uniqueId).css("margin-bottom"));
		$("#ordSelControlContainerDiv" + self.m_uniqueId).css("height", maxHeight + "px");

		$("#ordSelControlDiv" + self.m_uniqueId).css("height", containerHeight + "px");

	}
};

/**
 * Creates the scratchpad order object and prepares it to be sent to the pendingOrders scratchpad.
 * @param {object} el - Table cell that has been clicked.
 * @param {object} data - JSON data tied to the order.
 * @param {number} curVenue - 1 for Inpatient, 2 for Discharge Meds, etc.
 * @returns {undefined} - No return value.
 */
orderSelectionControl.prototype.addItemToPendingOrdersSP = function(el, data, curVenue) {

	//create scratchpad object
	var self = this;
	var element = $(el.target).parents("dl").find("dd.ord-sel-control-rows")[0];
	var orderRecord = data.RESULT_DATA;
	var favType = orderRecord.FAV_TYPE;
	var favSynId = favType === 2 ? orderRecord.PATH_CAT_ID : orderRecord.SYN_ID;
	var favSentId = favType === 2 ? orderRecord.PW_CAT_SYN_ID : orderRecord.SENT_ID;

	/* Set venueType based on page-level venue
	 For 'All' venue type, set venueType to 1 if RX_INDICATOR is set to 1
	 For Inpatient/Ambulatory-In-office venue, set venueType to 0
	 For Rx venue, set venueType to 1
	 */
	var venueType = 0;
	switch (curVenue) {
		case 0:
			venueType = orderRecord.RX_INDICATOR;
			break;
		case 1:
			venueType = 0;
			break;
		case 2:
			venueType = 1;
			break;
	}

	var favParam = favSynId + ".0|" + venueType + "|" + favSentId + ".0";
	var scratchpadObj = {};
	scratchpadObj.componentId = self.getUniqueId();
	scratchpadObj.addedFrom = "StandaloneOrderSelection";
	//Location where the favorite was added from
	scratchpadObj.favId = element.id;
	//used when removing items from the scratchpad. should be able to look inside the component and find this id
	scratchpadObj.favType = orderRecord.FAV_TYPE;
	//0: Orderable; 1: Careset; 2: PowerPlan
	scratchpadObj.favParam = favParam;
	//Orderable or Careset: Synonym Id + ".0|" + venueType + "|" + Sentence Id + ".0";  venueType: Inpatient=0, Discharge=1
	//PowerPlan: PATH_CAT_ID + ".0|" + PATH_CAT_SYN_ID + ".0"
	scratchpadObj.favSynId = null;
	scratchpadObj.favSentId = null;
	scratchpadObj.favOrdSet = 0;
	scratchpadObj.favVenueType = venueType;

	var params = favParam.split("|");
	if (favType === 2) {
		scratchpadObj.favSynId = params[0];
		scratchpadObj.favSentId = params[2];
		//Display name of orderable/Careset/PowerPlan
		scratchpadObj.favName = orderRecord.ITEM_DISP;
		//Displays customizable name of the powerplan
		scratchpadObj.favOrderSentDisp = orderRecord.SENT_DISP;
		scratchpadObj.favPPEventType = 1;
		//all orders selection power plans are in the normal folder structure
	}
	else if (favType === 1) {
		scratchpadObj.favSynId = params[0];
		scratchpadObj.favSentId = params[2];
		scratchpadObj.favName = orderRecord.ITEM_DISP;
		//Display name of orderable/Careset/PowerPlan
		scratchpadObj.favOrderSentDisp = orderRecord.SENT_DISP;
		//Display name of order sentence, or if PowerPlan it displays the system name of the PowerPlan, not the customizable one in favName above
		scratchpadObj.favOrdSet = 6;
	}
	else {
		scratchpadObj.favSynId = params[0];
		scratchpadObj.favSentId = params[2];
		scratchpadObj.favName = orderRecord.ITEM_DISP;
		//Display name of orderable/Careset/PowerPlan
		scratchpadObj.favOrderSentDisp = orderRecord.SENT_DISP;
		//Display name of order sentence, or if PowerPlan it displays the system name of the PowerPlan, not the customizable one in favName above
		// Set the displayRxIcon flag to the Rx Indicator returned by the script
		scratchpadObj.displayRxIcon = orderRecord.RX_INDICATOR;
	}
	scratchpadObj.favNomenIds = '""';
	if (!$(element).hasClass("ord-sel-control-selected-row")) {
		$(element).addClass("ord-sel-control-selected-row");
		self.addToOrRemoveFromScratchpadSR(scratchpadObj, false);
	}
	else {
		$(element).removeClass("ord-sel-control-selected-row");
		self.addToOrRemoveFromScratchpadSR(scratchpadObj, true);
	}
};

/**
 * Updates the pendingDataSR resource object (for the scratchpad) with information detailing that the API instance has pending data.
 * @returns {undefined} - No return value.
 */
orderSelectionControl.prototype.checkPendingSR = function() {
	var self = this;
	var uniqueId = self.getUniqueId();
	var strCompId = String(uniqueId);
	//Convert to string to keep consistent.
	var srObj = null;
	var dataObj = {};
	//Get the shared resource
	srObj = MP_Resources.getSharedResource("pendingDataSR");
	if (!srObj) {
		srObj = new SharedResource("pendingDataSR");
		//Create the object that will be stored in the SharedResource
		if (CERN_Platform.inMillenniumContext()) {
			dataObj.pendingDataObj = window.external.DiscernObjectFactory("PVFRAMEWORKLINK");
		}
		else {
			dataObj.pendingDataObj = CERN_Platform.getDiscernObjectWebEquivalent("PVFRAMEWORKLINK");
		}
		dataObj.pendingDataCompArr = [];
		//Set the available flag to true
		srObj.setIsAvailable(true);
		//Set the shared resource data object
		srObj.setResourceData(dataObj);
		//Add the shared resource so other components can access it
		MP_Resources.addSharedResource("pendingDataSR", srObj);
	}
	if (srObj) {
		//Retrieve the object from the shared resource.
		dataObj = srObj.getResourceData();
		if (dataObj) {
			var pendingArr = dataObj.pendingDataCompArr;
			if (pendingArr.join("|").indexOf(strCompId) === -1) {
				pendingArr.push(strCompId);
			}
			dataObj.pendingDataCompArr = pendingArr;
			//If there are no other components that have pending actions communicate to the PVFRAMEWORKLINK object that there is no pending components.
			dataObj.pendingDataObj.SetPendingData(dataObj.pendingDataCompArr.length === 0 ? 0 : 1);
			//Update the SharedResource.
			MP_Resources.setSharedResourceData("pendingDataSR", dataObj);
		}
	}
};

/**
 * Updates the API's variable m_SPArr with the addition or removal of an order that is to be sent to the scratchpad.
 * @param {object} scratchpadObj - Object containing details about scratchpad order.
 * @param {boolean} isRemovingObj - True if removing object from m_SPArr, false if adding object.
 * @returns {undefined} - No return value.
 */
orderSelectionControl.prototype.addToOrRemoveFromScratchpadSR = function(scratchpadObj, isRemovingObj) {
	var self = this;

	var scratchpadArr = self.m_SPArr;
	if (scratchpadArr) {
		if (isRemovingObj) {
			var idx = scratchpadArr.length;
			while (idx--) {
				if (scratchpadArr[idx].favSynId === scratchpadObj.favSynId && scratchpadArr[idx].favSentId === scratchpadObj.favSentId && scratchpadArr[idx].favVenueType === scratchpadObj.favVenueType) {
					scratchpadArr.splice(idx, 1);
					break;
				}
			}
		}
		else {
			scratchpadArr.push(scratchpadObj);
		}
	}
};

/**
 * Creates html for each row on the order's table.
 * Updates the calling array's information by adding a display and hover value to each entry.
 * @param {array} subFolder - Array of order objects.
 * @param {integer} favoritesSort - Indicates if the orders should be sorted alphabetically or stay sorted by sequence. 1 - Sort alphabetically; 0 - Keep the sequence sort.
 * @returns {undefined} - No return value.
 */
orderSelectionControl.prototype.processResultsForRender = function(subFolder, favoritesSort) {
	var iconHTML = null;
	var subFolderLength = subFolder.length;
	var arrHTML = [];
	var itemWeight = 0;
	var ordSelControlI18n = i18n.discernabu.orderSelectionControl;

	for (var j = 0; j < subFolderLength; j++) {
		itemWeight = 0;
		arrHTML = [];
		var curItem = subFolder[j];
		var sentDisp = curItem.SENT_DISP ? curItem.SENT_DISP : "";
		if (curItem.SENT_ALIAS) {
			sentDisp = curItem.SENT_ALIAS;
		}
		var itemDisp = curItem.ITEM_ALIAS ? curItem.ITEM_ALIAS : curItem.ITEM_DISP;
		itemDisp = itemDisp.charAt(0).toUpperCase() + itemDisp.slice(1);
		if (curItem.TYPE_CD === 2) {//Order Synonym
			if (curItem.ORDERABLE_TYPE_FLAG === 6) {
				itemWeight = 1;
				iconHTML = "<div class='ord-sel-control-careset-icon'></div>";
				curItem.FAV_TYPE = 1;
			}
			else {
				itemWeight = 2;
				curItem.FAV_TYPE = 0;
				iconHTML = "";
			}
			arrHTML.push("<div class='ord-sel-control-row-div'>", iconHTML, "<div class='ord-sel-control-ord-disp'><span class='ord-sel-control-syn-id' data-syn-id='", curItem.SYN_ID, "'>", itemDisp, "</span><span class='ord-sel-control-sent ord-sel-control-sent-id' data-sent-id='", curItem.SENT_ID, "'>", sentDisp, "</span></div></div>");

		}
		else if (curItem.TYPE_CD === 6) {//PowerPlan
			iconHTML = "<div class='ord-sel-control-pp-icon'></div>";
			arrHTML.push("<div class='ord-sel-control-row-div'>", iconHTML, "<div class='ord-sel-control-ord-disp'><span class='ord-sel-control-sent-id' data-sent-id='", curItem.PW_CAT_SYN_ID, "'>", itemDisp, "</span><span class='ord-sel-control-sent ord-sel-control-syn-id' data-syn-id='", curItem.PATH_CAT_ID, "'>", sentDisp, "</span></div></div>");
			curItem.FAV_TYPE = 2;
		}
		curItem.ITEM_DISPLAY = arrHTML.join("");
		if (curItem.TYPE_CD === 6) {
			curItem.ITEM_HOVER = "<div class = 'ord-sel-control-hover'><dl><dt class='ord-sel-control-det-type'><span>" + ordSelControlI18n.POWERPLAN_DISPLAY + ":</span></dt><dd><span>" + curItem.ITEM_DISP + "</span></dd><dt class='ord-sel-control-det-type'><span>" + ordSelControlI18n.POWERPLAN_DESCRIPTION + ":</span></dt><dd><span>" + curItem.SENT_DISP + "</span></dd></dl></div>";
		}
		else {
			curItem.ITEM_HOVER = "<div class = 'ord-sel-control-hover'><dl><dt class='ord-sel-control-det-type'><span>" + ordSelControlI18n.ORDER_SYNONYM + ":</span></dt><dd><span>" + curItem.ITEM_DISP + "</span></dd><dt class='ord-sel-control-det-type'><span>" + ordSelControlI18n.ORDER_SENTENCE + ":</span></dt><dd><span>" + curItem.SENT_DISP + "</span></dd></dl></div>";
		}
		curItem.itemDisp = itemWeight + itemDisp;
	}
	if (favoritesSort === 1) {
		subFolder.sort(function(elA, elB) {
			var a = elA.itemDisp;
			var b = elB.itemDisp;
			if (a > b) {
				return 1;
			}
			else if (a < b) {
				return -1;
			}
			return 0;
		});
	}
};
function OrgSearchControl(textBox){var selectedId=0;
var serviceDelegate=new OrgServiceDelegate();
var orgSecurityInd=0;
var orgType="";
var selectionHandler=function(newSelectedId){selectedId=newSelectedId;
};
var queryHandler=function(callback,searchString){serviceDelegate.getResults(searchString,orgType,function(results){callback.autosuggest(results);
},orgSecurityInd);
};
var autoSuggestControl=new RCMAutoSuggestControl(textBox,queryHandler,selectionHandler,ToolTipDetailsHandler);
this.getSelectedOrgId=function(){return selectedId;
};
this.setSelectedOrg=function(orgId,orgName){selectedId=orgId;
textBox.value=orgName;
autoSuggestControl.setVerified(orgId>0);
};
this.setRequired=function(required){autoSuggestControl.setRequired(required);
};
this.isVerified=function(){return autoSuggestControl.isVerified;
};
this.setOrgType=function(org){orgType=org;
};
this.addVerifyStateChangeListener=function(listener){autoSuggestControl.addVerifyStateChangeListener(listener);
};
this.removeVerifyStateChangeListener=function(listener){autoSuggestControl.removeVerifyStateChangeListener(listener);
};
var addEventHandler=function(element,event,handler){element.addEventListener?element.addEventListener(event,handler,false):element.attachEvent("on"+event,handler);
};
if(textBox.form){addEventHandler(textBox.form,"reset",function(){selectedId=0;
autoSuggestControl.setVerified(false);
});
}}
function OrgServiceDelegate(){var that=this;
this.getResults=function(searchString,orgType,callback,orgSecurityInd,physicianInd){if(searchString.replace(/\s+/g,"").length<3){callback(new Array());
return;
}var json={REQUEST:{ORG_CDS:[{ORG_TYPE_CD:0}],ORG_TYPE_CODE:0,ORG_TEXT:searchString+"*",MAX:10,START_NUM:1,ORG_ALIAS:"",SEARCH_IND:1,MATCH_IND:"*",SHOW_UNAUTH:0,GROUPNAMEDISP:0,SHOW_INACTIVE:0,ZIP_CODE:"",FSCONTEXT:{CONTEXTLIST:[]},SEARCH_ALL_LOGICAL_DOMAINS_IND:0,PRSNL_ID:0,RCCLINIC_FLAG:0,FILTER_OUT_RCCLINIC_FLAG:0,SPONSOR_NAME_CONTAINS_IND:0,PARENT_ORG_ID:0,RCM_ORG_TYPE_MEANING:orgType}};
var requestArgs=[];
requestArgs.push("^MINE^","0.0","4","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",requestArgs,true,function(status,recordData){if("S"===status){var orgResults=[];
for(var i=0,length=recordData.ORGANIZATION.length;
i<length;
i++){var orgResult=recordData.ORGANIZATION[i];
orgResults.push({NAME:orgResult.ORG_NAME,VALUE:orgResult.ORGANIZATION_ID,DETAILS:""});
}callback(orgResults);
}else{if("F"===status||"Z"===status){callback(new Array());
}}});
};
}
var PathwaysModel = (function() {
	var m_pathwaysConfig = {};

	return {
		"getPathwayFromNodeId" : function(nodeId) {
			var x, y;

			for (x in m_pathwaysConfig) {
				for ( y = m_pathwaysConfig[x].NODE_LIST.length; y--; ) {
					if (m_pathwaysConfig[x].NODE_LIST[y].CP_NODE_ID === nodeId) {
						return (m_pathwaysConfig[x]);
					}
				}
			}
		},
		"getPathwaysConfig" : function() {
			return m_pathwaysConfig;
		},
		"getConfigById" : function(id) {
			return m_pathwaysConfig[id];
		},
		"loadPathway" : function(pathwayId, pathwayInstanceId, pathwayName) {
		    var scriptRequest = new ScriptRequest();
		    
			CERN_PATHWAYS_SHARED_O1.timer.checkpoint("ENG:MPG.Pathway_Workflow", "Start Pathway", {
				"pathway_name" : pathwayName,
				"pathway_id" : pathwayId,
				"pathway_instance_id" : pathwayInstanceId
			});
			
			scriptRequest.setProgramName("CP_LOAD_PATHWAY_CONFIG");
			scriptRequest.setParameterArray(["^MINE^", pathwayId + ".0", 0.0, pathwayInstanceId + ".0"]);
			scriptRequest.setResponseHandler(function(response) {
				PathwaysModel.setConfigById(pathwayId, response.m_responseData);
				CPEventManager.notifyObservers("CP_LOAD_PATHWAY", {
					"PATHWAY_ID" : pathwayId,
					"PATHWAY_INSTANCE_ID" : pathwayInstanceId,
					"PATHWAY_CONFIG" : response.m_responseData
				});
			});

			scriptRequest.performRequest();
		},
		"loadPathwayByConcept" : function(conceptCd) {
			// TODO
		},
		"setPathwaysConfig" : function(val) {
			m_pathwaysConfig = val;
		},
		"setConfigById" : function(id, val) {
			m_pathwaysConfig[id] = val;
		}

	};
})();

var MPageControls = MPageControls || {};

/**
 * This class creates a modal for HealtheIntent Person Search.
 * @public
 * @class
 */
MPageControls.HealtheIntentPersonSearch = (function($) {
  var Search = function() {
    this.id = newId();
    this.formId = 'hi_person_search_form_' + this.id;
    this.tableId = 'hi_person_search_table_' + this.id;

    // Defaults (Overridable by setter methods)
    this.selectHandler = function() {
    };
    this.serviceKey = 'HI_RECORD_API_PERSON_SEARCH';
    this.pageSize = 20;
  };

  /**
   * @public
   * @param {String} testUrl - url to be used instead of registrar key to test
   *         person search with mock data.
   */
  Search.prototype.setTestUrl = function(testUrl) {
    this.serviceKey = testUrl || this.serviceKey;
    return this;
  };

  /**
   * @public
   * @param {String} pageSize - the page size to use when paging through search
   *        results. The default page size is 20.
   */
  Search.prototype.setPageSize = function(pageSize) {
    this.pageSize = pageSize;
    return this;
  };

  /**
   * @public
   * @param {function} setOnSelect - callback function called when a person is selected in
   *        person search modal. A person is considered selected when the user clicked on
   *        the row in the table and click the "Ok" button to close the modal.
   */
  Search.prototype.setOnSelect = function(selectHandler) {
    this.selectHandler = selectHandler;
    return this;
  };

  /**
   * @public
   * @param {function} addPersonHandler - callback function called when 'Add New Person' button is clicked.
   */
  Search.prototype.setOnAddPerson = function(addPersonHandler) {
    this.addPersonHandler = addPersonHandler;
    return this;
  };

  /**
   * This method displays/pops up the persons search modal.
   * @public
   */
  Search.prototype.show = function() {
    var search = this;

    this.modal = HealtheIntent.PersonSearch.modal(this.id, this.formId, this.tableId, this.addPersonHandler);
    this.modal.show();

    $(document).on("submit", "#" + this.formId, function(event) {
      event.preventDefault();

      retrieveAndRenderSearchResults(search, 1, $(event.target));
      search.modal.deactivateSelectButton();
      toggleLoadSpinner(true, search.tableId);
      toggleFormInputsEnabled(true, search.formId);
    });
  }

  // private api exposed for testing
  MPageControls.__HealtheIntentPersonSearch = {
    createResultsTable: createResultsTable,
    retrieveAndRenderSearchResults: retrieveAndRenderSearchResults,
    searchPeople: searchPeople
  };

  // private

  function retrieveAndRenderSearchResults(search, currentPage, $form) {
    searchPeople(search.serviceKey, search.pageSize, currentPage, $form)
      .then(function(response) {
        toggleLoadSpinner(false, search.tableId);
        toggleFormInputsEnabled(false, search.formId);
        return HealtheIntent.PersonSearch.DemographicsList(response);
      })
      .then(function(demographicsList) {
        createResultsTable(search, demographicsList, currentPage, $form);
      })
      .fail(function() {
        toggleLoadSpinner(false, search.tableId);
        toggleFormInputsEnabled(false, search.formId);
        $('#' + search.tableId).html(
          "<h3 class='info-hd'><span class='res-normal'>" + i18n.ERROR_RETREIVING_DATA + "</span></h3>" +
          "<dl class='error-message error-text'><dd><span>" + i18n.ERROR_RETREIVING_DATA + "</span></dd></dl>"
        );
      });
  }

  function createResultsTable(search, demographicsList, currentPage, $form) {
    var table = HealtheIntent.PersonSearch.resultsTable(search.tableId, demographicsList);

    table.onRowSelect(function(selectedDemographics) {
      search.modal.activateSelectButton(function() {
        search.selectHandler(selectedDemographics.id, selectedDemographics);
      });
    });

    $('#' + search.tableId).html(table.html());
    table.finalize();

    if (demographicsList.total_results > search.pageSize) {
      var pager = HealtheIntent.PersonSearch.resultsPager(currentPage, search.pageSize, demographicsList.total_results);

      pager.onPageChange(function(currentPage) {
        retrieveAndRenderSearchResults(search, currentPage, $form);
        search.modal.deactivateSelectButton();
      });

      $('#' + search.tableId).append(pager.html());
      pager.attachEvents();
      pager.updateNextPreviousDisabled();
    }
    $(".hi_person_search .search-container .results-section").scrollTop(0);

    return table;
  };

  function searchPeople(serviceKey, pageSize, currentPage, $form) {
    var formData = HealtheIntent.Utils.serializeFormToJson($form);

    if (formData.dob) {
      //trigger the cap timer for DOB field use
      var capTimer = new CapabilityTimer("CAP:MPG HEALTHE INTENT PERSON SEARCH DOB FIELD USED");
      capTimer.capture();
    }

    var queryParams = {
      q: formData.name,
      date_of_birth: formData.dob ? new Date(formData.dob).toISOString().split("T")[0] : "", // Using split to remove time from date format.
      start: (currentPage - 1) * pageSize,
      limit: pageSize
    };

    return HealtheIntent.Utils.serviceRequest(serviceKey, queryParams);
  };

  function toggleLoadSpinner(loadSpinner, tableId) {
    var $tableId = $('#' + tableId);

    if (loadSpinner) {
      MP_Util.LoadSpinner(tableId);
      // this class adjusts the loading screen indicator for the search modal.
      $tableId.find('.loading-screen').addClass('person-search-load');
    }
    else {
      $tableId.find('.loading-screen').remove();
    }
  }

  function toggleFormInputsEnabled(disableInputs, formId) {
    var $form = $("#" + formId).closest(".form-section"),
      $formAllInputs = $form.find("input"),
      $datepicker = $("#datepicker");

    if (disableInputs) {
      $formAllInputs.not("#datepicker").prop("disabled", true);
      $datepicker.datepicker("disable");
    }
    else {
      $formAllInputs.not("#datepicker").prop("disabled", false);
      $datepicker.datepicker("enable");
    }
  }

  var newId = (function() {
    var counter = 0;
    return function() {
      return counter += 1;
    };
  })();

  return Search;
})(jQuery);

/**
 * Need to shim toISOString() method for IE 8
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString
 */
if (!Date.prototype.toISOString) {
  (function() {

    function pad(number) {
      if (number < 10) {
        return '0' + number;
      }
      return number;
    }

    Date.prototype.toISOString = function() {
      return this.getUTCFullYear() +
        '-' + pad(this.getUTCMonth() + 1) +
        '-' + pad(this.getUTCDate()) +
        'T' + pad(this.getUTCHours()) +
        ':' + pad(this.getUTCMinutes()) +
        ':' + pad(this.getUTCSeconds()) +
        '.' + (this.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) +
        'Z';
    };

  }());
}
function ProviderSearchControl(textBox){var selectedId=0;
var serviceDelegate=new ProviderServiceDelegate();
var orgSecurityInd=0;
var physicianOnlyInd=0;
var providerFilter=[];
var selectionHandler=function(newSelectedId){selectedId=newSelectedId;
};
var queryHandler=function(callback,searchString){if(searchString.replace(/\s+/g,"").length>2){autoSuggestControl.addLoadingSpinner();
serviceDelegate.getResults(searchString,function(results){callback.autosuggest(results);
autoSuggestControl.removeLoadingSpinner();
},orgSecurityInd,physicianOnlyInd,providerFilter);
}else{callback.autosuggest(new Array());
}};
var autoSuggestControl=new RCMAutoSuggestControl(textBox,queryHandler,selectionHandler,ToolTipDetailsHandler);
this.getSelectedProviderId=function(){return selectedId;
};
this.setSelectedProvider=function(providerId,providerName){selectedId=providerId;
textBox.value=providerName;
autoSuggestControl.setVerified(providerId>0);
};
this.setRequired=function(required){autoSuggestControl.setRequired(required);
};
this.isVerified=function(){return autoSuggestControl.isVerified;
};
this.enableProviderSearchOrgSecurity=function(isOrgSecurityEnabled){if(isOrgSecurityEnabled){orgSecurityInd=1;
}};
this.enablePhysicianOnlySearch=function(isPhysicianOnlyInd){if(isPhysicianOnlyInd){physicianOnlyInd=1;
}};
this.setAdvanceFilters=function(filterArray){if(filterArray){providerFilter=filterArray;
}};
this.addVerifyStateChangeListener=function(listener){autoSuggestControl.addVerifyStateChangeListener(listener);
};
this.removeVerifyStateChangeListener=function(listener){autoSuggestControl.removeVerifyStateChangeListener(listener);
};
var addEventHandler=function(element,event,handler){element.addEventListener?element.addEventListener(event,handler,false):element.attachEvent("on"+event,handler);
};
if(textBox.form){addEventHandler(textBox.form,"reset",function(){selectedId=0;
autoSuggestControl.setVerified(false);
});
}}
function ProviderServiceDelegate(){var that=this;
this.getResults=function(searchString,callback,orgSecurityInd,physicianInd,providerFilter){var searchTokens=Search_Util.createPersonNameSearchTokens(searchString);
var nameLastKey=searchTokens[0]+"*";
var nameFirstKey=((searchTokens.length>1)?searchTokens[1]:"")+"*";
var json={REQUEST:{MAX:10,NAME_LAST_KEY:nameLastKey,NAME_FIRST_KEY:nameFirstKey,PHYSICIAN_IND:physicianInd,INACTIVE_IND:0,FT_IND:0,NON_FT_IND:0,PRIV:[],PRSNL_GROUP_ID:0,LOCATION_CD:0,SEARCH_STR_IND:0,SEARCH_STR:"",TITLE_STR:"",SUFFIX_STR:"",DEGREE_STR:"",USE_ORG_SECURITY_IND:orgSecurityInd,ORGANIZATION_ID:0,ORGANIZATIONS:[],START_NAME:"",START_NAME_FIRST:"",CONTEXT_IND:0,CONTEXT_PERSON_ID:0,RETURN_ALIASES:0,RETURN_ORGS:1,RETURN_SERVICES:1,ALIAS_TYPE_LIST:"",PROVIDER_FILTER:providerFilter,AUTH_ONLY_IND:1}};
var requestArgs=[];
requestArgs.push("^MINE^","0.0","1","^"+JSON.stringify(json)+"^");
Search_Util.makeCCLRequest("rcm_searches",requestArgs,true,function(status,recordData){if("S"===status){var providerResults=[];
for(var i=0,length=recordData.PRSNL.length;
i<length;
i++){var providerResult=recordData.PRSNL[i];
providerResults.push({NAME:providerResult.NAME_FULL_FORMATTED.replace(/\s+$/,""),VALUE:providerResult.PERSON_ID,DETAILS:createProviderAdditionalDetails(providerResult)});
}callback(providerResults);
}else{if("F"===status){callback(new Array());
}else{if("Z"===status){callback([{NAME:rcm_search_i18n.NO_RESULTS_FOUND,VALUE:null,DETAILS:null}]);
}}}});
};
function createProviderAdditionalDetails(providerResult){var positionDetails="<strong>"+rcm_search_i18n.PROV_SEARCH_DETAILS_POSITIONS+"</strong>";
var isFirstPosition=true;
for(var i=0,positionsLength=providerResult.POSITIONS.length;
i<positionsLength;
i++){if(isFirstPosition){positionDetails+=providerResult.POSITIONS[i].POSITION_DISP;
isFirstPosition=false;
continue;
}positionDetails+=", "+providerResult.POSITIONS[i].POSITION_DISP;
}positionDetails+="<br />";
var servicesDetails="<strong>"+rcm_search_i18n.PROV_SEARCH_DETAILS_SERVICES+"</strong>";
var isFirstService=true;
for(var j=0,servicesLength=providerResult.SERVICE.lenth;
j<servicesLength;
j++){if(isFirstService){servicesDetails+=providerResult.SERVICE[j].SERVICE_DESC_NAME;
isFirstService=false;
continue;
}servicesDetails+=", "+providerResult.SERVICE[j].SERVICE_DESC_NAME;
}servicesDetails+="<br />";
var orgsDetails="<strong>"+rcm_search_i18n.PROV_SEARCH_DETAILS_ORGS+"</strong>";
var isFirstOrg=true;
var maxOrgsToDisplay=5;
for(var k=0,orgsLength=providerResult.ORG.length;
k<orgsLength;
k++){if(isFirstOrg){orgsDetails+=providerResult.ORG[k].ORG_NAME;
isFirstOrg=false;
continue;
}if(k==maxOrgsToDisplay){orgsDetails+=", "+rcm_search_i18n.PROV_SEARCH_MORE_ORGS_AVAILABLE;
break;
}orgsDetails+=", "+providerResult.ORG[k].ORG_NAME;
}return positionDetails+servicesDetails+orgsDetails;
}}
/**
 * The ReferenceTextViewer object contains information about the aspects of how the ReferenceTextViewer will wrap the entity information and the ModalDialog id associated with that object. The customizable options include the entity name, entity id, entity date time(optional) and text type cd(optional).
 */
function ReferenceTextViewer(referenceTextViewerId, component) {
	//The component object
	this.m_component = component;
	//The id given to the ReferenceTextViewer object. It will be used to set/retrieve the reference text object
	this.m_refTextViewerId = referenceTextViewerId;
	this.m_entityName = null;
	this.m_entityId = 0.0;
	this.m_entityDtTm = 0;
	this.m_entityTextTypeCd = 0;
	this.m_modalId = null;
	this.m_headerTitle = "";
	this.m_errorFunction = null;
	//HTML code set value 
	this.m_htmlCodeValue = 0;
	//RTF code set value 
	this.m_rtfCodeValue = 0;
}
/** Setters */
/**
 * set the html code value
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setHtmlCodeValue = function (htmlCodeValue) {
	if ( typeof htmlCodeValue !== "number") {
		throw new Error("The html code value passed is not a number");
	}
	this.m_htmlCodeValue = htmlCodeValue;
	return this;
};
/**
 * set the rtf code value
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setRtfCodeValue = function(rtfCodeValue){
	if ( typeof rtfCodeValue !== "number") {
		throw new Error("The rtf code value passed is not a number");
	}
	this.m_rtfCodeValue = rtfCodeValue;
	return this;
};
/**
 * set the header title for modal window
 * @param{string} header title 
 * @return{ReferenceTextViewer} return self to allow chaining
*/
ReferenceTextViewer.prototype.setWindowHeader = function(headerTitle){
	if (typeof headerTitle !== "string") {
		throw new Error("The header title passed is not a string");
	}
	this.m_headerTitle = headerTitle;
	return this;
};
/**
 * set the entity name
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setEntityName = function (entityName) {
	if (typeof entityName !== "string") {
		throw new Error("The entity name passed is not a string");
	}
	this.m_entityName = entityName;
	return this;
};
/**
 * set the entity id
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setEntityId = function (entityId) {
	if (typeof entityId !== "number") {
		throw new Error("The entity id passed is not a number");
	}
	this.m_entityId = entityId;
	return this;
};
/**
 * set the entity date time
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setEntityDateTime = function (entityDateTime) {
	if (!(entityDateTime instanceof Date)) {
		throw new Error("The entity date time passed is not a Date time ");
	}
	this.m_entityDtTm = entityDateTime;
	return this;
};
/**
 * set the entity text type
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setEntityTextType = function (entityTextType) {
	if (typeof entityTextType !== "number") {
		throw new Error("The entity text type passed is not a number");
	}
	this.m_entityTextTypeCd = entityTextType;
	return this;
};
/**
 * set the error method which will be called in case if service fails
 * @throws {Error} An error indicating that the parameter is an invalid type.
 * @return {ReferenceTextViewer} return self to allow chaining
 */
ReferenceTextViewer.prototype.setErrorMethod = function(errorFunction){
	if (typeof errorFunction !== "function") {
		throw new Error("The entity name passed is not a number");
	}
	this.m_errorFunction = errorFunction;
	return this;
};

/** Getters*/
/**
 * @private
 * @return {number} return html code value
 */
ReferenceTextViewer.prototype.getHtmlCodeValue = function () {
	return this.m_htmlCodeValue;
};
/**
 * @private
 * @return {number} return rtf code value
 */
ReferenceTextViewer.prototype.getRtfCodeValue = function () {
	return this.m_rtfCodeValue;
};
/**
 * @private
 * @return {String} return comp ID
 */
ReferenceTextViewer.prototype.getComponentIdForObject = function () {
	return this.m_refTextViewerId;
};
/**
 * @return {String} return entity naem
 */
ReferenceTextViewer.prototype.getEntityName = function () {
	return this.m_entityName;
};
/**
 * @return {number} return entity ID
 */
ReferenceTextViewer.prototype.getEntityId = function () {
	return this.m_entityId;
};
/**
 * @return {Date} return date time associated with an entity
 */
ReferenceTextViewer.prototype.getEntityDateTime = function () {
	return this.m_entityDtTm;
};
/**
 * @return {number} return text type
 */
ReferenceTextViewer.prototype.getEntityTextType = function () {
	return this.m_entityTextTypeCd;
};
/**
 * @return {function} return error handler
 */
ReferenceTextViewer.prototype.getErrorMethod = function(){
	return this.m_errorFunction;
};
/**
 * @return {object} return component object
 */
ReferenceTextViewer.prototype.getComponent = function(){
	return this.m_component;
};
/**
 This function iterates through the reference qual array and return a boolean value matching the text type passed.
* @params {String, Array} textTypeMean: defines the text type; referenceQualArray : reference qual array
* @return {boolean} return true/false depending if he specified text type is available.
*/
ReferenceTextViewer.prototype.isQualAvailable = function (textTypeMean, referenceQualArray) {
	var referenceQualArrayLength = referenceQualArray.CDF_QUAL.length;
	for (var i = 0; i < referenceQualArrayLength; i++) {
		if (textTypeMean === referenceQualArray.CDF_QUAL[i].CDF_MEANING && referenceQualArray.CDF_QUAL[i].EXIST_IND === 1) {
			return true;
		}
	}
	return false;
};
/**
This function iterates through the reference texts array and return long_blob matching the text type passed.
 * @private
 * @params {String, Array} textTypeMean: defines the text type; referenceTextArray : reference text array
 * @return {String} return long_blob value for the specified text type
 */
ReferenceTextViewer.prototype.getBlobDataFromReferenceTextArray = function (textTypeMean, referenceTextArray) {
	var referenceTextArrayLength = referenceTextArray.REF_TEXT_VERSION.length;
	for (var i = 0; i < referenceTextArrayLength; i++) {
		if (textTypeMean === referenceTextArray.REF_TEXT_VERSION[i].TEXT_TYPE_MEAN) {
			return referenceTextArray.REF_TEXT_VERSION[i].LONG_BLOB;
		}
	}
};
/**
 * This function calls the request 969553 to convert rtf data to HTML markup and
 * append it to the modal window container.
 * @private
 * @params {JSON, number, jquery selector} mp_request:request structure to request 969553; compId : the component ID; tabContentsContainer: jquery selector for modal window body.
 */
ReferenceTextViewer.prototype.setHTMLFromLongBlob = function (mp_request, compId, tabContentsContainer) {
	var MP_RTFTOFO = {
		APPLICATION : 600005,
		TASK : 3202004,
		REQUEST : 969553
	};
	var self = this;
	var referenceTexti18n = i18n.discernabu.reference_text;
	var htmlScriptRequest = new ScriptRequest();
	htmlScriptRequest.setProgramName("MP_EXEC_STD_REQUEST");
	htmlScriptRequest.setParameterArray(["^MINE^", "^^", MP_RTFTOFO.APPLICATION, MP_RTFTOFO.TASK, MP_RTFTOFO.REQUEST]);
	htmlScriptRequest.setDataBlob(MP_Util.enhancedStringify(mp_request));
	htmlScriptRequest.setResponseHandler(function (htmlScriptReply) {
		if (htmlScriptReply.getStatus() === "S") {
			var response = htmlScriptReply.getResponse();
			var bodyData = response.CONVERTED_TEXT;
			var bodyStart = bodyData.indexOf("<div");
			var bodyEnd = bodyData.lastIndexOf("</div>");
			var body = bodyData.substring(bodyStart, bodyEnd);
			var tabData = "<div class='ref-text-tab-body'>" + body + "</div>";
			tabContentsContainer.empty().append(tabData);

		} else {
			var retryButton = new MPageUI.Button();
			retryButton.setLabel(referenceTexti18n.RETRY).setStyle(MPageUI.BUTTON_OPTIONS.STYLE.NORMAL).setOnClickCallback(function () {
				self.setHTMLFromLongBlob(mp_request, compId, tabContentsContainer);
			});
			var errorHTML = "<div id='referenceTextError' class='ref-text-error'><div class='ref-text-error-icon'></div><div class='ref-text-primary-error'>" + referenceTexti18n.REFERENCE_TEXT_FAILURE + "</div><div>" + referenceTexti18n.INLINE_ERROR_MESSAGE + "</div><div class='ref-text-retry-btn'>" + retryButton.render() + "</div></div>";
			tabContentsContainer.empty().append(errorHTML);
			retryButton.attachEvents();
		}
	});
	htmlScriptRequest.performRequest();
};
/**
 * This function creates the required html for the reference text modal window adding * a tabbed view for different types reference texts.
 * Calls the request 500664 to fetch reference text data for the given
 * parent_entity_name and parent_entity_id. Calls setHTMLFromLongBlob function to set * reference text data to modal window body.
 */
ReferenceTextViewer.prototype.createReferenceTextModalWindow = function (refTextExistsResponse, rtfCodeValue, htmlCodeValue) {
	var self = this;
	var referenceTexti18n = i18n.discernabu.reference_text;
	var compId = self.getComponentIdForObject();
	var referenceTextModalDialog = null;
	var headerTitle = "";
	var scriptSuccess = false;
	var tabContent = "";
	if (this.m_headerTitle !== "") {
		headerTitle = referenceTexti18n.REFERENCE_TEXT + " " + referenceTexti18n.FOR + " " + this.m_headerTitle;
	} else {
		headerTitle = referenceTexti18n.REFERENCE_TEXT;
	}
	if (this.m_entityName === null) {
		throw new Error("The entity name cannot be null");
	}
	if (this.m_entityId === 0.0) {
		throw new Error("The entity id cannot be empty");
	}
	// If the entity name and entity id is not null, then call the dcp_get_ref_text_by_version to retrieve reference text associated with the request.
	var DCP_GET_REF_TEXT_BY_VERSION = {
		APPLICATION : 600005,
		TASK : 3202004,
		REQUEST : 500664
	};
	var blobIn = {
		REQUESTIN : {
			PARENT_ENTITY_NAME : this.getEntityName(),
			PARENT_ENTITY_ID : this.getEntityId(),
			FACILITY_CD : this.getEntityDateTime(),
			TEXT_TYPE_CD : this.getEntityTextType()
		}
	};
	var mp_request = {
		REQUESTIN : {
			DESIRED_FORMAT_CD : htmlCodeValue,
			ORIGIN_FORMAT_CD : rtfCodeValue,
			ORIGIN_TEXT : ""
		}
	};
	var scriptRequest = new ScriptRequest();
	scriptRequest.setProgramName("MP_EXEC_STD_REQUEST");
	scriptRequest.setParameterArray(["^MINE^", "^^", DCP_GET_REF_TEXT_BY_VERSION.APPLICATION, DCP_GET_REF_TEXT_BY_VERSION.TASK, DCP_GET_REF_TEXT_BY_VERSION.REQUEST]);
	scriptRequest.setDataBlob(MP_Util.enhancedStringify(blobIn));
	scriptRequest.setResponseHandler(function (scriptReply) {
		if (scriptReply.getStatus() === "S") {
			var tabControl = new MPageUI.SecondaryTabControl();
			var response = scriptReply.getResponse();
			referenceTextModalDialog = new ModalDialog(self.getComponentIdForObject() + "referenceText").setHeaderTitle(headerTitle).setIsBodySizeFixed(false);
			referenceTextModalDialog.m_margins = {
				top : 5,
				right : 5,
				bottom : 100,
				left : 5
			};
			referenceTextModalDialog.setBodyDataFunction(function (modalObj) {
				var carePlanInformation = {
					id : "carePlanInformation",
					label : referenceTexti18n.CARE_PLAN_INFORMATION,
					title : "Care Plan Information",
				};
				var chartGuide = {
					id : "chartGuide",
					label : referenceTexti18n.CHART_GUIDE,
					title : "Chart Guide",
				};
				var nursePreparation = {
					id : "nursePrep",
					label : referenceTexti18n.NURSE_PREPARATION,
					title : "Nurse Preparation",
				};
				var patientEducation = {
					id : "patientEducation",
					label : referenceTexti18n.PATIENT_EDUCATION,
					title : "Patient Education",
				};
				var policyAndProcedures = {
					id : "policyAndProcedures",
					label : referenceTexti18n.POLICY_AND_PROCEDURES,
					title : "Policy and Procedures ",
				};
				var schedulingInformation = {
					id : "schedulingInformation",
					label : referenceTexti18n.SCHEDULING_INFORMATION,
					title : "Scheduling Information ",
				};
				if (self.isQualAvailable("SCHED INFO", refTextExistsResponse)) {
					tabControl.addTab(schedulingInformation);
				}
				if (self.isQualAvailable("CAREPLANINFO", refTextExistsResponse)) {
					tabControl.addTab(carePlanInformation);
				}
				if (self.isQualAvailable("CHART GUIDE", refTextExistsResponse)) {
					tabControl.addTab(chartGuide);
				}
				if (self.isQualAvailable("NURSE PREP", refTextExistsResponse)) {
					tabControl.addTab(nursePreparation);
				}
				if (self.isQualAvailable("POLICYPROC", refTextExistsResponse)) {
					tabControl.addTab(policyAndProcedures);
				}
				if (self.isQualAvailable("PATIENT ED", refTextExistsResponse)) {
					tabControl.addTab(patientEducation);
				}
				tabControl.setCanSortTabs(true);
				tabControl.setEnableLabelCount(false);
				tabControl.setOnSelectCallback(function (tab) {
					switch (tab.id) {
					case "schedulingInformation":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("SCHED INFO", response);
						break;
					case "carePlanInformation":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("CAREPLANINFO", response);
						break;
					case "chartGuide":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("CHART GUIDE", response);
						break;
					case "nursePrep":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("NURSE PREP", response);
						break;
					case "patientEducation":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("PATIENT ED", response);
						break;
					case "policyAndProcedures":
						mp_request.REQUESTIN.ORIGIN_TEXT = self.getBlobDataFromReferenceTextArray("POLICYPROC", response);
						break;
					}
					var tabContentsContainer = $("#tabContentsContainer" + compId);
					tabContentsContainer.empty();
					self.setHTMLFromLongBlob(mp_request, compId, tabContentsContainer);
				});

				var tabContainer = "<div class='ref-tab-container' id='tabContainer" + compId + "'><div id='tabData" + compId + "'class='ref-tab-control-container'><div id='refTabControlContainer" + compId + "'>";
				tabContent = tabControl.render();
				tabContent = tabContainer.concat(tabContent);
				tabContent += "</div></div><hr><div id='tabContentsContainer" + compId + "' class='ref-tab-content-container'></div></div>";
				modalObj.setBodyHTML(tabContent);
				tabControl.finalize();
			});
			var closeModalButton = new ModalButton(self.getComponentIdForObject() + "closeButton");
			closeModalButton.setText(i18n.CLOSE).setIsDithered(false);
			closeModalButton.setOnClickFunction(function () {
				MP_ModalDialog.closeModalDialog(referenceTextModalDialog.getId());
				MP_ModalDialog.deleteModalDialogObject(referenceTextModalDialog.getId());
			});
			referenceTextModalDialog.setHeaderCloseFunction(function () {
				MP_ModalDialog.closeModalDialog(referenceTextModalDialog.getId());
				MP_ModalDialog.deleteModalDialogObject(referenceTextModalDialog.getId());
			});
			referenceTextModalDialog.addFooterButton(closeModalButton);
			MP_ModalDialog.addModalDialogObject(referenceTextModalDialog);
			MP_ModalDialog.showModalDialog(referenceTextModalDialog.getId());
			scriptSuccess = true;

		} else {
			if (self.getErrorMethod()) {
				self.m_errorFunction(self.getComponent());
			}
		}
	});
	scriptRequest.performRequest();
};
/**
 * This function calls the  service 600112 to retrieve qual for the given entity and calls the createReferenceTextModalWindow function
 */
ReferenceTextViewer.prototype.viewReferenceText = function () {
	var self = this;
	var DCP_GET_REF_TEXT_EXISTS = {
		APPLICATION : 600005,
		TASK : 600701,
		REQUEST : 600112
	};
	var blobInForRefExists = {
		REQUESTIN : {
			parent_entity_name : this.getEntityName(),
			parent_entity_id : this.getEntityId(),
			parent_entity_dt_tm : this.getEntityDateTime()
		}
	};
	var scriptRequestForRefExists = new ScriptRequest();
	scriptRequestForRefExists.setProgramName("MP_EXEC_STD_REQUEST");
	scriptRequestForRefExists.setParameterArray(["^MINE^", "^^", DCP_GET_REF_TEXT_EXISTS.APPLICATION, DCP_GET_REF_TEXT_EXISTS.TASK, DCP_GET_REF_TEXT_EXISTS.REQUEST]);
	scriptRequestForRefExists.setDataBlob(MP_Util.enhancedStringify(blobInForRefExists));
	scriptRequestForRefExists.setResponseHandler(function (scriptReply) {
		if (scriptReply.getStatus() === "S") {
			refTextExistsResponse = scriptReply.getResponse();
			if (self.getRtfCodeValue() === 0 || self.getHtmlCodeValue() === 0) {
				self.getCodeValuesForRtfToHtml(refTextExistsResponse);
			} else {
				self.createReferenceTextModalWindow(refTextExistsResponse, self.getRtfCodeValue(), self.getHtmlCodeValue());
			}
		} else {
			if (self.getErrorMethod()) {
				self.m_errorFunction(self.getComponent());
			}
		}
	});
	scriptRequestForRefExists.performRequest();
};
/**
 * Calls the request 600334 to fetch code values for code set 23
 */
ReferenceTextViewer.prototype.getCodeValuesForRtfToHtml = function (refTextExistsResponse) {
	var self = this;
	var DCP_GET_CODE_VALUE = {
		APPLICATION : 600005,
		TASK : 601010,
		REQUEST : 600334
	};
	var blobIn = {
		REQUESTIN : {
			MODE_FLAG : 2,
			CODE_LIST : [{
					CODE_SET : 23,
					CODE_MEANING : "RTF"
				}, {
					CODE_SET : 23,
					CODE_MEANING : "HTML"
				}
			]
		}
	};
	var codeValueScriptRequest = new ScriptRequest();
	codeValueScriptRequest.setProgramName("MP_EXEC_STD_REQUEST");
	codeValueScriptRequest.setParameterArray(["^MINE^", "^^", DCP_GET_CODE_VALUE.APPLICATION, DCP_GET_CODE_VALUE.TASK, DCP_GET_CODE_VALUE.REQUEST]);
	codeValueScriptRequest.setDataBlob(MP_Util.enhancedStringify(blobIn));
	codeValueScriptRequest.setResponseHandler(function (scriptReply) {
		if (scriptReply.getStatus() === "S") {
			var codeList = scriptReply.getResponse().CODE_LIST;
			for (var codeListCount = 0; codeListCount < codeList.length; codeListCount++) {
				if (codeList[codeListCount].CDF_MEANING === "RTF") {
					self.setRtfCodeValue(codeList[codeListCount].CODE_VALUE);
				} else if (codeList[codeListCount].CDF_MEANING === "HTML") {
					self.setHtmlCodeValue(codeList[codeListCount].CODE_VALUE);
				}
			}
			self.createReferenceTextModalWindow(refTextExistsResponse, self.getRtfCodeValue(), self.getHtmlCodeValue());
		} else {
			if (self.getErrorMethod()) {
				self.m_errorFunction(self.getComponent());
			}
		}
	});
	codeValueScriptRequest.performRequest();
};
/**
 * @class
 * This AbstractViewerHandler object is the basic implementation of any viewer handlers and should be used to model specific viewer handler.
 * It defines the functions and values that will be present for any type of viewer handlers regardless of the viewer type.
 */
var AbstractViewerHandler = function() {
	/* member variables needed for launching a viewer */
	this.m_eventIds = null;

	this.m_parentEventId = 0;
	this.m_patientId = 0;
	this.m_encounterId = 0;
	this.m_providerId = 0;
	this.m_resultName = "";
	this.m_imageUrl = "";
	this.m_imageInd = false;
	this.m_viewerType = "";

	//below are fields needed to launch the editors
	this.m_activityId = 0;
	this.m_editorType = "";
	this.m_editModeInd = false;
	

	//flag which indicate whether MPage is being run in Millennium context
	this.m_millenniumInd = false;
	//the Unique ID of the viewer handler
	this.m_uniqueId = 0;

	//variables used for CMV authentication and displaying the CMV within MPages
	this.m_username = "";
	this.m_password = "";
	this.m_domain = "";
};

/**
 * Retrieves the event ID Array that will be used by the viewer handler to launch the viewer.
 * If no event ID has been added to it before, empty array will be returned. 
 * @return {Array} The event ID array of the results that will be viewed
 */
AbstractViewerHandler.prototype.getEventIds = function() {
	if(this.m_eventIds === null){
		this.m_eventIds = [];
	}
	return this.m_eventIds;
};

/**
 * Add the event ID that will be used by the viewer handler to launch the viewer.
 * The event ID will be appended to the event ID array, or create an array if the array doesn't exist yet.
 * @param {number} eventId The event ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.addEventId = function(eventId) {
	if (typeof eventId !== "number" || eventId < 0) {
		throw new Error("AbstractViewerHandler.addEventId: Invalid eventId");
	}
	this.getEventIds().push(eventId);
};

/**
 * Retrieves the parent event ID that will be used by the viewer handler to launch the viewer.
 * @return {number} The parent event ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.getParentEventId = function() {
	return this.m_parentEventId;
};

/**
 * Set the parent event ID that will be used by the viewer handler to launch the viewer.
 * It should be a non-negative number.
 * @param {number} parentEventId The parent event ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.setParentEventId = function(parentEventId) {
	if (typeof parentEventId !== "number" || parentEventId < 0) {
		throw new Error("AbstractViewerHandler: Invalid parentEventId");
	}
	this.m_parentEventId = parentEventId;
};

/**
 * Retrieves the patient ID that will be used by the viewer handler to launch the viewer.
 * @return {number} The patient ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.getPatientId = function() {
	return this.m_patientId;
};

/**
 * Set the patient ID that will be used by the viewer handler to launch the viewer.
 * It should be a non-negative number.
 * @param {number} patientId The patient ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.setPatientId = function(patientId) {
	if (typeof patientId !== "number" || patientId < 0) {
		throw new Error("AbstractViewerHandler: Invalid patientId");
	}
	this.m_patientId = patientId;
};

/**
 * Retrieves the encounter ID that will be used by the viewer handler to launch the viewer.
 * @return {number} The encounter ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.getEncounterId = function() {
	return this.m_encounterId;
};

/**
 * Set the encounter ID that will be used by the viewer handler to launch the viewer.
 * It should be a non-negative number.
 * @param {number} encounterId The encounter ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.setEncounterId = function(encounterId) {
	if (typeof encounterId !== "number" || encounterId < 0) {
		throw new Error("AbstractViewerHandler: Invalid encounterId");
	}
	this.m_encounterId = encounterId;
};

/**
 * Retrieves the provider ID that will be used by the viewer handler to launch the viewer.
 * @return {number} The provider ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.getProviderId = function() {
	return this.m_providerId;
};

/**
 * Set the provider ID that will be used by the viewer handler to launch the viewer.
 * It should be a non-negative number.
 * @param {number} providerId The provider ID of the results that will be viewed
 */
AbstractViewerHandler.prototype.setProviderId = function(providerId) {
	if (typeof providerId !== "number" || providerId < 0) {
		throw new Error("AbstractViewerHandler: Invalid providerId");
	}
	this.m_providerId = providerId;
};

/**
 * Retrieves the result name that will be used in the result viewer.
 * @return {string} The result name of the results that will be viewed
 */
AbstractViewerHandler.prototype.getResultName = function() {
	return this.m_resultName;
};

/**
 * Set the result name that will be used in the result viewer.
 * @param {string} resultName The result name of the results that will be viewed
 */
AbstractViewerHandler.prototype.setResultName = function(resultName) {
	if ( typeof resultName !== "string") {
		throw new Error("AbstractViewerHandler: Invalid resultName");
	}
	this.m_resultName = resultName;
};

/**
 * Retrieves the image URL that will be used by the viewer handler to launch the viewer.
 * This is mainly used in Document/Pathology viewers.
 * @return {string} The URL of the result image
 */
AbstractViewerHandler.prototype.getImageUrl = function() {
	return this.m_imageUrl;
};

/**
 * Set the image URL that will be used by the viewer handler to launch the viewer.
 * This is mainly used in Document/Pathology viewers.
 * @param {string} imageUrl The URL of the result image
 */
AbstractViewerHandler.prototype.setImageUrl = function(imageUrl) {
	if ( typeof imageUrl !== "string") {
		throw new Error("AbstractViewerHandler: Invalid imageUrl");
	}
	this.m_imageUrl = imageUrl;
};

/**
 * Retrieves the image indicator that will be used by the viewer handler to launch the viewer.
 * This is used mainly in Document/Pathology viewers to indicate whether the image tab should be displayed by default.
 * @return {boolean} Flag indicating whether the image tab of the viewer should be displayed by default
 */
AbstractViewerHandler.prototype.getImageInd = function() {
	return this.m_imageInd;
};

/**
 * Set the image indicator that will be used by the viewer handler to launch the viewer.
 * This is used mainly in Document/Pathology viewers to indicate whether the image tab should be displayed by default.
 * @param {boolean} imageInd Flag indicating whether the image tab of the viewer should be displayed by default
 */
AbstractViewerHandler.prototype.setImageInd = function(imageInd) {
	if ( typeof imageInd !== "boolean") {
		throw new Error("AbstractViewerHandler: Invalid imageInd");
	}
	this.m_imageInd = imageInd;
};

/**
 * Retrieves the Powerform activity ID associated to the discrete results charted on a Powerform. 
 * It will be used to launch the viewer in edit mode. 
 * @return {number} Poowerform activity ID
 */
AbstractViewerHandler.prototype.getActivityId = function() {
	return this.m_activityId;
};

/**
 * Set the Powerform activity ID associated to the discrete results charted on Powerform. 
 * It will be used to launch the viewer in edit mode. 
 * @param {number} activityId Poowerform activity ID
 */
AbstractViewerHandler.prototype.setActivityId = function(activityId) {
	if ( typeof activityId !== "number") {
		throw new Error("AbstractViewerHandler: Invalid activityId");
	}
	this.m_activityId = activityId;
};

/**
 * Retrieves the editor type associated to the result. 
 * It will be used to launch the right viewer in edit mode. 
 * @return {string} The editor type of the result
 */
AbstractViewerHandler.prototype.getEditorType = function() {
	return this.m_editorType;
};

/**
 * Set the editor type associated to the result. 
 * It will be used to launch the right viewer in edit mode. 
 * @param {string} editorType The editor type
 */
AbstractViewerHandler.prototype.setEditorType = function(editorType) {
	if ( typeof editorType !== "string") {
		throw new Error("AbstractViewerHandler: Invalid editorType");
	}
	this.m_editorType = editorType;
};

/**
 * Retrieves the flag that indicates whether the viewer will be launched in edit mode. 
 * When false (default), the viewer will be launched in readonly mode. When true, it will be in edit mode. 
 * @return {boolean} The flag that indicates whether the viewer will be launched in edit mode
 */
AbstractViewerHandler.prototype.getEditModeInd = function() {
	return this.m_editModeInd;
};

/**
 * Set the flag that indicates whether the viewer will be launched in edit mode. 
 * When false (default), the viewer will be launched in readonly mode. When true, it will be in edit mode. 
 * @return {boolean} The flag that indicates whether the viewer will be launched in edit mode
 */
AbstractViewerHandler.prototype.setEditModeInd = function(editModeInd) {
	if ( typeof editModeInd !== "boolean") {
		throw new Error("AbstractViewerHandler: Invalid editModeInd");
	}
	this.m_editModeInd = editModeInd;
};

/**
 * Retrieves the viewer type that will be used by the viewer handler to launch the viewer.
 * This is one of the most important field that helps decides which viewer will be used.
 * @return {string} The viewer type of the viewer that will be launched to display the results
 */
AbstractViewerHandler.prototype.getViewerType = function() {
	return this.m_viewerType;
};

/**
 * Set the viewer type that will be used by the viewer handler to launch the viewer.
 * In viewers like Document/Pathology, it's required as part of CCL parameters
 * @param {string} viewerType The viewer type of the viewer that will be launched to display the results
 */
AbstractViewerHandler.prototype.setViewerType = function(viewerType) {
	if ( typeof viewerType !== "string") {
		throw new Error("AbstractViewerHandler: Invalid viewerType");
	}
	this.m_viewerType = viewerType;
};

/**
 * It is the main function in AbstractViewerHandler that validates required fields before opening the viewer in right mode.
 * When the MPage is running on Millennium system, it will launch Millennium viewer; otherwise, it will launch the web modal dialog viewer.
 */
AbstractViewerHandler.prototype.showViewer = function() {
	//Validate required fields are available
	this.validateRequiredFields();

	//Launch the viewer that is available to its platform
	if (this.m_millenniumInd) {
		//launch the Millennium viewer
		this.launchMillenniumViewer();
	} else {
		//launch the web modal viewer
		this.launchWebViewer();
	}
};

/**
 * This function will check if required fields have the correct data types and valid values. It is called inside function showViewer prior displaying the viewer.
 * It helps prevent making invalid CCL calls to the back-end and displaying invalid results.
 * It will fail hard with Error thrown out when a required field is missing or not set correctly.
 * It needs to be implemented by objects that overrides AbstractViewerHandler.
 * Typically it only checks fields required by the specific viewer that will launch in the application context (in Millennium or in browsers).
 */
AbstractViewerHandler.prototype.validateRequiredFields = function() {
	
};

/**
 * It launches Millennium viewer in Millennium platform to display the result
 * It is supposed to be implemented by objects that overrides AbstractViewerHandler.
 */
AbstractViewerHandler.prototype.launchMillenniumViewer = function() {
	alert(i18n.discernabu.CAN_NOT_VIEW_RESULTS);
};

/**
 * It launches web modal dialog viewer in non-Millennium platform to display the result. 
 * By default, it will display the error message in the dialog that the result cannot be viewed. 
 * It is supposed to be implemented by objects that overrides AbstractViewerHandler. The implementation 
 * should display the results correctly in a modal dialog. 
 */
AbstractViewerHandler.prototype.launchWebViewer = function() {
	var message = i18n.discernabu.CAN_NOT_VIEW_RESULTS;
	var buttonText = i18n.discernabu.mpage_result_viewer.result_modal.CLOSE;
	var title = i18n.discernabu.mpage_result_viewer.result_modal.ERROR_TITLE;

	var modalObj = MP_Util.generateModalDialogBody("resultViewerNotSupportedAlert", "error", message, "");
	var modalButton = modalObj.getFooterButton("modalOkBtn");
	if (!modalButton) {
		modalButton = new ModalButton("modalOkBtn");
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true);
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
	}
	modalObj.setHeaderTitle(title);
	modalObj.setFooterButtonText("modalOkBtn", buttonText);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("resultViewerNotSupportedAlert");
};

//old code
AbstractViewerHandler.prototype.loadWithCBParameters = function(programName, cclParams, callBack, requireRawData) {
	try {
		var request = new MP_Core.ScriptRequest(null);
		request.setProgramName(programName);
		request.setParameters(cclParams);
		request.setAsync(true);
		//set the field when it's true or 1
		if (requireRawData === true || requireRawData === 1) {
			request.setRequiresRawData(true);
		}
		MP_Core.XMLCCLRequestCallBack(null, request, callBack);
	} catch (err) {
		logger.logScriptCallError(null, this, "abstract-viewer-handler.js", "loadWithCBParameters");
	}
};

/**
 * It retrieves the right XMLHttpRequest depending on the browser type
 * It's used to load Cerner Media Viewer for document viewer and pathology viewer.
 * @return {XMLHttpRequest} An XMLHttpRequest object
 */
AbstractViewerHandler.prototype.getXMLHttpRequest = function() {
	var xmlHttp = null;
	try {
		if (window.XMLHttpRequest) {
			xmlHttp = new XMLHttpRequest();
		}
	} catch (e) {
		try {
			xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e2) {
			xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
		}
	}
	return xmlHttp;
};

/**
 * It's the first step to load Cerner Media Viewer for document viewer and pathology viewer.
 * It starts the chain of loading Cerner Media Viewer. Specifically it requests authentication information from ../../mpages/creds,
 * saves CMV authentication information and continue loading CMV, and then calls locateCmvWebapp to continue loading CMV.
 */
AbstractViewerHandler.prototype.initMediaViewer = function() {
	var self = this;
	var url = "../../mpages/creds";
	//Create XMLHttpRequest object for CMV initialization
	var xhrObjInit = this.getXMLHttpRequest();
	xhrObjInit.open("GET", url, false);
	xhrObjInit.onreadystatechange = function() {
		try {
			if (this.readyState == 4) {
				if (this.status == 200) {
					var jObj = JSON.parse(xhrObjInit.responseText);
					self.m_username = jObj.un;
					self.m_password = jObj.pw;
					self.m_domain = jObj.dm;
					self.locateCmvWebapp();
				}
			} else {
				logger.logScriptCallError(null, this, "abstract-viewer-handler.js", "processRequest");
			}
		} catch (e) {
			logger.logScriptCallError(null, this, "abstract-viewer-handler.js", "processRequest");
		}
	};
	xhrObjInit.send();
};

/**
 * It's the second step to load Cerner Media Viewer for document viewer and pathology viewer.
 * It starts loading Cerner Media Viewer with the authentication information retrieved in previous steps.
 * When CMV webapp finishes the requests, it sets the CMV flag to true.
 */
AbstractViewerHandler.prototype.locateCmvWebapp = function() {
	var url = "../../../mediaviewer/mom";
	var xhrObj = this.getXMLHttpRequest();
	var userDomain = "";

	//Safari user agent strings are like "Mozila ([operation system]) AppleWebKit/[number] [other stuff]"
	//http://www.useragentstring.com/pages/Safari/
	var isWebKit = new RegExp(" AppleWebKit/").test(navigator.userAgent);

	if (isWebKit) {
		//Safari only accepts %40
		userDomain = this.m_username + "%40" + this.m_domain;
	} else {
		//IE only accepts @, but Chrome and FF do as well
		userDomain = this.m_username + "@" + this.m_domain;
	}
	xhrObj.open("GET", url, false, userDomain, this.m_password);
	xhrObj.onreadystatechange = function() {
		try {
			if (this.readyState == 4) {
				if (this.status == 200) {
					//log message when reply comes back successfully
					logger.logInfo("AbstractViewerHandler.locateCmvWebapp: Connected to ../../../mediaviewer/mom successfully.");
				}
			}
		} catch (e) {
			logger.logScriptCallError(null, this, "abstract-viewer-handler.js", "locateCmvWebapp");
		}
	};
	xhrObj.send();
};

/**
 * Check if the variable is an array of non-negative numbers. 
 * It will have to be an array with at least one element, and all elements in it should be non-negative numbers. 
 * @param {Array} numList An array of numbers
 * @return {boolean} flag which indicates if numList is an array of non-negative numbers
 */
AbstractViewerHandler.prototype.validateEventIdArray = function(numList) {
	//check if numList is an array with element(s) in it
	var isNonEmptyArray = ( numList instanceof Array && numList.length);

	//return false if it's not an Array, or it's empty
	if (!isNonEmptyArray) {
		return false;
	}

	//check each element and verify they're >=0
	for (var x = numList.length; x--; ) {
		if (typeof numList[x] !== "number" || numList[x] < 0) {
			return false;
		}
	}

	//it passed all tests, return true
	return true;
};
/**
 * @class
 * This DocumentViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display documents.
 * Launching Millennium viewer requires fields:
 *   - Patient ID
 *   - Event ID Array (with one or multiple Event IDs)
 * Launching Web viewer requires fields:
 *   - Patient ID
 *   - Event ID Array (with one or multiple Event IDs)
 *   - Document Viewer Type
 *   - Image URL
 *   - Provider ID
 */
var DocumentViewerHandler = function() {
	this.m_documentViewerTabsIndex = {
		DOCUMENTS : 0,
		IMAGES : 1
	};
	this.m_currentPage = this.m_documentViewerTabsIndex.DOCUMENTS;
	this.m_docContentHTML = [];
	this.m_patName = "";
	this.m_patMRN = "";
	this.m_patDOB = "";
	this.m_resultType = "";
	this.m_resultDate = "";
	this.m_resultTitle = "";
	this.m_performedBy = "";
	this.m_resultStatus = "";
	this.m_verifiedBy = "";
	this.m_encounterInfo = "";
	this.m_providerName = "";

	this.m_recordData = "";
	this.m_patEncounterDetails = null;
	this.m_verifyCd = 0;
	this.m_performCd = 0;
	this.m_alteredCd = 0;
	this.m_modifiedCd = 0;
	this.m_unauthCd = 0;
	this.m_authCd = 0;
};

DocumentViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
DocumentViewerHandler.prototype.validateRequiredFields = function() {
	var patientId = this.getPatientId();
	var eventIdArray = this.getEventIds();
	var docViewerType = this.getViewerType();
	var imageUrl = this.getImageUrl();
	var providerId = this.getProviderId();

	//it has to be a non-negative number
	if ( typeof patientId !== "number" || patientId < 0) {
		throw new Error("DocumentViewerHandler requires patientId to launch the viewer");
	}

	//should have at least one event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("DocumentViewerHandler requires at least one event ID to launch the viewer");
	}

	//Validate web viewer related fields
	if (!this.m_millenniumInd) {
		//it should be a string
		if ( typeof docViewerType !== "string") {
			throw new Error("DocumentViewerHandler requires docViewerType to launch the viewer");
		}

		//it should be a string
		if ( typeof imageUrl !== "string") {
			throw new Error("DocumentViewerHandler requires imageUrl to launch the viewer");
		}

		//it has to be a non-negative number
		if ( typeof providerId !== "number" || providerId < 0) {
			throw new Error("DocumentViewerHandler requires pvodiderId to launch the viewer");
		}
	}
};

/**
 * It launches web modal dialog viewer in non-Millennium platform to display the document
 */
DocumentViewerHandler.prototype.launchWebViewer = function() {
	var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;

	//TODO rename all css classes
	var patientId = this.getPatientId();
	var docViewerType = this.getViewerType();
	var imageUrl = this.getImageUrl();
	var providerId = this.getProviderId();
	var imageInd = this.getImageInd();

	var eventIdArray = this.getEventIds();
	var eventIdStr = MP_Util.CreateParamArray(eventIdArray, 1);
	var self = this;

	patientId = patientId + ".0";
	providerId = providerId + ".0";

	var docModalDialog = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
	if (!docModalDialog) {
		docModalDialog = new ModalDialog("docModalDialog");
		docModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
		docModalDialog.setHeaderTitle("<span class='mrv-doc-window-title'>" + docViewerModalI18n.DOCUMENT_VIEWER + "</span>");
		MP_ModalDialog.addModalDialogObject(docModalDialog);
	}
	docModalDialog.setBodyDataFunction(function(docViewDlg) {
		docModalDialog.setBodyHTML("<div class='mrv-doc-body-loading'><span class='mrv-doc-loading'></span></div>");
		var cclParams = [];
		cclParams.push("^MINE^", eventIdStr, patientId, providerId, "^" + docViewerType + "^");
		
		self.loadWithCBParameters("mp_get_doc_viewer_data", cclParams, function(replyObj) {
			self.renderDocViewer(replyObj);
		});
	});
	MP_ModalDialog.updateModalDialogObject(docModalDialog);
	MP_ModalDialog.showModalDialog(docModalDialog.getId());

	$("#docModalDialogbody").css({
		"overflow" : "hidden",
		"height" : "100%"
	});
	$("#vwpModalDialogdocModalDialog").css({
		"height" : "100%",
		"position" : "absolute"
	});
};

/**
 * It launches Millennium viewer in Millennium platform to display the document.
 */
DocumentViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var patientId = this.getPatientId();
		var encounterId = this.getEncounterId();
		var eventIdArray = this.getEventIds();
		var imageUrl = this.getImageUrl();
		var imageInd = this.getImageInd();

		var editModeInd = this.getEditModeInd();
		var editorType = this.getEditorType();

		if(imageInd){
			//launch the image viewer
			MPAGES_SVC_EVENT(imageUrl,"MINE,$PAT_PersonId$");
		}else if(editModeInd && (editorType==="POWERNOTE" || editorType === "CLINNOTES"  || editorType === "DYNDOC"  || editorType === "UNDEFINED")){
			//Enter the edit mode if editModeInd flag is true. Supported types include: Powernote, clinical notes, DynDoc and undefined types. 
			//If the flag is false, or the results are not supported in edit mode, it will use the normal readonly mode. 
			logger.logDiscernInfo(null, "DYNDOC", "document-viewer-handler.js", "launchMillenniumViewer");
			//Use the first event id of the array to launch the viewer because DYNDOC API only receives one event ID for launching the viewer. 
			var eventId = eventIdArray[0];
			CERN_Platform.getDiscernObject("DYNDOC").ModifyExistingDocumentByEventId(patientId, encounterId, eventId);
		}else{
			//launch Millennium viewer
			var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
			logger.logDiscernInfo(null, "PVVIEWERMPAGE", "document-viewer-handler.js", "launchMillenniumViewer");
			viewerObj.CreateDocViewer(patientId);

			for (var x = eventIdArray.length; x--; ) {
				viewerObj.AppendDocEvent(eventIdArray[x]);
			}
			viewerObj.LaunchDocViewer();
		}
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "DocumentViewerHandler.launchMillenniumViewer");
	}
};

/**
 * Helper functions
 */

/**
 * It renders the content for the viewer when data requisition finishes.
 * @param {ScriptReply} replyObj ScriptReply object for the data requisition.
 */
DocumentViewerHandler.prototype.renderDocViewer = function(replyObj) {
	try {
		var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;
		var docModalDialogObject = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
		var codesLength = 0;
		var reply = replyObj.getResponse();
		this.m_recordData = reply;

		if (reply && replyObj.getStatus() === "F") {
			logger.logScriptCallError(null, this, "document-viewer-handler.js", "renderDocViewer");
			return;
		}

		var codeArray = MP_Util.LoadCodeListJSON(reply.CODES);
		var replyRBList = reply.RB_LIST[0];
		this.m_patEncounterDetails = reply.PAT_ENCNTR_DETAILS;

		//Establish code_values for action_type_cd and result_status_cd
		codesLength = codeArray.length;
		for (var cdIndex = 0; cdIndex < codesLength; cdIndex++) {
			if (codeArray[cdIndex].value.codeSet === 21) {
				if (codeArray[cdIndex].value.meaning === "VERIFY") {
					this.m_verifyCd = codeArray[cdIndex].value.codeValue;
				} else if (codeArray[cdIndex].value.meaning === "PERFORM") {
					this.m_performCd = codeArray[cdIndex].value.codeValue;
				}
			} else if (codeArray[cdIndex].value.codeSet === 8) {
				if (codeArray[cdIndex].value.meaning === "ALTERED") {
					this.m_alteredCd = codeArray[cdIndex].value.codeValue;
				} else if (codeArray[cdIndex].value.meaning === "MODIFIED") {
					this.m_modifiedCd = codeArray[cdIndex].value.codeValue;
				} else if (codeArray[cdIndex].value.meaning === "UNAUTH") {
					this.m_unauthCd = codeArray[cdIndex].value.codeValue;
				} else if (codeArray[cdIndex].value.meaning === "AUTH") {
					this.m_authCd = codeArray[cdIndex].value.codeValue;
				}
			}
		}

		this.buildDocHeaderInformation(replyRBList);
		this.buildDocBodyInformation(replyRBList);

		var imageInd = this.getImageInd();
		if (imageInd) {
			this.m_currentPage = this.m_documentViewerTabsIndex.IMAGES;
		} else {
			this.m_currentPage = this.m_documentViewerTabsIndex.DOCUMENTS;
		}
		docModalDialogObject.setBodyHTML(this.generateTabHtml());
		$("#docModalDialogheader").css({
			"border" : "0px"
		});
		$("#docModalDialogbody").css({
			"border-bottom" : "1px solid #ABADB3",
			"border-left" : "1px solid #ABADB3",
			"border-right" : "1px solid #ABADB3"
		});
		if (imageInd) {
			this.switchImagesTabContent();
		}
		this.attachListeners();
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "renderDocumentViewer");
	}
};

/**
 * This function processes meta data of the document when data requisition finshies.
 * Information is stored in the object's member variables, which other functions can use to create document details HTML contents.
 * @param {Object} replyRBList JSon Reply's result block list
 */
DocumentViewerHandler.prototype.buildDocHeaderInformation = function(replyRBList) {
	try {
		var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;
		var actionListLength = replyRBList.EVENT_PRSNL_LIST.length;
		var actionListItem = null;
		var performedDate = null;
		var verifiedDate = null;
		var dateTime = new Date();
		var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
		var patEncounterDetails = this.m_patEncounterDetails;
		var emptyData = "--";

		this.m_patName = (patEncounterDetails.NAME_FULL_FORMATTED) ? patEncounterDetails.NAME_FULL_FORMATTED : "";
		this.m_patMRN = (patEncounterDetails.PAT_ALIAS) ? patEncounterDetails.PAT_ALIAS : emptyData;
		this.m_patDOB = (patEncounterDetails.BIRTH_DT_TM) ? df.formatISO8601(patEncounterDetails.BIRTH_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR) : emptyData;
		this.m_resultType = (patEncounterDetails.RESULT_TYPE) ? patEncounterDetails.RESULT_TYPE : emptyData;
		this.m_resultDate = (patEncounterDetails.RESULT_DATE) ? df.formatISO8601(patEncounterDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;
		this.m_resultTitle = (patEncounterDetails.RESULT_TITLE) ? patEncounterDetails.RESULT_TITLE : emptyData;

		for (var alIndex = 0; alIndex < actionListLength; alIndex++) {
			actionListItem = replyRBList.EVENT_PRSNL_LIST[alIndex];
			if (actionListItem.ACTION_TYPE_CD === this.m_performCd) {
				performedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			}
			if (actionListItem.ACTION_TYPE_CD === this.m_verifyCd) {
				verifiedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			}
		}

		if (patEncounterDetails.PERFORMED_PRSNLID > 0) {
			this.m_performedBy = patEncounterDetails.PERFORMED_FULL;
			if (performedDate) {
				this.m_performedBy = this.m_performedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + performedDate;
			}
		} else {
			this.m_performedBy = emptyData;
		}
		this.m_resultStatus = (patEncounterDetails.RESULT_STATUS) ? patEncounterDetails.RESULT_STATUS : emptyData;
		if (patEncounterDetails.VERIFIED_PRSNLID > 0) {
			this.m_verifiedBy = patEncounterDetails.VERIFIED_FULL;
			if (verifiedDate) {
				this.m_verifiedBy = this.m_verifiedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + verifiedDate;
			}
		} else {
			this.m_verifiedBy = emptyData;
		}

		//They're used to calculate encounterInfo
		var encntrFin = (patEncounterDetails.ENCNTR_ALIAS) ? patEncounterDetails.ENCNTR_ALIAS : "";
		var encntrFacility = (patEncounterDetails.FACILITY_DISP) ? patEncounterDetails.FACILITY_DISP : "";
		var encntrType = (patEncounterDetails.ENCNTR_TYPE) ? patEncounterDetails.ENCNTR_TYPE : "";
		var encntrAdmitDate = "";
		var encntrDischargeDate = "";

		//Get the admit year (4-digit)
		var admitYear = patEncounterDetails.REG_DT_TM.substr(6, 4);
		if (admitYear > 0) {
		    encntrAdmitDate = df.formatISO8601(patEncounterDetails.REG_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		} else {
			encntrAdmitDate = "";
		}

		//Get the discharge year (4-digit)
		var dischargeYear = patEncounterDetails.DISCH_DT_TM.substr(6, 4);
		if (dischargeYear > 0) {
			encntrDischargeDate = df.formatISO8601(patEncounterDetails.DISCH_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		} else {
			encntrDischargeDate = "";
		}
		if (patEncounterDetails.REG_DATE && patEncounterDetails.DISCH_DATE === "") {
			encntrDischargeDate = "-";
		}
		if (patEncounterDetails.DISCH_DATE === "" && patEncounterDetails.REG_DATE === "") {
			encntrDischargeDate = "";
		}
		if (patEncounterDetails.DISCH_DATE && patEncounterDetails.REG_DATE === "") {
			encntrDischargeDate = "";
		}
		if (encntrFin === "" && encntrFacility === "" && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "") {
			this.m_encounterInfo = emptyData;
		} else if (encntrFin && encntrFacility && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "") {
			this.m_encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType;
		} else {
			this.m_encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType + ", " + encntrAdmitDate + ", " + encntrDischargeDate;
		}
		this.m_providerName = patEncounterDetails.PROVIDER_NAME ? patEncounterDetails.PROVIDER_NAME : "";
	} catch(e) {
		logger.logScriptCallError(null, this, "document-viewer-handler.js", "buildHeaderInformation");
	}
};

/**
 * This function processes document content data when data requisition finshies. Then it creates HTML content
 * that will display in the modal dialog. The HTML content is stored in the object's member variable to be used later.
 * @param {Object} replyRBList JSon Reply's result block list
 */
DocumentViewerHandler.prototype.buildDocBodyInformation = function(replyRBList) {
	try {
		var reply = this.m_recordData;
		var docContentLength = replyRBList.CHILD_EVENT_LIST.length;
		var docNoteBlobListLength = reply.NOTE_BLOB.length;
		var docBlobContentLength = reply.BLOBS.length;
		var docEventNoteListLength = replyRBList.EVENT_NOTE_LIST.length;
		var childBlobResultLength = 0;
		var childSubListLength = 0;
		var docBlobText = "";
		var docEventText = "";
		var docEventNoteText = "";
		var signLine = "";
		var docReasonForExamText = "";
		var reasonForExam = "";
		var notelistFlag = false;
		var modifiedFlag = false;
		var docModifiedBlobText = "";
		var docModifiedContent = [];
		var docUnmodifiedContent = [];
		var docEventContent = [];
		var docBlobContentHTML = [];
		var docReasonForExam = [];
		var contentFlag = false;
		var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

		if (replyRBList.RESULT_STATUS_CD === this.m_authCd) {
			if (docBlobContentLength > 0 && docContentLength <= 1) {
				contentFlag = true;
				for (var bc = 0;bc < docBlobContentLength;bc++) {
					docBlobContentHTML.push(reply.BLOBS[bc].BLOB_HTML);						 
					if (docNoteBlobListLength) {
						notelistFlag = true;
						docEventNoteText = reply.NOTE_BLOB[0].NOTE_BLOB_HTML;
						if (replyRBList.CHILD_EVENT_LIST[bc] && replyRBList.CHILD_EVENT_LIST[bc].EVENT_NOTE_LIST.length > 0) {
							signLine = replyRBList.CHILD_EVENT_LIST[bc].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
						}
					}							
				}
				if (docEventNoteListLength) {
					for (var nt = 0; nt < docEventNoteListLength; nt++) {
						if (replyRBList.EVENT_NOTE_LIST[nt].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
							notelistFlag = true;
							docReasonForExamText = replyRBList.EVENT_NOTE_LIST[nt].LONG_BLOB_TXT;
							reasonForExam = replyRBList.EVENT_NOTE_LIST[nt].NOTE_TYPE_CD_DISP;
						}
						else if (replyRBList.EVENT_NOTE_LIST[nt].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[nt].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[nt].NOTE_TYPE_CD_DISP;
						}
					}
				}
				if(docReasonForExamText) {
					docReasonForExam.push("<br><span class='mrv-doc-event-title'>" + reasonForExam + "</span><br><span>" + docReasonForExamText + "</span><br>");
				}
				if(docEventNoteText) {
					docBlobContentHTML.push("<br><span class='mrv-doc-event-title'> " + signLine + "</span><br><span>" + docEventNoteText + "</span>");
				}
			}
			if (docBlobContentLength > 0 && contentFlag === false) {
				for (var dc = 0;dc < docBlobContentLength;dc++) {
					docBlobContentHTML.push(reply.BLOBS[dc].BLOB_HTML);
					if (docNoteBlobListLength) {
						notelistFlag = true;
						docEventNoteText = reply.NOTE_BLOB[0].NOTE_BLOB_HTML;
						if (replyRBList.CHILD_EVENT_LIST[dc] && replyRBList.CHILD_EVENT_LIST[dc].EVENT_NOTE_LIST.length > 0) {
							signLine = replyRBList.CHILD_EVENT_LIST[dc].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
						}
					}
				}
				if (docEventNoteListLength) {
					for (var nb = 0;nb < docEventNoteListLength;nb++) {
						if (replyRBList.EVENT_NOTE_LIST[nb].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
							notelistFlag = true;
							docReasonForExamText = replyRBList.EVENT_NOTE_LIST[nb].LONG_BLOB_TXT;
							reasonForExam = replyRBList.EVENT_NOTE_LIST[nb].NOTE_TYPE_CD_DISP;
						}
						else if (replyRBList.EVENT_NOTE_LIST[nb].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[nb].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[nb].NOTE_TYPE_CD_DISP;
						}
					}
				}
				if(docReasonForExamText){
					docReasonForExam.push("<br><span class='mrv-doc-event-title'>" + reasonForExam + "</span><br><span>" + docReasonForExamText + "</span><br>");
				}						
				if (docBlobContentHTML.length > 0 && docEventNoteText!=="") {
					docBlobContentHTML.push("<br><span class='mrv-doc-event-title'>" + signLine + "</span><br><span>" + docEventNoteText + "</span>");
				}
			}
		} else if ((replyRBList.RESULT_STATUS_CD === this.m_modifiedCd) || (replyRBList.RESULT_STATUS_CD === this.m_unauthCd)) {
			if (docContentLength > 1 && replyRBList.BLOB_RESULT.length < 1) {
				for (var d = 0; d < docContentLength; d++) {
					docEventText = "";
					docBlobText = "";
					docEventNoteText = "";
					signLine = "";
					//Check size of blob_result
					childBlobResultLength = replyRBList.CHILD_EVENT_LIST[d].BLOB_RESULT.length;
					if (childBlobResultLength > 0 && replyRBList.CHILD_EVENT_LIST[d].BLOB_RESULT[0].BLOB.length > 0) {
						docBlobText = replyRBList.CHILD_EVENT_LIST[d].BLOB_RESULT[0].BLOB[0].BLOB_TEXT;
						docEventText = replyRBList.CHILD_EVENT_LIST[d].EVENT_TITLE_TEXT;
					} else {
						//Length of sub-CHILD_EVENT_LIST records
						childSubListLength = replyRBList.CHILD_EVENT_LIST[d].CHILD_EVENT_LIST.length;
						if (childSubListLength > 0) {
							for (var x = 0;	x < childSubListLength;x++) {
								childBlobResultLength = replyRBList.CHILD_EVENT_LIST[d].CHILD_EVENT_LIST[x].BLOB_RESULT.length;
								if (childBlobResultLength > 0) {
									if (replyRBList.CHILD_EVENT_LIST[d].CHILD_EVENT_LIST[x].BLOB_RESULT[0].BLOB.length > 0) {
										docBlobText = replyRBList.CHILD_EVENT_LIST[d].CHILD_EVENT_LIST[x].BLOB_RESULT[0].BLOB[0].BLOB_TEXT;
										docEventText = replyRBList.CHILD_EVENT_LIST[d].CHILD_EVENT_LIST[x].EVENT_TITLE_TEXT;
										docModifiedContent.push("<br><br><span class='mrv-doc-event-title'> " + docEventText + " </span><br><span class='mrv-doc-blob-text'> " + docBlobText + " </span>");
									}
								}
							}
						}
					}
					if (docNoteBlobListLength) {
						if (replyRBList.CHILD_EVENT_LIST[d] && replyRBList.CHILD_EVENT_LIST[d].EVENT_NOTE_LIST.length > 0) {
							if (reply.NOTE_BLOB[d]) {
								notelistFlag = true;
								docEventNoteText = reply.NOTE_BLOB[d].NOTE_BLOB_HTML;
								signLine = replyRBList.CHILD_EVENT_LIST[d].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
							}
						}
					}
					if (notelistFlag === true) {
						docModifiedContent.push("<br><br><span class='mrv-doc-event-title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
						notelistFlag = false;
					}
				}
			} else if(docContentLength) {
					for (var cb = 0;  cb < replyRBList.CHILD_EVENT_LIST.length; cb++) {																	
						childSubListLength = replyRBList.CHILD_EVENT_LIST[cb].CHILD_EVENT_LIST.length;
						if (childSubListLength > 0) {
							for (var x = 0;	x < childSubListLength;x++) {
								childBlobResultLength = replyRBList.CHILD_EVENT_LIST[cb].CHILD_EVENT_LIST[x].BLOB_RESULT.length;
								if (childBlobResultLength > 0) {
									if (replyRBList.CHILD_EVENT_LIST[cb].CHILD_EVENT_LIST[x].BLOB_RESULT[0].BLOB.length > 0) {										
										contentFlag = true;
										docEventText = replyRBList.CHILD_EVENT_LIST[cb].CHILD_EVENT_LIST[x].EVENT_TITLE_TEXT;																			
										docBlobContentHTML.push("<br><span class='mrv-doc-event-title'> " + docEventText + " </span><br><span class='mrv-doc-blob-text'> " + reply.BLOBS[x].BLOB_HTML + " </span>");
									} else if (docBlobContentLength) {
										contentFlag = true;
										for(var bc = 0; bc < docBlobContentLength; bc++) {
											docBlobContentHTML.push(reply.BLOBS[bc].BLOB_HTML);
										}
									}
								} 
								if (docNoteBlobListLength) {
									if (replyRBList.CHILD_EVENT_LIST[cb].EVENT_NOTE_LIST.length > 0) {
										notelistFlag = true;
										docEventNoteText = reply.NOTE_BLOB[0].NOTE_BLOB_HTML;
										signLine = replyRBList.CHILD_EVENT_LIST[cb].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
									}
								}
							}
						} 							
					}
				if (docBlobContentLength && contentFlag === false) {
					for(var bc = 0; bc < docBlobContentLength; bc++) {
						docBlobContentHTML.push(reply.BLOBS[bc].BLOB_HTML);
					}
				}

				if (docEventNoteListLength) {
					for (var nl = 0;nl < docEventNoteListLength;nl++) {
						if (replyRBList.EVENT_NOTE_LIST[nl].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
							notelistFlag = true;
							docReasonForExamText = replyRBList.EVENT_NOTE_LIST[nl].LONG_BLOB_TXT;
							reasonForExam = replyRBList.EVENT_NOTE_LIST[nl].NOTE_TYPE_CD_DISP;
						}
						else if (replyRBList.EVENT_NOTE_LIST[nl].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[nl].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[nl].NOTE_TYPE_CD_DISP;
							}
						}
				}
				if(docReasonForExamText){
					docReasonForExam.push("<br><span class='mrv-doc-event-title'> " + reasonForExam + " </span><br><span>" + docReasonForExamText + "</span>");
				}
				if(docEventNoteText){
					docBlobContentHTML.push("<br><span class='mrv-doc-event-title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
				}
			}
		} else if (replyRBList.RESULT_STATUS_CD === this.m_alteredCd) {
			for (var p = 0;	p < docBlobContentLength;p++) {
				docBlobContentHTML.push(reply.BLOBS[p].BLOB_HTML);
				if (docNoteBlobListLength) {
					if (replyRBList.CHILD_EVENT_LIST[p] && replyRBList.CHILD_EVENT_LIST[p].EVENT_NOTE_LIST.length > 0) {
						notelistFlag = true;
						docEventNoteText = reply.NOTE_BLOB[0].NOTE_BLOB_HTML;
						signLine = replyRBList.CHILD_EVENT_LIST[p].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
					}
				}
			}
			if (docEventNoteListLength) {
				for (var n = 0;	n < docEventNoteListLength;n++) {
					if (replyRBList.EVENT_NOTE_LIST[n].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
						notelistFlag = true;
						docReasonForExamText = replyRBList.EVENT_NOTE_LIST[n].LONG_BLOB_TXT;
						reasonForExam = replyRBList.EVENT_NOTE_LIST[n].NOTE_TYPE_CD_DISP;
					}
					else if (replyRBList.EVENT_NOTE_LIST[n].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[n].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[n].NOTE_TYPE_CD_DISP;
							}
						}
					}
			if(docReasonForExamText) {
				docReasonForExam.push("<br><span class='mrv-doc-event-title'> " + reasonForExam + " </span><br><span>" + docReasonForExamText + "</span><br>");
			}
			if(docEventNoteText) {
				docBlobContentHTML.push("<br><span class='mrv-doc-event-title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
			}
		} else if (docContentLength) {
				for (var c = 0; c < docContentLength; c++) {
					docBlobText = "";
					signLine = "";
					docEventNoteText = "";
					//Length of sub-CHILD_EVENT_LIST records
					childSubListLength = replyRBList.CHILD_EVENT_LIST[c].CHILD_EVENT_LIST.length;
					if (childSubListLength) {
						for (var x = 0;	x < childSubListLength; x++) {
							docEventText = replyRBList.CHILD_EVENT_LIST[c].CHILD_EVENT_LIST[x].EVENT_TITLE_TEXT;						
						}
					}
					if(docEventText) {
						docBlobContentHTML.push("<br><span class='mrv-doc-event-title'> " + docEventText + " </span><br><span>" + reply.BLOBS[c].BLOB_HTML + "</span>");
					}
						
					if (docNoteBlobListLength) {
						if (replyRBList.CHILD_EVENT_LIST[c] && replyRBList.CHILD_EVENT_LIST[c].EVENT_NOTE_LIST.length > 0) {
							if (replyRBList.CHILD_EVENT_LIST[c].EVENT_NOTE_LIST[0].LONG_BLOB_TXT) {
								notelistFlag = true;
								docEventNoteText = reply.NOTE_BLOB[0].NOTE_BLOB_HTML;
								signLine = replyRBList.CHILD_EVENT_LIST[c].EVENT_NOTE_LIST[0].NOTE_TYPE_CD_DISP;
							}
						}
					} 
				}
				if (docEventNoteListLength) {
					for (var en = 0;en < docEventNoteListLength;en++) {
						if (replyRBList.EVENT_NOTE_LIST[en].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
							notelistFlag = true;
							docReasonForExamText = replyRBList.EVENT_NOTE_LIST[en].LONG_BLOB_TXT;
							reasonForExam = replyRBList.EVENT_NOTE_LIST[en].NOTE_TYPE_CD_DISP;
						}
						else if (replyRBList.EVENT_NOTE_LIST[en].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[en].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[en].NOTE_TYPE_CD_DISP;
							}
					}
				}									
				docUnmodifiedContent.push("<br><br><span class='mrv-doc-blob-text'> " + docBlobText + " </span>");
					
				if (notelistFlag) {
					if(docEventNoteText) {
						docUnmodifiedContent.push("<br><br><span class='mrv-doc-event-title'>" + signLine + "</span><br><span>" +
						docEventNoteText + "</span>");
					}
					if(docReasonForExamText){
						docReasonForExam.push("<br><span class='mrv-doc-event-title'>" + reasonForExam + "</span><br><span>" +docReasonForExamText + "</span><br>");
					}						
				}
			} else {
					for (var eventNoteIndex = 0;eventNoteIndex < docEventNoteListLength;eventNoteIndex++) {
						if (replyRBList.EVENT_NOTE_LIST[eventNoteIndex].NOTE_TYPE_CD_MEAN === "REASONFOREXM") {
							notelistFlag = true;
							docReasonForExamText = replyRBList.EVENT_NOTE_LIST[eventNoteIndex].LONG_BLOB_TXT;
							reasonForExam = replyRBList.EVENT_NOTE_LIST[eventNoteIndex].NOTE_TYPE_CD_DISP;
						}
						else if (replyRBList.EVENT_NOTE_LIST[eventNoteIndex].LONG_BLOB_TXT) {
							notelistFlag = true;
							docEventNoteText = replyRBList.EVENT_NOTE_LIST[eventNoteIndex].LONG_BLOB_TXT;
							signLine = replyRBList.EVENT_NOTE_LIST[eventNoteIndex].NOTE_TYPE_CD_DISP;
						}
					}
					if (notelistFlag) {
						if(docEventNoteText){
							docUnmodifiedContent.push("<br><span class='mrv-doc-event-title'>" + signLine + "</span><br><span>" + docEventNoteText + "</span>");
						}
						if(docReasonForExamText){
							docReasonForExam.push("<br><span class='mrv-doc-event-title'>" + reasonForExam + "</span><br><span>" +docReasonForExamText + "</span><br>");									
						}
					}
				}
		
		if (docModifiedContent.length) {
			docEventContent.push(docModifiedContent.join(""));
		}
		if (docUnmodifiedContent.length) {
			docEventContent.push(docUnmodifiedContent.join(""));
		}
		this.m_docContentHTML = [];
		if (docReasonForExam.length) {
			this.m_docContentHTML.push(docReasonForExam.join(""));
		} 
		if (docBlobContentHTML.length) {
			this.m_docContentHTML.push(docBlobContentHTML.join(""));
		} else if (docEventContent.length) {
			this.m_docContentHTML.push(docEventContent.join(""));
		}
	} catch(e) {
		logger.logScriptCallError(null, this, "document-viewer-handler.js", "buildDocBodyInformation");
	}
};

/**
 * It attach event listeners to DOM to enable user interactions
 */
DocumentViewerHandler.prototype.attachListeners = function() {
	var self = this;
	var allTabs = "#tabContainer .mrv-tabs ul li";
	$(allTabs).eq(this.m_currentPage).addClass("mrv-tab-active-header");
	$(allTabs).on("click", function() {
		var $activeTab = $(this.parentElement).find(".mrv-tab-active-header");
		var activeTabId = $activeTab.attr("id");
		var curTabId = this.id;
		$activeTab.removeClass("mrv-tab-active-header");
		$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
		$(this).addClass("mrv-tab-active-header");
		$("#curTabId").show();
		if (curTabId === "tabHeader_0") {
			self.switchDocumentsTabContent();
		} else if (curTabId === "tabHeader_1") {
			self.switchImagesTabContent();
		}
	});

	var viewerId = this.m_uniqueId;
	$('#docViewerDetailsLink' + viewerId).on("click", function() {
		self.ShowDetailsLink();
	});

	$('#docViewerPrintIcon' + viewerId).on("click", function() {
		self.PrintDocument();
	});
};

/**
 * Generate HTML for current tab
 * @return {string} HTML string of the tab
 */
DocumentViewerHandler.prototype.generateTabHtml = function() {
	try {
		var imageUrl = this.getImageUrl();
		var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;
		var viewerId = this.m_uniqueId;
		var docSwitchHTML = [];
		var showDetails = docViewerModalI18n.SHOW_DETAILS;
		var windowSize = $(window).width();
		docSwitchHTML.push("<div class='mrv-doc-header'><div class='mrv-doc-type-date'><dl class='mrv-doc-note-type'><dt class='mrv-doc-res-type'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='mrv-doc-res-value'>" + this.m_resultType + "</dd></dl><dl class='mrv-doc-note-type'><dt class='mrv-doc-res-date'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='mrv-doc-res-value'>" + this.m_resultDate + "</dd></dl></div><div class='mrv-doc-showdetails-link'><a id='docViewerDetailsLink" + viewerId + "' href='#'>" + showDetails + "</a></div><div class='mrv-doc-separator'><dl class='mrv-doc-note-type'><span>&nbsp;</span></dl></div><div class='mrv-doc-print' id='printId'><dl class='mrv-doc-note-type'><span id='docViewerPrintIcon" + viewerId + "' class='mrv-doc-print-icon'>&nbsp;</span></dl></div><div class='mrv-doc-hdr-details'><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='mrv-doc-res-value'>" + this.m_resultTitle + "</dd></dl><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='mrv-doc-res-value'>" + this.m_performedBy + "</dd></dl><br><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='mrv-doc-res-value'>" + this.m_resultStatus + "</dd></dl><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='mrv-doc-res-value'>" + this.m_verifiedBy + "</dd></dl><br><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'></dt><dd class='mrv-doc-res-value'></dd></dl><dl class='mrv-doc-note-type'><dt class='mrv-doc-name'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='mrv-doc-res-value'>" + this.m_encounterInfo + "</dd></dl></div></div>");
		docSwitchHTML.push('<div class="mrv-doc-main-container" id="tabContainer">');
		var numTabs;
		var tabNames = [];
		if (imageUrl) {
			docSwitchHTML.push('<div class="mrv-tabs"><ul>');
			tabNames = [docViewerModalI18n.DOCUMENTS, docViewerModalI18n.IMAGES];
			numTabs = tabNames.length;
		} else {
			numTabs = 0;
		}
		for (var i = 0; i < numTabs; i++) {
			docSwitchHTML.push('<li id="tabHeader_', i, '"><span class="mrv-tab-left-edge">&nbsp;</span><span class="mrv-tab-text">', tabNames[i], '</span><span class="mrv-tab-right-edge">&nbsp;</span></li>');
		}
		if (imageUrl) {
			if (windowSize > 1024) {
				docSwitchHTML.push('</ul></div><hr/><div class="mrv-doc-tabs-content-high-resolution" id="tabContent">');
			} else if (windowSize > 768 && windowSize <= 1024) {
				docSwitchHTML.push('</ul></div><hr/><div class="mrv-doc-tabs-content-low-resolution" id="tabContent">');
			}
			docSwitchHTML.push("</br></br>", this.m_docContentHTML.join(""), "</div><iframe id='image-section' class='mrv-doc-document-tab' src='" + imageUrl + "' width='100%'></iframe>");
			docSwitchHTML.push("</div>");
			this.initMediaViewer();
		} else {
			if (windowSize > 1024) {
				docSwitchHTML.push('<div class="mrv-doc-notabs-content-high-resolution" id="noTabContent"></br>', this.m_docContentHTML.join(""), "</div></div>");
			} else if (windowSize > 768 && windowSize <= 1024) {
				docSwitchHTML.push('<div class="mrv-doc-notabs-content-low-resolution" id="noTabContent"></br>', this.m_docContentHTML.join(""), "</div></div>");
			}
		}
		return docSwitchHTML.join("");
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "generateTabHtml");
	}
};

/**
 * Reconstruct the document content in a printable layout and print it out from the browser
 */
DocumentViewerHandler.prototype.PrintDocument = function() {
	var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;
	var iframeObj = "";
	try {
		var htmlText = [];
		var $style = $("<style type='text/css'>.mrv-doc-print-label{display:inline;width:20%;}.mrv-doc-print-bold{font-weight:bold;}.mrv-doc-print-value {margin-right:10px;margin-left:4px;display:-moz-inline-stack;vertical-align:top;display:inline-block;zoom:1;*display:inline;}</style>");
		htmlText.push("<div id='printDiv'>");
		htmlText.push("<dl><dd class='mrv-doc-print-value mrv-doc-print-bold'>" + this.m_patName + "</dd>");
		htmlText.push("<dd class='mrv-doc-print-value'>" + docViewerModalI18n.MRN + "</dd>");
		htmlText.push("<dd class='mrv-doc-print-value'>" + this.m_patMRN + "</dd>");
		htmlText.push("<dd class='mrv-doc-print-value'>" + docViewerModalI18n.DOB + "</dd>");
		htmlText.push("<dd class='mrv-doc-print-value'>" + this.m_patDOB + "</dd></dl>");
		htmlText.push("<dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='mrv-doc-print-value'>" + this.m_resultType + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='mrv-doc-print-value'>" + this.m_resultDate + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='mrv-doc-print-value'>" + this.m_resultStatus + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='mrv-doc-print-value'>" + this.m_resultTitle + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='mrv-doc-print-value'>" + this.m_performedBy + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='mrv-doc-print-value'>" + this.m_verifiedBy + "</dd></dl><dl><dt class='mrv-doc-print-label'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='mrv-doc-print-value'>" + this.m_encounterInfo + "</dd></dl></div></br></br>");
		htmlText.push(this.m_docContentHTML.join(""));
		htmlText.push("</br></br></br></br><div><span>" + docViewerModalI18n.PRINTED_BY + "</span><span>&nbsp" + this.m_providerName + "</span></div>");
		iframeObj = document.createElement("iframe");
		$(iframeObj).css("display", "none");
		document.body.appendChild(iframeObj);
		var printWindow = iframeObj.contentWindow;
		var docObject = printWindow ? printWindow.document : null;
		if (docObject) {
			docObject.write(htmlText.join(""));
			docObject.close();
			$(iframeObj).show().contents().find("head").append($style);
			printWindow.focus();
			printWindow.print();
			printWindow.location.reload();
			printWindow.close();
		}
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "PrintDocument");
		throw err;
	} finally {
		if ($(iframeObj).length) {
			$(iframeObj).remove();
		}
	}
};

/**
 * Switch to Document Tab and hide the other tab content
 */
DocumentViewerHandler.prototype.switchDocumentsTabContent = function() {
	try {
		var modaldlg = null;
		modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
		var modaldlgId = modaldlg.getBodyElementId();
		$("#docModalDialogbody").find("#tabContent").show();
		$("#image-section").removeClass("mrv-doc-image-tab");
		$("#image-section").addClass("mrv-doc-document-tab");
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "switchDocumentsTabContent");
	}
};

/**
 * Switch to Images Tab and hide the other tab content
 */
DocumentViewerHandler.prototype.switchImagesTabContent = function() {
	try {
		var modaldlg = null;
		modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
		var modaldlgId = modaldlg.getBodyElementId();
		$("#docModalDialogbody").find("#tabContent").hide();
		$("#image-section").removeClass("mrv-doc-document-tab");
		$("#image-section").addClass("mrv-doc-image-tab");
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "switchImagesTabContent");
	}
};

/**
 * Expand the details panel and display document meta info like title, performed_by, status and etc.
 */
DocumentViewerHandler.prototype.ShowDetailsLink = function() {
	try {
		var docViewerModalI18n = i18n.discernabu.mpage_result_viewer.document_modal;
		var modaldlg = null;
		modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
		var modaldlgId = modaldlg.getBodyElementId();
		var docModalDialogBodyObj = $('#docModalDialogbody');
		var windowSize = $(window).width();
		if (docModalDialogBodyObj.find(".mrv-doc-showdetails-link").children("a").text() === "" + docViewerModalI18n.SHOW_DETAILS + "") {
			docModalDialogBodyObj.find(".mrv-doc-showdetails-link").children("a").text("" + docViewerModalI18n.HIDE_DETAILS + "");
			docModalDialogBodyObj.find(".mrv-doc-header").children("div").removeClass("mrv-doc-hdr-details").addClass("mrv-doc-hdr-show");
			if (windowSize > 1024) {
				$("#tabContent").css("height", "56%");
				$("#noTabContent").css("height", "415px");
			} else if (windowSize > 768 && windowSize <= 1024) {
				$("#tabContent").css("height", "47%");
				$("#noTabContent").css("height", "290px");
			}
		} else {
			docModalDialogBodyObj.find(".mrv-doc-showdetails-link").children("a").text("" + docViewerModalI18n.SHOW_DETAILS + "");
			docModalDialogBodyObj.find(".mrv-doc-header").children("div").removeClass("mrv-doc-hdr-show").addClass("mrv-doc-hdr-details");
			if (windowSize > 1024) {
				$("#tabContent").css("height", "65%");
				$("#noTabContent").css("height", "500px");
			} else if (windowSize > 768 && windowSize <= 1024) {
				$("#tabContent").css("height", "61%");
				$("#noTabContent").css("height", "390px");
			}
		}
	} catch (err) {
		logger.logJSError(err, null, "document-viewer-handler.js", "ShowDetailsLink");
	}
};
/**
 * @class
 * This GroupViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display group results.
 */
var GroupViewerHandler = function() {
	this.m_recordData = null;
	this.m_eventCount = 0;
	this.m_eventIdx = 0;
	this.m_personnelArray = null;
	this.m_dateFormatter = null;
	this.m_commentsFound = false;
	this.m_modalDialogId = null;
	this.m_groupViewerI18n = null;
};

GroupViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
GroupViewerHandler.prototype.validateRequiredFields = function() {
	var eventIdArray = this.getEventIds();
	//should have at least one event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("GroupViewerHandler requires at least one event ID to launch the viewer");
	}
	if ( typeof this.getResultName() !== "string") {
		throw new Error("GroupViewerHandler requires valid resultName to launch the viewer");
	}
};

/**
 * Function GroupViewerHandler.prototype.launchWebViewer launches web modal dialog viewer in non-Millennium platform to display the clinical result.
 * It is yet to be implemented. When it is called, it will use the AbstractViewerHandler's default implementation, which will launch a modal dialog
 * that displays an error message that the result can't be viewed.
 */
GroupViewerHandler.prototype.launchWebViewer = function() {
	this.m_groupViewerI18n = i18n.discernabu.mpage_result_viewer.group_modal;
	var eventIdArray = this.getEventIds();
	this.m_eventCount = eventIdArray.length;
	var eventIdStr = MP_Util.CreateParamArray(eventIdArray, 1);
	this.m_modalDialogId = "groupViewer" + eventIdArray[0];
	var self = this;
	var resultName = this.m_groupViewerI18n.RESULT_DETAILS;
	if(this.getResultName()) {
		resultName = resultName + ": " + this.getResultName();
	}
	var groupViewerModalObj = MP_ModalDialog.retrieveModalDialogObject(self.m_modalDialogId);
	if (!groupViewerModalObj) {
		groupViewerModalObj = new ModalDialog(self.m_modalDialogId);
		var groupViewerCloseBtn = new ModalButton(self.m_modalDialogId + "CloseBtn");
		groupViewerCloseBtn.setText(this.m_groupViewerI18n.CLOSE);
		groupViewerCloseBtn.setFocusInd(true).setOnClickFunction(function() {
			MP_ModalDialog.closeModalDialog(self.m_modalDialogId);
			MP_ModalDialog.deleteModalDialogObject(self.m_modalDialogId);
		});
		groupViewerModalObj.addFooterButton(groupViewerCloseBtn);
		groupViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(25).setBottomMarginPercentage(15).setLeftMarginPercentage(25).setIsBodySizeFixed(false);
		groupViewerModalObj.setHeaderTitle(resultName).setHeaderCloseFunction(function() {
			MP_ModalDialog.closeModalDialog(self.m_modalDialogId);
			MP_ModalDialog.deleteModalDialogObject(self.m_modalDialogId);
		});
		MP_ModalDialog.addModalDialogObject(groupViewerModalObj);
	}
	groupViewerModalObj.setHeaderTitle(resultName);
	groupViewerModalObj.setBodyDataFunction(function(groupViewerObj) {
		self.attachListeners();
		groupViewerModalObj.setBodyHTML("<div class = 'mrv-result-loading'></div>");
		var scriptRequest = new ScriptRequest();
		scriptRequest.setProgramName("mp_get_result_viewer_data");
		/*
		 * Parameters to retrieve group event details
		 * Output to where, Event ID, View level indicator, Publish Flag, Micro Indicator
		 */
		scriptRequest.setParameterArray(["^MINE^", eventIdStr, 1, 1, 0]);
		scriptRequest.setResponseHandler(function(scriptReply) {
			self.renderGroupViewer(scriptReply);
		});
		scriptRequest.performRequest();
	});
	MP_ModalDialog.updateModalDialogObject(groupViewerModalObj);
	MP_ModalDialog.showModalDialog(self.m_modalDialogId);
};

/**
 * It launches Millennium viewer in Millennium platform to display the clinical result.
 */
GroupViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var eventIdArray = this.getEventIds();
		var patientId = this.getPatientId();
		var encounterId = this.getEncounterId();

		var editModeInd = this.getEditModeInd();
		var editorType = this.getEditorType();
		var activityId = this.getActivityId();

		//Enter the edit mode if editModeInd flag is true. Only Powerform results are supported in edit mode. 
		//If the flag is false, or the results are not supported in edit mode, it will use the normal readonly mode. 
		if(editModeInd && editorType==="POWERFORMS"){
			if (activityId){
				//launch the result in powerform if powerform activity id is available
				logger.logDiscernInfo(null, "POWERFORMS", "group-viewer-handler.js", "launchMillenniumViewer");
				CERN_Platform.getDiscernObject("POWERFORM").OpenForm(patientId, encounterId, 0, activityId, 0);
			}else{
				//If activityId is 0, it means the result is not directly associated to a powerform, so it will only log a warning. 
				logger.logWarning("This result cannot be opened in edit mode as it is not directly associated to a Powerform: activityId === 0 (group-viewer-handler.js)");
			}
		}else{
			//launch Millennium viewer
			var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
			logger.logDiscernInfo(null, "PVVIEWERMPAGE", "group-viewer-handler.js", "launchMillenniumViewer");
			viewerObj.CreateGroupViewer();

			for (var x = eventIdArray.length; x--; ) {
				viewerObj.AppendGroupEvent(eventIdArray[x]);
			}
			viewerObj.LaunchGroupViewer();
		}
	} catch (err) {
		logger.logJSError(err, null, "group-viewer-handler.js", "GroupViewerHandler.launchMillenniumViewer");
	}
};

/**
 * It displays an error message in modal dialog window
 * @param {string} message Message
 * @param {string} title of the Modal dialog window
 * @param {string} buttonText Button label
 */
GroupViewerHandler.prototype.handleError = function(message, title, buttonText) {
	var modalObj = MP_Util.generateModalDialogBody("groupViewerFailureAlert", "error", message, "");
	var modalButton = modalObj.getFooterButton("modalOkBtn");
	if (!modalButton) {
		modalButton = new ModalButton("modalOkBtn");
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true).setOnClickFunction(function() {
			MP_ModalDialog.closeModalDialog(this.m_modalDialogId);
		});
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
	}
	modalObj.setHeaderTitle(title);
	modalObj.setFooterButtonText("modalOkBtn", buttonText);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("groupViewerFailureAlert");
};

/**
 * This function create the HTML string for the event details including the tabs and contents of each tab.
 * @param {Object} eventRecordObj JSon Reply's result block list
 * @return {string} HTML content of the detail section
 */
GroupViewerHandler.prototype.buildEventDetailSectionHTML = function(eventRecordObj) {
	var eventDetailHTML = [];
	eventDetailHTML.push("<div class='mrv-group-detail' id='groupViewDetail'><div class='mrv-group-tabs' id='groupViewControls'>");
	eventDetailHTML.push(this.buildTabSectionHTML());
	eventDetailHTML.push("</div><hr class='mrv-group-separator'><div class='mrv-group-result-tab-body ' id='groupViewBody'><div class='mrv-group-body-container' id='groupViewTabBodyId'>");
	eventDetailHTML.push(this.buildDetailsTabHTML(eventRecordObj));
	eventDetailHTML.push(this.buildActionListTabHTML(eventRecordObj));
	if (this.m_commentsFound) {
		eventDetailHTML.push(this.buildCommentsTabHTML(eventRecordObj));
	}
	eventDetailHTML.push("</div></div></div>");
	return eventDetailHTML.join("");
};

/**
 * This function create the HTML string the tab section including details, action list and comments.
 * @return {string} HTML string of the tab section
 */
GroupViewerHandler.prototype.buildTabSectionHTML = function() {
	var self = this;
	var tabHTML = [];
	tabHTML.push("<ul><li id='",self.m_modalDialogId,"Tab1' class='mrv-group-tab-active-header'><span class='mrv-group-tab-left-edge'>&nbsp;</span><span class='mrv-group-tab-text'>", this.m_groupViewerI18n.DETAILS, "</span><span class='mrv-group-tab-right-edge'>&nbsp;</span></li><li id='",self.m_modalDialogId,"Tab2'><span class='mrv-group-tab-left-edge'>&nbsp;</span><span class='mrv-group-tab-text'>", this.m_groupViewerI18n.ACTION_LIST, "</span><span class='mrv-group-tab-right-edge'>&nbsp;</span></li>");
	if(this.m_commentsFound){
		tabHTML.push("<li id='",self.m_modalDialogId,"Tab3'><span class='mrv-group-tab-left-edge'>&nbsp;</span><span class='mrv-group-tab-text'>", this.m_groupViewerI18n.COMMENTS, "</span><span class='mrv-group-tab-right-edge'>&nbsp;</span></li>");
	}
	tabHTML.push("</ul>");
	return tabHTML.join("");
};

/**
 * This function create the HTML string of the common details to be displayed across all tabs.
 * @param {Object} eventRecordObj JSon Reply's result block list
 * @return {string} HTML string of the tab section
 */
GroupViewerHandler.prototype.buildHeaderHTML = function(eventRecordObj) {
	var detailsTabHTML = [];
	var eventDtTm = "";
	eventDtTm = this.m_dateFormatter.formatISO8601(eventRecordObj.EVENT_END_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
	detailsTabHTML.push("<dl class = 'mrv-group-event-info'><dd class = 'mrv-group-event-hd'>", this.m_groupViewerI18n.DATE_TIME, ":</dd><dd class = 'mrv-group-event-data'>", eventDtTm, "</dd></dl><dl class = 'mrv-group-event-info'><dd class = 'mrv-group-event-hd'>", this.m_groupViewerI18n.CONTRIBUTE_SYSTEM, ":</dd><dd class = 'mrv-group-event-data'>", eventRecordObj.CONTRIBUTOR_SYSTEM_CD_DISP, "</dd></dl><dl class = 'mrv-group-event-info'><dd class = 'mrv-group-event-hd'>", this.m_groupViewerI18n.REFERENCE_NUM, ":</dd><dd class = 'mrv-group-event-data'>", eventRecordObj.REFERENCE_NBR, "</dd></dl><dl class = 'mrv-group-event-info'><dd class = 'mrv-group-event-hd'>", this.m_groupViewerI18n.STATUS, ":</dd><dd class = 'mrv-group-event-data'>", eventRecordObj.RESULT_STATUS_CD_DISP, "</dd></dl>");
	return detailsTabHTML.join("");
};

/**
 * This function create the HTML string for the Details tab.
 * @param {Object} eventRecordObj JSon Reply's result block list
 * @return {string} HTML string of Details tab
 */
GroupViewerHandler.prototype.buildDetailsTabHTML = function(eventRecordObj) {
	var detailsTabHTML = [];
	var self = this;
	detailsTabHTML.push("<div class = 'mrv-group-result-details-info' id = '", self.m_modalDialogId, "DetailsInfoId'>",this.buildHeaderHTML(eventRecordObj),"<div class = 'mrv-group-section-container' id = 'GrpSectionContainer'>");
	/*
	 * Populate the details of inner subsection of the details tab.
	 */
	detailsTabHTML.push(this.buildDetailsSubsectionHTML(eventRecordObj.CHILD_EVENT_LIST));
	detailsTabHTML.push("</div></div>");
	return detailsTabHTML.join("");
};

/*
 * This function create the HTML for the contents to be displayed in the
 * Details tab sub-section.
 * @param {Array} Child Event Array of the main event queried
 * @return {string} HTML string of sub-section contents
 */
GroupViewerHandler.prototype.buildDetailsSubsectionHTML = function(childEventArr) {
	var self = this;
	var childEventsHTML = [];
	childEventsHTML.push("<ul class = 'mrv-group-child-event-block'>");
	childEventArr.sort(this.SortByCollatingSeq);
	//generate the sub-section HTML
	$.each(childEventArr, function(key, value) {
		self.createList(value, childEventsHTML);
	});
	childEventsHTML.push("</ul>");
	return childEventsHTML.join('');
};

/*
 * This function creates the HTML for different levels of child events
 * @param {Object} item stores the JSON Object containing details of the child event
 * @param {Array} list stores the content to be displayed for a corresponding child events
 */
GroupViewerHandler.prototype.createList = function(item, list) {
	var self = this;
	var resultVal;
	var resultStatus = null;
	var eventDisplay = null;
	var event_cd_disp = "";
	var eventId = 0.0;
	var listItem;
	//If an child event item exists
	if (item) {
		eventId = item.EVENT_ID;
		resultStatus = MP_Util.GetValueFromArray(item.RESULT_STATUS_CD,MP_Util.LoadCodeListJSON(self.m_recordData.CODES));
		eventDisplay = MP_Util.GetValueFromArray(item.EVENT_CD,MP_Util.LoadCodeListJSON(self.m_recordData.CODES));
		//set the display value for any event to be event_cd_description first
		event_cd_disp = eventDisplay.description;
		/*
		 * Logic for displaying event names is as follows:
		 * If meaning of the event_cd is DCP_GENERIC then display value will be pulled from "event_title_text" field
		 * If the description is empty string then display value will be pulled from "event_cd_disp" field 
		 */
		if(eventDisplay.meaning === "DCPGENERIC") {
			event_cd_disp = item.EVENT_TITLE_TEXT;
		}
		if(event_cd_disp === "") {
			event_cd_disp = eventDisplay.display;
		}
		//This block handles child events with result status of "IN ERROR"
		if (resultStatus.meaning === "INERROR") {
			resultVal = resultStatus.display;
			if (item.EVENT_NOTE_LIST.length) {
				resultVal = "*" + resultVal;
			}
			listItem = ("<li><span class = 'mrv-group-event-data-label' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\""+eventDisplay.description+"\")' >" + eventDisplay.description + "</span><span class = 'mrv-group-event-data-val' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\"" + eventDisplay.description+"\")' >" + resultVal + "</span></li>");
			list.push(listItem);
		}
		/*
		 * This block handles the display of child events with values associated to them
		 * Logic of if-block is as follows:
		 * The item should have no further child events
		 * All events not having event_class_cd as GRP
		 * End result events which are in modified state has a child item though they store the value in the parent level are handled in this block
		 * Event code display and result value should not be empty
		 */
		else if (((!item.CHILD_EVENT_LIST || item.CHILD_EVENT_LIST.length === 0) || (item.EVENT_CLASS_CD_DISP !== "GRP") || (resultStatus.meaning === "MODIFIED" && item.RESULT_VAL !== "" && item.CHILD_EVENT_LIST.length > 0)) && !(event_cd_disp === "" && item.RESULT_VAL === "")) {
			//For events that have its result value as a date time
			if (item.DATE_RESULT.length > 0) {
				resultVal = self.m_dateFormatter.formatISO8601(item.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			}
			else {
				resultVal = item.RESULT_VAL + " " + item.RESULT_UNITS_CD_DISP;
			}
			/*
			 * If the event has any comments associated to them then an asterisk needs to be prefixed to the result value
			 * If the event has a modified status then (c) needs to be prefixes to the result value
			 * In case a comment is also associated to an event with modified status then the modified indicator(c) appears
			 * first followed by the comment indicator(*).
			*/
			if (item.EVENT_NOTE_LIST.length) {
				resultVal = "*" + resultVal;
			}
			if (resultStatus.meaning === "MODIFIED") {
				resultVal = "(c)" + resultVal;
			}
			listItem = ("<li><span class = 'mrv-group-event-data-label' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\""+event_cd_disp+"\")' >" + event_cd_disp + "</span><span class = 'mrv-group-event-data-val' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\"" + event_cd_disp+"\")' >" + resultVal + "</span></li>");
			list.push(listItem);
		}
		//This else if block handles the display of the group child events in the subsection
		else if (item.CHILD_EVENT_LIST && item.CHILD_EVENT_LIST.length !== 0 && !(event_cd_disp === "" && item.RESULT_VAL === "")) {
			var comment_ind = (item.EVENT_NOTE_LIST.length)?"*":"";
			
			if (resultStatus.meaning === "MODIFIED") {
				listItem = ("<li><span class = 'mrv-group-child-event-list' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\"" + event_cd_disp+"\")' >" + event_cd_disp + "<span class = 'mrv-group-event-modified'>(c)" + comment_ind + "</span></span></li>");
			}
			else {
				listItem = ("<li><span class = 'mrv-group-child-event-list' onclick = 'ResultViewer.launchAdHocViewer(parseFloat(" + eventId + "),\""+event_cd_disp+"\")' >" + event_cd_disp + ((comment_ind !== "") ? "<span class = 'mrv-group-event-comment'>" + comment_ind + "</span>": "") + "</span></li>");
			}
			list.push(listItem);
		}
	}
	/*
	 *	If the child event has any further child events then build the sub-list for those child
	 *	events before proceeding to the next sibling
	*/
	if (item.CHILD_EVENT_LIST && item.CHILD_EVENT_LIST.length && item.RESULT_VAL === "" && item.EVENT_CLASS_CD_DISP === "GRP") {
		var sublistHTML = [];
		sublistHTML.push("<ul class = 'mrv-group-child-event-block'>");
		item.CHILD_EVENT_LIST.sort(self.SortByCollatingSeq);
		$.each(item.CHILD_EVENT_LIST, function(key, value) {
			self.createList(value, sublistHTML);
		});
		sublistHTML.push("</ul>");
		list.push(sublistHTML.join(''));
	}
};

GroupViewerHandler.prototype.SortByCollatingSeq = function(a,b) {
	var aSeq = a.COLLATING_SEQ;
	var bSeq = b.COLLATING_SEQ;
	if (aSeq > bSeq) {
		return 1;
	} else {
		if (aSeq < bSeq) {
			return -1;
		}
		return 0;
	}
};

/**
 * This function create the HTML string for the Action List tab.
 * @param {Object} eventRecordObj JSon Reply's result block list
 * @return {string} HTML string of Action List tab
 */
GroupViewerHandler.prototype.buildActionListTabHTML = function(eventRecordObj) {
	var actionListTabHTML = [];
	var actionListLen = 0;
	var actionDtTm = "";
	var requestDtTm = "";
	var actionListItem = null;
	var emptyCell = "--";
	var provider = null;
	var actionProviderName = "";
	var requestedByName = "";
	var requestedBy = null;
	var proxyName = "";
	var proxy = null;
	var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";

	actionListTabHTML.push("<div class ='mrv-group-actionlist-info hidden' id = '", this.m_modalDialogId, "ActionListInfoId'>",this.buildHeaderHTML(eventRecordObj),"<div class = 'mrv-group-result-table-div'><table class='mrv-group-actionlist-table'><tr><th>", this.m_groupViewerI18n.ACTION, "</th><th>", this.m_groupViewerI18n.PERFORMED_BY, "</th><th>", this.m_groupViewerI18n.PERFORMED_DATE, "</th><th>", this.m_groupViewerI18n.ACTION_STATUS, "</th><th>", this.m_groupViewerI18n.COMMENT, "</th><th>", this.m_groupViewerI18n.PROXY_PERSONNEL, "</th><th>", this.m_groupViewerI18n.REQUESTED_BY, "</th><th>", this.m_groupViewerI18n.REQUESTED_DATE, "</th><th>", this.m_groupViewerI18n.REQUEST_COMMENT, "</th></tr>");
	actionListLen = eventRecordObj.EVENT_PRSNL_LIST.length;
	for (var alIndex = 0; alIndex < actionListLen; alIndex++) {
		actionDtTm = "";
		requestDtTm = "";
		actionListItem = eventRecordObj.EVENT_PRSNL_LIST[alIndex];
		if (actionListItem.ACTION_DT_TM !== invalidDate) {
			actionDtTm = this.m_dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}
		if (actionListItem.REQUEST_DT_TM !== invalidDate) {
			requestDtTm = this.m_dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}
		provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, this.m_personnelArray);
		actionProviderName = (provider) ? provider.fullName : "";
		requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, this.m_personnelArray);
		requestedByName = (requestedBy) ? requestedBy.fullName : "";
		proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, this.m_personnelArray);
		proxyName = (proxy) ? proxy.fullName : "";
		actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
	}
	actionListTabHTML.push("</table></div></div>");
	return actionListTabHTML.join("");
};

/**
 * This function create the HTML string for the Comments tab.
 * @param {Object} eventRecordObj JSon Reply's result block list
 * @return {string} HTML string of Comments tab
 */
GroupViewerHandler.prototype.buildCommentsTabHTML = function(eventRecordObj) {
	var commentsTabHTML = [];
	var noteListItem = null;
	var provider = null;
	var commentProviderName = "";
	commentsTabHTML.push("<div class ='mrv-group-comments-info hidden' id = '" , this.m_modalDialogId , "CommentsInfoId'>");
	commentsTabHTML.push(this.buildHeaderHTML(eventRecordObj));
	commentsTabHTML.push("<div class ='mrv-group-comments-div'>");
	var noteListLen = eventRecordObj.EVENT_NOTE_LIST.length;
	for (var noteIndex = 0; noteIndex < noteListLen; noteIndex++) {
		noteListItem = eventRecordObj.EVENT_NOTE_LIST[noteIndex];
		provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, this.m_personnelArray);
		commentProviderName = (provider) ? provider.fullName : "";
		commentsTabHTML.push("<div class = 'mrv-group-comments-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", this.m_groupViewerI18n.BY, " ", commentProviderName, " ", this.m_groupViewerI18n.ON, " ", this.m_dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
		commentsTabHTML.push("<div class = 'mrv-group-comments-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
	}
	commentsTabHTML.push("</div>");
	return commentsTabHTML.join("");
};

/**
 * It renders the content for the viewer when data requisition finishes.
 * @param {ScriptReply} response ScriptReply object for the data requisition.
 */
GroupViewerHandler.prototype.renderGroupViewer = function(response) {
	this.m_groupViewerI18n = i18n.discernabu.mpage_result_viewer.group_modal;
	var groupViewModalBodyHTML = [];
	var groupViewModalObject = MP_ModalDialog.retrieveModalDialogObject(this.m_modalDialogId);
	var groupViewModalId = groupViewModalObject.getBodyElementId();
	this.m_dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	this.m_recordData = response.getResponse();
	if (this.m_recordData) {
		if (this.m_recordData.STATUS_DATA.STATUS === "F" || this.m_recordData.STATUS_DATA.STATUS === "Z") {
			this.handleError(this.m_groupViewerI18n.ERROR_RETRIEVE, this.m_groupViewerI18n.ERROR_TITLE, this.m_groupViewerI18n.OK);
			MP_ModalDialog.closeModalDialog(this.m_modalDialogId);
			MP_ModalDialog.deleteModalDialogObject(this.m_modalDialogId);
			return;
		}
	}
	this.m_personnelArray = MP_Util.LoadPersonelListJSON(this.m_recordData.PRSNL);
	this.m_commentsFound = false;
	if (this.m_recordData.RB_LIST[0].EVENT_NOTE_LIST.length) {
		this.m_commentsFound = true;
	}
	groupViewModalBodyHTML.push("<div class='mrv-group-container'>",this.buildEventDetailSectionHTML(this.m_recordData.RB_LIST[0]),"</div>");
	var grpViewerBody = "#" + this.m_modalDialogId + "body";
	$(grpViewerBody).removeClass("mrv-result-loading");
	$("#" + groupViewModalId).html(groupViewModalBodyHTML.join(""));
};

/*
 * This function attaches event listeners to the DOM.
 */
GroupViewerHandler.prototype.attachListeners = function() {
	var self = this;
	var tab1 = "#" + self.m_modalDialogId + "Tab1";
	var tab2 = "#" + self.m_modalDialogId + "Tab2";
	var tab3 = "#" + self.m_modalDialogId + "Tab3";
	var detailsInfoId = "#" + self.m_modalDialogId + "DetailsInfoId";
	var actionListInfoId = "#" + self.m_modalDialogId + "ActionListInfoId";
	var commentsInfoId = "#" + self.m_modalDialogId + "CommentsInfoId";
	//Handle click events on the respective tabs of group viewers
	$(document).on("click", tab1, function() {
		self.onTabChange($(this));
		//When details tab is clicked
		self.showAndHideTabs(detailsInfoId, actionListInfoId, commentsInfoId);
	});
	$(document).on("click", tab2, function() {
		self.onTabChange($(this));
		//when action list tab is clicked
		self.showAndHideTabs(actionListInfoId, detailsInfoId, commentsInfoId);
	});
	$(document).on("click", tab3, function() {
		self.onTabChange($(this));
		//when comments tab is clicked
		self.showAndHideTabs(commentsInfoId, detailsInfoId, actionListInfoId);
	});
};

/*
 * This function alters CSS property to display the appropriate tab content
 * First parameter stores the tab ID to be displayed while other two will be hidden tabs
 * @param {string} showTabId Id of tab to be displayed
 * @param {string} hideTabId1 tab id to be hidden
 * @param {string} hideTabId2 tab id to be hidden
 */
 GroupViewerHandler.prototype.showAndHideTabs = function(showTabId, hideTabId1, hideTabId2) {
	$(showTabId).removeClass("hidden");
	$(hideTabId1).addClass("hidden");
	$(hideTabId2).addClass("hidden");
 };

/**
 * This function displays the content of the selected tab and hide previous tab's contents
 * @param {DOM Object} selectedTabObj The DOM object of the selected tab
 */
GroupViewerHandler.prototype.onTabChange = function(selectedTabObj) {
	var objTabActive = $(selectedTabObj).parent().find(".mrv-group-tab-active-header");
	if(objTabActive.length){
		//If selected and active tab are the same then exit
		if($(objTabActive).attr("id") === $(selectedTabObj).attr("id")){
			return;
		}
	}
	//Remove active header class from active tab
	$(objTabActive).removeClass("mrv-group-tab-active-header");
	//Add active header class to the selected tab
	$(selectedTabObj).addClass("mrv-group-tab-active-header");
};

/**
 * @class
 * This HLAViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display group results.
 * Launching Millennium viewer requires fields:
 *   - Patient ID
 *   - Event ID Array (with only one Event ID)
 * Launching Web viewer requires fields:
 *   * Yet to implement
 */
var HLAViewerHandler = function() {

};

HLAViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
HLAViewerHandler.prototype.validateRequiredFields = function() {
	var patientId = this.getPatientId();
	//it has to be a non-negative number
	if (typeof patientId !== "number" || patientId < 0) {
		throw new Error("HLAViewerHandler requires patientId to launch the viewer");
	}

	var eventIdArray = this.getEventIds();
	//only accept a single event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("HLAViewerHandler requires a valid event ID to launch the viewer");
	}
	
	if (eventIdArray.length > 1) {
		throw new Error("HLAViewerHandler only needs one event ID to launch the view");
	}
};


/**
 * Function HLAViewerHandler.prototype.launchWebViewer launches web modal dialog viewer in non-Millennium platform to display the clinical result.
 * It is yet to be implemented. When it is called, it will use the AbstractViewerHandler's default implementation, which will launch a modal dialog
 * that displays an error message that the result can't be viewed. 
 */
 
/**
 * It launches Millennium viewer in Millennium platform to display the clinical result.
 */
HLAViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var patientId = this.getPatientId();
		var eventId = this.getEventIds()[0];

		//launch Millennium viewer
		var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
		logger.logDiscernInfo(null, "PVVIEWERMPAGE", "hla-viewer-handler.js", "launchMillenniumViewer");
		viewerObj.CreateAndLaunchHLAViewer(patientId, eventId);
	} catch (err) {
		logger.logJSError(err, null, "hla-viewer-handler.js", "HLAViewerHandler.launchMillenniumViewer");
	}
};
/**
 * @class
 * This MicroViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display microbiology results/documents.
 * Launching Millennium viewer requires fields:
 *   - Patient ID
 *   - Event ID Array (with one or multiple Event IDs)
 * Launching Web viewer requires fields:
 *   - Event ID Array (with one or multiple Event IDs)
 */
var MicroViewerHandler = function() {
	this.m_recordData = null;

	this.m_specimenFound = false;
	this.m_commentsFound = false;
	this.m_reportsFound = false;
	this.m_suscepFound = false;
	this.m_dateFormatter = null;
	this.m_personnelArray = [];

	this.m_antibioticArray = [];
	this.m_micOrganismDescArray = [];
};

MicroViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields. 
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
MicroViewerHandler.prototype.validateRequiredFields = function() {
	var patientId = this.getPatientId();
	var eventIdArray = this.getEventIds();

	//should have at least one event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("MicroViewerHandler requires at least one event ID to launch the viewer");
	}

	//Validate Millennium viewer related fields
	if (this.m_millenniumInd) {
		//it has to be a non-negative number
		if (typeof patientId !== "number" || patientId < 0) {
			throw new Error("MicroViewerHandler requires patientId to launch the viewer");
		}
	}
};

/**
 * It launches web modal dialog viewer in non-Millennium platform to display the microbiology result/document.
 */
MicroViewerHandler.prototype.launchWebViewer = function() {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var eventIdArray = this.getEventIds();
	var eventIdStr = MP_Util.CreateParamArray(eventIdArray, 1);
	var self = this;

	var microViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("microViewer");
	if (!microViewerModalObj) {
		microViewerModalObj = new ModalDialog("microViewer");
		var micViewerCloseBtn = new ModalButton("micViewerCloseBtn");
		micViewerCloseBtn.setText(micViewModalI18n.CLOSE);
		micViewerCloseBtn.setFocusInd(true);
		microViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(15).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
		microViewerModalObj.setHeaderTitle(micViewModalI18n.MIC_RESULT_DETAILS);
		microViewerModalObj.addFooterButton(micViewerCloseBtn);
		MP_ModalDialog.addModalDialogObject(microViewerModalObj);
	}

	microViewerModalObj.setBodyDataFunction(function(micModalObj) {
		self.attachListeners();
		microViewerModalObj.setBodyHTML("<div class = 'mrv-micro-loading'></div>");

		var cclParams = [];
		cclParams.push("^MINE^", eventIdStr, 0, 1, 1);

		self.loadWithCBParameters("mp_get_result_viewer_data", cclParams, function(replyObj) {
			self.renderMicroViewer(replyObj);
		});
	});
	MP_ModalDialog.updateModalDialogObject(microViewerModalObj);
	MP_ModalDialog.showModalDialog("microViewer");
};

/**
 * It launches Millennium viewer in Millennium platform to display the microbiology result/document.
 */
MicroViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var patientId = this.getPatientId();
		var eventIdArray = this.getEventIds();

		var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
		logger.logDiscernInfo(null, "PVVIEWERMPAGE", "micro-viewer-handler.js", "launchMillenniumViewer");
		viewerObj.CreateMicroViewer(patientId);

		for (var x = eventIdArray.length; x--; ) {
			viewerObj.AppendMicroEvent(eventIdArray[x]);
		}
		viewerObj.LaunchMicroViewer();
	} catch (err) {
		logger.logJSError(err, null, "micro-viewer-handler.js", "MicroViewerHandler.launchMillenniumViewer");
	}
};


/**
 * Helper functions
 */

/**
 * It opens a modal dialog and displays an error message in it. 
 * @param {string} message Message
 * @param {string} title Modal dialog title
 * @param {string} buttonText Button label
 */
MicroViewerHandler.prototype.alertError = function(message, title, buttonText) {
	var modalObj = MP_Util.generateModalDialogBody("micViewerFailureAlert", "error", message, "");
	var modalButton = modalObj.getFooterButton("modalOkBtn");
	if (!modalButton) {
		modalButton = new ModalButton("modalOkBtn");
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true).setOnClickFunction(function() {
			MP_ModalDialog.closeModalDialog("microViewer");
		});
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
	}
	modalObj.setHeaderTitle(title);
	modalObj.setFooterButtonText("modalOkBtn", buttonText);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("micViewerFailureAlert");
};

/**
 * It opens a modal dialog and displays the micro foot note HTML in it. 
 * @param {string} message Foot note HTML message
 */
MicroViewerHandler.prototype.alertMicFootNoteWindow = function(message) {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var modalObj = MP_Util.generateModalDialogBody("micMicFootNoteAlert", "", message, "");
	var modalButton = modalObj.getFooterButton("modalCloseBtn");
	if (!modalButton) {
		modalButton = new ModalButton("modalCloseBtn");
		modalButton.setText(micViewModalI18n.CLOSE);
		modalButton.setFocusInd(true).setOnClickFunction(function() {
		});
		modalObj.addFooterButton(modalButton);
	}
	modalObj.setHeaderTitle(micViewModalI18n.MIC_FOOTNOTE);
	modalObj.setFooterButtonText("modalCloseBtn", micViewModalI18n.CLOSE);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("micMicFootNoteAlert");
};

/**
 * This function create the HTML string for the micro details including the tabs and contents of each tab. 
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML content of the detail section
 */
MicroViewerHandler.prototype.buildEventDetailSectionHTML = function(eventRBListObj) {
	var eventDetailHTML = [];
	eventDetailHTML.push("<div class='mrv-micro-detail' id='micViewDetail'>");
	eventDetailHTML.push("<div class='mrv-micro-controls' id='micViewControls'>");
	eventDetailHTML.push(this.buildTabSectionHTML());
	eventDetailHTML.push("</div><div class='mrv-micro-tab-body ' id='micViewBody'>");
	eventDetailHTML.push("<div class='mrv-micro-body-container' id='micViewTabBodyId'>");
	if (this.m_reportsFound) {
		eventDetailHTML.push(this.buildMicroRepotsTabHTML(eventRBListObj));
	}
	if (this.m_suscepFound) {
		eventDetailHTML.push(this.buildSuscepTabHTML(eventRBListObj));
	}
	if (this.m_specimenFound) {
		eventDetailHTML.push(this.buildSpecimenTabHTML(eventRBListObj));
	}
	if (this.m_commentsFound) {
		eventDetailHTML.push(this.buildCommentsTabHTML(eventRBListObj));
	}
	eventDetailHTML.push(this.buildActionListTabHTML(eventRBListObj));

	eventDetailHTML.push("</div></div></div>");
	return eventDetailHTML.join("");
};

/**
 * This function create the HTML string the tab section including reports, susceptibilities, specimen, comments and action list. 
 * @return {string} HTML string of the tab section
 */
MicroViewerHandler.prototype.buildTabSectionHTML = function() {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var tabHTML = [];
	var activeTabHTML = "<span class = 'mrv-micro-tab-active-left'></span><span class = 'mrv-micro-tab-active-center'>";
	var activeCloseHTML = "</span><span class = 'mrv-micro-tab-active-right'></span>";
	var tabActivateClass = " mrv-micro-tab-active";
	var tabActivateLbl = "mrv-micro-tab-active-label";
	var micSepVisible = " hidden";

	tabHTML.push("<span class = 'mrv-micro-tab-bg-left mrv-micro-tab-container'></span>");

	if (this.m_reportsFound) {

		tabHTML.push("<div  class='mrv-micro-tab-container", tabActivateClass, "' id='micViewTab1' tabtext = '", micViewModalI18n.MIC_REPORT, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.MIC_REPORT, "</div>", activeCloseHTML, "</div><span id = 'rvDetSepId' class='mrv-micro-tab-sep", micSepVisible, "'></span>");
		activeTabHTML = "";
		activeCloseHTML = "";
		tabActivateClass = " mrv-micro-tab-inactive";
		tabActivateLbl = "mrv-micro-tab-inactive-label";
		micSepVisible = "";

	}

	if (this.m_suscepFound) {
		tabHTML.push("<div  class='mrv-micro-tab-container", tabActivateClass, "'  id='micViewTab2' tabtext = '", micViewModalI18n.SUSCEPTABILITIES, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SUSCEPTABILITIES, "</div>", activeCloseHTML, "</div><span id = 'rvSuscepSepId' class='mrv-micro-tab-sep", micSepVisible, "'></span>");
		activeTabHTML = "";
		activeCloseHTML = "";
		tabActivateClass = " mrv-micro-tab-inactive";
		tabActivateLbl = "mrv-micro-tab-inactive-label";
		micSepVisible = "";
	}

	if (this.m_specimenFound) {
		tabHTML.push("<div  class='mrv-micro-tab-container", tabActivateClass, "' id='micViewTab3' tabtext = '", micViewModalI18n.SPECIMEN, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SPECIMEN, "</div>", activeCloseHTML, "</div><span id = 'rvSpecimenSepId' class='mrv-micro-tab-sep", micSepVisible, "'></span>");
		activeTabHTML = "";
		activeCloseHTML = "";
		tabActivateClass = " mrv-micro-tab-inactive";
		tabActivateLbl = "mrv-micro-tab-inactive-label";
		micSepVisible = "";
	}

	if (this.m_commentsFound) {
		tabHTML.push("<div  class='mrv-micro-tab-container", tabActivateClass, "' id='micViewTab5' tabtext = '", micViewModalI18n.COMMENTS, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.COMMENTS, "</div>", activeCloseHTML, "</div><span id = 'rvCommentsSepId' class='mrv-micro-tab-sep", micSepVisible, "'></span>");
	}
	tabHTML.push("<div  class='mrv-micro-tab-container", tabActivateClass, "' id='micViewTab4' tabtext = '", micViewModalI18n.ACTION_LIST, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.ACTION_LIST, "</div>", activeCloseHTML, "</div><span id = 'rvActionSepId' class='mrv-micro-tab-sep", micSepVisible, "'></span>");
	return tabHTML.join("");
};

/**
 * This function create the HTML string for the micro Report tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Report tab
 */
MicroViewerHandler.prototype.buildMicroRepotsTabHTML = function(eventRBListObj) {
	var micReportsTabHTML = [];

	var micListItem = null;
	micReportsTabHTML.push("<div class ='mrv-micro-comments-info' id = 'rvMicRepoInfoId'>");
	var micRptListLen = eventRBListObj.CHILD_EVENT_LIST.length;
	for (var rptIndex = 0; rptIndex < micRptListLen; rptIndex++) {
		micListItem = eventRBListObj.CHILD_EVENT_LIST[rptIndex];
		micReportsTabHTML.push("<div class = 'mrv-micro-comment-text1'>", micListItem.EVENT_CD_DISP, " - ", this.m_dateFormatter.formatISO8601(micListItem.VERIFIED_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), " - </div>");
		micReportsTabHTML.push("<div class = 'mrv-micro-comment-pad'>", micListItem.BLOB_RESULT[0].BLOB[0].BLOB_TEXT, "</div>");
	}
	micReportsTabHTML.push("</div>");

	return micReportsTabHTML.join("");
};


/**
 * This function create the HTML string for the micro Susceptibilities tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Susceptibilities tab
 */
MicroViewerHandler.prototype.buildSuscepTabHTML = function(eventRBListObj) {
	var suscepTabHTML = [];
	var micListItem = null;
	var micSuscepListItem = null;
	var micListLen = 0;
	var suscepFTLen = 0;
	var suscepFTItem = null;
	var micSuscepListLen = 0;
	var firstColIndx = 1;
	var suscepColHeaders = [];
	var suscepTableHeaderCols = 0;
	var alphaChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	var suscepVisible = this.m_reportsFound ? " hidden" : "";
	var micSuscepIndex = 0;
	suscepTabHTML.push("<div class ='mrv-micro-comments-info", suscepVisible, "' id = 'rvSuscepInfoId'>");
	suscepTabHTML.push("<div class = 'mrv-micro-table-div'><table class='mrv-micro-suscep-table'><tr><th></th>");

	micListLen = eventRBListObj.MICROBIOLOGY_LIST.length;
	suscepColHeaders = new Array(micListLen);
	this.m_antibioticArray = new Array(micListLen);

	for (var micIndex = 0; micIndex < micListLen; micIndex++) {

		micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
		micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
		var tempArray = [];
		var tempAntibioticArray = [];
		var tempAntibioticObjectArr = [];

		for (micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

			micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

			var colName = micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP;
			var antiBioticDisp = micSuscepListItem.ANTIBIOTIC_CD_DESC;
			if (tempArray.indexOf(colName) === -1) {
				tempArray.push(colName);
			}
			if (tempAntibioticArray.indexOf(antiBioticDisp) === -1) {
				var antibioticObject = new MicroViewerHandler.AntibioticDetails();
				antibioticObject.setAntiDescription(antiBioticDisp);
				suscepFTLen = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST.length;
				for (var suscepFTIndex = 0; suscepFTIndex < suscepFTLen; suscepFTIndex++) {
					suscepFTItem = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST[suscepFTIndex];
					var ftLen = suscepFTItem.SUSCEP_FOOTNOTE.length;
					for (var ftIndex = 0; ftIndex < ftLen; ftIndex++) {
						var ftItem = suscepFTItem.SUSCEP_FOOTNOTE[ftIndex];
						if (suscepFTItem.SUSCEP_SEQ_NBR === micSuscepListItem.SUSCEP_SEQ_NBR) {
							antibioticObject = new MicroViewerHandler.AntibioticDetails();
							antibioticObject.setFootNoteInd(true);
							antibioticObject.setAntiDescription(antiBioticDisp);
							antibioticObject.setFootNoteText(ftItem.LONG_TEXT);
						}

					}

				}//suscepFoot note
				tempAntibioticArray.push(antiBioticDisp);
				tempAntibioticObjectArr.push(antibioticObject);
			}

		}// end for suscep

		suscepColHeaders[micIndex] = tempArray;

		this.m_antibioticArray[micIndex] = tempAntibioticObjectArr;
		this.m_micOrganismDescArray.push();

		if (suscepColHeaders[micIndex].length > suscepTableHeaderCols) {
			suscepTableHeaderCols = suscepColHeaders[micIndex].length;
		}

	}//end for micro

	//Adding Suscep table column headers
	for ( var suscepColIdx = 0; suscepColIdx < suscepTableHeaderCols + 1; suscepColIdx++) {
		suscepTabHTML.push("<th>", alphaChars.charAt(suscepColIdx), "</th>");
	}
	suscepTabHTML.push("</tr>");
    
	var i = 0;
	for (micIndex = 0; micIndex < micListLen; micIndex++) {
		micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
		var micItemOrganismCDDesc = (micListItem.ORGANISM_OCCURRENCE_NBR === 1) ? micListItem.ORGANISM_CD_DESC : micListItem.ORGANISM_CD_DESC + " #" + micListItem.ORGANISM_OCCURRENCE_NBR;
		this.m_micOrganismDescArray.push(micItemOrganismCDDesc);

		suscepTabHTML.push("<tr><th class = 'mrv-micro-suscep-firstcol'>", firstColIndx++, "</th><td class = 'mrv-micro-suscep-section'>", micItemOrganismCDDesc, "</td>");

		for (i = 0; i < suscepColHeaders[micIndex].length; i++) {
			suscepTabHTML.push("<td  class = 'mrv-micro-suscep-section'></td>");
			if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
				suscepTabHTML.push("<td class = 'mrv-micro-suscep-cell'></td>");
			}
		}
		suscepTabHTML.push("</tr>");

		suscepTabHTML.push("<tr><th class = 'mrv-micro-suscep-firstcol'>", firstColIndx++, "</th><td class = 'mrv-micro-suscep-subsection'></td>");

		for (i = 0; i < suscepColHeaders[micIndex].length; i++) {
			suscepTabHTML.push("<td  class = 'mrv-micro-suscep-subsection'>", suscepColHeaders[micIndex][i], "</td>");
			if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
				suscepTabHTML.push("<td class = 'mrv-micro-suscep-cell'></td>");
			}
		}
		suscepTabHTML.push("</tr>");

		micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;

		for (var k = 0; k < this.m_antibioticArray[micIndex].length; k++) {
			var antobioticHTML = [];
			for (var j = 0; j < suscepColHeaders[micIndex].length; j++) {
				this.m_suscepFound = false;

				for (micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

					micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

					if (this.m_antibioticArray[micIndex][k].getAntiDescription() === micSuscepListItem.ANTIBIOTIC_CD_DESC && suscepColHeaders[micIndex][j] === micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP) {
						antobioticHTML.push("<td class = 'mrv-micro-suscep-cell'>", micSuscepListItem.RESULT_CD_DISP ? micSuscepListItem.RESULT_CD_DISP : micSuscepListItem.RESULT_NUMERIC_VALUE, "</td>");
						this.m_suscepFound = true;

						break;
					}
				}
				if (!this.m_suscepFound) {
					antobioticHTML.push("<td class = 'mrv-micro-suscep-cell'></td>");
				}
			}
			var footNoteClass = "";
			var footNoteInd = this.m_antibioticArray[micIndex][k].getFootNoteInd();

			var antibioticText = footNoteInd ? this.m_antibioticArray[micIndex][k].getAntiDescription() + "*" : this.m_antibioticArray[micIndex][k].getAntiDescription();

			if (footNoteInd) {
				footNoteClass = " mrv-micro-footnote";
			}
			if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
				antobioticHTML.push("<td  class = 'mrv-micro-suscep-cell'></td>");
			}
			suscepTabHTML.push("<tr><th class = 'mrv-micro-suscep-firstcol'>", firstColIndx++, "</th><td class = 'mrv-micro-suscep-cell", footNoteClass, "' id='micViewSuscepCell_", this.m_uniqueId, "_", micIndex, "_", k, "'", ">", antibioticText, "</td>", antobioticHTML.join(""), "</tr>");
		}
		if (micIndex !== micListLen - 1) {
			suscepTabHTML.push("<tr><th class = 'mrv-micro-suscep-firstcol'>", firstColIndx++, "</th>");
			for (i = 0; i <= suscepTableHeaderCols; i++) {
				suscepTabHTML.push("<td class = 'mrv-micro-suscep-cell'></td>");
			}
			suscepTabHTML.push("</tr>");
		}
	}

	suscepTabHTML.push("</table></div></div>");

	return suscepTabHTML.join("");
};


/**
 * This function create the HTML string for the Action List tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Action List tab
 */
MicroViewerHandler.prototype.buildActionListTabHTML = function(eventRBListObj) {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var actionListTabHTML = [];
	var actionListLen = 0;
	var actionDtTm = "";
	var requestDtTm = "";
	var actionListItem = null;
	var emptyCell = "--";
	var provider = null;
	var actionProviderName = "";
	var requestedByName = "";
	var requestedBy = null;
	var proxyName = "";
	var proxy = null;
	var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";
	actionListTabHTML.push("<div class = 'mrv-micro-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'mrv-micro-table-div'><table class='mrv-micro-actionlist-table'><tr><th>", micViewModalI18n.ACTION, "</th><th>", micViewModalI18n.PERFORMED_BY, "</th><th>", micViewModalI18n.PERFORMED_DATE, "</th><th>", micViewModalI18n.ACTION_STATUS, "</th><th>", micViewModalI18n.COMMENT, "</th><th>", micViewModalI18n.PROXY_PERSONNEL, "</th><th>", micViewModalI18n.REQUESTED_BY, "</th><th>", micViewModalI18n.REQUESTED_DATE, "</th><th>", micViewModalI18n.REQUEST_COMMENT, "</th></tr>");
	actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
	for (var alIndex = 0; alIndex < actionListLen; alIndex++) {
		actionDtTm = "";
		requestDtTm = "";
		actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
		if (actionListItem.ACTION_DT_TM !== invalidDate) {
			actionDtTm = this.m_dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}
		if (actionListItem.REQUEST_DT_TM !== invalidDate) {
			requestDtTm = this.m_dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}
		provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, this.m_personnelArray);
		actionProviderName = (provider === null) ? "" : provider.fullName;
		requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, this.m_personnelArray);
		requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
		proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, this.m_personnelArray);
		proxyName = (proxy === null) ? "" : proxy.fullName;
		actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
	}
	actionListTabHTML.push("</table></div></div>");
	return actionListTabHTML.join("");
};


/**
 * This function create the HTML string for the Specimen tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Specimen tab
 */
MicroViewerHandler.prototype.buildSpecimenTabHTML = function(eventRBListObj) {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var specimenTabHTML = [];
	var specimenCollObj = null;
	var specimenCollectedDtTm = "";
	var emptyCell = " --";
	var specimenVisible = (this.m_reportsFound || this.m_suscepFound) ? " hidden" : "";

	specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
	specimenCollectedDtTm = this.m_dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
	specimenTabHTML.push("<div class ='mrv-micro-specimen-info", specimenVisible, "' id = 'rvSpecimenInfoId'><div class = 'mrv-micro-tt'><span><h2 class='mrv-micro-resval'><span class = 'mrv-micro-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='mrv-micro-pad", "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
	specimenTabHTML.push("<dl class = 'mrv-micro-event-info'><dd class = 'mrv-micro-event-hd'>", micViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'mrv-micro-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP ? specimenCollObj.SOURCE_TYPE_CD_DISP : emptyCell, "</dd></dl>");
	specimenTabHTML.push("<dl class = 'mrv-micro-event-info'><dd class = 'mrv-micro-event-hd'>", micViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'mrv-micro-event-data'>", specimenCollectedDtTm ? specimenCollectedDtTm : emptyCell, "</dd></dl>");
	specimenTabHTML.push("<dl class = 'mrv-micro-event-info'><dd class = 'mrv-micro-event-hd'>", micViewModalI18n.BODY_SITE, ":</dd><dd class = 'mrv-micro-event-data'>", specimenCollObj.BODY_SITE_CD_DISP ? specimenCollObj.BODY_SITE_CD_DISP : emptyCell, "</dd></dl>");

	specimenTabHTML.push("</div>");
	return specimenTabHTML.join("");
};


/**
 * This function create the HTML string for the Comments tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Comments tab
 */
MicroViewerHandler.prototype.buildCommentsTabHTML = function(eventRBListObj) {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var commentsTabHTML = [];
	var noteListItem = null;
	var provider = null;
	var commentProviderName = "";
	commentsTabHTML.push("<div class ='mrv-micro-comments-info hidden' id = 'rvCommentsInfoId'>");
	var noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
	for (var noteIndex = 0; noteIndex < noteListLen; noteIndex++) {
		noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
		provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, this.m_personnelArray);
		commentProviderName = (provider === null) ? "" : provider.fullName;
		commentsTabHTML.push("<div class = 'mrv-micro-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", micViewModalI18n.BY, " ", commentProviderName, " ", micViewModalI18n.ON, " ", this.m_dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
		commentsTabHTML.push("<div class = 'mrv-micro-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
	}
	commentsTabHTML.push("</div>");
	return commentsTabHTML.join("");
};

/**
 * It renders the content for the viewer when data requisition finishes.
 * @param {ScriptReply} response ScriptReply object for the data requisition.
 */
MicroViewerHandler.prototype.renderMicroViewer = function(response) {
	var micViewModalI18n = i18n.discernabu.mpage_result_viewer.micro_modal;
	var micViewModalBodyHTML = [];
	var micViewModalObject = MP_ModalDialog.retrieveModalDialogObject("microViewer");
	var micViewModalId = micViewModalObject.getBodyElementId();
	this.m_dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	this.m_recordData = response.getResponse();
	if (this.m_recordData) {
		if (response.getStatus() === "F") {
			this.alertError(micViewModalI18n.ERROR_RETRIEVE, micViewModalI18n.ERROR_TITLE, micViewModalI18n.OK);
			return;
		}
	}
	this.m_personnelArray = MP_Util.LoadPersonelListJSON(this.m_recordData.PRSNL);
	this.m_specimenFound = false;
	this.m_commentsFound = false;
	this.m_suscepFound = false;
	this.m_reportsFound = false;
	if (this.m_recordData.RB_LIST[0].SPECIMEN_COLL.length) {
		this.m_specimenFound = true;
	}
	if (this.m_recordData.RB_LIST[0].EVENT_NOTE_LIST.length) {
		this.m_commentsFound = true;
	}
	if (this.m_recordData.RB_LIST[0].CHILD_EVENT_LIST.length) {
		this.m_reportsFound = true;
	}
	if (this.m_recordData.RB_LIST[0].MICROBIOLOGY_LIST.length) {
		for (var micIndex = 0; micIndex < this.m_recordData.RB_LIST[0].MICROBIOLOGY_LIST.length; micIndex++) {
			var micListItem = this.m_recordData.RB_LIST[0].MICROBIOLOGY_LIST[micIndex];
			var micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
			if (micSuscepListLen) {
				this.m_suscepFound = true;
			}
		}
	}

	micViewModalBodyHTML.push("<div class='mrv-micro-container'>");
	micViewModalBodyHTML.push("<div class = 'mrv-micro-tt'><span><h2 class='mrv-micro-resval'><span class = 'mrv-micro-resname'>", this.m_recordData.RB_LIST[0].EVENT_CD_DISP, " - ", micViewModalI18n.ACCESSION_NUMBER, ":</span><span><span class='mrv-micro-pad", "'>", this.m_recordData.RB_LIST[0].ACCESSION_NBR, "</span></span></h2></span></div>");
	micViewModalBodyHTML.push(this.buildEventDetailSectionHTML(this.m_recordData.RB_LIST[0]));
	micViewModalBodyHTML.push("</div>");
	$("#microViewerbody").removeClass("mrv-micro-loading");
	$("#" + micViewModalId).html(micViewModalBodyHTML.join(""));
};

/** 
 * This function create HTML string for foot note, and displays it in a modal dialog. 
 * @param {string} fnOrganismDesc Organism description
 * @param {string} fnAntiDesc Antibiotics description
 * @param {string} fnText foot note text
 */
MicroViewerHandler.prototype.buildFootNoteHTML = function(fnOrganismDesc, fnAntiDesc, fnText) {
	var modalFootNoteHTML = "";
	modalFootNoteHTML = "<div><span class = 'mrv-micro-resname'>" + fnOrganismDesc + "<span><span class = 'mrv-micro-footnote-txt'> - " + fnAntiDesc + "</span></div><br><div class = 'mrv-micro-footnote-div'>" + fnText + "</div>";
	this.alertMicFootNoteWindow(modalFootNoteHTML);
};

/**
 * This function displays the content of the selected tab and hide previous tab's contents
 * @param {DOM Object} selectedTabObj The DOM object of the selected tab
 */
MicroViewerHandler.prototype.onTabChange = function(selectedTabObj) {
	var targetTab = $(selectedTabObj);
	var activeTab = targetTab.parent().find(".mrv-micro-tab-active");
	if (activeTab.length) {
		if (activeTab.attr("id") === targetTab.attr("id")) {
			return;
		}
		activeTab.empty();
		activeTab.html("<div class='mrv-micro-tab-inactive-label'>" + activeTab.attr("tabText") + "</div>");
		activeTab.removeClass("mrv-micro-tab-active");
		activeTab.addClass("mrv-micro-tab-inactive");
		activeTab.next().removeClass("hidden");
		activeTab.prev().removeClass("hidden");
	}
	targetTab.removeClass("mrv-micro-tab-inactive");
	targetTab.next().addClass("hidden");
	targetTab.prev().addClass("hidden");
	targetTab.html("<span class = 'mrv-micro-tab-active-left'></span><span class = 'mrv-micro-tab-active-center'><span class='mrv-micro-tab-active-label'>" + targetTab.attr("tabText") + "</span></span><span class = 'mrv-micro-tab-active-right'></span>");
	targetTab.removeClass("mrv-micro-tab-inactive");
	targetTab.addClass("mrv-micro-tab-active");
};

/**
 * This function attaches event listeners to the DOM.  
 */
MicroViewerHandler.prototype.attachListeners = function() {
	var self = this;
	$(document).on("click", "#micViewTab1", function() {
		self.onTabChange($(this));
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
		$("#rvMicRepoInfoId").removeClass("hidden");
		$("#rvSuscepInfoId").addClass("hidden");
	});
	$(document).on("click", "#micViewTab2", function() {
		self.onTabChange($(this));
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
		$("#rvMicRepoInfoId").addClass("hidden");
		$("#rvSuscepInfoId").removeClass("hidden");
	});
	$(document).on("click", "#micViewTab3", function() {
		self.onTabChange($(this));
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").removeClass("hidden");
		$("#rvMicRepoInfoId").addClass("hidden");
		$("#rvSuscepInfoId").addClass("hidden");
	});
	$(document).on("click", "#micViewTab4", function() {
		self.onTabChange($(this));
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").removeClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
		$("#rvMicRepoInfoId").addClass("hidden");
		$("#rvSuscepInfoId").addClass("hidden");
	});
	$(document).on("click", "#micViewTab5", function() {
		self.onTabChange($(this));
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").removeClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
		$("#rvMicRepoInfoId").addClass("hidden");
		$("#rvSuscepInfoId").addClass("hidden");
	});

	//watch the click event of micro footnote
	$(document).on("click", ".mrv-micro-footnote", function() {
		var elementId = $(this).attr("id");
		//retrieve the indexes that reference to antibiotic object and organism description
		var matches = elementId.match(/micViewSuscepCell_\d+_(\d+)_(\d+)/);
		if (matches && matches.length === 3) {
			var micIndex = matches[1];
			var antibioticIndex = matches[2];
			var antibioticObj = self.m_antibioticArray[micIndex][antibioticIndex];
			//display foot note
			var micViewFNText = antibioticObj.getFootNoteText();
			var micViewFNHeader = self.m_micOrganismDescArray[micIndex];
			var micViewFNAnti = antibioticObj.getAntiDescription();
			self.buildFootNoteHTML(micViewFNHeader, micViewFNAnti, micViewFNText);
		}
	});

};

/**
 * @class
 * Nested Data structure for storing antibiotic details info
 */
MicroViewerHandler.AntibioticDetails = function() {
	this.m_description = "";
	this.m_footNoteInd = false;
	this.m_footNoteText = "";
};
/**
 * Retrieve antibiotic description
 * @return {string} Antibiotic description
 */
MicroViewerHandler.AntibioticDetails.prototype.getAntiDescription = function() {
	return this.m_description;
};

/**
 * Set Antibiotic Description
 * @param {string} desc Antibiotic Description
 */
MicroViewerHandler.AntibioticDetails.prototype.setAntiDescription = function(desc) {
	this.m_description = desc;
};

/**
 * Retrieve foot note indicator
 * @return {boolean} Foot note indicator
 */
MicroViewerHandler.AntibioticDetails.prototype.getFootNoteInd = function() {
	return this.m_footNoteInd;
};

/**
 * Set foot note indicator
 * @param {boolean} ftInd Foot note indicator
 */
MicroViewerHandler.AntibioticDetails.prototype.setFootNoteInd = function(ftInd) {
	this.m_footNoteInd = ftInd;
};

/**
 * Retrieve foot note text
 * @return {string} Foot note text
 */
MicroViewerHandler.AntibioticDetails.prototype.getFootNoteText = function() {
	return this.m_footNoteText;
};

/**
 * Set foot note text
 * @param {string} ftText Foot note text
 */
MicroViewerHandler.AntibioticDetails.prototype.setFootNoteText = function(ftText) {
	this.m_footNoteText = ftText;
};
/**
 * @class
 * This PathologyViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display pathology documents.
 * Launching Millennium viewer requires fields:
 *   - Event ID Array (with only one Event ID)
 *   - Parent Event ID
 * Launching Web viewer requires fields:
 *   - Event ID Array (with only one Event ID)
 *   - Patient ID
 *   - Document Viewer Type
 */
var PathologyViewerHandler = function() {
	this.m_recordData = null;
	var PathologyViewerTabsIndex = {
		REPORT : 0,
		IMAGES : 1,
		ACTION_LIST : 2,
		COMMENTS : 3
	};
	this.m_dateFormatter = null;
	this.m_personnelArray = [];
	this.m_requestedBy = "";
	this.m_receivedDate = "";
	this.m_verifiedDate = "";
};

PathologyViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
PathologyViewerHandler.prototype.validateRequiredFields = function() {
	var patientId = this.getPatientId();
	var eventIdArray = this.getEventIds();
	var peventId = this.getParentEventId();
	var docViewerType = this.getViewerType();

	//only accept a single event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("PathologyViewerHandler requires a valid single event ID to launch the viewer");
	}

	if (eventIdArray.length > 1) {
		throw new Error("PathologyViewerHandler only needs one event ID to launch the view");
	}

	//Validate Millennium viewer related fields
	if (this.m_millenniumInd) {
		//it has to be a non-negative number
		if (typeof peventId !== "number" || peventId < 0) {
			throw new Error("PathologyViewerHandler requires parent event ID to launch the viewer");
		}
	} else {
		//Validate web viewer related fields

		//it has to be a non-negative number
		if (typeof patientId !== "number" || patientId < 0) {
			throw new Error("PathologyViewerHandler requires patientId to launch the viewer");
		}

		//it should be a string
		if ( typeof docViewerType !== "string") {
			throw new Error("PathologyViewerHandler requires docViewerType to launch the viewer");
		}
	}
};

/**
 * It launches web modal dialog viewer in non-Millennium platform to display the pathology document.
 */
PathologyViewerHandler.prototype.launchWebViewer = function() {
	var pathViewerModalI18n = i18n.discernabu.mpage_result_viewer.pathology_modal;
	var patientId = this.getPatientId();
	var eventId = this.getEventIds()[0];
	var docViewerType = this.getViewerType();
	var self = this;

	//Convert numbers to floating-point format
	eventId = eventId + ".0";
	patientId = patientId + ".0";

	var pathModalDialog = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
	if (!pathModalDialog) {
		pathModalDialog = new ModalDialog("pathModalDialog");
		pathModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
		//pathModalDialog.setHeaderCloseFunction();
		pathModalDialog.setHeaderTitle("<span class='visitswindow-title'>" + pathViewerModalI18n.PATHOLOGY_TITLE + "</span>");
		MP_ModalDialog.addModalDialogObject(pathModalDialog);
	}

	pathModalDialog.setBodyDataFunction(function(pathViewDlg) {
		pathModalDialog.setBodyHTML("<div class='mrv-path-body-loading'><span class='mrv-path-loading'></span></div>");

		var cclParams = [];
		cclParams.push("^MINE^", eventId, patientId, "^" + docViewerType + "^");
		self.loadWithCBParameters("mp_get_path_viewer_data", cclParams, function(replyObj) {
			self.renderPathViewer(replyObj);
		});
	});

	MP_ModalDialog.updateModalDialogObject(pathModalDialog);
	MP_ModalDialog.showModalDialog(pathModalDialog.getId());

	$('#pathModalDialogbody').css({
		"overflow" : "hidden",
		"height" : "100%"
	});
	$("#vwpModalDialogpathModalDialog").css({
		"height" : "100%",
		"position" : "absolute"
	});
};

/**
 * It launches Millennium viewer in Millennium platform to display the pathology document.
 */
PathologyViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var peventId = this.getParentEventId();
		var eventId = this.getEventIds()[0];
		//launch Millennium viewer
		var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
		logger.logDiscernInfo(null, "PVVIEWERMPAGE", "pathology-viewer-handler.js", "launchMillenniumViewer");
		viewerObj.CreateAPViewer();
		viewerObj.AppendAPEvent(eventId, peventId);
		viewerObj.LaunchAPViewer();
	} catch (err) {
		logger.logJSError(err, null, "pathology-viewer-handler.js", "PathologyViewerHandler.launchMillenniumViewer");
	}
};


/**
 * Helper functions
 */

/**
 * It renders the content for the viewer when data requisition finishes.
 * @param {ScriptReply} replyObj ScriptReply object for the data requisition.
 */
PathologyViewerHandler.prototype.renderPathViewer = function(replyObj) {
	try {
		var pathViewerModalI18n = i18n.discernabu.mpage_result_viewer.pathology_modal;
		var pathModalObject = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
		var pathModalId = pathModalObject.getBodyElementId();

		var self = this;
		this.m_dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

		this.m_recordData = replyObj.getResponse();
		if (this.m_recordData && replyObj.getStatus() === "F") {
			logger.logError("Error retrieving reply in renderPathViewer, pathology-viewer-handler.js");
			return;
		}

		this.m_personnelArray = MP_Util.LoadPersonelListJSON(this.m_recordData.PRSNL);

		pathModalObject.setBodyHTML(this.generateTabHtml());
		$('#pathModalDialogheader').css("border", "0px");
		$("#pathModalDialogbody").css({
			"border-bottom" : "1px solid #ABADB3",
			"border-left" : "1px solid #ABADB3",
			"border-right" : "1px solid #ABADB3"
		});

		var allTabs = "#tabContainer .mrv-tabs ul li";
		$('#pathViewerTab_0').addClass("mrv-tab-active-header");

		//Allow user to switch the tab. The following code will hide/show tabs accordingly
		$(allTabs).on("click", function() {
			var $activeTab = $(this.parentElement).find(".mrv-tab-active-header");
			var activeTabId = $activeTab.attr("id");
			var curTabId = this.id;

			$activeTab.removeClass("mrv-tab-active-header");
			$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
			$(this).addClass("mrv-tab-active-header");
			$("#curTabId").show();
			var pathModalDialogBodyObj = $('#pathModalDialogbody');

			if (curTabId === "pathViewerTab_0") {
				self.setImageInd(false);
				pathModalDialogBodyObj.find(".mrv-path-report-tab").show();
				pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").hide();
				pathModalDialogBodyObj.find(".mrv-path-comments-tab").hide();
				pathModalDialogBodyObj.find(".mrv-path-image-tab").hide();
				$("#iframeImageId").css("visibility", "hidden");
			} else if (curTabId === "pathViewerTab_3") {
				self.setImageInd(false);
				pathModalDialogBodyObj.find(".mrv-path-comments-tab").show();
				pathModalDialogBodyObj.find("mrv-path-comments-info").show();
				$("#pathCommentsInfoId").removeClass("hidden");
				pathModalDialogBodyObj.find(".mrv-path-report-tab").hide();
				pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").hide();
				pathModalDialogBodyObj.find(".mrv-path-image-tab").hide();
				$("#iframeImageId").css("visibility", "hidden");
			}

			//TODO could simplify the logic here
			var imageUrl = self.getImageUrl();
			var imageInd = self.getImageInd();
			if (imageUrl) {
				if (curTabId === "pathViewerTab_1") {
					if (imageInd) {
						var iframeObj = document.getElementById('iframeImageId');
						iframeObj.src = imageUrl;
						var url0 = iframeObj.src.split('?')[0];
						var q = "?";
						var urlLen = iframeObj.src.split('?')[1].length;
						var url1 = iframeObj.src.split('?')[1].slice(1, urlLen);
						iframeObj.src = url0 + q + url1;
					}
					pathModalDialogBodyObj.find(".mrv-path-report-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-comments-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-image-tab").show();
					$("#iframeImageId").css("visibility", "visible");
				} else if (curTabId === "pathViewerTab_2") {
					self.setImageInd(false);
					pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").show();
					pathModalDialogBodyObj.find("mrv-path-actionlist-info").show();
					$("#pathActionListInfoId").removeClass("hidden");
					pathModalDialogBodyObj.find(".mrv-path-report-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-comments-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-image-tab").hide();
					$("#iframeImageId").css("visibility", "hidden");
				}
			} else {
				if (curTabId === "pathViewerTab_1") {
					pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").show();
					pathModalDialogBodyObj.find("mrv-path-actionlist-info").show();
					$("#pathActionListInfoId").removeClass("hidden");
					pathModalDialogBodyObj.find(".mrv-path-report-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-comments-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-image-tab").hide();
					$("#iframeImageId").css("visibility", "hidden");
				} else if (curTabId === "pathViewerTab_2") {
					pathModalDialogBodyObj.find(".mrv-path-comments-tab").show();
					pathModalDialogBodyObj.find("mrv-path-comments-info").show();
					$("#pathCommentsInfoId").removeClass("hidden");
					pathModalDialogBodyObj.find(".mrv-path-report-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-actionlist-tab").hide();
					pathModalDialogBodyObj.find(".mrv-path-image-tab").hide();
					$("#iframeImageId").css("visibility", "hidden");
				}
			}
		});
	} catch(err) {
		logger.logJSError(err, this, "pathology-viewer-handler.js", "renderPathologyViewer");
	}
};

/**
 * This function create the HTML string for the Action List tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Action List tab
 */
PathologyViewerHandler.prototype.buildActionListTabHTML = function(eventRBListObj) {
	var pathViewerModalI18n = i18n.discernabu.mpage_result_viewer.pathology_modal;
	var actionListTabHTML = [];
	var actionListLen = 0;
	var actionDtTm = "";
	var requestDtTm = "";
	var actionListItem = null;
	var emptyCell = "--";
	var provider = null;
	var actionProviderName = "";
	var actionListRequestedBy = null;
	var actionListRequestedByName = "";
	var proxy = null;
	var proxyName = "";
	var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

	actionListTabHTML.push("<div class ='mrv-path-actionlist-info hidden' id = 'pathActionListInfoId'><div class = 'mrv-path-table-div'><table class='mrv-path-actionlist-table'><tr><th>", pathViewerModalI18n.ACTION, "</th><th>", pathViewerModalI18n.ACTION_PERFORMED_BY, "</th><th>", pathViewerModalI18n.PERFORMED_DATE, "</th><th>", pathViewerModalI18n.ACTION_STATUS, "</th><th>", pathViewerModalI18n.COMMENT, "</th><th>", pathViewerModalI18n.PROXY_PERSONNEL, "</th><th>", pathViewerModalI18n.ACTION_REQUESTED_BY, "</th><th>", pathViewerModalI18n.REQUESTED_DATE, "</th><th>", pathViewerModalI18n.REQUEST_COMMENT, "</th></tr>");
	actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
	for (var alIndex = 0; alIndex < actionListLen; alIndex++) {
		actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
		actionDtTm = "";
		requestDtTm = "";
		var actionDate = actionListItem.ACTION_DT_TM.substr(6, 4);
		var reqDate = actionListItem.REQUEST_DT_TM.substr(6, 4);
		if (actionDate > 0) {
			actionDtTm = this.m_dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}

		if (reqDate > 0) {
			requestDtTm = this.m_dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}

		provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, this.m_personnelArray);
		actionProviderName = (provider === null) ? "" : provider.fullName;
		actionListRequestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, this.m_personnelArray);
		actionListRequestedByName = (actionListRequestedBy === null) ? "" : actionListRequestedBy.fullName;
		proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, this.m_personnelArray);
		proxyName = (proxy === null) ? "" : proxy.fullName;

		actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", actionListRequestedByName ? actionListRequestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
		if (actionListItem.ACTION_TYPE_CD === this.m_recordData.ACTION_TYPE_CDS.ORDER_CD) {
			this.m_requestedBy = actionProviderName;
			this.m_receivedDate = actionDtTm;
		}

		if (actionListItem.ACTION_TYPE_CD === this.m_recordData.ACTION_TYPE_CDS.VERIFY_CD) {
			this.m_verifiedDate = actionDtTm;
		}
	}
	actionListTabHTML.push("</table></div></div>");
	return actionListTabHTML.join("");
};

/**
 * This function create the HTML string for the Comments tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Comments tab
 */
PathologyViewerHandler.prototype.buildCommentsTabHTML = function(eventRBListObj) {
	var pathViewerModalI18n = i18n.discernabu.mpage_result_viewer.pathology_modal;
	var commentsTabHTML = [];
	var noteListItem = null;
	var provider = null;
	var commentProviderName = "";
	commentsTabHTML.push("<div class ='mrv-path-comments-info hidden' id = 'pathCommentsInfoId'>");
	var noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
	if (noteListLen > 0) {
		for (var noteIndex = 0; noteIndex < noteListLen; noteIndex++) {
			noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
			provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, this.m_personnelArray);
			commentProviderName = (provider === null) ? "" : provider.fullName;
			commentsTabHTML.push("<div class = 'mrv-path-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", pathViewerModalI18n.BY, " ", commentProviderName, " ", pathViewerModalI18n.ON, " ", this.m_dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
			commentsTabHTML.push("<div class = 'mrv-path-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
		}
	} else {
		commentsTabHTML.push("<div class = 'mrv-path-nocomments-text'>" + pathViewerModalI18n.NO_COMMENTS + "</div>");
	}
	return commentsTabHTML.join("");
};

/**
 * Generate HTML for the current tab
 * @return {string} HTML string of the tab
 */
PathologyViewerHandler.prototype.generateTabHtml = function() {
	try {
		var pathViewerModalI18n = i18n.discernabu.mpage_result_viewer.pathology_modal;
		var htmlArray = [];
		var jsonRBList = this.m_recordData.RB_LIST[0];
		var pathReportDetailsLength = jsonRBList.CHILD_EVENT_LIST.length;
		var blobsLength = this.m_recordData.BLOBS.length;
		var noteBlobLength = this.m_recordData.NOTE_BLOB.length;
		var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
		var reportHTML = [];
		var reportTitleLine = "";
		var reportNoteLine = "";
		var reportHTMLDisplay = [];
		var emptyData = "--";
		var rptCase = "";
		var rptRequestedBy = "";
		var rptCollected = "";
		var rptLocation = "";
		var rptReport = "";
		var rptPerformedBy = "";
		var rptReceived = "";
		var rptStatus = "";
		var rptVerified = "";
		var rptActionList = [];
		var rptComments = [];
		var imageUrl = this.m_recordData.PATH_IMAGES.IMAGE_URL ? this.m_recordData.PATH_IMAGES.IMAGE_URL : "";
		this.setImageUrl(imageUrl);
		this.setImageInd(true);

		if (pathReportDetailsLength > 0) {
			var jsonChildEventList = jsonRBList.CHILD_EVENT_LIST[0];
			var jsonResultDetails = this.m_recordData.PAT_ENCNTR_DETAILS;
			rptActionList = this.buildActionListTabHTML(jsonRBList);
			rptComments = this.buildCommentsTabHTML(jsonRBList);

			rptCase = (jsonChildEventList.EVENT_TAG) ? jsonChildEventList.EVENT_TAG : emptyData;
			rptRequestedBy = (this.m_requestedBy) ? this.m_requestedBy : emptyData;
			rptCollected = (jsonResultDetails.RESULT_DATE) ? df.formatISO8601(jsonResultDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;
			rptLocation = (jsonResultDetails.INSTITUTION_DISP) ? jsonResultDetails.INSTITUTION_DISP : emptyData;
			rptReport = (jsonResultDetails.RESULT_TITLE) ? jsonResultDetails.RESULT_TITLE : emptyData;
			rptPerformedBy = (jsonResultDetails.VERIFIED_FULL) ? jsonResultDetails.VERIFIED_FULL : emptyData;
			rptReceived = (this.m_receivedDate) ? this.m_receivedDate : emptyData;
			rptStatus = (jsonResultDetails.RESULT_STATUS) ? jsonResultDetails.RESULT_STATUS : emptyData;
			rptVerified = (this.m_verifiedDate) ? this.m_verifiedDate : emptyData;
		}

		if (blobsLength > 0) {
			for (var b = 0; b < blobsLength; b++) {
				var childNoteListLen = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST.length;
				reportTitleLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_TITLE_TEXT;
				reportHTML.push("<br><span class='mrv-path-blob-title'>" + reportTitleLine + "</span><br>");
				reportHTML.push(this.m_recordData.BLOBS[b].BLOB_HTML);

				for (var n = 0; n < childNoteListLen; n++) {
					reportNoteLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST[0].LONG_BLOB_TXT;
					reportHTML.push("<br><span>" + reportNoteLine + "</span><br>");
				}
				reportHTMLDisplay = reportHTML.join("");
			}
		}

		htmlArray.push("<div class='mrv-path-header'>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.CASE + "</dt><dd class='mrv-path-res-value'>" + rptCase + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.REQUESTED_BY + "</dt><dd class='mrv-path-res-value'>" + rptRequestedBy + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.COLLECTED + "</dt><dd class='mrv-path-res-value'>" + rptCollected + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.VERIFIED + "</dt><dd class='mrv-path-res-value'>" + rptVerified + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.REPORT + "</dt><dd class='mrv-path-res-value'>" + rptReport + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.PERFORMED_BY + "</dt><dd class='mrv-path-res-value'>" + rptPerformedBy + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.RECEIVED + "</dt><dd class='mrv-path-res-value'>" + rptReceived + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.LOCATION + "</dt><dd class='mrv-path-res-value'>" + rptLocation + "</dd></dl>" + "<dl class='mrv-path-note-type'><dt class='mrv-path-name'>" + pathViewerModalI18n.STATUS + "</dt><dd class='mrv-path-res-value'>" + rptStatus + "</dd></dl>" + "</div>");

		htmlArray.push('<div class="mrv-path-tab-container" id="tabContainer"><div class="mrv-tabs"><ul>');

		var numTabs;
		var resultTitle = this.m_recordData.PAT_ENCNTR_DETAILS.RESULT_TITLE ? this.m_recordData.PAT_ENCNTR_DETAILS.RESULT_TITLE : "";
		var tabNames = [resultTitle, pathViewerModalI18n.IMAGES, pathViewerModalI18n.ACTION_LIST, pathViewerModalI18n.COMMENTS];
		//Remove the image tab (2nd one in the array) if imageUrl is not available
		if (!imageUrl) {
			tabNames.splice(1, 1);
		}
		numTabs = tabNames.length;

		for (var i = 0; i < numTabs; i++) {
			htmlArray.push('<li id="pathViewerTab_', i, '"><span class="mrv-tab-left-edge">&nbsp;</span><span class="mrv-tab-text">', tabNames[i], '</span><span class="mrv-tab-right-edge">&nbsp;</span></li>');
		}
		htmlArray.push('</ul></div><hr /><div class="mrv-path-tabs-content">');
		if (imageUrl) {
			htmlArray.push("<div class='tabs'>" + "<ul>" + "<li id='tab1'></li>" + "<li id='tab2'></li>" + "<li id='tab3'></li>" + "<li id='tab4'></li>" + "</ul>" + "</div>" + "<div class='mrv-path-report-tab' id='tab-sec-1'>" + "<dl class='mrv-path-smry-data'><dt class='mrv-path-res-type'></dt><dd class='mrv-path-smry-value'>" + reportHTMLDisplay + "</dd></dl>" + "</div>" + "<div class='mrv-path-image-tab' id='tab-sec-2'>" + "<iframe id='iframeImageId' style= 'visibility:hidden;' src='" + imageUrl + "' width='100%' height='700'></iframe>" + "</div>" + "<div class='mrv-path-actionlist-tab' id='tab-sec-3'>", rptActionList, "</div>" + "<div class='mrv-path-comments-tab' id='tab-sec-4'>", rptComments, "</div></div>");

			htmlArray.push('</div>');
			htmlArray.push("</div></div>");
			this.initMediaViewer();
		} else {
			htmlArray.push("<div class='tabs'>" + "<ul>" + "<li id='tab1'></li>" + "<li id='tab3'></li>" + "<li id='tab4'></li>" + "</ul>" + "</div>" + "<div class='mrv-path-report-tab' id='tab-sec-1'>" + "<dl class='mrv-path-smry-data'><dt class='mrv-path-res-type'></dt><dd class='mrv-path-smry-value'>" + reportHTMLDisplay + "</dd>" + "</div>" + "<div class='mrv-path-actionlist-tab' id='tab-sec-3'>" + "<span class='mrv-path-tab-content'>" + rptActionList + "</span>" + "</div>" + "<div class='mrv-path-comments-tab' id='tab-sec-4'>" + "<span class='mrv-path-tab-content'>" + rptComments + "</span>" + "</div>");

			htmlArray.push('</div>');
			htmlArray.push("</div></div>");
		}
		var hxHTML = htmlArray.join("");
		return hxHTML;
	} catch(err) {
		logger.logJSError(err, this, "pathology-viewer-handler.js", "generateTabHtml");
	}
};
/**
 * @class
 * This ProcedureViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display group results.
 * Launching Millennium viewer requires fields:
 *   - Event ID Array (with one or multiple Event IDs)
 * Launching Web viewer requires fields:
 *   * Yet to implement
 */
var ProcedureViewerHandler = function() {
};

ProcedureViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
ProcedureViewerHandler.prototype.validateRequiredFields = function() {
	var patientId = this.getPatientId();
	//it has to be a non-negative number
	if (typeof patientId !== "number" || patientId < 0) {
		throw new Error("ProcedureViewerHandler requires patientId to launch the viewer");
	}

	var eventIdArray = this.getEventIds();
	//should have at least one event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("ProcedureViewerHandler requires at least one event ID to launch the viewer");
	}
};

/**
 * Function ProcedureViewerHandler.prototype.launchWebViewer launches web modal dialog viewer in non-Millennium platform to display the clinical result.
 * It is yet to be implemented. When it is called, it will use the AbstractViewerHandler's default implementation, which will launch a modal dialog
 * that displays an error message that the result can't be viewed. 
 */
 
/**
 * It launches Millennium viewer in Millennium platform to display the clinical result.
 */
ProcedureViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var patientId = this.getPatientId();

		var eventIdArray = this.getEventIds();

		//launch Millennium viewer
		var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
		logger.logDiscernInfo(null, "PVVIEWERMPAGE", "procedure-viewer-handler.js", "launchMillenniumViewer");
		viewerObj.CreateProcViewer(patientId);

		for (var x = eventIdArray.length; x--; ) {
			viewerObj.AppendProcEvent(eventIdArray[x]);
		}

		viewerObj.LaunchProcViewer();
	} catch (err) {
		logger.logJSError(err, null, "procedure-viewer-handler.js", "ProcedureViewerHandler.launchMillenniumViewer");
	}
};
/**
 * @class
 * This ReminderViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display group results.
 * Launching Millennium viewer requires fields:
 *   - Event ID Array (with only one Event ID)
 * Launching Web viewer requires fields:
 *   * Yet to implement
 */
var ReminderViewerHandler = function() {

};

ReminderViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
ReminderViewerHandler.prototype.validateRequiredFields = function() {
	var eventIdArray = this.getEventIds();
	//only accept a single event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("ReminderViewerHandler requires a valid single event ID to launch the viewer");
	}

	if (eventIdArray.length > 1) {
		throw new Error("ReminderViewerHandler only needs one event ID to launch the view");
	}
};

/**
 * Function ReminderViewerHandler.prototype.launchWebViewer launches web modal dialog viewer in non-Millennium platform to display the clinical result.
 * It is yet to be implemented. When it is called, it will use the AbstractViewerHandler's default implementation, which will launch a modal dialog
 * that displays an error message that the result can't be viewed. 
 */

 
/**
 * It launches Millennium viewer in Millennium platform to display the clinical result.
 */
ReminderViewerHandler.prototype.launchMillenniumViewer = function() {
	try {
		var eventId = this.getEventIds()[0];

		//launch Millennium viewer
		var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
		logger.logDiscernInfo(null, "PVVIEWERMPAGE", "reminder-viewer-handler.js", "launchMillenniumViewer");
		viewerObj.LaunchRemindersViewer(eventId);
	} catch (err) {
		logger.logJSError(err, null, "reminder-viewer-handler.js", "ReminderViewerHandler.launchMillenniumViewer");
	}
};
/**
 * @class
 * This ResultViewerHandler object extends the base viewer handler AbstractViewerHandler.
 * It implements functions of launching Millennium/Web viewer to display clinical results.
 * Launching Millennium viewer requires fields:
 *   - Patient ID
 *   - Event ID Array (with one or multiple Event IDs)
 * Launching Web viewer requires fields:
 *   - Event ID Array (with one or multiple Event IDs)
 *   - Result Name
 */
var ResultViewerHandler = function() {
	this.m_recordData = null;

	this.m_specimenFound = false;
	this.m_commentsFound = false;
	this.m_dateFormatter = null;
	this.m_personnelArray = [];
	this.m_eventIndex = 0;
	this.m_eventCount = 0;	
};

ResultViewerHandler.prototype = new AbstractViewerHandler();

/**
 * It will validate whether the viewer handler has all the required fields.
 * It will fail hard with Error thrown out when a required field is not set correctly.
 */
ResultViewerHandler.prototype.validateRequiredFields = function() {
	var eventIdArray = this.getEventIds();
	var patientId = this.getPatientId();
	var resultName = this.getResultName();

	//should have at least one event ID
	if (!this.validateEventIdArray(eventIdArray)) {
		throw new Error("ResultViewerHandler requires at least one event ID to launch the viewer");
	}

	//Validate Millennium viewer related fields
	if (this.m_millenniumInd) {
		//it has to be a non-negative number
		if (typeof patientId !== "number" || patientId < 0) {
			throw new Error("ResultViewerHandler requires patientId to launch the viewer");
		}
	} else {
		//Validate web viewer related fields
		if ( typeof resultName !== "string") {
			throw new Error("ResultViewerHandler requires valid resultName to launch the viewer");
		}
	}
};

/**
 * It launches web modal dialog viewer in non-Millennium platform to display the clinical result.
 */
ResultViewerHandler.prototype.launchWebViewer = function() {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var eventIdArray = this.getEventIds();
	var eventIdStr = MP_Util.CreateParamArray(eventIdArray, 1);
	var self = this;
	var multipleEventsFound = (eventIdArray.length>1)?true:false;
	this.m_eventCount = eventIdArray.length;
	

	var resultName = this.getResultName();
	if (!resultName) {
		resultName = resViewModalI18n.RESULT_DETAILS;
	}

	var resultViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
	if (!resultViewerModalObj) {
		resultViewerModalObj = new ModalDialog("resultViewer");
		var resViewerCloseBtn = new ModalButton("resViewerCloseBtn");
		resViewerCloseBtn.setText(resViewModalI18n.CLOSE);
		resViewerCloseBtn.setFocusInd(true).setOnClickFunction(function(){		
		MP_ModalDialog.closeModalDialog("resultViewer");
		MP_ModalDialog.deleteModalDialogObject("resultViewer");
		});
		if (multipleEventsFound) {
			var resViewerPrevBtn = new ModalButton("resViewerPrevBtn");
			resViewerPrevBtn.setText("< "+resViewModalI18n.PREVIOUS).setOnClickFunction(function(){self.retrievePreviousResultData();});	
			resViewerPrevBtn.setIsDithered(true).setFocusInd(false).setCloseOnClick(false);	
		
			var resViewerNextBtn = new ModalButton("resViewerNextBtn");
			resViewerNextBtn.setText(resViewModalI18n.NEXT+" >").setOnClickFunction(function(){self.retrieveNextResultData();});			
			resViewerNextBtn.setIsDithered(false).setFocusInd(false).setCloseOnClick(false).setSeparatorInd(true);
			resultViewerModalObj.addFooterButton(resViewerPrevBtn).addFooterButton(resViewerNextBtn).addFooterButton(resViewerCloseBtn);
			resultViewerModalObj.setFooterText(resViewModalI18n.RESULT_OF.replace("{0}","1").replace("{1}",this.m_eventCount));
		}
		else {
			 resultViewerModalObj.addFooterButton(resViewerCloseBtn);
		}
		resultViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(15).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
		resultViewerModalObj.setHeaderTitle(resultName).setHeaderCloseFunction(function(){
           MP_ModalDialog.closeModalDialog("resultViewer");
           MP_ModalDialog.deleteModalDialogObject("resultViewer");
        });
		
		
		MP_ModalDialog.addModalDialogObject(resultViewerModalObj);
	}

	resultViewerModalObj.setHeaderTitle(resultName);
	resultViewerModalObj.setBodyDataFunction(function(resultModalObj) {
		self.attachListeners();
		resultViewerModalObj.setBodyHTML("<div class = 'mrv-result-loading'></div>");

		var cclParams = [];
		cclParams.push("^MINE^", eventIdStr, 0, 1);
		self.loadWithCBParameters("mp_get_result_viewer_data", cclParams, function(replyObj) {
			self.renderResultViewer(replyObj);
		});
	});
	MP_ModalDialog.updateModalDialogObject(resultViewerModalObj);
	MP_ModalDialog.showModalDialog("resultViewer");
};
/**
 * This function is called when the "Previous button clicked.Increment/decrement event index,enable/disable next and previous buttons.
 */
ResultViewerHandler.prototype.retrievePreviousResultData = function() {		
	var eventIdArray = this.getEventIds();
	this.m_eventIndex = this.m_eventIndex - 1;
	if (this.m_eventIndex === 0) {
		$('#resViewerPrevBtn').attr("disabled", true);					
		}
	this.retrieveResultData(eventIdArray[this.m_eventIndex],this.m_eventIndex);
	$('#resViewerNextBtn').attr("disabled", false);		
};
/**
 * This function retrieves the eventid data when the "Next" button clicked if the result has multiple event id's
 */
ResultViewerHandler.prototype.retrieveNextResultData = function() {
	var eventIdArray = this.getEventIds();	
	this.m_eventIndex = this.m_eventIndex + 1;	
	if (this.m_eventIndex === this.m_eventCount-1) {
		$('#resViewerNextBtn').attr("disabled", true);					
	}
	this.retrieveResultData(eventIdArray[this.m_eventIndex],this.m_eventIndex);	
	$('#resViewerPrevBtn').attr("disabled", false);	
};
/**
 * It retrieves the eventid data when the "Previous"/"Next" buttons are clicked if the result has multiple event id's
 * @param {number} event Id Eventid of a result. 
 * @param {number} eventIndex Index of the multiple events of a result.
 */
ResultViewerHandler.prototype.retrieveResultData = function(eventId,eventIndex){
	var resultViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var cclParams = [];
	var self = this;
	this.attachListeners();	
	resultViewerModalObj.setBodyHTML("<div class = 'mrv-result-loading'></div>");	
	resultViewerModalObj.setFooterText(resViewModalI18n.RESULT_OF.replace("{0}",(eventIndex+1)).replace("{1}",this.m_eventCount));			
	cclParams.push("^MINE^", eventId+".0", 0, 1);
	self.loadWithCBParameters("mp_get_result_viewer_data", cclParams, function(replyObj) {
			self.renderResultViewer(replyObj);
	});
};

/**
 * It launches Millennium viewer in Millennium platform to display the clinical result.
 */
ResultViewerHandler.prototype.launchMillenniumViewer = function() {
	try{
		var patientId = this.getPatientId();
		var encounterId = this.getEncounterId();
		var eventIdArray = this.getEventIds();

		var editModeInd = this.getEditModeInd();
		var editorType = this.getEditorType();
		var activityId = this.getActivityId();

		//Enter the edit mode if editModeInd flag is true. Only Powerform results are supported in edit mode. 
		//If the flag is false, or the results are not supported in edit mode, it will use the normal readonly mode. 
		if(editModeInd && editorType==="POWERFORMS"){
			if (activityId){
				//launch the result in powerform if powerform activity id is available
				logger.logDiscernInfo(null, "POWERFORMS", "result-viewer-handler.js", "launchMillenniumViewer");
				CERN_Platform.getDiscernObject("POWERFORM").OpenForm(patientId, encounterId, 0, activityId, 0);
			}else{
				//If activityId is 0, it means the result is not directly associated to a powerform, so it will only log a warning. 
				logger.logWarning("The result can't be opened in edit mode. (result-viewer-handler.js)");
			}
		}else{
			//launch Millennium viewer in normal readonly mode
			var viewerObj = CERN_Platform.getDiscernObject("PVVIEWERMPAGE");
			logger.logDiscernInfo(null, "PVVIEWERMPAGE", "result-viewer-handler.js", "launchMillenniumViewer");
			viewerObj.CreateEventViewer(patientId);
			
			var eventIdLen = eventIdArray.length;

			for (var x = 0; x < eventIdLen; x++) {
				viewerObj.AppendEvent(eventIdArray[x]);
			}
			viewerObj.LaunchEventViewer();
		}
	} catch (err) {
		logger.logJSError(err, null, "result-viewer-handler.js", "ResultViewerHandler.launchMillenniumViewer");
	}
	
};

/**
 * It displays an error message in modal dialog
 * @param {string} message Message
 * @param {string} title Modal dialog title
 * @param {string} buttonText Button label
 */
ResultViewerHandler.prototype.alertError = function(message, title, buttonText) {
	var modalObj = MP_Util.generateModalDialogBody("resViewerFailureAlert", "error", message, "");
	var modalButton = modalObj.getFooterButton("modalOkBtn");
	if (!modalButton) {
		modalButton = new ModalButton("modalOkBtn");
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true).setOnClickFunction(function() {
			MP_ModalDialog.closeModalDialog("resultViewer");
		});
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
	}
	modalObj.setHeaderTitle(title);
	modalObj.setFooterButtonText("modalOkBtn", buttonText);
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("resViewerFailureAlert");
};

/**
 * This function create the HTML string for the Event History section which displays at the upper half of the modal dialog.
 * @return {string} HTML string of Event History section
 */
ResultViewerHandler.prototype.buildEventHistorySectionHTML = function() {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var eventHistoryHTML = [];
	var validFromDtTm = "";
	var validUntilDtTm = "";
	var normalcyClass = "";
	eventHistoryHTML.push("<div class = 'mrv-result-history-label' id = 'resViewHistLblId'>", resViewModalI18n.HISTORY, "</div>");
	eventHistoryHTML.push("<div class ='mrv-result-event-hist-info' id = 'resViewHistLblId'><div class = 'mrv-result-hist-table-div'>");
	eventHistoryHTML.push("<table class='mrv-result-actionlist-table'><tr><th>", resViewModalI18n.VALUE, "</th><th>", resViewModalI18n.VALID_FROM, "</th><th>", resViewModalI18n.VALID_UNTIL, "</th></tr>");
	var eventHistLength = this.m_recordData.EVENT_HIST_LIST.length;
	var zebraClass = "odd ";
	var firstRow = "";
	var resultValColorClass = "";
	var resVal = "";
	for (var ehIndex = 0; ehIndex < eventHistLength; ehIndex++) {
		var eventHistItem = this.m_recordData.RB_LIST[ehIndex];
		if (ehIndex === 0) {
			firstRow = "mrv-result-hist-select mrv-result-wht-text";
			resultValColorClass = "mrv-result-wht-text ";
		} else {
			firstRow = "";
			resultValColorClass = "";
		}

		zebraClass = (ehIndex % 2) ? "even " : "odd ";

		validFromDtTm = this.m_dateFormatter.formatISO8601(eventHistItem.VALID_FROM_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		validUntilDtTm = this.m_dateFormatter.formatISO8601(eventHistItem.VALID_UNTIL_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		if (ehIndex === 0) {
			validUntilDtTm = resViewModalI18n.CURRENT;
		}
		if (eventHistItem.DATE_RESULT.length) {
			resVal = this.m_dateFormatter.formatISO8601(eventHistItem.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		} else {
			resVal = this.formatNumber(eventHistItem.RESULT_VAL);
		}
		normalcyClass = this.GetNormalcyClass(eventHistItem.NORMALCY_CD_MEAN);
		eventHistoryHTML.push("<tr class = 'mrv-result-hist-info ", zebraClass, firstRow, "' eventRowIndex = ", ehIndex, "><td><span class='", resultValColorClass, normalcyClass, "'><span class='res-ind'></span>", resVal, "</span></td><td>", validFromDtTm, "</td><td>", validUntilDtTm, "</td>");
	}
	eventHistoryHTML.push("</table></div></div>");
	return eventHistoryHTML.join("");
};

/**
 * This function retrieves the CSS class for the given normalcy. Therefore the results will be displayed in different styles 
 * depending on their normalcy mean.   
 * @param {string} resultNormalcy Result Normalcy mean
 * @return {string} CSS class name for the given normalcy
 */
ResultViewerHandler.prototype.GetNormalcyClass = function(resultNormalcy) {
	var normalcy = "res-normal";
	var normalcyMeaning = resultNormalcy;
	if (normalcyMeaning) {
		switch (normalcyMeaning) {
			case "NORMAL":
				normalcy = "res-normal";
				break;
			case "LOW":
				normalcy = "res-low";
				break;
			case "HIGH":
				normalcy = "res-high";
				break;
			case "ABNORMAL":
				normalcy = "res-abnormal";
				break;
			case "CRITICAL":
			case "EXTREMEHIGH":
			case "PANICHIGH":
			case "EXTREMELOW":
			case "PANICLOW":
			case "VABNORMAL":
			case "POSITIVE":
				normalcy = "res-severe";
				break;
		}
	}
	return normalcy;
};

/**
 * This functions formats numbers with the correct decimal points in various languages. 
 * @param {number|string} value The number that will be formatted
 * @return {string} formatted number
 */
ResultViewerHandler.prototype.formatNumber = function(value) {
	var nf = MP_Util.GetNumericFormatter();
	return mp_formatter._isNumber(value) ? nf.format(value, "^." + MP_Util.CalculatePrecision(value)) : value;
};

/**
 * This function create the HTML string for the event details including the tabs and contents of each tab. 
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML content of the detail section
 */
ResultViewerHandler.prototype.buildEventDetailSectionHTML = function(eventRBListObj) {
	var eventDetailHTML = [];
	eventDetailHTML.push("<div class='mrv-result-detail' id='resViewDetail'>");
	eventDetailHTML.push("<div class='mrv-result-controls' id='resViewControls'>");
	eventDetailHTML.push(this.buildTabSectionHTML());
	eventDetailHTML.push("</div><div class='mrv-result-tab-body ' id='resViewBody'>");
	eventDetailHTML.push("<div class='mrv-result-body-container' id='resViewTabBodyId'>");
	eventDetailHTML.push(this.buildDetailsTabHTML(eventRBListObj));
	eventDetailHTML.push(this.buildActionListTabHTML(eventRBListObj));
	if (this.m_specimenFound) {
		eventDetailHTML.push(this.buildSpecimenTabHTML(eventRBListObj));
	}
	if (this.m_commentsFound) {
		eventDetailHTML.push(this.buildCommentsTabHTML(eventRBListObj));
	}
	eventDetailHTML.push("</div></div></div>");
	return eventDetailHTML.join("");
};

/**
 * This function create the HTML string the tab section including details, specimen, action list and comments. 
 * @return {string} HTML string of the tab section
 */
ResultViewerHandler.prototype.buildTabSectionHTML = function() {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var tabHTML = [];
	tabHTML.push("<span class = 'mrv-result-tab-bg-left mrv-result-tab-container'></span><div  class='mrv-result-tab-container mrv-result-tab-active' id='resViewTab1' tabtext = '", resViewModalI18n.DETAILS, "'><span class = 'mrv-result-tab-active-left'></span><span class = 'mrv-result-tab-active-center'><div class='mrv-result-tab-active-label'>", resViewModalI18n.DETAILS, "</div></span><span class = 'mrv-result-tab-active-right'></span></div><span id = 'rvDetSepId' class='mrv-result-tab-sep hidden'></span>");
	if (this.m_specimenFound) {
		tabHTML.push("<div  class='mrv-result-tab-container mrv-result-tab-inactive' id='resViewTab2' tabtext = '", resViewModalI18n.SPECIMEN, "'><div class='mrv-result-tab-inactive-label'>", resViewModalI18n.SPECIMEN, "</div></div><span id = 'rvSpecimenSepId' class='mrv-result-tab-sep'></span>");
	}
	tabHTML.push("<div class='mrv-result-tab-container mrv-result-tab-inactive' id='resViewTab3' tabtext = '", resViewModalI18n.ACTION_LIST, "'><div class='mrv-result-tab-inactive-label'>", resViewModalI18n.ACTION_LIST, "</div></div><span id = 'rvActionSepId' class='mrv-result-tab-sep'></span>");
	if (this.m_commentsFound) {
		tabHTML.push("<div  class='mrv-result-tab-container mrv-result-tab-inactive' id='resViewTab4' tabtext = '", resViewModalI18n.COMMENTS, "'><div class='mrv-result-tab-inactive-label'>", resViewModalI18n.COMMENTS, "</div></div><span id = 'rvCommentsSepId' class='mrv-result-tab-sep'></span>");
	}

	return tabHTML.join("");
};

/**
 * This function create the HTML string for the Details tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Details tab
 */
ResultViewerHandler.prototype.buildDetailsTabHTML = function(eventRBListObj) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var detailsTabHTML = [];
	var eventDtTm = "";
	var resVal = "";
	var normalcyClass = this.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);
	eventDtTm = this.m_dateFormatter.formatISO8601(eventRBListObj.EVENT_END_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
	if (eventRBListObj.DATE_RESULT.length) {
		resVal = this.m_dateFormatter.formatISO8601(eventRBListObj.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
	} else {
		resVal = this.formatNumber(eventRBListObj.RESULT_VAL);
	}
	detailsTabHTML.push("<div class ='mrv-result-details-info' id = 'rvDetailsInfoId'><div class = 'mrv-result-tt'><span><h2 class='mrv-result-resval'><span class = 'mrv-result-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span class='mrv-result-pad ", normalcyClass, "'><span class = 'res-ind'></span>", resVal, " ", "</span><span>", eventRBListObj.RESULT_UNITS_CD_DISP ? eventRBListObj.RESULT_UNITS_CD_DISP : "", "</span></h2></span></div>");
	detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.DATE_TIME, ":</dd><dd class = 'mrv-result-event-data'>", eventDtTm, "</dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.NORMAL_LOW, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.NORMAL_LOW, "</dd></dl>");
	detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.CONTRIBUTE_SYSTEM, ":</dd><dd class = 'mrv-result-event-data'>", eventRBListObj.CONTRIBUTOR_SYSTEM_CD_DISP, "</dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.NORMAL_HIGH, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.NORMAL_HIGH, "</dd></dl>");
	if (this.m_specimenFound) {
		detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.ACCESSION_NUMBER, ":</dd><dd class = 'mrv-result-event-data'>", eventRBListObj.ACCESSION_NBR, "</dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
		detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.SERVICE_RESOURCE, ":</dd><dd class = 'mrv-result-event-data'>", eventRBListObj.RESOURCE_CD_DISP, "</dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
		detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'mrv-result-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd>");
	} else {
		detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'mrv-result-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
		detailsTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'></dd><dd class = 'mrv-result-event-data'></dd><dd class = 'mrv-result-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'mrv-result-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
	}
	detailsTabHTML.push("</div>");
	return detailsTabHTML.join("");
};


/**
 * This function create the HTML string for the Action List tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Action List tab
 */
ResultViewerHandler.prototype.buildActionListTabHTML = function(eventRBListObj) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var actionListTabHTML = [];
	var actionListLen = 0;
	var actionDtTm = "";
	var requestDtTm = "";
	var actionListItem = null;
	var emptyCell = "--";
	var provider = null;
	var actionProviderName = "";
	var requestedByName = "";
	var requestedBy = null;
	var proxyName = "";
	var proxy = null;
	var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";

	actionListTabHTML.push("<div class ='mrv-result-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'mrv-result-table-div'><table class='mrv-result-actionlist-table'><tr><th>", resViewModalI18n.ACTION, "</th><th>", resViewModalI18n.PERFORMED_BY, "</th><th>", resViewModalI18n.PERFORMED_DATE, "</th><th>", resViewModalI18n.ACTION_STATUS, "</th><th>", resViewModalI18n.COMMENT, "</th><th>", resViewModalI18n.PROXY_PERSONNEL, "</th><th>", resViewModalI18n.REQUESTED_BY, "</th><th>", resViewModalI18n.REQUESTED_DATE, "</th><th>", resViewModalI18n.REQUEST_COMMENT, "</th></tr>");
	actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
	for (var alIndex = 0; alIndex < actionListLen; alIndex++) {
		actionDtTm = "";
		requestDtTm = "";
		actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
		if (actionListItem.ACTION_DT_TM !== invalidDate) {
			actionDtTm = this.m_dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
		}
		if (actionListItem.REQUEST_DT_TM !== invalidDate) {
			requestDtTm = this.m_dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);

		}
		provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, this.m_personnelArray);
		actionProviderName = (provider === null) ? "" : provider.fullName;
		requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, this.m_personnelArray);
		requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
		proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, this.m_personnelArray);
		proxyName = (proxy === null) ? "" : proxy.fullName;
		actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
	}
	actionListTabHTML.push("</table></div></div>");
	return actionListTabHTML.join("");
};

/**
 * This function create the HTML string for the Specimen tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Specimen tab
 */
ResultViewerHandler.prototype.buildSpecimenTabHTML = function(eventRBListObj) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var specimenTabHTML = [];
	var specimenCollObj = null;
	var specimenCollectedDtTm = "";
	var normalcyClass = this.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);
	specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
	specimenCollectedDtTm = this.m_dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
	specimenTabHTML.push("<div class ='mrv-result-specimen-info hidden' id = 'rvSpecimenInfoId'><div class = 'mrv-result-tt'><span><h2 class='mrv-result-resval'><span class = 'mrv-result-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='mrv-result-pad ", normalcyClass, "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
	specimenTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'mrv-result-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP, "</dd></dl>");
	specimenTabHTML.push("<dl class = 'mrv-result-event-info'><dd class = 'mrv-result-event-hd'>", resViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'mrv-result-event-data'>", specimenCollectedDtTm, "</dd></dl>");
	specimenTabHTML.push("</div>");
	return specimenTabHTML.join("");
};


/**
 * This function create the HTML string for the Comments tab.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of Comments tab
 */
ResultViewerHandler.prototype.buildCommentsTabHTML = function(eventRBListObj) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var commentsTabHTML = [];
	var noteListItem = null;
	var provider = null;
	var commentProviderName = "";
	commentsTabHTML.push("<div class ='mrv-result-comments-info hidden' id = 'rvCommentsInfoId'>");
	var noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
	for (var noteIndex = 0; noteIndex < noteListLen; noteIndex++) {
		noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
		provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, this.m_personnelArray);
		commentProviderName = (provider === null) ? "" : provider.fullName;
		commentsTabHTML.push("<div class ='mrv-result-comments-section'>");
		commentsTabHTML.push("<div class = 'mrv-result-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", resViewModalI18n.BY, " ", commentProviderName, " ", resViewModalI18n.ON, " ", this.m_dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
		commentsTabHTML.push("<div class = 'mrv-result-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
		commentsTabHTML.push("</div>");
	}
	commentsTabHTML.push(this.buildFlagCommentsHTML(eventRBListObj));	
	return commentsTabHTML.join("");
};

/**
 * This function creates the HTML string for the flag Comments section.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {string} HTML string of flag comments section
 */
ResultViewerHandler.prototype.buildFlagCommentsHTML = function(eventRBListObj) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var flagCommentsHTML = [];
	var prsnlListItem = null;
	var provider = null;
	var commentProviderName = "";
	var displayCount = 0;
	var codeValue = null;
	var personalEventLength = eventRBListObj.EVENT_PRSNL_LIST.length;
	flagCommentsHTML.push("<div>");
	for (var noteIndex = 0; noteIndex < personalEventLength; noteIndex++) {
		prsnlListItem = eventRBListObj.EVENT_PRSNL_LIST[noteIndex];		
		codeValue = MP_Util.GetValueFromArray(prsnlListItem.ACTION_TYPE_CD, this.m_codeValueArray);
		if(codeValue.meaning === "FLAG" || codeValue.meaning === "UNFLAG") {
			displayCount++;
			provider = MP_Util.GetValueFromArray(prsnlListItem.ACTION_PRSNL_ID, this.m_personnelArray);
			commentProviderName = (provider === null) ? "" : provider.fullName;
			flagCommentsHTML.push("<div class = 'mrv-result-comment-hd-text'>", displayCount, ".) " + codeValue.display, " ", resViewModalI18n.BY, " ", commentProviderName, " ", resViewModalI18n.ON, " ", this.m_dateFormatter.formatISO8601(prsnlListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
			flagCommentsHTML.push("<div class = 'mrv-result-comment-text'>", prsnlListItem.ACTION_COMMENT, "</div>");
		}
	}
	if (displayCount > 0) {
		flagCommentsHTML[0] = "<div class ='mrv-result-comments-section'>";
	} 
	
	flagCommentsHTML.push("</div>");
	return flagCommentsHTML.join("");
};

/**
 * This function to find out either a comments or flag comments are set for the event.
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {boolean} true or false
 */
ResultViewerHandler.prototype.isCommentOrFlagCommentSet = function(eventRBListObj) {
	return eventRBListObj.EVENT_NOTE_LIST.length || this.isFlagCommentSet(eventRBListObj);
};

/**
 * This function to return true if it finds the flag comments from EVEN_PRSNL_LIST
 * @param {Object} eventRBListObj JSon Reply's result block list
 * @return {boolean} true or false
 */
ResultViewerHandler.prototype.isFlagCommentSet = function(eventRBListObj) {
	var eventPrsnlItem = null;
	var eventCode = null;
	var codeValue = null;
	var personalEventLength = eventRBListObj.EVENT_PRSNL_LIST.length;
	for (var noteIndex = 0; noteIndex < personalEventLength; noteIndex++) {
		eventPrsnlItem = eventRBListObj.EVENT_PRSNL_LIST[noteIndex];
		codeValue = MP_Util.GetValueFromArray(eventPrsnlItem.ACTION_TYPE_CD, this.m_codeValueArray);
		if(codeValue.meaning === "FLAG" || codeValue.meaning === "UNFLAG") {
			return true;
		}
	}
	return false;
}; 

/**
 * It renders the content for the viewer when data requisition finishes.
 * @param {ScriptReply} response ScriptReply object for the data requisition.
 */
ResultViewerHandler.prototype.renderResultViewer = function(response) {
	var resViewModalI18n = i18n.discernabu.mpage_result_viewer.result_modal;
	var resViewModalBodyHTML = [];
	var resViewModalObject = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
	var resViewModalId = resViewModalObject.getBodyElementId();
	this.m_dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
	this.m_recordData = response.getResponse();
	if (this.m_recordData) {
		if (response.getStatus() === "F") {
			this.alertError(resViewModalI18n.ERROR_RETRIEVE, resViewModalI18n.ERROR_TITLE, resViewModalI18n.OK);
			return;
		}
	}
	this.m_personnelArray = MP_Util.LoadPersonelListJSON(this.m_recordData.PRSNL);
	this.m_codeValueArray = MP_Util.LoadCodeListJSON(this.m_recordData.CODES);
	this.m_specimenFound = false;
	this.m_commentsFound = false;
	if (this.m_recordData.RB_LIST[0].SPECIMEN_COLL.length) {
		this.m_specimenFound = true;
	}
	this.m_commentsFound = this.isCommentOrFlagCommentSet(this.m_recordData.RB_LIST[0]);
	resViewModalBodyHTML.push("<div class='mrv-result-container'>");
	resViewModalBodyHTML.push(this.buildEventHistorySectionHTML());
	resViewModalBodyHTML.push(this.buildEventDetailSectionHTML(this.m_recordData.RB_LIST[0]));
	resViewModalBodyHTML.push("</div>");
	$("#resultViewerbody").removeClass("mrv-result-loading");
	$("#" + resViewModalId).html(resViewModalBodyHTML.join(""));
};

/**
 * This function displays the content of the selected tab and hide previous tab's contents
 * @param {DOM Object} selectedTabObj The DOM object of the selected tab
 */
ResultViewerHandler.prototype.onTabChange = function(selectedTabObj) {
	var objTabActive = $(selectedTabObj).parent().find(".mrv-result-tab-active");
	if (objTabActive.length) {
		if ($(objTabActive).attr("id") === $(selectedTabObj).attr("id")) {
			return;
		}
		$(objTabActive).empty();
		$(objTabActive).html("<div class='mrv-result-tab-inactive-label'>" + $(objTabActive).attr("tabText") + "</div>");

		objTabActive.removeClass("mrv-result-tab-active");
		objTabActive.addClass("mrv-result-tab-inactive");
		$(objTabActive).next().removeClass("hidden");
		$(objTabActive).prev().removeClass("hidden");
	}
	$(selectedTabObj).removeClass("mrv-result-tab-inactive");
	$(selectedTabObj).next().addClass("hidden");
	$(selectedTabObj).prev().addClass("hidden");

	$(selectedTabObj).addClass("mrv-result-tab-active");
	$(selectedTabObj).html("<span class = 'mrv-result-tab-active-left'></span><span class = 'mrv-result-tab-active-center'><span class='mrv-result-tab-active-label'>" + $(selectedTabObj).attr("tabText") + "</span></span><span class = 'mrv-result-tab-active-right'></span>");
	$(selectedTabObj).removeClass("mrv-result-tab-inactive");
	$(selectedTabObj).addClass("mrv-result-tab-active");
};

/**
 * This function attaches event listeners to the DOM.  
 */
ResultViewerHandler.prototype.attachListeners = function() {
	var self = this;	
	var resultViewerDialogElement = $("#vwpModalDialogresultViewer");
	resultViewerDialogElement.on("click", ".mrv-result-hist-info", function() {
		var clickedRowElement = $(this);
		var objSelRow = clickedRowElement.parent().find(".mrv-result-hist-select");
		var objSelRowResInd = $(objSelRow).find(".res-ind").parent();
		var eventRowIndex = clickedRowElement.attr("eventRowIndex");
		var eventRBListObj = null;
		var newTabHTML = [];
		if (objSelRow.length) {
			objSelRow.removeClass("mrv-result-hist-select");
			objSelRow.removeClass("mrv-result-wht-text");
			$(objSelRowResInd).removeClass("mrv-result-wht-text");
		}
		clickedRowElement.addClass("mrv-result-hist-select");
		clickedRowElement.addClass("mrv-result-wht-text");
		clickedRowElement.find(".res-high").addClass("mrv-result-wht-text");
		if (objSelRow.attr("eventRowIndex") !== eventRowIndex) {
			eventRBListObj = self.m_recordData.RB_LIST[eventRowIndex];
			self.m_specimenFound = false;
			self.m_commentsFound = false;
			if (eventRBListObj.SPECIMEN_COLL.length) {
				self.m_specimenFound = true;
			}
			self.m_commentsFound = self.isCommentOrFlagCommentSet(eventRBListObj);	
			$("#resViewControls").html(self.buildTabSectionHTML());
			newTabHTML.push(self.buildDetailsTabHTML(eventRBListObj));
			newTabHTML.push(self.buildActionListTabHTML(eventRBListObj));
			if (self.m_specimenFound) {
				newTabHTML.push(self.buildSpecimenTabHTML(eventRBListObj));
			}
			if (self.m_commentsFound) {
				newTabHTML.push(self.buildCommentsTabHTML(eventRBListObj));
			}
			$("#resViewTabBodyId").html(newTabHTML.join(""));
			self.onTabChange($("#resViewTab1"));

			$("#rvDetailsInfoId").removeClass("hidden");
			$("#rvActionListInfoId").addClass("hidden");
			$("#rvCommentsInfoId").addClass("hidden");
			$("#rvSpecimenInfoId").addClass("hidden");
		}
	});
	resultViewerDialogElement.on("click", "#resViewTab1", function() {
		self.onTabChange(this);
		$("#rvDetailsInfoId").removeClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
	});
	resultViewerDialogElement.on("click", "#resViewTab2", function() {
		self.onTabChange(this);
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").removeClass("hidden");
	});
	resultViewerDialogElement.on("click", "#resViewTab3", function() {
		self.onTabChange(this);
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").removeClass("hidden");
		$("#rvCommentsInfoId").addClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
	});
	resultViewerDialogElement.on("click", "#resViewTab4", function() {
		self.onTabChange(this);
		$("#rvDetailsInfoId").addClass("hidden");
		$("#rvActionListInfoId").addClass("hidden");
		$("#rvCommentsInfoId").removeClass("hidden");
		$("#rvSpecimenInfoId").addClass("hidden");
	});	
};
/**
 * @class
 * This ResultViewer object is the main entry point of ResultViewer API.
 * It will launch the correct viewer based on parameters it receives and the Millennium context.
 * And how they're determined will be transparent to the consumer.
 *   - In Millennium context it will launch Millennium viewers, while in non-Millennium context, it will launch the web versions.
 *   - Depending on the result's viewer-type, it will launch the correct viewer to properly display the result.
 */
var ResultViewer = function() {
	//Accessible variables
	this.m_eventIds = null;
	this.m_resultName = "";
	this.m_imageTabInd = false;
	this.m_editModeInd = false;
};

/**
 * Retrieves the event ID array that will be used to launch the result viewer.
 * @return {Array} The event ID array of the results that will be viewed
 */
ResultViewer.prototype.getEventIds = function() {
	return this.m_eventIds;
};

/**
 * Add the event ID that will be used to launch the result viewer.
 * The event ID will be appended to the event ID array, or create an array if the array doesn't exist yet.
 * @param {number} eventId The event ID of the results that will be viewed
 */
ResultViewer.prototype.addEventId = function(eventId) {
	if (typeof eventId !== "number" || eventId < 0) {
		throw new Error("ResultViewer.addEventId: Invalid eventId");
	}
	if (this.m_eventIds === null) {
		this.m_eventIds = [eventId];
	} else {
		this.m_eventIds.push(eventId);
	}
};

/**
 * Retrieves the result name that will be used in the result viewer.
 * It's primarily used on components where a result name is not simply the event code display. (like in Vitals/Labs)
 * It is to force the viewer to display the specified string as its title. 
 * @return {string} The result name of the results that will be viewed
 */
ResultViewer.prototype.getResultName = function() {
	return this.m_resultName;
};

/**
 * Set the result name that will be used in the result viewer. 
 * It's primarily used on components where a result name is not simply the event code display. 
 * It is to force the viewer to display the specified string as its title. 
 * @param {string} resultName The result name of the results that will be viewed
 */
ResultViewer.prototype.setResultName = function(resultName) {
	if ( typeof resultName !== "string") {
		throw new Error("ResultViewer: Invalid resultName");
	}
	this.m_resultName = resultName;
};

/**
 * Retrieves the image tab indicator that will be used to launch the result viewer.
 * This is used mainly in Document/Pathology viewers to indicate whether the image tab should be displayed by default.
 * @return {boolean} Flag indicating whether the image tab of the viewer should be displayed by default
 */
ResultViewer.prototype.getImageTabInd = function() {
	return this.m_imageTabInd;
};

/**
 * Set the image tab indicator that will be used to launch the result viewer.
 * This is used mainly in Document/Pathology viewers to indicate whether the image tab should be displayed by default.
 * @param {boolean} imageInd Flag indicating whether the image tab of the viewer should be displayed by default
 */
ResultViewer.prototype.setImageTabInd = function(imageInd) {
	if ( typeof imageInd !== "boolean") {
		throw new Error("ResultViewer: Invalid imageInd");
	}
	this.m_imageTabInd = imageInd;
};

/**
 * Retrieves the flag that indicates whether the viewer will be launched in edit mode. 
 * When false (default), the viewer will be launched in readonly mode. When true, it will be in edit mode. 
 * @return {string} The flag that indicates whether the viewer will be launched in edit mode
 */
ResultViewer.prototype.getEditModeInd = function() {
	return this.m_editModeInd;
};

/**
 * Set the flag that indicates whether the viewer will be launched in edit mode. 
 * When false (default), the viewer will be launched in readonly mode. When true, it will be in edit mode. 
 * @return {string} The flag that indicates whether the viewer will be launched in edit mode
 */
ResultViewer.prototype.setEditModeInd = function(editModeInd) {
	if ( typeof editModeInd !== "boolean") {
		throw new Error("ResultViewer: Invalid editModeInd");
	}
	this.m_editModeInd = editModeInd;
};

/**
 * Determine the viewer handler object that inherits AbstractViewerHandler that will launch a viewer to display a result base on viewer type.
 * If limited or incorrect information makes it impossible to determine the right viewer handler, it returns null;
 * @param {String} viewerType The viewer type of the result. 
 * @return {ViewerHandler} The viewer handler that will launch the right viewer.
 */
ResultViewer.prototype.determineViewerHandler = function(viewerType) {
	var viewerHandler = null;
	//Determine viewer type. Each viewer handler will be responsible to verify it has enough information.
	switch (viewerType) {
		 //'AP' - Anatomic Pathology viewer
 		case 'AP':
			viewerHandler = new PathologyViewerHandler();
			break;
		//'DOC' - Document viewer
		case 'DOC':
			viewerHandler = new DocumentViewerHandler();
			break;
		//'EVENT' - Clinical event result viewer
		case 'EVENT':
			viewerHandler = new ResultViewerHandler();
			break;
		//'MICRO' - Microbiology viewer
		case 'MICRO':
			viewerHandler = new MicroViewerHandler();
			break;
		//'GRP' - Group result viewer
		case 'GRP':
			viewerHandler = new GroupViewerHandler();
			break;
		//'PROC' - Procedure viewer
		case 'PROC':
			viewerHandler = new ProcedureViewerHandler();
			break;
		//'HLA' - HLA viewer
		case 'HLA':
			viewerHandler = new HLAViewerHandler();
			break;
		//'NR' - Notes and Reminder viewer
		case 'NR':
			viewerHandler = new ReminderViewerHandler();
			break;
		default:
    		//If viewer type is not one of the known types, use default viewer handler, which will prompt the user that it's not supported.
    		viewerHandler = new AbstractViewerHandler();
	}
	return viewerHandler;
};


/**
 * It will query the event information including the viewer type and image url based on Event ID. 
 * Then the appropriate viewer will launch in the right mode depending on the viewer type and the Millennium context. 
 * Event ID field needs to be set before it is called. 
 * To launch the viewer that defaults to the image tab, image indicator needs to be true;
 * 
 */
ResultViewer.prototype.launchViewer = function() {
	var events = this.getEventIds();
	var editModeFlag = this.getEditModeInd() ? 1:0;
	var self = this;
	//Event ID is reqruied before using the event data retrieval CCL. 
	if(!(events instanceof Array) || events.length === 0){
		throw new Error("ResultViewer.prototype.launchViewer requires event ID to launch the viewer.");
	}

	var request = new MP_Core.ScriptRequest(null);
	request.setProgramName("mp_get_event_info");
	//Use the first event ID to query information even when there're multiple events. 
	//It's assuming all the events have the same viewer type, result name, and image Url, etc. 
	//It would be otherwise confusing to reconcile them any way. 
	request.setParameters(["MINE",events[0]+".0", editModeFlag]);
	//Use Synchronous call to block the MPages until the viewer is launched. Otherwise users may click the same result multiple times and launch multiple viewers. 
	request.setAsync(false);

	//Use CAP timer to track usage of mp_get_event_info
	var timer  = new CapabilityTimer("CAP:MPG ResultViewer View Result");
	timer.capture();

	//request event information and show viewer
	MP_Core.XMLCCLRequestCallBack(null, request, function(replyObj){
		try {
			var status = replyObj.getStatus();
			var reply = replyObj.getResponse();
			if (status !== "S") {
				MP_Util.LogError("Unable to retrieve the event information: " + reply.STATUS_DATA.SUBEVENTSTATUS[0].TARGETOBJECTVALUE);
				return;
			}
			
			var eventData = reply.EVENT_INFO;

			var viewerType = eventData.VIEWER_TYPE;
			var viewerHandler = self.determineViewerHandler(viewerType);
			//Check if current environment is millennium
			viewerHandler.m_millenniumInd = CERN_Platform.inMillenniumContext();
			viewerHandler.m_uniqueId = ResultViewer.generateUniqueId();

			//Set the flag that indicates whether the viewer will display the image tab by default
			viewerHandler.setImageInd(self.getImageTabInd());
			if (events) {
				for (var x = 0, len = events.length; x < len; x++) {
					viewerHandler.addEventId(events[x]);
				}
			}

			viewerHandler.setParentEventId(eventData.PARENT_EVENT_ID);
			viewerHandler.setPatientId(eventData.PATIENT_ID);
			viewerHandler.setEncounterId(eventData.ENCOUNTER_ID);
			viewerHandler.setProviderId(eventData.VIEWING_PROVIDER_ID);
			viewerHandler.setImageUrl(eventData.IMAGE_URL);
			viewerHandler.setEditModeInd(self.getEditModeInd());
			viewerHandler.setActivityId(eventData.ACTIVITY_ID);
			viewerHandler.setEditorType(eventData.EDITOR_TYPE);
			viewerHandler.setViewerType(eventData.VIEWER_TYPE);

			//use the resultName parameter if it's passed from the consumer. Otherwise use the event code display. 
			if(self.getResultName()){
				viewerHandler.setResultName(self.getResultName());
			}else{
				viewerHandler.setResultName(eventData.EVENT_CD_DISPLAY);
			}

			//launch viewer - viewer handler will choose Millennium or web viewer depending on the Millennium indicator
			viewerHandler.showViewer();
		} catch (err) {
			logger.logJSError(err, null, "result-viewer.js", "viewerHandler.launchViewer");
		}
	});
};

/////////////////////////////////////////////////////////////////////////////////////
//Static attributes and methods

/*
* Static variable to track how many viewers have been launched. Its purpose is to provide
* a unique number for each viewer so it can assigns the elements unique IDs, so the viewers won't get in the way of each other
*/
ResultViewer.m_viewerCount = 0;

/**
 * Generate unique ID for the viewer handlers which can be used for unique element IDs
 * @return {number} A unique ID for a viewer handler
 */
ResultViewer.generateUniqueId = function() {
	return ResultViewer.m_viewerCount++;
};

/**
 * It's the Ad Hoc function to launch a result viewer that defaults to the result tab. 
 * It simply creates a new ResultViewer, set values on the fields, and launch the viewer.
 * It's designed to further simplify the ResultViewer API so it launches the viewer by simply calling ResultViewer.launchAdHocViewer(...)
 * @param {double|Array} eventId Event ID or an array of event IDs
 * @param {string} resultName Result name (Optional) that displays as the title of the web viewer. 
 * It is primarily used in Labs/Vitals components, where the result name is determined by event id and other factors. 
 * When omitted, it will use the result name queried from event info retrieval CCL.
 */
ResultViewer.launchAdHocViewer = function(eventId, resultName) {
	var viewer = new ResultViewer();
	viewer.setImageTabInd(false);
	
	//Allow adding event ID event when it's 0
	if ( typeof eventId !== "undefined" && eventId !== null) {
		if ( typeof eventId === "number") {
			viewer.addEventId(eventId);
		} else if ( eventId instanceof Array) {
			for (var x = 0, len = eventId.length; x < len; x++) {
				viewer.addEventId(eventId[x]);
			}
		}
	}

	if (resultName) {
		viewer.setResultName(resultName);
	}

	viewer.launchViewer();
};

/**
 * It's the Ad Hoc function to launch a result viewer that defaults to the image tab rather than the result tab. 
 * It simply creates a new ResultViewer, set values on the fields, and launch the viewer.
 * It's designed to further simplify the ResultViewer API so it launches the viewer by simply calling ResultViewer.launchAdHocImageViewer(...)
 * @param {double|Array} eventId Event ID or an array of event IDs
 * @param {string} resultName Result name (Optional) that displays as the title of the web viewer. 
 * It is primarily used in Labs/Vitals components, where the result name is determined by event id and other factors. 
 * When omitted, it will use the result name queried from event info retrieval CCL.
 */
ResultViewer.launchAdHocImageViewer = function(eventId, resultName) {
	var viewer = new ResultViewer();
	viewer.setImageTabInd(true);
	
	//Allow adding event ID event when it's 0
	if ( typeof eventId !== "undefined" && eventId !== null) {
		if ( typeof eventId === "number") {
			viewer.addEventId(eventId);
		} else if ( eventId instanceof Array) {
			for (var x = 0, len = eventId.length; x < len; x++) {
				viewer.addEventId(eventId[x]);
			}
		}
	}

	if (resultName) {
		viewer.setResultName(resultName);
	}

	viewer.launchViewer();
};

var HealtheIntent = HealtheIntent || {};
HealtheIntent.PersonSearch = HealtheIntent.PersonSearch || {};

HealtheIntent.PersonSearch.resultsPager = (function() {
	// private

	var trans = i18n.discernabu.HealtheIntent.PersonSearch;

	function create(currentPage, pageSize, totalCount) {
		var pageCount = Math.ceil(totalCount / pageSize);
		var pager = new MPageUI.Pager();
		pager.setCurrentPageLabelPattern("${currentPage} / ${numberPages}");
		pager.setPreviousLabel(trans.pagePrevious);
		pager.setNextLabel(trans.pageNext);
		pager.setNumberPages(pageCount);
		// Adjust page index to be 0-based for the MPages pager control
		pager.setCurrentPage(currentPage - 1);

		return pager;
	};

	// private api exposed for testing
	HealtheIntent.PersonSearch.__resultsPager = {
		create: create
	};

	// public
	function onPageChange(onPageChangeHandler) {
		this.setOnPageChangeCallback(function(pageInfo) {
			// Note: the MPages pager uses a 0-based index for pages, this adjusts it
			// to be 1-based
			onPageChangeHandler(pageInfo.currentPage + 1);
		});
	};

	function html() {
		return this.render();
	};

	return function(currentPage, pageSize, totalCount) {
		var pager = create(currentPage, pageSize, totalCount);

		// Appending to the public api
		pager.html = html;
		pager.onPageChange = onPageChange;

		return pager;
	};
})();
var HealtheIntent = HealtheIntent || {};
HealtheIntent.PersonSearch = HealtheIntent.PersonSearch || {};

HealtheIntent.PersonSearch.resultsTable = (function() {
	// private

	var trans = i18n.discernabu.HealtheIntent.PersonSearch;

	function createColumn(field, options) {
		var column = new TableColumn();
		var options = options || {};

		options.cssClass && column.setCustomClass(options.cssClass);
		column.setColumnId(field);
		column.setColumnDisplay(options.display || trans[field] || field);
		column.setIsSortable(options.sortable || false);
		column.setPrimarySortField(options.sortBy || field);
		column.setRenderTemplate(options.template || "${" + field + "}");

		return column;
	};

	function address() {
		var html = "<div class='demographics-details'>${street_address}</div>" +
			"<div class='demographics-details'>${address_last_line}</div>";

		return createColumn('address', {template: html, cssClass: "address-column"});
	};

	function name() {
		var html = "<div class='demographics-label'>${name}</div>" +
			"<span class='demographics-details'>${age}</span>" +
			"<span class='demographics-details'>${gender}</span>" +
			"<span class='demographics-details'>" + trans.dobLabel + " ${dob}</span>";
		return createColumn('name', {template: html, cssClass: "name-column"});
	};

	function phone() {
		var html = "<div class='demographics-details'>${phone}</div>";
		return createColumn('phone', {template: html, cssClass: "phone-column"});
	};

	function selectRow(id, onSelectHandler) {
		var ext = new TableCellClickCallbackExtension();

		ext.setCellClickCallback(function(event, data) {
			var $selectedRow = $(event.target).parents('dl.result-info');
			var $previousRow = $('#' + id).find('.selected');

			$previousRow.removeClass('selected');
			$selectedRow.addClass('selected');

			onSelectHandler(data.RESULT_DATA);
		});

		return ext;
	};

	function create(id) {
		var table = new ComponentTable();
		table.setNamespace(id);

		table.addColumn(name());
		table.addColumn(address());
		table.addColumn(phone());

		return table;
	};

	// private api exposed for testing
	HealtheIntent.PersonSearch.__resultsTable = {
		address: address,
		create: create,
		createColumn: createColumn,
		name: name,
		phone: phone,
		selectRow: selectRow
	};

	// public

	function html() {
		return "<div class='search-results-bar'>" +
			trans.searchResults.replace("{count}", this.data.total_results || 0) +
			"</div>" +
			"<div class='component-table-container'>" +
			"<div>" + this.render() + "</div>" +
			"</div>";
	};

	function onRowSelect(onSelectHandler) {
		return this.addExtension(selectRow(this.getNamespace(), onSelectHandler));
	};

	return function(id, data) {
		var table = create(id);
		table.bindData(data);

		// Appending to the public api
		table.data = data;
		table.html = html;
		table.onRowSelect = onRowSelect;

		return table;
	};
})();
/**
 * A scratchpad Util.
 * @class
 * @scope public
 */
var MP_ScratchPadMgr = function() {

	/**
	 * Stores the initial vertical offset of each subsection header for use within the stickScroll function
	 * @scope private
	 */
	this.subSecHdrOffsetArr = null;

	/**
	 * The scratchpad shared resource name
	 * @scope private
	 */
	this.scratchpadSRName = null;

	/**
	 * The pending data shared resource name
	 * @scope private
	 */
	this.pendingDataSRName = null;

	/**
	 * Keeps track of the dx table checkbox state
	 * @scope private
	 */
	this.isDxTableCheckedSP = 0;

	/**
	 * Keeps track of if the dx table checkbox was clicked
	 * @scope private
	 */
	this.wasDxTableChkbxClickedSP = false;

	/**
	 * Keeps track of the provider id (for prefs)
	 * @scope private
	 */
	this.providerId = "";

	/**
	 * Keeps track of the viewpoint id (for prefs)
	 * @scope private
	 */
	this.viewpointId = "";

	/**
	 * Keeps track whether PowerPlans are on the scratchpad
	 * @scope private
	 */
	this.isPowerPlanOnSP = null;

	/**
	 * Keeps track of rezise when Dx Table is open
	 * @scope private
	 */
	this.resizeTimeoutId = null;

	/**
	 * Keeps track of the container element that has the vertical scroll function attached to it
	 * @scope private
	 */
	this.scrollCont = null;

	/**
	 * The global subsection header array
	 * @scope private
	 */
	this.subHdrArr = null;

	/**
	 * Keeps track of the current number of subsection headers
	 */
	this.subHdrLen = null;

	/**
	 * Keeps track if the component has a vertical scrollbar active.
	 * @scope private
	 */
	this.hasVerticalScroll = null;

	var OrdTable = function() {
		/**
		 * The addPendingOrders function builds the HTML markup for the Pending Orders table.
		 * Each cell represents a pending order from the scratchpad Shared resource.	     *
		 * @param {Object} dataObj Scratchpad Shared Resource Object.
		 * @param {Object} dxData The JSON structure that contains the category and dx information for the orders
		 * @returns {undefined}
		 */
		this.addPendingOrders = function(dataObj, dxData) {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			var i = 0;
			var n = 0;
			var p = 0;
			var favHTML = [];
			var ordActionArr = [];
			var orderData = [];
			var orderDataLen = 0;
			var orderCats = [];
			var sectionArray = [];
			var codesArr = [];
			var clinicalCat = null;
			var dxArray = (dxData) ? dxData.DIAG_INFO.DIAGNOSIS : null;
			var frstColClass = (dxArray && dxArray.length) ? "md-scratchpad-left-down-div" : "";

			function sortClinCats(a, b) {
				if (a.sequence < b.sequence) {
					return -1;
				}
				if (a.sequence > b.sequence) {
					return 1;
				}
				return 0;
			}

			if (dxData && dxData.ORDERDATA) {
				var catFound = null;
				codesArr = MP_Util.LoadCodeListJSON(dxData.CODES);
				orderData = dxData.ORDERDATA.ORDERS;
				orderDataLen = dxData.ORDERDATA.ORDER_CNT;
				//iterate through data structure and populate the categories object
				for ( i = 0; i < orderDataLen; i++) {
					clinicalCat = MP_Util.GetValueFromArray(orderData[i].CLIN_CAT_CD, codesArr);
					if (!clinicalCat) {
						//this order's clinical category code was not found. Default it to the Non Categorized one.
						clinicalCat = MP_Util.GetValueFromArray(dxData.ORDERDATA.NON_CAT_CD, codesArr);
						orderData[i].CLIN_CAT_CD = clinicalCat.codeValue;
						orderData[i].CLIN_CAT_DISP = clinicalCat.display;
						orderData[i].CLIN_CAT_MEAN = clinicalCat.meaning;
					}
					//only push each category once
					catFound = $.grep(orderCats, function(e){
						return e.meaning === clinicalCat.meaning;
					});
					if (catFound.length === 0) {
						orderCats.push(clinicalCat);
					}
				}
				orderCats.sort(sortClinCats);
			}

			favHTML.push("<div id='spResultsContainer' class='md-scratchpad-dx-tbl-ord-cont' onScroll='MP_ScratchPadMgr.stickyScroll()'>");

			//Retrieve the object from the shared resource.
			if (dataObj) {
				var scratchpadArr = dataObj.scratchpadObjArr;
				var scratchpadObj = null;
				if (scratchpadArr) {
					var scratchpadArrLength = scratchpadArr.length;
					for ( n = 0; n < orderCats.length; n++) {
						var sectionHTML = [];
						var fixedClass = (n === 0) ? "md-scratchpad-sub-hdr-fixed" : "";
						//apply fixed positioning to the first sub section header
						var paddedClass = (fixedClass !== "") ? "md-scratchpad-padded" : "";
						//add padding to first sub section for proper formatting/display
						//push category subsection container div and header bar
						sectionHTML.push("<div id='subSec", orderCats[n].meaning, "' class='md-scratchpad-sub-sec-hdr'><h3 class='sub-sec-hd ", fixedClass, "'><span class='sub-sec-title'><dl><dd><span class='sub-sec-display'>", orderCats[n].display, "</span></dd></dl></span></h3>");
						//push HTML for left column
						sectionHTML.push("<div class='", frstColClass, " ", paddedClass, "'><table class='md-scratchpad-dx-table'>");
						for ( i = 0; i < scratchpadArrLength; i++) {
							scratchpadObj = scratchpadArr[i];
							for ( p = 0; p < orderData.length; p++) {
								if (parseInt(scratchpadObj.favSynId, 10) === orderData[p].SYN_ID && orderData[p].CLIN_CAT_DISP === orderCats[n].display) {
									sectionArray.push(scratchpadObj);
									if (scratchpadObj.ordAction) {
										//this order was added by order profile and will be pushed last with any other order actions
										ordActionArr.push(scratchpadObj);
									} 
									else {
										sectionHTML.push("<tr class='md-scratchpad-row'><td class='md-scratchpad-row-label md-scratchpad-word-fix'><dl id='sp", scratchpadObj.favId, i, "' class='md-scratchpad-info ", (scratchpadObj.favType === 0) ? "md-scratchpad-ord-icon-margin" : " ", "'>");

										if (scratchpadObj.favType === 2) {//PowerPlan
											MP_ScratchPadMgr.setPowerPlanOn(true);
											sectionHTML.push("<span class='md-scratchpad-remove-icon' onclick='MP_ScratchPadMgr.RemoveFav(this, \"", scratchpadObj.componentId, "\", \"", scratchpadObj.addedFrom, "\", \"", scratchpadObj.favId, "\", \"", scratchpadObj.favSynId, "\", \"", scratchpadObj.favSentId,  "\", \"", "", "\", \"", "", "\", \"", scratchpadObj.favType, "\")'></span><span class='md-scratchpad-pp-icon'>&nbsp;</span><dt>", scratchpadcontroli18n.ORDER_NAME, ":</dt><dd class='md-scratchpad-fav-name'>", scratchpadObj.favName, "</dd><dt>", scratchpadcontroli18n.POWERPLAN_SYS_NAME, ":</dt><dd class='md-scratchpad-sys-pp-name-disp'>", "(", (scratchpadObj.favOrderSentDisp) ? scratchpadObj.favOrderSentDisp : scratchpadObj.favName, ")", "</dd><dt>", scratchpadcontroli18n.ORDER_PARAMETERS, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favParam, "</dd><dt>", scratchpadcontroli18n.ORDER_NOMEN, ":</dt><dd class='md-scratchpad-order-details'>", (scratchpadObj.favNomenIds == '""') ? '' : scratchpadObj.favNomenIds, "</dd><dt>", scratchpadcontroli18n.ORDER_SET, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favOrdSet, "</dd>", "<dt>", scratchpadcontroli18n.NON_ORDER_EVENT, ":</dt><dd class='md-scratchpad-order-details'>2</dd>", "<dt>", scratchpadcontroli18n.POWERPLAN_EVENT_TYPE, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favPPEventType, "</dd>");
										} 
										else if (scratchpadObj.favType === 1) { //Care set
											sectionHTML.push("<span class='md-scratchpad-remove-icon' onclick='MP_ScratchPadMgr.RemoveFav(this, \"", scratchpadObj.componentId, "\", \"", scratchpadObj.addedFrom, "\", \"", scratchpadObj.favId, "\", \"", scratchpadObj.favSynId, "\", \"", scratchpadObj.favSentId, "\", \"", scratchpadObj.favVenueType, "\", \"", "", "\", \"", scratchpadObj.favType, "\")'></span><span class='md-scratchpad-careset-icon'>&nbsp;</span><dt>", scratchpadcontroli18n.ORDER_NAME, ":</dt><dd class='md-scratchpad-fav-name'>", scratchpadObj.favName, "</dd><dt>", scratchpadcontroli18n.ORDER_DISPLAY_LINE, ":</dt><dd class='md-scratchpad-fav-sent-name'>", scratchpadObj.favOrderSentDisp, "</dd><dt>", scratchpadcontroli18n.ORDER_PARAMETERS, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favParam, "</dd><dt>", scratchpadcontroli18n.ORDER_NOMEN, ":</dt><dd class='md-scratchpad-order-details'>", (scratchpadObj.favNomenIds == '""') ? '' : scratchpadObj.favNomenIds, "</dd><dt>", scratchpadcontroli18n.ORDER_SET, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favOrdSet, "</dd><dt>", scratchpadcontroli18n.NON_ORDER_EVENT, ":</dt><dd class='md-scratchpad-order-details'>1</dd>");
										} 
										else {
											if (scratchpadObj.displayRxIcon && scratchpadObj.displayRxIcon === 1) {
												sectionHTML.push("<span class='md-scratchpad-rx-img'></span><span class='md-scratchpad-remove-icon' onclick='MP_ScratchPadMgr.RemoveFav(this, \"", scratchpadObj.componentId, "\", \"", scratchpadObj.addedFrom, "\", \"", scratchpadObj.favId, "\", \"", scratchpadObj.favSynId, "\", \"", scratchpadObj.favSentId,  "\", \"", scratchpadObj.favVenueType, "\", \"", "", "\", \"", scratchpadObj.favType, "\")'></span><dt>", scratchpadcontroli18n.ORDER_NAME, ":</dt><dd class='md-scratchpad-fav-name'>", scratchpadObj.favName, "</dd><dt>", scratchpadcontroli18n.ORDER_DISPLAY_LINE, ":</dt><dd class='md-scratchpad-fav-sent-name'>", scratchpadObj.favOrderSentDisp, "</dd><dt>", scratchpadcontroli18n.ORDER_PARAMETERS, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favParam, "</dd><dt>", scratchpadcontroli18n.ORDER_NOMEN, ":</dt><dd class='md-scratchpad-order-details'>", (scratchpadObj.favNomenIds == '""') ? '' : scratchpadObj.favNomenIds, "</dd><dt>", scratchpadcontroli18n.ORDER_SET, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favOrdSet, "</dd>");
											} 
											else {
												sectionHTML.push("<span class='md-scratchpad-remove-icon' onclick='MP_ScratchPadMgr.RemoveFav(this, \"", scratchpadObj.componentId, "\", \"", scratchpadObj.addedFrom, "\", \"", scratchpadObj.favId, "\", \"", scratchpadObj.favSynId, "\", \"", scratchpadObj.favSentId, "\", \"", scratchpadObj.favVenueType, "\", \"", "", "\", \"", scratchpadObj.favType, "\")'></span><dt>", scratchpadcontroli18n.ORDER_NAME, ":</dt><dd class='md-scratchpad-fav-name'>", scratchpadObj.favName, "</dd><dt>", scratchpadcontroli18n.ORDER_DISPLAY_LINE, ":</dt><dd class='md-scratchpad-fav-sent-name'>", scratchpadObj.favOrderSentDisp, "</dd><dt>", scratchpadcontroli18n.ORDER_PARAMETERS, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favParam, "</dd><dt>", scratchpadcontroli18n.ORDER_NOMEN, ":</dt><dd class='md-scratchpad-order-details'>", (scratchpadObj.favNomenIds == '""') ? '' : scratchpadObj.favNomenIds, "</dd><dt>", scratchpadcontroli18n.ORDER_SET, ":</dt><dd class='md-scratchpad-order-details'>", scratchpadObj.favOrdSet, "</dd>");
											}
										}
										sectionHTML.push("</dl></td></tr>");
									}
									break;
								}
							}
						}
						//we have order actions to handle, add them at the bottom
						for (var j = 0, jl = ordActionArr.length; j < jl; j++) {
							var ordActionObj = ordActionArr[j];
							sectionHTML.push("<tr class='md-scratchpad-row'><td class='md-scratchpad-row-label md-scratchpad-word-fix'><dl id='sp", scratchpadObj.favId, i, "' class='md-scratchpad-info ", (scratchpadObj.favType === 0) ? "md-scratchpad-ord-icon-margin" : " ", "'>");
							sectionHTML.push("<span class='md-scratchpad-remove-icon' onclick='MP_ScratchPadMgr.RemoveFav(this, \"", ordActionObj.componentId, "\", \"", ordActionObj.addedFrom, "\", \"", ordActionObj.favId, "\", \"", ordActionObj.ordId, "\", \"", ordActionObj.favSentId, "\", \"", ordActionObj.favVenueType, "\", \"", "clear", "\", \"", ordActionObj.favType, "\")'></span><span class='md-scratchpad-cancel-icon'>&nbsp;</span><dt>", scratchpadcontroli18n.ORDER_NAME, ":</dt><dd class='md-scratchpad-fav-name md-scratchpad-cancelled'>", ordActionObj.favName, "</dd><dt>", scratchpadcontroli18n.ORDER_DISPLAY_LINE, ":</dt><dd class='md-scratchpad-ord-icon-margin md-scratchpad-fav-sent-name md-scratchpad-cancelled'>", ordActionObj.favOrderSentDisp, "</dd><dt>", scratchpadcontroli18n.ORDER_PARAMETERS, ":</dt><dd class='md-scratchpad-order-details'>", ordActionObj.favParam, "</dd><dt>", scratchpadcontroli18n.ORDER_NOMEN, ":</dt><dd class='md-scratchpad-order-details'>", (ordActionObj.favNomenIds == '""') ? '' : ordActionObj.favNomenIds, "</dd><dt>", scratchpadcontroli18n.ORDER_SET, ":</dt><dd class='md-scratchpad-order-details'>", ordActionObj.favOrdSet, "</dd>");
						}
						//reset ordActionArr
						ordActionArr = [];

						sectionHTML.push("</table></div>");

						if (dxArray.length) {
							//push Dx Rows
							sectionHTML.push(this.addDxRows(sectionArray, dxData, paddedClass));
						}
						//close subsection and reset sectionArray
						sectionArray = [];
						sectionHTML.push("</div>");
						favHTML.push(sectionHTML.join(""));
					} //for loop
				}
			}
			return favHTML.join("");
		};

		/**
		 * The createDxNomenHead function has the logic to create the HTML markup
		 * for creating the columns for each active diagnosis
		 *
		 * @param {Array<Object>} dxArray  dxArray has the information with all the diagnosis.
		 * @returns {String} HTML string for date columns
		 */
		this.createDxNomenHead = function(dxArray) {
			var dxArrayLength = dxArray.length;
			var x = 0;
			var ar = [];
			// creating the HTML markup for the date columns.
			while (x < (dxArrayLength)) {
				var classVar = (x !== 0) ? "md-scratchpad-col-seperator" : "md-scratchpad-first-col";
				ar.push("<td class='", classVar, "'><div class='md-scratchpad-dx-col-hgt'><span class = 'md-scratchpad-dx-col-code'>", dxArray[x].CODE, "</span></br><div class = 'md-scratchpad-dx-col-name-container'><span class = 'md-scratchpad-dx-col-name'>", dxArray[x].DISPLAY_AS, "</span></div><div class='md-scratchpad-ellipsis'>...&nbsp;&nbsp;&nbsp;</div></div></td>");
				x++;
			}
			return ar.join("");
		};
		/**
		 * The addDxRows function builds the HTML markup for the Dx Table.
		 * Each cell represents an association between the pending order (left column) and the Diagnosis (table header).
		 *
		 * @param {Array<Object>} scratchpadArr The pending orders to be associated.
		 * @param {Object} recordData Active diagnosis for the given encounter
		 * @param {String} paddedClass String that determines if extra padding will be added to the column
		 */
		this.addDxRows = function(scratchpadArr, recordData, paddedClass) {
			var i = 0;
			var j = 0;
			var k = 0;
			var l = 0;
			var orderData = recordData.ORDERDATA;
			var dxData = recordData.DIAG_INFO;
			var dxLen = dxData.DIAGNOSIS.length;
			var jl = orderData.ORDERS.length;
			var dxTbl = [];
			var nullTds = [];
			var ordActionArr = [];
			
			dxTbl.push("<div class='md-scratchpadDwnCol ", paddedClass, "'><table class='md-scratchpad-right-div-tab'>");

			if (scratchpadArr) {
				/*build blank table row?*/
				for ( i = 0; i < dxLen; i++) {
					nullTds.push('<td class="md-scratchpad-dx-col-cell" sp-dxNomen-id="dxt', dxData.DIAGNOSIS[i].NOMEN_ID, '" ><div>&nbsp;</div></td>');
				}
				var scratchpadArrLength = scratchpadArr.length;
				for ( i = 0; i < scratchpadArrLength; i++) {
					var scratchpadObj = scratchpadArr[i];
					var favId = $.trim(scratchpadObj.favId).toUpperCase();
					var favSelected = null;
					var cellCntnt = "&nbsp;";
					var isRowEmpty = true;
					var nomenIds = null;
					var newTrId = null;
					var ordTds = null;
					var curOrdJSON = null;
					var curId = null;
					var hasNomenIds = false;
					var dataNomenId = 0.0;

					if (scratchpadObj.ordAction) {
						//this is an order action, its dx row will be at the bottom
						ordActionArr.push(scratchpadObj);
					} else if(scratchpadObj.favType == 2 && !isOrdersAddPowerPlanDetailsAvailable()) {
						ordActionArr.push(scratchpadObj);
					} else {
						if (scratchpadObj.favType >= 0) {//Allow cells to be built for PowerPlans 
							//look for a matching Dx Item
							for ( j = 0; j < jl; j++) {
								curOrdJSON = orderData.ORDERS[j];
								newTrId = $.trim(curOrdJSON.ROW_ID).toUpperCase();
								nomenIds = curOrdJSON.NOMEN_IDS;
								hasNomenIds = (parseInt(nomenIds, 10) >= 0);
								ordTds = [];
								if (favId === newTrId) {
									favSelected = favId;
									break;
								}
							}

							if (favSelected) {
								for ( k = 0; k < dxLen; k++) {
									if (hasNomenIds) {
										cellCntnt = 0;
										var nomenArr = nomenIds.split('|');

										for ( l = dxLen; l--; ) {
											//Checking on the favType too, due to a possibility of having nomen_id and diagnosis_id same.  
											if (nomenArr[l] === ((scratchpadObj.favType !== 2 ? dxData.DIAGNOSIS[k].NOMEN_ID + "" : dxData.DIAGNOSIS[k].DIAGNOSIS_ID + ""))) {
												cellCntnt = l + 1;
											}
										}
										if (cellCntnt === 0) {
											cellCntnt = "&nbsp;";
										}
									} 
									else {
										if (dxData.DIAGNOSIS[k].PRIORITY !== 999) {
											cellCntnt = dxData.DIAGNOSIS[k].PRIORITY;
										} 
										else {
											cellCntnt = "&nbsp;";
										}
									}
									
									if (cellCntnt !== "&nbsp;") {
										isRowEmpty = false;
									}
									
									if (scratchpadObj.favType === 2){
										dataNomenId = dxData.DIAGNOSIS[k].DIAGNOSIS_ID;
									}
									else {
										dataNomenId = dxData.DIAGNOSIS[k].NOMEN_ID;
									}
									ordTds.push('<td class="md-scratchpad-dx-col-cell" sp-dxNomen-id="dxt', dataNomenId, '" >');
									ordTds.push('<div>', cellCntnt, '</div></td>');
								}
							}
							else {
								ordTds.push(nullTds.join(''));
							}

							var curOrd = curOrdJSON.SYN_MNE;
							var curOrdDet = curOrdJSON.SENT_DISP;
							var curReq = curOrdJSON.DIAG_REQ;
							curId = null;
							if (newTrId) {
								curId = newTrId.toUpperCase();
							}
							var curClass = '';

							if (curReq == 1) {
								if (isRowEmpty && (!hasNomenIds)) {
									curClass = 'md-scratchpad-dx-req';
								}
								else {
									curClass = 'md-scratchpad-dx-prev-req';
								}
								curOrd = '<strong class="md-scratchpad-asc-req">' + curOrd + '*</strong>';
							}
							dxTbl.push('<tr id="', 'dxTableRow', i, '" data-sp-id="', curId, '" class="', curClass, '">', ordTds.join(''), '</tr>');
						} 
					}
				}
				for (var m = 0, ml = ordActionArr.length; m < ml; m++) {
					dxTbl.push('<tr id="', 'dxTableRow', i, '" data-sp-id="', ordActionArr[m].ordId, '" class="md-scratchpad-dx-disable">', nullTds.join(''), '</tr>');
					i++;
				}
			}
			dxTbl.push("</table></div>");
			return (dxTbl.join(""));

		};
	};
	
		
	/**
	 * Checks the current environment for the PowerOrders API and its method 'AddPowerPlanWithDetails'
	 * to determine if a call can be made to the API. 
	 * @function
	 * @scope private
	 */
	function isOrdersAddPowerPlanDetailsAvailable() {
		var isAvailable = false;
		
		try{
			isAvailable = ("AddPowerPlanWithDetails" in CERN_Platform.getDiscernObject("POWERORDERS"));
		} catch(err) {
			logger.logError(err.message);
		}
		
		return isAvailable;
	}
	
	/**
	 * Update target table row height with a matching source table. 1 for 1.
	 * @param {Array} sourceColumn : The array of tr elements from the source table.
	 * @param {Array} targetColumn : The array of tr elements from the target table.
	 * @function
	 * @scope private
	 */
	function adjDxRowHeight(sourceColumn, targetColumn) {
		var rowsH = [];
		//rows' heights' array
		if (sourceColumn.length === targetColumn.length) {
			for (var i = 0, il = sourceColumn.length; i < il; i++) {
				if (sourceColumn[i].offsetHeight !== targetColumn[i].offsetHeight) {
					$(targetColumn[i]).css("height", sourceColumn[i].offsetHeight);
				}
			}
		}
	}

	function loadPreferences() {
		var info = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();
		var prefId = "MP_SCRATCHPAD_" + MP_ScratchPadMgr.getViewpointId();
		info.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
				MP_Util.LogScriptCallInfo(null, this, "scratchpadcontrol.js", "loadPreferences");
				var jsonEval = JSON.parse(this.responseText);
				var recordData = jsonEval.RECORD_DATA;
				var isDxTableChecked = true;
				//dx table shown by default
				if (recordData.STATUS_DATA.STATUS == "S") {
					var scratchpadPrefs = JSON.parse(recordData.PREF_STRING).scratchpad_prefs || null;
					if (scratchpadPrefs) {
						isDxTableChecked = (scratchpadPrefs.scratchpad_dx_table_unchecked === 0);
					}
					MP_ScratchPadMgr.setIsDxTableChecked(isDxTableChecked);
				} else if (recordData.STATUS_DATA.STATUS == "Z") {
					MP_ScratchPadMgr.setIsDxTableChecked(isDxTableChecked);
					//No preference was found, use default
				} else {
					MP_Util.LogScriptCallError(null, this, "scratchpadcontrol.js", "loadPreferences");
					var errAr = [];
					var statusData = recordData.STATUS_DATA;
					errAr.push("STATUS: " + statusData.STATUS);
					for (var x = 0, xl = statusData.SUBEVENTSTATUS.length; x < xl; x++) {
						var ss = statusData.SUBEVENTSTATUS[x];
						errAr.push(ss.OPERATIONNAME, ss.OPERATIONSTATUS, ss.TARGETOBJECTNAME, ss.TARGETOBJECTVALUE);
					}
					window.status = "Error calling Dx Table script: " + errAr.join(",");
				}
				if (this.readyState == 4) {
					MP_Util.ReleaseRequestReference(this);
				}
			}
		};
		var arr = ["^mine^", MP_ScratchPadMgr.getProviderId(), "^" + prefId + "^"];
		if (CERN_BrowserDevInd) {
			var url = "MP_GET_USER_PREFS?parameters=" + arr.join(",");
			info.open("GET", url, false);
			//Synchronous so we're sure the prefs are loaded before launching scratchpad
			info.send(null);
		} else {
			info.open("GET", "MP_GET_USER_PREFS", false);
			info.send(arr.join(","));
		}
		return;
	}

	/**
	 * Remove the resize event if the modal is no longer needed.
	 * @function
	 * @scope private
	 */
	function removeModalResizeEvent() {
		//Since the modal is closing we no longer need to resize.
		Util.removeEvent(window, "resize", MP_ScratchPadMgr.WindowResize);
	}

	/**
	 * Sets the scratchpad's dx table checkbox tracking variable and
	 * rerenders the body of the modal dialog.
	 * @function
	 * @scope private
	 */
	function refreshModalBody() {
		//The 1st time chkbx is clicked, var set to true.  Then alternate between false and true on subsequent clicks
		var dxTableStateChanged = !MP_ScratchPadMgr.wasDxTableChkbxClicked();
		MP_ScratchPadMgr.setWasDxTableChkbxClicked(dxTableStateChanged);
		//Switches the state of the checkbox.
		MP_ScratchPadMgr.setIsDxTableChecked(!MP_ScratchPadMgr.isDxTableChecked());
		MP_ScratchPadMgr.loadScratchPadData();
	}

	/**
	 * Add preloader to allow the div to resize before displaying the content.
	 * @param {boolean} preloaderOn : Display the preloader true/false.
	 * @function
	 * @scope private
	 */
	function togglePreloader(preloaderOn) {
		if (!preloaderOn) {
			//Remove preloader and make content visible.
			$("#spPreloadBodyCont").removeClass("md-scratchpad-preloader");
			$("#containerDivSP").removeClass("md-scratchpad-container-hidden");
		} else {
			//Add preloader and make content invisible.
			$("#containerDivSP").addClass("md-scratchpad-container-hidden");
			$("#spPreloadBodyCont").addClass("md-scratchpad-preloader");
		}
	}

	/**
	 * @private
	 * Writes the scratchpad preferences to the database.
	 * @param {object} prefsObj The object which is used to contain all of the viewpoint preferences
	 * @return {null}
	 */
	function writeScratchpadPreferences() {
		//Only save preferences if the state of the dx table checkbox has changed
		if (!MP_ScratchPadMgr.wasDxTableChkbxClicked()) {
			return;
		}
		var info = null;
		var paramArr = [];
		var url = "";
		var prefId = "MP_SCRATCHPAD_" + MP_ScratchPadMgr.getViewpointId();
		var prefsObj = {
			scratchpad_prefs : {
				scratchpad_dx_table_unchecked : MP_ScratchPadMgr.isDxTableChecked() ? 0 : 1
			}
		};

		info = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();
		info.onreadystatechange = function() {
			var jsonEval = null;
			var recordData = null;

			if (this.readyState == 4 && this.status == 200) {
				MP_Util.LogScriptCallInfo(null, this, "scratchpadcontrol.js", "writeScratchpadPreferences");
				jsonEval = JSON.parse(this.responseText);
				recordData = jsonEval.RECORD_DATA;
				if (recordData.STATUS_DATA.STATUS != "S") {
					MP_Util.LogScriptCallError(null, this, "scratchpadcontrol.js", "writeScratchpadPreferences");
				}
			}
			if (this.readyState == 4) {
				MP_Util.ReleaseRequestReference(this);
			}
		};
		paramArr.push("^mine^", MP_ScratchPadMgr.getProviderId(), "^" + prefId + "^", "~" + JSON.stringify(prefsObj) + "~");
		MP_ScratchPadMgr.setWasDxTableChkbxClicked(false);
		//Set to false for next time the dx table is opened.
		if (CERN_BrowserDevInd) {
			url = "MP_MAINTAIN_USER_PREFS?parameters=" + paramArr.join(",");
			info.open('GET', url, true);
			info.send(null);
		} else {
			info.open('GET', "MP_MAINTAIN_USER_PREFS", true);
			info.send(paramArr.join(","));
		}
	}

	return {
		/**
		 * Set true if a power plan is on the scratchpad.
		 * @scope public
		 */
		setPowerPlanOn: function(value) {
			this.isPowerPlanOnSP = value;
		},
		/**
		 * Return the value of isPowerPlanOnSP.
		 * @return {boolean}
		 * @scope public
		 */
		isPowerPlanOn: function() {
			return this.isPowerPlanOnSP;
		},

		/**
		 * Sets true if the dx table checkbox is checked.
		 * @scope public
		 */
		setIsDxTableChecked: function(value) {
			this.isDxTableCheckedSP = value;
		},

		/**
		 * Return the value of isDxTableCheckedSP.
		 * @return {boolean}
		 * @scope public
		 */
		isDxTableChecked: function() {
			return this.isDxTableCheckedSP;
		},

		/**
		 * Return the value of wasDxTableChkbxClickedSP.
		 * @return {boolean}
		 * @scope public
		 */
		setWasDxTableChkbxClicked: function(value) {
			this.wasDxTableChkbxClickedSP = value;
		},

		/**
		 * Sets true if the dx table checkbox was clicked
		 * @scope public
		 */
		wasDxTableChkbxClicked: function() {
			return this.wasDxTableChkbxClickedSP;
		},

		/**
		 * Sets the provider id
		 * @scope public
		 */
		setProviderId: function(value) {
			this.providerId = value;
		},

		/**
		 * Return the value of providerId
		 * @scope public
		 */
		getProviderId: function() {
			return this.providerId;
		},

		/**
		 * Sets the viewpoint id
		 * @scope public
		 */
		setViewpointId: function(value) {
			this.viewpointId = value;
		},

		/**
		 * Return the value of viewpointId
		 * @scope public
		 */
		getViewpointId: function() {
			return this.viewpointId;
		},

		/**
		 * This function grabs the initial offsets of each subsection header and saves them as data so that the stickyScroll function can work properly
		 * @param {Array} subHdrArr Array containing the subsection headers
		 */
		setSubSecHdrOffsets: function(subHdrArr) {
			//at the time that this function is called, the scroll position has changed and is not zero'd. get the scroll position so we can offset the initial header positions.
			var ogOffset = 0;
			var topOffset = $("#spResultsContainer").offset().top;
			var offsetDiff = subHdrArr.eq(0).data("pos") - topOffset;
			if(subHdrArr.length > 0){
				//initial offset positions not set, set them
				if(!$.hasData(subHdrArr[0])){
					$(subHdrArr).each(function(i) {
						$(this).data("pos", this.getBoundingClientRect().top);
					});
				} else {
					$(subHdrArr).each(function(i) {
						if($(this).css("position") === "fixed"){
							this.style.top = topOffset + "px";
						}
						ogOffset = $(this).data("pos");
						$(this).data("pos", ogOffset - offsetDiff);
					});
				}
			}
		},

		/**
		 * This scroll function sticks each subsection header to the top of the scrollable area until the next subsection header pushes it up or the previous one pushes it down
		 */
		stickyScroll: function() {
			var scrollCont = MP_ScratchPadMgr.scrollCont;
			var subHdrArr = MP_ScratchPadMgr.subHdrArr;
			var subHdrLen = MP_ScratchPadMgr.subHdrLen;
			//set initial offset positions for each subsection header if not already set or if offset is negative (offset set before headers rendered)
			if (!$.hasData(subHdrArr[0]) || $(subHdrArr[0]).data("pos") < 0) {
				MP_ScratchPadMgr.setSubSecHdrOffsets(subHdrArr);
			}
			var subHdrHgt = $(subHdrArr[0]).outerHeight();
			var subSecWidth = $(subHdrArr[subHdrLen - 1]).width();
			var topOffset = scrollCont.offset().top;
			var scrollTop = $(".md-scratchpad-dx-tbl-ord-cont").scrollTop() + topOffset;
			//this helps determine subsection header position relative to scroll position
			var fixedClass = "md-scratchpad-sub-hdr-fixed";
			var paddedClass = "md-scratchpad-padded";

			$(subHdrArr).each(function(i) {
				var curHdr = $(this);
				var prevHdr = subHdrArr.eq(i - 1);
				var nextHdr = subHdrArr.eq(i + 1);
				var thisPos = curHdr.data("pos");

				if (thisPos < scrollTop && nextHdr.length > 0 && scrollTop > nextHdr.data("pos") - subHdrHgt) {
					//scenario 1: next subsection header is ready to push up this (currently fixed) header
					//use in-line styling to simulate the "push" effect and remove any padding added for formatting
					curHdr.css("position", "relative");
					if (curHdr.next().hasClass(paddedClass)) {
						curHdr.next().removeClass(paddedClass);
						curHdr.next().next().removeClass(paddedClass);
					}
					curHdr.offset({
						top : nextHdr[0].getBoundingClientRect().top - subHdrHgt
					});
				} else if (thisPos <= scrollTop) {
					//scenario 2: current header is ready to be fixed at the top
					if (curHdr.hasClass(fixedClass) === false) {
						curHdr.addClass(fixedClass);
						//make sure to retain proper width
						curHdr.css("width", subSecWidth);
						//in-line styling to keep header at proper position
						curHdr.offset({
							top : topOffset
						});
						//add padding to keep table from "jumping" when header becomes fixed
						curHdr.next().addClass(paddedClass);
						curHdr.next().next().addClass(paddedClass);
					} else if (curHdr.data("pos") === topOffset) {
						//first header. re-add the padding for proper formatting and remove any styling that may still be lingering
						//remove styling and re-add width styling for proper formatting.
						curHdr.removeAttr("style");
						curHdr.css("width", subSecWidth);
						curHdr.next().addClass(paddedClass);
						curHdr.next().next().addClass(paddedClass);
					} else if (curHdr[0].scrollTop + topOffset === topOffset && nextHdr.length > 0 &&  nextHdr[0].getBoundingClientRect().top - prevHdr[0].getBoundingClientRect().top === subHdrHgt * 2) {
						//we're scrolling up and the current header needs to be fixed
						curHdr.removeAttr("style");
						curHdr.css("width", subSecWidth);
						curHdr.offset({
							top : topOffset
						});
						curHdr.next().addClass(paddedClass);
						curHdr.next().next().addClass(paddedClass);
					} else if (curHdr.offset().top !== topOffset) {
						//we've managed to miss every scenario above. reset headers.
						curHdr.removeAttr("style");
						curHdr.css("width", subSecWidth);
						curHdr.offset({
							top : topOffset
						});
						curHdr.next().addClass(paddedClass);
						curHdr.next().next().addClass(paddedClass);
						prevHdr.offset({
							top : curHdr[0].getBoundingClientRect().top - subHdrHgt
						});
					}
				} else if (thisPos > scrollTop && curHdr.hasClass(fixedClass)) {
					//scenario 3: this header needs to be unfixed and have its styling removed along with any padding that was added to the subsection's columns
					curHdr.removeClass(fixedClass);
					curHdr.next().removeClass(paddedClass);
					curHdr.next().next().removeClass(paddedClass);
					curHdr.removeAttr("style");
				} else if (prevHdr.length > 0 && prevHdr.data("pos") === topOffset && curHdr[0].getBoundingClientRect().top - prevHdr[0].getBoundingClientRect().top > subHdrHgt) {
					//scenario 4: previous header is the first header and needs to be fixed in place
					//remove styling and re add cur width for formatting
					prevHdr.removeAttr("style");
					prevHdr.css("width", subSecWidth);
				}
				//Just in case we have someone that likes to play with the scroll wheel, lets make sure the subsections are where they're supposed to be
				window.clearTimeout(this.scrollTimeoutId);
				var scrollTimeout = function(){
					if(thisPos > scrollTop){
						curHdr.removeAttr("style");
					}
				};
				this.scrollTimeoutId = window.setTimeout(scrollTimeout, 10);
			});
		},

		/**
		 * This function allows table content and diagnoses to scroll horizontally while the left column remains static.
		 * @scope public
		 */
		sideScroll: function() {
			var dxResultsSections = $(".md-scratchpadDwnCol");
			var dxTblHeader = $("#tblHeaderSP");
			var horizScrollbar = $("#spHorizontalScrollbar");
			dxResultsSections.scrollLeft(horizScrollbar.scrollLeft());
			dxTblHeader.scrollLeft(horizScrollbar.scrollLeft());
		},
		/**
		 * This function will gather the shared resource object.
		 * @return {Object} srObj : Scratchpad shared resource object
		 * @scope public
		 */
		retrieveScratchpadSR: function() {
			var srObj = null;
			var sharedResourceName = this.scratchpadSRName;
			//Get the shared resource
			srObj = MP_Resources.getSharedResource(sharedResourceName);
			if (!srObj) {
				srObj = initScratchpadSR(sharedResourceName);
			}

			return srObj;
		},

		/**
		 * This function will initialize the shared resource.
		 * @param {string} sharedResourceName : The name of the shared resource to create
		 * @return {Object} srObj : Scratchpad shared resource object
		 * @scope public
		 */
		initScratchpadSR: function(sharedResourceName) {
			var srObj = null;
			var dataObj = {};
			srObj = new SharedResource(sharedResourceName);
			//Create the object that will be stored in the SharedResource
			dataObj.scratchpadObjArr = [];
			//Set the available flag to true
			srObj.setIsAvailable(true);
			//Set the shared resource data object
			srObj.setResourceData(dataObj);
			//Set the shared resource event listener object
			var object = {};
			srObj.setEventListenerObject(object);
			//Set the shared resource event listener flag
			srObj.setEventListenerFlag(EventListener.EVENT_SCRATCHPAD_COUNT_UPDATE);
			//Add the shared resource so other components can access it
			MP_Resources.addSharedResource(srObj.getName(), srObj);
			return srObj;
		},

		/**
		 * This function will update the icon text displaying the number of items on the scratch pad.
		 * @param {Object} event : The event
		 * @param {Object} dataObj : Scratchpad shared resource data object
		 * @scope public
		 */
		updateIconText: function(event, dataObj) {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			var scratchpadObjArr = dataObj.scratchpadObjArr;
			var iconElement = null;
			if (scratchpadObjArr) {
				var scratchpadLen = scratchpadObjArr.length;
				var iconTextStr = "<span class='md-scratchpad-util-text'>" + scratchpadLen.toString() + "</span>";
				var modalDialogObj = MP_ModalDialog.retrieveModalDialogObject("vwpScratchPad");
				if (modalDialogObj) {
					iconElement = $("#" + modalDialogObj.getIconElementId());
					if (iconElement.length) {
						iconElement.animate({
							opacity : 0.1
						}, 300, function() {
							if ( typeof iconTextStr == "string") {
								if (scratchpadLen === 0) {
									//Clear the count text
									modalDialogObj.setIconText("");
									//dither all buttons
									modalDialogObj.setFooterButtonDither("spSignButton", true);
									modalDialogObj.setFooterButtonDither("spModButton", true);
									modalDialogObj.setFooterButtonDither("spSaveButton", true);
									//dither the icon
									modalDialogObj.setIconClass("md-scratchpad-util-icon-disabled");
									//de-activate the click event on the dithered icon
									modalDialogObj.setIsIconActive(false);
									//Modal is closing, so save the dx table checkbox pref
									writeScratchpadPreferences();
									//Since the modal is closing we no longer need to resize.
									removeModalResizeEvent();
									//close the Modal Window.
									MP_ModalDialog.closeModalDialog("vwpScratchPad");
								} else {
									//Update the count text
									modalDialogObj.setIconText(iconTextStr);
									//activate all buttons
									modalDialogObj.setFooterButtonDither("spSignButton", false);
									modalDialogObj.setFooterButtonDither("spModButton", false);
									modalDialogObj.setFooterButtonDither("spSaveButton", false);
									//make sure icon is activated
									modalDialogObj.setIconClass("md-scratchpad-util-icon-active");
									//activate the click event on the active icon
									modalDialogObj.setIsIconActive(true);
								}
								iconElement.animate({
									opacity : 1
								}, 300);
							}
						});
					}
				}
			}
		},

		/**
		 * This function will populate the scratch pad data into the modal window.
		 * @scope public
		 */
		loadScratchPadData: function() {
			//fire the CAP timer
			var ordersForSigTimer = MP_Util.CreateTimer("CAP:MPG SCRATCHPAD LAUNCH ORDERS FOR SIGNATURE");
			if (ordersForSigTimer) {
				ordersForSigTimer.Start();
				ordersForSigTimer.Stop();
			}
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			var criterion = JSON.parse(m_criterionJSON).CRITERION;
			var venueType = 1;
			//default to Inpatient
			var ordDataJSON = '';
			var ordsJSON = [];
			var ordCnt = 0;
			var ordSetFilter = 0;
			var containerDiv = "containerDivSP";
			var blnkDivId = "blankDivSP";
			var tblHdrId = "tblHeaderSP";
			var oSpTable = new OrdTable();
			var strOrdsJSON = null;
			var dxArray = [];
			var categoriesOnly = 0;

			var scratchpadArrLength = 0;
			//every time we load the scratchpad data, set the variable to false. this is used in SubmitOrders
			MP_ScratchPadMgr.setPowerPlanOn(false);
			//grab scratchpad modal dialog
			var modalDialogObj = MP_ModalDialog.retrieveModalDialogObject("vwpScratchPad");
			//Update the footer checkbox state
			modalDialogObj.setFooterCheckboxIsChecked(MP_ScratchPadMgr.isDxTableChecked());
			MP_ModalDialog.updateModalDialogObject(modalDialogObj);
			//Correct shared resource id's.  Ex.  MySearch orders will not have an ID therefore we need to assign them one.
			MP_ScratchPadMgr.FixNullSrItemId();
			//Load the SR data
			var srObj = MP_ScratchPadMgr.retrieveScratchpadSR();
			var favHTML = [];
			// Checking the Show Diagnosis Table checkbox state for displaying Clear All hyperlink.
			if (MP_ScratchPadMgr.isDxTableChecked()) {
				favHTML.push("<div id='spClearAllLink' class='md-scratchpad-clearall-hpr-div'><a class='md-scratchpad-clearall'>", scratchpadcontroli18n.CLEAR_ALL, "</a></div>");
			}
			favHTML.push("<div><div id='spPreloadBodyCont' class='md-scratchpad-preloader'></div>");
			favHTML.push("<div id=", containerDiv, " class='md-scratchpad-container md-scratchpad-container-hidden'>");
			if (srObj) {
				//Retrieve the object from the shared resource.
				var dataObj = srObj.getResourceData();
				if (dataObj) {
					var scratchpadArr = dataObj.scratchpadObjArr;
					if (scratchpadArr) {
						scratchpadArrLength = scratchpadArr.length;
						for (var i = 0; i < scratchpadArrLength; i++) {
							var scratchpadObj = scratchpadArr[i];
							var curClinCat = scratchpadObj.favClinCategory;
							var curClass = scratchpadObj.favId.toUpperCase();
							var curOrdSyn = scratchpadObj.favName;
							var curOrdSent = scratchpadObj.favOrderSentDisp;
							var ordParams = scratchpadObj.favParam.split('|');
							var curSynId = scratchpadObj.favSynId;
							var curSentId = scratchpadObj.favSentId;
							var curReq = 0;
							//default to 0 to send to BE
							var curNomenIds = "'" + scratchpadObj.favNomenIds + "'";
							var curOrdSet = scratchpadObj.favOrdSet;
							var nonOrderEvent = (scratchpadObj.favType === 6) ? 1 : 0;
							strOrdsJSON = null;

							if (!nonOrderEvent) {
								ordCnt++;
								ordsJSON.push('{"SYN_MNE": "', curOrdSyn, '","SENT_DISP": "', curOrdSent, '","SYN_ID": ', curSynId, ',"SENT_ID": ', curSentId, ', "DIAG_REQ": ', curReq, ', "NOMEN_IDS": ', curNomenIds, ', "ROW_ID": "', curClass, '", "ORD_SELECTED": 1, "ORDER_SET": 0, "CLIN_CAT_CD":0, "CLIN_CAT_DISP":"", "CLIN_CAT_MEAN":""},');
							} else if (nonOrderEvent && curOrdSet == 6) {
								ordSetFilter = 1;
							}
						}
						if (ordsJSON.length) {
							strOrdsJSON = ordsJSON.join('');
							//remove last comma
							if (/,$/.test(strOrdsJSON)) {
								strOrdsJSON = strOrdsJSON.replace(/,$/, "");
							}
						}

						ordDataJSON += '{"ORDERDATA": {"COMPONENT_ID": "' + 0 + '","ORDER_CNT": ' + ordCnt + ',"ORD_SET_FILTER": ' + ordSetFilter + ',"NON_CAT_DISP": ' + '""' + ', "ORDERS": [' + strOrdsJSON + ']}}';

						if (!MP_ScratchPadMgr.isDxTableChecked()) {
							//only retrieve clinical category information
							categoriesOnly = 1;
						}

						var paramString = [];
						paramString.push("^MINE^", criterion.PERSON_ID + ".0", criterion.PRSNL_ID + ".0", criterion.ENCNTRS[0].ENCNTR_ID + ".0", criterion.PPR_CD + ".0", criterion.POSITION_CD + ".0", venueType, "^^", categoriesOnly);
						var dxData = null;
						dxData = MP_ScratchPadMgr.CallDxTableScript("mp_order_diag_config", paramString, ordDataJSON);

						if (dxData) {
							dxArray = dxData.DIAG_INFO.DIAGNOSIS;
							if (dxArray.length) {
								var tabArray = [];
								var colValueArray = [];
								for (var x = 0, xl = dxArray.length; x < xl; x++) {
									tabArray.push(dxArray[x].DISPLAY_AS + " " + dxArray[x].CODE);
									colValueArray.push("--");
								}

								//fire the CAP timer
								var launchDxTimer = MP_Util.CreateTimer("CAP:MPG SCRATCHPAD ORDERS FOR SIGNATURE DXTABLE");
								if (launchDxTimer) {
									launchDxTimer.Start();
									launchDxTimer.Stop();
								}

								favHTML.push("<div id=", blnkDivId, " class='md-scratchpad-left-col-cont'>" + "<table class='md-scratchpad-dx-table'>" + "<tr><th class = 'md-scratchpadColHgt'>", scratchpadcontroli18n.DX_INSTRUCTIONS, "</th></tr>");
								favHTML.push("</table></div>");
								favHTML.push("<div><div class = 'md-scratchpad-shiftingHdr'><div id=", tblHdrId, " class='md-scratchpadHdrCol'><table class='md-scratchpad-right-div-tab'><tr class='hdr'>");
								favHTML.push(oSpTable.createDxNomenHead(dxArray));
								favHTML.push("</tr>");
								favHTML.push("</table></div></div></div>");
								favHTML.push(oSpTable.addPendingOrders(dataObj, dxData));

								//HTML markup for the displaying the rows with results.
								favHTML.push("</div></div></div>");
								favHTML.push("</div>");
							} else {
								favHTML.push(oSpTable.addPendingOrders(dataObj, dxData));
							}
						} else {
							if (MP_ScratchPadMgr.isDxTableChecked()) {
								MP_Util.LogError("File: UTILS.scratchpadcontrol.js </br>  Function: loadScratchPadData </br> " + scratchpadcontroli18n.ERROR_LOADING_DX_TABLE);
							}
							favHTML.push(oSpTable.addPendingOrders(dataObj, dxData));
						}
					}
				}
			}
			favHTML.push("</div></div>");
			MP_ScratchPadMgr.UpdateHeaderTitle(scratchpadArrLength);
			modalDialogObj.setBodyHTML(favHTML.join(""));
			
			this.scrollCont = $("#spResultsContainer");
			this.subHdrArr = this.scrollCont.find(".sub-sec-hd");
			this.subHdrLen = this.subHdrArr.length;
			
			//While the modal is open. We must manually resize certain portions.
			Util.addEvent(window, "resize", MP_ScratchPadMgr.WindowResize);

			if (dxArray.length) {
				var blnkDiv = _g(blnkDivId);
				var dxTblHdrDiv = _g(tblHdrId);
				var dxTrHead = _gbt('tbody', dxTblHdrDiv);
				var scrollContainer = $("#spResultsContainer");
				var oRows = scrollContainer.find(".md-scratchpad-row");
				var dxRows = scrollContainer.find(".md-scratchpad-right-div-tab").find("tr");
				var dxActiveRowsArray = scrollContainer.find("tr[data-sp-id]").not(".md-scratchpad-dx-disable");
				var dxActiveCellsArray = dxActiveRowsArray.find("td");
				var osFiltWarn = $("#osFiltWarn");

				//Adjust Table Rows to account for wrapping of order name.
				adjDxRowHeight(oRows, dxRows);
				$(blnkDiv).css("height", dxTblHdrDiv.offsetHeight);
				
				if (!isOrdersAddPowerPlanDetailsAvailable() && osFiltWarn.length === 0) {
					osFiltWarn = $("<span />").attr("id", "osFiltWarn").addClass("md-scratchpad-os-filt-warn").html("*" + scratchpadcontroli18n.DX_ASSOC_UNSUPPORTED_CARE_PLANS);

					osFiltWarn.insertBefore($("#spSignButton"));
				}

				if (dxActiveCellsArray.length > 0) {
					$(dxActiveCellsArray).each(function() {
					    var self = this;
						$(self).click(function() {
						    MP_ScratchPadMgr.DxCellClick.call(self);
						});
					});
					//Add Dx Table Header click event
					if (dxTrHead) {
						$(dxTrHead[0]).delegate("td", "click", MP_ScratchPadMgr.DxColClick);
					}
					//Add Clear All hyperlink click event
					$("#spClearAllLink").click(function () {
						MP_ScratchPadMgr.clearDxPriorities();
					});
				}
			}
			// add tooltip to header columns on hovering
			var dxColNodes = $("div.md-scratchpad-dx-col-hgt");
			dxColNodes.on("mouseenter", MP_ScratchPadMgr.DxHeaderCellHover);
			MP_ScratchPadMgr.WindowResize();
		},
		/**
		 * Orders added to the pending orders shared resource through MySearch will not have an Id.  Assign them one.
		 * @return {Object} dataObj : Scratchpad shared resource data object
		 * @scope public
		 */
		FixNullSrItemId : function() {
			var srObj = MP_ScratchPadMgr.retrieveScratchpadSR();
			if (srObj) {
				//Retrieve the object from the shared resource.
				var dataObj = srObj.getResourceData();
				if (!dataObj) {
					return null;
				} else {
					var scratchpadArr = dataObj.scratchpadObjArr;
					if (scratchpadArr) {
						for (var idx = 0, idxLen = scratchpadArr.length; idx < idxLen; idx++) {
							var scratchPadObj = scratchpadArr[idx];
							if (scratchPadObj.addedFrom === "MySearch") {
								scratchPadObj.favId = scratchPadObj.addedFrom + scratchPadObj.componentId + "searchRow_" + idx + "_";
							}
						}
					}

					dataObj.scratchpadObjArr = scratchpadArr;

					//Update the SharedResource.
					MP_Resources.setSharedResourceData(srObj.getName(), dataObj);

					//notify consumers that something has been added to or deleted from the shared resource
					srObj.notifyResourceConsumers();

					return dataObj;
				}
			}
		},
		/**
		 * Remove an order, PowerPlan, or Careset favorite from the scratch pad
		 * @param {node} removeButton : The button of the order favorite clicked by the user
		 * @param {string} componentId : The id of the component, passed in as a string
		 * @param {string} addedFrom : Location where the favorite was added from
		 * @param {string} favoriteId : The id of the favorite, passed in as a string
		 * @param {string} favSynId : The id of the synonym favorite, passed in as a string
		 * @param {string} favSentId : The id of the sentence favorite, passed in as a string
		 * @param {object} ordAction : The order action object that is being removed from the scratchpad
		 * @scope public
		 */
		RemoveFav: function(removeButton, componentId, addedFrom, favoriteId, favSynId, favSentId, favVenueType, ordAction, orderableType) {
			//remove favorite object from scratchpad HTML
			var scratchpadFav = $(removeButton).closest("tr");
			//find the subsection this favorite is in
			var favSubSecContainer = scratchpadFav.parents(".md-scratchpad-sub-sec-hdr");
			//Get row index
			var rowIdx = scratchpadFav[0].rowIndex;

			if (scratchpadFav) {
				scratchpadFav.remove();
				//Remove corresponding row from Dx table.
				var tblDxTable = favSubSecContainer.find(".md-scratchpad-right-div-tab")[0];
				if (tblDxTable) {
					tblDxTable.deleteRow(rowIdx);
					MP_ScratchPadMgr.WindowResize();
				}
				if ($(favSubSecContainer).find("tr").length === 0) {
					//there are no more orders left in this subsection, remove it
					favSubSecContainer.remove();
					//update the subsection header array and length if this was not the last order removed
					MP_ScratchPadMgr.subHdrArr = MP_ScratchPadMgr.scrollCont.find(".sub-sec-hd");
					MP_ScratchPadMgr.subHdrLen--;
				}
			}

			//remove favorite object from shared resource
			var dataObj = MP_ScratchPadMgr.RemoveFromScratchpadSR(favSynId, favSentId,favVenueType, orderableType);

			//check to see if component is still dirty after removing one scratchpad object
			if (dataObj) {
				var componentIsDirty = false;
				var scratchpadArr = dataObj.scratchpadObjArr;
				if (scratchpadArr) {
					var idx = scratchpadArr.length;
					while (idx--) {
						if (scratchpadArr[idx].componentId == componentId) {
							componentIsDirty = true;
							break;
						}
					}
				}

				if (!componentIsDirty) {
					MP_ScratchPadMgr.RemovePendingSR(componentId);
				}
			}

			//favoriteId will be null for items added from MySearch
			if (favoriteId && addedFrom != "MySearch") {
				var removeObject = {};
				removeObject.componentId = componentId;
				removeObject.favoriteId = favoriteId;
				removeObject.favSynId = favSynId;
				removeObject.favSentId = favSentId;

				if (ordAction) {
					removeObject.ordAction = ordAction;
					//fire event to call function to update corresponding component
					CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_REMOVED_ORDER_ACTION, removeObject);
				}
				else {
					//fire event to call function to update corresponding component
					CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_UPDATES_COMPONENT, removeObject);
				}
			}
		},

		/**
		 * Remove scratchpad object from the shared resource array of objects
		 * @param {string} favSynId : The id of the synonym favorite, passed in as a string
		 * @param {string} favSentId : The id of the sentence favorite, passed in as a string
		 * @param {string} favVenueType : The venue type that the order was added as, passed in as a string
		 * @param {string} favOrderableType : The orderable type of the order passed in (if orderable) (0 - synonym, 1 - careset, 2 - powerplan)
		 * @returns {Object} dataObj : Scratchpad shared resource data object
		 * @scope public
		 */
		RemoveFromScratchpadSR: function(favSynId, favSentId, favVenueType, favOrderableType){
			// Helper function to determine whether the provided scratchpad object matches the given details
			function scratchpadObjectMatchesDetails(scratchpadObj, orderEntityId, sentenceEntityId, orderableType, venueType){
				var scratchpadObjVenue = scratchpadObj.favVenueType;
				//Default to empty if venue not set (Inpatient venue is 0)
				if (!scratchpadObjVenue && scratchpadObjVenue !== 0){
					scratchpadObjVenue = "";
				}
				if (scratchpadObj.ordId) {
					//this is a cancel action, match based on id of order
					return scratchpadObj.ordId == orderEntityId;
				}
				else {
					// match on orderable type (synonym, powerplan, careset), entity id (synonym id / powerplan id), sentence entity id (sentence id/plan favorite id), and venue
					return (scratchpadObj.favSynId == orderEntityId && scratchpadObj.favSentId == sentenceEntityId && scratchpadObjVenue == venueType && scratchpadObj.favType == orderableType);
				}
			}


			var removedFav = false;
			var scratchpadArrLength = 0;
			var srObj = MP_ScratchPadMgr.retrieveScratchpadSR();
			favVenueType = favVenueType || "";
			if (srObj) {
				//Retrieve the object from the shared resource.
				var dataObj = srObj.getResourceData();
				if (!dataObj) {
					return null;
				}
				else {
					var scratchpadArr = dataObj.scratchpadObjArr;
					if (scratchpadArr) {
						scratchpadArrLength = scratchpadArr.length;
						var idx = scratchpadArr.length;
						while (idx--) {
							// Loop through the scratchpad objects in the scratchpad removing the first one that matches the provided details
							if (scratchpadObjectMatchesDetails(scratchpadArr[idx], favSynId, favSentId, favOrderableType, favVenueType)) {
								scratchpadArr.splice(idx, 1);
								removedFav = true;
								break;
							}
						}
					}
					if (removedFav) {
						MP_ScratchPadMgr.UpdateHeaderTitle(scratchpadArrLength - 1);
					}

					dataObj.scratchpadObjArr = scratchpadArr;

					//Update the SharedResource.
					MP_Resources.setSharedResourceData(srObj.getName(), dataObj);

					//notify consumers that something has been added to or deleted from the shared resource
					srObj.notifyResourceConsumers();

					return dataObj;
				}
			}
		},

		/**
		 * Toggle the pending data flag used by the PVFRAMEWORKLINK discernobject factory object.
		 * @param {string} componentId : The component id of the component that sent the order or order action to the scratchpad
		 */
		RemovePendingSR: function(componentId) {
			var srObj = null;
			var dataObj = {};
			var pendingDataSRName = this.pendingDataSRName;
			//Get the shared resource
			srObj = MP_Resources.getSharedResource(pendingDataSRName);
			//Retrieve the object from the shared resource.
			if (!srObj) {
				return;
			}
			dataObj = srObj.getResourceData();
			var pendingArr = dataObj.pendingDataCompArr;
			var idx = pendingArr.length;
			while (idx--) {
				if (componentId === pendingArr[idx]) {
					pendingArr.splice(idx, 1);
					break;
				}
			}
			dataObj.pendingDataCompArr = pendingArr;
			//If there are no other components that have pending actions communicate to the PVFRAMEWORKLINK object that there is no pending components.
			dataObj.pendingDataObj.SetPendingData(dataObj.pendingDataCompArr.length === 0 ? 0 : 1);
			//Update the SharedResource.
			MP_Resources.setSharedResourceData(pendingDataSRName, dataObj);
		},

		/**
		 * Update header title with correct count for "Orders for Signature (n)"
		 * @param {int} newTitleCount : The new title count
		 * @scope public
		 */
		UpdateHeaderTitle: function(newTitleCount) {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			//grab scratchpad modal dialog
			var modalDialogObj = MP_ModalDialog.retrieveModalDialogObject("vwpScratchPad");
			var newTitle = scratchpadcontroli18n.ORDERS_FOR_SIGNATURE + " (" + (newTitleCount) + ")";
			modalDialogObj.setHeaderTitle(newTitle);
		},

		/**
		 * Add nomen ids to the scratchpad sr
		 * @param {Object} nomenObjArr : The nomenclature object array, consisting of an array of
		 * 		nomenclature objects. Each object has an orderSynId, orderSentId, and corresponding nomenIds
		 * 			(nomenObj.orderSynId, nomenObj.orderSentId, nomenObj.nomenIds)
		 * @scope public
		 */
		AddNomenIdsToScratchpadSR: function(nomenObjArr) {
			var srObj = MP_ScratchPadMgr.retrieveScratchpadSR();
			if (srObj) {
				//Retrieve the object from the shared resource.
				var dataObj = srObj.getResourceData();
				if (!dataObj) {
					return null;
				} else {
					var scratchpadArr = dataObj.scratchpadObjArr;
					if (scratchpadArr) {
						var nomenObjArrLength = nomenObjArr.length;
						var idx = scratchpadArr.length;
						while (nomenObjArrLength--) {
							var nomenObj = nomenObjArr[nomenObjArrLength];
							var foundIdx = null;
							$.each(scratchpadArr, function(i, n){
								if((n.favId.toUpperCase() === nomenObj.Id) || (n.ordId === nomenObj.Id)){
									foundIdx = i;
									return false;
								}
							});
							if(foundIdx !== null){
								scratchpadArr[foundIdx].favNomenIds = nomenObj.nomenIds;
							}							
						}
					}

					dataObj.scratchpadObjArr = scratchpadArr;

					//Update the SharedResource.
					MP_Resources.setSharedResourceData(srObj.getName(), dataObj);

					//notify consumers that something has been added to or deleted from the shared resource
					srObj.notifyResourceConsumers();

					return dataObj;
				}
			}
		},
		SaveToSR: function() {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			var dxTbl = $(".md-scratchpadDwnCol");
			if (!dxTbl) {
				//Since the modal is closing, save the dx table checkbox pref
				writeScratchpadPreferences();
				//Since the modal is closing we no longer need to resize.
				removeModalResizeEvent();
				//close the Modal Window.
				MP_ModalDialog.closeModalDialog("vwpScratchPad");
				return;
			}
			var dxTbody = dxTbl.find('tbody');
			var reqd = dxTbl.find(".md-scratchpad-dx-req");
			if (reqd.length > 0) {
				alert(scratchpadcontroli18n.COMPLETE_ASSOCIATIONS);
			} else {
				var nomenObjArr = [];
				var tRows = dxTbody.find('tr');
				var trLen = tRows.length;
				for (var j = 0; j < trLen; j++) {
					var nomenObj = {};
					var curRow = tRows[j];
					var tds = _gbt('td', curRow);
					var tdLen = tds.length;
					var dxAsoc = [];
					for (var i = 0; i < tdLen; i++) {
						var curTd = tds[i];
						//create array of nomen id associations
						var curTdContents = _gbt('div', curTd)[0];
						if (curTdContents.innerHTML != "&nbsp;") {
							var dxNomenId = curTd.getAttribute("sp-dxNomen-id");
							if (dxNomenId) {
								var idx = (parseInt(curTdContents.innerHTML, 10)) - 1;
								dxAsoc[idx] = (dxNomenId).replace('dxt', '');
							}
						}
					}
					var strDx = dxAsoc.join('|');
					var pendOrder = curRow.getAttribute('data-sp-id');
					nomenObj.Id = pendOrder;
					nomenObj.nomenIds = strDx;
					nomenObjArr.push(nomenObj);
				}
				//update the shared resource with the nomenIds of all orders
				var dataObj = MP_ScratchPadMgr.AddNomenIdsToScratchpadSR(nomenObjArr);
				//Since the modal is closing, save the dx table checkbox pref
				writeScratchpadPreferences();
				//Since the modal is closing we no longer need to resize.
				removeModalResizeEvent();
				//close the Modal Window.
				MP_ModalDialog.closeModalDialog("vwpScratchPad");
			}
		},

		/**
		 * Call the Dx Table Script
		 * @param {string} scriptName : The name of the script to be executed
		 * @param {string} paramString : The param string used in executing the script
		 * @param {string} blobIn : The orders json string that will be passed to mp_order_diag_config
		 * @scope public
		 */
		CallDxTableScript: function(scriptName, paramString, blobIn) {
			var record = null;
			var parameters = paramString.join(",");
			var info = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();
			info.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					MP_Util.LogScriptCallInfo(null, this, "scratchpadcontrol.js", "CallDxTableScript");
					var jsonEval = JSON.parse(this.responseText);
					var recordData = jsonEval.RECORD_DATA;
					if (recordData.STATUS_DATA.STATUS == "Z") {
						record = recordData;
					} else if (recordData.STATUS_DATA.STATUS == "S") {
						record = recordData;
					} else {
						MP_Util.LogScriptCallError(null, this, "scratchpadcontrol.js", "CallDxTableScript");
						var errAr = [];
						var statusData = recordData.STATUS_DATA;
						errAr.push("STATUS: " + statusData.STATUS);
						for (var x = 0, xl = statusData.SUBEVENTSTATUS.length; x < xl; x++) {
							var ss = statusData.SUBEVENTSTATUS[x];
							errAr.push(ss.OPERATIONNAME, ss.OPERATIONSTATUS, ss.TARGETOBJECTNAME, ss.TARGETOBJECTVALUE);
						}
						window.status = "Error calling Dx Table script: " + errAr.join(",");
						record = "error";
					}
				}
				if (this.readyState == 4) {
					MP_Util.ReleaseRequestReference(this);
				}
			};

			if (CERN_BrowserDevInd) {
				var url = scriptName + "?parameters=" + encodeURIComponent(parameters);
				if (blobIn) {
					url += "&blobIn=" + encodeURIComponent(blobIn);
				}
				info.open('GET', url, false);
				info.send(null);
			} else {
				if(blobIn){
					info.setBlobIn(blobIn);
				}
				info.open('GET', scriptName, false);
				info.send(paramString.join(","));
			}
			return record;
		},
		/**
		 * When a cell is clicked within the Dx table we need to update the priority.
		 */
		DxCellClick: function() {
			var prnt = Util.gp(this);
			var tds = _gbt('td', prnt);
			var tdLen = tds.length;
			var cellVal = _gbt("div", this)[0];
			var tmpCellVal = "&nbsp;";
			if (!Util.Style.ccss(prnt, "md-scratchpad-dx-disable")) {
				if (cellVal.innerHTML != "&nbsp;") {
					var curVal = parseInt(cellVal.innerHTML, 10);
					cellVal.innerHTML = "&nbsp;";
					var nomCount = 0;
					for (var j = tdLen; j--; ) {
						tmpCellVal = _gbt("div", tds[j])[0];
						var iCellVal = parseInt(tmpCellVal.innerHTML, 10);
						if (tmpCellVal.innerHTML != "&nbsp;") {
							nomCount++;
							if (iCellVal > curVal) {
								tmpCellVal.innerHTML = iCellVal - 1;
							}
						}
					}
					if (nomCount === 0) {
						if (Util.Style.ccss(prnt, "md-scratchpad-dx-prev-req")) {
							Util.Style.rcss(prnt, "md-scratchpad-dx-prev-req");
							Util.Style.acss(prnt, "md-scratchpad-dx-req");
						}
					}
				} else {
					var newArr = [];
					if (Util.Style.ccss(prnt, "md-scratchpad-dx-req")) {
						Util.Style.rcss(prnt, "md-scratchpad-dx-req");
						Util.Style.acss(prnt, "md-scratchpad-dx-prev-req");
					}
					for (var i = tdLen; i--; ) {
						tmpCellVal = _gbt("div", tds[i])[0];
						if (tmpCellVal.innerHTML != "&nbsp;") {
							newArr[i] = parseInt(tmpCellVal.innerHTML, 10);
						} else {
							newArr[i] = 0;
						}
					}
					var mx = (Math.max.apply(null, newArr)) + 1;
					cellVal.innerHTML = mx;
				}
			}
		},
		/**
		 * When the select all cell is clicked within the Dx table we need to update the prioritty for every cell in the column.
		 * @param {node} firstRowCell : The node of the cell that is in the first row of the selected column
		 * @param {int} columnNum : A column index for the table
		 */
		DxColClick: function(event) {
			//Find nearest TD container
			var targetTd = $(event.target).closest('td')[0];

			//Find total number of diagnosis column headers
			var dxColHdrCount = $("#tblHeaderSP").find(".md-scratchpad-dx-col-hgt").length;

			//Find cellIndex
			var cellIndex = targetTd.cellIndex;

			//Find the DxTable Results
			var dxActiveRowsArray = $(".md-scratchpad-dx-tbl-ord-cont").find("tr[data-sp-id]").not(".md-scratchpad-dx-disable");
			var dxActiveCellsArray = $(dxActiveRowsArray).find("td");
			var hasFiredEvent = false;
			var cellCounter = cellIndex;

			//associate any non-associated rows
			for (var x = 0; x < dxActiveRowsArray.length; x++) {
				var activeDxCell = dxActiveCellsArray[cellCounter].firstChild;
				if ($(activeDxCell).html() == "&nbsp;") {
					$(activeDxCell).click();
					hasFiredEvent = true;
				}
				//increase cellCounter so we only mark the rows in the clicked column
				cellCounter += dxColHdrCount;
			}

			//if no event has fired, that means every cell in the column is already associated to every order
			//so, we must remove all associations
			if (!hasFiredEvent) {
				cellCounter = cellIndex;
				for (var y = 0; y < dxActiveRowsArray.length; y++) {
					$(dxActiveCellsArray[cellCounter]).click();
					//increase cellCounter so we only mark the rows in the clicked column
					cellCounter += dxColHdrCount;
				}
			}
		},
		/**
		 * When the Clear All hyperlink is clicked all orders-to-diagnoses associations will be removed.
		 * @return null
		 */
		clearDxPriorities : function () {
			//Find the DxTable Results		
			var dxTableRowsArray = $(".md-scratchpad-dx-tbl-ord-cont").find("tr[data-sp-id]").not(".md-scratchpad-dx-disable");			
			var dxTableCellsArray = dxTableRowsArray.find("td");
			for (var x = 0; x < dxTableCellsArray.length; x++) {
				var activeDxCell = dxTableCellsArray[x].firstChild;
				//Checking every cell in the column is already associated to every order. so, we must remove all associations.			   
				if ($(activeDxCell).html() != "&nbsp;") {
					$(dxTableCellsArray[x]).click();
				}
			}
		},
		/**
		 * When a header cell for the diagnosis table is hovered over, a tooltip will display with the full formatted name of the diagnosis
		 * along with the code
		 */
		DxHeaderCellHover: function(event) {
			var anchor = this;
			var curColEl = $(this);
			var dxFullName = $("span.md-scratchpad-dx-col-name", curColEl);
			var dxCode = $("span.md-scratchpad-dx-col-code", curColEl);
			var tooltip = new MPageTooltip().setShowDelay(0);
			var tipContent = "<span class='md-scratchpad-dx-tooltip-text'>" + dxFullName.html() + "  " + dxCode.html() + "</span>";
			tooltip.setX(event.pageX).setY(event.pageY).setAnchor(anchor).setContent(tipContent);
			tooltip.getContent().addClass("dx-tooltip");
			tooltip.show();
		},

		/**
		 * Starts a timer in which call the WindowResizeTimeout function upon timeout.  Timeout needed for ie6 issues.
		 * @param {int} componentId : A unique identifier for the component using the dx table
		 */
		WindowResize: function() {
			var frstColDiv = $(".md-scratchpad-left-down-div")[0];
			var contentTblDiv = $(".md-scratchpadDwnCol")[0];

			if (contentTblDiv && frstColDiv) {
				window.clearTimeout(this.resizeTimeoutId);
				var windowResizeTimeout = function() {
					togglePreloader(true);
					MP_ScratchPadMgr.WindowResizeTimeout();
					togglePreloader(false);
					//reset scroll position on resize for proper section header display
					$(".md-scratchpad-dx-tbl-ord-cont").scrollTop(0);
					MP_ScratchPadMgr.ResizeSectionHeaders();
				};
				this.resizeTimeoutId = window.setTimeout(windowResizeTimeout, 10);
			} else {
				window.clearTimeout(this.resizeTimeoutId);
				var windowResizeClearTimeout = function(){
					togglePreloader(false);
					MP_ScratchPadMgr.ResizeContentDiv();
					MP_ScratchPadMgr.ResizeSectionHeaders();	
				};
				this.resizeTimeoutId = window.setTimeout(windowResizeClearTimeout, 10);
			}
		},

		/**
		 * Resize the main content div
		 */
		ResizeContentDiv: function() {
			var resultsContentDiv = $(".md-scratchpad-dx-tbl-ord-cont");
			var scratchPadBody = $("#vwpScratchPadbody");
			var scratchPadBodyMaxHeight = parseFloat(scratchPadBody.css("max-height"), 10);
			var tableVertMargin = 38;

			if (resultsContentDiv.height() + tableVertMargin > scratchPadBodyMaxHeight) {
				resultsContentDiv.css({
					height : scratchPadBodyMaxHeight - tableVertMargin
				});
			}
		},

		/**
		 * Resize the section headers upon initial load and whenever the window is resized
		 * @return null
		 */
		ResizeSectionHeaders: function() {
			//grab the currently fixed header
			var fixedHdr = $(".md-scratchpad-sub-hdr-fixed").filter(function() {
				return $(this).css("position") === "fixed";
			});
			var subSecHdr = $("#containerDivSP").find(".sub-sec-hd");
			var subSecHdrWidth = 0;

			// Set width of the fixed subsection header
			if (subSecHdr.length === 1) {
				var scrollCont = $(".md-scratchpad-dx-tbl-ord-cont")[0];
				//there's only one subsection in the scratchpad
				subSecHdrWidth = $(scrollCont.firstChild).width() - 6;
				//subtracting 6 to account for padding
			} else {
				subSecHdrWidth = subSecHdr.not(".md-scratchpad-sub-hdr-fixed").width();
			}
			fixedHdr.width(subSecHdrWidth);

			//set offset positions for each subsection
			MP_ScratchPadMgr.setSubSecHdrOffsets(subSecHdr);
		},

		/**
		 * Resize the dx table header once the user stops resizing the window.
		 * @param {int} componentId : A unique identifier for the component using the dx table
		 */
		WindowResizeTimeout: function() {
			var resultsContentDiv = $("#spResultsContainer");
			var orderColDiv = resultsContentDiv.find(".md-scratchpad-left-down-div");
			var orderColDivLen = orderColDiv.length;
			var dxColDiv = resultsContentDiv.find(".md-scratchpadDwnCol");
			var dxColDivLen = dxColDiv.length;
			var dxColDivWidth = dxColDiv.width();
			//Dx Table Div Contents Width
			var dxCols = dxColDiv.find("tr:first td");
			var tblHeaderSP = _g("tblHeaderSP");
			var tblHeaderSPHeight = $(tblHeaderSP).outerHeight();
			var tblHeaderTbody = _gbt('tbody', tblHeaderSP)[0];
			var nomTds = _gbt('td', tblHeaderTbody);
			var horizontalScrollNeeded = false;
			var horizontalScrollbarHTML = [];
			var tblContentsHeight = 0;
			var minColumnWidth = 90;
			var hasHorizontalScrollbar;
			//px Pull from CSS?
			if ((dxColDivWidth / dxCols.length) < minColumnWidth) {
				$(nomTds).addClass('md-scratchpad-dx-fixed');
				dxColDiv.find("td").addClass('md-scratchpad-dx-fixed');
				$("#blankDivSP").css("height", tblHeaderSP.offsetHeight);
				horizontalScrollNeeded = true;
			}
			var scratchPadBody = $("#vwpScratchPadbody");
			var dxRows = dxColDiv.find("tr").length;
			//Number of rows in Dx Table.

			dxColDiv.each(function() {
				tblContentsHeight += $(this).height();
			});
			resultsContentDiv.removeAttr("style");
			var resultsContentHeight = resultsContentDiv.height();

			var tblVertMargin = 38;
			//px
			var scrollAllowance = 17;
			//px
			var totalContentHeight = tblHeaderSPHeight + resultsContentHeight + tblVertMargin;
			var scratchPadBodyMaxHeight = parseFloat($(scratchPadBody).css("max-height"), 10);
			var horizontalScrollBar = $(".md-scratchpad-horiz-scrollbar");

			//override the overflow property of the main container to prevent any unnecessary scroll bars
			$(scratchPadBody).css("overflow", "hidden");

			if (totalContentHeight > scratchPadBodyMaxHeight) {
				resultsContentDiv.css({
					height : scratchPadBodyMaxHeight - (tblHeaderSPHeight + tblVertMargin)
				});
				$(tblHeaderSP).addClass("md-scratchpad-dx-vert-scroll");
				this.hasVerticalScroll = true;
			} else if (this.hasVerticalScroll) {
				$(tblHeaderSP).removeClass("md-scratchpad-dx-vert-scroll");
				this.hasVerticalScroll = false;
			}

			// Check if horizontal scroll bar is present and adjust the height of table body accordingly
			if (dxColDiv.length > 0) {
				 hasHorizontalScrollbar = dxColDiv[0].scrollWidth > dxColDiv[0].clientWidth;
			}

			if (this.hasVerticalScroll && (resultsContentDiv[0].scrollHeight <= resultsContentDiv[0].clientHeight)) {
				$(tblHeaderSP).removeClass("md-scratchpad-dx-vert-scroll");
				this.hasVerticalScroll = false;
			}

			if (hasHorizontalScrollbar && horizontalScrollNeeded) {
				var dxTableWidth = $(".md-scratchpad-right-div-tab").width();
				var footerHeight = $("#vwpScratchPadfooter").outerHeight();
				if (horizontalScrollBar.length <= 0) {
					horizontalScrollbarHTML.push("<div id='spHorizontalScrollbar' class='md-scratchpad-horiz-scrollbar' onscroll='MP_ScratchPadMgr.sideScroll();'><div>&nbsp;</div></div>");
					resultsContentDiv.append(horizontalScrollbarHTML.join(""));
					horizontalScrollBar = $("#spHorizontalScrollbar");
				}
				horizontalScrollBar.children().css("width", dxTableWidth);
				//adjust for horizontal scrollbar height
				$(orderColDiv[orderColDivLen - 1]).css("padding-bottom", scrollAllowance);
				$(dxColDiv[dxColDivLen - 1]).css("padding-bottom", scrollAllowance);
				
				//position the scroll bar
				horizontalScrollBar.css({
					width : resultsContentDiv.find(".md-scratchpadDwnCol").width() - scrollAllowance,
					top : $("#containerDivSP").height() + tblVertMargin,
					left : tblHeaderSP.offsetLeft + 10 //10 for vwpScratchPadBody margin
				});
			} else {
				if (horizontalScrollBar.length > 0) {
					horizontalScrollBar.remove();
				}
				$(orderColDiv[orderColDivLen - 1]).removeAttr("style");
				$(dxColDiv[dxColDivLen - 1]).removeAttr("style");
			}

			/*
			 * Below handles truncation of diagnosis nomenclature strings that will take up longer than two lines (truncating to 2 lines with an ellipse)
			 */

			/*
			 * Class to wrap jquery elements necessary for truncating a diagnosis string
			 * @param jQuery object that contains diagnosis details
			 */
			var DxName = function(dxElement) {
				var dxNameElement = $("span.md-scratchpad-dx-col-name", dxElement);
				var dxNameContainer = $("div.md-scratchpad-dx-col-name-container", dxElement);
				var dxEllipsis = $(".md-scratchpad-ellipsis", dxElement);
				return {
					DX_NAME_ELEMENT : dxNameElement,
					DX_NAME_CONTAINER_ELEMENT : dxNameContainer,
					DX_ELLIPSIS : dxEllipsis
				};
			};

			/*
			 * Takes a DxName object and performs the necessary calculations to determine whether
			 * an ellipsis should be displayed on the second line of the diagnosis text (over approximately the last
			 * 3 characters of text)
			 * @param DxName Object
			 */
			var ellipsify = function(dxNameObject) {
				var dxNameHeight = dxNameObject.DX_NAME_ELEMENT.height();
				var nameContainerHeight = dxNameObject.DX_NAME_CONTAINER_ELEMENT.height();
				var dxEllipsisElement = dxNameObject.DX_ELLIPSIS;
				if (dxNameHeight > nameContainerHeight) {
					dxEllipsisElement.css("display", "block");
				} else {
					dxEllipsisElement.css("display", "none");
				}
			};

			var dxElements = $("div.md-scratchpad-dx-col-hgt");
			dxElements.each(function() {
				var curDxElement = $(this);
				var curDxName = new DxName(curDxElement);
				ellipsify(curDxName);
			});
		},
		
		/**
		 * Takes the scratchpad object and creates an XML string for the plan element in the following format
		 * <Plan>
		 * 		<PathwayCatalogId></PathwayCatalogId>
		 * 		<PersonalizedPlanId></PersonalizedPlanId>
		 * 		<Diagnoses>
		 * 			<DiagnosisId><DiagnosisId>
		 *		 </Diagnoses>
		 * </Plan>
		 * @param scratcpadObj, The object that represents single row in the Scratchpad.
		 * @return planXML, a Single Plan element of type string.
		 * */ 
		 CreatePlansXMLString: function(scratchpadObj) {
			if ( typeof scratchpadObj !== "object" || scratchpadObj === null) {
				throw new Error("Cannot create a the Plans XML string on an invalid object");
			}
			var createXMLEleFunc = MP_ScratchPadMgr.CreateXMLElement;
			//IMPORTANT: Do not replace == with === even if JSLint complains. That was done specifically for CR 1-9513197701
			var planXml = createXMLEleFunc("Plan", createXMLEleFunc("PathwayCatalogId", parseFloat(scratchpadObj.favSynId)) + createXMLEleFunc("PersonalizedPlanId", scratchpadObj.favPPEventType == 2 ? parseFloat(scratchpadObj.favSentId) : 0.0) + createXMLEleFunc("Diagnoses", createXMLEleFunc("DiagnosisId", scratchpadObj.favNomenIds != '""' ? (scratchpadObj.favNomenIds).split('|') : 0.0)));
			return planXml;
		},
		/*
		 * Ensures whether the planxml contains all the following nodes{plan, PathwayCatalogId, PersonalizedPlanId, Diagnoses, DiagnosisId}
		 * @param planXML string created by the XMLCreateElement.
		 * @return true for a valid plan, throws an Error when the plan is invalid element.
		 */ 
		 ValidatePlanXML: function(planXML) {
			var validPlan = true;
			var planElements = ['<Plan>', '</Plan>', '<PathwayCatalogId>', '</PathwayCatalogId>', '<PersonalizedPlanId>', '</PersonalizedPlanId>', '<Diagnoses>', '</Diagnoses>', '<DiagnosisId>', '</DiagnosisId>'];
			for (var i = 0; i < planElements.length; i++) {
				if (planXML.indexOf(planElements[i]) === -1) {
					validPlan = false;
					throw new Error("Element " + planElements[i] + " is missing from the new plan element");
				}
			}
			return validPlan;
		},
		/*
		 * Appends a new plan element to the existing powerplans xml. The element is appended at the end of current <Plan> element.s
		 * @param plansXMLString, an exisiting xml string with Plans as start and the end node
		 * @param newPlanElement, a new plan element
		 * @return updatedPlansXMLString, plansXMLString updated with the new plan element. 
		 */ 
		 AppendNewPlanElement: function(plansXMLString, newPlanElement) {
			var indexOfLastNode = plansXMLString.indexOf("</Plans>");
			var validPlanElement = MP_ScratchPadMgr.ValidatePlanXML(newPlanElement);
			if (!plansXMLString || !newPlanElement || typeof plansXMLString !== "string" || typeof newPlanElement !== "string" || !validPlanElement || indexOfLastNode<0) {
				throw new Error("The existing plansXMLString or the newPlanElement is not a valid string");
			}
			var updatedPlansXMLString = plansXMLString.substr(0, indexOfLastNode) + newPlanElement + plansXMLString.substr(indexOfLastNode);
			return updatedPlansXMLString;
		},
		/**
		 * Creates an XML element
		 * @param name: name of the element
		 * @param value value for the name, If value is of type array, a series of xml elements are created with different values.
		 * @return xmlElement, An xml element of type string. 
		 */ 
		 CreateXMLElement: function(name,value) {
			var xmlElement = "";
			if ( typeof name === "undefined" || typeof value === "undefined") {
				throw new Error("Cannot create a new xml element in an invalid name value pair.");
			}
			if (name && !( value instanceof Array)) {
				xmlElement += "<" + name + ">" + (!isNaN(parseFloat(value))?value+".00":value).toString()+ "</" + name + ">";
			} else {
				for (var i = 0; i < value.length; i++) {
					xmlElement += "<" + name + ">" + (!isNaN(parseFloat(value[i]))?value[i]+".00":value[i])+ "</" + name + ">";
				}
			}
			xmlElement = $.trim(xmlElement);
			return xmlElement;
			
		},
		/**
		 * Submit selected orders on the scratch pad
		 * @param {int} goToOrdersFlag : If set, open the orders tab without signing.
		 */
		SubmitOrders: function(goToOrdersFlag) {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;
			var orderParams = [];
			var nomenIds = 0;
			var scratchLen = 0;
			var addPpRet = 0;
			var curCancel = 0;
			var cancelLen = 0;
			var noActionArr = [];
			var tempPPArr = [];
			var personId = 0.0;
			var encntrId = 0.0;
			var orderId = 0;
			var ordersExist = false;
			var criterion = JSON.parse(m_criterionJSON).CRITERION;
			var srObj = MP_ScratchPadMgr.retrieveScratchpadSR();
			var m_hMOEW = null;
			var powerplansXML;
			var planElement;
			var addPPWithDetails = 0;
			
			//Add powerplans to the MOEW
			function addPowerPlans(scratchpadObj) {
					//When the addPowerPlans method is called for the first Plan in the Scractpad array,
					// subsequent calls will append the Plan element to the existing powerplansxml.					
				 if(isOrdersAddPowerPlanDetailsAvailable()) {
						if (typeof powerplansXML === "undefined") {
							powerplansXML = MP_ScratchPadMgr.CreateXMLElement("Plans", MP_ScratchPadMgr.CreatePlansXMLString(scratchpadObj));
						} else {
							planElement = MP_ScratchPadMgr.CreatePlansXMLString(scratchpadObj);
							powerplansXML = MP_ScratchPadMgr.AppendNewPlanElement(powerplansXML, planElement);
						}
					} else{//If the AddPowerPlanWithDetails is not present in the domain then use the previous API	
						if (scratchpadObj.favPPEventType == 2) {
							addPpRet += PowerOrdersMPageUtils.AddPowerPlanMOEW(m_hMOEW, parseFloat(scratchpadObj.favSynId), parseFloat(scratchpadObj.favSentId));
						} else {
							addPpRet += PowerOrdersMPageUtils.AddPowerPlanMOEW(m_hMOEW, parseFloat(scratchpadObj.favSynId), 0.0);
						}
				 	}	
				}
	
			//Save current Dx Associations.
			MP_ScratchPadMgr.SaveToSR();
			personId = criterion.PERSON_ID;
			encntrId = criterion.ENCNTRS[0].ENCNTR_ID;
			//isPowerPlanEnabled is used to either initiate PowerOrders object in domains that have required package,
			//or in domains that don't have required dependency this will allow them to still sign/modify orders/caresets
			var isPowerPlanEnabled = MP_ScratchPadMgr.isPowerPlanOn();
			var PowerOrdersMPageUtils = window.external.DiscernObjectFactory("POWERORDERS");
			if (!PowerOrdersMPageUtils) {
				MP_Util.LogError("Unable to create PowerOrdersMPageUtils object.");
			}
			var addPowerPlanMOEW_Exits = false;
			if ('AddPowerPlanMOEW' in PowerOrdersMPageUtils) {
				addPowerPlanMOEW_Exits = true;
			}
			if (!addPowerPlanMOEW_Exits && isPowerPlanEnabled) {
				MP_Util.LogError("File: neworderentry.js </br>  Function: SubmitOrders </br> Call to POWERORDERS DiscernObjectFactory.AddPowerPlanMOEW Failed.");
			}

			if (srObj) {
				//Retrieve the object from the shared resource.
				var dataObj = srObj.getResourceData();
				if (dataObj) {
					var scratchpadArr = dataObj.scratchpadObjArr;
					var scratchpadObj = null;
					if (scratchpadArr) {
						scratchLen = scratchpadArr.length;

						if (isPowerPlanEnabled && addPowerPlanMOEW_Exits) {
							//create MOEW handle
							//24 = bitmask for MOEW options, 2 = Customizations to Order List, 127 = bitmask to specify which components display
							m_hMOEW = PowerOrdersMPageUtils.CreateMOEW(personId, encntrId, 24, 2, 127);
							if (!m_hMOEW) {
								MP_Util.LogError("Unable to create m_hMOEW object.");
							}
							PowerOrdersMPageUtils.CustomizeTabMOEW(m_hMOEW, 2, 127);
							PowerOrdersMPageUtils.CustomizeTabMOEW(m_hMOEW, 3, 127);
						}
						for (var idx = 0; idx < scratchLen; idx++) {
							scratchpadObj = scratchpadArr[idx];
							var custPlanId = 0.0;
							var favParam = scratchpadObj.favSynId + "|" + scratchpadObj.favVenueType + "|" + scratchpadObj.favSentId;
							if (isPowerPlanEnabled && addPowerPlanMOEW_Exits && scratchpadObj.favType === 2) {//PowerPlan
								if (goToOrdersFlag === 1) {
									addPowerPlans(scratchpadObj);
								} else {
									tempPPArr.push(scratchpadObj);
								}
							} else if (scratchpadObj.ordAction) {
								cancelLen++;
								var prevCancel = curCancel;
								if (scratchpadObj.ordAction === "cancel") {
									orderId = scratchpadObj.ordId;
								}
								//check for the MOEW handle
								if (!m_hMOEW) {
									m_hMOEW = PowerOrdersMPageUtils.CreateMOEW(personId, encntrId, 24, 2, 127);
									if (!m_hMOEW) {
										MP_Util.LogError("Unable to create m_hMOEW object.");
									}
								}

								curCancel += PowerOrdersMPageUtils.InvokeCancelDCAction(m_hMOEW, orderId, "0000000000000000", 0.0);
								if (curCancel === prevCancel) {
									//the invoke was not successful on this order, add it to the fail array
									noActionArr.push(scratchpadObj.favName);
								}
							} else {
								if (scratchpadObj.favNomenIds != '""') {
									nomenIds = "[" + scratchpadObj.favNomenIds + "]";
								} else {
									nomenIds = 0;
								}
								orderParams.push("{ORDER|", favParam, "|", nomenIds, "|1}");
								ordersExist = true;
							}
						}
					}
					//Submit cancel/dc actions
					if (curCancel && goToOrdersFlag === 0) {
						PowerOrdersMPageUtils.SignOrders(m_hMOEW);
						PowerOrdersMPageUtils.DestroyMOEW(m_hMOEW);
						//double check that the MOEW handle is destroyed
						if (m_hMOEW) {
							m_hMOEW = null;
						}
					}
					if (noActionArr.length > 0) {
						//log failed orders
						MP_Util.LogError("The following orders were not successfully canceled:\n" + noActionArr.join("\n"));
						alert(scratchpadcontroli18n.ACTION_NOT_TAKEN);
					}
					if (tempPPArr.length > 0) {
						var PPlen = tempPPArr.length;
						//process powerplans
						if (!m_hMOEW) {
							//create a new MOEW handle
							m_hMOEW = PowerOrdersMPageUtils.CreateMOEW(personId, encntrId, 24, 2, 127);
							if (!m_hMOEW) {
								MP_Util.LogError("Unable to create m_hMOEW object.");
							}
							PowerOrdersMPageUtils.CustomizeTabMOEW(m_hMOEW, 2, 127);
							PowerOrdersMPageUtils.CustomizeTabMOEW(m_hMOEW, 3, 127);
						}
						for (var p = 0; p < PPlen; p++) {
							var curPP = tempPPArr[p];
							addPowerPlans(curPP);
						}
					}
					if(isOrdersAddPowerPlanDetailsAvailable() && isPowerPlanEnabled && typeof powerplansXML !== "undefined") {
						addPPWithDetails += PowerOrdersMPageUtils.AddPowerPlanWithDetails(m_hMOEW, powerplansXML); //Call AddPowerPlanWithDetails method and pass in the powerplanXML string
					}
					// Construct parameter string and submit orders if one or more are checked
					if (goToOrdersFlag !== 1 && scratchLen === 0) {
						alert(scratchpadcontroli18n.NO_ORDERS_SELECTED);
					} else if (goToOrdersFlag !== 1 && encntrId === 0.0) {
						alert(scratchpadcontroli18n.NO_ENCNTR_SELECTED);
					} else {
						//Default ORDER field if no orders selected.
						if (orderParams.length === 0) {
							orderParams.push("{ORDER|0|0|0|0|0}");
						}

						var mpagesParams = [personId, ".0|", encntrId, ".0|"];
						mpagesParams = mpagesParams.concat(orderParams);

						if (goToOrdersFlag === 1) {
							mpagesParams.push('|24|{2|127}{3|127}|32|0');
						} else {
							mpagesParams.push('|24|{2|127}{3|127}|32|1');
						}
						// Submit orders
						if (addPPWithDetails|| addPpRet || ordersExist || (curCancel && goToOrdersFlag === 1)) {
							MP_Util.LogMpagesEventInfo(null, "ORDERS", mpagesParams.join(""), "scratchpadcontrol.js", "SubmitOrders");
							MPAGES_EVENT("ORDERS", mpagesParams.join(""));
						}
						//Update the SharedResource to a blank array now that everything has been submitted
						dataObj.scratchpadObjArr = [];
						//save the blank dataObj back to the shared resource
						MP_Resources.setSharedResourceData(srObj.getName(), dataObj);
						srObj.notifyResourceConsumers();

						//fire event listener to update components
						CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_ORDER_ACTION, 'ScratchPadUtil');
					}

					if (isPowerPlanEnabled && addPowerPlanMOEW_Exits) {
						PowerOrdersMPageUtils.DestroyMOEW(m_hMOEW);
					}
				}
			}
		},

		/**
		 * Initializes the scratch pad functionality.
		 * @scope private
		 */
		init: function() {
			var scratchpadcontroli18n = i18n.discernabu.scratchpadcontrol;

			//set pending data shared resource name
			this.pendingDataSRName = "pendingDataSR";

			//set scratchpad shared resource name
			this.scratchpadSRName = "scratchpadSR";

			//Initialize the shared resource
			var srObj = MP_ScratchPadMgr.initScratchpadSR(this.scratchpadSRName);

			//Set provider/viewpoint ids for easier saving of prefs
			if (m_viewpointJSON) {
				MP_ScratchPadMgr.setViewpointId(JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME);
			}
			if (m_criterionJSON) {
				MP_ScratchPadMgr.setProviderId(JSON.parse(m_criterionJSON).CRITERION.PRSNL_ID);
			}

			//Add Listener for shared resource.
			var object = {};
			CERN_EventListener.addListener(object, EventListener.EVENT_SCRATCHPAD_COUNT_UPDATE, MP_ScratchPadMgr.updateIconText, 0);

			var defaultIconText = scratchpadcontroli18n.PENDING_ORDERS.replace("{0}", "(0)");

			//Create the scratchPad Modal Dialog
			var mdUtil = new ModalDialog("vwpScratchPad");
			mdUtil.activeIconClickEventHandler = function() {
				//Fire CAP timer for scratchPad icon click		
				var scratchpadIconClickCAPTimer = new CapabilityTimer("CAP:MPG MPAGE VIEWPOINT CLICK ON SCRATCHPAD");
				scratchpadIconClickCAPTimer.capture();
				//On load this will be undefined so fire a request.
				if ( typeof MP_ScratchPadMgr.isDxTableChecked() === "undefined") {
					//loadPreferences
					loadPreferences();
					//Configure the checkbox for the modal dialog
					mdUtil.setFooterCheckboxLabel(scratchpadcontroli18n.SHOW_DX_TABLE).setFooterCheckboxEnabled(true).setFooterCheckboxIsChecked(MP_ScratchPadMgr.isDxTableChecked()).setFooterCheckboxClickFunction(function() {
						refreshModalBody();
					});
				}
				MP_ModalDialog.showModalDialog(this.getId());
			};
			mdUtil.setIconClass("md-scratchpad-util-icon-disabled").setIconHoverText(scratchpadcontroli18n.ORDERS_FOR_SIGNATURE).setIconElementId("vwpScratchPadIcon").setIsIconActive(false).setTopMarginPercentage(15).setRightMarginPercentage(15).setBottomMarginPercentage(15).setLeftMarginPercentage(15).setIsBodySizeFixed(false).setHeaderTitle(scratchpadcontroli18n.ORDERS_FOR_SIGNATURE).setBodyDataFunction(function(mdUtil) {
				MP_ScratchPadMgr.loadScratchPadData();
			});

			//Create the buttons for the modal dialog
			var button = new ModalButton("spSignButton");
			button.setText(scratchpadcontroli18n.SIGN).setIsDithered(true).setOnClickFunction(function() {
				//Fire the CAP timer for orders sign button click
				var signButtonClickCAPTimer = new CapabilityTimer("CAP:MPG SCRATCHPAD SIGN ORDERS");
				signButtonClickCAPTimer.capture();
				MP_ScratchPadMgr.SubmitOrders(0);
			}).setCloseOnClick(false);
			mdUtil.addFooterButton(button);

			button = new ModalButton("spSaveButton");
			button.setText(scratchpadcontroli18n.SAVE).setIsDithered(true).setOnClickFunction(function() {
				//Fire the CAP timer
				var saveDxTimer = MP_Util.CreateTimer("CAP:MPG SCRATCHPAD ORDERS FOR SIGNATURE SAVE");
				if (saveDxTimer) {
					saveDxTimer.Start();
					saveDxTimer.Stop();
				}
				MP_ScratchPadMgr.SaveToSR();
			}).setCloseOnClick(false);
			mdUtil.addFooterButton(button);

			button = new ModalButton("spModButton");
			button.setText(scratchpadcontroli18n.MODIFY).setIsDithered(true).setOnClickFunction(function() {
				//Fire the CAP timer
				var modifyDxTimer = MP_Util.CreateTimer("CAP:MPG SCRATCHPAD ORDERS FOR SIGNATURE MODIFY");
				if (modifyDxTimer) {
					modifyDxTimer.Start();
					modifyDxTimer.Stop();
				}
				MP_ScratchPadMgr.SubmitOrders(1);
			}).setCloseOnClick(false);
			mdUtil.addFooterButton(button);

			button = new ModalButton("spCancel");
			button.setText("Cancel").setIsDithered(false).setOnClickFunction(function() {
				writeScratchpadPreferences();
				//Since the modal is closing we no longer need to resize.
				removeModalResizeEvent();
			}).setCloseOnClick(true);
			mdUtil.addFooterButton(button);

			mdUtil.setHeaderCloseFunction(function() {
				writeScratchpadPreferences();
				removeModalResizeEvent();
			});
			MP_ModalDialog.addModalDialogObject(mdUtil);
			MP_ModalDialog.addModalDialogOptionToViewpoint("vwpScratchPad");

			//Modify the margin for this utility since the icon is larger
			$("#" + mdUtil.getIconElementId()).css("margin-top", "2px");
		},
		/**
		 * Returns scratchpad attributes to the default.  Intended for use only in unit testing.
		 * @scope private
		 */
		clear: function(){
			this.subSecHdrOffsetArr = null;
			this.scratchpadSRName = null;
			this.pendingDataSRName = null;
			this.isDxTableCheckedSP = 0;
			this.wasDxTableChkbxClickedSP = false;
			this.providerId = "";
			this.viewpointId = "";
			this.isPowerPlanOnSP = null;
			this.resizeTimeoutId = null;
			this.hasVerticalScroll = null;
		}
	};
}();
var HealtheIntent = HealtheIntent || {};
HealtheIntent.PersonSearch = HealtheIntent.PersonSearch || {};

HealtheIntent.PersonSearch.modal = (function() {
	// private

	var trans = i18n.discernabu.HealtheIntent.PersonSearch;

	function body(id, formId, tableId, addPersonHandler) {
		return "<div class='search-container'>" +
			"<div class='form-section'>" +
			"<form id='" + formId + "'>" +
			"<label class='required' for='name'>" + trans.name + "</label>" +
			"<input class='required' type='text' name='name'>" +
			"<label form='dob'>" + trans.dob + "</label>" +
			"<input id='datepicker' type='text' name='dob'>" +
			"<div class='action-buttons'>" +
			"<input type='submit' name='submit' class='btn' value='" + trans.search + "' disabled>" +
			"<input class='hi_person_search_clear btn' type='button' name='clear' value='" + trans.clear + "'>" +
			"</div>" +
			"</form>" +
			addNewPersonButton(id, addPersonHandler) +
			"</div>" +
			"<div id='" + tableId + "' class='results-section'>" +
			emptyResultsTable(tableId) +
			"</div>" +
			"</div>";
	};

	function addNewPersonButton(id, addPersonHandler) {
		if (typeof(addPersonHandler) == "function") {
			$(document).off("click", ".hi_add_person#hi_add_person_" + id);
			$(document).on("click", ".hi_add_person#hi_add_person_" + id, function() {
				addPersonHandler();
			});

			return "<div class='add-person-section'>" +
				"<input type='button' id='hi_add_person_" + id + "' class='hi_add_person btn' name='add_person' value='" + trans.addPerson + "'>" +
				"</div>";
		}
		else {
			return "";
		}
		;
	}

	function emptyResultsTable(id) {
		return HealtheIntent.PersonSearch.resultsTable(id, []).html();
	}

	function button(id, text, dithered) {
		var button = new ModalButton(id);
		button.setText(text).setIsDithered(!!dithered).closeOnClick(true);

		return button;
	};

	function create(id, formId, tableId, addPersonHandler) {
		return new ModalDialog("HealtheIntent_PersonSearch_" + id)
			.setTopMarginPercentage(20)
			.setBottomMarginPercentage(20)
			.setHasGrayBackground(true)
			.setIsBodySizeFixed(true)
			.setIsFooterAlwaysShown(true)
			.setLeftMarginPercentage(10)
			.setRightMarginPercentage(10)
			.setHeaderTitle(trans.modalHeader)
			.addFooterButton(button("hi_person_search_modal_select", trans.ok, true))
			.addFooterButton(button("hi_person_search_modal_cancel", trans.cancel))
			.setBodyDataFunction(function(modal) {
				modal.setBodyHTML(body(id, formId, tableId, addPersonHandler));
			});
	};

	// private api exposed for testing
	HealtheIntent.PersonSearch.__modal = {
		addNewPersonButton: addNewPersonButton,
		body: body,
		button: button,
		create: create,
		emptyResultsTable: emptyResultsTable
	};

	// public

	function activateSelectButton(onSelectHandler) {
		return this
			.setFooterButtonDither('hi_person_search_modal_select', false)
			.setFooterButtonOnClickFunction('hi_person_search_modal_select', onSelectHandler);
	};

	function deactivateSelectButton() {
		return this
			.setFooterButtonDither('hi_person_search_modal_select', true)
			.setFooterButtonOnClickFunction('hi_person_search_modal_select', function() {
			});
	}

	function show() {
		MP_ModalDialog.addModalDialogObject(this);
		MP_ModalDialog.showModalDialog(this.getId());

		this.finalize();
		return this;
	};

	function reset() {
		this
			.setBodyHTML(body(this.id, this.formId, this.tableId, this.addPersonHandler))
			.setFooterButtonDither('hi_person_search_modal_select', true)
			.setFooterButtonOnClickFunction('hi_person_search_modal_select', function() {
			});

		this.finalize();
		return this;
	}

	function validateNameInput(formId) {
		var $name = $("#" + formId + " input[name='name']"); 
		var name = $name.val();
		name = name && name.replace(/^\s+|\s+$/gm, ''); // trim whitespace

		$("#" + formId + " input[name='submit']").prop("disabled", !name);
		name ? $name.removeClass('required') : $name.addClass('required');
	}

	function finalize() {
		var calendarIcon = CERN_static_content + "/UnifiedContent/images/4974.png",
			modal = this,
			currentYear = new Date().getFullYear();

		// add "hi_person_search" class on modal's main div to namespace all our css and
		// set focus to Name Search field.
		$("#vwpModalDialog" + this.getId())
			.addClass("hi_person_search")
			.find("input[name='name']").focus();

		// add a reset handler on "clear" button (this button defined in modal#body function)
		$(document).on("click", "#" + this.formId + " .hi_person_search_clear", function() {
			modal.reset();
		});

		// disable search button and add yellow background to name input when no data is entered in name input field
		$(document).on("keyup", "#" + this.formId + " input[name='name']", function() {
			validateNameInput(modal.formId);
		});

		// add jquery datepicker to the dob input field (element defined in modal#body function)
		$('.hi_person_search form #datepicker').datepicker({
			buttonImage: calendarIcon,
			buttonImageOnly: true,
			changeMonth: true,
			changeYear: true,
			dateFormat: trans.dateFormatDatePicker,
			showOn: "both",
			yearRange: "1900:" + currentYear
		});
	}

	return function(id, formId, tableId, addPersonHandler) {
		var modal = create(id, formId, tableId, addPersonHandler);

		// Appending to the public api
		modal.id = id;
		modal.formId = formId;
		modal.tableId = tableId;

		modal.addPersonHandler = addPersonHandler;
		modal.activateSelectButton = activateSelectButton;
		modal.deactivateSelectButton = deactivateSelectButton;
		modal.finalize = finalize;
		modal.show = show;
		modal.reset = reset;

		return modal;
	};
})();
/**
 * The getDstSwitches function has been obtained from a third party source which can be found in the link below:
 * http://www.codeproject.com/Articles/58728/JavaScript-code-to-determine-when-DayLight-Savings
 * License for it can be found here: http://www.codeproject.com/info/cpol10.aspx
 */
/**
 * @class
 * This TimeZone object will be used to store the respective information about each timezone.
 * It will determine the correct abbreviation on basis of whether DST is observed in a timezone.
 * It will also store the DST transition information for any particular year.
 * @param {String} m_name The unique timezone name from JSTimeZoneDetect library
 * @param {String} m_abbr The abbreviation to be displayed when in Standard Time
 * @param {String} m_dst_abbr The abbreviation to be displayed when in Daylight Time
 * @param {Object} m_dst_info The transition time information for the timezone
 * @param {Number} m_tz_index The time zone index value from srvcalendars
 */
var TimeZone = function(name,abbr,dst_abbr,info,tz_index){
	this.m_name = name;
	this.m_abbr = abbr;
	this.m_dst_abbr = dst_abbr;
	this.m_dst_info = info;
	this.m_tz_index = tz_index;
};

/**
 * Returns the time zone index value
 * @return {Number} The TimeZone index value
 */
TimeZone.prototype.getTzIndex = function(){
	return this.m_tz_index;
};

/**
 * Returns the unique name assigned to the TimeZone
 * @return {String} The TimeZones unique name
 */
TimeZone.prototype.getName = function(){
	return  this.m_name;
};

/**
 * Set the unique name for the TimeZone Object
 * @param {String} name The unique name to be given to the TimeZone
 */
TimeZone.prototype.setName = function(name){
	if(typeof name !== "string"){
		throw new Error("TimeZone: Invalid timezone name");
	}
	this.m_name = name;
};

/**
 * Returns the standard time abbreviation of the TimeZone
 * @return {String} The TimeZones standard abbreviation
 */
TimeZone.prototype.getStandardAbbreviation = function() {
	return this.m_abbr;
};

/**
 * Set the Standard time abbreviation for the TimeZone
 * @param {String} abbr The standard abbreviation to be set for the TimeZone
 */
TimeZone.prototype.setStandardAbbreviation = function(abbr){
	if(typeof abbr !== "string"){
		throw new Error("TimeZone: Invalid standard timezone abbreviation");
	}
	this.m_abbr = abbr;
};

/**
 * Returns the daylight time abbreviation of the TimeZone
 * @return {String} The TimeZones daylight abbreviation
 */
TimeZone.prototype.getDaylightAbbreviation = function() {
	return this.m_dst_abbr;
};

/**
 * Set the Daylight time abbreviation for the TimeZone
 * @param {String} abbr The daylight abbreviation to be set for the TimeZone
 */
TimeZone.prototype.setDaylightAbbreviation = function(abbr){
	if(typeof abbr !== "string"){
		throw new Error("TimeZone: Invalid daylight timezone abbreviation");
	}
	this.m_dst_abbr = abbr;
};

/**
 * Return the DST transition information of a TimeZone
 */
TimeZone.prototype.getDSTInfo = function(){
	return this.m_dst_info;
};

/**
 * Set the Daylight time information for the TimeZone
 * @param {String} key The key for the hashmap usually a year
 * @param {Object} value The value to be set for corresponding key
 */
TimeZone.prototype.setDSTInfo = function(key, value){
	this.m_dst_info[key] = value;
};

/**
 * Create mappings of TimeZone object for each unique value that can be returned by the
 * JSTimeZoneDetect library.
 */
var timezones = {};
timezones.mapping = {
	'Etc/GMT+12'   : new TimeZone('Etc/GMT+12', "DST", "DST", {}, 1),
	'Pacific/Pago_Pago'   : new TimeZone('Pacific/Pago_Pago',  "SST", "SST", {}, 7),
	'America/Adak'   : new TimeZone('America/Adak',  "HAST", "HADT", {}, 10),
	'Pacific/Apia' : new TimeZone('Pacific/Apia',  "WST", "WST", {}, 4),
	'Pacific/Honolulu'   : new TimeZone('Pacific/Honolulu',  "HAST", "HAST", {}, 15),
	'Pacific/Marquesas'   : new TimeZone('Pacific/Marquesas',  "MART", "MART", {}, 22),
	'Pacific/Gambier'   : new TimeZone('Pacific/Gambier',  "GAMT", "GAMT", {}, 29),
	'America/Anchorage'   : new TimeZone('America/Anchorage',  "AKST", "AKDT", {}, 24),
	'America/Los_Angeles'   : new TimeZone('America/Los_Angeles',  "PST", "PDT", {}, 35),
	'America/Santa_Isabel'   : new TimeZone('America/Santa_Isabel',  "PST", "PDT", {}, 607),
	'Pacific/Pitcairn'   : new TimeZone('Pacific/Pitcairn',  "PST", "PST", {}, 45),
	'America/Phoenix'   : new TimeZone('America/Phoenix',  "MST", "MST", {}, 59),
	'America/Denver'   : new TimeZone('America/Denver',  "MST", "MDT", {}, 54),
	'America/Mazatlan'   : new TimeZone('America/Mazatlan',  "MST", "MDT", {}, 58),
	'America/Guatemala'   : new TimeZone('America/Guatemala',  "CST", "CST", {}, 78),
	'America/Chicago'   : new TimeZone('America/Chicago',  "CST", "CDT", {}, 75),
	'America/Mexico_City'   : new TimeZone('America/Mexico_City',  "CST", "CDT", {}, 82),
	'Pacific/Easter' : new TimeZone('Pacific/Easter',  "EAST", "EASST", {}, 99),
	'America/Bogota'   : new TimeZone('America/Bogota',  "COT", "COT", {}, 104),
	'America/New_York'   : new TimeZone('America/New_York',  "EST", "EDT", {}, 126),
	'America/Havana'   : new TimeZone('America/Havana',  "CST", "CDT", {}, 111),
	'America/Caracas'   : new TimeZone('America/Caracas',  "VET", "VET", {}, 154),
	'America/Halifax'   : new TimeZone('America/Halifax',  "AST", "ADT", {}, 163),
	'America/Goose_Bay'   : new TimeZone('America/Goose_Bay',  "AST", "ADT", {}, 159),
	'America/Santo_Domingo'   : new TimeZone('America/Santo_Domingo',  "AST", "AST", {}, 172),
	'America/Asuncion' : new TimeZone('America/Asuncion',  "PYT", "PYST", {}, 151),
	'America/Santiago' : new TimeZone('America/Santiago',  "CLT", "CLST", {}, 171),
	'America/Campo_Grande' : new TimeZone('America/Campo_Grande',  "AMT", "AMST", {}, 573),
	'America/St_Johns'   : new TimeZone('America/St_Johns',  "NST", "NDT", {}, 190),
	'America/Godthab'   : new TimeZone('America/Godthab',  "WGT", "WGST", {}, 201),
	'America/Miquelon'   : new TimeZone('America/Miquelon',  "PMST", "PMDT", {}, 205),
	'America/Argentina/Buenos_Aires'   : new TimeZone('America/Argentina/Buenos_Aires', "ART", "ART", {}, 562),
	'America/Montevideo' : new TimeZone('America/Montevideo',  "UYT", "UYST", {}, 206),
	'America/Sao_Paulo' : new TimeZone('America/Sao_Paulo',  "BRT", "BRST", {}, 210),
	'America/Noronha'   : new TimeZone('America/Noronha',  "FNT", "FNT", {}, 214),
	'Atlantic/Azores'    : new TimeZone('Atlantic/Azores',  "AZOT", "AZOST", {}, 219),
	'Atlantic/Cape_Verde'    : new TimeZone('Atlantic/Cape_Verde',  "CVT", "CVT", {}, 220),
	'UTC'      : new TimeZone('UTC',  "GMT", "GMT", {}, 266),
	'Europe/London'      : new TimeZone( 'Europe/London',  "WET", "WEST", {}, 257),
	'Europe/Berlin'     : new TimeZone('Europe/Berlin',  "CET", "CEST", {}, 293),
	'Europe/Helsinki' : new TimeZone("Europe/Helsinki", "EET", "EEST", {}, 350),
	'Africa/Lagos'     : new TimeZone('Africa/Lagos',  "WAT", "WAT", {}, 276),
	'Africa/Windhoek'   : new TimeZone('Africa/Windhoek',  "WAT", "WAST", {}, 284),
	'Asia/Beirut'    : new TimeZone('Asia/Beirut',  "EET", "EEST", {}, 336),
	'Asia/Amman'    : new TimeZone('Asia/Amman',  "AST", "AST", {}, 335),
	'Asia/Jerusalem'    : new TimeZone('Asia/Jerusalem',  "IST", "IDT", {}, 340),
	'Asia/Damascus'    : new TimeZone('Asia/Damascus',  "EET", "EEST", {}, 337),
	'Africa/Cairo'    : new TimeZone('Africa/Cairo',  "EET", "EET", {}, 324),
	'Asia/Gaza'    : new TimeZone('Asia/Gaza',  "EET", "EEST", {}, 338),
	'Europe/Minsk'    : new TimeZone('Europe/Minsk',  "FET", "FET", {}, 354),
	'Africa/Johannesburg'    : new TimeZone('Africa/Johannesburg',  "SAST", "SAST", {}, 327),
	'Europe/Moscow'    : new TimeZone('Europe/Moscow',  "MSK", "MSK", {}, 384),
	'Asia/Baghdad'    : new TimeZone('Asia/Baghdad',  "AST", "AST", {}, 377),
	'Asia/Tehran'    : new TimeZone('Asia/Tehran',  "IRST", "IRDT", {}, 395),
	'Asia/Dubai'    : new TimeZone('Asia/Dubai',  "GST", "GST", {}, 399),
	'Asia/Yerevan'    : new TimeZone('Asia/Yerevan',  "AMT", "AMT", {}, 403),
	'Asia/Baku'    : new TimeZone('Asia/Baku',  "AZT", "AZST", {}, 398),
	'Asia/Kabul'    : new TimeZone('Asia/Kabul',  "AFT", "AFT", {}, 410),
	'Asia/Yekaterinburg'    : new TimeZone('Asia/Yekaterinburg',  "YEKT", "YEKT", {}, 419),
	'Asia/Karachi'    : new TimeZone('Asia/Karachi',  "PKT", "PKT", {}, 416),
	'Asia/Kolkata'    : new TimeZone('Asia/Kolkata',  "IST", "IST", {}, 596),
	'Asia/Kathmandu'    : new TimeZone('Asia/Kathmandu',  "NPT", "NPT", {}, 597),
	'Asia/Dhaka'    : new TimeZone('Asia/Dhaka',  "BST", "BST", {}, 432),
	'Asia/Omsk'    : new TimeZone('Asia/Omsk',  "OMST", "OMST", {}, 434),
	'Asia/Rangoon'    : new TimeZone('Asia/Rangoon',  "MMT", "MMT", {}, 441),
	'Asia/Krasnoyarsk'    : new TimeZone('Asia/Krasnoyarsk',  "KRAT", "KRAT", {}, 447),
	'Asia/Jakarta'    : new TimeZone('Asia/Jakarta',  "WIB", "WIB", {}, 446),
	'Asia/Shanghai'    : new TimeZone('Asia/Shanghai',  "CST", "CST", {}, 469),
	'Asia/Irkutsk'    : new TimeZone('Asia/Irkutsk',  "IRKT", "IRKT", {}, 461),
	'Australia/Perth'    : new TimeZone('Australia/Perth',  "AWST", "AWST", {}, 476),
	'Australia/Eucla'    : new TimeZone('Australia/Eucla',  "ACWST", "ACWST", {}, 582),
	'Asia/Yakutsk'    : new TimeZone('Asia/Yakutsk',  "YAKT", "YAKT", {}, 489),
	'Asia/Tokyo'    : new TimeZone('Asia/Tokyo',  "JST", "JST", {}, 488),
	'Australia/Darwin'    : new TimeZone('Australia/Darwin',  "ACST", "ACST", {}, 498),
	'Australia/Adelaide'  : new TimeZone('Australia/Adelaide',  "ACST", "ACDT", {}, 496),
	'Australia/Brisbane'    : new TimeZone('Australia/Brisbane',  "AEST","AEST",{}, 507),
	'Asia/Vladivostok'    : new TimeZone('Asia/Vladivostok',  "VLAT", "VLAT", {}, 505),
	'Australia/Sydney'  : new TimeZone('Australia/Sydney',  "AEST", "AEDT", {}, 514),
	'Australia/Lord_Howe'  : new TimeZone('Australia/Lord_Howe',  "LHST", "LHDT", {}, 524),
	'Asia/Kamchatka'    : new TimeZone('Asia/Kamchatka',  "PETT", "PETT", {}, 537),
	'Pacific/Noumea'    : new TimeZone('Pacific/Noumea',  "NCT", "NCT", {}, 530),
	'Pacific/Norfolk'    : new TimeZone('Pacific/Norfolk',  "NFT", "NFT", {}, 533),
	'Pacific/Auckland'  : new TimeZone('Pacific/Auckland',  "NZST", "NZDT", {}, 542),
	'Pacific/Fiji'  : new TimeZone('Pacific/Fiji',  "FJT", "FJST", {}, 543),
	'Pacific/Majuro'    : new TimeZone('Pacific/Tarawa',  "GILT", "GILT", {}, 546),
	'Pacific/Chatham'  : new TimeZone('Pacific/Chatham',  "CHAST", "CHADT", {}, 552),
	'Pacific/Tongatapu'    : new TimeZone('Pacific/Tongatapu',  "TOT", "TOT", {}, 555),
	'Pacific/Kiritimati'    : new TimeZone('Pacific/Kiritimati',  "LINT", "LINT", {}, 557)
};

/**
 * Global TimeZone object which will store the timezone information from where MPages is viewed. 
 */
var MP_Timezone = {};
MP_Timezone = timezones.mapping[jstz.determine().name()];

/**
 * This function determines the DST transition switches for a timezone for any particular year.
 * For example, consider we are in America/Chicago timezone in year 2015 then the DST switches correct to 1 second of difference
 * will be returned as an Object.
	{
		first: {
			from: Sun Mar 08 2015 01:59:59 GMT-0600 (Central Standard Time)
			to: Sun Mar 08 2015 03:00:00 GMT-0500 (Central Daylight Time)
		},
		second: {
			from: Sun Nov 01 2015 01:59:59 GMT-0500 (Central Daylight Time)
			to: Sun Nov 01 2015 01:00:00 GMT-0600 (Central Standard Time)
		}
	}
 * More info can be found here: http://www.codeproject.com/Articles/58728/JavaScript-code-to-determine-when-DayLight-Savings	
 * @param {Number} year The year for which the DST transition switches are to be found.
 * @return {Object} The two DST switches date time for a particular year
 */
TimeZone.prototype.getDstSwitches = function(year) {
	var p=1000, 
	tzo=function(n){
		return new Date(n*p).getTimezoneOffset();
	},
	f = function (a, b){
		return tzo(a) !== tzo(b);
	}, 
	search,
	dec = new Date(year-1,11,21,12)/p, 
	jun = new Date(year,5,21,12)/p;

	if (!f(dec, jun)){
		return null;
	}

	search = function (a,b) {
		var m;
		while(b-a>1){
			m=a+(b-a>>1);
			f(m,b)?a=m:b=m;
		}
		return{from:a*p,to:b*p};
	};
	return { first: search(dec,jun), second: search(jun,new Date(year,11,21,12)/p) };
};

/**
 * This function will determine the ambiguous end time frames of a timezone for a particular year.
 * It will return an Object denoting the last one hour time frame of Daylight time and starting one hour time frame of Standard time
 * when the time repeats itself.
 * For example, if we are in America/Chicago timezone in 2015 year,then we get the following in return on calling this function.
	{
		dst_trans_day_start: 1st Nov 1.00:00 am CDT,
		dst_trans_day_end: 1st Nov 1:59:59 am CDT,
		dst_trans_std_start: 1st Nov 1:00:00 am CST,
		dst_trans_std_end: 1st Nov 1:59:59 CST
	}
 * @param {dstSwitches} Object The two DST switches date time for a particular year 
 * @return {Object} The one hour end and start time frame of Daylight time and Standard time when DST ends.
 */
TimeZone.prototype.getAmbiguousEndDates = function(dstSwitches) {
	if(dstSwitches){
		/**
		 * Find the difference in offset between the DST transition dates once when they move ahead by one hour
		 * and once when they fall back by one hour.
		 */
		var firstDiff = (new Date(dstSwitches.first.from).getTimezoneOffset() - new Date(dstSwitches.first.to).getTimezoneOffset());
		var secondDiff = (new Date(dstSwitches.second.from).getTimezoneOffset() - new Date(dstSwitches.second.to).getTimezoneOffset());
		var daylightStart = new Date();
		var daylightEnd = new Date();
		var standardStart = new Date();
		var standardEnd = new Date();
		/**
		 * dstSwitches.first will store the transition date within the first half of the year.
		 * dstSwitches.second will store the transition date within the second half of the year.
		 * If first difference is less than second then the timezone is in Southern Hemisphere(i.e. dstSwitches.first is the end date)
		 * and if second difference is less then the timezone is in Northern Hemisphere(i.e. dstSwitches.second is the end date)
		 * (59*61*1000) is added or subtracted to get the respective one hour time frame of Daylight and Standard Time when DST ends.
		 * (59*61*1000) was arrived from 59mins 59secs. In milliseconds they will be obtained by simplifying(59*60*1000+59*1000).
		 */
		if(firstDiff < secondDiff){
			daylightStart = new Date().setTime(new Date(dstSwitches.first.from).getTime()-(59*61*1000));
			standardEnd = new Date().setTime(new Date(dstSwitches.first.to).getTime()+(59*61*1000));
			daylightEnd = new Date().setTime(dstSwitches.first.from);
			standardStart = new Date().setTime(dstSwitches.first.to);
		} else if(firstDiff > secondDiff){
			daylightStart = new Date().setTime(new Date(dstSwitches.second.from).getTime()-(59*61*1000));
			standardEnd = new Date().setTime(new Date(dstSwitches.second.to).getTime()+(59*61*1000));
			daylightEnd = new Date().setTime(dstSwitches.second.from);
			standardStart = new Date().setTime(dstSwitches.second.to);
		}
		return {dst_trans_day_start:daylightStart, dst_trans_day_end:daylightEnd, dst_trans_std_start:standardStart , dst_trans_std_end:standardEnd};
	}
};

/**
 * This function will return the correct abbreviation to be displayed for DST observing timezones.
 * @param {Date} date The date for which timezone information has to be retrieved
 * @param {formatMask} String The date format masks for which timezones need to be calculated.
 * @return {String} The timezone abbreviation
 */
TimeZone.prototype.getTimeZone = function (date, formatMask) {
	var locale = MPAGE_LOCALE;
	var dateTime = new Date();
	var mask = (formatMask) ? formatMask : "";
	var validMask = false;
	if (date) {
		dateTime = date;
	}
	var supportedDSTMasks = {
		"longDateTime2" : 1,
		"longDateTime3" : 1,
		"shortTime" : 1,
		"mediumTime" : 1,
		"militaryTime" : 1,
		"isoTime" : 1,
		"shortDateTime" : 1,
		//fulldatetimenoyr
		"mm/dd h:MM TT" : 1,
		"dd/mm h:MM TT" : 1,
		"dd.mm h:MM TT" : 1,
		//default format
		"ddd dd.mm.yyyy HH:MM:ss" : 1,
		"ddd, dd mmm yyyy HH:MM:ss" : 1,
		"ddd mmm dd yyyy HH:MM:ss" : 1,
		//shortTime
		"h:MM TT" : 1,
		//mediumTime
		"h:MM:ss TT" : 1,
		"h:MM:ss TT" : 1,
		//time24hrnosec and militaryTime
		"HH:MM" : 1, 
		//time24hr and isoTime
		"HH:MM:ss" : 1,
		//longDateTime2 and fulldatetime2yr
		"mm/dd/yy HH:MM" : 1,
		"dd/mm/yy HH:MM" : 1,
		"dd.mm.yy HH:MM" : 1, 
		//longDateTime3 and fulldatetime4yr
		"mm/dd/yyyy HH:MM" : 1,
		"dd/mm/yyyy HH:MM" : 1,
		"dd.mm.yyyy HH:MM" : 1,		
		//shortDateTime
		"mm/dd h:MM TT" : 1,
		"dd/mm HH:MM" : 1,
		"dd.mm. HH:MM" : 1,
		"dd/mm HH:MM TT" : 1,
		//custom time format used in Meds WF
		"mmmm dd, yyyy HH:MM" : 1,
		"default" : 1
	};
	//Supported date formats for which timezones will be displayed.
	if(mask in supportedDSTMasks) {
		validMask = true;
	}
	var yr = dateTime.getFullYear();
	/**
	 * Check if DST indicator is set for that particular year. If yes the DST information for that year has already been calculated and no
	 * need to calculate again. If it not set then enter the if block. This block will be entered only once for a year.
	 */
	if (!this.m_dst_info[yr+'_dst_ind']) {
		this.setDSTInfo(yr+'_dst_ind',this.isDSTObserved(yr));
		/** 
		 * If DST transition information hasn't been calculated yet go ahead and calculate it
		 * If DST indicator is 0(i.e. timezone does not observe DST) then directly return "" as timezone abbreviation.
		 * This block too will be entered only once for an year in DST enabled zones.
		 */
		if (!this.m_dst_info[yr] && this.m_dst_info[yr+'_dst_ind']) {
			var dstSwitchDates = this.getDstSwitches(yr);
			if (dstSwitchDates) {
				this.setDSTInfo(yr,this.getAmbiguousEndDates(dstSwitchDates));
			}
		} else{
			//If DST is not observed directly return null as we wont show those timezone values.
			return "";
		}
	}
	if(validMask){
		if (date >= this.m_dst_info[yr].dst_trans_day_start && date <= this.m_dst_info[yr].dst_trans_day_end) {
			//If date falls within Daylight end 1 hour time frame return DST abbreviation
			return this.m_dst_abbr;
		} else if (date >= this.m_dst_info[yr].dst_trans_std_start && date <= this.m_dst_info[yr].dst_trans_std_end) {
			//If date falls within Standard start 1 hour time frame return STD abbreviation
			return this.m_abbr;
		}
	}
	return "";
};

/** 
 * To check whether the timezone observes DST for an particular year
 * @param {Number} year The year for which we need to check if DST is on or off
 * @return {Number} 0 if daylight savings time is NOT observed and 1 if daylight savings time is observed.
 */
TimeZone.prototype.isDSTObserved = function (year) {
	var curYearJanDate = new Date(year, 0, 1, 0, 0, 0, 0); 
	var strCurYearJanUTCDate = curYearJanDate.toUTCString(); 
	var curYearJanUTCDate = new Date(strCurYearJanUTCDate.substring(0, strCurYearJanUTCDate.lastIndexOf(" ")-1)); 
	var std_time_offset = (curYearJanDate - curYearJanUTCDate) / (1000 * 60 * 60);	

	var curYearJuneDate = new Date(year, 6, 1, 0, 0, 0, 0);
	var strCurYearJuneUTCDate = curYearJuneDate.toUTCString();
	var curYearJuneUTCDate = new Date(strCurYearJuneUTCDate.substring(0, strCurYearJuneUTCDate.lastIndexOf(" ")-1));
	var daylight_time_offset = (curYearJuneDate - curYearJuneUTCDate) / (1000 * 60 * 60);
	
	if (std_time_offset === daylight_time_offset) {
		return 0; // daylight savings time is NOT observed
	} else {
		return 1; // daylight savings time is observed
	}
};
var HealtheIntent = HealtheIntent || {};
HealtheIntent.Utils = HealtheIntent.Utils || {};

/**
 * Converts a jquery form object to a json object with name-value of the input
 * elements in the form.
 *
 * @param  {Jquery form} $form - form element retrieved from the DOM.
 * @param {Object} [map] - Mapping between the form element names and the keys of the object beign returned.
 *
 * @return {Object} - name-value pairs of form input elements.
 */
HealtheIntent.Utils.serializeFormToJson = function($form, map) {
	var formElements = $form.serializeArray(), // [{name: 'a', value: '1'}, {name: 'b', value: '2'}]
		formJsonObj = {},
		mappedForm = {};

	$.each(formElements, function(_, inputElement) {
		formJsonObj[inputElement.name] = inputElement.value;
	});

	map && $.each(map, function(key, value) {
		mappedForm[value] = formJsonObj[key];
	});

	return map ? mappedForm : formJsonObj; // {a: '1', b: '2'}
};

/**
 * Calls the HealtheIntent services using a service registrar key or a test url.
 * Implemented as a wrapper on top of Mpage standard framework ScriptRequest.
 *
 * @param {String} templateKey - service registrar key for the http service to be requested
 * @param {Object} params - an object of key-value pairs to be passed as service query params.
 * @param {Object} settings - setting for the ComponentScriptReply.
 *        {RTMSTimer} [loadTimer=new RTMSTimer(component.getComponentLoadTimerName())]
 *        {String} [personId] -
 *        {String} [providerId] -
 *
 * @return {Jquery.Promise} - Async promise that will retrieve data from HeatheIntent Service.
 */
HealtheIntent.Utils.serviceRequest = (function() {
	function cclParams(template, personId, providerId, params) {
		var template = "^" + template + "^",
			personId = (personId && personId + ".0") || "0.0",
			providerId = (providerId && providerId + ".0") || "0.0";

		var templateArgs = $.map(removeBlank(params), function(value, key) {
			return (key + "=" + value);
		}).join(";");

		return ["^MINE^", template, "^JSON^", personId, providerId, "^" + templateArgs + "^"];
	};

	function removeBlank(params) {
		var cleanParams = {};

		params && $.each(params, function(key, value) {
			if (value !== undefined && value !== null && value !== "") {
				cleanParams[key] = value;
			}
		});

		return cleanParams;
	}

	function parseReply(reply) {
		var response = reply.getResponse(),
			proxyReply = response && JSON.parse(response).PROXYREPLY,
			status = proxyReply && proxyReply.HTTPREPLY && proxyReply.HTTPREPLY.STATUS,
			successInd = proxyReply && proxyReply.TRANSACTIONSTATUS && proxyReply.TRANSACTIONSTATUS.SUCCESSIND;

		if (successInd == 1 && status == 200) {
			return JSON.parse(proxyReply.HTTPREPLY.BODY);
		}
	};

	function createRequest(templateKey, params, settings, callback) {
		var scriptRequest = new ScriptRequest();
		settings.loadTimer && serviceRequest.setLoadTimer(settings.loadTimer);

		return scriptRequest
			.setParameterArray(cclParams(templateKey, settings.personId, settings.providerId, params))
			.setProgramName('HI_HTTP_PROXY_GET_REQUEST')
			.setRawDataIndicator(true)
			.setResponseHandler(callback)
			.performRequest();
	};

	// private api exposed for testing
	HealtheIntent.Utils.__serviceRequest = {
		cclParams: cclParams,
		createRequest: createRequest,
		parseReply: parseReply
	};

	return function requestPromise(templateKey, params, settings) {
		var deferred = $.Deferred(),
			settings = settings || {personId: null, providerId: null, loadTimer: null};

		createRequest(templateKey, params, settings, function(reply) {
			var bodyJson = parseReply(reply);
			bodyJson ? deferred.resolve(bodyJson) : deferred.reject(reply);
		});

		return deferred.promise();
	};
})();
/**
 * XR Print Modal Dialog Util.
 * @class
 * @scope public
 */

var MD_xrPrintDialog = function() {
	var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
	var m_rsnTemplReplyObj;
	var m_rsnTemplReply;
	this.m_criterion = null;
	this.m_timeoutCallback = function() {
		alert(xrPrintModalI18n.NOTIMEOUT);
	};

	return {

		/**

		 * @scope public
		 */

		addVwpIcon: function() {
			var xrPrintVwpTrigger = $('<div class="vwp-util" id="vwpXrPrint"><div class="vwp-util-icon ipass-util-icon" id="vwpXrPrintIcon">&nbsp;</div></div>');
			xrPrintVwpTrigger.click(function() {
				MD_xrPrintDialog.initializeModalObject();
			});
			$("#vwpUtilities").append(xrPrintVwpTrigger);
			MD_xrPrintDialog.setCriterion(JSON.parse(m_criterionJSON).CRITERION);

			var handleFunc = function() {
				location.href = "../../index.html";
			};

			MD_xrPrintDialog.setTimeoutCallback(handleFunc);

		},

		setTimeoutCallback: function(callback) {
			this.m_timeoutCallback = callback;
		},

		getTimeoutCallback: function() {
			return this.m_timeoutCallback;
		},

		setCriterion: function(criterion) {
			this.m_criterion = criterion;
		},

		initializeModalObject: function() {
			var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
			var xrCreateReportBtn = new ModalButton("xrCreateReportBtn");
			var xrCancelBtn = new ModalButton("xrCancelBtn");
			xrCreateReportBtn.setText(xrPrintModalI18n.CREATEREPORT).setIsDithered(false).setCloseOnClick(false).setOnClickFunction(function() {
				MD_xrPrintDialog.submitValidateInput();
			});
			xrCancelBtn.setText(xrPrintModalI18n.CANCELBTNTXT);
			xrCancelBtn.setFocusInd(true);

			var xrprintUtil = new ModalDialog("modalXRPrint");
			xrprintUtil.setTopMarginPercentage(18).setRightMarginPercentage(33).setBottomMarginPercentage(18).setLeftMarginPercentage(33);
			xrprintUtil.setIsBodySizeFixed(false);
			xrprintUtil.setHeaderTitle("<span>" + xrPrintModalI18n.CREATEREPORT + "</span>");
			xrprintUtil.addFooterButton();
			xrprintUtil.setBodyDataFunction(function(modalObj) {
				MD_xrPrintDialog.init(modalObj);
			});
			//Add XR Print Modal buttons
			xrprintUtil.addFooterButton(xrCreateReportBtn);
			xrprintUtil.addFooterButton(xrCancelBtn);
			//Add XR Print Modal Dialog
			MP_ModalDialog.addModalDialogObject(xrprintUtil);
			MP_ModalDialog.showModalDialog("modalXRPrint");
		},

		/**
		 * This function will build the xr print failure/error html for the modal window.
		 * @class
		 * @scope public
		 */
		buildErrorHTML: function() {
			var xrPrintModalI18n = i18n.discernabu.xr_print_modal;

			var xrBody = $('#modalXRPrintbody');

			var xrStatus = MD_xrPrintDialog.m_rsnTemplReplyObj.STATUS_DATA.STATUS;

			var xrFailStart = '<div id="xrFailure" class="xr-error-msg">' + '<div class="xr-error-info">' + '<p class="xr-error-full">';

			var xrMsg;
			if (xrStatus == "F") {
				xrMsg = xrPrintModalI18n.NOAVAILTEMPLS;
			}
			else {
				xrMsg = xrPrintModalI18n.NOAVAILTEMPLUSR;
			}

			var xrFailEnd = '</p></div>' + '<p class="xr-error-min">' + xrPrintModalI18n.CONTACTADMIN + '</p></div>';

			var xrFailed = xrFailStart + xrMsg + xrFailEnd;

			//innerhtml error info
			$(xrBody).html(xrFailed);

		},

		/**
		 * This function will build the xr print html for the modal window.
		 * @class
		 * @scope public
		 */
		buildHTML: function() {
			var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
			m_rsnTemplReply = MD_xrPrintDialog.m_rsnTemplReplyObj.getResponse();

			var xrBody = $('#modalXRPrintbody');

			//Remove loading icon
			$(xrBody).removeClass('xr-report-loading');
			
			//Display XR print contents
			$('#xrPrintContent').removeClass('xr-content-hidden');

			//XR Reason logic
			var rsn_size = m_rsnTemplReply.REASONCD.length;

			var rHTML = [];
			var rsnHTML = "";

			if (rsn_size) {
				rHTML.push('<select id="xrReasons" class="xr-dropdown xr-default-opt" name="xrReasons"><option id="xrPlaceHolder" value="0"></option>');
				for (var i = 0; i < rsn_size; i++) {
					rHTML.push('<option value="' + m_rsnTemplReply.REASONCD[i].CD_VALUE + '">' + m_rsnTemplReply.REASONCD[i].DISPLAY + '</option>');
				}
				rHTML.push('</select><p id="reasonErr" class="hidden">' + xrPrintModalI18n.SELECTREASON + '</p>');
				rsnHTML = rHTML.join("");
				//innerhtml XR reasons
				$('#xrReasonsDD').html(rsnHTML);
			}

			//XR Template logic
			var templ_size = m_rsnTemplReply.TEMPL_QUAL.length;

			var tHTML = [];
			var selHTML = "";

			//Loop through XR templates and store in tHTML array
			if (templ_size) {
				tHTML.push('<select id="xrTemplates" class="xr-dropdown xr-default-opt" name="xrTemplates"><option id="xrPlaceHolder" value="0"></option>');
				for (var i = 0; i < templ_size; i++) {
					tHTML.push('<option value="' + m_rsnTemplReply.TEMPL_QUAL[i].TID + '">' + m_rsnTemplReply.TEMPL_QUAL[i].NAME + '</option>');
				}
				tHTML.push('</select><p id="templErr" class="hidden">',xrPrintModalI18n.SELECTTEMPLATE,'</p>');
				selHTML = tHTML.join("");
				//innerhtml templates
				$('#templateDD').html(selHTML);

				// Create anchor for expand/collapse of sections
				$('#expandPH').append($("<a/>").attr("id", "dispSections").addClass("exp-sections xr-disabled").html("Expand/Collapse"));

				//add click event to expand/collapse XR template sections
				$("#dispSections").click(function() {
					MD_xrPrintDialog.showHideSections(this);
				});

			}
			else {
				tHTML.push('<p id="templErr" class="error-msg">',xrPrintModalI18n.NOTEMPLSADMIN,'</p>');
				selHTML = tHTML.join("");
				$('#templateDD').html(selHTML);
				$('#templateSections').addClass("hidden");
			}

			//Click event for the selection/deselections of all sections
			$('#xrTemplateSelected').click(function() {
				MD_xrPrintDialog.toggleAll(this);
			});

			//Click events for displaying calendars
			var init = false;
			
			var datepicker_opts = {
				showOn: "both",
				buttonImage: "../../resources/UnifiedContent/images/4974.png",
				buttonImageOnly: true,
				maxDate: '0',
				changeMonth: true,
				changeYear: true,
				dayNamesMin: ["S", "M", "T", "W", "T", "F", "S"],
				yearRange: "c-110:+0"			
			};

			//Invoke From Date Calendar ticker
			$('#calOpenFrom').datepicker(datepicker_opts);

			//Invoke To Date Calendar ticker
			$('#calOpenTo').datepicker(datepicker_opts);

			$('img.ui-datepicker-trigger').addClass('my-button-style');

			//Click event for selecting "Entire Encounter" date range radio button
			$('#xrEncntr').click(function() {
				$('#dateErr').addClass('hidden').removeClass('req-error');
			});

			//Click event for selecting date range radio button
			$('#fromCal,#toCal,.ui-datepicker-trigger').click(function() {
				$('#xrDtRange').prop('checked', true);
				$('#xrEncntr').prop('checked', false);
			});	

			//Onchange event for Reasons Dropdown to validate selection
			$('#xrReasons').change(function() {
				MD_xrPrintDialog.validateReasonsDD();
			});

			//Focusin event for Reasons Dropdown to remove required highlight
			$('#xrReasons').focusin(function(e) {
				MD_xrPrintDialog.removeReason(e);
			});

			//Onblur event for Reasons Dropdown to add required highlight and option element if no option chosen
			$('#xrReasons').blur(function(e) {
				MD_xrPrintDialog.addReason(e);
			});

			//Onchange event for Templates Dropdown to validate selection and sections
			$('#xrTemplates').change(function() {
				MD_xrPrintDialog.validateTemplDD();
				MD_xrPrintDialog.populateSectionsOnChange(this);
			});

			//Focusin event for Templates Dropdown to remove required highlight
			$('#xrTemplates').focusin(function(e) {
				MD_xrPrintDialog.removeTemplate(e);
			});

			//Onblur event for Templates Dropdown to add required highlight and option element if no option chosen
			$('#xrTemplates').blur(function(e) {
				MD_xrPrintDialog.addTemplate(e);
			});

			//Click event for each section, to check or uncheck all sections
			$('#sectionsCont .xr-section').click(MD_xrPrintDialog.checkAllChildrenSelected);

			//Enable create report button
			$('#xrCreateReportBtn').prop("disabled", false);

		},

		/**
		 * This function will populate the xr print modal window based on  table.
		 * @param {object} modObj : Modal Object
		 * @class
		 * @scope public
		 */
		init: function(modObj) {
			var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
			var xrHTML = [];
			var xrprintBody = $('#' + modObj.getBodyElementId());

			//Default Create Report button to disabled
			$('#xrCreateReportBtn').prop("disabled", true);

			//Set up loading image
			$(xrprintBody).addClass('xr-report-loading');
			
			//Build HTML shell
			xrHTML.push('<div id="xrPrintContent" class="print-dialog-content xr-content-hidden">', '<!--<h2 class="print-header">',xrPrintModalI18n.CREATEREPORT,'</h2>-->', '<div id="wrapper">', '<div id="reasons" class="xr-control-container">', '<label for="xrReasons">', '<span class="xr-required">*</span>', '<span class="templ-secs-header">',xrPrintModalI18n.REASONFORPRINTING,'</span>', '</label>', '<br/>', '<div class="xr-content-div" id="xrReasonsDD"></div>', '</div>', '<div id="templates" class="xr-control-container">', '<label for="xrTemplates">', '<span class="xr-required">*</span>', '<span class="templ-secs-header">',xrPrintModalI18n.REPORTTEMPLATE,'</span>', '</label>', '<br/>', '<div class="xr-content-div">', '<div id="templateDD"></div>', '<div id="templateSections">', '<span id="expandPH"></span>', '<label id="allSecsLabel">', '<input id="xrTemplateSelected" name"selectAll" type="checkbox" disabled="true"/><span class="checkbox-text">', xrPrintModalI18n.INCLUDEALLSECT, '</span>', '<p id="sectionsErr" class="hidden">', xrPrintModalI18n.SELECTONE, '</p>', '</label>', '<div id="sectionsCont" style="display:none">', '<div id="secWrapper"></div>', '</div>', '</div>', '</div>', '</div>', '<div id="encounter" class="xr-control-container">', '<label for="xrEncounter">', '<span class="xr-required">*</span>', '<span class="templ-secs-header">', xrPrintModalI18n.ENCSELECT, '</span>', '</label>', '<br/>', '<div class="xr-content-div">', '<div class="xr-radio-sel">', '<label>', '<input type="radio" name="scopeSelEnc" id="xrSelEncntr" checked="checked"/><span>', xrPrintModalI18n.SELECTENC, '</span>', '</label>', '</div>', '<div class="xr-radio-sel">', '<label>', '<input type="radio" name="scopeSelEnc" id="xrAllEncntr"/><span>', xrPrintModalI18n.ALLENC, '</span>', '</label>', '</div>', '</div>', '</div>', '<div id="xrDateRanges" class="xr-control-container">', '<label for="xrDateRanges">', '<span class="xr-required">*</span>', '<span class="templ-secs-header">', xrPrintModalI18n.DATERANGE, '</span>', '</label>', '<br/>', '<div class="xr-content-div">', '<div class="xr-radio-sel">', '<label>', '<input type="radio" name="scopeSel" id="xrEncntr" checked="checked"/><span>', xrPrintModalI18n.ALLDATES, '</span>', '</label>', '</div>', '<div id="xrDtRangeDiv" class="xr-radio-sel">', '<input type="radio" name="scopeSel" id="xrDtRange"/>', '<form action="#" method="post" id="dateForm">', '<div id="dateFrom" class="xr-dt-from">', '<span id="dateLabel" class="xr-date-label">', xrPrintModalI18n.FROM, '</span>', '<div id="fromCal" class="calendar-trig">', '<input type="text" id="calOpenFrom" class="cal-trig">', '</div>', '</div>', '<div id="dateTo" class="xr-dt-to">', '<span id="dateLabel" class="xr-date-label">', xrPrintModalI18n.TO, '</span>', '<div id="toCal" class="calendar-trig">', '<input type="text" id="calOpenTo" class="cal-trig">', '</div>', '</div>', '</form>', '<p id="dateErr" class="hidden"></p>', '</div>', '</div>', '</div>', '</div>', '</div>');
			//innerhtml base HTML for XR Print modal
			$(xrprintBody).html(xrHTML.join(""));

			//Check to see if the template info has already been loaded successfully, if so, no need to retrieve again
			if (MD_xrPrintDialog.m_rsnTemplReplyObj && MD_xrPrintDialog.m_rsnTemplReplyObj.getStatus() === "S") {
				MD_xrPrintDialog.buildHTML();
			}
			else {
				//Execute asynchronous call to get XR reasons and templates
				var sendRsnTemplAr = ["^MINE^"];
				var rsnTemplRequest = null;

				//Get reasons and templates/sections via asynchronous call
				rsnTemplRequest = new MP_Core.ScriptRequest(null, "ENG:MPG.REACH_REASON_TEMPLATE_SECT.O1 - retrieve XR reasons, templates and sections data");
				rsnTemplRequest.setProgramName("MP_GET_XR_PRINT_CONFIG");
				rsnTemplRequest.setName("GetXrRsnTempSectData");
				rsnTemplRequest.setParameters(sendRsnTemplAr);
				rsnTemplRequest.setAsync(true);

				MP_Core.XMLCCLRequestCallBack(null, rsnTemplRequest, function(reply) {
					try {
						// Capture reply object for future consumption
						MD_xrPrintDialog.m_rsnTemplReplyObj = reply;
						if (reply.getStatus() === "S") {
							MD_xrPrintDialog.buildHTML();
						}
						else if (reply.getStatus() === "F") {
							MD_xrPrintDialog.buildErrorHTML();
						}
						else if (reply.getStatus() === "Z") {
							MD_xrPrintDialog.buildErrorHTML();
						}
					}
					catch(err) {
						MD_xrPrintDialog.buildErrorHTML();
					}
				});
			}
		},

		validateTemplDD: function() {
			var templDD = $('#xrTemplates').get(0);
			if (templDD) {
				var templVal = templDD.options[templDD.selectedIndex].value;
				var eTemplErr = $('#templErr');
				if (templDD.selectedIndex <= 0) {
					$(templDD).addClass('xr-default-opt');
					templDD.blur();
				}
				if (templVal <= 0) {
					//Display error if it wasnt already displaying
					$(eTemplErr).removeClass('hidden').addClass('req-error');

					//Disable All Sections checkbox
					$('#xrTemplateSelected').prop("disabled", true).removeClass("collapsed expanded").addClass("xr-disabled");

					//Remove sections content
					$('#secWrapper').empty();

					return false;
				}
				else {
					$(eTemplErr).addClass("hidden").removeClass("req-error");

					return templVal;
				}
			}
			else {
				return false;
			}
		},

		populateSectionsOnChange: function(e) {
			var selectedVal = e.options[e.selectedIndex].value;
			var tHTML = [];
			var dispHTML = "";
			if (selectedVal > 0) {
				//loop through JSON object, and build sections based on template
				for (var i = 0; i < m_rsnTemplReply.TEMPL_QUAL.length; i++) {
					if (selectedVal == m_rsnTemplReply.TEMPL_QUAL[i].TID) {
						tHTML.push('<ul>');
						for (var x = 0; x < m_rsnTemplReply.TEMPL_QUAL[i].SECS_QUAL.length; x++) {
							tHTML.push('<li><label class="sec-input"><input type="checkbox" class="xr-section" name="xrSection" value="' + m_rsnTemplReply.TEMPL_QUAL[i].SECS_QUAL[x].SID + '"/><span class="checkbox-text">' + m_rsnTemplReply.TEMPL_QUAL[i].SECS_QUAL[x].NAME + '</span></label></li>');
						}
						tHTML.push('</ul>');
						dispHTML = tHTML.join("");

						$('#secWrapper').html(dispHTML);
					}
				}

				//Make sure check box is not checked
				$('#xrTemplateSelected').prop('checked', false);

				//Add click event to expand/collapse
				$('#dispSections').click(function() {
					$('#dispSections').listener;
				});

				//Enable check box
				$('#xrTemplateSelected').prop({
					'disabled': false,
					'selected': false
				});

				//If the expander was disabled, remove disabled, and set to collapsed
				if ($('#dispSections').hasClass('xr-disabled')) {
					$('#dispSections').removeClass('xr-disabled').addClass('collapsed');
				}

				//Setup onclick for disabling sections
				$('#sectionsCont .xr-section').click(MD_xrPrintDialog.checkAllChildrenSelected);

				//Select all sections
				//Putting this in a timeout b/c it doesn't seem to trigger correctly the first time;
				var t = setTimeout('$("#xrTemplateSelected").get(0).click()', 10);

			}
		},
		//// CHECKED/UNCHECKED OF ALL
		checkAllChildrenSelected: function() {
			var allSelected = true;
			var templateInput = $('#xrTemplateSelected');
			var unselCnt = 0;

			$('#sectionsCont .xr-section').each(function() {
				if (!$(this).is(':checked')) {
					unselCnt = unselCnt + 1;
					templateInput.prop('checked', false);
					allSelected = false;
				}
			});

			if (allSelected === true) {
				templateInput.prop('checked', true);
			}

			//If all sections are unchecked, display error
			var eSectionsErr = $('#sectionsErr');

			if (unselCnt == $('#sectionsCont .xr-section').length) {
				eSectionsErr.removeClass('hidden').addClass('req-error');
			}
			else {
				eSectionsErr.addClass('hidden').removeClass('req-error');
			}
		},

		validateReasonsDD: function() {
			var reasonDD = $('#xrReasons').get(0);
			$('#xrReasons').attr('data-cur-val', '0');
			var reasonVal = reasonDD.options[reasonDD.selectedIndex].value;
			var eReasonErr = $('#reasonErr');

			if (reasonDD.selectedIndex <= 0) {
				$(reasonDD).addClass('xr-default-opt');
				reasonDD.blur();
			}
			if (reasonVal <= 0) {
				if (eReasonErr.hasClass('hidden')) {
					eReasonErr.removeClass('hidden').addClass('req-error');
				}
				return false;
			}
			else {
				eReasonErr.addClass('hidden').removeClass('req-error');
				reasonDD.setAttribute("data-cur-val", reasonVal);
				return reasonVal;
			}
		},

		showHideSections: function(expE) {
			if (!($(expE).hasClass('xr-disabled'))) {

				$('#sectionsCont').removeClass('hidden');
				$("#sectionsCont").slideToggle("slow");

				if ($(expE).hasClass('collapsed')) {
					$(expE).removeClass('collapsed');
					$(expE).addClass('expanded');
				}
				else {
					$(expE).removeClass('expanded');
					$(expE).addClass('collapsed');
				}
			}
		},

		toggleAll: function(source) {
			$('#sectionsCont .xr-section').each(function() {
				this.checked = source.checked;
			});

			var eSectionsErr = $('#sectionsErr');

			if (source.checked == false) {
				//If all sections are unchecked, display error
				eSectionsErr.removeClass('hidden').addClass('req-error');
			}
			else {
				eSectionsErr.addClass('hidden').removeClass('req-error');
			}
		},

		handleInvalidDateRange: function(txt) {
			var dateErr = $('#dateErr');

			dateErr.html(txt).removeClass('hidden').addClass('req-error');
		},

		addReason: function(e) {
			var xrReasons = $('#xrReasons');
			xrReasons.attr('data-cur-val', '0');
			e = e || window.event;
			target = e.target || e.srcElement;

			if (!$(target).hasClass('xr-default-opt')) {
				//Add yellow background if no default/blank option is selected
				if (xrReasons.prop('selectedIndex') === 0) {
					xrReasons.addClass('xr-default-opt');
				}
				//Remove yellow background if option other than blank chosen
				else {
					xrReasons.removeClass('xr-default-opt');
				}
			}
		},

		removeReason: function() {
			$('#xrReasons').removeClass('xr-default-opt');
		},

		addTemplate: function(e) {
			e = e || window.event;
			target = e.target || e.srcElement;

			if (!$(target).hasClass('xr-default-opt')) {
				//Add yellow background if no default/blank option is selected
				if ($('#xrTemplates').prop('selectedIndex') === 0) {
					$('#xrTemplates').addClass('xr-default-opt');
				}
				//Remove yellow background if option other than blank chosen
				else {
					$('#xrTemplates').removeClass('xr-default-opt');
				}
			}
		},

		removeTemplate: function() {
			$('#xrTemplates').removeClass('xr-default-opt');
		},

		submitValidateInput: function() {
			var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
			var reasonVal, templVal = 0;
			var fromDtStr, toDtStr;
			var fdVal = "";
			var fmVal = "";
			var fyVal = "";
			var tdVal = "";
			var tmVal = "";
			var tyVal = "";

			//Validate all input fields to make sure values are selected
			var printOK = true;

			//Validate Reason
			reasonVal = MD_xrPrintDialog.validateReasonsDD();

			//Validate Template Selected
			templVal = MD_xrPrintDialog.validateTemplDD();

			//Validate what sections are selected
			var secsOK = false;
			var secsSelCnt = 0;
			var secsStr = "";

			$('#sectionsCont .xr-section').each(function() {
				if ($(this).is(':checked')) {
					secsOK = true;
					secsSelCnt += 1;
					if (secsSelCnt > 1) {
						secsStr = secsStr + "," + $(this).attr('value');
					}
					else {
						secsStr = $(this).attr("value");
					}
				}
			});

			//Validate Encounter Selection
			var encntrSel = true;

			if ($('#xrAllEncntr').is(':checked')) {
				encntrSel = false;
			}

			//Date range OK
			var dateRangeOK = true;
			$('#dateErr').removeClass('req-error').addClass('hidden');
			
			//check each date to make sure it is filled out and valid			
			function getMonth(date) {
				var month = date.getMonth();
				return (month > 8) ? month + 1 : '0' + (month + 1);
			}			

			if ($('#xrDtRange').is(':checked')) {
				//get from date (month,date,year)
				var FromDate = $('#calOpenFrom').datepicker('getDate');
				if (FromDate) {
					fdVal = ("0" + (FromDate.getDate())).slice(-2);
					fmVal = getMonth(FromDate);
					fyVal = FromDate.getFullYear();
				}

				//get to date (month,date,year)
				var ToDate = $('#calOpenTo').datepicker('getDate');
				if (ToDate) {
					tdVal = ("0" + (ToDate.getDate())).slice(-2);
					tmVal = getMonth(ToDate);
					tyVal = ToDate.getFullYear();
				}

				if (fmVal && fdVal && fyVal && tmVal && tdVal && tyVal) {
					var fromDate = new Date(fyVal, fmVal - 1, fdVal);
					var toDate = new Date(tyVal, tmVal - 1, tdVal);

					if (fromDate <= toDate) {
						dateRangeOK = true;
						fromDtStr = fdVal + "/" + fmVal + "/" + fyVal + " 00:00:00";
						toDtStr = tdVal + "/" + tmVal + "/" + tyVal + " 23:59:59";
					}
					else {
						dateRangeOK = false;
						MD_xrPrintDialog.handleInvalidDateRange(xrPrintModalI18n.FROMBFRTO);
					}
				}
				else if (fmVal && fdVal && fyVal && tmVal == "" && tdVal == "" && tyVal == "") {
					dateRangeOK = false;
					MD_xrPrintDialog.handleInvalidDateRange(xrPrintModalI18n.SELCTTODATE);
				}
				else if (fmVal == "" && fdVal == "" && fyVal == "" && tmVal && tdVal && tyVal) {
					dateRangeOK = false;
					MD_xrPrintDialog.handleInvalidDateRange(xrPrintModalI18n.SELCTFROMDATE);
				}
				else {
					dateRangeOK = false;
					MD_xrPrintDialog.handleInvalidDateRange(xrPrintModalI18n.SELCTVLDRANGE);
				}
			}
			if ((reasonVal) && (templVal) && (dateRangeOK) && (secsOK)) {
				MD_xrPrintDialog.xrPrint(this.m_criterion.person_id, this.m_criterion.provider_id, (encntrSel) ? this.m_criterion.encntr_id : 0.0, reasonVal, templVal, ($('#sectionsCont .xr-section').length != secsSelCnt) ? secsStr : "", fromDtStr, toDtStr);
				//Disable Create Report button
				$('#xrCreateReportBtn').prop("disabled", true);	
				//Display loading icon	
				$('#modalXRPrintbody').addClass('xr-report-loading');	
			}
		},

		xrPrint: function(pid, prid, eid, rcd, tid, sids, bDt, eDt) {
		
			var respCheckPrgName = "MP_MOBILE_RESPONSE_CHECK";
			var sendCheckAr = ["^MINE^"];
			var checkRequest = null;

			checkRequest = new MP_Core.ScriptRequest(null, "ENG:MPG.REACH_RESP_CHECK.01 - check response");
			checkRequest.setProgramName(respCheckPrgName);
			checkRequest.setName("GetRespCheck");
			checkRequest.setParameters(sendCheckAr);
			checkRequest.setAsync(true);
			checkRequest.setExecCallback(true);

			if (CERN_BrowserDevInd) {
				MP_Core.XMLCCLRequestCallBack(null, checkRequest, function(reply) {
					if (reply.getResponse() == "<!--S-->") {
						xrPrintCallback();
						//Close XR Print modal
						MP_ModalDialog.closeModalDialog("modalXRPrint");
					}
					else {
						//session must no longer be valid, handle here
						var timedOutCallback = MD_xrPrintDialog.getTimeoutCallback();
						if (timedOutCallback && typeof timedOutCallback === "function") {
							timedOutCallback();
						}
					}
				});
			}
			else {
				xrPrintCallback();
			}

			function xrPrintCallback() {
				var xrPrintModalI18n = i18n.discernabu.xr_print_modal;
				var url1 = "../../mpages/xrreport";
				var url2 = "http://localhost:8080/discern/mpages/xrreport";
				var prstr = "?personId=" + pid + ".0&personnelId=" + prid + ".0&templateId=" + tid;

				if (eid) {
					prstr = prstr + "&scope=ENCOUNTER&encounterId=" + eid + ".0";
				}
				else {
					prstr = prstr + "&scope=PERSON";
				}

				prstr = prstr + "&purposeCd=" + rcd;

				if (sids) {
					prstr = prstr + "&sections=" + sids;
				}

				if (bDt && eDt) {
					prstr = prstr + "&beginDtTm=" + bDt + "&endDtTm=" + eDt;
				}

				// Check context to determine whether PowerChart or In-browser
				if ( typeof XMLCclRequest === "undefined") {
					window.open(url1 + prstr);
				}
				else {
					alert(xrPrintModalI18n.WIN32NOTAVAIL);
				}
			}

		}
	};
}();
var eventManagers = function() {
	var managersById = {};

	return {
		"addManager" : function(manager) {
			managersById[manager.getId()] = manager;
		},
		"findManager" : function(id) {
			return managersById[id];
		},
		"getManagers" : function() {
			return managersById;
		},
		"removeManager" : function(id) {
			delete managersById[id];
		}

	};
}();

function DocEventManager(id) {
	this.activityLog = [];
	this.cache = {};
	this.criterion = {};
	this.decorationByOCID = {};
	this.eventsByOCID = {};
	this.eventsByTarget = {};
	this.id = id;
	this.initialized = false;
	this.itemGroupsByOCID = {};
	this.loggingEnabled = false;
	this.queue = {};
	this.ruleResponses = {};
	this.statesByOCID = {};
	this.structureOrganizer = null;
	this.suggestions = {};
	this.termGroupsByOCID = {};
	this.termsByOCID = {};
	this.batchedFireRules = [];
	this.itemByResponseIdent = {};

	// TODO - bad; doing this to get around visual issues with multiple choice questions
	this.queueProcessing = false;

	eventManagers.addManager(this);
}

DocEventManager.prototype.getActivityLog = function() {
	return this.activityLog;
};

DocEventManager.prototype.getCache = function() {
	return this.cache;
};

DocEventManager.prototype.getCriterion = function() {
	return this.criterion;
};

DocEventManager.prototype.getDecorationByOCID = function() {
	return this.decorationByOCID;
};

DocEventManager.prototype.getEventsByOCID = function() {
	return this.eventsByOCID;
};

DocEventManager.prototype.getEventsByTarget = function() {
	return this.eventsByTarget;
};

DocEventManager.prototype.getId = function() {
	return this.id;
};

DocEventManager.prototype.getInitialized = function() {
	return this.initialized;
};

DocEventManager.prototype.getItemGroupsByOCID = function() {
	return this.itemGroupsByOCID;
};

DocEventManager.prototype.getLoggingEnabled = function() {
	return this.loggingEnabled;
};

DocEventManager.prototype.getQueue = function() {
	return this.queue;
};

DocEventManager.prototype.getQueueLength = function() {
	return this.queueLength;
};

DocEventManager.prototype.getQueueProcessing = function() {
	return this.queueProcessing;
};

DocEventManager.prototype.getRuleResponses = function() {
	return this.ruleResponses;
};

DocEventManager.prototype.getStatesByOCID = function() {
	return this.statesByOCID;
};

DocEventManager.prototype.getStructureOrganizer = function() {
	return this.structureOrganizer;
};

DocEventManager.prototype.getSuggestions = function() {
	return this.suggestions;
};

DocEventManager.prototype.getTermGroupsByOCID = function() {
	return this.termGroupsByOCID;
};

DocEventManager.prototype.getTermsByOCID = function() {
	return this.termsByOCID;
};

DocEventManager.prototype.getItemsByResponseIdent = function(responseIdent) {
	var itemOCIDs = [];
	if (this.itemByResponseIdent[responseIdent]) {
		itemOCIDs = this.itemByResponseIdent[responseIdent];
	}
	return itemOCIDs;
};

DocEventManager.prototype.setItemByResponseIdent = function(responseIdent, items) {
	this.itemByResponseIdent[responseIdent] = items;
};

DocEventManager.prototype.setActivityLog = function(val) {
	this.activityLog = val;
};

DocEventManager.prototype.setCache = function(val) {
	this.cache = val;
};

DocEventManager.prototype.setCriterion = function(val) {
	this.criterion = val;
};

DocEventManager.prototype.setDecorationByOCID = function(val) {
	this.decorationByOCID = val;
};

DocEventManager.prototype.setEventsByOCID = function(val) {
	this.eventsByOCID = val;
};

DocEventManager.prototype.setEventsByTarget = function(val) {
	this.eventsByTarget = val;
};

DocEventManager.prototype.setId = function(val) {
	this.id = val;
};

DocEventManager.prototype.setInitialized = function(val) {
	this.initialized = val;
};

DocEventManager.prototype.setItemGroupsByOCID = function(val) {
	this.itemGroupsByOCID = val;
};

DocEventManager.prototype.setLoggingEnabled = function(val) {
	this.loggingEnabled = val;
};

DocEventManager.prototype.setQueue = function(val) {
	this.queue = val;
};

DocEventManager.prototype.setQueueLength = function(val) {
	this.queueLength = val;
};

DocEventManager.prototype.setQueueProcessing = function(val) {
	this.queueProcessing = val;
};

DocEventManager.prototype.setRuleResponses = function(val) {
	this.ruleResponses = val;
};

DocEventManager.prototype.setStatesByOCID = function(val) {
	this.statesByOCID = val;
};

DocEventManager.prototype.setStructureOrganizer = function(val) {
	this.structureOrganizer = val;
};

DocEventManager.prototype.setSuggestions = function(val) {
	this.suggestions = val;
};

DocEventManager.prototype.setTermGroupsByOCID = function(val) {
	this.termGroupsByOCID = val;
};

DocEventManager.prototype.setTermsByOCID = function(val) {
	this.termsByOCID = val;
};

DocEventManager.prototype.addItemGroup = function(itemGroup) {
	this.getItemGroupsByOCID()[itemGroup.getOCID()] = itemGroup;
};

DocEventManager.prototype.addItemToLog = function(item) {
	var activityLog = this.getActivityLog();
	var itemIndex = this.findLogIndexByOCID(item.TERM_OCID);

	if (itemIndex > -1) {
		activityLog[itemIndex] = item;
	}
	else {
		activityLog.unshift(item);
	}
};

DocEventManager.prototype.addTerm = function(term) {
	this.getTermsByOCID()[term.getOCID()] = term;
};

DocEventManager.prototype.addTermGroup = function(termGroup) {
	this.getTermGroupsByOCID()[termGroup.getOCID()] = termGroup;
};

DocEventManager.prototype.addToCache = function(name, val) {
	this.getCache()[name] = val;
};

DocEventManager.prototype.createCommentElement = function(id, contents) {
	return $("<div id='" + this.getStructureOrganizer().getNamespace() + ":term:ROOT:" + id + "_comments' class='structure-term-item'><div class='structure-term-info-wrapper'><span class='structure-term-title'>" + contents + "</span></div></div>");
};

DocEventManager.prototype.executeActions = function(actions, actionedTerm) {
	// reset suggestions from different term items
	var itemOCID;
	var actionedTermGroup;
	var actionedItem;
	if (actionedTerm) {
		actionedItem = this.getItemForTerm(actionedTerm);
		if (actionedItem) {
			itemOCID = actionedItem.getOCID();
			CPEventManager.notifyObservers("FILTER_RECOMMENDATIONS_BY_ITEM", {
				"ITEM_OCID" : itemOCID,
				"CP_NODE_ID" : this.getNodeId()
			});
		}
	}

	if (actions.length > 0) {
		this.setQueueProcessing(true);
		this.processActions(actions);
		this.processQueue();
		this.setQueueProcessing(false);
		CPEventManager.notifyObservers("DOCUMENT_EVENTS_PROCESSED", this);
	}
};

DocEventManager.prototype.findCommentElement = function(id) {
	return $("#" + this.getStructureOrganizer().getNamespace() + "\\:term\\:ROOT\\:" + id + "_comments");
};

DocEventManager.prototype.findLogIndexByOCID = function(ocid) {
	var activityLog = this.getActivityLog();
	var x;

	for ( x = activityLog.length; x--; ) {
		if (activityLog[x].TERM_OCID === ocid) {
			return x;
		}
	}

	return -1;
};

DocEventManager.prototype.findItemGroup = function(OCID) {
	return this.getItemGroupsByOCID()[OCID];
};

DocEventManager.prototype.findTerm = function(OCID) {
	return this.getTermsByOCID()[OCID];
};

DocEventManager.prototype.findTermGroup = function(OCID) {
	return this.getTermGroupsByOCID()[OCID];
};

DocEventManager.prototype.findStructuredElement = function(type, structured) {
	return $("#" + this.getStructureOrganizer().getNamespace() + "\\:" + type + "\\:ROOT\\:" + structured.getId());
};

DocEventManager.prototype.fireRule = function(curEvents) {
	// TODO - possible to rename the "TARGET" part of the rule events to something more descriptive (ie RULE_NAME)?

	var ruleResponses = this.getRuleResponses();
	var termsByOCID = this.getTermsByOCID();
	var response, curAction, term, x, y, i, j;
	var curResponses = [];
	var replyArr = [];
	var scriptReq = "value(";
	var scriptReqArr = [];
	var a, al, b, bl;
	var curResponse, curEvent;

	for ( a = 0, al = curEvents.length; a < al; a++) {
		if (ruleResponses.hasOwnProperty(curEvents[a].TARGET)) {
			curResponses.push(ruleResponses[curEvents[a].TARGET]);
		}
		else {
			scriptReqArr.push('"' + curEvents[a].TARGET + '"');
		}
	}

	if (scriptReqArr.length > 0) {
		var scriptRequest = new ScriptRequest();
		var criterion = this.getCriterion();
		scriptReq += scriptReqArr.join(",") + ")";

		scriptRequest.setProgramName("inn_mp_execute_synch_event");
		scriptRequest.setAsyncIndicator(false);
		scriptRequest.setParameterArray(["^MINE^", scriptReq, criterion.person_id, criterion.encntr_id]);

		scriptRequest.setResponseHandler(function(scriptResponse) {
			if (scriptResponse.m_status != "F") {
				curReply = scriptResponse.m_responseData.ALERT_DATA;
				replyArr = curReply.RESPONSES;
				if (curReply.RESPONSECNT > 0) {
					for ( a = 0, al = curReply.RESPONSECNT; a < al; a++) {
						ruleResponses[replyArr[a].TARGET] = replyArr[a];
					}
					if (scriptResponse.m_status == "S") {
						curResponses = curResponses.concat(replyArr);
					}
				}
			}
		});

		scriptRequest.performRequest();
	}

	for ( a = 0, al = curResponses.length; a < al; a++) {
		curResponse = curResponses[a];
		for ( b = 0, bl = curEvents.length; b < bl; b++) {
			curEvent = curEvents[b];
			if (curResponse.TARGET == curEvent.TARGET && curEvent.hasOwnProperty("ACTIONS")) {
				for ( x = 0, y = curEvent.ACTIONS.length; x < y; x++) {
					curAction = curEvent.ACTIONS[x];

					if (curAction.hasOwnProperty("RESULT") && curAction.RESULT.length > 0 && curAction.RESULT === curResponse.TEXT) {
						for ( i = 0, j = curAction.TARGETS.length; i < j; i++) {
							this.handleAction({
								"TYPE" : curAction.TYPE,
								"TARGET" : curAction.TARGETS[i],
								"PRIORITY" : 9999
							});
						}
					}
				}
			}
		}
	}
};

DocEventManager.prototype.getActionsFromEvents = function(events) {
	var actions = [];
	var curEvent, response, curAction, x, y, i, j;
	var that = this;

	if (events) {
		for ( x = 0, y = events.length; x < y; x++) {
			curEvent = events[x];
			response = null;

			if (curEvent.TAGS.indexOf("ONLOAD") !== -1) {
				if (curEvent.hasOwnProperty("ACTIONS")) {
					for ( i = 0, j = curEvent.ACTIONS.length; i < j; i++) {
						curAction = curEvent.ACTIONS[i];

						actions.push({
							"TYPE" : curAction.TYPE,
							"TARGETS" : curAction.TARGETS
						});
					}
				}
			}
			else {
				if (curEvent.hasOwnProperty("EXPRESSION")) {
					try {
						response = String(eval(this.translateExpression(curEvent))).toUpperCase();
						curEvent.RESPONSE = response;
					}
					catch(ignore) {
						curEvent.RESPONSE = null;
					}
				}

				if (response != undefined) {
					if (curEvent.hasOwnProperty("ACTIONS")) {
						for ( i = 0, j = curEvent.ACTIONS.length; i < j; i++) {
							curAction = curEvent.ACTIONS[i];

							if (curAction.hasOwnProperty("RESULT") && curAction.RESULT === response) {
								var ItemOCIDS = that.getItemOCIDsForTerms(curEvent.TAGS);
								actions.push({
									"TYPE" : curAction.TYPE,
									"TARGETS" : curAction.TARGETS,
									"ITEMS" : ItemOCIDS
								});
							}
						}
					}
				}
			}
		}
	}

	return actions;
};

DocEventManager.prototype.getItemOCIDsForTerms = function(tags) {
	var ItemOCIDS = [];
	var currentTerm;
	var currentItem;
	for (var x = 0, y = tags.length; x < y; x++) {
		currentTerm = this.findTerm(tags[x]);
		currentItem = this.getItemForTerm(currentTerm);
		if (currentItem) {
			if (ItemOCIDS.indexOf(currentItem.getOCID()) === -1) {
				ItemOCIDS.push(currentItem.getOCID())
			}
		}
	}
	return (ItemOCIDS);
};

DocEventManager.prototype.getItemForTerm = function(term) {
	var termGroup;
	var item;
	if (term) {
		termGroup = term.getParent();
		if (termGroup) {
			item = termGroup.getParent();
			return (item)
		}
	}
	return (null);
};

DocEventManager.prototype.getElementContents = function(contentSource) {
	var sourceType = contentSource.COMMENT_SOURCE;

	switch(sourceType) {
		case "RULE" :
			var ruleResponses = this.getRuleResponses();

			try {
				return ruleResponses[contentSource.COMMENT_SOURCE_NAME].TITLE || "";
			}
			catch(e) {
				return i18n.innovations.pathways_shared.ERROR_RETRIEVING_COMMENTS;
			}

			break;
		default:
			return this.handleOtherContentSource(contentSource);
			break;
	}
};

DocEventManager.prototype.getFromCache = function(name) {
	return this.getCache()[name];
};

DocEventManager.prototype.getStateByOCID = function(ocid) {
	return this.statesByOCID[ocid];
};

DocEventManager.prototype.insertBatchedFireRule = function(rule) {
	this.batchedFireRules.push(rule);
};

DocEventManager.prototype.initBatchedFireRules = function() {
	if (this.batchedFireRules.length > 0) {
		this.fireRule(this.batchedFireRules);
		this.batchedFireRules.length = 0;
	}
};

DocEventManager.prototype.handleFireRuleAction = function(action) {
	this.insertBatchedFireRule(action.TARGET);
};

// NOTE - action.TYPE values of "HIDE_TERMS" and "SHOW_TERMS" are deprecated; use "HIDE_TERM_GROUPS" and "SHOW_TERM_GROUPS" instead.
DocEventManager.prototype.handleAction = function(action) {
    try {
        logger.logMessage("DEM Action - " + JSON.stringify(action));    
    } catch(ignore) {
        
    }
    
	switch(action.TYPE) {
		case "BROADCAST_EVENT" :
			this.handleBroadcastAction(action);
			break;
		case "COLLAPSE_ITEM_GROUPS" :
			this.handleCollapseItemGroupAction(action);
			break;
		case "DEFAULT_TERM_NO" :
			this.handleDefaultNoAction(action);
			break;
		case "DEFAULT_TERM_YES" :
			this.handleDefaultYesAction(action);
			break;
		case "EXPAND_ITEM_GROUPS" :
			this.handleExpandItemGroupAction(action);
			break;
		case "FIRE_RULES" :
			this.handleFireRuleAction(action);
			break;
		case "HIDE_TERM_COMMENTS" :
			this.handleHideCommentsAction(action);
			break;
		case "HIDE_TERM_GROUPS" :
			this.handleHideTermGroupsAction(action);
			break;
		case "HIDE_TERMS" :
			this.handleHideTermsAction(action);
			break;
		case "SHOW_TERM_COMMENTS" :
			this.handleShowCommentsAction(action);
			break;
		case "SHOW_TERM_GROUPS" :
			this.handleShowTermGroupsAction(action);
			break;
		case "SHOW_TERMS" :
			this.handleShowTermsAction(action);
			break;
		case "SUGGEST":
			this.handleSuggestAction(action);
			break;
		case "UNSUGGEST" :
			this.handleUnsuggestAction(action);
			break;
	}
};

DocEventManager.prototype.handleBroadcastAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var eventTerms = [];
	var x, y;

	for ( x = 0, y = target.TERMS.length; x < y; x++) {
		eventTerms.push(that.findTerm(target.TERMS[x]));
	}

	that.pushToQueue({
		"ACTION" : function() {
			CPEventManager.notifyObservers(target.EVENT, {
				"MANAGER" : that,
				"TERMS" : eventTerms
			});
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleCollapseItemGroupAction = function(action) {
	var that = this;
	var target = action.TARGET;

	that.pushToQueue({
		"ACTION" : function() {
			var itemGroupElement = that.findStructuredElement("section", that.findItemGroup(target));
			var groupHeader = itemGroupElement.children(".pw-section-header");
			var iconContainer = groupHeader.children(".pw-icon-container");

			if (!iconContainer.hasClass("pw-collapsed-icon")) {
				groupHeader.click();
			}
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleDefaultNoAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var term = that.findTerm(target);

	that.pushToQueue({
		"ACTION" : function() {
			term.jumpToState("2");
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleDefaultYesAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var term = that.findTerm(target);

	that.pushToQueue({
		"ACTION" : function() {
			term.jumpToState("1");
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleExpandItemGroupAction = function(action) {
	var that = this;
	var target = action.TARGET;

	that.pushToQueue({
		"ACTION" : function() {
			var itemGroupElement = that.findStructuredElement("section", that.findItemGroup(target));
			var groupHeader = itemGroupElement.children(".pw-section-header");
			var iconContainer = groupHeader.children(".pw-icon-container");

			if (!iconContainer.hasClass("pw-expanded-icon")) {
				groupHeader.click();
			}
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleHideCommentsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var termElement = that.findTerm(target);
	var commentElement = that.findCommentElement(termElement.getId());

	that.pushToQueue({
		"ACTION" : function() {
			that.toggleElementVisibility(commentElement, false);
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : target,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleHideTermGroupsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var group = that.findTermGroup(target);
	var state = that.getStateByOCID(target);

	if (state !== false) {
		that.setStateByOCID(target, false);

		that.pushToQueue({
			"ACTION" : function() {
				var children = group.getChildren();
				var x;

				for ( x = children.length; x--; ) {
					that.findStructuredElement("term", children[x]).show();
					children[x].deactivate();
				}

				that.toggleElementVisibility(that.findStructuredElement("group", group), false);
			},
			"PRIORITY" : action.PRIORITY,
			"TARGET" : target,
			"TYPE" : action.TYPE
		});

        /* TODO - term decoration is term-specific. Do we loop through all the children of a group and look for decoration that way? */
        if (that.getInitialized()) {
            var children = group.getChildren();
            var decoration, x, y, i, j;

            for ( x = 0, y = children.length; x < y; x++) {
                decoration = that.getDecorationByOCID()[children[x].getOCID()];

                if (decoration) {
                    for ( i = 0, j = decoration.length; i < j; i++) {
                        switch(decoration[i].NAME) {
                            case "EXPRESSION" :
                                that.processActions(that.getActionsFromEvents([decoration[i].VALUE]));
                                break;
                        }
                    }
                }
            }
        }
	}
};

DocEventManager.prototype.handleHideTermsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var term = that.findTerm(target);
	var termGroup = term.getParent();

	if (termGroup) {
		action.TARGET = termGroup.getOCID();
		action.TYPE = "HIDE_TERM_GROUPS";

		that.handleHideTermGroupsAction(action);
	}
};

DocEventManager.prototype.handleOtherContentSource = function(contentSource) {
	return "";
};

DocEventManager.prototype.handleShowCommentsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var termObject = that.findTerm(target.OCID);
	var termId = termObject.getId();
	var termElement = that.findStructuredElement("term", termObject);
	var commentElement = that.findCommentElement(termId);

	if (commentElement.length === 0) {
		commentElement = that.createCommentElement(termId, that.getElementContents(target));
	}

	that.pushToQueue({
		"ACTION" : function() {
			that.moveElement(commentElement, termElement);
		},
		"PRIORITY" : action.PRIORITY,
		"TARGET" : action.TARGET,
		"TYPE" : action.TYPE
	});
};

DocEventManager.prototype.handleShowTermGroupsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var group = that.findTermGroup(target);
	var state = that.getStateByOCID(target);

	if (state !== true) {
		that.setStateByOCID(target, true);

		that.pushToQueue({
			"ACTION" : function() {
				that.toggleElementVisibility(that.findStructuredElement("group", group), true);
			},
			"PRIORITY" : action.PRIORITY,
			"TARGET" : target,
			"TYPE" : action.TYPE
		});

		/* TODO - term decoration is term-specific. Do we loop through all the children of a group and look for decoration that way? */

		if (that.getInitialized()) {
			var children = group.getChildren();
			var decoration, x, y, i, j;

			for ( x = 0, y = children.length; x < y; x++) {
				decoration = that.getDecorationByOCID()[children[x].getOCID()];

				if (decoration) {
					for ( i = 0, j = decoration.length; i < j; i++) {
						switch(decoration[i].NAME) {
							case "EXPRESSION" :
								that.processActions(that.getActionsFromEvents([decoration[i].VALUE]));
								break;
							case "RULE" :
								this.insertBatchedFireRule(decoration[i].VALUE);
								break;
						}
					}
				}
			}
		}
	}
};

DocEventManager.prototype.handleShowTermsAction = function(action) {
	var that = this;
	var target = action.TARGET;
	var term = that.findTerm(target);
	var termGroup = term.getParent();

	if (termGroup) {
		action.TARGET = termGroup.getOCID();
		action.TYPE = "SHOW_TERM_GROUPS";

		that.handleShowTermGroupsAction(action);
	}
};

DocEventManager.prototype.handleSuggestAction = function(action) {
	var target = action.TARGET;
	var state = this.getStateByOCID(target);
	var items = action.ITEMS;

	if (state !== true) {
		this.setStateByOCID(target, false);
		that.setItemByResponseIdent(target, items);

		this.pushToQueue({
			"ACTION" : function() {
				CPEventManager.notifyObservers("DOCUMENT_EVENT_MANAGER_SUGGEST", target);
			},
			"PRIORITY" : action.PRIORITY,
			"TARGET" : target,
			"TYPE" : action.TYPE,
			"RESPONSE_IDENT" : target
		});
	}
};

DocEventManager.prototype.handleUnsuggestAction = function(action) {
	var target = action.TARGET;
	var state = this.getStateByOCID(target);

	if (state !== false) {
		this.setStateByOCID(target, false);

		this.pushToQueue({
			"ACTION" : function() {
				CPEventManager.notifyObservers("DOCUMENT_EVENT_MANAGER_UNSUGGEST", target);
			},
			"PRIORITY" : action.PRIORITY,
			"TARGET" : target,
			"TYPE" : action.TYPE
		});
	}
};

DocEventManager.prototype.init = function() {
	var that = this;
	var termsByOCID = that.getTermsByOCID();
	var eventsByOCID = that.getEventsByOCID();
	var x, y;

	(function() {
		var termGroups = that.getTermGroupsByOCID();
		var group;

		for (x in termGroups) {
			group = termGroups[x];

			group.getIsDone = function() {
				return this.m_isDone;
			};

			group.setIsDone = function(val) {
				this.m_isDone = val;
			};

			if ( group instanceof SingleStructureTermGroup) {
				group.handleTermActivity = function(term) {
					if (term !== this.m_activeTerm && this.m_activeTerm) {
						if (this.m_activeTerm instanceof InputStructureTerm) {
							this.m_activeTerm.setCurrentValue("");
						}
						this.m_activeTerm.deactivate();
					}
					this.m_activeTerm = term;

					if (this.getActiveTerm().getState().getValue()) {
						this.setIsDone(true);
						CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
					}
					else {
						if (this.getIsDone()) {
							this.setIsDone(false);
							CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY_UNDO", term);
							CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
						}
					}
				};
			}
			else if ( group instanceof YesNoStructureTermGroup) {
				group.handleTermActivity = function(term) {
					if (this.getNumberOfDocumentedChildren() === this.getChildren().length) {
						this.setIsDone(true);
						CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
					}
					else {
						if (this.getIsDone()) {
							this.setIsDone(false);
							CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY_UNDO", term);
							CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
						}
					}
				};
			}
			else if ( group instanceof MultiStructureTermGroup) {
			    // TODO - haven't had a use case for this, yet...
				group.handleTermActivity = function(term) {
				    if(term.getCurrentState()) {
				        this.setIsDone(true);
                        CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
				    } else {
				        this.setIsDone(false);
                        CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY_UNDO", term);
                        CPEventManager.notifyObservers("MPAGE_STRUCTURED_TERM_ACTIVITY", term);
				    }
				};
			}
		}
	})();

	(function() {
		var organizerElement = that.findStructuredElement("organizer", that.getStructureOrganizer());
		var sectionContainer = $("<div class='pw-section-container'></div>");
		var itemGroups = that.getItemGroupsByOCID();
		var groupNames = [];
		var multipleGroupsInd, itemGroup, section, termGroups, groupElement, groupHeaderElement, x, y, i, j;

		for (x in itemGroups) {
			if (itemGroups.hasOwnProperty(x)) {
				groupNames.push(x);
			}
		}

		multipleGroupsInd = groupNames.length > 1;

		organizerElement.css({
			"border" : "none",
			"margin-top" : "0px"
		});

		if (multipleGroupsInd) {
			sectionContainer.addClass("groups");
		}
		else {
			sectionContainer.addClass("no-groups");
		}

		for ( x = 0, y = groupNames.length; x < y; x++) {
			itemGroup = itemGroups[groupNames[x]];
			termGroups = itemGroup.getChildren();

			if (multipleGroupsInd) {
				section = $("<div class='pw-section'><div class='pw-section-header pw-hover-cursor-pointer'><span class='pw-icon-container pw-expanded-icon'></span><span class='pw-section-header-text'></span></div><div class='pw-section-details'></div><div class='pw-section-hidden'></div>");
				section.find(".pw-section-header-text").html(itemGroup.getTitle());
				section.children(".pw-section-header").click(function() {
					var that = $(this);
					var iconContainer = that.children(".pw-icon-container");
					var sectionDetails = that.siblings(".pw-section-details");

					iconContainer.toggleClass("pw-expanded-icon pw-collapsed-icon");

					if (iconContainer.hasClass("pw-expanded-icon")) {
						sectionDetails.show();
					}
					else {
						sectionDetails.hide();
					}
				});
			}
			else {
				section = $("<div class='pw-section'><div class='pw-section-details'></div><div class='pw-section-hidden'></div>");
			}

			for ( i = 0, j = termGroups.length; i < j; i++) {
				groupElement = that.findStructuredElement("group", termGroups[i]);
				groupHeaderElement = groupElement.children(".structure-group-header");

				if (termGroups[i].getChildren().length > 1) {
					groupElement.addClass("multiple-terms");
					$("<div class='structure-term-item structure-term-question'><div class='structure-term-info-wrapper'><span class='structure-term-title'>" + termGroups[i].getTitle() + "</span></div></div>").insertBefore(groupHeaderElement);
				}

				groupHeaderElement.remove();
				section.children(".pw-section-details").append(groupElement);
			}

			section.attr("id", that.getStructureOrganizer().getNamespace() + ":section:ROOT:" + itemGroup.getId());

			if (x > 0) {
				section.css("margin-top", "-1px");
			}

			sectionContainer.append(section);
		}

		organizerElement.empty().append(sectionContainer);

		// Can't modify the structure of elements created through mpage-structured, and the CSS goes back for miles, so...here's a terrible
		// alternative approach. TODO - suck less and find a real solution.

		organizerElement.find(".structure-term-item").each(function(cnt, obj) {
			var height = obj.offsetHeight + 1 + "px";
			var children = obj.querySelectorAll(".structure-yes-no-icon, .structure-documented-icon-area");
			var x;

			for ( x = children.length; x--; ) {
				children[x].style.height = height;
				children[x].style.lineHeight = height;
			}

			obj.style.height = height;
		});
	})();

	that.setStatesByOCID({});

	for (x in termsByOCID) {
		var currentTerm = termsByOCID[x];
		that.executeActions(that.getActionsFromEvents(eventsByOCID[currentTerm.getOCID()]), currentTerm);
	}

	if (eventsByOCID.hasOwnProperty("ONLOAD")) {
		that.executeActions(that.getActionsFromEvents(eventsByOCID["ONLOAD"]));
	}
};

DocEventManager.prototype.moveElement = function(target, anchor, appendInd) {
	if (anchor.length > 0) {
		if (appendInd) {
			target.detach().appendTo(anchor);
		}
		else {
			target.detach().insertAfter(anchor);
		}
	}
};

DocEventManager.prototype.processActions = function(actions) {
	var x, y, i, j;
	for ( x = 0, y = actions.length; x < y; x++) {
		for ( i = 0, j = actions[x].TARGETS.length; i < j; i++) {
			this.handleAction({
				"TYPE" : actions[x].TYPE,
				"TARGET" : actions[x].TARGETS[i],
				"PRIORITY" : actions[x].PRIORITY,
				"ITEMS" : actions[x].ITEMS || []
			});
		}
	}
	this.initBatchedFireRules();
};

DocEventManager.prototype.processQueue = function(executions) {
	if (executions == undefined) {
		executions = 0;
	}

	if (executions >= 10) {
		return;
	}
	else {
		var queue = this.getQueue();
		var priorities = [];
		var action, x, y, i, j;

		for (x in queue) {
			if (x !== "addAll") {
				priorities.push(x);
			}
		}

		priorities.sort();

		for ( x = 0, y = priorities.length; x < y; x++) {
			for ( z = 0; z < queue[priorities[x]].length; z++) {
				action = queue[priorities[x]].splice(z, 1)[0];
				z--;
				action.ACTION();
				/*queue[priorities[x]][z].ACTION();
				 queue[priorities[x]].splice(z, 1);
				 z--;*/
			}
		}

		this.setQueue(queue);

		for (x in queue) {
			if (x !== "addAll" && queue[x].length > 0) {
				this.processQueue(executions++);
				break;
			}
		}
	}
};

DocEventManager.prototype.pushToQueue = function(item) {
	var queue = this.getQueue();
	var priority = item.PRIORITY || "0";

	if (!queue.hasOwnProperty(priority)) {
		queue[priority] = [];
	}

	queue[priority].push(item);
};

DocEventManager.prototype.removeFromCache = function(name) {
	delete this.getCache()[name];
};

DocEventManager.prototype.removeItemFromLog = function(ocid) {
	var itemIndex = this.findLogIndexByOCID(ocid);

	if (itemIndex > -1) {
		var activityLog = this.getActivityLog();

		activityLog.splice(itemIndex, 1);
	}
};

DocEventManager.prototype.setDecoration = function(decoration) {
	var decorationByOCID = this.getDecorationByOCID();
	var x, y, i, j;

	for ( x = 0, y = decoration.length; x < y; x++) {
		if (!(decorationByOCID.hasOwnProperty(decoration[x].OCID))) {
			decorationByOCID[decoration[x].OCID] = [];
		}

		for ( i = 0, j = decoration[x].ATTRS.length; i < j; i++) {
			decorationByOCID[decoration[x].OCID].push(decoration[x].ATTRS[i]);
		}
	}
};

DocEventManager.prototype.setDocEvents = function(events) {
	var eventsByOCID = {};
	var eventsByTarget = {};
	var targets = [];
	var breakInd, x, y, z, i;

	for ( x = events.length; x--; ) {
		for ( y = events[x].TAGS.length; y--; ) {
			if (!eventsByOCID.hasOwnProperty(events[x].TAGS[y])) {
				eventsByOCID[events[x].TAGS[y]] = [];
			}

			eventsByOCID[events[x].TAGS[y]].push(events[x]);
		}

		for ( y = events[x].ACTIONS.length; y--; ) {
			if (events[x].ACTIONS[y]) {
				for ( z = events[x].ACTIONS[y].TARGETS.length; z--; ) {
					if (targets.indexOf(events[x].ACTIONS[y].TARGETS[z] === -1)) {
						targets.push(events[x].ACTIONS[y].TARGETS[z]);
					}
				}
			}
		}
	}

	for ( x = targets.length; x--; ) {
		breakInd = false;
		eventsByTarget[targets[x]] = [];
		for ( y = events.length; y--; ) {
			for ( z = events[y].ACTIONS.length; z--; ) {
				if (events[y].ACTIONS[z]) {
					for ( i = events[y].ACTIONS[z].TARGETS.length; i--; ) {
						if (events[y].ACTIONS[z].TARGETS[i] === targets[x]) {
							eventsByTarget[targets[x]].push(events[y]);
							breakInd = true;
						}

						if (breakInd) {
							break;
						}
					}

					if (breakInd) {
						break;
					}
				}
			}
		}
	}

	this.setEventsByOCID(eventsByOCID);
	this.setEventsByTarget(eventsByTarget);
};

DocEventManager.prototype.setItemGroups = function(groups) {
	var x, y;

	for ( x = 0, y = groups.length; x < y; x++) {
		this.addItemGroup(groups[x]);
	}
};

DocEventManager.prototype.setStateByOCID = function(ocid, value) {
	this.statesByOCID[ocid] = value;
};

DocEventManager.prototype.setTermGroups = function(groups) {
	var x, y;

	for ( x = 0, y = groups.length; x < y; x++) {
		this.addTermGroup(groups[x]);
	}
};

DocEventManager.prototype.setTerms = function(terms) {
	var x, y;

	for ( x = 0, y = terms.length; x < y; x++) {
		this.addTerm(terms[x]);
	}
};

DocEventManager.prototype.toggleElementVisibility = function(element, visible) {
	var target;

	if (visible) {
		target = element.parent().siblings(".pw-section-details");
	}
	else {
		target = element.parent().siblings(".pw-section-hidden");
	}

	this.moveElement(element, target, true);
};

DocEventManager.prototype.translateExpression = function(curEvent) {
	var expression = curEvent.EXPRESSION;
	var tags = curEvent.TAGS;
	var regex, x, y;

	var regexValues = {
		"TERM_VALUES" : {
			"STATE" : ".getCurrentState()"
		},
		"OPERATORS" : {
			"AND" : "&&",
			"OR" : "||",
			"NOT" : "!",
			"EQUALS" : "==",
			"GTE" : ">=",
			"GT" : ">",
			"LTE" : "<=",
			"LT" : "<"
		},
		"CONSTANTS" : {
			"NULL" : "0",
			"YES" : "1",
			"NO" : "2"
		}
	};

	for ( x = tags.length; x--; ) {
		regex = new RegExp("TERM\\{" + x + "\\}", "g");
		expression = expression.replace(regex, "this.findTerm('" + tags[x] + "')");
	}

	for (x in regexValues) {
		for (y in regexValues[x]) {
			regex = new RegExp(y, "g");
			expression = expression.replace(regex, regexValues[x][y]);
		}
	}

	if (expression.indexOf("CACHE") !== -1) {
		var modifyCacheString = function(target) {
			return "this.getFromCache(\"" + target.replace("CACHE{", "").replace("}", "") + "\")";
		};

		var replaceCacheString = function(target) {
			var regex = /CACHE{\w*}/;
			var match, matchIdx, matchStr, remainder;

			match = regex.exec(target);

			if (match) {
				matchIdx = match.index;
				matchStr = modifyCacheString(match[0]);
				target = target.replace(regex, matchStr);
				remainder = target.substring(matchIdx + matchStr.length, target.length);
				target = target.replace(remainder, replaceCacheString(remainder));
			}

			return target;
		};

		expression = replaceCacheString(expression);
	}

	return expression.split(" ").join("");
};

(function() {
	var managers = eventManagers.getManagers();
	var manager, eventsByOCID, x;

	CPEventManager.addObserver("MPAGE_STRUCTURED_TERM_ACTIVITY", function(term) {
		var ocid = term.getOCID();

		for (x in managers ) {
			manager = managers[x];
			eventsByOCID = manager.getEventsByOCID();

			if (manager.findTerm(ocid) != undefined) {
				var parent = term.getParent();
				var currentState = term.getCurrentState();
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

				if ( parent instanceof SingleStructureTermGroup && parent.getChildren().length > 1) {
					try {
						(function() {
							var children = parent.getChildren();
							var activeTerm = parent.getActiveTerm();

							if (activeTerm) {
								if (activeTerm.getCurrentState() === 0) {
									if (!manager.getQueueProcessing()) {
										for ( x = 0, y = children.length; x < y; x++) {
											manager.findStructuredElement("term", children[x]).show();
										}
									}
								}
								else {
									for ( x = 0, y = children.length; x < y; x++) {
										manager.findStructuredElement("term", children[x]).hide();
									}

									manager.findStructuredElement("term", activeTerm).show();
								}
							}
							/*else {
							 for ( x = 0, y = children.length; x < y; x++) {
							 manager.findStructuredElement("term", children[x]).hide();
							 }
							 }*/
						})();
					}
					catch(ignore) {

					}
				}

				if (manager.getLoggingEnabled()) {
					var activityLog = manager.getActivityLog();
					var idx = -1;

					for ( x = activityLog.length; x--; ) {
						if (activityLog[x].TERM_OCID === ocid) {
							idx = x;
							break;
						}
					}

					if (idx > -1) {
						if (currentState != activityLog[x].TERM_STATE) {
							activityLog[x].TERM_STATE = currentState;
							activityLog[x].TIMESTAMP = df.format(new Date(), mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
							activityLog[x].NEW = (currentState == activityLog[x].ORIG_STATE ? false : true);
						}
					}
					else {
						manager.addItemToLog({
							"TERM_OCID" : ocid,
							"TERM_DISPLAY" : term.getTitle(),
							"TERM_STATE" : currentState,
							"ORIG_STATE" : 0,
							"TIMESTAMP" : df.format(new Date(), mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR),
							"NEW" : true
						});
					}

					CPEventManager.notifyObservers("ACTIVITY_LOG_UPDATE", manager);
				}

				manager.executeActions(manager.getActionsFromEvents(eventsByOCID[ocid]), term);
			}
		}
	});

	CPEventManager.addObserver("MPAGE_STRUCTURED_TERM_ACTIVITY_UNDO", function(term) {
		var ocid = term.getOCID();

		for (x in managers) {
			manager = managers[x];

			if (manager.findTerm(ocid) != undefined) {
				try {
					manager.handleHideCommentsAction({
						"TYPE" : "HIDE_TERM_COMMENTS",
						"TARGET" : ocid,
						"PRIORITY" : 0
					});
				}
				catch(ignore) {

				}
			}
		}
	});
})();

var Search_Util=function(){return{makeCCLRequest:function(program,paramAr,async,statusHandler){var info=CERN_BrowserDevInd?new XMLHttpRequest():new XMLCclRequest();
info.onreadystatechange=function(){if(info.readyState===4&&info.status===200){if(statusHandler){var jsonEval=JSON.parse(info.responseText);
var recordData=jsonEval.RECORD_DATA;
if(recordData.STATUS_DATA.STATUS==="Z"){statusHandler("Z");
}else{if(recordData.STATUS_DATA.STATUS==="S"){statusHandler("S",recordData);
}else{var errAr=[];
var statusData=recordData.STATUS_DATA;
for(var x=0,xl=statusData.SUBEVENTSTATUS.length;
x<xl;
x++){var ss=statusData.SUBEVENTSTATUS[x];
errAr.push(ss.OPERATIONNAME,ss.OPERATIONSTATUS,ss.TARGETOBJECTNAME,ss.TARGETOBJECTVALUE);
}statusHandler("F",errAr.join(", "));
}}}}else{if(info.readyState===4&&info.status!==200){statusHandler("F");
}}};
if(CERN_BrowserDevInd){var joinedParam=paramAr.join(",").replace(/[\^]/g,"~");
var url=program+"?parameters="+joinedParam;
info.open("GET",url,async);
info.send(null);
}else{info.open("GET",program,async);
info.send(paramAr.join(","));
}},createPersonNameSearchTokens:function(searchString){searchString=searchString.replace(/^\s+|\s+$/,"");
var searchTokens=[];
var indexOfComma=searchString.indexOf(",");
var indexOfSpace=searchString.indexOf(" ");
if(indexOfComma>=0){searchTokens=searchString.split(",");
}else{if((indexOfSpace<0)||(indexOfSpace>=0&&indexOfSpace==searchString.length-1)){searchTokens[0]=searchString;
searchTokens[1]="";
}else{var tempSearchTokens=searchString.split(/\s+/g);
searchTokens[0]=tempSearchTokens[1];
searchTokens[1]=tempSearchTokens[0];
}}searchTokens[0]=searchTokens[0].replace(/\s+/g,"");
searchTokens[1]=searchTokens[1].replace(/\s+/g,"");
return searchTokens;
}};
}();
function DocumentBaseComponent(){this.m_resultStatusCodes=null;
this.m_resultStatusMeanings=null;
this.m_includeHover=true;
this.m_pcnFavorites=true;
this.setIncludeLineNumber(true);
DocumentBaseComponent.method("InsertData",function(){if(this.getGrouperFilterEventSets()){CERN_DOCUMENT_BASE_O1.RefreshDocumentsTable(this,this.getGrouperFilterLabel(),this.getGrouperFilterEventSets());
}else{CERN_DOCUMENT_BASE_O1.GetDocumentsTable(this);
}});
DocumentBaseComponent.method("setResultStatusCodes",function(value){this.m_resultStatusCodes=value;
});
DocumentBaseComponent.method("addResultStatusCode",function(value){if(!this.m_resultStatusCodes){this.m_resultStatusCodes=[];
}this.m_resultStatusCodes.push(value);
});
DocumentBaseComponent.method("getResultStatusCodes",function(){if(this.m_resultStatusCodes){return this.m_resultStatusCodes;
}else{if(this.m_resultStatusMeanings){var resStatusCodeSet=MP_Util.GetCodeSet(8,false);
if(this.m_resultStatusMeanings&&this.m_resultStatusMeanings.length>0){for(var x=this.m_resultStatusMeanings.length;
x--;
){var code=MP_Util.GetCodeByMeaning(resStatusCodeSet,this.m_resultStatusMeanings[x]);
if(code){this.addResultStatusCode(code.codeValue);
}}}}}return this.m_resultStatusCodes;
});
DocumentBaseComponent.method("addResultStatusMeaning",function(value){if(!this.m_resultStatusMeanings){this.m_resultStatusMeanings=[];
}this.m_resultStatusMeanings.push(value);
});
DocumentBaseComponent.method("setResultStatusMeanings",function(value){this.m_resultStatusMeanings=value;
});
DocumentBaseComponent.method("isHoverEnabled",function(){return this.m_includeHover;
});
DocumentBaseComponent.method("setHoverEnabled",function(value){this.m_includeHover=value;
});
DocumentBaseComponent.method("isPcnFavEnabled",function(){return this.m_pcnFavorites;
});
DocumentBaseComponent.method("setPcnFavEnabled",function(value){this.m_pcnFavorites=value;
});
DocumentBaseComponent.method("FilterRefresh",function(label,esArray){CERN_DOCUMENT_BASE_O1.RefreshDocumentsTable(this,label,esArray);
});
DocumentBaseComponent.method("HandleSuccess",function(recordData){CERN_DOCUMENT_BASE_O1.RenderComponent(this,recordData);
});
}DocumentBaseComponent.inherits(MPageComponent);
var CERN_DOCUMENT_BASE_O1=function(){function getLatestParticipation(doc){var returnPart=null;
for(var x=doc.ACTION_PROVIDERS.length;
x--;
){var part=doc.ACTION_PROVIDERS[x];
if(!returnPart||part.DATE>returnPart.DATE){returnPart=part;
}}return(returnPart);
}function DocumentSorter(a,b){var aPart=getLatestParticipation(a);
var bPart=getLatestParticipation(b);
var aDate="";
var bDate="";
if(aPart){aDate=aPart.EFFECTIVE_DT_TM;
}if(bPart){bDate=bPart.EFFECTIVE_DT_TM;
}if(aDate>bDate){return -1;
}else{if(aDate<bDate){return 1;
}else{return 0;
}}}function getAuthorParticipant(doc){var returnPart=null,type_cd=null,status_cd=null,part=null,strPerform="PERFORM",strCompleted="COMPLETED";
for(var y=doc.ACTION_PROVIDERS.length;
y--;
){part=doc.ACTION_PROVIDERS[y];
type_cd=part.TYPE_CD_MEANING;
status_cd=part.STATUS_CD_MEANING;
if((type_cd===strPerform)&&(status_cd===strCompleted)){returnPart=part;
break;
}}return(returnPart);
}function appendDropDown(preSec,component,pcnFav,contentPath){if(preSec!="doc"){return;
}pre=component.getStyles().getId();
if(_g(pre+"Drop")&&_g(pre+"Menu")){return;
}var img=Util.cep("img",{src:contentPath+"/images/3943_16.gif"});
var link=Util.cep("a",{className:"drop-Down",id:pre+"Drop"});
var menu=Util.cep("div",{id:pre+"Menu",className:"form-menu menu-hide"});
Util.ac(img,link);
var sec=_g(component.getStyles().getId());
var secCL=Util.Style.g("sec-hd",sec,"h2");
var secSpan=secCL[0];
Util.ac(link,secSpan);
Util.ac(menu,secSpan);
pcnFavLoad(pcnFav,component);
}function pcnFavLoad(pcnFav,component){var jsonPcnFav=pcnFav;
var docDropId=component.getStyles().getId()+"Drop";
var docDrop=_g(docDropId);
var htmlPcnFav=[];
var numId=0;
var pcn=jsonPcnFav.PRE_COMPLETED;
pcn.sort(function(obj1,obj2){function checkStrings(s1,s2){return(s1===s2)?0:((s1>s2)?1:-1);
}return checkStrings(obj1.DISPLAY.toUpperCase(),obj2.DISPLAY.toUpperCase());
});
if(!pcn[0]){htmlPcnFav.push("<div>",i18n.discernabu.documents_base_o1.DOCUMENT_FAVS,'<span class="favHidden" id="docCKI',numId,'">',i18n.DOCUMENT_FAVS,"</span></div>");
}else{var crit=component.getCriterion();
for(var j=0,l=pcn.length;
j<l;
j++){var pcNote=pcn[j];
numId=numId+1;
htmlPcnFav.push('<div><a id="doc',numId,'" href="#">',pcNote.DISPLAY,"</a>",'<span class="favHidden" id="docCKI',numId,'">',pcNote.SOURCE_IDENTIFIER,"</span>",'<span class="favHidden" id="docStyleID',numId,'">',component.getStyles().getId(),"</span>","</div>");
}}var pcnArray=htmlPcnFav.join("");
var newSpan=Util.cep("span");
newSpan.innerHTML=pcnArray;
var docMenuId=component.getStyles().getId()+"Menu";
var docMenu=_g(docMenuId);
Util.ac(newSpan,docMenu);
var docMenuList=_gbt("a",docMenu);
var dmLen=docMenuList.length;
for(var i=dmLen;
i--;
){Util.addEvent(docMenuList[i],"click",addDocDet);
}closeMenuInit(docMenu,component.getStyles().getId());
Util.addEvent(docDrop,"click",function(){if(Util.Style.ccss(Util.gns(this),"menu-hide")){_g(component.getStyles().getId()).style.zIndex=2;
Util.preventDefault();
Util.Style.rcss(Util.gns(this),"menu-hide");
}else{_g(component.getStyles().getId()).style.zIndex=1;
Util.Style.acss(Util.gns(this),"menu-hide");
}});
}function addDocDet(){try{var PowerNoteMPageUtils=window.external.DiscernObjectFactory("POWERNOTE");
MP_Util.LogDiscernInfo(null,"POWERNOTE","documentbase.js","addDocDet");
var comp={};
if(PowerNoteMPageUtils){var menuVal=Util.gns(this);
var cki=menuVal.firstChild.data;
var spanDocStyleID=Util.gns(menuVal);
for(var x=0,xl=CERN_MPageComponents.length;
x<xl;
x++){comp=CERN_MPageComponents[x];
var styles=comp.getStyles();
if(styles.getId()==spanDocStyleID.firstChild.data){break;
}}var crit=comp.getCriterion();
PowerNoteMPageUtils.BeginNoteFromPrecompletedNote(crit.person_id+".0",crit.encntr_id+".0",cki+".0");
CERN_DOCUMENT_BASE_O1.GetDocumentsTable(comp);
}}catch(err){alert('An error has occured calling DiscernObjectFactory("POWERNOTE"): '+err.name+" "+err.message);
return;
}}function closeMenuInit(inMenu,compId){var menuId;
var docMenuId=compId+"Menu";
function menuLeave(e){if(!e){var e=window.event;
}var relTarg=e.relatedTarget||e.toElement;
if(e.relatedTarget.id==inMenu.id){Util.Style.acss(inMenu,"menu-hide");
_g(menuId).style.zIndex=1;
}e.stopPropagation();
Util.cancelBubble(e);
}if(inMenu.id==docMenuId){menuId=compId;
}if(!e){var e=window.event;
}if(window.attachEvent){Util.addEvent(inMenu,"mouseleave",function(){Util.Style.acss(inMenu,"menu-hide");
_g(menuId).style.zIndex=1;
});
}else{Util.addEvent(inMenu,"mouseout",menuLeave);
}}return{GetDocumentsTable:function(component){var mgr=new MP_Core.XMLCCLRequestThreadManager(CERN_DOCUMENT_BASE_O1.RenderReply,component,false);
var sendAr=[];
var request=null;
var thread=null;
var criterion=component.getCriterion();
var groups=component.getGroups();
var codes=component.getResultStatusCodes();
var events=(groups&&groups.length>0)?groups[0].getEventSets():null;
var results=(codes&&codes.length>0)?codes:null;
var encntrOption=(component.getScope()===2)?(criterion.encntr_id+".0"):"0.0";
sendAr.push("^MINE^",criterion.person_id+".0",encntrOption,criterion.provider_id+".0",component.getLookbackUnits());
sendAr.push(MP_Util.CreateParamArray(events,1));
sendAr.push(MP_Util.CreateParamArray(results,1));
var unitType=component.getLookbackUnitTypeFlag();
sendAr.push(criterion.ppr_cd+".0",unitType);
request=new MP_Core.ScriptRequest(component,"ENG:MPG.DOC.O1 - load documents");
request.setProgramName("MP_RETRIEVE_DOCUMENTS_JSON");
request.setParameters(sendAr);
request.setAsync(true);
thread=new MP_Core.XMLCCLRequestThread("GetDocumentData",component,request);
mgr.addThread(thread);
if(component.isPlusAddEnabled()){sendAr=[];
sendAr.push("^MINE^",criterion.provider_id);
request=new MP_Core.ScriptRequest(component,"ENG:MPG.DOC.O1 - load PCN Favs");
request.setProgramName("MP_GET_DOCUMENT_FAVORITES");
request.setParameters(sendAr);
request.setAsync(true);
thread=new MP_Core.XMLCCLRequestThread("GetPcnFavorites",component,request);
mgr.addThread(thread);
}mgr.begin();
},RefreshDocumentsTable:function(component,filterLabel,filterESArray){var mgr=new MP_Core.XMLCCLRequestThreadManager(CERN_DOCUMENT_BASE_O1.RenderReply,component,false);
var sendAr=[];
var request=null;
var thread=null;
var criterion=component.getCriterion();
var codes=component.getResultStatusCodes();
var encntrOption=(component.getScope()==2)?(criterion.encntr_id+".0"):"0.0";
sendAr.push("^MINE^",criterion.person_id+".0",encntrOption,criterion.provider_id+".0",component.getLookbackUnits());
sendAr.push(MP_Util.CreateParamArray(filterESArray,1));
sendAr.push(MP_Util.CreateParamArray(codes,1));
var unitType=component.getLookbackUnitTypeFlag();
sendAr.push(criterion.ppr_cd+".0",unitType);
request=new MP_Core.ScriptRequest(component,"ENG:MPG.DOC.O1 - load documents");
request.setProgramName("MP_RETRIEVE_DOCUMENTS_JSON");
request.setParameters(sendAr);
request.setAsync(true);
thread=new MP_Core.XMLCCLRequestThread("GetDocumentData",component,request);
mgr.addThread(thread);
if(component.isPlusAddEnabled()){sendAr=[];
sendAr.push("^MINE^",criterion.provider_id);
request=new MP_Core.ScriptRequest(component,"ENG:MPG.DOC.O1 - load PCN Favs");
request.setProgramName("MP_GET_DOCUMENT_FAVORITES");
request.setParameters(sendAr);
request.setAsync(true);
thread=new MP_Core.XMLCCLRequestThread("GetPcnFavorites",component,request);
mgr.addThread(thread);
}mgr.begin();
},RenderReply:function(replyAr,component){var timerRenderComponent=MP_Util.CreateTimer(component.getComponentRenderTimerName());
var countText="";
var compNS=component.getStyles().getNameSpace();
var errMsg=[];
try{for(var repCnt=replyAr.length;
repCnt--;
){var reply=replyAr[repCnt];
var repStatus=reply.getStatus();
switch(reply.getName()){case"GetPcnFavorites":var favData=reply.getResponse();
if(repStatus=="S"){appendDropDown(compNS,component,favData,component.getCriterion().static_content);
}break;
case"GetDocumentData":if(repStatus=="F"){errMsg.push(reply.getError());
MP_Util.Doc.FinalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(),errMsg.join("<br />")),component,"");
}else{if(repStatus=="S"){var recordData=reply.getResponse();
var sHTML="";
sHTML=CERN_DOCUMENT_BASE_O1.RenderComponent(component,recordData);
countText=MP_Util.CreateTitleText(component,recordData.DOCS.length);
MP_Util.Doc.FinalizeComponent(sHTML,component,countText);
if(component.isScrollingEnabled()&&(recordData.DOCS.length>=component.getScrollNumber())){var xNode=Util.Style.g(compNS+"-info-hdr",document.body,"DL");
if(xNode[0]){Util.Style.acss(xNode[0],"hdr-scroll");
}}}else{countText=(component.isLineNumberIncluded()?"(0)":"");
MP_Util.Doc.FinalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()),component,countText);
}}break;
}}}catch(err){if(timerRenderComponent){timerRenderComponent.Abort();
timerRenderComponent=null;
}throw (err);
}finally{if(timerRenderComponent){timerRenderComponent.Stop();
}}},RenderComponent:function(component,recordData){var compNS=component.getStyles().getNameSpace();
var DocI18n=i18n.discernabu.documents_base_o1;
var df=new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
var sHTML="";
var countText="";
var jsHTML=[];
jsHTML.push("<div class='content-hdr'><dl class='",compNS,"-info-hdr hdr'><dd class='",compNS+"-cat-hd'><span></span></dd>");
jsHTML.push("<dd class='",compNS,"-auth-hd'><span>",DocI18n.AUTHOR,"</span></dd>");
if(PathologyComponent&&(component instanceof PathologyComponent)){jsHTML.push("<dd class='",compNS,"-dt-hd'><span>",DocI18n.DATE,"</span></dd>");
}else{jsHTML.push("<dd class='",compNS,"-dt-hd'><span>",DocI18n.DATE_TIME,"</span></dd>");
}if(component.getDateFormat()==3){jsHTML.push("<dd class='",compNS+"-cat-hd'><span></span></dd><dd class='",compNS,"-auth-hd'><span></span></dd><dd class='",compNS,"-dt-hd'><span>",DocI18n.WITHIN,"</span></dd>");
}jsHTML.push("</dl></div>");
recordData.DOCS.sort(DocumentSorter);
jsHTML.push("<div class='",MP_Util.GetContentClass(component,recordData.DOCS.length),"'>");
for(var x=0,xl=recordData.DOCS.length;
x<xl;
x++){var dtHvr="",lastPrsnl="";
var author=DocI18n.UNKNOWN;
var docObj=recordData.DOCS[x];
var patId=docObj.PERSON_ID+".0";
var enctrId=docObj.ENCNTR_ID+".0";
var evntId=docObj.EVENT_ID+".0";
var docStatus=docObj.RESULT_STATUS_CD_MEAN;
var doc=docObj.EVENT_CD_DISP;
var parentEventId=docObj.PARENT_EVENT_ID+".0";
var viewerType=docObj.VIEWER_TYPE;
var dateOfService=null;
var withinDateDos=null;
var dateTime=new Date();
if(docObj.EFFECTIVE_DT_TM){dateTime.setISO8601(docObj.EFFECTIVE_DT_TM);
dateOfService=MP_Util.DisplayDateByOption(component,dateTime);
withinDateDos=MP_Util.CalcWithinTime(dateTime);
}else{dateOfService=DocI18n.UNKNOWN;
withinDateDos=DocI18n.UNKNOWN;
}var recentPart=getLatestParticipation(docObj);
var authorPart=getAuthorParticipant(docObj);
if(authorPart){author=authorPart.PRSNL_NAME;
}if(recentPart&&recentPart.PRSNL_NAME!==""){lastPrsnl=recentPart.PRSNL_NAME;
var dtTm=new Date();
if(recentPart.DATE!==""){dtTm.setISO8601(recentPart.DATE);
dtHvr=df.format(dtTm,mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
}else{dtHvr=DocI18n.UNKNOWN;
}}else{lastPrsnl=DocI18n.UNKNOWN;
dtHvr=DocI18n.UNKNOWN;
}jsHTML.push("<dl class='",compNS,"-info'><dd class='",compNS+"-cat'><span>",MP_Util.CreateClinNoteLink(patId,enctrId,evntId,doc,viewerType,parentEventId),"</span>");
if(docStatus==="MODIFIED"||docStatus==="ALTERED"){jsHTML.push("<span class='res-modified'>&nbsp;</span>");
}jsHTML.push("</dd>");
jsHTML.push("<dd class='",compNS,"-auth'><span>",author,"</span></dd>");
if(component.getDateFormat()==3){jsHTML.push("<dd class='",compNS,"-dt'><span class='date-time'>",withinDateDos,"</span></dd>");
}else{jsHTML.push("<dd class='",compNS,"-dt'><span class='date-time'>",dateOfService,"</span></dd>");
}jsHTML.push("<dd class='",compNS,"-image'>");
if(docObj.IMAGE_URL!==""){var urlParam='javascript:MPAGES_SVC_EVENT("'+docObj.IMAGE_URL+'",^MINE,$PAT_PersonId$^)';
jsHTML.push("<a class='",compNS,"-image-found' href='",urlParam,"'>&nbsp;</a>");
}else{jsHTML.push("&nbsp;");
}jsHTML.push("</dd></dl>");
if(component.isHoverEnabled()){jsHTML.push("<h4 class='det-hd'><span>",DocI18n.DOCUMENTATION_DETAILS,"</span></h4><div class='hvr'><dl class='",compNS,"-det'><dt><span>",DocI18n.NAME,":</span></dt><dd class='",compNS,"-det-name'><span>",doc,"</span></dd><dt><span>",DocI18n.SUBJECT,":</span></dt><dd class='",compNS,"-det-subj'><span>",docObj.SUBJECT,"</span></dd><dt><span>",DocI18n.STATUS,":</span></dt><dd class='",compNS,"-det-status'><span>",docObj.RESULT_STATUS_CD_DISP,"</span></dd><dt><span>",DocI18n.LAST_UPDATED,":</span></dt><dd class='",compNS,"-det-dt'><span>",dtHvr,"</span></dd><dt><span>",DocI18n.LAST_UPDATED_BY,":</span></dt><dd class='",compNS,"-det-dt'><span>",lastPrsnl,"</span></dd></dl></div>");
}}jsHTML.push("</div>");
sHTML=jsHTML.join("");
return sHTML;
}};
}();
function MeasurementBaseComponent(criterion){this.m_resultCount=0;
this.m_isEventSetInfo=false;
this.m_isComment=false;
MeasurementBaseComponent.method("setResultCount",function(value){this.m_resultCount=value;
});
MeasurementBaseComponent.method("getResultCount",function(){return(this.m_resultCount);
});
MeasurementBaseComponent.method("setIncludeEventSetInfo",function(value){this.m_isEventSetInfo=value;
});
MeasurementBaseComponent.method("includeEventSetInfo",function(){return(this.m_isEventSetInfo);
});
MeasurementBaseComponent.method("setIncludeComments",function(value){this.m_isComment=value;
});
MeasurementBaseComponent.method("includeComments",function(){return(this.m_isComment);
});
MeasurementBaseComponent.method("InsertData",function(){var timerLoadComponent=MP_Util.CreateTimer(this.getComponentLoadTimerName(),this.getCriterion().category_mean);
try{getMeasurementData(this);
}catch(err){if(timerLoadComponent){timerLoadComponent.Abort();
timerLoadComponent=null;
}}finally{if(timerLoadComponent){timerLoadComponent.Stop();
}}});
function getMeasurementData(component){var groups=component.getGroups();
if(groups&&groups.length>0){var mgr=new MP_Core.XMLCCLRequestThreadManager(component.HandleSuccess,component,true);
var criterion=component.getCriterion();
var programName="MP_RETRIEVE_N_RESULTS_JSON";
for(var x=0,xl=groups.length;
x<xl;
x++){var group=groups[x];
var sEventSets="0.0",sEventCodes="0.0";
var sBeginDate="^^";
var sEndDate="^^";
var esInfo=(component.includeEventSetInfo())?1:0;
var commentInfo=(component.includeComments())?1:0;
var sendAr=[];
var request=null;
var thread=null;
var sEncntr=(component.getScope()===2)?criterion.encntr_id+".0":"0.0";
if(group instanceof MPageEventSetGroup){sEventSets=MP_Util.CreateParamArray(group.getEventSets(),1);
}else{if(group instanceof MPageEventCodeGroup){sEventCodes=MP_Util.CreateParamArray(group.getEventCodes(),1);
}else{if(group instanceof MPageSequenceGroup){var mapItems=group.getMapItems();
sEventSets=MP_Util.CreateParamArray(MP_Util.GetValueFromArray("CODE_VALUE",mapItems),1);
}else{if(group instanceof MPageGrouper){var g=group.getGroups();
var ec=[];
for(var y=0,yl=g.length;
y<yl;
y++){if(g[y] instanceof MPageEventCodeGroup){ec=ec.concat(g[y].getEventCodes());
}}sEventCodes=MP_Util.CreateParamArray(ec,1);
}else{continue;
}}}}sendAr.push("^MINE^",criterion.person_id+".0",sEncntr,criterion.provider_id+".0",criterion.ppr_cd+".0",component.getResultCount(),"^^",sEventSets,sEventCodes,component.getLookbackUnits(),component.getLookbackUnitTypeFlag(),esInfo,sBeginDate,sEndDate,commentInfo);
request=new MP_Core.ScriptRequest(component,"ENG:MPG.MEASBASE.O1 - load "+group.getGroupName());
request.setProgramName(programName);
request.setParameters(sendAr);
request.setAsync(true);
thread=new MP_Core.XMLCCLRequestThread(group.getGroupName(),component,request);
mgr.addThread(thread);
}mgr.begin();
}else{MP_Core.CreateSimpleError(component,i18n.discernabu.measurement_base_o1.ERROR_MISSING_ES_EC);
}}}MeasurementBaseComponent.inherits(MPageComponent);
var CERN_MEASUREMENT_BASE_O1=function(){function getMeasurementDataArray(recordData,personnelArray,codeArray){var measureArray=[];
if(!codeArray){codeArray=MP_Util.LoadCodeListJSON(recordData.CODES);
}if(!personnelArray){personnelArray=MP_Util.LoadPersonelListJSON(recordData.PRSNL);
}var results=recordData.RESULTS;
for(var i=0,il=results.length;
i<il;
i++){var result=results[i];
if(result.CLINICAL_EVENTS.length>0){for(var j=0,jl=result.CLINICAL_EVENTS.length;
j<jl;
j++){var meas=result.CLINICAL_EVENTS[j];
for(var k=0,kl=meas.MEASUREMENTS.length;
k<kl;
k++){var measurement=new MP_Core.Measurement();
measurement.initFromRec(meas.MEASUREMENTS[k],codeArray);
measureArray.push(measurement);
}}}}return measureArray;
}return{LoadMeasurementDataMap:function(recordData,personnelArray,codeArray,sortOption){var mapObjects=[];
var results=recordData.RESULTS;
if(!codeArray){codeArray=MP_Util.LoadCodeListJSON(recordData.CODES);
}if(!personnelArray){personnelArray=MP_Util.LoadPersonelListJSON(recordData.PRSNL);
}for(var i=0,il=results.length;
i<il;
i++){var result=results[i];
if(result.CLINICAL_EVENTS.length>0){for(var j=0,jl=result.CLINICAL_EVENTS.length;
j<jl;
j++){var measureArray=[];
var mapObject=null;
if(result.EVENT_CD>0){mapObject=new MP_Core.MapObject(result.EVENT_CD,measureArray);
}else{mapObject=new MP_Core.MapObject(result.EVENT_SET_NAME,measureArray);
}var meas=result.CLINICAL_EVENTS[j];
for(var k=0,kl=meas.MEASUREMENTS.length;
k<kl;
k++){var measurement=new MP_Core.Measurement();
measurement.initFromRec(meas.MEASUREMENTS[k],codeArray);
measureArray.push(measurement);
}if(measureArray.length>0){if(sortOption){measureArray.sort(sortOption);
}else{measureArray.sort(CERN_MEASUREMENT_BASE_O1.SortByEffectiveDateDesc);
}mapObjects.push(mapObject);
}}}}return mapObjects;
},LoadMeasurementDataArray:function(recordData,personnelArray,codeArray,sortOption){var measureArray=getMeasurementDataArray(recordData,personnelArray,codeArray);
if(measureArray.length>0){if(sortOption){measureArray.sort(sortOption);
}else{measureArray.sort(CERN_MEASUREMENT_BASE_O1.SortByEffectiveDateDesc);
}}return measureArray;
},LoadMeasurementDataArrayNoSort:function(recordData,personnelArray,codeArray){return getMeasurementDataArray(recordData,personnelArray,codeArray);
},SortByEffectiveDateDesc:function(a,b){if(a.getDateTime()>b.getDateTime()){return -1;
}else{if(a.getDateTime()<b.getDateTime()){return 1;
}}return 0;
}};
}();
/**
 * This object is used as an adapter between the Discern ABU MPages framework MPageView generic loading API
 * and the Organizer Worklist framework.  All of the necessary configuration and instantiation for both
 * frameworks will happen in this object.
 * @constructor
 */
OrganizerWorklistAdapter = function() {
	//Log info for debugger
	logger.logMessage("Instantiating an OrganizerWorklistAdapter MPagesView");
	//Set page level information
	this.setName("MPages View");
};

/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
OrganizerWorklistAdapter.prototype = new MPageView();
OrganizerWorklistAdapter.prototype.constructor = MPageView;

OrganizerWorklistAdapter.prototype.preProcessing = function(){
	var criterion = this.getCriterion();
	
	if(!this.isContextValid()){
		//If we are not in the correct context, do not attempt to initialize the framework.
		//We will handle displaying the invalid context in the renderView function.
		return;
	}
	
	try{
		require.config({
			paths: {
				'text': criterion.static_content +'/lib/require/text'
			},
			deps: ['knockout', 'ko.mapping', 'ko.scroll'],
			callback: function (ko, mapping, scroll) {
				ko.mapping = mapping;
				ko.scroll = scroll;
			},
			waitSeconds: 0
		});
	}
	catch(err){
		logger.logError("Error initializing the Worklist Framework");
		logger.logJSError(err, null, "OrgnaizerWorklistAdapter.js", "initializeView");
		throw err;
	}
};
OrganizerWorklistAdapter.prototype.initializeComponents = function(){};


OrganizerWorklistAdapter.prototype.renderView = function() {
	var timerRenderMPage = null;
	var self = this;
	
	try {
		//Check to see if this view is even valid in the current context.
		if(!this.isContextValid()){
			//The current context is not valid for this view so we need to show a context error message
			this.displayInvalidContextMessage();
			return;
		}
		
		timerRenderMPage = MP_Util.CreateTimer("ENG:MPG.MPageView - renderMPage", this.getCategoryMean());
		
		//Store the container, so we can easily access it later
		this.setContainer($("#" + this.getCategoryMean()));

		// Configure the Organizer framework
		var categoryMean = this.getCategoryMean();
		var bedrockData = this.getViewSettingsObject();

		require(
			['require','jquery', 'durandal/system', 'durandal/app', 'durandal/composition','durandal/viewLocator', 'durandal/binder', 'i18next', 'toastr', 'plugins/dialog', 'dialogContext', 'numeral', 'plugins/widget'],
			function (require, $, system, app, composition, viewLocator, binder, i18n, toastr, dialog, dContext, numeral, widget) {
				// Set the i18n options
				var resources = {};
				var criterion = CERN_Platform.getCriterion();
				var isInMillenniumContext = CERN_Platform.inMillenniumContext();
				var locale = criterion.CRITERION.LOCALE_ID.replace(/_/gi,"-").toLowerCase();
				resources[locale] = _i18nData();
				var divHost = $('<div id="appHost-' + categoryMean + '"></div>');
				
				requirejs.config({
				 config: {
	                'framework/services/viewpointAdapter': {
	                    criterion: criterion,
						inMillenniumContext : isInMillenniumContext,
	                    viewIdentifier: categoryMean,
	                    bedrockData: bedrockData
	                },
	                'mpages/mp_util': {
	                    criterion: criterion
	                },
	                'framework/services/datacontext': {
	                    criterion: criterion,
						inMillenniumContext : isInMillenniumContext
	                }
	            }
				});
				system.debug(CERN_BrowserDevInd);
			
				var i18nNOptions = {
					detectFromHeaders: false,
					lng: locale,
					fallbackLang: 'en-us',
					ns: 'app',
					useCookie: false,
					getAsync: false,
					resStore: resources,
					lowerCaseLng : true
				};
	
				// enable durandal plugins
				app.configurePlugins({
					dialog: true,
					widget: true
				});
	
				// enable custom plugins
				app.configurePlugins({
					popover: true,
					messagebox : true
				}, 'framework/plugins');

				// configure toastr  options
				toastr.options = {
					"closeButton": false,
					"debug": false,
					"positionClass": "toast-top-right",
					"onclick": null,
					"showDuration": "300",
					"hideDuration": "1000",
					"timeOut": "5000",
					"extendedTimeOut": "1000",
					"showEasing": "swing",
					"hideEasing": "linear",
					"showMethod": "fadeIn",
					"hideMethod": "fadeOut"
				};
	
				// set the custom modal dialog and custom message box
				dialog.addContext('BasicDialog', dContext);
				widget.mapKind('columnHeader', 'framework/widgets/columnHeader/view', 'framework/widgets/columnHeader/viewmodel');
				widget.mapKind('statusPanel', 'framework/widgets/statusPanel/view', 'framework/widgets/statusPanel/viewmodel');

				   system.acquire('lang/' + locale.toLowerCase()).then(function (lang) {
					if (lang) {
						// load the language settings
						numeral.language(locale.toLowerCase(), lang);
						// switch to use the language settings
						numeral.language(locale.toLowerCase());
					}
				});
	
				
				// ensure that hasFocus binding gets applied after composition is complete
				composition.addBindingHandler('hasFocus');

				app.start().then(function () {
	
					//Replace 'viewmodels' in the moduleId with 'views' to locate the view.
					//Look for partial views in a 'views' folder in the root.
					viewLocator.useConvention();
	
					i18n.init(i18nNOptions, function () {
						binder.binding = function (obj, view) {
							$(view).i18n();
						};
					});
	
					//Show the app by setting the root view model for our application with a transition.
					return app.setRoot('framework/viewmodels/shell', 'entrance',divHost[0]);
				}).done(function () {
					$(self.getContainer()).append(divHost[0]);
				});
			}
		);
	
		return true;
	}
	catch (err) {
		if (timerRenderMPage) {
			timerRenderMPage.Abort();
			timerRenderMPage = null;
		}
		logger.logJSError(err, null, "MPageView.js", "renderMPage");
		throw err;
	}
	finally {
		if (timerRenderMPage) {
			timerRenderMPage.Stop();
		}
	}
};

OrganizerWorklistAdapter.prototype.postProcessing = function(){};

/** These functions are overwritten since most of the functionality does not apply to the Organizer Worklist MPages **/

OrganizerWorklistAdapter.prototype.createMPageComponentObject = function(compFilterMean) {
     // do nothing
};

OrganizerWorklistAdapter.prototype.resizeView = function(){
	var viewIdentifier = this.getCategoryMean();
	require(['durandal/app'], function (app) {
		app.trigger('mpages-resize', viewIdentifier);
	});
};

MP_Util.setObjectDefinitionMapping("PO_PATLIST", OrganizerWorklistAdapter);
/* calculators view object**/
/**
 * Implementation of the Calculators Summary MPageView object
 */
/**
 * A constructor used to create a new CalculatorsSummaryMPage object and initialize page level variables.
 * @constructor
 * @param {string} categoryMean The category mean for the MPageView
 */
var CalculatorsSummaryMPage = function(categoryMean) {
	//Log info for debugger
	logger.logMessage("Rendering Calculators Summary View");
	//Set page level information
	this.setCategoryMean(categoryMean);
	this.setName("Calculators  MPage");
};

/**
 * Set up the prototype and constructor to inherit from the base MPagesView
 */
CalculatorsSummaryMPage.prototype = new MPageView();
CalculatorsSummaryMPage.prototype.constructor = MPageView;


/**
 * Overriding the createLayoutMenu function to ensure that the option is not added to the view.
 * @return {null} This function returns null to prevent the drag and drop menu item from being added
 */
CalculatorsSummaryMPage.prototype.createLayoutMenu = function(){
	return null;
};

/**
 * Sets the page settings object used when initializing CalculatorsSummaryMpage MPageView object elements.
 * @param {Object} settingsObj The settings object from the preferences model.
 * @return {boolean} True if the settings were applied successfully, false otherwise
 */
CalculatorsSummaryMPage.prototype.setViewSettings = function(settingsObj) {
	var compSetting = null;
	var cnt = 0;
	var compCnt = 0;
	try {
		if (settingsObj) {
			compSetting = settingsObj.BR_SET.CS;
			compCnt = compSetting.length;
			for (cnt = 0; cnt < compCnt; cnt++) {
				compSetting[cnt].C_SQ = compSetting[cnt].F_MN === "CALCULATOR" ? 2 : 1;
			}
			this.m_viewSettings = settingsObj;
			return true;
		}
		return false;
	}
	catch (err) {
		logger.logError(i18n.discernabu.mpageViewpoint.ERROR_PARSING);
		throw err;
	}
};

/**
 * Used to render the Mpages View once it has been initialized and setup, Also call the function
 * which is used to set the height of column1.
 * @return {undefined} This function does not return a value
 */
CalculatorsSummaryMPage.prototype.renderView = function() {
	MPageView.prototype.renderView.call(this);
	//Add the calc-summary class to the correct location
	$("#" + this.getCategoryMean()).addClass("mp-calc-summary");
	this.setCalcColHeight();
};


/**
 * The base functionality resizeView is called and also this function set's the height of column1
 * Also it calls function to set the column1 height.
 * @return {undefined} This function does not return a value
 */
CalculatorsSummaryMPage.prototype.resizeView = function() {
	this.setCalcColHeight();
	MPageView.prototype.resizeView.call(this);
};

/**
 * Set the column1 height of MpageView to enable scroll.
 * @return {undefined} This function does not return a value
 */
CalculatorsSummaryMPage.prototype.setCalcColHeight = function() {
	var colPsuedoMargin = 0;
	if (this.isBannerEnabled()) {
		if ($("#demobanner").outerHeight(true) > 0) {
			colPsuedoMargin = $("#vwpControls").outerHeight(true) + $("#demobanner").outerHeight(true);
		}
		else {
			colPsuedoMargin = $("#vwpControls").outerHeight(true) + 18;
		}
	}
	else {
		colPsuedoMargin = $("#vwpControls").outerHeight(true);
	}

	if(!CERN_Platform.inMillenniumContext()){
		colPsuedoMargin += $(".demo-banner-container").outerHeight(true);
	}

	colPsuedoMargin = colPsuedoMargin + 6;
	//Set column1 height containing the Summary Components.
	$(".mp-calc-summary").find(".col1").css({height: $(window).height() - colPsuedoMargin + "px"});
	//Set column2 height containing the Summary Components.
	$(".mp-calc-summary").find(".col2").css({height: $(window).height() - colPsuedoMargin + "px"});
};
/* globals MenuItem, DynamicMenu, SummaryRenderStrategy, OrderSelectionComponentO2, CERN_MPageComponents, unescape, escape, MenuSeparator, TemplateBuilder*/
/**
 * A constructor used to create a new ViewBuilderQOC object and initialize page level variables.
 * @constructor
 */
var ViewBuilderQOC = function() {
	//Log info for debugger
	logger.logMessage("Rendering View Builder QOC MPages View");
	this.m_qocSubsectionSavingEnabled = null;
	//Set page level information
	this.setName("MPages View");
	this.personalFavoriteCount = 0;
	this.i18nCommonOrdersSummary = i18n.discernabu.commonorderssummary_i18n;
	this.personalFavArray = [];
	this.venueList = [];
	this.defaultVenueDisp = "";
	this.defaultVenueVal = 0;
	//default to inpatient for order selection components
	this.m_currentPageVenue = 1;
	this.currentVenue = 0;
	this.isFolderReqAsync = false;
	this.venueSelectorId = "";
	this.m_inpatientDefaultVenue = 1;
	this.m_outpatientDefaultVenue = 1;
};
/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
ViewBuilderQOC.prototype = new MPageView();
ViewBuilderQOC.prototype.constructor = MPageView;

/**
 * Increments the personalFavoriteCount
 * @return {boolean} true if successful, false if otherwise
 */
ViewBuilderQOC.prototype.incrementFavCount = function() {
	if (this.personalFavoriteCount === 15) {
		return (false);
	}
	else {
		this.personalFavoriteCount++;
		return (true);
	}
};

/**
 * Decrements the personalFavoriteCount, intended to be used upon removal of a personal
 * favorite folder
 * @return {boolean} true if successful, false if otherwise
 */
ViewBuilderQOC.prototype.decrementFavCount = function() {
	if (this.personalFavoriteCount === 0) {
		return (false);
	}
	else {
		this.personalFavoriteCount--;
		return (true);
	}
};

/**
 * retrieves the personalFavoriteCount, intended to be used upon removal of a personal
 * favorite folder
 * @return {integer} the value of personalFavoriteCount
 */
ViewBuilderQOC.prototype.getPersonalFavoriteCount = function() {
	return (this.personalFavoriteCount);
};
/**
 * Sets whether or not to enable saving of subsections for all Order Selection components on the QOC page
 * @param {Boolean} value The boolean value in which to note to save Order Selection subsections on the QOC page
 */
ViewBuilderQOC.prototype.setQOCSubsectionSavingEnabled = function(qocSubsectionSavingEnabled) {
	this.m_qocSubsectionSavingEnabled = qocSubsectionSavingEnabled;
};


/*
 * Returns true if Order Selection components on this page will have subsection saving enabled, false otherwise
 */
ViewBuilderQOC.prototype.isQOCSubsectionSavingEnabled = function() {
	return this.m_qocSubsectionSavingEnabled;
};

/**
 * Sets the page level venue
 * @param {integer} the value to the page level-venue value to
 */
ViewBuilderQOC.prototype.setPageVenue = function(venue) {
	this.m_currentPageVenue = venue;
};

/**
 * Returns the page-level venues
 * @return {integer} the value of the page-level venue
 */
ViewBuilderQOC.prototype.getPageVenue = function() {
	return this.m_currentPageVenue;
};

/**
 * Sets the Inpatient Default Venue
 * 1 - Inpatient Venue
 * 2 - Rx Venue
 * 3 - All
 * @param {string} the value of Inpatient Default Venue
 */
ViewBuilderQOC.prototype.setInpatientDefaultVenue = function(value) {

	// If value set in bedrock filter is 3 (for All Venue), translate it to 0.
	switch(parseInt(value, 10)) {
		case 1:
			this.m_inpatientDefaultVenue = 1;
			break;
		case 2:
			this.m_inpatientDefaultVenue = 2;
			break;
		case 3:
			this.m_inpatientDefaultVenue = 0;
			break;
		default:
			this.m_inpatientDefaultVenue = 1;
			break;
	}
};

/**
 * Returns the Inpatient Default Venue
 * @return {integer} Inpatient default venue value
 */
ViewBuilderQOC.prototype.getInpatientDefaultVenue = function() {
	return this.m_inpatientDefaultVenue;
};


/**
 * Sets the Outpatient Default Venue
 * 1 - Ambulatory-In-Office Venue
 * 2 - Rx Venue
 * 3 - All
 * @param {string} the value of Outpatient Default Venue
 */
ViewBuilderQOC.prototype.setOutpatientDefaultVenue = function(value) {

	// If value set in bedrock filter is 3 (for All Venue), translate it to 0.
	switch(parseInt(value, 10)) {
		case 1:
			this.m_outpatientDefaultVenue = 1;
			break;
		case 2:
			this.m_outpatientDefaultVenue = 2;
			break;
		case 3:
			this.m_outpatientDefaultVenue = 0;
			break;
		default:
			this.m_outpatientDefaultVenue = 1;
			break;
	}
};

/**
 * Returns the Outpatient Default Venue
 * @return {integer} Outpatient default venue value
 */
ViewBuilderQOC.prototype.getOutpatientDefaultVenue = function() {
	return this.m_outpatientDefaultVenue;
};

/**
 * This function will call the base class initializeComponent, so that all the components are intialized correctly.  Once that
 * returns the components which have a toggleStatus of 0 (off), are set to not display in the MPageView.
 * @this ViewBuilderQOC
 * @return null
 */
ViewBuilderQOC.prototype.initializeComponents = function() {
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var x = 0;
	var userFavs = {};
	var userFavsCompAr = [];
	var pageSettings = {};

	pageSettings = this.getViewSettingsObject();
	if (pageSettings) {
		if (pageSettings.BR_SET.UP.length > 0) {
			//Determine if there are settings for personal favorite folders, and if so add them to the settings object.
			try {
				userFavs = JSON.parse(pageSettings.BR_SET.UP);
				userFavsCompAr = userFavs.user_prefs.page_prefs.components;
				var tempCompArr = pageSettings.BR_SET.CS;
				var userFavsLen = userFavsCompAr.length;
				var tempRow = 99;
				for (x = userFavsLen; x--;) {
					var tempID = new String(userFavsCompAr[x].id);
					/*Component IDs with the category_mean are dynamically created personal favorite folders saved in the user pref data.  Once recognized,
		 			a JSON object with the personal favorite folder component data will be created and added to the overall component list.*/
					if (tempID.indexOf(this.getCategoryMean()) > 0) {
						//personal favorite folder located
						var prsnlFavObj = this.createPersonalFolderJSONObj(userFavsCompAr[x].preferencesObj.compFolderId, unescape(userFavsCompAr[x].preferencesObj.compLabel), tempRow);
						//add to MPageView component list
						tempCompArr.push(prsnlFavObj);
						//place next personal favorite in a different location
						tempRow--;
						this.incrementFavCount();
					}
				}
			}
			catch (err) {
				return null;
			}
		}
	}

	//Call the base function to initialize the components.
	MPageView.prototype.initializeComponents.call(this, null);

	//Filter out the components based on the component toggle settings.
	componentArr = this.getComponents();
	componentCnt = componentArr.length;
	for (x = componentCnt; x--;) {
		component = componentArr[x];
		if (component.getToggleStatus() === 0) {
			component.setDisplayEnabled(false);
		}
		var temp = new String(component.getStyles()
			.getId());
		if (temp.indexOf(this.getCategoryMean()) > 0) {
			component.setIsPersonalFavorite(1);
		}
		if (component instanceof OrderSelectionComponentO2) {
			component.setSaveOnExpandEnabled(this.isQOCSubsectionSavingEnabled());
		}
	}
};

/**
 * This function will call the base class loadFilterMappings, to ensure that the base filter maps are loaded correctly.  Once
 * that returns additional filters needed for this specific view will be added
 * @return null
 */
ViewBuilderQOC.prototype.loadFilterMappings = function() {
	MPageView.prototype.loadFilterMappings.call(this, null);
	this.addFilterMappingObject("QOC_SUBSEC_PREF_SAVE", {
		setFunction : this.setQOCSubsectionSavingEnabled,
		type : "Boolean",
		field : "FREETEXT_DESC"
	});
	this.addFilterMappingObject("INPATIENT_VENUE_DFLT", {
		setFunction: this.setInpatientDefaultVenue,
		type: "String",
		field: "FREETEXT_DESC"
	});
	this.addFilterMappingObject("OUTPATIENT_VENUE_DFLT", {
		setFunction: this.setOutpatientDefaultVenue,
		type: "String",
		field: "FREETEXT_DESC"
	});
};

/**
 * Implementation for loading the component selection menu.  Components with a toggle status of 0(off) or 1(on) will
 * be added to the component selection menu.
 * @this {MPageView}
 * @return {Menu} The Menu item created for the component selection menu
 */
ViewBuilderQOC.prototype.loadComponentSelection = function() {
	var addMenu = false;
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var componentToggled = false;
	var compSelMenu = null;
	var menuItem = null;
	var that = this;
	var toggleStatus = 0;
	var x = 0;

	//This function is used to sort the available component in alphabetical order based on the component Label
	var componentSort = function(a, b) {
		var aName = a.getLabel()
			.toUpperCase();
		var bName = b.getLabel()
			.toUpperCase();
		if (aName < bName) {
			return -1;
		}
		else if (aName > bName) {
			return 1;
		}
		else {
			return 0;
		}
	};

	//This function is used to toggle the component on/off and make the necessary updates to all of the component sequences
	var toggleComponent = function(componentId, activateComp) {
		var pageGroupSeq = null;
		var toggleComp = null;
		//1 - on, 0 - off
		var toggleStatus = (activateComp) ? 1 : 0;
		var z = 0;

		//Set the toggle status for the component selected from the component selection menu
		//Locate the component we are toggling and updates its location
		for (z = componentCnt; z--;) {
			component = componentArr[z];
			//Check to see if this is the component we are toggling
			if (component.getComponentId() === componentId) {
				toggleComp = component;
				toggleComp.setToggleStatus(toggleStatus);
				if (activateComp) {
					//Add the component as the first component in the left most column
					//If the component is an organizer level component, column 99, do not update the column
					if (toggleComp.getColumn() !== 99) {
						toggleComp.setColumn(1);
					}
					toggleComp.setSequence(0);
					//Check to see if user preferences exist and if not create the blank object
					if (!MP_Core.AppUserPreferenceManager.GetPreferences()) {
						MP_Core.AppUserPreferenceManager.SetPreferences('{"user_prefs":{"page_prefs":{"components":[]}}}');
					}
				}
				break;
			}
		}

		//Update the sequences/rows for all of the components in the same colgroup and column as the toggled component.
		if (activateComp) {
			pageGroupSeq = toggleComp.getPageGroupSequence();
			for (z = componentCnt; z--;) {
				component = componentArr[z];
				//Move all of the other components in the first column down one row
				if (component.getColumn() === 1 && component.getPageGroupSequence() === pageGroupSeq && component !== toggleComp) {
					component.setSequence(component.getSequence() + 1);
				}
			}
		}
	};

	//This function is used when an element is selected in the component selection menu.
	var createSelectionFunc = function(menuItemObj) {
		return function() {
			componentToggled = true;
			toggleComponent(parseFloat(menuItemObj.getId(), 10), menuItemObj.isSelected());
		};
	};

	//Check to see if any of the components are available for toggle.
	componentArr = this.getComponents();
	componentCnt = componentArr.length;
	for (x = componentCnt; x--;) {
		component = componentArr[x];
		toggleStatus = component.getToggleStatus();
		if (toggleStatus !== 2 && !component.isComponentFiltered()) {
			addMenu = true;
			break;
		}
	}
	//Return if all components are required.  No need for a menu option.
	if (!addMenu) {
		return null;
	}

	//Create the menu
	compSelMenu = new Menu("compSelection" + this.getCategoryMean());
	compSelMenu.setLabel(i18n.COMPONENTS);
	compSelMenu.setIsRootMenu(false);
	compSelMenu.setAnchorConnectionCorner(["top", "left"]);
	compSelMenu.setContentConnectionCorner(["top", "right"]);

	//Sort the components by name
	componentArr.sort(componentSort);
	//Add all of the component selection items to the menu
	for (x = 0; x < componentCnt; x++) {
		component = componentArr[x];
		if (!component.isComponentFiltered()) {
			toggleStatus = component.getToggleStatus();
			//Create the MenuSelector item for this component
			menuItem = new MenuSelection(component.getComponentId()
				.toString());
			menuItem.setCloseOnClick(false);

			//Add the HTML for the element and the click event if it can be toggled
			if (toggleStatus === 2) {
				menuItem.setLabel(component.getLabel() + " (" + i18n.LOCKED + ")");
				menuItem.setIsDisabled(true);
				menuItem.setIsSelected(true);
			}
			else {
				menuItem.setLabel(component.getLabel());
				menuItem.setIsSelected((toggleStatus === 1) ? true : false);
				menuItem.setClickFunction(createSelectionFunc(menuItem));
			}
			compSelMenu.addMenuItem(menuItem);
		}
	}

	//Add the close menu function so the preferences are saved if the user toggles a component
	compSelMenu.setCloseFunction(function() {
		if (componentToggled) {
			var criterion = that.getCriterion();
			//Show the cursor as busy
			$("body")
				.css("cursor", "wait");

			//This call is used to update all of the component's settings before refreshing the page.
			MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(componentArr);

			//Refresh the Page or viewpoint
			CERN_Platform.refreshMPage();
		}
	});

	return compSelMenu;
};
/**
 * Loads the page menu for a specific MPageView object.
 * @this {MPageView}
 */
ViewBuilderQOC.prototype.loadPageMenu = function() {
	var categoryMean = this.getCategoryMean();
	var tempMenuItem = null;

	//Create the menu object for this page
	var pageMenu = new Menu("pageMenu" + categoryMean);
	pageMenu.setTypeClass("menu-page-menu");
	pageMenu.setIsRootMenu(true);
	pageMenu.setAnchorElementId("pageMenu" + categoryMean);
	pageMenu.setAnchorConnectionCorner(["bottom", "right"]);
	pageMenu.setContentConnectionCorner(["top", "right"]);
	pageMenu.setLabel("");

	//Create the layout selector menu item
	tempMenuItem = this.createLayoutMenu();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Create the drag and drop menu item
	tempMenuItem = this.loadDragAndDropMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Expand/Collapse Menu Option
	tempMenuItem = this.loadExpandCollapseAllMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Component Selection menu option
	tempMenuItem = this.loadComponentSelection();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Print report menu item
	tempMenuItem = this.loadPrintableReportMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Load the Add Favorite report menu item
	tempMenuItem = this.loadAddFavoriteMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Add a seperator
	pageMenu.addMenuItem(new MenuSeparator("separator"));

	//Create the clear preferences menu item
	tempMenuItem = this.createClearPrefsMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Create the help link menu item
	tempMenuItem = this.loadHelpMenuItem();
	if (MenuItem.prototype.isPrototypeOf(tempMenuItem)) {
		pageMenu.addMenuItem(tempMenuItem);
	}

	//Add the menu object to the menu manager
	MP_MenuManager.addMenuObject(pageMenu);

	//Update the click event on the menu to launch this menu when clicked.
	$("#pageMenu" + categoryMean)
		.unbind("click")
		.click(function() {
			if (pageMenu.isActive()) {
				MP_MenuManager.closeMenuStack(true);
			}
			else {
				MP_MenuManager.showMenu("pageMenu" + categoryMean);
			}
		});
	//disable add favorite menu if there are already 15 favorites on the page.
	if (this.getPersonalFavoriteCount() === 15) {
		this.disableAddFavoriteMenu();
	}
};

/**
 * ViewBuilderQOC implementation of postProcessing
 */
ViewBuilderQOC.prototype.postProcessing = function() {
	var component = null;
	var componentArr;
	var componentCnt;
	componentArr = this.getComponents();
	componentCnt = componentArr.length;
	for (var x = componentCnt; x--;) {
		component = componentArr[x];
		if (OrderSelectionComponentO2.prototype.isPrototypeOf(component)) {
			if (component.getIsPersonalFavorite()) {
				component.addRemoveMenuOption();
			}
		}
	}
	//Listen for a personal order selection component to be removed from the page
	CERN_EventListener.addListener(this, EventListener.EVENT_REMOVE_PERSONAL_FAV_FOLDER, this.personalFolderRemoval, this);
};
/**
 * Creates the Add Folder menu option for the QOC bedrock view
 * @return {MenuSelection} The MenuSelection object which will be added to the page menu for this view
 */
ViewBuilderQOC.prototype.loadAddFavoriteMenuItem = function() {
	var criterion = this.getCriterion();
	var addFoldItem = new MenuSelection("addFolder" + this.getCategoryMean());
	addFoldItem.setLabel(this.i18nCommonOrdersSummary.ADD_FAVORITE + "...");
	addFoldItem.setCloseOnClick(true);
	var self = this;
	var getFoldClick = function(QOCView) {
		return function(event) {
			var i18nCore = i18n.discernabu;
			var i18nCOS = QOCView.i18nCommonOrdersSummary;
			QOCView.getFavFolders("0", "1", function(reply) {

				var confirmMsg = i18nCOS.SELECT_PERSONAL_FAV_COMP;
				//Create the Add Favorite Folders MPage Modal Dialog
				var qocModalDialogObj = new ModalDialog("qocAddPersonalFavFolderModal");
				qocModalDialogObj.setHeaderTitle(i18nCOS.ADD_PERSONAL_FAV_COMP)
					.setHasGrayBackground(true)
					.setTopMarginPercentage(10)
					.setRightMarginPercentage(25)
					.setLeftMarginPercentage(25)
					.setIsBodySizeFixed(false)
					.setBodyDataFunction(function(qocModalDialogObj) {
						self.RenderFavFolder(reply.getResponse(), criterion, confirmMsg, qocModalDialogObj);
						self.createAddPrsnlFavFolderMsg(confirmMsg);
						self.createVenueDropDown();
					});
				//Create the Cancel ModalButton object
				var cancelButton = new ModalButton("qocCancel");
				cancelButton.setText(i18n.discernabu.CONFIRM_CANCEL)
					.setIsDithered(false)
					.setCloseOnClick(true);
				qocModalDialogObj.addFooterButton(cancelButton);
				//Adding the Qoc Add Personal Favorite Folder ModalDialog to the ModalDialog lists
				MP_ModalDialog.addModalDialogObject(qocModalDialogObj);
				//Show the modal
				MP_ModalDialog.showModalDialog('qocAddPersonalFavFolderModal');
			});
		};
	};
	addFoldItem.setClickFunction(getFoldClick(this));
	return addFoldItem;
};


/**
 * Retrieves the favorite folders
 * @param {int} folderId - the folder to retrieve
 * @param {int} venueType - the venue of the folder
 * @return order folder data
 */
ViewBuilderQOC.prototype.getFavFolders = function(folderId, venueType, callback) {

	var criterion = this.getCriterion();
	//setup the call to MP_GET_POWERORDER_FAVS_JSON at the root folder
	var sendAr = ["^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0", criterion.provider_id + ".0", folderId + ".0", "^FAVORITES^", criterion.position_cd + ".0", criterion.ppr_cd + ".0", "11", venueType];
	var request = new MP_Core.ScriptRequest();
	request.setProgramName("MP_GET_POWERORDER_FAVS_JSON");
	request.setParameters(sendAr);
	request.setAsync(this.isFolderReqAsync);
	MP_Core.XmlStandardRequest(null, request, callback);

};

/**
 * Creates the View Layout menu option for the ViewBuildderQOC
 * @return {MenuSelection} The MenuSelection object which will be added to the page menu for this view
 */
ViewBuilderQOC.prototype.createLayoutMenu = function() {
	var categoryMean = this.getCategoryMean();
	var layoutSelector = new DynamicMenu("layoutSelction" + categoryMean);
	var self = this;
	layoutSelector.setLabel(i18n.discernabu.VIEW_LAYOUT);
	layoutSelector.setIsRootMenu(false);
	layoutSelector.setAnchorConnectionCorner(["top", "left"]);
	layoutSelector.setContentConnectionCorner(["top", "right"]);
	layoutSelector.setContentCreationFunction(function() {
		var col1 = null,
			col2 = null,
			col3 = null,
			col4 = null,
			col5 = null,
			curColGroupClass = "",
			i18nCore = i18n.discernabu,
			initialColCnt = 0,
			layoutClasses = [],
			menuContainer = null,
			column = null,
			context = null,
			columnTemplate = null,
			columnName = [];
		//Determine Which dom element to examine to get the column layout
		var vpParent = "#" + categoryMean + " ";
		//Determine how many columns are currently being shown so we can highlight that element in the menu
		var colGroups = $(vpParent + '.col-group:last');
		if (colGroups.length) {
			curColGroupClass = $(colGroups)
				.attr('class')
				.replace("col-group ", "");
		}
		switch (curColGroupClass) {
			case "five-col":
				initialColCnt = 5;
				break;
			case "four-col":
				initialColCnt = 4;
				break;
			case "three-col":
				initialColCnt = 3;
				break;
			case "two-col":
				initialColCnt = 2;
				break;
			case "one-col":
				initialColCnt = 1;
				break;
		}

		//create the menu contents
		menuContainer = $("<div></div>")
			.addClass("menu-layout-menu")
			.attr("id", layoutSelector.getId());
		layoutClasses = ['view-layout1', 'view-layout2', 'view-layout3', 'view-layout4', 'view-layout5'];
		columnName = [i18nCore.COLUMN_ONE, i18nCore.COLUMN_TWO, i18nCore.COLUMN_THREE, i18nCore.COLUMN_FOUR, i18nCore.COLUMN_FIVE];
		layoutClasses[initialColCnt - 1] += " view-layout-selected";
		//Apply click events to each col section
		for (var i = 0; i < layoutClasses.length; i++) {
			columnTemplate = TemplateBuilder.buildTemplate(ViewBuilderQOC.templates.columnSelector);
			context = {
				"columnClass": layoutClasses[i],
				"dataCols": i + 1,
				"columnName": columnName[i]
			};
			column = columnTemplate.render(context);
			$(menuContainer)
				.append(column);
		}
		$(menuContainer)
			.on('click', function(e) {
				var dataColAttr = parseInt(e.target.getAttribute('data-cols'), null);
				//Update the selectedClass
				$("#" + layoutSelector.getId() + " .view-layout-selected")
					.removeClass("view-layout-selected");
				$("#" + layoutSelector.getId() + " .view-layout" + dataColAttr)
					.addClass("view-layout-selected");
				//Update the layout
				if (colGroups.length) {
					self.changeQOCLayout(dataColAttr, categoryMean);
				}
			});
		//Return the jQuery object
		return menuContainer;
	});
	return layoutSelector;
};
/**
 * Creates the AlertMessage control and renders the message in the Add Personal Fav Folder  Modal Dialog
 * @param {var} confirmMsg - the i18n message to be displayed in the Modal
 */
ViewBuilderQOC.prototype.createAddPrsnlFavFolderMsg = function(confirmMsg) {

	var alertMessageType = MPageControls.AlertMessage.MessageTypes.INFORMATION;
	var addPrsnlFavFolderMsg = "<span>" + confirmMsg + "</span>";
	var template = MPageControls.getDefaultTemplates()
		.messageBar;
	var addPrsnlFavFolderMsgEle = $("#qocAddFavMsg");
	var control = new MPageControls.AlertMessage(addPrsnlFavFolderMsgEle, template, alertMessageType);
	control.render(addPrsnlFavFolderMsg);

};

/**
 * Shows the loading spinner in the Folder navigation section of modal
 * @param {var} show - boolean to add or remove the spinner
 */
ViewBuilderQOC.prototype.showLoading = function(show) {

	var pageId = "pageMenuAddFavorite1234";
	var prevFolderContent = _g("pgMnuFavFolderContents" + pageId);

	if (!prevFolderContent) {
		return;
	}
	else {
		if (show) {
			prevFolderContent.innerHTML = "";
			prevFolderContent.style.overflowY = "auto";
			Util.Style.acss(prevFolderContent, "noe-preloader-icon");
		}
		else {
			Util.Style.rcss(prevFolderContent, "noe-preloader-icon");
		}
	}
};
/**
 *Creates the OrderVenueGroup control and renders the venue dropdown list.
 */
ViewBuilderQOC.prototype.createVenueDropDown = function() {

	var venue;
	var self = this;
	this.venueList.sort(function(a, b) {
		return a.VENUE_VAL - b.VENUE_VAL;
	});
	var qocModalVenueGrp = new MPageControls.OrderVenueGroup($("#qocAddFavoriteVenueId"), "<div class = 'venue-selected'>" + this.defaultVenueDisp + "</div>", this.venueList, 0);

	// This method would be invoked on selecting one of venues from the venue dropdown
	qocModalVenueGrp.getList()
		.setOnSelect(function(item) {
			if (item.VENUE_VAL === self.currentVenue) {
				return;
			}
			qocModalVenueGrp.setValue("<div class = 'venue-selected'>" + item.VENUE_DISPLAY + "</div>");
			self.currentVenue = item.VENUE_VAL;
			qocModalVenueGrp.getDetailDialog()
				.hide();
			self.showLoading(true);
			self.switchFavFolderVenue("pageMenuAddFavorite1234", item.VENUE_VAL);
		});

};

/**
 *Creates the OrderVenueGroup control and renders the venue dropdown list.
 */
ViewBuilderQOC.prototype.createVenueSelector = function(venueSelectorId, tempVenueList) {

	var venue;
	var venueObj;
	var self = this;
	var defaultVenueDisp;
	var defaultVenueVal;
	var venueList = [];

	var sortValues = {
		SORT_VAL_INPATIENT_VENUE : 1,
		SORT_VAL_RX_VENUE : 2,
		SORT_VAL_ALL_VENUE : 3
	};

	var tempVenueListLength = tempVenueList.length;
	if (tempVenueList && tempVenueListLength) {
		for (var x = 0; x < tempVenueListLength; x++) {
			venue = tempVenueList[x];
			venueObj = {};
			// Set Ambulatory-In-Office value to 1 (mp_get_venue_list returns 3 for ambulatory-in-office venue)
			if(venue.VALUE === 3) {
				venue.VALUE = 1;
			}
			switch(venue.VALUE) {
				// 'All' Venue Type
				case 0:
					venueObj.VENUE_VAL = 0;
					venueObj.SORT_VAL = sortValues.SORT_VAL_ALL_VENUE;

					if(this.getPageVenue() === 0) {
						defaultVenueVal = venue.VALUE;
						defaultVenueDisp = venue.DISPLAY;
					}
					break;

				// Inpatient/Ambulatory-in-office
				case 1:
					//set currently selected menu option
					venueObj.VENUE_VAL = 1;
					venueObj.SORT_VAL = sortValues.SORT_VAL_INPATIENT_VENUE;

					if(this.getPageVenue() === 1) {
						defaultVenueVal = venue.VALUE;
						defaultVenueDisp = venue.DISPLAY;
					}
					break;

				// Discharge Meds as Rx/Ambulatory Meds as Rx
				case 2:
					venueObj.VENUE_VAL = 2;
					venueObj.SORT_VAL = sortValues.SORT_VAL_RX_VENUE;

					if(this.getPageVenue() === 2) {
						defaultVenueVal = venue.VALUE;
						defaultVenueDisp = venue.DISPLAY;
					}
					break;
			}			
			venueObj.VENUE_DISPLAY = venue.DISPLAY;
			venueList.push(venueObj);
		}
	}
	venueList.sort(function(a, b) {
		return a.SORT_VAL - b.SORT_VAL;
	});
	var qocModalVenueGrp = new MPageControls.OrderVenueGroup($("#" + venueSelectorId), "<div class = 'venue-selected'>" + defaultVenueDisp + "</div>", venueList, 0);

	// This method would be invoked on selecting one of venues from the venue dropdown
	qocModalVenueGrp.getList()
		.setOnSelect(function(item) {
			var venueSelectionTimer = MP_Util.CreateTimer("CAP:MPG:QUICK_ORDERS.VENUE_SELECTION");
			if (venueSelectionTimer) {
				venueSelectionTimer.Start();
				venueSelectionTimer.Stop();
			}
			qocModalVenueGrp.setValue("<div class = 'venue-selected'>" + item.VENUE_DISPLAY + "</div>");
			self.setPageVenue(item.VENUE_VAL);
			qocModalVenueGrp.getDetailDialog()
				.hide();
			var venueObj = {
				VALUE: item.VENUE_VAL,
				DISPLAY: item.VENUE_DISPLAY
			};
			CERN_EventListener.fireEvent(null, self, EventListener.EVENT_QOC_VIEW_VENUE_CHANGED, venueObj);
		});

	// Set the width of the venue selector drop down to fit the longest string contained
	var detail = qocModalVenueGrp.getDetailDialog();
	var element = qocModalVenueGrp.getElement();
	// Show and get longest width of contents
	detail.show();
	var contents = qocModalVenueGrp.getContents();
	contents.width('auto');
	contents.css({
		'overflow': 'hidden'
	}, {
		'white-space': 'no-wrap'
	});
	var contentWidth = contents.width();
	var iconWidth = 20;
	contents.width(contentWidth + iconWidth);
	element.width(contentWidth + iconWidth);
	// remove drop down contents
	detail.hide();
};

/**
 * Creates the modal window to choose a favorite folder to add
 * @param {JSON object} recordData - the data returned from a database call
 * @param {JSON object} criterion - criterion data for the page
 * @return {JSON object} The folder data
 */
ViewBuilderQOC.prototype.RenderFavFolder = function(recordData, criterion, confirmMsg, qocModalDialogObj) {
	var noeFavArr = [];
	var venueTypeList = [];
	var self = this;
	var venue = null;
	var venueObj = {};
	this.currentVenue = 0;
	this.venueList = [];
	if (recordData.STATUS_DATA.STATUS != "F") {
		noeFavArr = recordData.USER_FAV;
		venueTypeList = recordData.VENUE_TYPE_LIST;
	}
	var pageId = "pageMenuAddFavorite1234";
	var favSec = [];
	favSec.push("<div class = 'qoc-add-fav-container'>");
	favSec.push("<div class = 'message-container' id = 'qocAddFavMsg'></div>");
	favSec.push("<div class = 'qoc-add-fav-venue-container' id = 'qocAddFavoriteVenueId'></div>");

	//Basically processing the VenueList object to be used for the venue dropdown.
	if (venueTypeList && !this.venueList.length) {
		for (var x = 0; x < venueTypeList.length; x++) {
			venue = venueTypeList[x];
			venueObj = {};
			if (venue.SOURCE_COMPONENT_LIST[0].VALUE === 2) {
				venueObj.VENUE_VAL = 2;
			}
			else {
				//set currently selected menu option
				venueObj.VENUE_VAL = 1;
				//Setting the default Venue display and value at ViewBuilderQOC level as the display and the venue type will need be set to Inpatient or Ambulatory Meds in office whenever the modal is launched
				//in the same session of the ViewBuilderQOC object.
				this.defaultVenueDisp = venue.DISPLAY;
				//Current venue gets updated everytime we switched the venues, thus is the difference between, defaultVenueVal and currentVenue
				this.defaultVenueVal = 1;
				this.currentVenue = 1;
			}
			venueObj.VENUE_DISPLAY = venue.DISPLAY;
			this.venueList.push(venueObj);
		}
	}
	var noeItem;
	var noeRow;
	var noeType;
	var noeItemArr;
	var personalFavArr = [];
	var personalFavObj = null;
	//DefaultVenue
	var venueType = this.defaultVenueVal;

	var favLength = null;

	if (noeFavArr) {
		favLength = noeFavArr.length;
		if (favLength === 0) {
			favSec.push("<span class='res-none'>", this.i18nCommonOrdersSummary.NO_FAVORITES_FOUND, "</span>");
		}
		else {
			favSec.push("<div id='pgMnuFavFolderPath", pageId, "' class='noe-fav-path hdr'><dl id='pgMnuFolderPath", pageId, "' class='noe-folder-info'><dt>0</dt><dd class='noe-fav-folder'><span id='pgMnuFolderPathRoot", pageId, "'>", noeFavArr[0].SHORT_DESCRIPTION, "</span></dd></dl></div>", "<div id='pgMnuFavFolderContents", pageId, "' class='page-menu-add-favorite-contents'>");
			personalFavObj = this.createQOCPersonalFolderMarkup(noeFavArr, criterion, pageId, venueType);
			favSec.push(personalFavObj.favSecHtml);
			personalFavArr = personalFavObj.personalFavArr;
			this.SetQOCPersonalFavArray(personalFavArr);
		}
	}
	else {
		if (!noeFavArr) {
			var i18nCore = i18n.discernabu;
			var errMsg = [];
			errMsg.push("<span class='res-none'>", i18n.ERROR_RETREIVING_DATA, "</span>");
			favSec = favSec.concat(errMsg);
		}
	}
	favSec.push("</div>");
	var favSecHTML = favSec.join("");
	var actionableContDiv = _g(qocModalDialogObj.getBodyElementId());
	if (actionableContDiv) {
		actionableContDiv.innerHTML = favSecHTML;
	}
	qocModalDialogObj.setBodyHTML(actionableContDiv.innerHTML);
	var getClickHandlerFunction = function(criterion, pageId, venueType, QOCView) {

		return function(event) {
			//If the target does not contain a class list look to the parent.
			var targetClass = null;
			var eTarget = $(event.target)
				.attr('class');
			var eParent = $(event.target)
				.parent()
				.attr('class');
			if (eTarget) {
				targetClass = eTarget.split(' ')[0];
			}
			else if (eParent) {
				targetClass = eParent.split(' ')[0];
			}
			switch (targetClass) {
				case "noe-name":
					QOCView.displayNextFavFolder(pageId, self.currentVenue, event);
					break;
				case "qoc-folder-sel-button":
					QOCView.addFavoriteComponent(event);
					break;
				case "noe-fav-folder":
					QOCView.displaySelectedFavFolder(pageId, event, self.currentVenue);
					break;
			}
			event.stopPropagation();
		};
	};

	$("#" + qocModalDialogObj.getBodyElementId())
		.on("click", "div", getClickHandlerFunction(criterion, pageId, venueType, this));
};

/**
 * This function changes the layout of the current view with a differnt number of columns
 * @param {Number} newColCnt Number of columns of the new layout
 * @param {String} catMean Category Mean of the current view
 */
ViewBuilderQOC.prototype.changeQOCLayout = function(newColCnt, catMean) {
	var viewpointState = (catMean) ? "#" + catMean + " " : "";
	var colClasses = ["one-col", "two-col", "three-col", "four-col", "five-col"];
	var curColCnt = 0;
	var comps = null;
	var curColGroupClass = $(viewpointState + '.col-group:last')
		.attr('class')
		.replace("col-group ", "");

	switch (curColGroupClass) {
		case "five-col":
			curColCnt = 5;
			break;
		case "four-col":
			curColCnt = 4;
			break;
		case "three-col":
			curColCnt = 3;
			break;
		case "two-col":
			curColCnt = 2;
			break;
		case "one-col":
			curColCnt = 1;
			break;
	}

	if (newColCnt < curColCnt) { //removing columns
		if (newColCnt === 1) {
			comps = $(viewpointState + '.col-group:last .section')
				.not(viewpointState + '.col1 .section');
			$(viewpointState + '.col-group:last .col1')
				.append(comps);
			$(viewpointState + '.col-group:last .col2')
				.remove();
			$(viewpointState + '.col-group:last .col3')
				.remove();
			$(viewpointState + '.col-group:last .col4')
				.remove();
			$(viewpointState + '.col-group:last .col5')
				.remove();
		}
		else if (newColCnt === 2) {
			comps = $(viewpointState + '.col-group:last .section')
				.not(viewpointState + '.col1 .section')
				.not(viewpointState + '.col2 .section');
			$(viewpointState + '.col-group:last .col2')
				.append(comps);
			$(viewpointState + '.col-group:last .col3')
				.remove();
			$(viewpointState + '.col-group:last .col4')
				.remove();
			$(viewpointState + '.col-group:last .col5')
				.remove();
		}
		else if (newColCnt === 3) {
			comps = $(viewpointState + '.col-group:last .section')
				.not(viewpointState + '.col1 .section')
				.not(viewpointState + '.col2 .section')
				.not(viewpointState + '.col3 .section');
			$(viewpointState + '.col-group:last .col3')
				.append(comps);
			$(viewpointState + '.col-group:last .col4')
				.remove();
			$(viewpointState + '.col-group:last .col5')
				.remove();
		}
		else if (newColCnt === 4) {
			comps = $(viewpointState + '.col-group:last .col5 .section');
			$(viewpointState + '.col-group:last .col4')
				.append(comps);
			$(viewpointState + '.col-group:last .col5')
				.remove();
		}
		//save new layout
		setTimeout(function() {
			MP_Core.AppUserPreferenceManager.SaveCompPreferences(null, "", null, true, catMean);
		}, 0);

		$(viewpointState + '.col-group:last')
			.attr('class', 'col-group ' + colClasses[newColCnt - 1]);
	}
	else if (newColCnt > curColCnt) { //adding columns
		if ((newColCnt - curColCnt) === 1) {
			$(viewpointState + '.col-outer1:last')
				.append('<div class="col' + newColCnt + '"></div>');
		}
		else if ((newColCnt - curColCnt) === 2) {
			$(viewpointState + '.col-outer1:last')
				.append('<div class="col' + (newColCnt - 1) + '"></div><div class="col' + newColCnt + '"></div>');
		}
		else if ((newColCnt - curColCnt) === 3) {
			$(viewpointState + '.col-outer1:last')
				.append('<div class="col' + (newColCnt - 2) + '"></div><div class="col' + (newColCnt - 1) + '"></div><div class="col' + newColCnt + '"></div>');
		}
		else if ((newColCnt - curColCnt) === 4) {
			$(viewpointState + '.col-outer1:last')
				.append('<div class="col2"></div><div class="col3"></div><div class="col4"></div><div class="col5"></div>');
		}

		$(viewpointState + '.col-group:last')
			.attr('class', 'col-group ' + colClasses[newColCnt - 1]);
		this.initDragAndDrop(catMean);
	}
};

/**
 * Function that initiates the drag and drop of  components within the columns.  Implemented based upon the mpage-core level functionality
 * @param {String} categoryMeaning category mean of the current view
 */
ViewBuilderQOC.prototype.initDragAndDrop = function(categoryMeaning) {
	var vpParent = "#" + categoryMeaning + " ";
	var compSelectorStr = vpParent + " .col-outer1:last .col1," + vpParent + " .col-outer1:last .col2," + vpParent + " .col-outer1:last .col3," + vpParent + " .col-outer1:last .col4," + vpParent + " .col-outer1:last .col5";
	var components = $(compSelectorStr);

	var self = this;
	components.sortable({
		connectWith: compSelectorStr + " ",
		items: " .section",
		zIndex: 1005,
		appendTo: "body",
		handle: "h2",
		over: function(event, ui) {
			if (ui.sender && $(this).attr("class") !== ui.sender.attr("class")) {
				$(this).css("z-index", "1");
			}
		},
		start: function(event, ui) {
			$(this)
				.css("z-index", "2");
			ui.item.css("z-index", "2");
		},
		stop: function(event, ui) {
			ui.item.css("z-index", "1");
			$(this)
				.css("z-index", "1");
			if (ui.sender) {
				ui.sender.css("z-index", "1");
			}
		},
		update: function(event, ui) {
			//only write preference when the destination DOM is updated
			if (this === ui.item.parent()[0]) {
				setTimeout(function() {
					MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(self.getComponents(), true, true);
				}, 0);
			}
		}
	});
	// //Determine if the drag and drop should be active or not
	if ($(vpParent)
		.hasClass("qoc-dnd-enabled")) {
		components.css("padding-bottom", "100px")
			.sortable("enable");
		$(vpParent + " .col-outer1:last .sec-hd")
			.css("cursor", "move");
	}
	else {
		components.css("padding-bottom", "100px")
			.sortable("disable");
		$(vpParent + " .col-outer1:last .sec-hd")
			.css("cursor", "auto");
	}
};


/**
 * Function that returns a MenuSelection object used for the drag and drop functionality. Implemented based upon the mpage-core level functionality.
 * @this {ViewBuilderQOC}
 * @return {MenuSelection}
 */
ViewBuilderQOC.prototype.loadDragAndDropMenuItem = function() {
	var categoryMean = this.getCategoryMean();
	var activeView = $("#" + categoryMean);
	var parentEleId = "";

	if (activeView.length) {
		parentEleId = "#" + categoryMean;
	}
	else {
		activeView = $(document.body);
	}

	var self = this;
	var dnd = new MenuSelection("dragNDrop" + categoryMean);
	dnd.setLabel(i18n.DRAG_AND_DROP);
	dnd.setCloseOnClick(false);
	dnd.setClickFunction(function() {
		if (dnd.isSelected()) {
			//Add the Drag and Drop css class from the view container
			$(activeView)
				.addClass("qoc-dnd-enabled");

			//initialize Drag and Drop if not initialized yet. Otherwise simply enabled it. 
			if (self.m_dragNDropInitialized) {
				// re-enables sortable
				$(parentEleId + " .col-outer1:last .col1," + parentEleId + " .col-outer1:last .col2," + parentEleId + " .col-outer1:last .col3," + parentEleId + " .col-outer1:last .col4," + parentEleId + " .col-outer1:last .col5")
					.sortable("enable");
				// update the cursor back to the move icon
				$(parentEleId + " .col-outer1:last .sec-hd")
					.css("cursor", "move");
			}
			else {
				//drag and drop is enabled as part of the initialization
				self.initDragAndDrop(categoryMean);
				//set the flag to true so it won't initialize again when the menu item is clicked
				self.m_dragNDropInitialized = true;
			}
		}
		else {
			//Remove the Drag and Drop css class from the view container
			$(activeView)
				.removeClass("qoc-dnd-enabled");

			//Disables Drag and Drop in the View
			$(parentEleId + " .col-outer1:last .col1," + parentEleId + " .col-outer1:last .col2," + parentEleId + " .col-outer1:last .col3," + parentEleId + " .col-outer1:last .col4," + parentEleId + " .col-outer1:last .col5")
				.sortable("disable");
			//Update the cursor to switch from the move icon to auto
			$(parentEleId + " .col-outer1:last .sec-hd")
				.css("cursor", "auto");
		}
	});
	return dnd;
};

/**
 * Change the venue of the available folders in the add favorite modal
 * @param {string} pageId - unique ID of the MPage
 * @param {Object} event - the event object that precipitated this function
 * @return {JSON object} The folder data
 */
ViewBuilderQOC.prototype.switchFavFolderVenue = function(pageId, venueVal) {

	var folderPathObj = _g("pgMnuFavFolderPath" + pageId);
	var folderPath = Util.Style.g("noe-folder-info", folderPathObj, "DL");
	var curList = folderPath[0];
	var curItem = _gbt("DT", curList);
	var curItemData = _gbt("DD", curList);
	var locatedIdIndex = 0;
	var criterion = this.getCriterion();
	var self = this;
	for (var i = curItem.length; i--;) {
		if (i !== 0) {
			Util.de(curItem[i]);
		}
	}
	for (var i = curItemData.length; i--;) {
		if (i !== 0) {
			Util.de(curItemData[i]);
		}
	}
	this.isFolderReqAsync = true;
	this.getFavFolders("0", venueVal, function(reply) {
		var recordData = reply.getResponse();
		self.LoadFavFolder(recordData, pageId, criterion, venueVal);
		return;
	});


};

/**
 * Navigate to the next child folder
 * @param {string} pageId - unique ID of the MPage
 * @param {int} venueType - venue of the folder
 * @param {Object} event - the event object that precipitated this function
 */
ViewBuilderQOC.prototype.displayNextFavFolder = function(pageId, venueType, event) {
	var favObj;
	var folderLen;
	var folderIdx;
	var folderName;
	var folderId;
	var personalFavArr = this.GetQOCPersonalFavArray();
	var criterion = this.getCriterion();
	var self = this;
	if (personalFavArr) {
		folderLen = personalFavArr.length;
		folderId = Util.gp(event.target)
			.getAttribute("data-folder-id");
		while (folderLen--) {
			favObj = personalFavArr[folderLen];
			if (favObj.Id === folderId) {
				folderName = favObj.folderName;
				break;
			}
		}
	}

	var curNameDisp = favObj.folderName;

	//grab all folder names and ids in DOM of component
	var folderPathObj = _g("pgMnuFavFolderPath" + pageId);
	var folderPath = Util.Style.g("noe-folder-info", folderPathObj, "DL");
	var curList = folderPath[0];
	var curItem = _gbt("DT", curList);
	var curItemData = _gbt("DD", curList);
	var lastId = curItem[curItem.length - 1];
	var lastFolder = curItemData[curItemData.length - 1];

	var pathLength = curItemData.length;
	var separator = "...";

	if (pathLength !== 1) {
		separator = ">";
	}

	if (pathLength > 4) {
		for (var j = pathLength - 1; j--;) {
			if (j > 1) {
				if (curItem[j].innerHTML == "-1") {
					Util.Style.acss(curItemData[j], "hidden");
					Util.Style.rcss(curItemData[j], "noe-fav-separator");
				}
				else {
					Util.Style.acss(curItemData[j], "hidden");
					Util.Style.rcss(curItemData[j], "noe-fav-folder");
				}
			}
		}
	}

	//create four new nodes for the folder id, folder name, separator id, and separator
	var newFolderId = Util.cep("DT", {
		"className": "hidden",
		"innerHTML": folderId
	});
	var newFolder = Util.cep("DD", {
		"className": "noe-fav-folder",
		"innerHTML": "<span>" + curNameDisp + "</span>"
	});
	var newSeparatorId = Util.cep("DT", {
		"className": "hidden",
		"innerHTML": "-1"
	});
	var newSeparator = Util.cep("DD", {
		"className": "noe-fav-separator",
		"innerHTML": "<span>" + separator + "</span>"
	});
	//add four new nodes to DOM
	Util.ia(newSeparatorId, lastFolder);
	Util.ia(newSeparator, newSeparatorId);
	Util.ia(newFolderId, newSeparator);
	Util.ia(newFolder, newFolderId);

	this.showLoading(true);
	this.isFolderReqAsync = true;
	this.getFavFolders(folderId, venueType, function(reply) {
		var recordData = reply.getResponse();
		self.LoadFavFolder(recordData, pageId, criterion, venueType);
	});
};

/**
 * Load data about a single favorite folder
 * @param {JSON object} criterion - page's criterion data
 * @param {string} pageId - unique ID of the MPage
 * @param {int} venueType - venue of the folder
 * @param {JSON Object} recordData - the data returned from the database call
 * @return {JSON object} The folder data
 */
ViewBuilderQOC.prototype.LoadFavFolder = function(recordData, pageId, criterion, venueType) {
	var noeFavArr = null;
	if (recordData.STATUS_DATA.STATUS != "F") {
		noeFavArr = recordData.USER_FAV;
	}
	var prevFolderContent = _g("pgMnuFavFolderContents" + pageId);
	if (prevFolderContent && noeFavArr) {
		this.showLoading(false);
		var favSec = ["<div>"];
		var favCnt = 0;
		var favChildFavFolder = [];
		var favSecondaryFavFolder = [];
		var personalFavArr = [];
		var personalFavObj = null;
		//grab all folder names and ids in DOM of component
		var folderPathObj = _g("pgMnuFavFolderPath" + pageId);
		var folderPath = Util.Style.g("noe-folder-info", folderPathObj, "DL");
		var curList = folderPath[0];
		var curItem = _gbt("DT", curList);

		personalFavObj = this.createQOCPersonalFolderMarkup(noeFavArr, criterion, pageId, venueType);
		favSec.push(personalFavObj.favSecHtml);
		personalFavArr = personalFavObj.personalFavArr;
		this.SetQOCPersonalFavArray(personalFavArr);

		favSec.push("</div>");
		var folderHTML = favSec.join("");
		prevFolderContent.innerHTML = folderHTML;
	}
	else
	if (prevFolderContent && !noeFavArr) {
		this.showLoading(false);
		var i18nCore = i18n.discernabu;
		var errMsg = [];
		errMsg.push("<span class='res-none'>", i18n.ERROR_RETREIVING_DATA, "</span>");
		folderHTML = errMsg.join("");
		prevFolderContent.innerHTML = folderHTML;
	}
};
/**
 * Display a selected favorite folder
 * @param {string} pageId - unique ID of the MPage
 * @param {Object} event - the event object that precipitated this function
 */
ViewBuilderQOC.prototype.displaySelectedFavFolder = function(pageId, event, currentVenue) {
	var criterion = this.getCriterion();
	var i, l;
	var folder = event.target || event.srcElement;
	var folderId = Util.gps(Util.gp(folder))
		.innerHTML;

	var folderPathObj = _g("pgMnuFavFolderPath" + pageId);
	var folderPath = Util.Style.g("noe-folder-info", folderPathObj, "DL");
	var curList = folderPath[0];
	var curItem = _gbt("DT", curList);
	var curItemData = _gbt("DD", curList);
	var self = this;

	//find index of folder id
	var locatedIdIndex = null;
	for (i = 0, l = curItem.length; i < l; i++) {
		if (curItem[i].innerHTML == folderId) {
			locatedIdIndex = i;
		}
	}

	//delete all folder names and ids that are after selected folder
	if (locatedIdIndex !== null) {
		for (var i = curItem.length; i--;) {
			var deleteId = curItem[i];
			if (locatedIdIndex < i) {
				Util.de(deleteId);
			}
		}
		for (var i = curItemData.length; i--;) {
			var deleteFolder = curItemData[i];
			if (locatedIdIndex < i) {
				Util.de(deleteFolder);
			}
		}
		if (locatedIdIndex > 3) {

			Util.Style.acss(curItemData[locatedIdIndex - 1], "noe-fav-separator");
			Util.Style.rcss(curItemData[locatedIdIndex - 1], "hidden");
			Util.Style.acss(curItemData[locatedIdIndex - 2], "noe-fav-folder");
			Util.Style.rcss(curItemData[locatedIdIndex - 2], "hidden");
		}

		this.showLoading(true);
		this.getFavFolders(folderId, currentVenue, function(reply) {
			var recordData = reply.getResponse();
			self.LoadFavFolder(recordData, pageId, criterion, currentVenue);
		});
	}

};

/**
 * Add a personal Favorite component to the MPage View
 * @param {Object} event - the event object that precipitated this function
 */
ViewBuilderQOC.prototype.addFavoriteComponent = function(event) {
	var criterion = this.getCriterion();
	var folderId = Util.gp(event.target).getAttribute("data-folder-id");
	var ordSelCompId = folderId + criterion.category_mean;
	var ordSelFound = false;
	var idArray = this.getComponentIds();
	var idLen = idArray.length;
	for (var x = idLen; x--;) {
		if (idArray[x] == folderId) {
			ordSelFound = true;
			break;
		}
	}
	if (!ordSelFound) {
		var folderName = $(event.target)
			.parent()
			.find(".noe-name")
			.text();
		var ordSelCompJSON = {};
		var col1Div = {};

		var viewDiv = document.getElementById(criterion.category_mean);
		col1Div = $(viewDiv).find(".col1")[0];

		var col1Count = $(col1Div).find(".section").length; //the current number of components in the first column
		var ordSelObj = {};
		var summaryRenderStrat = new SummaryRenderStrategy();
		var prnslFolderPrefObj = {
			subFolderExpanded: {},
			compLabel: escape(folderName), //ensure that the label is available when the user returns to the page, and that special characters are considered
			compFolderId: folderId
		};
		MP_ModalDialog.closeModalDialog("qocAddPersonalFavFolderModal");
		//reset overflow
		$("html")
			.css("overflow", "auto");
		//Set the viewpoint indicator to true if this is a viewpoint, otherwise false
		//create JSON object for component
		ordSelCompJSON = this.createPersonalFolderJSONObj(folderId, folderName, col1Count + 1);
		ordSelObj = new OrderSelectionComponentO2(criterion);
		ordSelObj.initializeComponent(criterion);
		//Set Component Preferences based on bedrock settings and user preferences
		ordSelObj.loadComponentSettings(ordSelCompJSON);
		//Load the display filters of the component
		ordSelObj.loadDisplayFilters();
		//create the component menu
		ordSelObj.createMainMenu();
		//Let the component handle any preprocessing actions that may need to take place before it will be rendered
		ordSelObj.preProcessing();
		//Ensure the venue of the personal favorite is the current page-level venue
		ordSelObj.setVenue(this.getPageVenue());
		ordSelObj.setIsPersonalFavorite(1);
		ordSelObj.setPreferencesObj(prnslFolderPrefObj);
		this.addComponent(ordSelObj);
		this.addComponentId(ordSelObj.getReportId());
		CERN_MPageComponents.push(ordSelObj);
		ordSelObj.setRenderStrategy(summaryRenderStrat);
		$(col1Div)
			.append(ordSelObj.getRenderStrategy()
				.createComponentShell()); //add to the bottom of the first column
		var ordSelObjArr = [];
		ordSelObjArr.push(ordSelObj);
		//setup expand/collapse
		var compDiv = document.getElementById(ordSelObj.getStyles()
			.getId());
		var toggleTarget = Util.Style.g("sec-hd-tgl", compDiv, "span");
		Util.addEvent(toggleTarget, "click", MP_Util.Doc.ExpandCollapse);
		//setup filters and menus
		MP_Util.Doc.SetupCompFilters(ordSelObjArr);
		MP_Util.Doc.CreateCompMenus(ordSelObjArr, false);
		ordSelObj.retrieveComponentData();
		ordSelObj.addRemoveMenuOption();
		this.incrementFavCount();
		if (this.getPersonalFavoriteCount() === 15) {
			this.disableAddFavoriteMenu();
		}
		MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(ordSelObj, true);
	}
	else {
		//using a simple alert to ensure that the favorite selection AlertConfirm interface remains after the user confirms the message
		alert(this.i18nCommonOrdersSummary.DUPLICATE_FAVORITE);
	}
};

/**
 * Creates the HTML for a single folder in the favorite modal
 * @param {Object} noeFavArr
 * @param {Object} criterion
 * @param {Object} pageId
 * @param {Object} venueType
 * @return {Object} object that contains the personal favorite folder data and related HTML
 */
ViewBuilderQOC.prototype.createQOCPersonalFolderMarkup = function(noeFavArr, criterion, pageId, venueType) {
	var favSec = ["<div>"];
	var favCnt = 0;
	var favChildFavFolder = [];
	var favSecondaryFavFolder = [];
	var folderName = "";
	var personalFavArr = [];
	var personalFavObj = {};
	var noeFavsObj = null;
	var noeItem = null;
	var noeItemArr = null;
	var noeRow = null;
	var noeType = null;
	var personalFavFolder = null;
	var noei18n = i18n.discernabu.noe_o1;

	personalFavObj.personalFavArr = [];
	personalFavObj.favSecHtml = null;

	//grab all folder names and ids in DOM of component
	for (var i = 0, fl = noeFavArr.length; i < fl; i++) {
		noeFavsObj = noeFavArr[i];
		//account for multiple favorite folders per venue
		if (i === 0) {
			//Create the rest of the folders/orders/caresets/PowerPlans
			noeItemArr = noeFavsObj.CHILD_LIST;
			for (var j = 0, k = noeItemArr.length; j < k; j++) {
				noeItem = noeItemArr[j];
				noeRow = [];
				noeType = noeItem.LIST_TYPE;
				if (noeType === 1) { //Favorite Folder
					personalFavFolder = {};
					favCnt++;
					personalFavFolder.Id = noeItem.CHILD_ALT_SEL_CAT_ID.toString();
					personalFavFolder.folderName = noeItem.SYNONYM;
					personalFavArr.push(personalFavFolder);
					noeRow.push("<h3 class='info-hd'>", noei18n.ORDER_FAVORITE, "</h3><dl class='noe-info page-menu-add-favorite-folder-dl' data-folder-id=", noeItem.CHILD_ALT_SEL_CAT_ID, "><button class='qoc-folder-sel-button' onmouseout='CERN_NEW_ORDER_ENTRY_O1.MouseOutButton(this)' onmouseover='CERN_NEW_ORDER_ENTRY_O1.MouseOverButton(this)'>", i18n.SELECT, "</button><span class='noe-fav-folder-icon'>&nbsp;</span><dt>", noei18n.ORDER_NAME, ":</dt><dd class='noe-name page-menu-add-favorite-folder'>", noeItem.SYNONYM, "</dd><dt>", noei18n.ORDER_DISPLAY_LINE, ":</dt><dd class='noe-disp'>", noeItem.SENTENCE, "</dd><dt>", noei18n.ORDER_PARAMETERS, ":</dt><dd class='det-hd'>", noeItem.SYN_ID, "|", venueType, "|", noeItem.SENT_ID, "</dd><dt>", noei18n.ORDER_SET, ":</dt><dd class='det-hd'>", noeItem.ORDERABLE_TYPE_FLAG, "</dd></dl>");
					favChildFavFolder = favChildFavFolder.concat(noeRow);
				}
			}
		}
		else {
			personalFavFolder = {};
			favCnt++;
			if (noeFavsObj.LONG_DESCRIPTION_KEY_CAP === "FAVORITES" && (noeFavsObj.SOURCE_COMPONENT_FLAG === 2 || noeFavsObj.SOURCE_COMPONENT_FLAG === 3)) {
				folderName = noei18n.FOLDER_FAV_AMBULATORY.replace("{0}", i);
			}
			else {
				folderName = noeFavsObj.SHORT_DESCRIPTION;
			}
			favSecondaryFavFolder.push("<h3 class='info-hd'>", noei18n.ORDER_FAVORITE, "</h3><dl class='noe-info page-menu-add-favorite-folder-dl' data-folder-id=", noeFavsObj.ALT_SEL_CATEGORY_ID, "><button class='qoc-folder-sel-button' onmouseout='CERN_NEW_ORDER_ENTRY_O1.MouseOutButton(this)' onmouseover='CERN_NEW_ORDER_ENTRY_O1.MouseOverButton(this)'>", i18n.SELECT, "</button><span class='noe-fav-folder-icon'>&nbsp;</span><dt>", noei18n.ORDER_NAME, ":</dt><dd class='noe-name page-menu-add-favorite-folder'>", folderName, "</dd><dt>", noei18n.ORDER_DISPLAY_LINE, ":</dt><dd class='noe-disp'></dd><dt>", noei18n.ORDER_PARAMETERS, ":</dt><dd class='det-hd'>0|", venueType, "|0</dd><dt>", noei18n.ORDER_SET, ":</dt><dd class='det-hd'>", noeFavsObj.ORDERABLE_TYPE_FLAG, "</dd></dl>");
			personalFavFolder.Id = noeFavsObj.ALT_SEL_CATEGORY_ID.toString();
			personalFavFolder.folderName = folderName;
			personalFavArr.push(personalFavFolder);
		}
	}
	if (!favCnt) {
		favSec.push("<span class='res-none'>", (noeFavArr) ? noei18n.NO_FAVORITES_FOUND : i18n.ERROR_RETREIVING_DATA, "</span>");
	}
	else {
		//add items in sorted order
		favSec = favSec.concat(favChildFavFolder, favSecondaryFavFolder);
	}
	favSec.push("</div>");
	personalFavObj.personalFavArr = personalFavArr;
	personalFavObj.favSecHtml = favSec.join("");

	return personalFavObj;
};
/**
 * Set personalFavArray attribute
 * @param {Object} arr
 */
ViewBuilderQOC.prototype.SetQOCPersonalFavArray = function(arr) {
	this.personalFavArray = arr;
};
/**
 * Return stored personal favorite array
 * @return {Array} array of favorite folders
 */
ViewBuilderQOC.prototype.GetQOCPersonalFavArray = function() {
	return (this.personalFavArray);
};

/**
 * Handle removal of a
 * @param {object} event - event data
 * @param {object} compObj - the component being removed
 */
ViewBuilderQOC.prototype.personalFolderRemoval = function(event, compObj) {
	var component = null;
	var componentId = "";
	var compId = compObj.getStyles()
		.getId();
	if (compObj.getCriterion()
		.category_mean === this.getCategoryMean()) {
		if (this.decrementFavCount()) {
			var componentArr = this.getComponents();
			var componentCnt = componentArr.length;
			for (var x = componentCnt; x--;) {
				component = componentArr[x];
				if (component.getStyles()
					.getId() === compId) {
					componentArr.splice(x, 1);
					break;
				}
			}
			componentArr = CERN_MPageComponents;
			componentCnt = componentArr.length;
			for (var x = componentCnt; x--;) {
				component = componentArr[x];
				if (component.getStyles()
					.getId() === compId) {
					componentArr.splice(x, 1);
					break;
				}
			}
			componentArr = this.getComponentIds();
			componentCnt = componentArr.length;
			for (var x = componentCnt; x--;) {
				componentId = componentArr[x];
				if (componentId === compObj.getPreferencesObj()
					.compFolderId) {
					componentArr.splice(x, 1);
					break;
				}
			}
			var pageMenuArray = MP_MenuManager.getMenuObject("pageMenu" + this.getCategoryMean())
				.getMenuItemArray();
			var mLen = pageMenuArray.length;
			for (var i = mLen; i--;) {
				if (pageMenuArray[i].getId() == "addFolder" + this.getCategoryMean()) {
					pageMenuArray[i].setIsDisabled(false);
					break;
				}
			}
		}
	}
};

/**
 * Create a JSON object for a personal favorite folder
 * @param {double} folderId - the folder id for the personal favorite folder
 * @param {string} folderNm - the name of the folder
 * @param {int} rowCount - the place in the first column where the component would reside
 * @return {JSON Object} a JSON object representing the dynamic order selection component.
 */
ViewBuilderQOC.prototype.createPersonalFolderJSONObj = function(folderId, folderNm, rowCount) {
	var tempJSON = {};
	var prsnlOrdSelCnt = 15 + this.getPersonalFavoriteCount();
	tempJSON = {
		"R_ID": folderId,
		"F_ID": folderId + this.getCategoryMean(),
		"R_MN": "MP_VB_QOC_ORD_SEL_" + prsnlOrdSelCnt, //hijack existing filter mapping object
		"F_MN": "ORD_SEL_PRSNL", //hijack existing filter mapping object
		"LBL": folderNm,
		"LNK": "",
		"G_SQ": 1,
		"R_SQ": rowCount,
		"C_SQ": 1,
		"EXP": 1,
		"SCR_NM": 0,
		"SCR_EN": 0,
		"PLS_AD": 0,
		"LB_UNT": 0,
		"LB_TYP": 0,
		"SCP": 0,
		"DT_DSP": 0,
		"THM": "",
		"TS": 1,
		"FILT": [{
			"F_ID": folderId,
			"F_MN": "ORD_SEL_ORD_FOLDER_" + prsnlOrdSelCnt, //hijack existing filter mapping object
			"FC_MN": "ORDER_FOLDER",
			"VALS": [{
				"PE_ID": folderId,
				"PE_NM": "ALT_SEL_CAT",
				"CDF_MN": "",
				"G_SQ": 0,
				"V_SQ": 0,
				"FTXT": "",
				"V_TYP": 0,
				"Q_FLG": 0
			}]
		}]
	};
	return tempJSON;
};

/**
 * Disable favorites menu
 */
ViewBuilderQOC.prototype.disableAddFavoriteMenu = function() {
	//disable Add Folder option
	var pageMenu = MP_MenuManager.getMenuObject("pageMenu" + this.getCategoryMean());
	var pageMenuArray = pageMenu.getMenuItemArray();
	var pageMenuLen = pageMenuArray.length;
	var menuId = 'addFolder' + this.getCategoryMean();
	for (var x = pageMenuLen; x--;) {
		if (pageMenuArray[x].getId() === menuId) {
			pageMenuArray[x].setIsDisabled(true);
			break;
		}
	}
};

/*
 * Retrieves the Venue Type List for this encounter
 * @return {Array} Array of Venue Type objects containing a venue VALUE and DISPLAY
 */
ViewBuilderQOC.prototype.retrieveVenueList = function() {
	var component = null;
	var sendAr = [];
	var venueList = [];
	var self = this;
	var returnVenueData = function(input) {
		var status = input.getStatus();
		if (status === "S"){
			var response = input.getResponse();
			venueList = response.VENUE_TYPE_LIST;

			// Add 'All' Venue option
			var venueObj = {
				VALUE: 0,
				DISPLAY: self.i18nCommonOrdersSummary.ALL_VENUE
			};
			venueList.push(venueObj);

			/*
				Set page level default venue based on the value of encounter venue flag(Order Encounter Group)
					1. Inpatient/Acute Care - Use the Inpatient Default Venue Filter
					2. Outpatient/Ambulatory - Use the Outpatient Default Venue Filter
			*/
			var orderEncounterGroup = response.ENCNTR_VENUE_FLAG;
			
			switch(orderEncounterGroup) {
				case 1:
					self.setPageVenue(self.getInpatientDefaultVenue());
					break;
				case 2:
					self.setPageVenue(self.getOutpatientDefaultVenue());
					break;
			}

			// Set default venue for all order selection components in the QOC mpage
			var componentArr = self.getComponents();
			var componentCnt = componentArr.length;
			for (var x = componentCnt; x--;) {
				component = componentArr[x];
				if (component instanceof OrderSelectionComponentO2) {
					switch(orderEncounterGroup){
						case 1:
							component.setVenue(self.getInpatientDefaultVenue());	
							break;
						case 2:
							component.setVenue(self.getOutpatientDefaultVenue());	
							break;
					}
				}
			}
		}
		// else (status is "F" or "Z") return empty venueList 
		return venueList;
	};
	var venueRequest = new MP_Core.ScriptRequest();
	venueRequest.setProgramName("mp_get_venue_list");
	venueRequest.setAsync(false);
	var criterion = this.getCriterion();
	sendAr = ["^MINE^", criterion.encntr_id + ".0"];
	venueRequest.setParameters(sendAr);
	MP_Core.XmlStandardRequest(null, venueRequest, returnVenueData);
	return venueList;
};


/**
 * This is implementation of the MPageView's renderView method. This is essentially calling the initDragAndDrop method instead of
 * the initDragAndDrop method in order to support the drag and drop functionality for all of the five columns.
 * @this {ViewBuilderQOC}
 * @return {boolean} True if the page was rendered successfully, false otherwise
 */
ViewBuilderQOC.prototype.renderView = function() {
	var timerRenderMPage = MP_Util.CreateTimer("ENG:MPG.MPageView - renderMPage", this.getCategoryMean());
	var component = null;
	var compCnt = 0;
	var componentList = null;
	var x = 0;
	var groups = [];
	var group = null;
	var collapsedComponents = [];
	var numberRows = 0;
	var numberGroups = 0;
	var venueSelectorHtml = null;
	var venueSelector = null;
	var venueErrorElement = null;

	try {
		
		//Check to see if this view is even valid in the current context.
		if(!this.isContextValid()){
			//The current context is not valid for this view so we need to show a context error message
			this.displayInvalidContextMessage();
			return;
		}
		
		//Create the aggregate timer object to measure page load time
		var aggregateTimer = this.createAggregateTimer();
		// Mark the timer as started because it is already started either in the driver script or in ViewPoint before the view is initialized. 
		aggregateTimer.markTimerStarted();

		//Store the container, so we can easily access it later
		this.setContainer($("#" + this.getCategoryMean()));
		var viewpointContainer = this.getContainer();
		//Check to see if any component are defined for this MPageView.  Return if there are not any
		componentList = this.getComponents();
		compCnt = componentList.length;
		if (compCnt === 0) {
			throw new Error(i18n.VIEW_SETTINGS_UNAVAILABLE);
		}
		
		// Obtain venue list
		var venueList = this.retrieveVenueList();
		// If venue list is returned successfully render venue selector
		if (venueList && venueList.length) {
			this.venueSelectorContainerId = 'qocVenueSelectorContainer' + this.getCategoryMean();
			this.venueSelectorId = 'qocVenueSelectDropDown' + this.getCategoryMean();
			venueSelectorHtml = "<div id='" + this.venueSelectorContainerId + "' class='qoc-venue-selector'><div class='qoc-venue-select-container'><span class='qoc-venue-label'>" + this.i18nCommonOrdersSummary.VENUE + ":</span>";
			venueSelectorHtml += "<div class='qoc-add-fav-venue-container qoc-venue-select-dropdown' id='" + this.venueSelectorId + "'></div></div></div>";
			venueSelector = $(venueSelectorHtml);
			viewpointContainer.append(venueSelector);
			this.createVenueSelector(this.venueSelectorId, venueList);
		}
		// display error message if valid venue list is not returned
		else {
			var venueErrorElement = $("<div class='qoc-venue-error-container'>" + "<span class='error-icon-component'>&nbsp</span>" + "<span class='error-text'>" + this.i18nCommonOrdersSummary.VENUE_ERROR_PRIMARY_MESSAGE + " </span><span>" + this.i18nCommonOrdersSummary.VENUE_ERROR_SECONDARY_MESSAGE + " </span>" + "</div>")
				.width('100%');
			$(viewpointContainer)
				.append(venueErrorElement);
		}

		//Render the component shells
		var componentContainer = $("<div class='qoc-component-container' id='qocComponentContainer" + this.getCategoryMean() + "'></div>");
		viewpointContainer.append(componentContainer);
		//Briefly setContainer to componentContainer so that renderComponents attaches components to correct containers
		this.setContainer(componentContainer);
		this.renderComponents(componentList);
		this.setContainer(viewpointContainer);

		viewpointContainer.css('overflow', 'hidden');
		//Get the component list as the group/column list
		componentList = MP_Util.GetComponentArray(componentList);
		//Ensure contents of QOC page are sized correctly
		this.resizeQocPage();
		//Create the page level menu
		this.loadPageMenu();
		
		//Additional page setup
		MP_Util.Doc.AddCustomizeLink(this.getCriterion());
		MP_Util.Doc.SetupExpandCollapse(this.getCategoryMean());
		MP_Util.Doc.SetupCompFilters(this.getComponents());
		MP_Util.Doc.CreateCompMenus(this.getComponents(), false);

		numberGroups = componentList.length;

		window.setTimeout(function() {
			//the number of all displayable components
			var initialComponentCount = 0;
			var i = 0;
			var j = 0;
			var k = 0;
			//Create the correct ordering
			for (i = 0; i < numberGroups; i++) {
				groups[i] = {};
				groups[i].ROWS = [];
				group = componentList[i];
				var numberColumns = group.length;
				//Iterate through the columns of the group
				for (j = 0; j < numberColumns; j++) {
					var column = group[j];
					numberRows = column.length;
					for (k = 0; k < numberRows; k++) {
						component = column[k];
						if (!groups[i].ROWS[k]) {
							groups[i].ROWS[k] = [];
						}
						if (component.isDisplayable() && component.isExpanded() && !component.isLoaded()) {
							groups[i].ROWS[k].push(component);
						}
						else if (component.isDisplayable() && !component.isExpanded() && !component.isLoaded()) {
							collapsedComponents.push(component);
						}
					}
				}
			}
			//Start the data retrieval for expanded components
			for (i = 0; i < numberGroups; i++) {
				group = groups[i];
				numberRows = group.ROWS.length;
				for (j = 0; j < numberRows; j++) {
					var row = group.ROWS[j];
					var numberComponents = row.length;
					for (k = 0; k < numberComponents; k++) {
						component = row[k];
						component.setLoaded(true);

						// register the component in the aggregate timer before data retrieval begins
						aggregateTimer.registerTask(component.getStyles()
							.getId());
						// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
						component.setAggregateTimer(aggregateTimer);
						//count the component because it will be loaded
						initialComponentCount++;
						component.startComponentDataRetrieval();
					}
				}
			}
			//Now start the data retrieval for the collapsed components
			for (i = 0; i < collapsedComponents.length; i++) {
				component = collapsedComponents[i];
				component.setLoaded(true);

				// register the component in the aggregate timer before data retrieval begins
				aggregateTimer.registerTask(component.getStyles()
					.getId());
				// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
				component.setAggregateTimer(aggregateTimer);
				//count the component because it will be loaded
				initialComponentCount++;
				component.startComponentDataRetrieval();
			}

			//add the number of components to meta data
			aggregateTimer.addMetaData("component.count", compCnt);

			//add the number of initially loaded components to meta data (all components are loaded in initial load)
			aggregateTimer.addMetaData("component.initialLoadCount", initialComponentCount);

			// Lock the registration when initial loading components are registered.
			aggregateTimer.lockRegistration();
		}, 0);
		return true;
	}
	catch (err) {
		if (timerRenderMPage) {
			timerRenderMPage.Abort();
			timerRenderMPage = null;
		}
		logger.logJSError(err, null, "common-orders-summary.js", "renderView");
		throw err;
	}
	finally {
		if (timerRenderMPage) {
			timerRenderMPage.Stop();
		}
	}
};

/*
 *This function handles resizing of the venue selector
 */
ViewBuilderQOC.prototype.resizeQocPage = function() {
	var bodyHeight = $('#' + 'vwpBody')
		.height();
	var componentContainer = $('#' + 'qocComponentContainer' + this.getCategoryMean());
	var venueSelectorHeight = 0;
	if (this.venueSelectorContainerId) {
		venueSelectorHeight = $('#' + this.venueSelectorContainerId)
			.outerHeight(true);
	}
	var errorMessageHeight = $('.qoc-venue-error-container')
		.outerHeight(true);
	var componentPadding = parseInt(componentContainer.css('padding-top'), 10);
	componentContainer.height(bodyHeight - venueSelectorHeight - errorMessageHeight - componentPadding);
};

/**
 * This function is used to handle the window.resize events that are fired when the browser window is resized.  The base
 * functionality calls the resizeComponent function for all MPageComponent objects.
 */
ViewBuilderQOC.prototype.resizeView = function() {
	MPageView.prototype.resizeView.call(this, null);
	this.resizeQocPage();
};

ViewBuilderQOC.templates = {
	columnSelector: "<div class ='${columnClass}' data-cols='${dataCols}'>${columnName}</div>"
};

MP_Util.setObjectDefinitionMapping("QOC_STD", ViewBuilderQOC);
var ICUDashboardMPage=function(){logger.logMessage("Rendering ICU Dashboard MPages View");
this.setCategoryMean("MP_ICU_DASHBOARD");
this.setName(i18n.discernabu.ICU_DASHBOARD);
this.setCustomizeEnabled(false);
};
ICUDashboardMPage.prototype=new MPageView();
ICUDashboardMPage.prototype.constructor=MPageView;
ICUDashboardMPage.prototype.loadDragAndDropMenuItem=function(){return null;
};
ICUDashboardMPage.prototype.createLayoutMenu=function(){return null;
};
ReachSummaryMPage = function(){
	var demoReply = "";
	//Log info for debugger
	MP_Util.LogInfo("Rendering Reach Summary MPages View");

	//Set page level information
	this.setCategoryMean("MP_REACH_V5");
	this.setName(i18n.REACH_SUMMARY);
	this.m_xrPrintFlag = false;//used to store XR Printing bedrock filter value,by default set to false.
};
/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
ReachSummaryMPage.prototype = new MPageView();
ReachSummaryMPage.prototype.constructor = MPageView;
/**
 * Gets the XR Printing indicator flag which determines if the Reach MPage is intended to display "Create Report" menu item.
 * @return {Boolean} True if the Reach MPage is intended to display "Create Report" menu item.  False otherwise.
 */
ReachSummaryMPage.prototype.getXRPrintFlag = function() {
	return this.m_xrPrintFlag;
};
/**
 * Sets the flag which determines if the Reach MPage is intended to display "Create Report" menu item.
 * @param value {Boolean}  A flag which determines if the Reach MPage is intended to display "Create Report" menu item.
 */
ReachSummaryMPage.prototype.setXRPrintFlag = function(value) {
	this.m_xrPrintFlag = value;
};
/**
 * Loads the default Reach MPage XR Printing filter mappings.Calls the default MPageView loadFilterMappings function and adds MPage Reach specific settings.
 * object.
 * @this {MPageView}
 * @return null
 */
ReachSummaryMPage.prototype.loadFilterMappings = function(){
	MPageView.prototype.loadFilterMappings.call(this,null);
	//A filter mapping used to determine if Reach MPage is displaying "Create Report" menu item or not.
	this.addFilterMappingObject("XR_PRINTING", {
		setFunction : this.setXRPrintFlag,
		type : "Boolean",
		field : "FREETEXT_DESC"
	});
};
/**
 * Initialize the ReachSummaryMPage. Setup the criterion object, load filter mappings, and create page times.
 * Once the setup has completed the help file information is loaded as well as the additional titleAnchor which gives the user the ability to start the
 * discharge process.
 * @return null
 */
ReachSummaryMPage.prototype.initializeMPageView = function() {
	var criterion = null;
	var patInfo = null;
	var programName = "MP_GET_PATIENT_DEMO";
	var sendAr = [];
	var demoRequest = null;
	var jsonText = null;	
	
	var demoHTML = [];	

	//Initialize function to handle all of the basic setup
	var resizeTimer = null;
	var self = this;
	try {
		this.loadFilterMappings();
		this.setCapTimerName("CAP:MPG MPages Reach Module");
		this.setSubTimerName(this.getCategoryMean());
		this.createMPageTimerObject();
		this.setCriterion(createPageCriterion(this.getCategoryMean()));
	
			$(window).resize(function () {
				if (resizeTimer) {
					clearTimeout(resizeTimer);
				}
				resizeTimer = setTimeout(function () {
						if (!validateWindowResize()) {
							return null;
						}
						self.resizeView();
					}, 100);
			});
		
	} catch (err) {
		MP_Util.LogJSError(err, null, "mpages-reach.js", "initializeMPageView");
		throw err;
	}

	//Store the criterion object temporarily
	criterion = this.getCriterion();
	
	patInfo = criterion.getPatientInfo();
	
	var nameFull = patInfo.getName();	
	var sexCheck = patInfo.getSex();
	var sexDisp = (sexCheck) ? patInfo.getSex().display : "--";	
	
	sendAr.push("^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0");
	demoRequest = new MP_Core.ScriptRequest(null, "ENG:MPG.REACH_DEMO_BANNER.01 - retrieve patient demo info");
	demoRequest.setProgramName(programName);
	demoRequest.setName("GetReachDemoData");
	demoRequest.setParameters(sendAr);
	demoRequest.setAsync(true);

	//Build Demographics Banner
	demoHTML.push('<div id="reachDemo" class="demo-main">',
		'<h1 id="demoName" class="demo-head">',
		'</h1>',
		'<ul class="demo-itms">',
		'<li><span>DOB: </span>',
		'<span id="demoDob">Loading...</span>',
		'</li>',
		'<li><span>MRN: </span>',
		'<span id="demoMrn">Loading...</span>',
		'</li></ul>',
		'<ul class="demo-itms">',
		'<li id="demoSex">Sex:',
		'</li>',
		'<li><span>FIN: </span>',
		'<span id="demoFin">Loading...</span>',
		'</li></ul>',
		'<ul class="demo-itms">',
		'<li><span>Location: </span>',
		'<span id="demoLoc">Loading...</span>',
		'</li>',
		'<li>&nbsp;</li></ul>',
		'<a id="reachClose"></a>',
		'</div>');
	$('body').prepend(demoHTML.join(""));
	$('body').addClass('in-iframe');
	
	$('#demoName').text(nameFull);	
	var demoSEX = $('#demoSex').html();	
	$('#demoSex').html(demoSEX + " " + sexDisp);
		
	MP_Core.XMLCCLRequestCallBack(null,demoRequest,ReachSummaryMPage.buildDemoHTML);	
	
};
/**
 * Initializes the MPageComponent objects that will be a part of the MPages View.  This function first calls the base initializeComponents 
 * function to setup all MPageComponent objects.  Once those objects are available the MPage name is set in each component.
 * @return null
 */
ReachSummaryMPage.prototype.initializeComponents = function() {	
	var criterion = null;

	//Call the base function to handle the basic component setup
	MPageView.prototype.initializeComponents.call(this, null);
	
	//this.banner is defaulted to true, so ensure banner is not loaded since Reach banner is built
	this.banner=false;

	//Store the criterion object temporarily
	criterion = this.getCriterion();

	MD_xrPrintDialog.setCriterion(criterion);

};

ReachSummaryMPage.prototype.loadPrintMenuItem = function() {
	var printMenuItem = null;
	var that = this;
	//check for the XR Printing bedrock filter is set Yes/No
	if(this.getXRPrintFlag()){
	//Create the menu item that will be added to the page level menu
	printMenuItem = new MenuSelection("printMenu" + this.getCategoryMean());
	printMenuItem.setLabel(i18n.discernabu.CREATE_REPORT);
	printMenuItem.setClickFunction(function(){
		MD_xrPrintDialog.initializeModalObject();
	});
	}
	return printMenuItem;
};

ReachSummaryMPage.prototype.loadLogoutMenuItem = function() {	
	var logoutMenuItem = null;
	var that = this;
	
	//Create the menu item that will be added to the page level menu
	logoutMenuItem = new MenuSelection("logoutMenu" + this.getCategoryMean());
	logoutMenuItem.setLabel(i18n.discernabu.LOGOUT);
	logoutMenuItem.setClickFunction(function(){
		parent.MPM.wf.closeIframe();		
	});
	return logoutMenuItem;
};

ReachSummaryMPage.prototype.loadHelpMenuItem = function() {
	var helpMenuItem = null;
	var that = this;
	
	//Create the menu item that will be added to the page level menu
	helpMenuItem = new MenuSelection("helpMenu" + this.getCategoryMean());
	helpMenuItem.setLabel(i18n.discernabu.HELP);
	helpMenuItem.setClickFunction(function(){
		window.open("https://wiki.ucern.com/display/r1mpagesHP/MPages+Help+Pages");
	});
	return helpMenuItem;
};

ReachSummaryMPage.prototype.loadPageMenu = function() {
	var categoryMean = this.getCategoryMean();
	var tempMenuItem = null;

	//Call the base function to handle the basic component setup
	MPageView.prototype.loadPageMenu.call(this);	
	
	//Create the menu object for this page
	var reachPageMenu = MP_MenuManager.getMenuObject("pageMenu" + categoryMean);	

	//Create the Create Report menu item
	tempMenuItem = this.loadPrintMenuItem();
	if(MenuItem.prototype.isPrototypeOf(tempMenuItem)){
		reachPageMenu.insertMenuItem(tempMenuItem,5);
	}
	
	reachPageMenu.insertMenuItem(new MenuSeparator("separator"),6);

	//Create the logout menu item
	tempMenuItem = this.loadLogoutMenuItem();
	if(MenuItem.prototype.isPrototypeOf(tempMenuItem)){
		reachPageMenu.insertMenuItem(tempMenuItem,7);
	}	
	
	//Add the menu object to the menu manager
	MP_MenuManager.updateMenuObject(reachPageMenu);
	
	//Add class to overwrite position attribute in base page-menu class
	$('#pageMenuMP_REACH_V5').addClass("demo-page-menu");
};

ReachSummaryMPage.buildDemoHTML = function(reply) {
	demoReply = reply.getResponse();
	var demoHTML = [];	
	
	var mrnNbr = "";
	var finNbr = "";
	var birthDate = "";
	var birthDtTm = new Date();	
	var locDesc = "";
	var locObj = null;
	var nurseObj = null;
	var roomObj = null;
	var bedObj = null;	
	var patInfo = null;	
	var enCodeArray = [];
	var ptCodeArray = [];
	var codeArray = null;
	
	codeArray = MP_Util.LoadCodeListJSON(demoReply.CODES);
	patInfo = demoReply.DEMOGRAPHICS.PATIENT_INFO;
	
	//Determine the patient's age based on the absolute date stored in the DB or the calculated date and time
	if(patInfo.ABS_BIRTH_DT_TM !== "") {
		var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
		var d = patInfo.ABS_BIRTH_DT_TM.match(new RegExp(regexp));
		birthDtTm = new Date(d[1], d[3] - 1, d[5], d[7], d[8], d[10]);
		birthDate = birthDtTm.format("shortDate2");
	} else if(patInfo.BIRTH_DT_TM !== "") {
		birthDtTm.setISO8601(patInfo.BIRTH_DT_TM);
		birthDate = birthDtTm.format("shortDate2");	
	}	
	
	if (birthDate) {
		$('#demoDob').html(birthDate);
	} else {
		$('#demoDob').html("--");
	}

	var encntrInfo = demoReply.DEMOGRAPHICS.ENCOUNTER_INFO;
	
	for(j = 0, e = encntrInfo.length; j < e; j++) {
		locObj = MP_Util.GetValueFromArray(encntrInfo[j].LOC_FACILITY_CD, codeArray);
		nurseObj = MP_Util.GetValueFromArray(encntrInfo[j].LOC_NURSE_UNIT_CD, codeArray);
		roomObj = MP_Util.GetValueFromArray(encntrInfo[j].LOC_ROOM_CD, codeArray);
		bedObj = MP_Util.GetValueFromArray(encntrInfo[j].LOC_BED_CD, codeArray);
		
		if (nurseObj) {
			locDesc += (nurseObj) ? nurseObj.description : ""; 
		}
		
		if (roomObj) {
			locDesc += (roomObj) ? "; " + roomObj.description : "";
		}
		
		if (bedObj) {
			locDesc += (bedObj) ? "; " + bedObj.description : "";
		}
		
		if (locDesc === "") {
			locDesc = "--";
		}
		
		for(i = 0, l = encntrInfo[j].ALIAS.length; i < l; i++) {
			enCodeArray[i] = MP_Util.GetValueFromArray(encntrInfo[j].ALIAS[i].ALIAS_TYPE_CD, codeArray);
			if(enCodeArray[i].meaning == "FIN NBR") {
				finNbr = encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
			} else if(enCodeArray[i].meaning == "MRN") {
				mrnNbr = encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
			}
		}
	}
	
	$('#demoLoc').html(locDesc);	
	
	//If did not find MRN look in Patient ALIAS
	if(mrnNbr === "") {
		var aliasArry = demoReply.DEMOGRAPHICS.PATIENT_INFO.ALIAS;				
		for(i = 0, l = aliasArry.length; i < l; i++) {
			ptCodeArray[i] = MP_Util.GetValueFromArray(aliasArry[i].ALIAS_TYPE_CD, codeArray);
			if(ptCodeArray[i].meaning == "MRN") {
				mrnNbr = aliasArry[i].FORMATTED_ALIAS;
			}
		}
	}		
	
	$('#demoMrn').html(mrnNbr || "--");
	
	$('#demoFin').html(finNbr || "--");	
	
	$('#reachLoad').removeClass('demo-load');
	$('#reachScreen').removeClass('demo-screen');
	
	$('#reachClose').click(function() {
		$('html',parent.document).removeClass('reach-hide-scroll');	
		//Remove iframe
		$('#reach1', parent.document).remove();
	});	

};

/**
* Used to initialize the MPage View and the setup.
*/
function renderMPagesView(mPageCategoryMean) {
	var timerRenderMPagesView = null;
	try {
		/*eslint-disable new-cap*/
		timerRenderMPagesView = MP_Util.CreateTimer("ENG:MPG.MPageReachView - renderMPagesView", mPageCategoryMean);
		/*eslint-enable new-cap*/
		var newMPage = null;
		parseMPageSettingsJSON();
		populateMPageLocale();
		/* Create an object of renderMpagesView */
		newMPage = createViewObject(mPageCategoryMean);
		if (MPageView.prototype.isPrototypeOf(newMPage)) {
			newMPage.initializeMPageView();
			newMPage.loadViewSettings();
			newMPage.initializeComponents();
			newMPage.renderView();
			newMPage.postProcessing();
			return newMPage;
		}
		return null;
	} catch (err) {
		if (timerRenderMPagesView) {
			timerRenderMPagesView.Abort();
			timerRenderMPagesView = null;
		}
		MP_Util.LogJSError(err, null, "mpages-reach.js", "renderMPagesView");
		throw err;
	}
	finally {
		if (timerRenderMPagesView) {
			timerRenderMPagesView.Stop();
		}
	}
}

/**
 * Used to render the MPages View once it has been initialized and setup.  Calls the MP_Util.Doc.InitLayout function to render the
 * HTML of the page layout.  Once the page layout has been rendered, the Chart Search functionality and demo banner are added to
 * the MPage View.  Finally the component script calls are executed within the MP_Util.Doc.RenderLayout() function call.
 * @return {boolean} True if the page was rendered successfully, false otherwise
 */
ReachSummaryMPage.prototype.renderView = function () {
	/*eslint-disable new-cap*/
	var timerRenderView = MP_Util.CreateTimer("ENG:MPG.MPageReachView - renderMPage", this.getCategoryMean());
	/*eslint-enable new-cap*/
	var component = null;
	var componentList = null;
	var componentCount = 0;
	var groups = [];
	var group = null;
	var collapsedComponents = [];
	var numberRows = 0;
	var numberGroups = 0;

	try {

		//Check to see if this view is even valid in the current context.
		if (!this.isContextValid()) {
			//The current context is not valid for this view so we need to show a context error message
			this.displayInvalidContextMessage();
			return false;
		}

		// Create the aggregate timer object to measure page load time
		var aggregateTimer = this.createAggregateTimer();
		// Mark the timer as started because it is already started either in the driver script or in ViewPoint before the view is initialized.
		aggregateTimer.markTimerStarted();

		//Store the container, so we can easily access it later
		this.setContainer($(document.body));

		//Check to see if any component are defined for this MPageView.  Return if there are not any
		componentList = this.getComponents();
		if (!(componentList && componentList.length)) {
			throw new Error(i18n.VIEW_SETTINGS_UNAVAILABLE);
		}

		//get the total number of components
		componentCount = componentList.length;
		
		//Add the Page Title
			MP_Util.Doc.AddPageTitle(this.getName(), this.getContainer(), this.getCriterion().debug_ind, this.getCustomizeEnabled(), this.getTitleAnchors(), this.getHelpFileName(), this.getHelpFileURL(), this.getCriterion(), null);
			
		//Render the component shells
		this.renderComponents(componentList);

		//Get the component list as the group/column list
		componentList = MP_Util.GetComponentArray(componentList);

		//Create the page level menu
		this.loadPageMenu();

		//Additional page setup
		MP_Util.Doc.AddCustomizeLink(this.getCriterion());
		MP_Util.Doc.SetupExpandCollapse(this.getCategoryMean());
		MP_Util.Doc.SetupCompFilters(this.getComponents());
		MP_Util.Doc.CreateCompMenus(this.getComponents(), false);

		numberGroups = componentList.length;

		window.setTimeout(function () {
			//the number of all displayable components
			var initialComponentCount = 0;
			var i = 0;
			var j = 0;
			var k = 0;
			//Create the correct ordering
			for (i = 0; i < numberGroups; i++) {
				groups[i] = {};
				groups[i].ROWS = [];
				group = componentList[i];
				var numberColumns = group.length;
				//Iterate through the columns of the group
				for (j = 0; j < numberColumns; j++) {
					var column = group[j];
					numberRows = column.length;
					for (k = 0; k < numberRows; k++) {
						component = column[k];
						if (!groups[i].ROWS[k]) {
							groups[i].ROWS[k] = [];
						}
						if (component.isDisplayable() && component.isExpanded() && !component.isLoaded()) {
							groups[i].ROWS[k].push(component);
						} else if (component.isDisplayable() && !component.isExpanded() && !component.isLoaded()) {
							collapsedComponents.push(component);
						}
					}
				}
			}
			//Start the data retrieval for expanded components
			for (i = 0; i < numberGroups; i++) {
				group = groups[i];
				numberRows = group.ROWS.length;
				for (j = 0; j < numberRows; j++) {
					var row = group.ROWS[j];
					var numberComponents = row.length;
					for (k = 0; k < numberComponents; k++) {
						component = row[k];
						component.setLoaded(true);
						// register the component in the aggregate timer before data retrieval begins
						aggregateTimer.registerTask(component.getStyles()
							.getId());
						// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
						component.setAggregateTimer(aggregateTimer);
						//count the component because it will be loaded
						initialComponentCount++;
						component.startComponentDataRetrieval();
					}
				}
			}
			//Now start the data retrieval for the collapsed components
			for (i = 0; i < collapsedComponents.length; i++) {
				component = collapsedComponents[i];
				component.setLoaded(true);
				// register the component in the aggregate timer before data retrieval begins
				aggregateTimer.registerTask(component.getStyles()
					.getId());
				// pass the reference of the aggregate timer to the component, so it will notify the timer when it finishes loading
				component.setAggregateTimer(aggregateTimer);
				//count the component because it will be loaded
				initialComponentCount++;
				component.startComponentDataRetrieval();
			}

			//add the total number of components to meta data
			aggregateTimer.addMetaData("component.count", componentCount);

			//add the number of initially loaded components to meta data (all components are loaded in initial load)
			aggregateTimer.addMetaData("component.initialLoadCount", initialComponentCount);

			// Lock the registration when initial loading components are registered.
			aggregateTimer.lockRegistration();
		}, 0);
		return true;
	} catch (err) {
		if (timerRenderView) {
			timerRenderView.Abort();
			timerRenderView = null;
		}
		logger.logJSError(err, null, "mpages-reach.js", "renderView");
		throw err;
	}
	finally {
		if (timerRenderView) {
			timerRenderView.Stop();
		}
	}
};
/*globals WorkflowRenderStrategy, AggregateTimer, m_bedrockMpage, CERN_driver_mean, MPageUI, CapabilityTimer*/
/**
 * A constructor used to create a new NavigatorSubsectionSummaryMPage object and initialize page level variables.
 * @constructor
 */
var NavigatorSubsectionSummaryMPage = function() {
	//A flag which will determine if we should load all components or attempt to selectively load components as needed
	this.m_selectiveComponentLoadInd = false;

	//Set page level information
	this.setName('Navigator Subsection Summary MPage');

	//Set the category mean of the parent workflow page so component subtimers will be associated with the parent
	// instead of the subsection
	this.m_parentWorkflowId = '';

	//Set the aggregate timer object that measures the page load time
	this.m_aggregateTimer = null;

	//Flag which will determine if the current view has been divided into two columns with the second column named
	// Contextual View.
	this.m_isContextualViewActive = false;

	//Minimum width required to have the second column/contextual view
	this.m_minWidthForContextualView = 1600;

	//Array to cache the instance of component in the second column/conxtextual view column
	this.m_componentsInContextualView = [];
};

/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
NavigatorSubsectionSummaryMPage.prototype = new MPageView();
NavigatorSubsectionSummaryMPage.prototype.constructor = MPageView;

/**
 * Checkers
 */
/**
 * Returns the flag which indicates if components should be loaded selectively.  If this flag is set to true the MPage
 * will not attempt to load any components upon initial render and will instead wait to load components when the
 * loadSelectedComponent function is called
 * @returns {boolean} The selective components loading indicator.
 */
NavigatorSubsectionSummaryMPage.prototype.selectivelyLoadComponents = function() {
	return this.m_selectiveComponentLoadInd;
};

/**
 * Getters
 */

/**
 * This function will retrieve the aggregate timer object that measure the page load time.
 * @returns {AggregateTimer} The AggregateTimer object
 */
NavigatorSubsectionSummaryMPage.prototype.getAggregateTimer = function() {
	return this.m_aggregateTimer;
};

/**
 * This function will retrieve the category_mean of the parent workflow MPage where this navigator subsection summary
 * MPage is being displayed.
 * @returns {string} The identifier of the parent Workflow MPage
 */
NavigatorSubsectionSummaryMPage.prototype.getParentWorkflowIdentifier = function() {
	return this.m_parentWorkflowId;
};

/**
 * Returns a flag indicating that the contextual view is active
 * @returns {Boolean}  The flag indicating that contextual view is active
 */
NavigatorSubsectionSummaryMPage.prototype.isContextualViewActive = function() {
	return this.m_isContextualViewActive;
};
/**
 * Setters
 */

/**
 * This function will set the aggregate timer object that measure the page load time.
 * @param {AggregateTimer} aggregateTimer The AggregateTimer object
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.setAggregateTimer = function(aggregateTimer) {
	this.m_aggregateTimer = aggregateTimer;
};

/**
 * This function will set the category_mean of the parent Workflow MPage where this navigator subsection summary MPage
 * is being displayed. This will allow the components being displayed in this navigator subsection summary to log
 * timers that are associated with the parent Workflow MPage.
 * @param {string} parentWorkflowId The identifier associated with the parent Workflow MPage
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.setParentWorkflowIdentifier = function(parentWorkflowId) {
	this.m_parentWorkflowId = parentWorkflowId;
};

/**
 * Set the selective component load flag which determines if the MPage should allow for selective component loading.
 * This means the MPage will not attempt to load its components until explicitly told to do so using the
 * loadSelectedComponent function.
 * @param {boolean} selectiveLoad A boolean which will indicate if the MPages should allow for selective loading of
 *     components.
 * @returns {boolean} True if the selective component load indicator was set successfully, false otherwise
 */
NavigatorSubsectionSummaryMPage.prototype.setSelectiveComponentLoadInd = function(selectiveLoad) {
	if(typeof selectiveLoad === 'boolean') {
		this.m_selectiveComponentLoadInd = selectiveLoad;
		return true;
	}
	return false;
};

/**
 * Set the contextual view active flag which determines if the MPage has contextual view.
 * @param {boolean} contextualViewActiveInd A boolean which will indicate if the MPage has contextual view active.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.setContextualViewActive = function(contextualViewActiveInd) {
	this.m_isContextualViewActive = contextualViewActiveInd;
};

/**
 * Helper functions
 */


/**
 * This function overrides the base implementation of creating the MPage Timer object.  The timer for the
 * workflow views will be handled at the workflow level instead of the MPageView that is associated with
 * an individual subsection.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.createMPageTimerObject = function() {
};


/**
 * Create the agregate timer object to measure the page load time
 * It will choose the right timer name based on whether it is the initial page load or the user is switching to another
 * view.
 * @returns {AggregateTimer} the aggregate timer object
 */
NavigatorSubsectionSummaryMPage.prototype.createAggregateTimer = function() {
	var pageLoadTimerName = null;

	// Retrieve the category mean from the parent Workflow container, because this subsection's category mean contains
	// ssView_0
	var viewCategoryMean = this.getParentWorkflowIdentifier();

	//get the timer name depending on whether the view is loaded during the initial page load
	if(MP_Viewpoint.getInitialViewId() === viewCategoryMean) {
		//use the same timer as defined in mp_unified_driver
		pageLoadTimerName = 'USR:MPG.MP_UNIFIED_DRIVER load entire page';
	}
	else {
		//use the timer name the measures the page load timer when the user switches the view
		pageLoadTimerName = 'USR:MPG.VIEWPOINT load switch view';
	}

	return new AggregateTimer(pageLoadTimerName, viewCategoryMean);
};

/**
 * This function is utilized when the selective component loading indicator has been set to true.  It allow a parent
 * controller to selectively load the components which are contained within this MPages View.
 * @param {MPageComponent} component The component which should be allowed to begin its data retrieval.
 * @returns {boolean} True if the component told to begin data retrieval false otherwise
 */
NavigatorSubsectionSummaryMPage.prototype.loadSelectedComponent = function(component) {
	//Ensure this component is actually an MPageComponent object
	if(!MPageComponent.prototype.isPrototypeOf(component)) {
		logger.logError('Invalid MPageComponent object passed into NavigatorSubsectionSummaryMPage.loadSelectedComponent');
		return false;
	}

	//Check to see if the component has already been loaded
	if(component.isDisplayable() && !component.isLoaded()) {
		//Mark the component as loaded and kick off the data retrieval
		component.setLoaded(true);
		component.startComponentDataRetrieval();
		return true;
	}
	else {
		return false;
	}
};

/**
 * This function creates the workflow render strategy for the components.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.createNewRenderStrategy = function() {
	return new WorkflowRenderStrategy();
};

/**
 * Initialize the NavigatorSubsectionSummaryMPage. Once the base function has completed the help file information is
 * loaded as well as the additional titleAnchor which gives the user the ability to start the discharge process.
 * @param {string} categoryMean The category mean for this MPageView
 * @param {Object} componentSettings The component settings for this MPageView
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.initializeView = function(categoryMean, componentSettings) {
	var pageSettings = {};

	//Set the categoryMean for this object
	this.setCategoryMean(categoryMean);

	//Create the page settings for this Object so it can be used in the initializeComponents function
	pageSettings.C_MN = categoryMean; //C_MN is shorthand for Category Mean
	pageSettings.BR_SET = {}; //BR_SET is shorthand for Bedrock Settings
	pageSettings.BR_SET.CS = componentSettings; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for
												// Component Settings
	this.setViewSettings(pageSettings);

	//Call the base initialize function to handle all of the basic setup
	MPageView.prototype.initializeView.call(this, null);
};

/**
 * We have to override this because the bedrock settings can't handle the setting structure and we are hacking this to
 * get it to function for phase 0
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.loadViewSettings = function() {
	//Create a settings object for this View.  This is a hack so that we can utilize the existing bedrock component
	// loading.
	m_bedrockMpage.MPAGE.push({
		SETTINGS: this.getViewSettings()
	});
};

/**
 * Initialize the components which will be shown within this particular view.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.initializeComponents = function() {
	var component = null;
	var componentsArr = [];
	var componentCnt = 0;
	var compSettings = null;
	var criterion = null;
	var pageSettings = null;
	var x = 0;

	//Load the necessary components based on the component settings
	pageSettings = this.getViewSettings();
	criterion = this.getCriterion();
	//Update the criterion category_mean so that component will utilize the parent workflow id instead of the
	// subsection generated id
	criterion.category_mean = this.getParentWorkflowIdentifier(); //eslint-disable-line mp-camelcase
	componentsArr = pageSettings.BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for
											// Component Settings
	componentCnt = componentsArr.length;
	//Initialize the components and add them to the Mpage
	for(x = 0; x < componentCnt; x++) {
		compSettings = componentsArr[ x ];
		//Create the component and prepare it for rendering
		component = this.createMPageComponentObject(compSettings.F_MN); //F_MN is shorthand for Filter Mean
		if(component) {
			component.initializeComponent(criterion);
			//Set Component Preferences based on bedrock settings and user preferences
			component.loadComponentSettings(compSettings);
			component.loadDisplayFilters();
			component.setAlwaysExpanded(true);
			//Set the component type so we can perform any special actions base on the workflow type
			component.getStyles().setComponentType(CERN_COMPONENT_TYPE_WORKFLOW);
			//Move components defined for the second and third columns to the end of the first column.
			if(component.getColumn() > 1) {
				//Using the * 100 to make sure the components are shown after the components defined to show
				// in the columns left of the current column.
				component.setSequence(component.getColumn() * 100 + component.getSequence());
				component.setColumn(1);
			}
			//Determine if the components should be displayed or not based on the view builder settings
			//Load component marked as Gap Check required even if it is set to off in the view builder settings
			if(component.getToggleStatus() === 0 && !component.getGapCheckRequiredInd()) {
				component.setDisplayEnabled(false);
			}
			//Create the component menu
			component.createMainMenu();
			component.preProcessing();
			this.addComponent(component);
			this.addComponentId(componentsArr[ x ].R_ID); //R_ID is shorthand for Report Id(br_datamart_report_id)
		}
	}
};

/**
 * This function forces all the components into a single group and single column
 * @param {Array} components The list of components we are forcing into the single group, single column
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.forceComponentsIntoSingleColumn = function(components) {
	var numberComponents = components.length;
	//Force all components into a single column layout
	for(var x = 0; x < numberComponents; x++) {
		var component = components[ x ];
		component.setPageGroupSequence(1);
		component.setColumn(1);
	}
};
/**
 * This function will validate whether the current MPageView can have contextual view.
 * @returns {Boolean} Flag whether the current screen resolution is capable for the MPageView to have contextual view.
 */
NavigatorSubsectionSummaryMPage.prototype.canHaveContextualView = function() {
	//Get the width of th screen from the screen object.
	var screenWidth = screen.availWidth;
	//Currently in Powerchart the width of the Window object in the powerchart is not exactly same as the screen's
	// available width,  on manual computing the difference has differed for different scenarios, the maximum
	// difference was 40. Calculating this on the go would not work when the window is resized to a smaller width and
	// this condition would always pass.
	var bufferWidth = 40;

	//Get the width of the workflow view and check whether is meets the minimum required width.
	var parentWorkflowContainerWidth = $('#' + this.m_parentWorkflowId).width();
	return screenWidth >= this.m_minWidthForContextualView && parentWorkflowContainerWidth >= this.m_minWidthForContextualView - bufferWidth;
};

/**
 * This function changes the layout of the current view with a different number of columns
 * @param {Number} newColCnt Number of columns of the new layout
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.changeLayout = function(newColCnt) {
	var catMean = this.getCategoryMean();
	var viewContainerId = '#' + catMean + ' ';
	var $parentContainer = $('#' + this.m_parentWorkflowId).find('.wrkflw-views');
	var parentContainerHeight = $parentContainer.height();
	var $columnGroup = $(viewContainerId + '.col-group:last');

	if(newColCnt === 1) {
		//Remove the second column
		this.getColumnContainer(2).remove();
		this.m_isContextualViewActive = false;
		$columnGroup.addClass('one-col');
		$columnGroup.removeClass('two-col');
	}
	else if(newColCnt === 2) {
		$(viewContainerId + '.col-outer1:last').append('<div class=\'col2\' height=\'' + parentContainerHeight + 'px\'><div class=\'components-col-container\'></div></div>');
		$columnGroup.addClass('two-col');
		$columnGroup.removeClass('one-col');
	}
};

/**
 * Function that adds component to the m_componentsInContextualView array and prevents duplicates.
 * @param {MPageComponent} comp The instance of the component being moved from single column to the contextual view
 *     column.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.addComponentToContextualViewArray = function(comp) {
	if($.inArray(comp, this.m_componentsInContextualView) === -1) {
		this.m_componentsInContextualView.push(comp);
	}
};
/**
 * Gets all the component in the contextual view.
 * @returns {Array} The array containing the components in contextual view.
 */
NavigatorSubsectionSummaryMPage.prototype.getComponentsInContextualViewArray = function() {
	return this.m_componentsInContextualView;
};
/**
 * Removes the component from the contextual view component array, called whenever a component is moved out of
 * contextual view.
 * @param  {MPageComponent} compObj Instance of component that is being moved between columns.
 * @returns {undefined} Does not return anything.
 */
NavigatorSubsectionSummaryMPage.prototype.removeComponentFromContextualViewArray = function(compObj) {
	var components = this.getComponentsInContextualViewArray();
	var component = null;
	for(var x = components.length; x--;) {
		component = components[ x ];
		if(component === compObj) {
			components.splice(x, 1);
			break;
		}
	}
};

/**
 * Function that filters active components present in contextual view.
 * @returns {Array}  The array of components that are present in the contextual view.
 */
NavigatorSubsectionSummaryMPage.prototype.filterActiveComponentsInContextualView = function() {
	var activeComponentsInContextualView = [];
	var components = this.getComponents();
	if(components.length) {
		activeComponentsInContextualView = $.grep(components, function(component) {
			return component.isAddedToContextualView() && component.isDisplayable();
		});
	}
	return activeComponentsInContextualView;
};

/**
 * Function that moves the component between the two column views. It gets called whenever the contextual view
 * control is clicked in the component header and when the resize is performed.
 * It has two code paths based on position of the component in contextual view.
 * @param  {MPageComponent} component Instance of component that is being moved between columns.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.moveComponentBetweenViews = function(component) {
	//Function that shuffles component nodes between the two columns.
	function changeComponentNodes(targetNode, activeNode) {
		var previousNode = $(targetNode).prev();
		var nextNode = $(targetNode).next();
		if(previousNode.length) {
			previousNode.after(activeNode);
		}
		else if(nextNode.length) {
			nextNode.before(activeNode);
		}
	}

	//The root component node
	var rootCompNode = component.getRootComponentNode();
	//The placeholder component node
	var placeholderCompNode = component.getRootPlaceholderComponentNode();

	var contextualViewContainer = this.getColumnContainer(2).find('.components-col-container');
	var placeholderView = null;
	//If the component is added to contextual and if contextual view is active,
	//replace the placeholder view of the component with the actual component
	//else create the placeholder view of component if not created and replace the actual component with it.
	if(component.isAddedToContextualView() && this.m_isContextualViewActive) {
		changeComponentNodes(placeholderCompNode, rootCompNode);
		$(placeholderCompNode).hide();
		component.setAddedToContextualView(false);
		//Update the icon of the contextual view control in the actual component to move right.
		component.getContextualViewControl().setIcon(MPageUI.ICONS.ICON_MOVE_RIGHT);
	}
	else {
		//On the initial call of this function the component is in the first column and would need to be replaced with
		// its placeholder view Create the placeholder view, if not already created else just show it.
		if(!placeholderCompNode.length) {
			placeholderCompNode = component.createPlaceholderViewOfComponent();
		}
		else {
			$(placeholderCompNode).show();
		}
		//if the component is not loaded yet, load it  by calling the startComponentDataRetrieval
		if(component.isDisplayable() && !component.isLoaded()) {
			//Mark the component as loaded and kick off the data retrieval
			component.setLoaded(true);
			component.startComponentDataRetrieval();
		}
		//Call the helper function that has logic to change component nodes.
		changeComponentNodes(rootCompNode, placeholderCompNode);
		//Append the actual component node to the contextual view container.
		contextualViewContainer.append(rootCompNode);
		//This is the first instance of the placeholder view created and just rendered.
		//Set the callback to the control that adds the component to the contextual view.
		placeholderView = component.getPlaceholderView();
		if(!placeholderView.hasRendered()) {
			component.getContextualViewControlInPlaceholderView().setOnClickCallback(this.handleContextualViewControlFunction(component));
			component.getContextualViewControlInPlaceholderView().attachEvents();
		}
		placeholderView.setRendered(true);
		component.setAddedToContextualView(true);
		//Update the icon of the contextual view control in placeholder view and the actual component to move left.
		component.getContextualViewControlInPlaceholderView().setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);
		component.getContextualViewControl().setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);
	}
};

/**
 * This function returns a function that would be used as a callback for the click on the MPageUI.Button instance for
 * the contextual view control. The callback will check whether the component is added to contextual view and would
 * activate the two column view by calling the changeLayout function else if not added to contextual view it would
 * remove the component from the contextual view and change the layout to single column.
 *
 * @param  {MPageComponent} component An instance of the MPageComponent
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.handleContextualViewControlFunction = function(component) {
	var categoryMean = this.getCategoryMean();
	var self = this;
	return function() {
		//Get the preferences object.
		var preferenceObj = component.getPreferencesObj();
		//If the component does not have az
		if(!preferenceObj) {
			preferenceObj = {
				contextualViewPrefs: {}
			};
		}
		else {
			preferenceObj.contextualViewPrefs = {};
		}
		//Capability timer for the add action that moves this component to the contextual view.
		var addToContextualViewCapTimer = new CapabilityTimer('CAP:MPG COMPONENT CONTEXTUAL VIEW CONTROL CLICK', categoryMean);
		addToContextualViewCapTimer.addMetaData('component.reportMean', component.getReportMean());
		//If the component is not added to contextual view, add the component instance to the
		//array containing only contextual view components,
		// change the layout to two column only once.
		if(!component.isAddedToContextualView()) {
			self.addComponentToContextualViewArray(component);
			preferenceObj.contextualViewPrefs.isAddedToContextualView = true;
			addToContextualViewCapTimer.addMetaData('action', 'Added to Contextual View');
			if(!self.m_isContextualViewActive) {
				self.m_isContextualViewActive = true;
				self.changeLayout(2);
			}
		}
		else {
			//If the component is in the contextual view, remove the component instance from the
			//contextual view array and set the preference to false.
			self.removeComponentFromContextualViewArray(component);
			preferenceObj.contextualViewPrefs = null;
			addToContextualViewCapTimer.addMetaData('action', 'Removed from Contextual View');
		}
		//Set the preference object at component level.
		component.setPreferencesObj(preferenceObj);
		//call the capture method on the CapabilityTimer
		addToContextualViewCapTimer.capture();
		//Call the moveComponentBetweenViews function that has logic to decide what to do with the
		//compoent, move it to contextual view or remove from it.
		self.moveComponentBetweenViews(component);
		//Update the preference for components in contextual view and change the layout to single column if there
		// aren't any components in it.
		self.updateContextualViewCompPreferences();
		//Close the contextual view
		self.closeContextualView();
		//Once the layout of the view is changed, call the resizeComponents function.
		self.resizeComponents();
		//Call the UpdateAllCompPreferences method that would  update the preferences of all components.
		CERN_EventListener.fireEvent(null, component, EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW, component);
		MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(self.getComponents(), true, true); //eslint-disable-line new-cap
	};
};
/**
 * This function updates the preferences of all the components present in the Contextual view.
 * The preference that gets updated currently is the sequence of the component in the contextual view.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.updateContextualViewCompPreferences = function() {
	var contextualViewContainer = this.getColumnContainer(2).find('.components-col-container');
	//Get all the components in the contextual view. For all the components update their position,
	//if there aren't any change the layout to single column.
	var contextualViewCompArr = this.getComponentsInContextualViewArray();
	var contextualViewCompArrLen = contextualViewCompArr.length;
	//If there are any components update their sequence by looping
	for(var c = 0; c < contextualViewCompArrLen; c++) {
		var comp = contextualViewCompArr[ c ];
		var compId = comp.getStyles().getId();
		//Create the preference object if not already created.
		var preferenceObj = comp.getPreferencesObj();
		if(preferenceObj) {
			if(preferenceObj.contextualViewPrefs) {
				preferenceObj.contextualViewPrefs.row_seq = contextualViewContainer.find('#' + compId).index(); //eslint-disable-line mp-camelcase
			}
		}
	}
};
/**
 * This function closes the contextual view if there are no more components left in contextual view column/second
 * column.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.closeContextualView = function() {
	//get the components in the Contextual view
	var contextualViewCompArr = this.getComponentsInContextualViewArray();
	var contextualViewCompArrLen = contextualViewCompArr.length;
	//If there are any components and if the contextual view is active change the layout to single column and set the
	// isContextualViewActive flag to false;
	if(!contextualViewCompArrLen && this.m_isContextualViewActive) {
		this.changeLayout(1);
		this.m_isContextualViewActive = false;
	}
};

/**
 * This function overrides the parent implementation and forces the components into a single column,
 * then gets the active components in Contextual View and creates a two column layout using all the columns and
 * the new array of contextual view components.
 *
 * @param {Array} components A list of components that we are rendering
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.renderComponents = function(components) {
	//Helper function that sorts the components in contextual view based on their sequence in contextual view.
	function sortMPageComponentInContextualView(c1, c2) {
		if(c1.getSequenceInContextualView() < c2.getSequenceInContextualView()) {
			return -1;
		}
		if(c1.getSequenceInContextualView() > c2.getSequenceInContextualView()) {
			return 1;
		}
		return 0;
	}

	if(!Array.prototype.isPrototypeOf(components) || !components || !components.length) {
		logger.logError('No components were provided to the renderComponents() method');
		return;
	}
	//Although this MPageView would be using the two column layout,
	//in reality we would be still maintaining the single column for all the components and the
	//second column would only be utilized to have the components moved from the first column which would be replaced
	// by  a placeholder version of the component. Hadn't we had the concept of placeholder view replacement of the
	// actual component in the first column, we would avoid forcing those components into single column.
	this.forceComponentsIntoSingleColumn(components);
	this.storeViewComponents(components);

	var columnArray = null;
	var componentGroupArray = MP_Util.GetComponentArray(components); //eslint-disable-line new-cap
	//Get the components in the contextual view by using the filterActiveComponentsInContextualView method.
	//Storing this array at the view level it will be used during resize.
	this.m_componentsInContextualView = this.filterActiveComponentsInContextualView();
	if(this.m_componentsInContextualView.length && this.canHaveContextualView()) {
		//Sort the components by the sequence in contextual view.
		this.m_componentsInContextualView.sort(sortMPageComponentInContextualView);
		//Use the array returned as the second array in the two dimensional column array to be used in two column
		// layout.
		componentGroupArray[ 0 ].push(this.m_componentsInContextualView);
		this.m_isContextualViewActive = true;
	}
	var container = this.getContainer();
	for(var x = 0; x < componentGroupArray.length; x++) {
		columnArray = componentGroupArray[ x ];
		var columnLength = columnArray.length;
		var columnSuperDiv = $('<div></div>').addClass('col-group');
		$(container).append($('<div></div>').append(columnSuperDiv));
		//Currently support only single and two column views.
		//One column for the actual components and other for the contextual view columns.
		switch(columnLength) {
			case 1:
				columnSuperDiv.addClass('one-col');
				break;
			case 2:
				columnSuperDiv.addClass('two-col');
				break;
		}
		var outerCol1 = $('<div></div>').addClass('col-outer1');
		var outerCol2 = $('<div></div>').addClass('col-outer2');
		outerCol2.append(outerCol1);
		columnSuperDiv.append(outerCol2);
		for(var y = 0; y < columnLength; y++) {
			var columnClassName = 'col' + (y + 1);
			var componentArray = columnArray[ y ];
			var columnDiv = $('<div></div>').addClass(columnClassName).appendTo(outerCol1);
			var contextualViewControlInPlaceholderView = null;
			//Since we are removing the scroll container from the actual parent div to the first column.
			//The components will be added to a new container in the column which will have padding to fit the screen.
			var componentsColumnContainer = $('<div></div>').addClass('components-col-container');
			columnDiv.append(componentsColumnContainer);
			for(var z = 0, zl = componentArray.length; z < zl; z++) {
				var component = componentArray[ z ];
				component.setRenderStrategy(this.createNewRenderStrategy());

				//On initial load if the component is marked as added to contextual View in the user pref
				//and if the placeholderView hasn't been created yet then we need to
				//create the placeholder view of the component and have it in place of the actual component in the
				// first column and append the actual column to the contextual view container.  If the component was
				// not added to contextual view in the previous session create the component shell to be added to the
				// first column.
				if(component.isAddedToContextualView() && !component.getPlaceholderView() && this.canHaveContextualView()) {
					componentsColumnContainer.append(component.createPlaceholderViewOfComponent());
					contextualViewControlInPlaceholderView = component.getContextualViewControlInPlaceholderView();
					//Set the callback for the control in placeholder view and attach the click event on only once
					// through session.
					contextualViewControlInPlaceholderView.setOnClickCallback(this.handleContextualViewControlFunction(component));
					contextualViewControlInPlaceholderView.attachEvents();
					//Set the flag that component is added to contextual view.
					component.setAddedToContextualView(true);
					//Set the flag that the placeholder is rendered.
					component.getPlaceholderView().setRendered(true);
				}
				else {
					componentsColumnContainer.append(component.getRenderStrategy().createComponentShell());
				}
			}
		}
	}
};
/**
 * Function to get the container of the column in the View
 * @param {number} colNum The column number whose container we would like to retrieve
 * @returns {jQuery} The jQuery object representing the column container in the View.
 **/
NavigatorSubsectionSummaryMPage.prototype.getColumnContainer = function(colNum) {
	var $columnGroup = $('#' + this.getCategoryMean() + ' .col-group:last');
	return $columnGroup.find('.col' + colNum);
};

/**
 * This will need to be handled in this object since a lot of extraneous stuff will be stripped out.
 * It would get components added to contextual view in the previous session and load them all.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.renderView = function() {
	var component = null;
	var componentsArr = this.getComponents();
	var componentsCnt = componentsArr ? componentsArr.length : 0;
	var componentMenu = null;
	var menuItems = null;
	var x = 0;
	var contextualViewControl = null;

	//Create the aggregate timer object to measure page load time
	var aggregateTimer = this.createAggregateTimer();
	// Mark the timer as started because it is already started either in the driver script or in ViewPoint before the
	// view is initialized.
	aggregateTimer.markTimerStarted();
	this.setAggregateTimer(aggregateTimer);

	//Store the container, so we can easily access it later
	this.setContainer($('#' + this.getCategoryMean()));

	//Render the components in the layout using the render strategy
	this.renderComponents(componentsArr);

	//check if the current view can have contextual view and show it accordingly
	var viewpointState = $('#' + this.getCategoryMean());
	var $contextualViewControls = viewpointState.find('.hdr-contextual-view-control-container');
	if(!this.canHaveContextualView()) {
		$contextualViewControls.hide();
	}
	//Get the second column in the view, If it exists then set the height of the column to the height of the parent.
	var contextualViewColumn = this.getColumnContainer(2);
	if(contextualViewColumn.length) {
		contextualViewColumn.height(this.getContainer().parent().height());
	}
	//Additional page setup
	MP_Util.Doc.SetupCompFilters(componentsArr); //eslint-disable-line new-cap

	//Load the components and add the click events to the component menus
	function createMenuClickEvent(compObj) {
		return function() {
			MP_MenuManager.showMenu('mainCompMenu' + compObj.getStyles().getId());
		};
	}

	//the number of all displayable components
	var initialComponentCount = 0;

	/*Load the components that should be displayed within this MPages View*/
	//Check the selective component loading flag to see if we should allow the components to retrieve their data
	var renderAllComponents = !this.selectivelyLoadComponents();
	for(x = 0; x < componentsCnt; x++) {
		component = componentsArr[ x ];
		if(component.isDisplayable() && !component.isLoaded()) {
			//Update the click event on the menu to launch this menu when clicked now that the component shells are
			// rendered
			componentMenu = component.getMenu();
			if(componentMenu) {
				menuItems = componentMenu.getMenuItemArray();
				//Check to see if any menu items have been added to the main component menu
				if((!menuItems || !menuItems.length) && component.getStyles().getId().indexOf('cust') !== 0) {
					//Disable the menu for this component and unbind all click events
					$('#' + componentMenu.getAnchorElementId()).addClass('opts-menu-empty').unbind('click');
				}
				else {
					//Add the click event to the menu anchor
					$('#' + componentMenu.getAnchorElementId()).unbind('click').click(createMenuClickEvent(component));
				}
			}
			//Check to see if we should load all components or skip the loading based on the selective component
			// loading flag
			if(renderAllComponents) {
				component.setLoaded(true);
				// register the component in the aggregate timer before data retrieval begins
				aggregateTimer.registerTask(component.getStyles()
					.getId());
				// pass the reference of the aggregate timer to the component, so it will notify the timer when it
				// finishes loading
				component.setAggregateTimer(aggregateTimer);

				//Increment the component count because it will start loading, and it be used for the AggregateTimer
				// meta data
				initialComponentCount++;

				component.startComponentDataRetrieval();
			}
			else if(component.isAddedToContextualView() && this.canHaveContextualView()) {
					//For all the components in contextual view call startComponentDataRetrieval and reset the count in the
					// navigator.
					component.setLoaded(true);
					component.startComponentDataRetrieval();
					CERN_EventListener.fireEvent(component, component, EventListener.EVENT_COUNT_UPDATE, {
						count: null
					});
			}
			//If the component is Contextual View compatible, get the control of the component for the contextual view,
			//set the callback for the control and attach the events.
			if(component.isContextualViewCompatible()) {
				contextualViewControl = component.getContextualViewControl();
				contextualViewControl.setOnClickCallback(this.handleContextualViewControlFunction(component));
				contextualViewControl.attachEvents();
			}
		}
	}

	if(renderAllComponents) {
		//add the number of components to meta data
		aggregateTimer.addMetaData('component.count', componentsCnt);

		//add the number of initially loaded components to meta data (all components are loaded in initial load)
		aggregateTimer.addMetaData('component.initialLoadCount', initialComponentCount);

		// Lock the registration when initial loading components are registered.
		aggregateTimer.lockRegistration();
	}

};

/**
 * This function is used to handle the window.resize events that are fired when the browser window is resized.  The
 * NavigatorSubsectionSummaryMPage overwrites the base class functionality since we may be selectively loading
 * components.  The base class functionality tells all displayable components to render, but based on selective
 * component loading we may have not loaded all of our components yet.  Therefore we only resize the components which
 * have already been loaded.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsectionSummaryMPage.prototype.resizeView = function() {
	var viewpointState = $('#' + this.getCategoryMean());
	var $contextualViewControls = viewpointState.find('.hdr-contextual-view-control-container');
	var contextualViewComponents = this.getComponentsInContextualViewArray();
	var self = this;
	var componentColumn = this.getColumnContainer(1);
	var contextualColumn = null;
	var vwpContainerHeight = $('#' + this.getParentWorkflowIdentifier()).height();
	//Resize the column
	componentColumn.height(vwpContainerHeight);
	//Resize the height of the second column if it is active.
	if(this.m_isContextualViewActive) {
		contextualColumn = this.getColumnContainer(2);
		contextualColumn.height(vwpContainerHeight);
	}

	/**
	 * Helper function that calls the moveComponentBetweenViews function for all the components in contextual view.
	 * @returns {undefined} This function does not return a value
	 */
	function moveComponents() {
		for(var c = 0; c < contextualViewComponents.length; c++) {
			var comp = contextualViewComponents[ c ];
			self.moveComponentBetweenViews(comp);
		}
	}

	//If the window width meets the criteria to have contextual view, update the commponent
	//to display the control for all components and change the layout to two column view if we have any component in
	// contextual view. Else hide all those controls change the layout to single column.
	if(this.canHaveContextualView()) {
		$contextualViewControls.show();
		//If there were any components prior in contextual view prior to resize to a smaller view and if contextual
		// view not already active change the layout to two column view and display the contextual view components by
		// calling the moveComponents method.
		if(contextualViewComponents.length && !this.m_isContextualViewActive) {
			this.changeLayout(2);
			moveComponents();
			this.m_isContextualViewActive = true;
		}
	}
	else if(!this.canHaveContextualView()) {
		//If the view is not wide enough for contextual view to fit in, hide all the controls for contextual view.
		//Change to single column layout only if the contextual view is active currently.
		$contextualViewControls.hide();
		if(contextualViewComponents.length && this.m_isContextualViewActive) {
			moveComponents();
			this.changeLayout(1);
		}

	}
	//Call the resizeComponents function
	this.resizeComponents();
};

/**
 * This function will call the resizeComponent function on all the components that are currently displayed
 * and loaded.
 * @returns {undefined} This function does not return a value
 **/
NavigatorSubsectionSummaryMPage.prototype.resizeComponents = function() {
	//Resize all the components after the columns containing them have resized.
	var compObj = null;
	var components = this.getComponents();
	for(var x = components.length; x--;) {
		compObj = components[ x ];
		if(compObj.isDisplayable() && compObj.isLoaded()) {
			compObj.resizeComponent();
		}
	}
};

/**
 * This function will create the component selection menu object for the workflow page menu.  It will
 * examine the toggle status of each component and mark it appropriately.  All user interactions for the
 * component selection menu are also defined within this function.
 * @returns {Menu} The Menu object that will be used within the page menu
 **/
NavigatorSubsectionSummaryMPage.prototype.loadComponentSelection = function() {
	var addMenu = false;
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var componentToggled = false;
	var compSelMenu = null;
	var menuItem = null;
	var toggleStatus = 0;
	var x = 0;

	//Check to see if the menu item already exists
	compSelMenu = MP_MenuManager.getMenuObject('compSelection' + this.getCategoryMean());
	if(compSelMenu) {
		return compSelMenu;
	}

	//This function is used to sort the available component in alphabetical order based on the component Label
	var componentSort = function(a, b) {
		var aName = a.getLabel().toUpperCase();
		var bName = b.getLabel().toUpperCase();
		if(aName < bName) {
			return -1;
		}
		else if(aName > bName) {
			return 1;
		}
		else {
			return 0;
		}
	};

	//This function is used to toggle the component on/off and make the necessary updates to all of the component
	// sequences
	var toggleComponent = function(componentId, activateComp) {
		var pageGroupSeq = null;
		var toggleComp = null;
		//1 - on, 0 - off
		var toggleStat = activateComp ? 1 : 0;
		var z = 0;

		//Set the toggle status for the component selected from the component selection menu
		//Locate the component we are toggling and updates its location
		for(z = componentCnt; z--;) {
			component = componentArr[ z ];
			//Check to see if this is the component we are toggling
			if(component.getComponentId() === componentId) {
				toggleComp = component;
				toggleComp.setToggleStatus(toggleStat);
				if(activateComp) {
					//Add the component as the first component in the left most column
					//If the component is an organizer level component, column 99, do not update the column
					if(toggleComp.getColumn() !== 99) {
						toggleComp.setColumn(1);
					}
					toggleComp.setSequence(0);
					//Check to see if user preferences exist and if not create the blank object
					if(!MP_Core.AppUserPreferenceManager.GetPreferences()) { //eslint-disable-line new-cap
						MP_Core.AppUserPreferenceManager.SetPreferences('{"user_prefs":{"page_prefs":{"components":[]}}}'); //eslint-disable-line new-cap
					}
				}
				break;
			}
		}

		//Update the sequences/rows for all of the components in the same colgroup and column as the toggled component.
		if(activateComp) {
			pageGroupSeq = toggleComp.getPageGroupSequence();
			for(z = componentCnt; z--;) {
				component = componentArr[ z ];
				//Move all of the other components in the first column down one row
				if(component.getColumn() === 1 && component.getPageGroupSequence() === pageGroupSeq && component !== toggleComp) {
					component.setSequence(component.getSequence() + 1);
				}
			}
		}
	};

	//This function is used when an element is selected in the component selection menu.
	var createSelectionFunc = function(menuItemObj) {
		return function() {
			componentToggled = true;
			var menuItemId = menuItemObj.getId();
			var parsedId = parseFloat(menuItemObj.getId(), 10);
			//There are certain scenarios where the component Id has an alpha identifier appended to it in order to
			// ensure uniqueness.  Hence we must utilize == to see whether the parsed ID is equivalent to the string
			// version and take the appropriate action so that we can properly match the selected component based on
			// the id.
			if(parsedId == menuItemId) { //eslint-disable-line eqeqeq
				toggleComponent(parsedId, menuItemObj.isSelected());
			}
			else {
				toggleComponent(menuItemId, menuItemObj.isSelected());
			}

		};
	};


	//Create a local copy of the component array since we are reordering the component by label
	componentArr = this.getComponents().slice(0);
	componentCnt = componentArr.length;
	//Check to see if any of the components are available for toggle.
	for(x = componentCnt; x--;) {
		component = componentArr[ x ];
		toggleStatus = component.getToggleStatus();
		if(toggleStatus !== 2 && !component.isComponentFiltered()) {
			addMenu = true;
			break;
		}
	}
	//Return if all components are required.  No need for a menu option.
	if(!addMenu) {
		return null;
	}

	//Create the menu
	compSelMenu = new Menu('compSelection' + this.getCategoryMean());
	compSelMenu.setLabel(i18n.COMPONENTS);
	compSelMenu.setIsRootMenu(false);
	compSelMenu.setAnchorConnectionCorner([ 'top', 'left' ]);
	compSelMenu.setContentConnectionCorner([ 'top', 'right' ]);

	//Sort the components by name
	componentArr.sort(componentSort);
	//Add all of the component selection items to the menu
	for(x = 0; x < componentCnt; x++) {
		component = componentArr[ x ];
		if(!component.isComponentFiltered()) {
			//Create the MenuSelector item for this component
			menuItem = new MenuSelection(component.getComponentId().toString());
			menuItem.setCloseOnClick(false);

			//Add the HTML for the element and the click event if it can be toggled
			//lock the required components in the menu so that they cannot be removed from the view
			if(component.getRequiredInd()) {
				menuItem.setLabel(component.getLabel() + ' (' + i18n.LOCKED + ')');
				menuItem.setIsDisabled(true);
				menuItem.setIsSelected(true);
			}
			else {
				menuItem.setLabel(component.getLabel());
				menuItem.setIsSelected(component.getToggleStatus() === 1);
				menuItem.setClickFunction(createSelectionFunc(menuItem));
			}
			compSelMenu.addMenuItem(menuItem);
		}
	}

	//Add the close menu function so the preferences are saved if the user toggles a component
	compSelMenu.setCloseFunction(function() {
		if(componentToggled) {
			//Show the cursor as busy
			$('body').css('cursor', 'wait');

			//This call is used to update all of the component's settings before refreshing the page.
			MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(componentArr); //eslint-disable-line new-cap

			//Refresh the Page or viewpoint
			CERN_Platform.refreshMPage();
		}
	});

	return compSelMenu;
};
/**
 * Implementation of the Partogram Navigator Subsection Summary MPageView object
 */

/**
 * A constructor used to create a new PartogramyNavigatorSubsectionSummaryMPage object and initialize page level variables.
 * @constructor
 */
PartogramNavigatorSubsectionSummaryMPage = function() {
	//Log info for debugger
	logger.logMessage('Rendering Partogram Navigator Subsection View');

	//A flag which will determine if we should load all components or attempt to selectively load components as needed
	this.m_selectiveComponentLoadInd = false;

	//Set page level information
	this.setName('Partogram Navigator Subsection Summary MPage');

	//Set the category mean of the parent workflow page so component subtimers will be associated with the parent instead of the
	// subsection
	this.m_parentWorkflowId = '';
	// Indicates whether a non partogram component is configured to the page
	this.m_anyNonPartogramComponents = false;
};

/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
PartogramNavigatorSubsectionSummaryMPage.prototype = new NavigatorSubsectionSummaryMPage();
PartogramNavigatorSubsectionSummaryMPage.prototype.constructor = NavigatorSubsectionSummaryMPage;

/**
 * Sets the status indicating whether any non partogram component have been configured for this page
 * @param {boolean} anyNonPartogramComponents A boolean value indicating whther any non partogram component has been configured on this page.
 * @returns {void}
 */
PartogramNavigatorSubsectionSummaryMPage.prototype.setAnyNonPartogramComponents = function(anyNonPartogramComponents) {
	this.m_anyNonPartogramComponents = anyNonPartogramComponents;
};

/**
 * Return the status indicating whether any non partogram component have been configured for this page
 * @returns {boolean} true, any non partogram component have been configured for this page
 */
PartogramNavigatorSubsectionSummaryMPage.prototype.isAnyNonPartogramComponents = function() {
	return this.m_anyNonPartogramComponents;
};


/**
 * Gets the array of MPageComponent objects associated to this instance of the MPageView object.
 *
 * @returns {Array} An array of MPageComponent objects.
 */
PartogramNavigatorSubsectionSummaryMPage.prototype.getComponents = function() {
	var components = NavigatorSubsectionSummaryMPage.prototype.getComponents.call(this);
	return components || [];
};

/**
 * This function is used to display the error message in the dialog that there are no components to
 * render the page.
 * @param {Number} errorType A integer value representing the error type
 * @returns {void}
 */
PartogramNavigatorSubsectionSummaryMPage.prototype.showConfigErrorMessage = function(errorType) {
	var partoWFi18n = i18n.discernabu.partogram_navigator_subsection_summary;
	var buttonText = partoWFi18n.CLOSE;
	var title = partoWFi18n.ERROR_OCCURED;
	var errorLogMessage = '';
	var errorMessage = '';
	if (errorType <= 0) {
		errorLogMessage = 'At least one partogram component must be configured along with Partogram Overview component in Bedrock.';
		errorMessage = partoWFi18n.PAGE_ERROR_ACTION_NO_COMP;
	} else {
		errorLogMessage = 'Only partogram components must be configured along with Partogram Overview component in Bedrock.';
		errorMessage = partoWFi18n.PAGE_ERROR_ACTION_NON_PARTO_COMP;
	}
	// Create initial dialog box
	var modalObj = MP_Util.generateModalDialogBody('partogramConfigErrorAlert', 'error', partoWFi18n.PAGE_ERROR, errorMessage);
	var modalButton = modalObj.getFooterButton('modalOkBtn');
	// Create the modal Ok/Close button if it isn't already defined
	if (!modalButton) {
		modalButton = new ModalButton('modalOkBtn');
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true);
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
		modalObj.setHeaderTitle(title);
		modalObj.setFooterButtonText('modalOkBtn', buttonText);
	}
	// Create/launch Modal Dialog Box
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog('partogramConfigErrorAlert');
	logger.logJSError(errorLogMessage, null, 'partogram-navigator-subsection-summary.js', 'showConfigErrorMessage');
};

/**
 * Initialize the components which will be shown within this particular view.
 *
 * @param {array} allComponentSettings - Contains the Component Settings

 * @returns {void}
 */
PartogramNavigatorSubsectionSummaryMPage.prototype.initializeComponents = function(allComponentSettings) {
	var component = null;
	var componentsArr = [];
	var componentCnt = 0;
	var compSettings = null;
	var criterion = null;
	var x = 0;
	var partogramInfoSR;
	var resourceData;
	if (!allComponentSettings || !allComponentSettings.length) {
		this.showConfigErrorMessage(0);
		return;
	}
	if (this.isAnyNonPartogramComponents()) {
		this.showConfigErrorMessage(1);
		return;
	}
	//Load the necessary components based on the component settings
	criterion = this.getCriterion();
	//Update the criterion category_mean so that component will utilize the parent workflow id instead of the subsection generated id
	criterion.category_mean = this.getParentWorkflowIdentifier();
	//sets the partogram user preferences before loading any components
	PARTO_GRAPH_BASE.setUserPreferences(criterion);
	//since shared resource is loaded before navigator subsection, partogram start/end date needs to be set here.
	partogramInfoSR = MP_Resources.getSharedResource('partogramInfo');
	if (partogramInfoSR && partogramInfoSR.isResourceAvailable()) {
		resourceData = partogramInfoSR.getResourceData();
		PARTO_GRAPH_BASE.calculatePartogramStartAndEndTime(resourceData.getPartogramStartDate());
	}
	componentsArr = allComponentSettings;
	componentCnt = componentsArr.length;
	//Initialize the components and add them to the Mpage
	for ( x = 0; x < componentCnt; x++) {
		compSettings = componentsArr[x];
		//Create the component and prepare it for rendering
		//F_MN is shorthand for Filter Mean
		component = this.createMPageComponentObject(compSettings.F_MN);
		if (component) {
			component.initializeComponent(criterion);
			//Set Component Preferences based on bedrock settings and user preferences
			component.loadComponentSettings(compSettings);
			component.loadDisplayFilters();
			component.setAlwaysExpanded(true);
			//Set the component type so we can perform any special actions base on the workflow type
			component.getStyles().setComponentType(CERN_COMPONENT_TYPE_WORKFLOW);
			//Move components defined for the second and third columns to the end of the first column.
			if (component.getColumn() > 1) {
				//Using the * 100 to make sure the components are shown after the components defined to show
				// in the columns left of the current column.
				component.setSequence(component.getColumn() * 100 + component.getSequence());
				component.setColumn(1);
			}
			//Determine if the components should be displayed or not based on the view builder settings
			if (component.getToggleStatus() === 0) {
				component.setDisplayEnabled(false);
			}
			//Create the component menu
			component.createMainMenu();
			component.preProcessing();
			this.addComponent(component);
			//R_ID is shorthand for Report Id(br_datamart_report_id)
			this.addComponentId(componentsArr[x].R_ID);
		}
	}
};
PregnancyNavigatorSubsectionSummaryMPage=function(){MP_Util.LogInfo("Rendering Pregnancy Navigator Subsection View");
this.m_selectiveComponentLoadInd=false;
this.setName("Pregnancy Navigator Subsection Summary MPage");
this.m_parentWorkflowId="";
this.m_lookBack=0;
this.m_isPatientPregnant=false;
};
PregnancyNavigatorSubsectionSummaryMPage.prototype=new NavigatorSubsectionSummaryMPage();
PregnancyNavigatorSubsectionSummaryMPage.prototype.constructor=NavigatorSubsectionSummaryMPage;
PregnancyNavigatorSubsectionSummaryMPage.prototype.setPregnancyLookBack=function(lookBack){this.m_lookBack=lookBack;
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.setIsPatientPregnant=function(isPatientPregnant){this.m_isPatientPregnant=isPatientPregnant;
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.getPregnancyLookBack=function(){return this.m_lookBack;
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.isPatientPregnant=function(){return this.m_isPatientPregnant;
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.getComponents=function(){var components=NavigatorSubsectionSummaryMPage.prototype.getComponents.call(this);
return components||[];
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.showErrorMessage=function(){var pregSummaryMPagei18n=i18n.discernabu.pregnancy_navigator_subsection_summary;
var buttonText=pregSummaryMPagei18n.CLOSE;
var title=pregSummaryMPagei18n.ERROR_OCCURED;
var errorLogMessage="At least one pregnancy component must be configured along with Add Pregnancy component in bedrock.";
var modalObj=MP_Util.generateModalDialogBody("noComponentErrorAlert","error",pregSummaryMPagei18n.PAGE_ERROR,pregSummaryMPagei18n.PAGE_ERROR_ACTION);
var modalButton=modalObj.getFooterButton("modalOkBtn");
if(!modalButton){modalButton=new ModalButton("modalOkBtn");
modalButton.setText(buttonText);
modalButton.setFocusInd(true);
modalObj.addFooterButton(modalButton);
modalObj.setShowCloseIcon(false);
modalObj.setHeaderTitle(title);
modalObj.setFooterButtonText("modalOkBtn",buttonText);
}MP_ModalDialog.updateModalDialogObject(modalObj);
MP_ModalDialog.showModalDialog("noComponentErrorAlert");
var noComponentsError=new Error(errorLogMessage);
MP_Util.LogJSError(noComponentsError,null,"pregnancy-navigator-subsection-summary_i18n.js","initializeComponents");
};
PregnancyNavigatorSubsectionSummaryMPage.prototype.initializeComponents=function(allComponentSettings){var component=null;
var componentsArr=[];
var componentCnt=0;
var compSettings=null;
var criterion=null;
var pageSettings=null;
var x=0;
var scopeAllEncntrs=1;
if(!allComponentSettings||!allComponentSettings.length){this.showErrorMessage();
return;
}criterion=this.getCriterion();
criterion.category_mean=this.getParentWorkflowIdentifier();
componentsArr=allComponentSettings;
componentCnt=componentsArr.length;
for(x=0;
x<componentCnt;
x++){compSettings=componentsArr[x];
component=this.createMPageComponentObject(compSettings.F_MN);
if(component){component.initializeComponent(criterion);
if(this.isPatientPregnant()&&component.getPregnancyLookbackInd()){compSettings.LB_TYP=2;
compSettings.LB_UNT=this.getPregnancyLookBack();
compSettings.SCP=scopeAllEncntrs;
}component.loadComponentSettings(compSettings);
component.loadDisplayFilters();
component.setAlwaysExpanded(true);
component.getStyles().setComponentType(CERN_COMPONENT_TYPE_WORKFLOW);
if(component.getColumn()>1){component.setSequence(component.getColumn()*100+component.getSequence());
component.setColumn(1);
}if(component.getToggleStatus()===0){component.setDisplayEnabled(false);
}component.createMainMenu();
component.preProcessing();
this.addComponent(component);
this.addComponentId(componentsArr[x].R_ID);
}}};
/*globals PREGNANCY_BASE_UTIL_O1*/

/**
 * A constructor used to create a new ViewBuilderMPage object and initialize page level variables.
 * @constructor
 */
var ViewBuilderMPage = function() {
	//Log info for debugger
	logger.logMessage("Rendering View Builder MPages View");

	//Set page level information
	this.setName("MPages View");
};
/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
ViewBuilderMPage.prototype = new MPageView();
ViewBuilderMPage.prototype.constructor = MPageView;

/**
 * This function will call the base class initializeComponent, so that all the components are initialized correctly.  Once that
 * returns the components which have a toggleStatus of 0 (off), are set to not display in the MPageView.
 * @returns {undefined} This function does not return a value
 */
ViewBuilderMPage.prototype.initializeComponents = function() {
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var x = 0;

	//Call the base function to initialize the components.
	MPageView.prototype.initializeComponents.call(this, null);

	//Filter out the components based on the component toggle settings.
	componentArr = this.getComponents();
	componentCnt = componentArr.length;
	for (x = componentCnt; x--;) {
		component = componentArr[x];
		if (component.getToggleStatus() === 0) {
			component.setDisplayEnabled(false);
		}
	}
};
/**
 * Implementation for loading the component selection menu.  Components with a toggle status of 0(off) or 1(on) will
 * be added to the component selection menu.
 * @returns {Menu} The Menu item created for the component selection menu
 */
ViewBuilderMPage.prototype.loadComponentSelection = function() {
	var addMenu = false;
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var componentToggled = false;
	var compSelMenu = null;
	var menuItem = null;
	var that = this;
	var toggleStatus = 0;
	var x = 0;

	//This function is used to sort the available component in alphabetical order based on the component Label
	var componentSort = function(a, b) {
		var aName = a.getLabel().toUpperCase();
		var bName = b.getLabel().toUpperCase();
		if (aName < bName) {
			return -1;
		}
		else if (aName > bName) {
			return 1;
		}
		else {
			return 0;
		}
	};

	//This function is used to toggle the component on/off and make the necessary updates to all of the component sequences
	var toggleComponent = function(componentId, activateComp) {
		var pageGroupSeq = null;
		var toggleComp = null;
		//1 - on, 0 - off
		var toggleStatus = activateComp ? 1 : 0;
		var z = 0;

		//Set the toggle status for the component selected from the component selection menu
		//Locate the component we are toggling and updates its location
		for (z = componentCnt; z--;) {
			component = componentArr[z];
			//Check to see if this is the component we are toggling
			if (component.getComponentId() === componentId) {
				toggleComp = component;
				toggleComp.setToggleStatus(toggleStatus);
				if (activateComp) {
					//Add the component as the first component in the left most column
					//If the component is an organizer level component, column 99, do not update the column
					if (toggleComp.getColumn() !== 99) {
						toggleComp.setColumn(1);
					}
					toggleComp.setSequence(0);
					//Check to see if user preferences exist and if not create the blank object
					if (!MP_Core.AppUserPreferenceManager.GetPreferences()) {
						MP_Core.AppUserPreferenceManager.SetPreferences('{"user_prefs":{"page_prefs":{"components":[]}}}');
					}
				}
				break;
			}
		}

		//Update the sequences/rows for all of the components in the same colgroup and column as the toggled component.
		if (activateComp) {
			pageGroupSeq = toggleComp.getPageGroupSequence();
			for (z = componentCnt; z--;) {
				component = componentArr[z];
				//Move all of the other components in the first column down one row
				if (component.getColumn() === 1 && component.getPageGroupSequence() === pageGroupSeq && component !== toggleComp) {
					component.setSequence(component.getSequence() + 1);
				}
			}
		}
	};

	//This function is used when an element is selected in the component selection menu.
	var createSelectionFunc = function(menuItemObj) {
		return function() {
			componentToggled = true;
			toggleComponent(parseFloat(menuItemObj.getId(), 10), menuItemObj.isSelected());
		};
	};

	//Check to see if any of the components are available for toggle.
	componentArr = this.getComponents();
	componentCnt = componentArr.length;
	for (x = componentCnt; x--;) {
		component = componentArr[x];
		toggleStatus = component.getToggleStatus();
		if (toggleStatus !== 2 && !component.isComponentFiltered()) {
			addMenu = true;
			break;
		}
	}
	//Return if all components are required.  No need for a menu option.
	if (!addMenu) {
		return null;
	}

	//Create the menu
	compSelMenu = new Menu("compSelection" + this.getCategoryMean());
	compSelMenu.setLabel(i18n.COMPONENTS);
	compSelMenu.setIsRootMenu(false);
	compSelMenu.setAnchorConnectionCorner(["top", "left"]);
	compSelMenu.setContentConnectionCorner(["top", "right"]);

	//Sort the components by name
	componentArr.sort(componentSort);
	//Add all of the component selection items to the menu
	for (x = 0; x < componentCnt; x++) {
		component = componentArr[x];
		if (!component.isComponentFiltered()) {
			toggleStatus = component.getToggleStatus();
			//Create the MenuSelector item for this component
			menuItem = new MenuSelection(component.getComponentId().toString());
			menuItem.setCloseOnClick(false);

			//Add the HTML for the element and the click event if it can be toggled
			if (toggleStatus === 2) {
				menuItem.setLabel(component.getLabel() + " (" + i18n.LOCKED + ")");
				menuItem.setIsDisabled(true);
				menuItem.setIsSelected(true);
			}
			else {
				menuItem.setLabel(component.getLabel());
				menuItem.setIsSelected(toggleStatus === 1 ? true : false);
				menuItem.setClickFunction(createSelectionFunc(menuItem));
			}
			compSelMenu.addMenuItem(menuItem);
		}
	}

	//Add the close menu function so the preferences are saved if the user toggles a component
	compSelMenu.setCloseFunction(function() {
		if (componentToggled) {
			var criterion = that.getCriterion();
			//Show the cursor as busy
			$('body').css('cursor', 'wait');

			//This call is used to update all of the component's settings before refreshing the page.
			MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(componentArr);

			//Refresh the Page or viewpoint
			CERN_Platform.refreshMPage();
		}
	});
	
	return compSelMenu;
};

MP_Util.setObjectDefinitionMapping("SUM_STD",ViewBuilderMPage);
/**
 * Implementation of the CPM Navigator Subsection Summary MPageView object
 */

/**
 * A constructor used to create a new CPMNavigatorSubsectionSummaryMPage object and initialize page level variables.
 * @constructor
 */
CPMNavigatorSubsectionSummaryMPage = function() {
	//Log info for debugger
	logger.logMessage("Rendering CPM Navigator Subsection View");

	//A flag which will determine if we should load all components or attempt to selectively load components as needed
	this.m_selectiveComponentLoadInd = false;

	//Set page level information
	this.setName("CPM Navigator Subsection Summary MPage");

	//Set the category mean of the parent workflow page so component subtimers will be associated with the parent instead of the
	// subsection
	this.m_parentWorkflowId = "";
};

/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
CPMNavigatorSubsectionSummaryMPage.prototype = new NavigatorSubsectionSummaryMPage();
CPMNavigatorSubsectionSummaryMPage.prototype.constructor = NavigatorSubsectionSummaryMPage;

CPMNavigatorSubsectionSummaryMPage.prototype.getCPMResource = function(){
	return this.m_cpmResource;
};

CPMNavigatorSubsectionSummaryMPage.prototype.setCPMResource = function(cpmResource){
	this.m_cpmResource = cpmResource;
};

/**
 * Gets the array of MPageComponent objects associated to this instance of the MPageView object.
 * @returns {[MPageComponent]} An array of MPageComponent objects.
 */
CPMNavigatorSubsectionSummaryMPage.prototype.getComponents = function() {
	var components = NavigatorSubsectionSummaryMPage.prototype.getComponents.call(this);
	return components || [];
};

/**
 * This function is used to display the error message in the dialog that there are no components to render the page.
 * @returns undefined
 */
CPMNavigatorSubsectionSummaryMPage.prototype.showErrorMessage = function() {
	var cpmSummaryMPagei18n = i18n.discernabu.CPM_navigator_subsection_summary;
	var buttonText = cpmSummaryMPagei18n.CLOSE;
	var title = cpmSummaryMPagei18n.ERROR_OCCURED;
	var errorLogMessage = "At least one component must be configured for this CPM.";

	// Create initial dialog box
	var modalObj = MP_Util.generateModalDialogBody("noComponentErrorAlert", "error", cpmSummaryMPagei18n.PAGE_ERROR, cpmSummaryMPagei18n.PAGE_ERROR_ACTION);

	var modalButton = modalObj.getFooterButton("modalOkBtn");

	// Create the modal Ok/Close button if it isn't already defined
	if (!modalButton) {
		modalButton = new ModalButton("modalOkBtn");
		modalButton.setText(buttonText);
		modalButton.setFocusInd(true);
		modalObj.addFooterButton(modalButton);
		modalObj.setShowCloseIcon(false);
		modalObj.setHeaderTitle(title);
		modalObj.setFooterButtonText("modalOkBtn", buttonText);
	}

	// Create/launch Modal Dialog Box
	MP_ModalDialog.updateModalDialogObject(modalObj);
	MP_ModalDialog.showModalDialog("noComponentErrorAlert");

	var noComponentsError = new Error(errorLogMessage);
	logger.logJSError(noComponentsError, null, "CPM-navigator-subsection-summary.js", "initializeComponents");
};

/**
 * Initialize the components which will be shown within this particular view.
 * @param {array} allComponentSettings - Contains the Component Settings
 * @returns null
 */
CPMNavigatorSubsectionSummaryMPage.prototype.initializeComponents = function(response) {
    var component = null;
    var criterion;
    var controller;
    var compConstructor;
    var allComponentsList = [];
    var componentCount;
    var nodeList = response.NODE_LIST || [];
    var conceptList = response.CONCEPT_LIST || [];
    var conceptCount = conceptList.length;
    var conceptGroupList = (conceptCount >= 1) ? conceptList[0].CG_LIST : [];
    var conceptGroupCount = conceptGroupList.length;
    var nodeComponentList = (nodeList.length >= 1) ? nodeList[0].COMPONENT_LIST : []; //TODO: We should loop through nodeList to find correct node based on intention cd (TREATMENTS)
    var nodeComponentCount = nodeComponentList.length;
    var conceptGroupCd = 0;
    var cpmComponentSettings = {};
    var conceptGroupMap = {};
    var cpmConstructorMean;
    var nodeSettings;
    var conceptGroupSettings;
    var i;
    //arbitrary high sequence and group for use when no sequence or group data is available
	var defaultSequence = 900;
	var defaultGroup = 900;
	
    if((!nodeList || !nodeList.length) && (!conceptList || !conceptList.length)){
    	this.showErrorMessage();
		return;
    }
    
	var conceptCd = conceptList[0].CONCEPT_CD || nodeList[0].CONCEPT_CD;
	var conceptDisp = response.PATHWAY_NAME;
	var pathwayId = response.PATHWAY_ID;
	var nodeId = nodeList[0].CP_NODE_ID;

    //Loop through nodeComponentList first
    for (i = 0; i < nodeComponentCount; i++){
        cpmComponentSettings = {};
        cpmComponentSettings.NODE_SETTINGS = nodeComponentList[i];
        allComponentsList.push(cpmComponentSettings);
        conceptGroupCd = nodeComponentList[i].CONCEPT_GROUP_CD;
        if (conceptGroupCd > 0){
            //Add the concept group plus index to the map for future reference
            conceptGroupMap[conceptGroupCd] = i;
        }
    }

    //Loop through conceptGroupList now
    for (i = 0; i < conceptGroupCount; i++){
        conceptGroupCd = conceptGroupList[i].CONCEPT_GROUP_CD;
        //Try to find existing config
        var conceptGroupIndex = conceptGroupMap[conceptGroupCd];
        if (conceptGroupIndex >= 0){
            //Found a match!  Update existing list of components
            cpmComponentSettings = allComponentsList[conceptGroupIndex];
            cpmComponentSettings.CG_SETTINGS = conceptGroupList[i];
        } else {
            //Didn't find a match.  Add component to existing list
            cpmComponentSettings = {};
            cpmComponentSettings.CG_SETTINGS = conceptGroupList[i];
            allComponentsList.push(cpmComponentSettings);
        }
    }

    criterion = this.getCriterion();
    criterion.category_mean = this.getParentWorkflowIdentifier();
    //Now instantiate the components
    componentCount = allComponentsList.length;
    controller = new CPMController();
    controller.setConceptConfig(conceptGroupList);
	var intentionCd = nodeList[0].INTENTION_CD;
	var intentionMeaning = nodeList[0].INTENTION_CD_MEANING;
	var cpComponentId = 0;
	var conceptGroupCd = 0;
	var conceptGroupCompSettings = [];
	var componentConfig = null;
	
    for (i = 0; i < componentCount; i++){
		cpmConstructorMean = "";
		conceptGroupCompSettings = [];
        cpmComponentSettings = allComponentsList[i];
        //Going to use the node_list component identifier first, then concept_group list
        nodeSettings = cpmComponentSettings.NODE_SETTINGS;
        conceptGroupSettings = cpmComponentSettings.CG_SETTINGS;
		if (conceptGroupSettings) {
			conceptGroupCompSettings.push(conceptGroupSettings);
			componentConfig = conceptGroupSettings;
		}
        if (nodeSettings){
            cpmConstructorMean = nodeSettings.COMP_TYPE_CD_MEANING || nodeSettings.CONCEPT_GROUP_CD_MEANING;
            cpComponentId = nodeSettings.CP_COMPONENT_ID;
			conceptGroupCd = nodeSettings.CONCEPT_GROUP_CD;
			componentConfig = nodeSettings;
        }
        if (!cpmConstructorMean && conceptGroupSettings){
            cpmConstructorMean = conceptGroupSettings.CONCEPT_GROUP_CD_MEAN;
        }
        //We don't have a constructor identifier... skip to the next component
        if (!cpmConstructorMean){
            continue;
        }
        //Grab the constructor!
        compConstructor = controller.getConstructorByMeaning(cpmConstructorMean);
        //If we don't have a constructor, the component must not exist. Gracefully move to the next component (and maybe log a message)
        if (!compConstructor){
            //TODO: log to blackbird
            continue;
        }
        //Set up our component
        component = new compConstructor();
        component.initializeComponent(criterion);
		component.setIntentionCd(intentionCd);
		component.setIntentionMean(intentionMeaning);
		component.setConceptCd(conceptCd);
		component.setConceptMean("" + conceptCd);
		component.setConceptDisp(conceptDisp);
		component.setAlwaysExpanded(true);
		component.setCpComponentId(cpComponentId);
		component.setComponentId(conceptCd + "_" + i);
		component.setNodeId(nodeId);
		component.setPathwayId(pathwayId);
		component.setConceptGroupCd(conceptGroupCd);
		component.setComponentConfig(cpmComponentSettings);
        component.processComponentConfig(componentConfig, conceptGroupCompSettings);
        component.setAlwaysExpanded(true);
		
		if(nodeSettings){
			if (nodeSettings.ROW != 0 && nodeSettings.GROUP != 0 && nodeSettings.COLUMN != 0){
				component.setSequence(nodeSettings.ROW); 
				component.setPageGroupSequence(nodeSettings.GROUP);
				component.setColumn(nodeSettings.COLUMN);
			}else{
				// set sequence to a high sequence if there is no sequence available
				component.setSequence(defaultSequence);
				//increment to prevent multiple components with the same sequence
				defaultSequence ++;
				component.setPageGroupSequence(defaultGroup);
				component.setColumn(1);
			}
		}
       	
        
        if (component.getToggleStatus() === 0) {
            component.setDisplayEnabled(false);
        }
        component.createMainMenu();
        component.preProcessing();
        this.addComponent(component);
    }
};
/*globals PREGNANCY_BASE_UTIL_O1*/

/**
 * A constructor used to create a new ViewBuilderPregnancySummary object and initialize page level variables.
 * @constructor
 */
var ViewBuilderPregnancySummary = function() {
	//Log info for debugger
	logger.logMessage("Rendering View Builder Pregnancy Summary View");

	//Set page level information
	this.setName("Pregnancy Summary View");
};

/**
 * Setup the prototype and constructor to inherit from the base ViewBuilderMPage
 */
ViewBuilderPregnancySummary.prototype = new ViewBuilderMPage();
ViewBuilderPregnancySummary.prototype.constructor = ViewBuilderMPage;

/**
 * Loads and stores the settings by calling the base class's loadViewSettings.
 * It will also attempt loading the pregnancy data.
 * @returns {boolean} True if the page settings were loaded successfully, false otherwise
 */
ViewBuilderPregnancySummary.prototype.loadViewSettings = function() {
	var isSuccessfulLoad = ViewBuilderMPage.prototype.loadViewSettings.call(this, null);
	if (isSuccessfulLoad) {
		//per a bedrock setting this is intended to be a pregnancy page, so load the pregnancy data now
		var pregInfoSR = MP_Resources.getSharedResource("pregnancyInfo");

		// Load the pregnancy data if and only if pregnancyInfo shared resource object is not available to use
		/*eslint-disable no-empty*/
		if (pregInfoSR && pregInfoSR.isResourceAvailable()) {
			// pregnancyInfo shared resource object is available to use - Do Nothing
		}
		//check existence of namespace to ensure passivity
		else if ( typeof PREGNANCY_BASE_UTIL_O1 !== "undefined") {
			// Kick off the pregnancyInfo data retrieval
			// Load the current pregnancy information stored it in a shared resource
			PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(this.getCriterion(), false);
		}
		/*eslint-enable no-empty*/
		return true;
	}
	return false;
};

/**
 * This function will call the base class's initializeComponent to initialize all the components.
 * If the patient is pregnancy, it will override the lookback ranges on the components that allow special pregnancy settings.
 * @returns {undefined} This function does not return a value
 */
ViewBuilderPregnancySummary.prototype.initializeComponents = function() {
	var component = null;
	var componentArr = null;
	var componentCnt = 0;
	var pregInfoSR = null;
	var pregInfoObj = null;
	var pregID = 0;
	var daysUnitType = 2;
	var lookBackDays = 0;
	var scopeAllEncntrs = 1;

	//Call the base function to initialize the components.
	ViewBuilderMPage.prototype.initializeComponents.call(this, null);

	//retrieve pregnancy shared resource data
	pregInfoSR = MP_Resources.getSharedResource("pregnancyInfo");
	if (pregInfoSR) {
		pregInfoObj = pregInfoSR.getResourceData();
		pregID = pregInfoObj.getPregnancyId();
		lookBackDays = pregInfoObj.getLookBack();
	}
	//Filter out the components based on the component toggle settings.
	componentArr = this.getComponents();
	componentCnt = componentArr.length;

	//if this patient is pregnant
	if (pregInfoObj && pregID > 0) {
		for (var x = componentCnt; x--; ) {
			component = componentArr[x];

			/*confirm that the component intends to respect the onset date of the pregnancy as the data retrieval lookback*/
			if (component.getPregnancyLookbackInd()) {
				//override the bedrock default values with the pregnancy onset date
				component.setLookbackUnitTypeFlag(daysUnitType);
				component.setScope(scopeAllEncntrs);
				component.setLookbackUnits(lookBackDays);
			}
		}
	}

};

MP_Util.setObjectDefinitionMapping("SUM_PREG", ViewBuilderPregnancySummary);
/*globals MenuItem, MenuSeparator*/
/**
 * The WorkflowView object
 * @constructor
 * @author Steven Lewis
 */
function WorkflowView(){ //eslint-disable-line no-redeclare

	/*Variables*/
	/*eslint-disable mp-camelcase*/
	this.m_activeSubsection = null;
	this.m_navigatorSubsections = null;
	this.m_offsetPositionObj = null;
	this.m_$parentWorkflowContainer = null;
	this.m_$workflowContainer = null;
	this.m_$navContainer = null;
	this.m_$viewContainer = null;
	/*eslint-enable mp-camelcase*/
}

/*Inherit from the MPagesView object*/
WorkflowView.prototype = new MPageView();
WorkflowView.prototype.constructor = MPageView;

/** Adders **/

/**
 * Adds a new NavigatorSubsection object to the listing of subsection objects.
 * @param {NavigatorSubsection} subsectionObj The NavigatorSubsection object to add to the array.
 * @returns {undefined} This function does not return a value
 **/
WorkflowView.prototype.addNavigatorSubsection = function(subsectionObj) {
	if(!this.m_navigatorSubsections) {
		this.m_navigatorSubsections = [];
	}
	this.m_navigatorSubsections.push(subsectionObj);
};

/**
 * This function is to scroll back to the actual offsets of the WorkflowView
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.applyOffsetPosition = function() {
	//Grab the currently active subsection and save its offset position
	var activeSubsection = this.getActiveSubsection();
	if(activeSubsection){
		activeSubsection.applyViewOffsetPosition();
	}
};

/** Getters **/

/**
 * Gets the active NavigatorSubsection within the WorkflowView
 * @returns {NavigatorSubsection} The current active NavigatorSubsection
 */
WorkflowView.prototype.getActiveSubsection = function() {
	return this.m_activeSubsection;
};

/**
 * Returns the NavigatorSubsection object that should be loaded as the default when this workflow is rendered
 * @returns {NavigatorSubsection} The subsection that this workflow should render as a default
 */
WorkflowView.prototype.getDefaultSubsection = function() {
	var savedSubsectionId = this.getSavedSubsectionIdFromCookie();
	var subsectionArr = this.m_navigatorSubsections;
	var subsectionCount = 0;
	var x = 0;
	if(subsectionArr && subsectionArr.length) {
		if(savedSubsectionId){
			//Since we have a saved subsection look for it in our array of subsections
			subsectionCount = subsectionArr.length;
			for (x = 0; x < subsectionCount; x++){
				if(subsectionArr[x].getSubsectionId() === savedSubsectionId){
					return subsectionArr[x];
				}
			}
		}

		//just return the first subsection if we dont have one stored for the session or it was removed
		return this.m_navigatorSubsections[ 0 ];
	}
	return null;
};

/**
 * Gets the array of NavigatorSubsection objects associated to this WorkflowView.
 * @returns {NavigatorSubsection[]} An array of NavigatorSubsection objects
 */
WorkflowView.prototype.getNavigatorSubsections = function() {
	return this.m_navigatorSubsections;
};

/**
 * This function is to save the vertical scroll offsets of the currently active subsection in the WorkflowView
 *  @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.saveOffsetPosition = function() {
	//Grab the currently active subsection and save its offset position
	var activeSubsection = this.getActiveSubsection();
	if(activeSubsection){
		activeSubsection.saveViewOffsetPosition();
	}
};

/**
 * This function attempts to retrieve the last active subsection identifier from the session cookie.
 * @returns {string} The last active subsection for this session or null
 */
WorkflowView.prototype.getSavedSubsectionIdFromCookie = function(){
	var criterion = this.getCriterion();
	var personId = criterion.person_id;
	var encounterId = criterion.encntr_id;
	return MP_Util.GetCookieProperty(this.getCategoryMean(), 'LAST_ACTIVE_SUBSECTION|' + personId + '|' + encounterId); //eslint-disable-line new-cap
};

/** Setters **/


/**
 * This function saves the subsection id in a cookie so we can reactivate the same subsection on reload.
 * @param {string} subsectionId The subsection object whose id we are storing.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.saveSubsectionIdInCookie = function(subsectionId){
	var criterion = this.getCriterion();
	var personId = criterion.person_id;
	var encounterId = criterion.encntr_id;
	MP_Util.AddCookieProperty(this.getCategoryMean(), 'LAST_ACTIVE_SUBSECTION|' + personId + '|' + encounterId, subsectionId); //eslint-disable-line new-cap
	MP_Util.WriteCookie(); //eslint-disable-line new-cap
};


/**
 * Sets the active NavigatorSubsection within the WorkflowView
 * @param {NavigatorSubsection} subsectionObj The navigatorSubsection object which is currently active
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.setActiveSubsection = function(subsectionObj) {
	this.m_activeSubsection = subsectionObj;
};

/**
 * Sets the array of NavigatorSubsection objects associated to this WorkflowView.
 * @param {NavigatorSubsection[]} subsectionArr An array NavigatorSubsection objects to set for the WorkflowView.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.setNavigatorSubsections = function(subsectionArr) {
	this.m_navigatorSubsections = subsectionArr;
};

/** Workflow Setup Functions **/

/**
 * Creates and initializes the NavigatorSubsection objects which will be a part of this Workflow View.  Once the subsections have
 * been created they are initialized with the associated settings and then the MPagesView which will be associated with that
 * subsection is created.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.initializeComponents = function() {
	var criterion = null;
	var subsectionArr = [];
	var subsectionCnt = 0;
	var subsection = null;
	var subsectionSettings = null;
	var viewSettings = this.getViewSettings();
	var x = 0;

	//Retrieve the subsection settings and criterion
	subsectionSettings = this.getComponentSettings(viewSettings);
	criterion = this.getCriterion();
	//Determine which subsections will be a part of this workflow and instantiate them
	this.createNavigatorSubsectionObjects(viewSettings);
	subsectionArr = this.getNavigatorSubsections();
	subsectionCnt = subsectionArr.length;
	//Loop through each subsection and initialize it.
	for(x = 0; x < subsectionCnt; x++) {
		subsection = subsectionArr[x];
		//Initialize the subsections by passing all of the component settings to the subsection.  The subsection
		//will determine which components to use.
		subsection.initializeSubsection(criterion);
		//Load the necessary MPageView settings for the subsection if needed
		if(subsection.hasAssociatedView()) {
			//Set the subsections view id so it can be used as the category mean for the associated view
			subsection.setAssociatedViewElementId(this.getCategoryMean() + '_ssView_' + x);
			if(!subsectionSettings){
				subsectionSettings = viewSettings;
			}
			subsection.createAssociatedMPageView(subsectionSettings);
		}
		//subsection will be rendered during the workflow loading
	}
};

/**
 * This function is to retrieve the component's view settings
 * @param {{}} viewSettings - Settings needed to render the components for the specified view
 * @returns {{}} viewSettings.BR_SET.CS if it exists, else null.
 */
WorkflowView.prototype.getComponentSettings = function(viewSettings) {
	if(viewSettings && viewSettings.BR_SET && viewSettings.BR_SET.CS.length){
		//Retrieve the subsection settings and criterion
		return viewSettings.BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for component settings
	}
	return null;
};

/**
 * Creates the overall HTML structure for the Workflow view.  Once the structure has been created, HTML is created for each of the
 * subsections associated with this Workflow view.  Once all of the subsections have been rendered, the active subsection is
 * activated using the WorkflowView.activeSubsection function.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.renderView = function() {
	var bodyId = '';
	//this buffer is used for the height of the view elements so we dont run into ceil/floor issues in different browsers
	var buffer = 2;
	var categoryMean = this.getCategoryMean();
	var containerHeight = 0;
	var headerId = '';
	var self = this;
	var subsection = null;
	var subsectionArr = null;
	var subsectionElement = null;
	var subsectionElementId = '';
	var subsectionCnt = 0;
	var workflowContainer = null;
	var workflowNav = null;
	var workflowViews = null;
	var x = 0;

	//Check to see if this view is even valid in the current context.
	if(!this.isContextValid()){
		//The current context is not valid for this view so we need to show a context error message
		this.displayInvalidContextMessage();
		return;
	}

	//A function used to create onclick functions for the subsection dom elements.
	function createActivationFunction(subsectionObj) {
		return function() {
			//Active the new subsection
			self.activateSubsection(subsectionObj);
		};
	}

	workflowContainer = this.m_$workflowContainer = $('#' + this.getCategoryMean()); //eslint-disable-line mp-camelcase
	this.m_$parentWorkflowContainer = this.m_$workflowContainer.parent(); //eslint-disable-line mp-camelcase

	//create the three main workflow html containers
	workflowNav = this.m_$navContainer = $('<div></div>').addClass('wrkflw-nav wf').attr('id', 'wrkflwNav_' + categoryMean); //eslint-disable-line mp-camelcase
	workflowViews = this.m_$viewContainer = $('<div></div>').addClass('wrkflw-views wf').attr('id', 'wrkflwViews_' + categoryMean); //eslint-disable-line mp-camelcase

	//Loop through the subsections and render the HTMl for each
	subsectionArr = this.getNavigatorSubsections();
	subsectionCnt = subsectionArr.length;
	for(x = 0; x < subsectionCnt; x++) {
		subsection = subsectionArr[x];

		//Create the Navigator subsection element for this subsection
		subsectionElementId = categoryMean + '_ssContainer_' + x;
		subsection.setSubsectionElementId(subsectionElementId);
		subsectionElement = $('<div></div>').addClass('wrkflw-nav-subsec').attr('id', subsectionElementId);

		//Check to see if the subsection should always be expanded
		if(subsection.isAlwaysExpanded()){
			subsectionElement.addClass('wrkflw-nav-subsec-always-expanded');
		}

		//Attach the activation function for the subsection
		subsectionElement.click(createActivationFunction(subsection));
		if(subsection.hasHeaderElement()) {
			//Encapsulate the header html so we can apply a workflow level styling to it
			headerId = categoryMean + '_ssHead_' + x;
			subsection.setHeaderElementId(headerId);
			$(subsectionElement).append($('<div></div>').addClass('navi-subsec-header').attr('id', headerId).append(subsection.generateHeaderHTML()));

		}
		if(subsection.hasBodyElement()) {
			//Encapsulate the body html so we can apply a workflow level styling to it
			bodyId = categoryMean + '_ssBody_' + x;
			subsection.setBodyElementId(bodyId);
			subsectionElement.append($('<div></div>').addClass('navi-subsec-body').attr('id', bodyId).append(subsection.generateBodyHTML()));
		}
		workflowNav.append(subsectionElement);
		//Create the subsection's associated MPageView element if necessary
		if(subsection.hasAssociatedView()) {
			var assocViewId = categoryMean + '_ssView_' + x;
			workflowViews.append($('<div></div>').addClass('wrkflw-view').attr('id', assocViewId));
			//Let the subsection know where the associated view is located in the DOM
			subsection.setAssociatedViewElementId(assocViewId);
		}
	}
	//Combine all of the workflow elements and add to the DOM
	workflowContainer.append(workflowNav).append(workflowViews);

	//Resize the workflow containers to fit the available screen size before rendering the first subsection
	//Force the DOM to render so we know for sure the size of the container will be ready for us to key off of
	containerHeight = this.m_$parentWorkflowContainer.height();
	workflowNav.height(containerHeight - buffer);
	workflowViews.height(containerHeight - buffer);

	//Determine which subsection is active and make the calls to render its Associated MPagesView
	subsection = self.getDefaultSubsection();
	setTimeout(function() {
		self.activateSubsection(subsection);
	}, 10);
};

/**
 * This function is used to resize certain containers for the workflow layout in order to achieve scrolling on only
 * the associated view of the subsections.  A buffer of 2px is removed from the calculations to prevent ceiling and
 * floor variances in different browser versions.  Once the containers have been resized, the applyNavigatorScrolling
 * function is called to apply the scrolling effect there if needed.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.resizeView = function() {
	var containerHeight = 0;
	var self = this;
	//this buffer is used for the height of the view elements so we dont run into ceil/floor issues in different browsers
	var buffer = 2;

	try {
		//Get WorkflowView container and its height
		containerHeight = this.m_$parentWorkflowContainer.height();
		this.m_$navContainer.height(containerHeight - buffer);
		this.m_$viewContainer.height(containerHeight - buffer);

		//Apply the scrolling to the navigator container if necessary
		this.applyNavigatorScrolling();

		//Fire the resize function for the currently active subsection
		setTimeout(function() {
			self.getActiveSubsection().resizeSubsection();
		}, 10);
	}
	catch(err) {
		logger.logJSError(err, null, 'base-workflow-def.js', 'resizeView');
		throw (err);
	}
};

/**
 * This function examines the height of the content within the workflow navigator element.  If those contents are larger
 * than what can be displayed in the viewable window then scrolling elements are added at the top and bottom of the navigator
 * so the use can hover over them and scroll.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.applyNavigatorScrolling = function() {
	var containerHeight = 0;
	var scrollerHeight = (CERN_Platform.isTouchModeEnabled()) ? 76 : 36;
	var totalHeight = 0;
	var workflowNavEle = null;
	//this buffer is used for the height of the view elements so we dont run into ceil/floor issues in different browsers
	var buffer = 2;

	//Define the scrolling function and the associated variables
	var scrollUp = 1;
	var scrollDown = 2;
	var scrollTimer = null;

	function scrollNavigator(direction, scrollDistance) {
		scrollDistance = scrollDistance || 10;
		if(direction === scrollUp) {
			//Scroll the navigator container up
			$(workflowNavEle).scrollTop($(workflowNavEle).scrollTop() - scrollDistance);
		}
		else {
			//Scroll the navigator container down
			$(workflowNavEle).scrollTop($(workflowNavEle).scrollTop() + scrollDistance);
		}
	}

	//Get WorkflowView container and its height
	containerHeight = this.m_$parentWorkflowContainer.height();
	workflowNavEle = this.m_$navContainer;

	//Check to see if the content we have for the navigator are larger than the viewing area and add the scrollers if necessary.
	workflowNavEle.children(':not(.wrkflw-nav-up):not(.wrkflw-nav-down)').each(function() {
		totalHeight += $(this).outerHeight();
	});

	if(totalHeight > containerHeight) {
		//Check to see if the scrollers are already available.
		if(!workflowNavEle.find('.wrkflw-nav-up').length) {
			//Add the navigator scroll up element
			workflowNavEle.prepend($('<div><div>&nbsp;</div></div>')
				.addClass('wrkflw-nav-up')
				.hover(function() {
					scrollTimer = setInterval(function() {
						scrollNavigator(scrollUp);
					}, 100);
				}, function() {
					clearInterval(scrollTimer);
				})
				.click(function() {
					scrollNavigator(scrollUp, 40);
				})
			);

			//Add the navigator scroll down element
			workflowNavEle.append($('<div><div>&nbsp;</div></div>')
				.addClass('wrkflw-nav-down')
				.hover(function() {
					scrollTimer = setInterval(function() {
						scrollNavigator(scrollDown);
					}, 100);

				}, function() {
					clearInterval(scrollTimer);
				})
				.click(function() {
					scrollNavigator(scrollDown, 40);
				})
			);
		}
		//Adjust the height of the container and add some margins to the navigator to account for the scrolling
		workflowNavEle.addClass('wrkflw-nav-scrolled').height(containerHeight - buffer - scrollerHeight);
	}
	else {
		//Remove the navigator margins for the scrollers and add 36 px to account for the lack of scrollers
		$(workflowNavEle).removeClass('wrkflw-nav-scrolled').height(containerHeight - buffer);
		//Remove the navigator scroll up element
		$(workflowNavEle).find('.wrkflw-nav-up').remove();
		//Remove the navigator scroll down element
		$(workflowNavEle).find('.wrkflw-nav-down').remove();
	}
};

/*eslint-disable no-unused-vars*/
/**
 * Each workflow will be responsible for creating its own NavigatorSubsections.  The loading of these Subsections is currently
 * hard coded in each WorkflowView object since there is no standard way of setting up workflows.  Once a standard way of
 * setting up wizards is developed the loading of subsection should be generalized and handled in this base class.
 * @param {object} workflowSettings The workflow settings object
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.createNavigatorSubsectionObjects = function(workflowSettings) {

};
/*eslint-enable no-unused-vars*/

/**
 * Activates the subsection which should be shown to the user.  If the subsection has an associated view it will replace the
 * previously active view.  This function is called either on mouse click or when the workflow is first loaded.
 * @param {NavigatorSubsection} subsectionObj The NavigatorSubsection object that should be activated
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.activateSubsection = function(subsectionObj) {
	var self = this;
	var activeSubsection = null;
	var associatedViewDiv = null;

	//Make sure there is a subsection to activate
	if(!subsectionObj) {
		return;
	}

	//Make sure we don't attempt to reactive the existing active subsection
	activeSubsection = this.getActiveSubsection();
	if(subsectionObj === activeSubsection) {
		return;
	}

	//Deactivate the curently active subsection if it is available
	if(activeSubsection) {
		//If there is an associated view with the active subsection save the offset position so we can go back
		// to its scroll offset when we reactivate.
		if(activeSubsection.hasAssociatedView()) {
			activeSubsection.saveViewOffsetPosition();
		}

		//If the new subsection has an associated view remove active classes from all other subsection bodies and views
		if(subsectionObj.hasAssociatedView()){
			//Hide whatever subsection was previously shown
			this.m_$navContainer.find('.ss-active').removeClass('ss-active');
			//Find the currently active view and hide it
			this.m_$viewContainer.find('.ss-view-active').removeClass('ss-view-active');
		}

		//Remove this subsection as the active subsection
		this.setActiveSubsection(null);
	}

	//Activate the newly selected subsection
	this.setActiveSubsection(subsectionObj);

	//Apply the active classes to this subsection element if it isnt already shown
	if(!subsectionObj.isAlwaysExpanded()){
		$('#' + subsectionObj.getSubsectionElementId()).addClass('ss-active');
	}

	//Apply the active classes the the associate view element if it is available
	//Determine if this subsection has an associated view to render
	if(subsectionObj.hasAssociatedView()) {

		//Save off the subsection id for the newly active subsection so we can make it the default on page refresh
		//We only do this for subsections that have an associated view
		this.saveSubsectionIdInCookie(subsectionObj.getSubsectionId());

		associatedViewDiv = $('#' + subsectionObj.getAssociatedViewElementId());
		associatedViewDiv.addClass('ss-view-active');
		//Tell the subsection to render itself if it hasn't already done so
		if(!subsectionObj.isSubsectionRendered()) {
			subsectionObj.renderSubsection();
		}
		else{
			//View is already rendered so we need to reset it to its previous offset position
			subsectionObj.applyViewOffsetPosition();
		}
		//Tell the subsection to activate its Workflow page menu items since the menu items are flexed based on the active subsection
		this.loadWorkflowPageMenu();
	}

	setTimeout(function(){
		//Apply the scrolling to the navigator container if necessary now that we have a new subsection being shown
		self.applyNavigatorScrolling();
	}, 0);
};

/**
 * Loads the default Workflow View level filter mappings.  These mappings can be overwritten by using the
 * WorkflowView.setFilterMappingObject() function with the same filter name as any of the existing filter
 * mappings.  Filter mappings can also be overridden by defining a loadFilterMappings function in a
 * WorkflowView prototyped object.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.loadFilterMappings = function() {
	this.addFilterMappingObject('VIEWPOINT_LABEL', {
		setFunction: this.setName,
		type: 'String',
		field: 'FTXT'
	});
	//A filter mapping used to set the printable report name.
	//The filter mean for this setting is named PREG_PRINT but it is not isolated to just the Pregnancy Summary.  It also applies to the
	// View Builder Workflow pages as well and is a setting to call a printable Discern report.
	this.addFilterMappingObject('PREG_PRINT', {
		setFunction: this.setPrintableReportName,
		type: 'String',
		field: 'FTXT'
	});
};

/**
 * Initializes the page level menu that is shared across all subsections in the WorkflowView object.  All subsection menu items are
 * removed before loading a new subsection within the workflow.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.loadWorkflowPageMenu = function() {
	var activeSubsection = null;
	var categoryMean = this.getCategoryMean();
	var defaultMenuItemIds = '';
	var menuItem = null;
	var menuItemArr = null;
	var pageMenu = null;
	var x = 0;

	//See if the page menu already exists since we share it among multiple subsection views
	pageMenu = MP_MenuManager.getMenuObject('pageMenu' + categoryMean);
	if(!pageMenu) {
		//Page menu does not already exist so we will create the default values
		pageMenu = new Menu('pageMenu' + categoryMean);
		pageMenu.setTypeClass('menu-page-menu');
		pageMenu.setIsRootMenu(true);
		pageMenu.setAnchorElementId('pageMenu' + categoryMean);
		pageMenu.setAnchorConnectionCorner([ 'bottom', 'right' ]);
		pageMenu.setContentConnectionCorner([ 'top', 'right' ]);

		//Load the Print report menu item
		menuItem = this.loadPrintableReportMenuItem();
		if(MenuItem.prototype.isPrototypeOf(menuItem)) {
			pageMenu.addMenuItem(menuItem);
		}

		//Add a separator
		pageMenu.addMenuItem(new MenuSeparator('separator'));

		//Create the clear preferences menu item
		menuItem = this.createClearPrefsMenuItem();
		if(MenuItem.prototype.isPrototypeOf(menuItem)) {
			pageMenu.addMenuItem(menuItem);
		}
	}
	else {
		//The workflow page menu is flexed between multiple views so we need to remove the menuItems that are not defaults
		menuItemArr = pageMenu.getMenuItemArray();
		if(menuItemArr) {
			defaultMenuItemIds = 'printReport' + categoryMean + '|' + 'clearPrefs' + categoryMean;
			for(x = menuItemArr.length; x--;) {
				menuItem = menuItemArr[x];
				if(defaultMenuItemIds.indexOf(menuItem.getId()) < 0) {
					menuItemArr.splice(x, 1);
				}
			}
		}
	}
	//Update/Add the menu to the collection so other objects will have access to it
	MP_MenuManager.updateMenuObject(pageMenu);

	//Get the active subsection and have it load its page level menu items
	activeSubsection = this.getActiveSubsection();
	if(activeSubsection) {
		activeSubsection.loadWorkflowPageMenuItems('pageMenu' + categoryMean);
	}

	//Update the click event on the menu to launch this menu when clicked.
	$('#pageMenu' + categoryMean).unbind('click').click(function() {
		MP_MenuManager.showMenu('pageMenu' + categoryMean);
	});
};
/*globals DetailedReviewSubsection*/

/**
 * Implementation of the View Builder Workflow WorkflowView object
 */

/**
 * A constructor used to create a new ViewBuilderWorkflow object and initialize page level variables.
 * @constructor
 */
var ViewBuilderWorkflow = function() {
	//Set page level information
	this.setName('View Builder Workflow');

	//This flag determines if the detailed review subsection should selectively load components
	this.m_selectiveComponentLoadInd = true;
};

/**
 * Setup the prototype and constructor to inherit from the base WorkflowView
 */
ViewBuilderWorkflow.prototype = new WorkflowView();
ViewBuilderWorkflow.prototype.constructor = WorkflowView;

/**
 * Returns the flag which indicates if components should be loaded selectively.  If this flag is set to true the Detailed Review
 * subsection will determine which components to load based on user input.
 * @returns {boolean} The selective components loading indicator.
 */
ViewBuilderWorkflow.prototype.selectivelyLoadComponents = function() {
	return this.m_selectiveComponentLoadInd;
};


/**
 * Getters
 */

/**
 * Set the selective component load flag which determines if the MPage should allow for selective component loading.  This means
 * the MPage will not attempt to load its components until explicitly told to do so using the loadSelectedComponent function.
 * @param {string} selectiveLoad A string which will be either "1" or "0" which will indicate if the MPages should allow for selective loading of components.
 * @returns {boolean} True if the selective component load indicator was set successfully, false otherwise
 */
ViewBuilderWorkflow.prototype.setSelectiveComponentLoadInd = function(selectiveLoad) {
	if (typeof selectiveLoad === 'string') {
		this.m_selectiveComponentLoadInd = selectiveLoad === '1';
		return true;
	}
	return false;
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} workflowSettings The settings JSON for this workflow view
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
ViewBuilderWorkflow.prototype.createNavigatorSubsectionObjects = function(workflowSettings) {
	var tempSubsection = null;
	//The creation of these subsections is currently hardcoded since Bedrock does not currently
	//provide a way to setup Workflows.  Once that is available the loading of these subsections
	//should be dynamic.

	//Create the Detailed Review subsection
	tempSubsection = new DetailedReviewSubsection();
	tempSubsection.setWorkflowViewId(this.getCategoryMean());
	//Add the selective component loading flag
	tempSubsection.setSelectiveComponentLoadInd(this.selectivelyLoadComponents());

	this.addNavigatorSubsection(tempSubsection);
};
/*eslint-enable no-unused-vars*/

/**
 * Loads the default Workflow View level filter mappings.  Calls the base functionality and l
 * @returns {undefined} This function does not return a value
 */
ViewBuilderWorkflow.prototype.loadFilterMappings = function() {
	//Call the base class definition of this function in order to load all of the default values
	WorkflowView.prototype.loadFilterMappings.call(this);
	//Selective component loading
	this.addFilterMappingObject('WF_SELECTIVE_COMP_LOADING_FLAG', {
		setFunction: this.setSelectiveComponentLoadInd,
		type: 'String',
		field: 'FTXT'
	});
};

MP_Util.setObjectDefinitionMapping('WF_STD', ViewBuilderWorkflow);
/**
 * A constructor used to create a new CPMWorkflow object and initialize page level variables.
 * @constructor
 */
var CPMWorkflow = function() {
    //Set page level information
    this.setName("CPM Workflow");
    this.m_cpmResource = null;
};

/**
 * Setup the prototype and constructor to inherit from the base WorkflowView
 */
CPMWorkflow.prototype = new WorkflowView();
CPMWorkflow.prototype.constructor = WorkflowView;

CPMWorkflow.prototype.applyOffsetPosition = function(){

};

CPMWorkflow.prototype.setSubsectionViewOffsetPosition = function(){

};

CPMWorkflow.prototype.getCPMResource = function(){
	return this.m_cpmResource;
};
CPMWorkflow.prototype.setCPMResource = function(cpmResource){
	this.m_cpmResource = cpmResource;
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} cpmSettings - The settings JSON for this body system view
 * @return {undefined} This function returns early if there are no cpmSettings, a concept list, or a component list
 */
CPMWorkflow.prototype.createNavigatorSubsectionObjects = function(cpmSettings) {
	var conceptList = [];
	var componentList = [];

	if(!cpmSettings){
		logger.logJSError("cpmSettings is undefined", this, "cpm-workflow.js", "createNavigatorSubsectionObjects");
		return;
	}
	if(!cpmSettings.CONCEPT_LIST || !cpmSettings.CONCEPT_LIST.length || !cpmSettings.CONCEPT_LIST[0].CG_LIST){
		logger.logJSError("a valid concept list or component list does not exist", this, "cpm-workflow.js", "createNavigatorSubsectionObjects");
		return;
	}
	conceptList = cpmSettings.CONCEPT_LIST;
	componentList = conceptList[0].CG_LIST;

	var tempSubsection = new CPMDetailedReviewSubsection();
	tempSubsection.setWorkflowViewId(this.getCategoryMean());
	tempSubsection.setSubsectionSettings(componentList);

	this.addNavigatorSubsection(tempSubsection);
};

CPMWorkflow.prototype.loadViewSettings = function() {
	var self = this;
	var request;
	var cpmResource = this.getCPMResource();
	var pathwayId = cpmResource.getPathwayId();
	var conceptCd = cpmResource.getConceptCd();

	request = new ScriptRequest();
	request.setProgramName("cp_load_pathway_config");
	request.setParameterArray(["^MINE^", pathwayId + ".0", conceptCd + ".0"]);
	request.setAsyncIndicator(false);
	request.setResponseHandler(function(reply){
		self.handleCPMResponse(reply);
	});
	request.performRequest();
};

CPMWorkflow.prototype.handleCPMResponse = function(reply){
	var categoryMean = this.getCategoryMean().replace("DYN_", "");
	if (!reply) {
		logger.logJSError("reply object is undefined", this, "cpm-workflow.js", "loadViewSettings");
		return;
	}
	var response = reply.getResponse();
	if (!response) {
		logger.logJSError("response object is undefined", this, "cpm-workflow.js", "loadViewSettings");
		return;
	}
	this.setViewSettings(response);
	this.setPageId(categoryMean);
	this.setViewType("DYN_CPM");
	var pageFilters = {
		FC_MN:"CPM_DYNAMIC_TAB",
		VALS: [{FTXT:"CPM_DYNAMIC_TAB",
		}]
	}
	var plfResource = this.loadPageLevelFiltersSharedResource(pageFilters, this.getCategoryMean());	
};

/**
 * Returns the NavigatorSunsection object that should be loaded as the default when this workflow is rendered
 * @return {NavigatorSubsection} The subsection that this workflow should render as a default
 */
CPMWorkflow.prototype.getDefaultSubsection = function() {
    if (this.m_navigatorSubsections && this.m_navigatorSubsections.length) {
        //return the Detailed Review subsection to be rendered as a default
        return this.m_navigatorSubsections[0];
    }
    return null;
};
/*globals DetailedReviewSubsection, ViewBuilderWorkflow*/

/**
 * Implementation of the GroupedView object
 */

/**
 * A constructor used to create a new GroupedView object and initialize page level variables.
 * @constructor
 */
var GroupedView = function() {
	//Set page level information
	this.setName('Grouped View');
	//This variable contains the id of the viewpoint we will be pulling settings from
	this.m_viewpointId = '';
	//This flag determines if the detailed review subsections should selectively load components
	this.m_selectiveComponentLoadInd = true;
	//The Grouped View Settings
	this.m_groupedViewSettings = null;
};

/**
 * Setup the prototype and constructor to inherit from the base WorkflowView
 */
GroupedView.prototype = new ViewBuilderWorkflow();
GroupedView.prototype.constructor = ViewBuilderWorkflow;


/**
 * This function returns the settings for this grouped view if currently set
 * @returns {object} The settings for this grouped view object
 */
GroupedView.prototype.getGroupedViewSettings = function() {
	return this.m_groupedViewSettings;
};

/**
 * This function is used to store the settings of the grouped view once retrieved
 * @param {object} settingsObj An object containing all of the settings for the grouped view
 * @returns {undefined} This function does not return a value
 */
GroupedView.prototype.setGroupedViewSettings = function(settingsObj) {
	this.m_groupedViewSettings = settingsObj;
};

/**
 * This function is used to retrieve the identifier of the viewpoint whose settings will be used in this Grouped View
 * @returns {string} The id of the viewpoint whose settings will be used
 */
GroupedView.prototype.getViewpointIdentifier = function() {
	return this.m_viewpointId;
};

/**
 * This function is used to set the id of the viewpoint whose settings will be retrieved for this Grouped View
 * @param {string} viewpointId The id of the viewpoint whose settings will be used in this grouped view.
 * @returns {undefined} This function does not return a value
 */
GroupedView.prototype.setViewpointIdentifier = function(viewpointId) {
	this.m_viewpointId = viewpointId;
};

/**
 * Loads the default Workflow View level filter mappings.  These mappings can be overwritten by using the
 * WorkflowView.setFilterMappingObject() function with the same filter name as any of the existing filter
 * mappings.  Filter mappings can also be overridden by defining a loadFilterMappings function in a
 * WorkflowView prototyped object.
 * @returns {undefined} This function does not return a value
 */
GroupedView.prototype.loadFilterMappings = function() {
	this.addFilterMappingObject('VIEWPOINT_LABEL', {
		setFunction: this.setName,
		type: 'String',
		field: 'FTXT'
	});
	//This filter is used to determine which viewpoint to pull settings from for the grouped view
	this.addFilterMappingObject('GROUPED_VIEW_VIEWPOINT_ID', {
		setFunction: this.setViewpointIdentifier,
		type: 'String',
		field: 'FTXT'
	});
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} groupedViewSettings The settings JSON for this grouped view
 * @return {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
GroupedView.prototype.createNavigatorSubsectionObjects = function(groupedViewSettings) {
	//Check for valid settings
	if(!groupedViewSettings) {
		return;
	}

	var groupedView = null;
	var groupedViewCnt = 0;
	var tempSubsection = null;

	if(groupedViewSettings.VIEWS) {
		groupedViewCnt = groupedViewSettings.VIEWS.length;
		tempSubsection = null;
		//Loop through each view in the groupedViewSettings and create a DetailedReview section for each
		for(var x = 0; x < groupedViewCnt; x++) {
			groupedView = groupedViewSettings.VIEWS[ x ];
			if(groupedView.VIEW_TYPE === 1){
				tempSubsection = new DetailedReviewSubsection();
				tempSubsection.setSubsectionId(groupedView.VIEW_CAT_MEAN);
				tempSubsection.setHasHeaderElement(true);
				tempSubsection.setHeaderText(groupedView.VIEW_NAME || 'MPages View');
				tempSubsection.setWorkflowViewId(this.getCategoryMean());
				tempSubsection.setSelectiveComponentLoadInd(this.selectivelyLoadComponents());
				tempSubsection.setSubsectionSettings(groupedView);
				this.addNavigatorSubsection(tempSubsection);
			}
		}
	}
};
/*eslint-enable no-unused-vars*/

/**
 * Activates the supplied subsection
 * @param {Object} subsectionObj The subsection object
 * @returns {undefined} This function does not return a value
 */
/**
 * Activates the supplied subsection
 * @param {Object} subsectionObj The subsection object
 * @returns {undefined} This function does not return a value
 */
GroupedView.prototype.activateSubsection = function(subsectionObj) {
	//Grab the view associated with this subsection and retrieve its settings
	if(!subsectionObj) {
		return;
	}

	var subsectionSettings = subsectionObj.getSubsectionSettings();

	if(subsectionObj.hasAssociatedView()) {
		//retrieve the settings for the view associated with this subsection
		var mpage = subsectionObj.getAssociatedView();

		//Check to see if the view already has settings
		var mpageSettings = mpage.getViewSettings();
		if(!mpageSettings) {
			mpage.setCriterion(subsectionObj.getCriterion());
			mpage.setCategoryMean(subsectionSettings.VIEW_CAT_MEAN);
			mpageSettings = mpage.getViewSettingsObject();
			var allComponentSettings = mpageSettings.BR_SET.CS;
			//We have to modify all component ids since these components may show up in other Grouped based views.
			//Appending the workflow category mean will ensure uniqueness across all views.
			for(var x = allComponentSettings.length; x--;) {
				allComponentSettings[ x ].F_ID += this.getCategoryMean();
			}

			//We also need to update the category_mean of the MPage since it can also be used in another grouped View.
			// Doing this will prevent the MPageView.getViewSettingsObject from returning this settings object and accidently
			// sharing it across grouped views.
			mpageSettings.C_MN = this.getCategoryMean() + '_' + mpageSettings.C_MN;
			mpage.setCategoryMean(mpageSettings.C_MN);

			//Initialize the view now that we have the settings
			mpage.initializeView(subsectionObj.getAssociatedViewElementId(), allComponentSettings);
			mpage.loadViewSettings();
			mpage.initializeComponents();
			//Generate the body HTML of the subsection now that we have the settings
			$('#' + subsectionObj.getBodyElementId())
				.append(subsectionObj.generateBodyHTML());
		}
	}

	//Call the parent activation function
	WorkflowView.prototype.activateSubsection.call(this, subsectionObj);
};

/**
 * Initialize a new detailed review subsection for each grouped view defined
 * @returns {undefined} This function does not return a value
 */
GroupedView.prototype.initializeComponents = function() {
	var criterion = null;
	var self = this;
	var subsectionArr = [];
	var subsectionCnt = 0;
	var subsection = null;
	var viewSettings = null;
	var x = 0;

	criterion = this.getCriterion();

	//Retrieve the viewpoint settings that will be used for the grouped view
	var systemRequest = new ScriptRequest();
	systemRequest.setName('Grouped View Request');
	systemRequest.setProgramName('mp_get_viewpoint_settings');
	systemRequest.setParameterArray([ '^MINE^', '^' + this.getViewpointIdentifier() + '^', '^^', criterion.encntr_id + '.0', criterion.provider_id + '.0', criterion.position_cd + '.0', 1 ]);
	systemRequest.setAsyncIndicator(false);
	systemRequest.setResponseHandler(function(reply) {
		self.setGroupedViewSettings(reply.getResponse());
	});
	systemRequest.performRequest();

	//Retrieve the subsection settings
	viewSettings = this.getGroupedViewSettings();

	//Ensure the viewpoint identified contains at least one view.
	if(!viewSettings || !viewSettings.VIEWS || !viewSettings.VIEWS.length){
		throw new Error('The Viewpoint identifier provided for this grouped view either does not exist or does not contain any views.');
	}

	//Determine which subsections will be a part of this workflow and instantiate them
	this.createNavigatorSubsectionObjects(viewSettings);
	subsectionArr = this.getNavigatorSubsections();
	subsectionCnt = subsectionArr.length;
	//Loop through each subsection and initialize it.
	for(x = 0; x < subsectionCnt; x++) {
		subsection = subsectionArr[ x ];
		subsection.initializeSubsection(criterion);
		//Load the necessary MPageView settings for the subsection if needed
		if(subsection.hasAssociatedView()) {
			//Set the subsections view id so it can be used as the category mean for the associated view
			subsection.setAssociatedViewElementId(this.getCategoryMean() + '_ssView_' + x);
			//Don't pass any settings object in since we will retrieve them upon subsection activation
			subsection.createAssociatedMPageView(null);
		}
		//subsection will be rendered during the workflow loading
	}
};

// Register GroupedView
MP_Util.setObjectDefinitionMapping('WF_GRP_VIEW', GroupedView);
/*globals ViewBuilderWorkflow, PartogramDetailedReviewSubsection, PARTOGRAM_BASE_UTIL*/
/**
 * Implementation of the Partogram Workflow ViewBuilderWorkflow object
 */

/**
 * A constructor used to create a new PartogramWorkflow object and initialize page level variables.
 * @constructor
 */
var PartogramWorkflow = function() {

	//Log info for debugger
	logger.logMessage("Rendering Partogram Workflow View");

	//Set page level information
	this.setName("Partogram Workflow");
};

/**
 * Setup the prototype and constructor to inherit from the base ViewBuilderWorkflow
 */
PartogramWorkflow.prototype = new ViewBuilderWorkflow();
PartogramWorkflow.prototype.constructor = ViewBuilderWorkflow;

/**
 * Call the base class implementation to load the workflow settings. Once that is complete, the partogram information
 * for the patient being view is retrieved for use in this workflow view as well as for components which require the
 * information.
 * @return {undefined} This function does not return a value
 */
PartogramWorkflow.prototype.loadViewSettings = function() {
	// Call the base class implementation of the loadViewSettings function
	ViewBuilderWorkflow.prototype.loadViewSettings.call(this);
	
	// Set the view as a partogram view type
	var criterion = this.getCriterion();
	PartogramBaseComponent.prototype.setPartogramViewID(criterion.category_mean);

	// Load the current partogram information and store it in a shared resource for use by other partogram objects
	// This call will need to be synchronous so that the PartogramDetailedReview subsection will have it available
	// when it is loaded.
	var patientGenderInfo = criterion.getPatientInfo().getSex();

	// Check to make sure the patient is a female with an active pregnancy
	if (patientGenderInfo !== null && patientGenderInfo.meaning !== null && patientGenderInfo.meaning === "FEMALE") {
		var partoInfoSR = MP_Resources.getSharedResource("partogramInfo");

		// Check to see if the partogramInfo object is available to use
		if (partoInfoSR && partoInfoSR.isResourceAvailable()) {
			// Do Nothing
		}
		else {
			// Kick off the partogramInfo data retrieval
			// Load the current partogram information stored it in a shared resource
			PartogramBaseComponent.prototype.loadPartogramData(criterion, false);
		}
	}
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} workflowSettings The workflow settings for this workflow view.
 * @return {undefined} This function does not return a value
 */
PartogramWorkflow.prototype.createNavigatorSubsectionObjects = function(workflowSettings) {
	//Create the Pregnancy Detailed Review subsection
	var partoDetailedReviewSubsection = new PartogramDetailedReviewSubsection();
	partoDetailedReviewSubsection.setWorkflowViewId(this.getCategoryMean());
	//Add the selective component loading flag
	partoDetailedReviewSubsection.setSelectiveComponentLoadInd(this.selectivelyLoadComponents());
	this.addNavigatorSubsection(partoDetailedReviewSubsection);
};

/**
 * Returns the NavigatorSunsection object that should be loaded as the default when this workflow is rendered
 * @return {NavigatorSubsection} The subsection that this workflow should render as a default
 */
PartogramWorkflow.prototype.getDefaultSubsection = function() {
	if (this.m_navigatorSubsections && this.m_navigatorSubsections.length && this.m_navigatorSubsections[0]) {
		//return the Detailed Review subsection to be rendered as a default
		return this.m_navigatorSubsections[0];
	}
	return null;
};

MP_Util.setObjectDefinitionMapping("WF_PARTOGRAM",PartogramWorkflow);
/*globals ViewBuilderWorkflow, PregnancyDetailedReviewSubsection, PREGNANCY_BASE_UTIL_O1*/
/**
 * Implementation of the Pregnancy Workflow ViewBuilderWorkflow object
 */

/**
 * A constructor used to create a new PregnancyWorkflow object and initialize page level variables.
 * @constructor
 */
var PregnancyWorkflow = function() {

	//Log info for debugger
	logger.logMessage("Rendering Pregnancy Workflow View");

	//Set page level information
	this.setName("Pregnancy Workflow");
};

/**
 * Setup the prototype and constructor to inherit from the base ViewBuilderWorkflow
 */
PregnancyWorkflow.prototype = new ViewBuilderWorkflow();
PregnancyWorkflow.prototype.constructor = ViewBuilderWorkflow;

/**
 * Call the base class implementation to load the workflow settings. Once that is complete, the pregnancy information
 * for the patient being view is retrieved for use in this workflow view as well as for components which require the
 * information.
 * @return {undefined} This function does not return a value
 */
PregnancyWorkflow.prototype.loadViewSettings = function() {
	//Call the base class implementation of the loadViewSettings function
	ViewBuilderWorkflow.prototype.loadViewSettings.call(this);

	//Load the current pregnancy information and store it in a shared resource for use by other pregnancy objects
	//This call will need to be synchronous so that the PregnancyDetailedReview subsection will have it available
	//when it is loaded.

	var criterion = this.getCriterion();
	var patientGenderInfo = criterion.getPatientInfo().getSex();

	// Check to make sure the patient is a female with an active pregnancy
	if (patientGenderInfo !== null && patientGenderInfo.meaning !== null && patientGenderInfo.meaning === "FEMALE") {
		var pregInfoSR = MP_Resources.getSharedResource("pregnancyInfo");

		// Check to see if the pregnancyInfo object is available to use
		if (pregInfoSR && pregInfoSR.isResourceAvailable()) {
			// Do Nothing
		}
		else {
			// Kick off the pregnancyInfo data retrieval
			// Load the current pregnancy information stored it in a shared resource
			PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(this.getCriterion(), false);
		}
	}
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} workflowSettings The workflow settings for this workflow view.
 * @return {undefined} This function does not return a value
 */
PregnancyWorkflow.prototype.createNavigatorSubsectionObjects = function(workflowSettings) {
	//Create the Pregnancy Detailed Review subsection
	var pregDetailedReviewSubsection = new PregnancyDetailedReviewSubsection();
	pregDetailedReviewSubsection.setWorkflowViewId(this.getCategoryMean());
	//Add the selective component loading flag
	pregDetailedReviewSubsection.setSelectiveComponentLoadInd(this.selectivelyLoadComponents());
	this.addNavigatorSubsection(pregDetailedReviewSubsection);
};

/**
 * Returns the NavigatorSunsection object that should be loaded as the default when this workflow is rendered
 * @return {NavigatorSubsection} The subsection that this workflow should render as a default
 */
PregnancyWorkflow.prototype.getDefaultSubsection = function() {
	if (this.m_navigatorSubsections && this.m_navigatorSubsections.length && this.m_navigatorSubsections[0]) {
		//return the Detailed Review subsection to be rendered as a default
		return this.m_navigatorSubsections[0];
	}
	return null;
};

MP_Util.setObjectDefinitionMapping("WF_PREG",PregnancyWorkflow);
/**
 * The NavigatorSubsection object
 * @constructor
 * @author Steven Lewis
 */
function NavigatorSubsection() {

	/*Variables*/
	this.m_criterion = null;
	this.m_filterMappingsObj = {};
	this.m_isSubsectionActive = false;
	this.m_isSubsectionRendered = false;
	this.m_subsectionSettings = null;
	this.m_subsectionId = 0.0;
	this.m_workflowViewId = '';

	/*Navigator Subsection*/
	this.m_bodyElementId = '';
	this.m_hasBodyElement = false;
	this.m_hasHeaderElement = false;
	this.m_headerElementId = '';
	this.m_headerElementText = '';
	this.m_subsectionElementId = '';
	this.m_subsectionName = '';
	this.m_subsectionIcon = '';
	this.m_alwaysExpanded = false;

	/*Associated MPageView*/
	this.m_hasAssociatedView = false;
	this.m_mpageViewElementId = '';
	this.m_associatedView = null;
	this.m_associatedViewElementId = '';
}

/**
 * Add a filter mapping object to the collection of mappings.  Filter mappings are referenced by name, so if a filter already exists
 * with the same name it will be overwritten.
 * @param {string} filterName The name of the filter object to add.
 * @param {Object} filterObject The object containing all of the filter properties used when loading settings.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.addFilterMappingObject = function(filterName, filterObject) {
	this.m_filterMappingsObj[filterName] = filterObject;
};

/**
 * Generates the HTML for the subsection header.  The base class implementation just returns the HeaderElementText
 * and requires the Workflow to style the container for the header.
 * @returns {string} The HTML which will be inserted into the subsection header
 */
NavigatorSubsection.prototype.generateHeaderHTML = function() {
	return this.getHeaderText();
};

/**
 * Generate the HTML for the subsection body.  The base class implementation of this function returns an empty string.  It is up to
 * the individual NavigatorSubsection objects to create their body HTML.
 * @returns {string} The HTML which will be inserted into the subsection body
 */
NavigatorSubsection.prototype.generateBodyHTML = function() {
	return '&nbsp;';
};

/**
 * Gets the MPageView object that is associated to this NavigatorSubsection object.
 * @returns {MPageView} The MPageView object that is associated to this NavigatorSubsection
 */
NavigatorSubsection.prototype.getAssociatedView = function() {
	return this.m_associatedView;
};

/**
 * Gets the element id of the container for the associated View.
 * @returns {MPageView} The MPageView object that is associated to this NavigatorSubsection
 */
NavigatorSubsection.prototype.getAssociatedViewElementId = function() {
	return this.m_associatedViewElementId;
};

/**
 * Gets the id of the subsection body HTML element assigned to this subsection.
 * @returns {string} The id of the body element assigned to this subsection
 */
NavigatorSubsection.prototype.getBodyElementId = function() {
	return this.m_bodyElementId;
};

/**
 * Gets the criterion object of this NavigatorSubsection
 * @returns {Criterion} The criterion object for the NavigatorSubsection
 */
NavigatorSubsection.prototype.getCriterion = function() {
	return this.m_criterion;
};

/**
 * Gets the array of filter mapping objects used to apply Workflow View level settings.
 * @returns {Object[]} An array of filter mapping objects.
 */
NavigatorSubsection.prototype.getFilterMappingsObj = function() {
	return this.m_filterMappingsObj;
};

/**
 * Gets the id of the subsection head HTML element assigned to this subsection.
 * @returns {string} The id of the head element assigned to this subsection
 */
NavigatorSubsection.prototype.getHeaderElementId = function() {
	return this.m_headerElementId;
};

/**
 * Gets the text/label to render in the subsection header element
 * @returns {string} The id of the head element assigned to this subsection
 */
NavigatorSubsection.prototype.getHeaderText = function() {
	return this.m_headerElementText;
};

/**
 * Gets the name of this NavigatorSubsection.
 * @returns {string} The name of the subsection
 */
NavigatorSubsection.prototype.getName = function() {
	return this.m_subsectionName;
};

/**
 * Gets the id of the subsection container HTML element assigned to this subsection
 * @returns {string} the id of the container element assigned to this subsection
 */
NavigatorSubsection.prototype.getSubsectionElementId = function() {
	return this.m_subsectionElementId;
};

/**
 * Gets the filename of the icon to display for the subsection head.
 * @returns {string} The name of the icon used in the subsection head
 */
NavigatorSubsection.prototype.getSubsectionIcon = function() {
	return this.m_subsectionIcon;
};

/**
 * Gets the unique ID assigned to this NavigatorSubsection
 * @returns {Number}	The id of the subsection
 */
NavigatorSubsection.prototype.getSubsectionId = function() {
	return this.m_subsectionId;
};

/**
 * Gets the settings object used when loading the NavigatorSubsection object.
 * @returns {Object} The subsection settings object.
 */
NavigatorSubsection.prototype.getSubsectionSettings = function() {
	return this.m_subsectionSettings;
};

/**
 * Gets the workflow view id that this subsection is in.
 * @returns {string} the workflow view id
 */
NavigatorSubsection.prototype.getWorkflowViewId = function() {
	return this.m_workflowViewId;
};

/** Checkers **/

/**
 * Checks to see if this subsection has an associated MPageView object that will be rendered along with the subsection element.
 * Not all subsections may need an associated MPageView object and performs some alternate functionality.
 * @returns {boolean} True if the subsection has a header element, false otherwise.
 */
NavigatorSubsection.prototype.hasAssociatedView = function() {
	return this.m_hasAssociatedView;
};

/**
 * Checks to see if this subsection has a body element.  Not all subsections may need a body and simply open
 * the associated View object when selected.
 * @returns {boolean} True if the subsection has a header element, false otherwise.
 */
NavigatorSubsection.prototype.hasBodyElement = function() {
	return this.m_hasBodyElement;
};

/**
 * Checks to see if this subsection has a header element
 * @returns {boolean} True if the subsection has a header element, false otherwise.
 */
NavigatorSubsection.prototype.hasHeaderElement = function() {
	return this.m_hasHeaderElement;
};

/**
 * This function is used to check and see if the subsection body should always be expanded
 * @returns {boolean} True if the subsection should always be expanded, false otherwise
 */
NavigatorSubsection.prototype.isAlwaysExpanded = function(){
	return this.m_alwaysExpanded;
};

/**
 * Checks to see if the sunsection is currently active
 * @returns {boolean} True if the subsection is active, false otherwise
 */
NavigatorSubsection.prototype.isSubsectionActive = function() {
	return this.m_isSubsectionActive;
};

/**
 * Checks to see if the sunsection has been rendered
 * @returns {boolean} True if the subsection has been rendered, false otherwise
 */
NavigatorSubsection.prototype.isSubsectionRendered = function() {
	return this.m_isSubsectionRendered;
};

/**
 * This function is used to apply the current offset position of the associated view.  This is to allow the view to
 * remain in the same position before and after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.applyViewOffsetPosition = function(){
	//This functionality should be implemented at the instance level
};

/**
 * This function is used to save the current offset position of the associated view.  This is to allow the view to
 * remain in the same position before and after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.saveViewOffsetPosition = function(){
	//This functionality should be implemented at the instance level
};

/**
 * This function is used to set the flag which determines if a subsection body should
 * always be expanded.
 * @param {boolean} alwaysExpanded A boolean which determines if the subsection should always be expanded or not
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setAlwaysExpanded = function(alwaysExpanded){
	this.m_alwaysExpanded = alwaysExpanded;
};

/**
 * Sets the MPageView object that is associated to this NavigatorSubsection object.
 * @param {MPageView} mpageViewObj The MPageView object that is associated to this NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setAssociatedView = function(mpageViewObj) {
	this.m_associatedView = mpageViewObj;
};

/**
 * Sets the id of the container for the associated View object.
 * @param {string} elementId The id of the DOM container for the associated view
 * @returns {MPageView} The MPageView object that is associated to this NavigatorSubsection
 */
NavigatorSubsection.prototype.setAssociatedViewElementId = function(elementId) {
	this.m_associatedViewElementId = elementId;
};

/**
 * Sets the id of the subsection body HTML element assigned to this subsection.
 * @param {string} elementId The id of the DOM container for the subsection body
 * @returns {boolean} True if the body element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setBodyElementId = function(elementId) {
	if (elementId && typeof elementId === 'string') {
		this.m_bodyElementId = elementId;
		return true;
	}
	return false;
};

/**
 * Sets the criterion object of this NavigatorSubsection object.
 * @param {Criterion} criterionObj A criterion object which will be used within the NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setCriterion = function(criterionObj) {
	this.m_criterion = criterionObj;
};

/**
 * Sets the filter mappings object which will be used when loading settings from the preferences model.  The filterObj parameter must
 * not be null.  If it is null it will be ignored.
 * @param {Object} filterObj An object which contains the filter mappings of the WorkflowView object
 * @returns {boolean} True if the filter mappings were set successfully, false otherwise
 */
NavigatorSubsection.prototype.setFilterMappingsObj = function(filterObj) {
	if (filterObj) {
		this.m_filterMappingsObj = filterObj;
		return true;
	}
	return false;
};

/**
 * Sets the hasAssociatedView flag which determines if this subsection will have an Associated MPageView object.
 * @param {boolean} hasView A boolean indicating if the subsection has an associated view
 * @returns {boolean} True if the head element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setHasAssociatedView = function(hasView) {
	if (typeof hasView === 'boolean') {
		this.m_hasAssociatedView = hasView;
		return true;
	}
	return false;
};

/**
 * Sets the hasBodyElement flag which determines if this subsection will have a body portion rendered.
 * @param {boolean} hasBody A boolean indicating if the subsection has a body
 * @returns {boolean} True if the head element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setHasBodyElement = function(hasBody) {
	if (typeof hasBody === 'boolean') {
		this.m_hasBodyElement = hasBody;
		return true;
	}
	return false;
};

/**
 * Sets the hasHeadElement flag which determines if this subsection will have a head portion rendered.
 * @param {boolean} hasHead A boolean indicating if the subsection has a header
 * @returns {boolean} True if the has head element flag was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setHasHeaderElement = function(hasHead) {
	if (typeof hasHead === 'boolean') {
		this.m_hasHeaderElement = hasHead;
		return true;
	}
	return false;
};

/**
 * Sets the id of the subsection head HTML element assigned to this subsection.
 * @param {string} elementId The id of the DOM element where the header is rendered
 * @returns {boolean} True if the head element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setHeaderElementId = function(elementId) {
	if (elementId && typeof elementId === 'string') {
		this.m_headerElementId = elementId;
		return true;
	}
	return false;
};

/**
 * Sets the text to be used used when rendering the subsection head HTML element assigned to this subsection.
 * @param {string} headerText The text to place in the header element
 * @returns {boolean} True if the head element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setHeaderText = function(headerText) {
	if (headerText && typeof headerText === 'string') {
		this.m_headerElementText = headerText;
		return true;
	}
	return false;
};

/**
 * Sets the name of this NavigatorSubsection.
 * @param {string} subsectionName The name of the subsection
 * @returns {boolean} True if the NavigatorSubsection name was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setName = function(subsectionName) {
	if (subsectionName && typeof subsectionName === 'string') {
		this.m_subsectionName = subsectionName;
		return true;
	}
	return false;
};

/**
 * Sets the flag indicating if the subsection is currently active.
 * @param {boolean} activeInd A boolean which signifies the subseciton as being active
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionActive = function(activeInd) {
	this.m_isSubsectionActive = activeInd;
};

/**
 * Sets the id of the subsection container HTML element assigned to this subsection.
 * @param {string} elementId The id of the DOM Elemenet that contains the subsection
 * @returns {boolean} True if the container element id was set successfully, false otherwise
 */
NavigatorSubsection.prototype.setSubsectionElementId = function(elementId) {
	if (elementId && typeof elementId === 'string') {
		this.m_subsectionElementId = elementId;
		return true;
	}
	return false;
};

/**
 * Sets the name of the icon to display for the subsection.
 * @param {string} iconFileName The file name of the icon to use next to the subsection header
 * @returns {string} The name of the icon used in the subsection header
 */
NavigatorSubsection.prototype.setSubsectionIcon = function(iconFileName) {
	if (iconFileName && typeof iconFileName === 'string') {
		this.m_subsectionIcon = iconFileName;
		return true;
	}
	return false;
};

/**
 * Sets the unique ID assigned to the NavigatorSubsection.
 * @param {Number} subsectionId	The id of the subsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionId = function(subsectionId) {
	this.m_subsectionId = subsectionId;
};

/**
 * Sets the flag which indicates if the subsection has been rendered
 * @param {boolean} renderedInd A flag indicating that the subsection has already been rendered
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionRendered = function(renderedInd) {
	this.m_isSubsectionRendered = renderedInd;
};

/**
 * Set the settings object for this particular NavigatorSubsection.
 * @param {Object} settingsObj The object which contains all of the settings needed for the NavigatorSubsection.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionSettings = function(settingsObj) {
	this.m_subsectionSettings = settingsObj;
};

/**
 * Sets the workflow view id that this subsection is in.
 * @param {String} viewId The id of the parent workflow view
 * @returns {boolean} true if the id was successfully set, otherwise false
 */
NavigatorSubsection.prototype.setWorkflowViewId = function(viewId) {
	if (viewId && typeof viewId === 'string') {
		this.m_workflowViewId = viewId;
		return true;
	}
	return false;
};

/** NavigatorSubsection Setup Functions **/

/**
 * Initializes the NavigatorSubsection element with the necessary information.
 * @param {Criterion} criterion The criterion object which will be used within this NavigatorSubsection object
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.initializeSubsection = function(criterion) {
	//Set the criterion object for later use
	this.setCriterion(criterion);
};

/**
 * Renders the Subsection and it's associated MPagesView.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.renderSubsection = function() {
	var associatedMPage = null;

	//Render the subsections body if needed
	if (this.hasAssociatedView()) {
		//Call the renderView function of the associated MpageView Object
		associatedMPage = this.getAssociatedView();
		if (MPageView.prototype.isPrototypeOf(associatedMPage)) {
			associatedMPage.renderView();
		}
	}
	this.setSubsectionRendered(true);
};

/**
 * Perform any special logic necessary for resizing an associated MPagesView object
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.resizeSubsection = function() {
	var associatedMPage = null;

	//Resize the associated MPagesView object if necessary
	if (this.hasAssociatedView()) {
		//Call the resizeView function of the associated MpageView Object
		associatedMPage = this.getAssociatedView();
		if (MPageView.prototype.isPrototypeOf(associatedMPage)) {
			associatedMPage.resizeView();
		}
	}
};

/**
 * Creates and initializes the MPagesView object which will be associated with this subsection.  Each NavigatorSubsection Object is
 * responsible for extracting the
 * necessary Component settings and creating the associated View object
 * @param {object} allComponentSettings An object which contains the settings for all of the Components shown within this workflow.
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
NavigatorSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
	//This functionality should be implemented at the instance level
};
/*eslint-enable no-unused-vars*/

/**
 * Extracts the component settings that will be used in the associated MPagesView object and sets them using the
 * setSubsectionSettings function.  This function should be implemented in each NavigatorSubsection object
 * otherwise it will just return the settings for all components.
 * @param {Object[]} settingsObj An object array which contains components settings
 * @returns {Object[]} An array of object containing component settings
 */
NavigatorSubsection.prototype.extractComponentSettings = function(settingsObj) {
	//This has to be implemented by the NavigatorSubsection objects because they know which components to pull otherwise all
	//component settings are returned
	return settingsObj;
};

/**
 * Injects the menu items into the Workflow Page Menu.  There is currently no implementation at the base level for this function.
 * All menu items will be determined by the individual implementation of each NavigatorSubsection object. This function should be
 * implemented in each NavigatorSubsection object.
 * @param {String} pageMenuId The id of the menu where menu items should be injected
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
NavigatorSubsection.prototype.loadWorkflowPageMenuItems = function(pageMenuId) {
	//This function should be implemented by each NavigatorSubsection that utilizes the Workflow page level menu
};
/*eslint-enable no-unused-vars*/
/*globals NavigatorSubsection, NavigatorSubsectionSummaryMPage, CapabilityTimer, DocumentationBaseComponent, GapCheck, ContextMenu*/
/*eslint-disable mp-camelcase*/
/**
 * A constructor used to create a new DetailedReviewSubsection object and
 * initialize subsection level variables.
 * @constructor
 */
var DetailedReviewSubsection = function() {

	//A reference to the detailed review subsection DOM element for quick access
	this.m_subsectionBodyElement = null;

	//This timeout reference is used to keep track of the timeout associated with the selective component loading
	//It is stored at the instance level so that it can be canceled in certain scenarios.
	this.m_componentLoadTimeout = null;

	//This flag is used to determine if the current value set for the m_componentLoadTimeout should block any future
	// requests to clear the existing timeout until after it has finished.
	this.m_blockingComponentLoadTimeout = false;

	//This value will determine how many component will be loaded selectively.  The value will be based on the
	// associated view's container and the minimum height of a workflow component.
	this.m_componentsToLoad = 0;

	//This value represents the height of an empty component in pixels.  It is used to calculate, based on a worst-case
	// scenario, how many components will be able to fit inside the viewing pane of the workflow MPage.
	this.m_emptyComponentHeightInPixels = 120;

	//This flag determines if the associated MPage should allow the detailed review subsection to selectively load the
	// components
	this.m_selectiveComponentLoadInd = true;

	/*eslint-disable mp-camelcase*/
	//This caches the padding element that is added to the bottom of the view
	this.m_$paddingPlaceholder = null;
	//This caches the container that holds all the components
	this.m_$contentObject = null;
	//This caches the root element of the last component in the workflow view
	this.m_$lastComponentElement = null;
	//This caches the id of the last component
	this.m_lastComponentId = 0;
	//This caches the view element which contains the scrollbar
	this.m_$viewElementObject = null;
	//This caches the last offset position of the view, which is used for returnin to the same offset position upon
	// displaying the view again
	this.m_viewScrollOffset = 0;
	/*eslint-enable mp-camelcase*/

	//This caches the height of the last component in the view since the last padding adjustment
	this.m_lastComponentHeight = 0;
	//This caches the height of the padding element in the view since the last padding adjustment
	this.m_lastPaddingHeight = 0;

	//Set page level information
	this.setName('Detailed Review');
	//Let the architecture know that we want to render a body portion for our subsection element
	this.setHasBodyElement(true);
	//Let the architecture know we have an associated MPageView object that we want to show
	this.setHasAssociatedView(true);
	//Let the architecture know that at least there is one component that is marked as required in the view
	this.m_gapCheckInd = null;
	//Checks for single instance of gap check
	this.m_gapCheckInstance = null;
};

/**
 * Setup the prototype and constructor to inherit from the base NavigatorSubsection
 */
DetailedReviewSubsection.prototype = new NavigatorSubsection();
DetailedReviewSubsection.prototype.constructor = NavigatorSubsection;

/**
 * Returns the flag which indicates if components should be loaded selectively.  If this flag is set to true the
 * Detailed Review subsection will determine which components to load based on user input.
 * @returns {boolean} The selective components loading indicator.
 */
DetailedReviewSubsection.prototype.selectivelyLoadComponents = function() {
	return this.m_selectiveComponentLoadInd;
};

/**
 * Set the selective component load flag which determines if the MPage should allow for selective component loading.
 * This means the MPage will not attempt to load its components until explicitly told to do so using the
 * loadSelectedComponent function.
 * @param {boolean} selectiveLoad A boolean which will indicate if the MPages should allow for selective loading of
 *     components.
 * @returns {boolean} True if the selective component load indicator was set successful, false otherwise
 */
DetailedReviewSubsection.prototype.setSelectiveComponentLoadInd = function(selectiveLoad) {
	if(typeof selectiveLoad === 'boolean') {
		this.m_selectiveComponentLoadInd = selectiveLoad;
		return true;
	}
	return false;
};

/**
 * Creates and initializes the MPagesView object which will be associated with this subsection.  Each
 * NavigatorSubsection is responsible for extracting the necessary Component settings for use in the MPagesView object.
 * @param {object} allComponentSettings An object which contains the settings for all of the Components shown within
 *     this workflow.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
	var newMPage = null;

	//Create the MPageView instance and prepare it for rendering for the subsection
	newMPage = new NavigatorSubsectionSummaryMPage();
	//Let the page know the identifier of the parent workflow page
	newMPage.setParentWorkflowIdentifier(this.getWorkflowViewId());
	//Inform the page that the detailed review subsection will let it know which components to load
	newMPage.setSelectiveComponentLoadInd(this.m_selectiveComponentLoadInd);
	//Only attempt to load the component settings if they are available.  It is possible they will be retrieved
	//at the time this subsection is activated.
	if(allComponentSettings) {
		newMPage.initializeView(this.getAssociatedViewElementId(), allComponentSettings);
		newMPage.loadViewSettings();
		newMPage.initializeComponents();
	}

	this.setAssociatedView(newMPage);
};

/**
 * Changes the background color and adds the right white arrow to the component link in the navigator.
 * @param {MpageComponent} component Can be a reference to an MpageComponent or an object
 * which has its own dummy versions of getStyles().getComponentId()
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.highlightNavigator = function(component) {
	var navigatorEle = null;
	if(component) {
		navigatorEle = this.m_subsectionBodyElement;
		//Remove the highlight from the current component
		navigatorEle.find('.dr-selected')
			.removeClass('dr-selected');
		//Highlight the newly selected element
		navigatorEle.find('#drNavi' + component.getStyles()
				.getId())
			.addClass('dr-selected');
	}
};

/**
 * This function is used to apply the current offset position of the associated view.  This is to allow the view to
 * remain in the same position before and after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.applyViewOffsetPosition = function() {
	//This functionality should be implemented at the instance level

	this.m_$viewElementObject.scrollTop(this.m_viewScrollOffset);
};

/**
 * This function is used to save the current offset position of the associated view.  This is to allow the view to
 * remain in the same position before and after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.saveViewOffsetPosition = function() {
	//This functionality should be implemented at the instance level
	this.m_viewScrollOffset = this.m_$viewElementObject.scrollTop();
};

/**
 * This function is fired on EventListener.EVENT_COUNT_UPDATE and is used to update the count displayed next to the
 * component's navigator element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to update the component count.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCountUpdate = function(component, args) {
	try {
		var compNavEle = this.m_subsectionBodyElement.find('#drNavi' + component.getStyles().getId());
		//Update the count for this element
		if(compNavEle.length) {
			if(args.count !== null && compNavEle.find('.dr-error').hasClass('hidden')) {
				compNavEle.find('.dr-count').html('(' + args.count + ')').removeClass('hidden');
			}
			else {
				compNavEle.find('.dr-count').html('(null)').addClass('hidden');
			}
		}
	}
	catch(err) {
		logger.logJSError(err, component, 'detailed-review.js', 'onCountUpdate');
	}
};

/**
 * This function is fired on EventListener.EVENT_SCROLL - when user clicks Checkout component label.
 * @param {MPageComponent} checkoutComponent A reference to the Checkout component.
 * @param {String} namespace component name space.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCheckoutScroll = function(checkoutComponent, namespace) {
	var componentCnt = 0;
	var components = null;
	var assocView = this.getAssociatedView();
	if(!assocView) {
		return;
	}
	var viewEle = $('#' + this.getAssociatedViewElementId())
		.find('.col1');
	/*
	 * This would be unique checkout component id across
	 * different views.
	 */
	var uniqueCheckoutComponentViewId = viewEle.find('#' + checkoutComponent.getStyles()
			.getId());

	/*
	 * uniqueCheckoutComponentViewId.length would be '0'
	 * for other checkout components set in other views.
	 * The same is true if check out component is not
	 * configured in other views as well.
	 */

	if(uniqueCheckoutComponentViewId.length) {
		components = assocView.getComponents();
		componentCnt = components.length;
		var throwError = true;

		for(var x = 0; x < componentCnt; x++) {

			if(components[ x ].getStyles()
					.getNameSpace() === namespace && components[ x ].isDisplayable()) {
				//Scroll the component to the top of the view
				if(viewEle.length) {
					var component = viewEle.find('#' + components[ x ].getStyles()
							.getId());
					if(component.length) {
						throwError = false;
						this.scrollToComponent(component);
					}
				}
			}

		}
		/*
		 * Fire an event when corresponding component is missing in navigator.
		 */
		if(throwError) {
			CERN_EventListener.fireEvent(checkoutComponent, checkoutComponent, EventListener.EVENT_NAVIGATOR_ERR, namespace);
		}

	}
	else {
		// do nothing- return
		return;
	}

};

/**
 * This function is fired on EventListener.EVENT_CRITICAL_UPDATE and is used to show the critical icon displayed next
 * to the component's navigator element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to update the component critical indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCriticalUpdate = function(component, args) {
	try {
		var compNavEle = this.m_subsectionBodyElement.find('#drNavi' + component.getStyles()
				.getId());
		//Update the count for this element
		if(compNavEle.length) {
			if(args.critical !== null && $(compNavEle)
					.find('.dr-error')
					.hasClass('hidden')) {
				compNavEle.find('.dr-critical')
					.removeClass('hidden');
			}
			else {
				compNavEle.find('.dr-critical')
					.addClass('hidden');
			}
		}
	}
	catch(err) {
		logger.logJSError(err, component, 'detailed-review.js', 'onCriticalUpdate');
	}
};

/**
 * This function is fired on EventListener.EVENT_SATISFIER_UPDATE and is used to show the required or complete icon *
 * based on the checked value, displayed next to the component's navigator element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to update the indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onSatisfierUpdate = function(component, args) {
	var compNavEle = this.m_subsectionBodyElement.find('#drNavi' + component.getStyles().getId());
	//Mark the component as satisfied or not based on the status
	if(compNavEle.length) {
		if(args.satisfied && $(compNavEle).find('.dr-error').hasClass('hidden')) {
			compNavEle.find('.dr-required')
				.removeClass('dr-required')
				.addClass('dr-satisfied');
		}
		else {
			compNavEle.find('.dr-satisfied')
				.addClass('dr-required')
				.removeClass('dr-satisfied');
		}
	}
};
/**
 * This function is fired on EventListener.EVENT_ERROR_UPDATE and is used to show the error icon displayed next to the
 * component's navigator element.  This element is added on the fly since the probability for error is much less than
 * for a critical or count element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to update the component critical indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onErrorUpdate = function(component, args) {
	try {
		var compNavEle = this.m_subsectionBodyElement.find('#drNavi' + component.getStyles()
				.getId());
		//Update the count for this element
		if(compNavEle.length) {
			if(args.error) {
				//Show the error icon and hide the count and critical elements
				compNavEle.find('.dr-error').removeClass('hidden');
				compNavEle.find('.dr-count').html('(null)').addClass('hidden');
				compNavEle.find('.dr-critical').addClass('hidden');
			}
			else {
				compNavEle.find('.dr-error').addClass('hidden');
			}
		}
	}
	catch(err) {
		logger.logJSError(err, component, 'detailed-review.js', 'onErrorUpdate');
	}
};

/**
 * This funciton handles the event of a user wanting to move a component to the contextual view.
 * @param {DOMEvent} event The event that is fired when
 * @param {MPageComponent} component The component which is being moved in/out of contextual view
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onContextualViewMoveUpdate = function(event, component) {
	//If the compoent is removed from contextual view focus the component in the first column, else bring the
	// placeholder view.
	var compIndex = -1;
	if(component.isAddedToContextualView()) {
		compIndex = component.getRootPlaceholderComponentNode().index();
	}
	else {
		compIndex = $(component.getRootComponentNode()).index();
	}

	//Cache the last compnent incase this is the last component in navigator and its height is being changed by moving
	// between the two views.
	this.cacheLastVisibleComponent();
	this.generateNavigatorLinkClickFunction(component, compIndex);
};


/**
 * This function is used to generate click events for the navigator portion of the detailed review subsection
 * @param {MPageComponent} componentObj This component associated to the link that is being created.
 * @param {number} componentIndex The index of the component within the array of components which will be used when
 *     selectively loading components.
 * @returns {function} The function that will be executed when the user clicks one of the navigator elements
 */
DetailedReviewSubsection.prototype.generateNavigatorLinkClickFunction = function(componentObj, componentIndex) {
	var self = this;
	return function() {
		//The actual column div that contains the components
		var actualColumnDiv = $('#' + self.getAssociatedViewElementId()).find('.col1');
		var component = null;
		//Scroll the component to the top of the view
		if(actualColumnDiv.length) {
			//If the component is added to contextual view, get the placeholder view instead of the actual component
			if(componentObj.isAddedToContextualView()) {
				component = actualColumnDiv.find('#' + componentObj.getStyles().getId() + 'PlaceholderView');
			}
			else {
				component = actualColumnDiv.find('#' + componentObj.getStyles().getId());
			}
			if(component.length) {
				//Selectively load the selected component and make sure the call is blocking so the scroll function
				// doesn't start loading components as well
				if(self.m_selectiveComponentLoadInd) {
					self.loadSelectiveComponents(componentIndex, true, 0);
				}
				self.scrollToComponent(component);
			}
		}
		//Scrolling the component to the top triggers the scroll handler so we need to wait for a bit and then
		// highlight the component link that was clicked.
		setTimeout(function() {
			//Highlight the component link
			self.highlightNavigator(componentObj);
			//Capture Capability timer
			self.captureCapabilityTimer(componentObj);
		}, 0);
	};
};

/**
 * This function is used to capture the cap timer of the detailed review subsection elements on clicking navigation bar.
 * @param {MPageComponent} componentObj This component associated to the link that is being created.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.captureCapabilityTimer = function(componentObj) {
	var capTimer = new CapabilityTimer('CAP:MPG Detailed Review Subsection - Click Navigator Link', componentObj.getCriterion().category_mean);
	capTimer.addMetaData('rtms.legacy.metadata.1', componentObj.getReportMean());
	capTimer.capture();
};

/**
 * This method will scroll to a component in the view. If the component is towards the bottom, we must still allow the
 * component to be scrolled to the top, thus some additional space needs to be added to the bottom of the view.
 * @param {Object} $componentElementObject - The component root level element that will be scrolled into view.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.scrollToComponent = function($componentElementObject) {
	this.attemptPaddingAdjustment();
	this.m_$viewElementObject.scrollTop($componentElementObject.position().top);
};

/**
 * This method will find the last visible component in the view and cache the root level element.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.cacheLastVisibleComponent = function() {
	var assocView = this.getAssociatedView();
	var components = assocView.getComponents();
	var componentCount = components.length;
	for(var i = componentCount; i--;) {
		var component = components[ i ];
		if(components[ i ].isDisplayable()) {
			this.m_lastComponentId = component.getComponentId();
			//If the last component is the placeholder version of the component, get the root node of the placeholder
			// view instead.
			if(!component.isAddedToContextualView() || !assocView.canHaveContextualView()) { //eslint-disable-line mp-camelcase
				this.m_$lastComponentElement = $(components[ i ].getRootComponentNode()); //eslint-disable-line mp-camelcase
			}
			else if(component.isAddedToContextualView()) {
				this.m_$lastComponentElement = $(components[ i ].getRootPlaceholderComponentNode()); //eslint-disable-line mp-camelcase
			}
			return;
		}
	}
};

/**
 * This method will find if at least one component is marked as required in the view and sets the gap check indicator.
 * @returns {boolean} The function will return true if there is a required component in the view else returns false
 */
DetailedReviewSubsection.prototype.isGapCheckRequired = function() {
	if(this.m_gapCheckInd === null) {
		var components = this.getAssociatedView().getComponents();
		var componentCount = components.length;
		//Initially set it to false
		this.m_gapCheckInd = false;
		for(var i = 0; i < componentCount; i++) {
			if(components[ i ].getGapCheckRequiredInd()) {
				this.m_gapCheckInd = true;
				break;
			}
		}
	}
	return this.m_gapCheckInd;
};

/**
 * This method will find the first visible component in the view and return its index.
 * If no component is visible, it will return -1.
 * @returns {number} The index of the first visible component
 */
DetailedReviewSubsection.prototype.getFirstVisibleComponentIndex = function() {
	var components = this.getAssociatedView().getComponents();
	var componentCount = components.length;
	for(var i = 0; i < componentCount; i++) {
		if(components[ i ].isDisplayable()) {
			return i;
		}
	}
	return -1;
};

/**
 * Store the latest dimensions used in the padding adjustment functionality. We store the last component height
 * so that we only adjust the padding when the height of the last component has changed. We store the last padding
 * height because it is used in calculating the new padding value since it is now included in the total view height.
 * @param {Number} lastComponentHeight - The height (in pixels) of the last component in the view since the last padding
 * adjustment.
 * @param {Number} paddingHeight - The height (in pixels) of the padding element in the view since the last padding
 * adjustment.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.storeLatestElementDimensions = function(lastComponentHeight, paddingHeight) {
	this.m_lastComponentHeight = lastComponentHeight;
	this.m_lastPaddingHeight = paddingHeight;
};

/**
 * This method adjusts the padding element at the bottom of the workflow to ensure the component is able to be scrolled
 * to the top of the workflow.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.attemptPaddingAdjustment = function() {
	var currentLastComponentHeight = null;
	var contentHeight = 0;
	var viewportHeight = 0;
	var componentPosition = 0;
	var lastComponentObj = null;
	//If we have not yet cached the last component root element, do that now
	if(!this.m_$lastComponentElement) {
		this.cacheLastVisibleComponent();
	}
	if(!this.m_$viewElementObject) {
		this.m_$viewElementObject = $('#' + this.getAssociatedViewElementId()).find('.col1');
	}
	//Let the content object be the actual column containing the components.
	if(!this.m_$contentObject && this.m_$lastComponentElement) {
		this.m_$contentObject = this.m_$lastComponentElement.closest('.components-col-container');
	}
	if(!this.m_$paddingPlaceholder && this.m_$contentObject) {
		this.m_$paddingPlaceholder = $('<div class=\'padding-placeholder\'></div>').appendTo(this.m_$contentObject);
	}
	//Extra padding since we are missing an actual component being replaced with placeholder placeholder.
	if(this.m_$lastComponentElement) {
		currentLastComponentHeight = $(this.m_$lastComponentElement).outerHeight();
		componentPosition = this.m_$lastComponentElement.position().top;
		lastComponentObj = MP_Util.GetCompObjById(this.m_lastComponentId); //eslint-disable-line new-cap
	}

	//If the last component is added to contextual view then the actual component is replaced by the placeholder which
	// has a static height. This would prevent the height of the padding placeholder from changing while scrolling
	// down. In order to avoid this a check on height of the last component  is added along with a check  whether the
	// last component was not added to contextual view.
	if(this.m_lastComponentHeight === currentLastComponentHeight && !lastComponentObj.isAddedToContextualView()) {
		return;
	}
	if(this.m_$contentObject) {
		contentHeight = this.m_$contentObject.outerHeight();
	}

	if(this.m_$viewElementObject) {
		viewportHeight = $(this.m_$viewElementObject).outerHeight();
	}

	//This checks to see if there is enough space below the component that would allow it to be scrolled to the top of
	//the view. If not, adjust the padding element such that the component can be scrolled into view.
	var paddingHeight = Math.max(viewportHeight - contentHeight + componentPosition + this.m_lastPaddingHeight, 0);
	if(this.m_$paddingPlaceholder) {
		this.m_$paddingPlaceholder.css({
			'height': paddingHeight + 'px'
		});
	}

	//Store the current dimensions so we can use them later for calculations and comparisons
	this.storeLatestElementDimensions(currentLastComponentHeight, paddingHeight);
};

/**
 * Generate the HTML for the subsection body.  This implementation takes the associated view and determines the
 * components which will be displayed.  It uses that list of components to render a navigator within the subsection
 * body.
 * @returns {String} The HTML which will be inserted into the subsection body
 */
DetailedReviewSubsection.prototype.generateBodyHTML = function() {
	var assocView = null;
	var component = null;
	var componentCnt = 0;
	var components = null;
	var navEle = null;
	var self = this;
	var subSecBodyEle = null;
	var x = 0;
	var requiredStatus = false;
	var requiredClass = '';
	var requiredContentHtml = '';


	try {
		//Determine which components are shown and in what order
		assocView = this.getAssociatedView();
		if(!assocView) {
			return null;
		}
		components = assocView.getComponents();
		componentCnt = components.length;
		if(componentCnt) {
			//Order the components by the comp_seq so we know before they are rendered what order they will be in
			components.sort(function(a, b) {
				var aSeq = a.getSequence();
				var bSeq = b.getSequence();
				if(aSeq < bSeq) {
					return -1;
				}
				//No two sequences will be the same so we already know bSeq > aSeq at this point.
				return 1;
			});

			//Create the list of components for the subsection body
			subSecBodyEle = $('<div></div>');
			for(x = 0; x < componentCnt; x++) {
				component = components[ x ];
				if(component.isDisplayable()) {
					//Append a required Indicator against the component navigator element when the Required Indicator
					// is set true
					if(this.isGapCheckRequired()) {
						requiredContentHtml = '';
						requiredStatus = component.getGapCheckRequiredInd();
						requiredClass = (requiredStatus) ? 'dr-required' : 'dr-required dr-hidden';
						requiredContentHtml = '<span class=\'' + requiredClass + '\'>&nbsp;</span>';
					}

					//Create the component navigation elements for each component
					if(this.m_selectiveComponentLoadInd) {
						navEle = $('<div id=\'drNavi' + component.getStyles().getId() + '\' class=\'dr-comp-link\' title=\'' + i18n.discernabu.detailed_review.COMPONENT_NOT_LOADED + '\'>' + requiredContentHtml + '<div class=\'dr-error hidden\'>&nbsp;</div>' + component.getLabel() + '<span class=\'dr-count\'>...</span><span class=\'dr-critical hidden\'>&nbsp;</span></div>');
					}
					else {
						navEle = $('<div id=\'drNavi' + component.getStyles().getId() + '\' class=\'dr-comp-link\'>' + requiredContentHtml + '<div class=\'dr-error hidden\'>&nbsp;</div>' + component.getLabel() + '<span class=\'dr-count\'>&nbsp;</span><span class=\'dr-critical hidden\'>&nbsp;</span></div>');
					}

					//Add the click event to the element and add to the list
					navEle.click(this.generateNavigatorLinkClickFunction(component, x));
					$(subSecBodyEle).append(navEle);
				}
			}

			//Add an event listener for the critical updates and the count updates
			//We can just use the last component as the listener object since all components will share the same object
			// definition
			CERN_EventListener.addListener(component, EventListener.EVENT_COUNT_UPDATE, this.onCountUpdate, this);
			CERN_EventListener.addListener(component, EventListener.EVENT_CRITICAL_UPDATE, this.onCriticalUpdate, this);
			CERN_EventListener.addListener(component, EventListener.EVENT_ERROR_UPDATE, this.onErrorUpdate, this);
			CERN_EventListener.addListener(component, EventListener.EVENT_SCROLL, this.onCheckoutScroll, this);
			//Change the required Icon if the component is satisfied
			CERN_EventListener.addListener(component, EventListener.EVENT_SATISFIER_UPDATE, this.onSatisfierUpdate, this);
			//When a component is added to or removed from the contextual  view add focus to the component in the view.
			CERN_EventListener.addListener(component, EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW, this.onContextualViewMoveUpdate, this);

			//Add drag and drop support
			subSecBodyEle.sortable({
				axis: 'y',
				containment: subSecBodyEle,
				distance: 5,
				items: '.dr-comp-link',
				placeholder: 'dr-comp-link-placeholder',
				tolerance: 'pointer',
				update: function(ev, ui) {
					try {
						var compEle = null;
						var compId = '';
						var compLinkEle = null;
						var prevEle = null;
						var prevEleId = '';
						var columnEle = null;

						//Get the component before the sorted component
						compLinkEle = $(ui.item);
						compId = compLinkEle.attr('id').replace('drNavi', '');
						prevEle = compLinkEle.prev();
						//Get the container that contains the component in the column.
						columnEle = $('#' + self.getAssociatedViewElementId() + ' .col1').find('.components-col-container');
						//Checking for the placeholder view of the component if it exists.
						compEle = columnEle.find('#' + compId).length ? columnEle.find('#' + compId) : columnEle.find('#' + compId + 'PlaceholderView');

						if(prevEle.length) {
							//Component is not at the beginning of the list
							prevEleId = prevEle.attr('id').replace('drNavi', '');
							prevEle = columnEle.find('#' + prevEleId);
							//If the actual component could not be found in the column, then we have it is placeholder
							// view.
							if(!prevEle.length) {
								prevEle = columnEle.find('#' + prevEleId + 'PlaceholderView');
							}
							compEle.insertAfter(prevEle);
						}
						else {
							//Component is now at the beginning of the list
							columnEle.prepend(compEle);
						}

						//Call the functions to update the component preferences for this workflow page
						MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(components, true, true); //eslint-disable-line new-cap

						//Resort the components since their sequence has changed.
						components.sort(function(a, b) {
							var aSeq = a.getSequence();
							var bSeq = b.getSequence();
							if(aSeq < bSeq) {
								return -1;
							}
							//No two sequences will be the same so we already know bSeq > aSeq at this point.
							return 1;
						});
						//Loop through the components and re-attach their click functions and trigger any action that
						// needs to be done post location change of the component that was dragged
						for(x = 0; x < componentCnt; x++) {
							component = components[ x ];
							if(component.isDisplayable()) {
								subSecBodyEle.find('#drNavi' + component.getStyles().getId()).unbind('click').click(self.generateNavigatorLinkClickFunction(component, x));
								if(component.getStyles().getId() === compId) {
									//save the component reference since the 'component' variable could change in a
									// loop.
									var movedComponent = component;
									setTimeout(function() {
										movedComponent.postDOMLocationChange();
									}, 0);
								}
							}
						}
					}
					catch(err) {
						logger.logJSError(err, null, 'detailed-review.js', 'scrolling: update');
					}
				},

				start: function(ev, ui) {
					//Add these classes so if the cursor no longer hovers over the elements it retains its styling
					var item = $(ui.item);
					if(item.hasClass('dr-selected')) {
						item.addClass('dr-link-selected-sorting');
					}
					else {
						item.addClass('dr-link-sorting');
					}
				},

				stop: function(ev, ui) {
					var item = $(ui.item);
					//Remove any styling added when sorting
					item.removeClass('dr-link-selected-sorting dr-link-sorting');
					//Since the components have been reordered, the last component element must be re-obtained
					self.cacheLastVisibleComponent();
					//Highlight and navigate to the component
					item.click();
					var capTimer = new CapabilityTimer('CAP:MPG Workflow Navigator Component Sort', assocView.getCriterion().category_mean);
					capTimer.capture();
				}

			});

			return subSecBodyEle;
		}
		else {
			//No components to show so we can just return a space
			return '&nbsp;';
		}
	}
	catch(error) {
		logger.logJSError(error, null, 'detailed-review.js', 'generateBodyHTML');
	}
};

/**
 * This function is used to selectively load components as they are selected/scrolled to in the navigator. If the
 * caller passes in the blockingTimeout flag set to true the function will prevent all future calls to this function
 * from processing until the initial call has completed. This function will return true if it has created a timeout
 * function for selectively loading the component.  However there is no guarantee that the function will execute unless
 * the blockingTimeout flag passed in is true and there currently isn't a blocking timeout active.
 * @param {number} startIndx The starting index in the componentArr where components should be notified that they can
 *     begin data retrieval
 * @param {boolean} blockingTimeout The flag that indicates whether the function will prevent all future calls to this
 *     function from processing until the initial call has completed
 * @param {number} timespan The timeout to apply before
 * @param {boolean} registerTimerInd The flag that indicates whether the components should be registered in the
 *     aggregate timer. This flag should be only true when the view is being rendered and starting data retrieval for
 *     the first few components.
 * @returns {boolean} True if components will attempt to be selectively loaded, false if the call is going to be ignored
 */
DetailedReviewSubsection.prototype.loadSelectiveComponents = function(startIndx, blockingTimeout, timespan, registerTimerInd) {
	var self = this;
	//Check to see if there is an existing blocking timeout
	blockingTimeout = blockingTimeout || false;
	if(this.m_blockingComponentLoadTimeout) {
		return false;
	}

	//Set the blocking timeout flag if we need to
	if(blockingTimeout) {
		this.m_blockingComponentLoadTimeout = true;
	}

	//Wrap the contents of this function in a timeout so we don't rapidly fire it
	clearTimeout(this.m_componentLoadTimeout);
	this.m_componentLoadTimeout = setTimeout(function() {
		var associatedMPage = self.getAssociatedView();
		var component = null;
		var componentArr = associatedMPage.getComponents();
		var componentCount = componentArr.length;
		var componentsToLoad = self.m_componentsToLoad;
		var navigatorBody = self.m_subsectionBodyElement;
		var x = 0;

		//retrieve the aggregate timer created from the associated View
		var aggregateTimer = associatedMPage.getAggregateTimer();

		//the number of the components loaded in the initial page load
		var initialComponentCount = 0;

		//Start loading the components until we hit our quota or we run out of components
		for(x = startIndx; x < componentCount; x++) {
			component = componentArr[ x ];
			//Load the component if it is displayable
			if(component.isDisplayable()) {
				if(!component.isLoaded() && ((componentsToLoad > 0) || component.getGapCheckRequiredInd())) {
					if(registerTimerInd) {
						// register the component in the aggregate timer before data retrieval begins
						aggregateTimer.registerTask(component.getStyles().getId());
						// pass the reference of the aggregate timer to the component, so it will notify the timer when
						// it finishes loading
						component.setAggregateTimer(aggregateTimer);
					}

					//count the component because it will be loaded
					initialComponentCount++;
					associatedMPage.loadSelectedComponent(component);
					//Remove the hover(title) of the component since it has been loaded
					navigatorBody.find('#drNavi' + component.getStyles().getId()).attr('title', '');
					//Remove the (...) from the component to show that it is being loaded
					self.onCountUpdate(component, {
						count: null
					});
				}
				componentsToLoad--;
			}
		}

		if(registerTimerInd) {
			//add the number of components to meta data
			aggregateTimer.addMetaData('component.count', componentCount);

			//add the number of initially loaded components to meta data (all components are loaded in initial load)
			aggregateTimer.addMetaData('component.initialLoadCount', initialComponentCount);

			// Lock the registration when initial loading components are registered.
			aggregateTimer.lockRegistration();
		}

		//Blindly clear the blocking timeout flag
		self.m_blockingComponentLoadTimeout = false;
	}, timespan);
	return true;
};

/**
 * This function is used to handle the special processing required when the user scrolls the contents of the MPages
 * View associated with this Detailed Review subsection.  When then user scrolls the page this function will highlight
 * the correct component in the navigator so the user can visually keep track of where they are in context of the
 * entire page. With the addition of contextual view and components being replaced with placeholder views, the
 * component would not load rather display the placeholder view.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.associatedViewScrollHandler = function() {
	var component = null;
	var components = this.getAssociatedView().getComponents();
	var componentsCnt = components.length;
	var componentEle = null;
	var componentOffset = 0;
	var pixelProximity = 75;
	var x = 0;
	//Checking in the first column now since we have assigned the scroll handler to it.
	var firstColumnDiv = $('#' + this.getAssociatedViewElementId() + ' .col1');
	//Check each component and see if it is close to the top of the view container
	for(x = 0; x < componentsCnt; x++) {
		component = components[ x ];
		var compId = component.getStyles().getId();
		var actualCompDiv = firstColumnDiv.find('#' + compId);
		componentEle = actualCompDiv.length ? actualCompDiv : firstColumnDiv.find('#' + compId + 'PlaceholderView');
		if(componentEle.length) {
			componentOffset = componentEle.offset().top;

			//If the component is too far scrolled up just continue
			if(componentOffset < 0 && (componentOffset + pixelProximity < 0)) {
				continue;
			}
			//If the component is still within our proximity or it is the next visible component highlight it
			if((Math.abs(this.m_viewElementOffsetTop - componentOffset) < pixelProximity) || componentOffset > 0) {
				this.attemptPaddingAdjustment();
				//Highlight this component in the navigator
				this.highlightNavigator(component);
				if(this.m_selectiveComponentLoadInd) {
					this.loadSelectiveComponents(x, false, 250, false);
				}
				break;
			}
		}
	}
};

/**
 * This function is used to gather the dynamic documentation components which are dirty;
 * @returns {Array} dirtyComps Array of dirty DocumentationBaseComponent instances associated to current subsection view
 */
DetailedReviewSubsection.prototype.gatherDirtyComponents = function() {
	var compObj = null;
	var dirtyComps = [];
	var compArr = this.getAssociatedView().getComponents();
	//If the documentation base component isn't defined we don't have any DynDoc components
	if(typeof DocumentationBaseComponent === 'undefined') {
		return dirtyComps;
	}

	//Grab all of the dirty components
	var editor = null;
	var structuredView = null;
	var structuredOrganizer = null;
	for(var x = compArr.length; x--;) {
		compObj = compArr[ x ];
		if(compObj instanceof DocumentationBaseComponent) {
			editor = compObj.getEditorInstance();
			structuredView = compObj.getStructuredView();

			if(structuredView !== null) {
				structuredOrganizer = structuredView.getOrganizer();
			}

			if((editor !== null && editor.isEditorDirty()) || (structuredOrganizer !== null && structuredOrganizer.checkIsDirty())) {
				dirtyComps.push(compObj);
			}
		}
	}
	return dirtyComps;
};


/**
 * The create note function is responsible for gathering the dynamic documentation component content
 * from the associated view along with the association of templateId and noteTypeId and sending that content to the
 * Dynamic Documentation COM object. If it is determined that any of the components has not yet saved data, the
 * autosave functionality will be executed prior to launching the Dynamic Documentation editor.
 * @param {number} templateId - The template ID of Association
 * @param {number} noteTypeId - The note type ID of Association
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.createNote = function(templateId, noteTypeId) {
	var dirtyComponents = [];
	var gapCheckStatus = this.isGapCheckRequired();
	//Gather all the dirty components that apply
	dirtyComponents = this.gatherDirtyComponents();

	if(dirtyComponents.length > 0) {
		//Autosave dirty components before navigating to Dyn Doc
		this.saveDirtyComponents(templateId, noteTypeId);
	}
	else if(gapCheckStatus) {
		this.initiateGapChecking(templateId, noteTypeId);
	}
	else {
		//Navigate to Dyn Doc if no editors are dirty
		this.openDynDocEditor(templateId, noteTypeId);
	}
};


/**
 * The initiateGapChecking function is responsible for Initiating the Gap Check on the unsatisfied component,that are
 * marked as override required.
 * @param {number} templateId - The template ID of Association
 * @param {number} noteTypeId - The note type ID of Association
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.initiateGapChecking = function(templateId, noteTypeId) {
	var self = this;
	var components = self.getAssociatedView().getComponents();
	var criterionObj = self.getCriterion();
	var encntrTypeFlag = 0;
	if(!self.m_gapCheckInstance) {
		//Initiate Gap check before moving to Dyn Doc
		self.m_gapCheckInstance = new GapCheck();
		encntrTypeFlag = 1;
	}
	else {
		encntrTypeFlag = 0;
	}
	self.m_gapCheckInstance.setResponseHandler(function() {
		self.openDynDocEditor(templateId, noteTypeId);
	});
	self.m_gapCheckInstance.InitiateGapCheck(components, criterionObj, encntrTypeFlag); //eslint-disable-line new-cap
};
/**
 * The create context menu function generates the context menu for the More option in the Navigator
 * and adds click functionality to each of the menu items. Also, it adds 'Select Other Note' item at the end of all
 * association links.
 * @param  {number} faceUpLinksCount - The count of associations displayed face up.
 * @param  {object} moreEle - The HTML element of More option
 * @param {object} filterObj - The object of page level filters
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.createMoreNoteContextMenu = function(faceUpLinksCount, moreEle, filterObj) {
	var createMoreNoteContextMenu = null;
	var detailedReviewi18n = i18n.discernabu.detailed_review;
	var self = this;
	var i = 0;
	var templateId = null;
	var noteTypeId = null;
	var criterion = this.getCriterion();
	var categoryMean = criterion.category_mean;
	var contextMenuOtherSelectionItem = null;
	var assocInfo = filterObj.VALS;
	createMoreNoteContextMenu = MP_MenuManager.getMenuObject('createMoreNoteContextMenu' + categoryMean);
	if(!createMoreNoteContextMenu) {
		createMoreNoteContextMenu = new ContextMenu().setId('createMoreNoteContextMenu' + categoryMean).setIsRootMenu(true).setAnchorElementId(moreEle.attr('id')).setAnchorConnectionCorner([ 'bottom', 'left' ]).setContentConnectionCorner([ 'top', 'left' ]);
		for(i = faceUpLinksCount; i < assocInfo.length; i++) {
			templateId = assocInfo[ i ].PE_ID2;
			noteTypeId = assocInfo[ i ].PE_ID;
			createMoreNoteContextMenu.addMenuItem(self.createMoreNoteMenuItem(assocInfo[ i ].FTXT, templateId, noteTypeId));
			MP_MenuManager.addMenuObject(createMoreNoteContextMenu);
		}
		contextMenuOtherSelectionItem = new MenuSelection(detailedReviewi18n.SELECT_OTHER_NOTE).setLabel(detailedReviewi18n.SELECT_OTHER_NOTE);
		contextMenuOtherSelectionItem.setClickFunction(function() {
			self.createNote(0, 0);
		});
		createMoreNoteContextMenu.addMenuItem(contextMenuOtherSelectionItem);
		MP_MenuManager.addMenuObject(createMoreNoteContextMenu);
	}
	//Show context menu
	MP_MenuManager.showMenu(createMoreNoteContextMenu.getId());
};

/**
 * The create more note menu item function generates the menu items opened inside the context menu on clicking the More
 * option.
 * @param  {string} title - Label of the menu item.
 * @param  {number} templateId - The templateId of the association
 * @param {number} noteTypeId - The noteTypeId of the association
 * @returns {object} This function returns a menu item
 */
DetailedReviewSubsection.prototype.createMoreNoteMenuItem = function(title, templateId, noteTypeId) {
	var self = this;
	var gapCheckStatus = self.isGapCheckRequired();
	var contextMenuSelectionItem = new MenuSelection(title).setLabel(title);
	contextMenuSelectionItem.setClickFunction(function() {
		if(gapCheckStatus) {
			self.initiateGapChecking(templateId, noteTypeId);
		}
		else {
			self.openDynDocEditor(templateId, noteTypeId);
		}
	});
	return contextMenuSelectionItem;
};

/**
 * Navigate to CreateNewNote functionality of DYNDOC API inside Win32 Dynamic Documentation Editor  * if templateId and
 * noteTypeId are not null.  If null then navigate to Win32 Dynamic Documentation Editor
 * @param {number} templateId - The template ID of Association
 * @param {number} noteTypeId - The note type ID of Association
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.openDynDocEditor = function(templateId, noteTypeId) {
	var self = this;
	var sendAr = null;
	var criterion = this.getCriterion();
	var data = null;
	var personId = criterion.person_id;
	var encounterId = criterion.encntr_id;
	var workflowId = 0;
	var eventCd = 0;
	var workflowResource = MP_Resources.getSharedResource('documentationWorkflow');
	//This function is used to handle the data received from the event listener
	var handleResponse = function(event, dataString) {
		if(templateId && noteTypeId) {
			sendAr = [ '^MINE^', noteTypeId + '.0' ];
			var getEventCdRequest = new ScriptRequest().
				setProgramName('mp_get_event_cd_by_note_type').
				setParameterArray(sendAr).
				setAsyncIndicator(false).
				setResponseHandler(function(reply) {
					if(reply.getStatus() === 'S') {
						eventCd = reply.getResponse().EVENT_CD;
						data = JSON.parse(dataString);
						workflowId = data.RECORD_DATA.WORKFLOW_ID;
						//Calling the OpenNewDocumentByReferenceTemplateIdAndNoteType API of DYNDOC
						CERN_Platform.getDiscernObject('DYNDOC').OpenNewDocumentByReferenceTemplateIdAndNoteType(personId, encounterId, templateId, eventCd); //eslint-disable-line new-cap
					}
					else {
						logger.logError('mp_get_event_cd_by_note_type failed: unable to get response');
						return;
					}
				});
			getEventCdRequest.performRequest();
		}
		else {
			if(dataString) {
				data = JSON.parse(dataString);
				if(data) {
					data = data.RECORD_DATA;
				}
			}
			// looks like we have data
			if(data) {
				workflowId = data.WORKFLOW_ID;
				CERN_Platform.getDiscernObject('DYNDOC').OpenDynDocByWorkflowId(personId, encounterId, workflowId); //eslint-disable-line new-cap
			}
		}
	};
	if(workflowResource) {
		if(workflowResource.isResourceAvailable()) {
			//The workflowId is available so we can now open the DynDoc editor
			handleResponse(null, workflowResource.getResourceData());
		}
		else {
			//The workflowId isn't available yet so start the data retrieval and register for the response
			workflowResource.retrieveSharedResourceData();
			CERN_EventListener.addListener(self, 'documentationWorkflowAvailable', handleResponse, self);
		}
	}
	else {
		//We need to create the Shared Resource, kick off data retrieval and register for the response
		sendAr = [ '^MINE^', criterion.person_id + '.0', criterion.encntr_id + '.0', criterion.provider_id + '.0' ];
		workflowResource = MP_Resources.createSharedResourceObj('documentationWorkflow', self, 'MP_GET_WORKFLOW', sendAr, 'documentationWorkflowAvailable');
		if(workflowResource) {
			workflowResource.retrieveSharedResourceData();
			CERN_EventListener.addListener(self, 'documentationWorkflowAvailable', handleResponse, self);
		}
	}
};


/**
 * Saves dirty DocumentationBase components within current detailed review subsection
 * @param {number} templateId - The template ID of Association
 * @param {number} noteTypeId - The note type ID of Association
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.saveDirtyComponents = function(templateId, noteTypeId) {
	var self = this;
	var successCount = 0;
	var totalSaved = 0;
	var dirtyDatai18n = i18n.discernabu.detailed_review;
	var dirtyComponents = [];
	var saveModal = null;
	var cancelModalBtn = null;
	var saveModalBtn = null;
	var gapCheckStatus = self.isGapCheckRequired();

	// reset/figure out total number of dirty components
	dirtyComponents = this.gatherDirtyComponents();
	var totalDirty = dirtyComponents.length;

	//Update Modal box to saving in progress state
	saveModal = MP_Util.generateModalDialogBody('DirtyDataDialog', 'busy', dirtyDatai18n.SAVING, '');
	saveModal.setHeaderTitle(dirtyDatai18n.UNSAVED_DOCUMENTATION);

	for(var x = 0; x < totalDirty; x++) {
		dirtyComponents[ x ].save(function(status) {
			//If the save was successful increment total(attempted) saved and success count
			if(status === 'S') {
				successCount++;
				totalSaved++;
			}
			//If the save wasn't successful just increment total(attempted) saved
			else {
				totalSaved++;
			}

			//If the number of successful saves equals number of dirty components then continue to DynDoc
			if(successCount === totalDirty) {
				MP_ModalDialog.closeModalDialog('DirtyDataDialog');
				if(gapCheckStatus) {
					self.initiateGapChecking(templateId, noteTypeId);
				}
				else {
					self.openDynDocEditor(templateId, noteTypeId);
				}
			}
			//If the total(attempted) saves equals the number of dirty components but the successful saves isn't the
			// same, alert the user
			if(totalSaved === totalDirty && successCount !== totalDirty) {
				//error Dialog box saying something didn't save correctly
				saveModal = MP_Util.generateModalDialogBody('DirtyDataDialog', 'error', dirtyDatai18n.FAILED_TO_SAVE_MSG_HEADER, dirtyDatai18n.FAILED_TO_SAVE_MSG_BODY);
				saveModal.setFooterButtonText('saveDirtyModal', dirtyDatai18n.RETRY_BTN);
				saveModal.setHeaderTitle(dirtyDatai18n.FAILED_TO_SAVE);
				saveModal.setFooterButtonDither('saveDirtyModal', false);
			}
		});
	}
	//Create the modal save (retry) button if it isn't already defined
	if(!saveModal.getFooterButton('saveDirtyModal')) {
		saveModalBtn = new ModalButton('saveDirtyModal');
		saveModalBtn.setFocusInd(true).setCloseOnClick(false).setText(dirtyDatai18n.SAVE_BTN);
		saveModalBtn.setOnClickFunction(function() {
			self.saveDirtyComponents(templateId, noteTypeId);
		});
		saveModal.addFooterButton(saveModalBtn);
	}
	//Create the modal cancel button if it isn't already defined
	if(!saveModal.getFooterButton('cnlModal')) {
		cancelModalBtn = new ModalButton('cnlModal');
		cancelModalBtn.setText(dirtyDatai18n.CANCEL_BTN);
		saveModal.addFooterButton(cancelModalBtn);
	}
	//Create/launch Modal Dialog Box
	MP_ModalDialog.updateModalDialogObject(saveModal);
	MP_ModalDialog.showModalDialog('DirtyDataDialog');
};

/**
 * This function is used to add the 'Create Note' label to the bottom of the Navigator face up along with 'Select Other
 * Note' option. It then adds the association links in the navigator which are selected in the bedrock filter only upto
 * the limit of 5. If the associations are more than 5 then More option is added, on the click of which open up a
 * context menu with further associations. The association links will be generated below the 'Create Note' label.
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.addCreateNoteLink = function() {
	var component = null;
	var components = this.getAssociatedView().getComponents();
	var componentsCnt = components.length;
	var count = 0;
	var createNoteEle = null;
	var criterion = this.getCriterion();
	var detailedReviewi18n = i18n.discernabu.detailed_review;
	var dynDoc = ('external' in window) && ('DiscernObjectFactory' in window.external) && window.external.DiscernObjectFactory('DYNDOC'); //eslint-disable-line new-cap
	var dynDocAvailable = dynDoc && ('OpenDynDocByWorkflowId' in dynDoc);
	var dynDocBaseDefined = (typeof DocumentationBaseComponent !== 'undefined');
	var faceUpLinksCount = 5;
	var filterObj = null;
	var i = 0;
	var index = 0;
	var noteTypeId = 0;
	var patternEle = null;
	var self = this;
	var selectOtherNoteEle = null;
	var templateId = 0;
	var x = 0;
	if(dynDocAvailable && dynDocBaseDefined) {
		for(x = componentsCnt; x--;) {
			component = components[ x ];
			if(component instanceof DocumentationBaseComponent && component.isDisplayable()) {
				createNoteEle = $('<div class=\'dr-create-note\'>' + detailedReviewi18n.CREATE_NOTE + '</div>');
				this.m_subsectionBodyElement.append(createNoteEle);
				var resourceName = criterion.category_mean + 'pageLevelFilters';
				var pageLevelFilters = MP_Resources.getSharedResource(resourceName);
				var plFilters = pageLevelFilters.getResourceData();
				var plFiltersLen = plFilters.length;
				if(pageLevelFilters && pageLevelFilters.isResourceAvailable() && plFiltersLen > 0) {
					//At this point, the codes are already available, so get the data
					for(index = 0; index < plFiltersLen; index++) {
						filterObj = plFilters[ index ];
						if(filterObj.F_MN === 'WF_NOTE_TEMPLATE_PAIR') {
							count = filterObj.VALS.length;
							if(count > faceUpLinksCount) {
								for(i = 0; i < faceUpLinksCount; i++) {
									patternEle = $('<div class=\'dr-create-assoc-link\' note-type-id=\'' + filterObj.VALS[ i ].PE_ID + '\' data-template-id=\'' + filterObj.VALS[ i ].PE_ID2 + '\'>' + filterObj.VALS[ i ].FTXT + '</div>');
									patternEle.click(function() {
										templateId = $(this).attr('data-template-id');
										noteTypeId = $(this).attr('note-type-id');
										self.createNote(templateId, noteTypeId);
									});
									this.m_subsectionBodyElement.append(patternEle);
								}
								this.addMoreNoteContextMenu(faceUpLinksCount, filterObj);
								return;
							}
							else {
								for(i = 0; i < count; i++) {
									patternEle = $('<div class=\'dr-create-assoc-link\' note-type-id=\'' + filterObj.VALS[ i ].PE_ID + '\' data-template-id=\'' + filterObj.VALS[ i ].PE_ID2 + '\'>' + filterObj.VALS[ i ].FTXT + '</div>');
									patternEle.click(function() {
										templateId = $(this).attr('data-template-id');
										noteTypeId = $(this).attr('note-type-id');
										self.createNote(templateId, noteTypeId);
									});
									this.m_subsectionBodyElement.append(patternEle);
								}
							}
						}
					}
				}
				selectOtherNoteEle = $('<div class=\'dr-create-more-link\'>' + detailedReviewi18n.SELECT_OTHER_NOTE + '</div>');
				selectOtherNoteEle.click(function() {
					self.createNote(0, 0);
				});
				this.m_subsectionBodyElement.append(selectOtherNoteEle);
				return;
			}
		}
	}
};

/**
 * This function adds the More option if the number of associations selected in the bedrock filter are more than 5. It
 * then makes a call to createMoreNoteContextMenu function to create a context menu with the associations
 * @param {number} faceUpLinksCount - The count of associations to be displayed face up
 * @param {object} filterObj - The object of page level filters
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.addMoreNoteContextMenu = function(faceUpLinksCount, filterObj) {
	var self = this;
	var moreEle = null;
	var categoryMean = this.getCriterion().category_mean;
	var detailedReviewi18n = i18n.discernabu.detailed_review;
	moreEle = $('<div id = \'createMoreNoteContextMenu' + categoryMean + '\' class=\'dr-create-more-link\'>' + detailedReviewi18n.MORE + '<span class=\'dr-create-more-down-link\'></span></div>');
	moreEle.click(function() {
		self.createMoreNoteContextMenu(faceUpLinksCount, $(this), filterObj);
	});
	this.m_subsectionBodyElement.append(moreEle);
};


/**
 * This function renders the View element associated with this subsection.  In addition to rendering that view it
 * also attaches scroll detection to the view and highlights the first component link in the navigation section
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.renderSubsection = function() {
	var self = this;

	//Save off a reference to the subsection body for later use
	this.m_subsectionBodyElement = $('#' + this.getBodyElementId());

	//Call the base class definition of this function
	NavigatorSubsection.prototype.renderSubsection.call(this);
	var viewDiv = $('#' + this.getAssociatedViewElementId());
	//Get the parent container
	var parentViewDiv = viewDiv.parent();
	//Since the first column in the layout contains all the components removing the scroll event handler from the
	// parent container to the first column in the view would prevent shifting of the control from parent to this
	// column when the contextual view is added.
	var firstColumnDiv = viewDiv.find('.col1');
	if(firstColumnDiv.length) {
		firstColumnDiv.height(parentViewDiv.height());
		//Cache the view element offset so we dont have to grab it during the scroll function call
		this.m_viewElementOffsetTop = firstColumnDiv.offset().top;
		//Determine how many components we should attempt to selectively load based on the height of the viewable area
		this.m_componentsToLoad = Math.ceil(firstColumnDiv.height() / this.m_emptyComponentHeightInPixels);
		firstColumnDiv.scroll(function() {
			self.associatedViewScrollHandler();
		});

		//Add the 'Create Note' link along with the association links to the subsection if we have dynamic
		// documentation components available
		this.addCreateNoteLink();

		//Find the index of the first visible component
		var componentIndex = this.getFirstVisibleComponentIndex();
		if(componentIndex > -1) {
			this.attemptPaddingAdjustment();

			//Highlight the first visible component in the navigator
			var components = this.getAssociatedView().getComponents();
			var component = components[ componentIndex ];
			this.highlightNavigator(component);

			//load the first batch of components and fire the page load timer.
			//It blocks subsequent component loading until the first batch is started.
			this.loadSelectiveComponents(0, true, 0, true);
		}
	}
};

/**
 * Loads the necessary page level menu items based on the content of the detailed review subsection
 * @param {string} pageMenuId The id of the page level menu container element where the menu items should be injected.
 * @returns {undefined} This function does not return a value.
 **/
DetailedReviewSubsection.prototype.loadWorkflowPageMenuItems = function(pageMenuId) {
	var menuIndex = 0;

	//Have the view create the component selection menu item
	var menuItem = this.getAssociatedView().loadComponentSelection();

	//Have the view create the touch mode menu item
	var touchItem = MP_Viewpoint.loadTouchMenuItem();

	//Insert the menu item into the appropriate location
	var pageMenu = MP_MenuManager.getMenuObject(pageMenuId);

	if(pageMenu) {
		if(menuItem && !pageMenu.containsMenuItem(menuItem.getId())) {
			//Insert the component selection menu since it doesn't already exist
			pageMenu.insertMenuItem(menuItem, menuIndex);
		}
		if(touchItem && !pageMenu.containsMenuItem(touchItem.getId())) {
			//Insert the touch item to menu
			pageMenu.insertMenuItem(touchItem, menuIndex + 1);
		}
		MP_MenuManager.updateMenuObject(pageMenu);
	}
};

/**
 * Perform the resize logic for the detailed review subsection.  Initially the base functionality is called in order
 * to continue the resize calls down to the associated view.  Once that call returns, a new calculation is made in order
 * determine how many components to selectively load within the associated view.
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.resizeSubsection = function() {
	//Call the base class functionality and let it handle the main logic
	NavigatorSubsection.prototype.resizeSubsection.call(this);

	//Determine the number of components to load based on the column containing the components.
	var componentColumnDiv = $('#' + this.getAssociatedViewElementId()).find('.col1');
	if(componentColumnDiv.length) {
		//Determine how many components we should attempt to selectively load based on the height of the viewable area
		this.m_componentsToLoad = Math.ceil(componentColumnDiv.height() / this.m_emptyComponentHeightInPixels);
		componentColumnDiv.scroll();
	}
};
/*eslint-enable mp-camelcase*/
/*globals DetailedReviewSubsection, CPMNavigatorSubsectionSummaryMPage*/

/**
 * A constructor used to create a new CPMDetailedReviewSubsection object and
 * initialize subsection level variables.
 * @constructor
 */
var CPMDetailedReviewSubsection = function() {
	//Log info for debugger
	logger.logMessage("Creating a CPM Detailed Review Subsection");
	//Set page level information
	this.setName("CPM Detailed Review");
	//Let the architecture know that we want to render a body portion for our subsection element
	this.setHasBodyElement(true);
	//Let the architecture know we have an associated MPageView object that we want to show
	this.setHasAssociatedView(true);
};

// ____________________________________________________________________________

/**
 * Setup the prototype and constructor to inherit from the base DetailedReviewSubsection
 */
CPMDetailedReviewSubsection.prototype = new DetailedReviewSubsection();
CPMDetailedReviewSubsection.prototype.constructor = DetailedReviewSubsection;

/**
 * Creates and initializes the MPagesView object which will be associated with this subsection.
 * @param {object} viewSettings - The response object back from loadViewSettings
 * @return {undefined} This function does not return a value
 */
CPMDetailedReviewSubsection.prototype.createAssociatedMPageView = function(viewSettings) {
	/*
	 * Create and initialize the MPagesView object which will be associated with this subsection. Each
	 * CPMNavigatorSubsection is responsible for extracting the necessary Component settings for use
	 * in the MPagesView object.
	 */
	var newMPage = null;
	var workflowViewId = this.getWorkflowViewId();
	var nodeList = viewSettings.NODE_LIST;
	if(!nodeList.length){
		logger.logJSError("Node List cannot be found. Check the view settings object.", this, "CPMDetailedReviewSubsection", "createAssociatedMPageView");
		return;
	}
	if(!nodeList[0].COMPONENT_LIST){
		logger.logJSError("Component list cannot be found. Check the view settings object.", this, "CPMDetailedReviewSubsection", "createAssociatedMPageView");
		return;
	}
	if(!nodeList[0].COMPONENT_LIST){
		logger.logJSError("Component list cannot be found. Check the view settings object.", this, "CPMDetailedReviewSubsection", "createAssociatedMPageView");
		return;
	}
	// Grab the components list from the response back from the script
	var components = viewSettings.NODE_LIST[0].COMPONENT_LIST;
	// Set the settings object to all of the components since none are filtered out
	this.setSubsectionSettings(components);
	// Create the MPageView instance and prepare it for rendering for the subsection
	newMPage = new CPMNavigatorSubsectionSummaryMPage();
	// Let the page know the identifier of the parent workflow page
	newMPage.setParentWorkflowIdentifier(workflowViewId);
	// Inform the page that the detailed review subsection will let it know which components to load
	newMPage.setSelectiveComponentLoadInd(this.m_selectiveComponentLoadInd);
	newMPage.initializeView(this.getAssociatedViewElementId(), components);
	newMPage.loadViewSettings();
	newMPage.initializeComponents(viewSettings);
	this.setAssociatedView(newMPage);
};/*globals DetailedReviewSubsection, PartogramNavigatorSubsectionSummaryMPage*/

/**
 * A constructor used to create a new PartogramDetailedReviewSubsection object and
 * initialize subsection level variables.
 * @constructor
 */
var PartogramDetailedReviewSubsection = function() {
	//Log info for debugger
	logger.logMessage("Creating a Partogram Detailed Review Subsection");

	//Set page level information
	this.setName("Partogram Detailed Review");

	//Let the architecture know that we want to render a body portion for our subsection element
	this.setHasBodyElement(true);
	//Let the architecture know we have an associated MPageView object that we want to show
	this.setHasAssociatedView(true);

	// Indicates whether a patient is pregnant or not
	this.m_isPatientPregnant = false;
	
	// Indicates whether a patient is in active labor
	this.m_isPatientInActiveLabor = false;

	// Indicates whether a non partogram component is configured to the page
	this.m_anyNonPartogramComponents = false;
};

// ____________________________________________________________________________

/**
 * Setup the prototype and constructor to inherit from the base DetailedReviewSubsection
 */
PartogramDetailedReviewSubsection.prototype = new DetailedReviewSubsection();
PartogramDetailedReviewSubsection.prototype.constructor = DetailedReviewSubsection;

/**
 * Creates and initializes the MPagesView object which will be associated with this subsection.  If Partogram Overview
 * component is configured in bedrock and there is an active pregnancy for a patient with an active labor onset, Add Pregnancy component will
 * be filtered out.
 * @param {object} allComponentSettings An object which contains the settings for all of the Components shown within this workflow.
 * @return {undefined} This function does not return a value
 */
PartogramDetailedReviewSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
	//Get the partogram information from the shared resource object created in the PartogramWorkflowView object
	var partoInfoSR = MP_Resources.getSharedResource("partogramInfo");

	// Object used to get partogram information like Pregnancy Onset, Partogram Onset, Labor Onset, etc,.
	var partoInfoObj = null;

	// Check to see if the partogramInfo object is available to use
	if (partoInfoSR && partoInfoSR.isResourceAvailable()) {
		partoInfoObj = partoInfoSR.getResourceData();
	}
	
	
	if (partoInfoObj) {
	
		if (partoInfoObj.getPregnancyId() > 0) {
			this.m_isPatientPregnant = true;
		
			if (partoInfoObj.getLaborOnsetDate()) {
				this.m_isPatientInActiveLabor = true;
			}
		}
	}

	var partoOverviewComponent = [];
	var requiredComponent = false;
	for (var i = 0; i < allComponentSettings.length; i++) {	
		// Check to see if any non Partogram components have been configured for this page
		if (allComponentSettings[i].R_MN.indexOf("MP_VB_WF_PARTO_") !== 0) {
			this.m_anyNonPartogramComponents = true;
		}
		
		// Validate if Partogram Overview component settings is configured as it is required
		if (allComponentSettings[i].R_MN === "MP_VB_WF_PARTO_OVERVIEW") {
			partoOverviewComponent.push(allComponentSettings[i]);
			requiredComponent = true;
		} 
	}
	
	// If required component (Partogram Overview) is not configured, display no components 
	if (!requiredComponent) {
		allComponentSettings = [];
	} 
	// If a patient does not have an active labor or is not pregnant - Display only "Partogram Overview" component
	else if (!this.m_isPatientInActiveLabor || !this.m_isPatientPregnant) {
		// Replace all component settings with only partogram overview component settings to load/render only
		// "Partogram Overview" component.
		allComponentSettings = partoOverviewComponent;
	} 

	/*
	 * Create and initialize the MPagesView object which will be associated with this subsection. Each
	 * PartogramNavigatorSubsection is responsible for extracting the necessary Component settings for use
	 * in the MPagesView object.
	 */
	var newMPage = null;

	// Set the settings object to all of the components since none are filtered out
	this.setSubsectionSettings(allComponentSettings);

	// Create the MPageView instance and prepare it for rendering for the subsection
	newMPage = new PartogramNavigatorSubsectionSummaryMPage();

	// Set whether any non partogram components have been configured, so properly error message is displayed
	// during the initialize components process
	if (this.m_anyNonPartogramComponents) {
		newMPage.setAnyNonPartogramComponents(this.m_anyNonPartogramComponents);
	}

	// Let the page know the identifier of the parent workflow page
	newMPage.setParentWorkflowIdentifier(this.getWorkflowViewId());
	// Inform the page that the detailed review subsection will let it know which components to load
	newMPage.setSelectiveComponentLoadInd(this.m_selectiveComponentLoadInd);
	newMPage.initializeView(this.getAssociatedViewElementId(), allComponentSettings);
	newMPage.loadViewSettings();
	newMPage.initializeComponents(allComponentSettings);
	this.setAssociatedView(newMPage);
};
/*globals DetailedReviewSubsection, PregnancyNavigatorSubsectionSummaryMPage*/

/**
 * A constructor used to create a new PregnancyDetailedReviewSubsection object and
 * initialize subsection level variables.
 * @constructor
 */
var PregnancyDetailedReviewSubsection = function() {
	//Log info for debugger
	logger.logMessage("Creating a Pregnancy Detailed Review Subsection");

	//Set page level information
	this.setName("Pregnancy Detailed Review");

	//Let the architecture know that we want to render a body portion for our subsection element
	this.setHasBodyElement(true);
	//Let the architecture know we have an associated MPageView object that we want to show
	this.setHasAssociatedView(true);

	// Indicates whether a patient is pregnant or not
	this.m_isPatientPregnant = false;
};

// ____________________________________________________________________________

/**
 * Setup the prototype and constructor to inherit from the base DetailedReviewSubsection
 */
PregnancyDetailedReviewSubsection.prototype = new DetailedReviewSubsection();
PregnancyDetailedReviewSubsection.prototype.constructor = DetailedReviewSubsection;

/**
 * Creates and initializes the MPagesView object which will be associated with this subsection.  If Add Pregnancy
 * component is configured in bedrock and there is an active pregnancy for a patient, Add Pregnancy component will
 * be filtered out.
 * @param {object} allComponentSettings An object which contains the settings for all of the Components shown within this workflow.
 * @return {undefined} This function does not return a value
 */
PregnancyDetailedReviewSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
	//Get the pregnancy information from the shared resource object created in the PregnancyWorkflowView object
	var pregInfoSR = MP_Resources.getSharedResource("pregnancyInfo");

	// Object used to get pregnancy information like Pregnancy Id, EDD, EGA, etc,.
	var pregInfoObj = null;

	// Check to see if the pregnancyInfo object is available to use
	if (pregInfoSR && pregInfoSR.isResourceAvailable()) {
		pregInfoObj = pregInfoSR.getResourceData();
	}

	if (pregInfoObj && pregInfoObj.getPregnancyId() > 0) {
		this.m_isPatientPregnant = true;
	}

	var addPregComponentSettings = null;

	//Filter out the Add Pregnancy component settings if there is an active pregnacy
	for (var i = 0; i < allComponentSettings.length; i++) {
		if (allComponentSettings[i].R_MN === "MP_VB_WF_PREG_ADD_PREGNANCY") {
			addPregComponentSettings = allComponentSettings.splice(i, 1);
			//No need to look through the rest of the array since we've found our component.
			break;
		}
	}

	// If a patient is not pregnant - Display only "Add Pregnancy" component
	if (!this.m_isPatientPregnant) {
		// Replace all component settings with only add pregnancy component settings to load/render only
		// "Add Pregnancy" component.
		allComponentSettings = addPregComponentSettings;
	}

	/*
	 * Create and initialize the MPagesView object which will be associated with this subsection. Each
	 * PregnancyNavigatorSubsection is responsible for extracting the necessary Component settings for use
	 * in the MPagesView object.
	 */
	var newMPage = null;

	// Set the settings object to all of the components since none are filtered out
	this.setSubsectionSettings(allComponentSettings);

	// Create the MPageView instance and prepare it for rendering for the subsection
	newMPage = new PregnancyNavigatorSubsectionSummaryMPage();

	// Set pregnancy lookback value & pregnancy status of a patient so that it will available during
	// initialization of components.
	if (this.m_isPatientPregnant) {
		newMPage.setPregnancyLookBack(pregInfoObj.getLookBack());
		newMPage.setIsPatientPregnant(this.m_isPatientPregnant);
	}

	// Let the page know the identifier of the parent workflow page
	newMPage.setParentWorkflowIdentifier(this.getWorkflowViewId());
	// Inform the page that the detailed review subsection will let it know which components to load
	newMPage.setSelectiveComponentLoadInd(this.m_selectiveComponentLoadInd);
	newMPage.initializeView(this.getAssociatedViewElementId(), allComponentSettings);
	newMPage.loadViewSettings();
	newMPage.initializeComponents(allComponentSettings);
	this.setAssociatedView(newMPage);
};
var CERN_DEMO_BANNER_O1=function(){function initHoversDemoBanner(trg,par){gen=Util.Style.g(trg,par,"SPAN");
for(var i=0,l=gen.length;
i<l;
i++){var m=gen[i];
if(m){var nm=Util.gns(Util.gns(m));
if(nm){if(Util.Style.ccss(nm,"hvr")){hs(m,nm);
}}}}}return{GetPatientDemographics:function(demoBanner,criterion){var sendAr=["^MINE^",criterion.person_id+".0",criterion.encntr_id+".0"];
var request=new MP_Core.ScriptRequest(null,"USR:MPG.DEMO_BANNER.O1 - load component");
request.setProgramName("MP_GET_PATIENT_DEMO");
request.setParameters(sendAr);
MP_Core.XMLCCLRequestCallBack(null,request,function(replyObj){MP_Util.LogScriptCallInfo(null,this,"demobanner.js","GetPatientDemographics");
var recordData=replyObj.getResponse();
if(!recordData){return;
}try{var timer=MP_Util.CreateTimer("ENG:MPG.DEMO_BANNER.O1 - render component");
var age="";
var birthDate="";
var birthDtTm=new Date();
var codeArray=null;
var deceasedDate="";
var deceasedDtTm=new Date();
var enCodeArray=[];
var finNbr="";
var i=0;
var isolation="";
var j=0;
var jsHTML=[];
var localBirthDtTm=new Date();
var localDeceasedDtTm=new Date();
var mrnNbr="";
var nameFull="";
var patInfo=null;
var ptCodeArray=[];
var sexDisp="";
var sexObj=null;
var visitReason="";
codeArray=MP_Util.LoadCodeListJSON(recordData.CODES);
patInfo=recordData.DEMOGRAPHICS.PATIENT_INFO;
nameFull=patInfo.PATIENT_NAME.NAME_FULL;
if(patInfo.ABS_BIRTH_DT_TM!==""){var regexp="([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
var d=patInfo.ABS_BIRTH_DT_TM.match(new RegExp(regexp));
birthDtTm=new Date(d[1],d[3]-1,d[5],d[7],d[8],d[10]);
birthDate=birthDtTm.format("shortDate2");
}else{if(patInfo.BIRTH_DT_TM!==""){birthDtTm.setISO8601(patInfo.BIRTH_DT_TM);
birthDate=birthDtTm.format("shortDate2");
}}if(patInfo.DECEASED_DT_TM!==""){deceasedDtTm.setISO8601(patInfo.DECEASED_DT_TM);
deceasedDate=deceasedDtTm.format("shortDate2");
}if(patInfo.LOCAL_DECEASED_DT_TM&&patInfo.LOCAL_BIRTH_DT_TM){localBirthDtTm.setISO8601(patInfo.LOCAL_BIRTH_DT_TM);
localDeceasedDtTm.setISO8601(patInfo.LOCAL_DECEASED_DT_TM);
age=MP_Util.CalcAge(localBirthDtTm,localDeceasedDtTm);
}else{if(patInfo.LOCAL_BIRTH_DT_TM){localBirthDtTm.setISO8601(patInfo.LOCAL_BIRTH_DT_TM);
age=MP_Util.CalcAge(localBirthDtTm);
}}var encntrInfo=recordData.DEMOGRAPHICS.ENCOUNTER_INFO;
for(j=0,e=encntrInfo.length;
j<e;
j++){visitReason=encntrInfo[j].REASON_VISIT;
for(i=0,l=encntrInfo[j].ALIAS.length;
i<l;
i++){enCodeArray[i]=MP_Util.GetValueFromArray(encntrInfo[j].ALIAS[i].ALIAS_TYPE_CD,codeArray);
if(enCodeArray[i].meaning=="FIN NBR"){finNbr=encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
}if(enCodeArray[i].meaning=="MRN"){mrnNbr=encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
}}if(encntrInfo[j].ISOLATION_CD>0){var isoObj=MP_Util.GetValueFromArray(encntrInfo[j].ISOLATION_CD,codeArray);
isolation=isoObj.display;
}}aliasArry=recordData.DEMOGRAPHICS.PATIENT_INFO.ALIAS;
if(mrnNbr===""){for(i=0,l=aliasArry.length;
i<l;
i++){ptCodeArray[i]=MP_Util.GetValueFromArray(aliasArry[i].ALIAS_TYPE_CD,codeArray);
if(ptCodeArray[i].meaning=="MRN"){mrnNbr=aliasArry[i].FORMATTED_ALIAS;
}}}sexObj=MP_Util.GetValueFromArray(patInfo.SEX_CD,codeArray);
sexDisp=(sexObj)?sexObj.display:i18n.UNKNOWN;
jsHTML.push("<div id='demobanner'",criterion.category_mean,"><dl class='dmg-info'><dt class='dmg-pt-name-lbl'><span>",i18n.NAME,"</span></dt><dd class='dmg-pt-name'><span>",nameFull,"</span></dd><dt class='dmg-sex-lbl'><span>",i18n.SEX," ","</span></dt><dd class='dmg-sex'><span>",sexDisp," ","</span></dd><dt class='dmg-age-lbl'><span>",i18n.AGE,"</span></dt>");
if(deceasedDate!==""){jsHTML.push("<span class='dmg-deceased'>",age,"</span><h4 class='det-hd'><span class='dmg-info'>",i18n.AGE,"</span></h4><div class='hvr'><dl class='dmg-info'><dt class='dmg-info'><span >",i18n.DECEASED,":</span></dt><dd class='dmg-info'><span>",deceasedDate,"</span></dd></dl></div>");
}else{jsHTML.push("<dd class='dmg-age'><span>",age,"</span></dd>");
}jsHTML.push("<dt><span>",i18n.DOB,":</span></dt><dd class='dmg-dob'><span>",birthDate,"</span></dd><dt><span>",i18n.MRN,":</span></dt><dd class='dmg-mrn'><span>",mrnNbr,"</span></dd><dt><span>",i18n.FIN,":</span></dt><dd class='dmg-fin'><span>",finNbr,"</span></dd><dt><span>",i18n.ISOLATION,":</span></dt><dd class='dmg-isolation'><span>",isolation,"</span></dd><dt><span>",i18n.VISIT_REASON,":</span></dt><dd class='dmg-rfv'><span>",visitReason,"</span></dd></dl></div>");
demoBanner.innerHTML=jsHTML.join("");
initHoversDemoBanner("dmg-deceased",_g("demobanner"+criterion.category_mean));
}catch(err){MP_Util.LogJSError(err,null,"demobanner.js","GetPatientDemographics");
if(timer){timer.Abort();
timer=null;
}}finally{if(timer){timer.Stop();
}}});
}};
}();
/**
 * The pregnancyInfo object is used to store information about a specific
 * pregnancy.
 */
function PregnancyInfo() {
	/** @private */
	var m_criterion = null;
	//had to make this a global so that the inline function, addOrReopenPregnancy could consume it
	/** @private */
	var m_delGesAge = 0;
	/** @private */
	var m_deliveryDt = 0;
	/** @private */
	var m_eddDt = 0;
	/** @private */
	var m_eddId = 0.0;
	/** @private */
	var m_gesAge = 0;
	/** @private */
	var m_label = "";
	/** @private */
	var m_lookBack = 0;
	//based on today minus onset date
	/** @private */
	var m_onsetDate = null;
	/** @private */
	var m_pregId = 0.0;
	/** @private */
	var m_reopenPregInd = 0;
	/** @private */
	var m_rtLookBack = 0;
	/** @private */
	var m_patientDelivered = 0;
	/** @private */
	var m_calculatedEga = 0;
	//based on gestational age at delivery plus (today minus delivery date)

	/** Getters **/
	this.getDelGesAge = function() {
		return m_delGesAge;
	};
	this.getDeliveryDate = function() {
		return m_deliveryDt;
	};
	this.getEddId = function() {
		return m_eddId;
	};
	this.getEstDeliveryDate = function() {
		return m_eddDt;
	};
	this.getGesAge = function() {
		return m_gesAge;
	};
	this.getLookBack = function() {
		return m_lookBack;
	};
	this.getOnsetDate = function() {
		return m_onsetDate;
	};
	this.getPregnancyId = function() {
		return m_pregId;
	};
	this.getReopenPregInd = function() {
		return m_reopenPregInd;
	};
	this.getRtLookBack = function() {
		return m_rtLookBack;
	};
	/**
	 * This function indicates whether patient has delivered
	 * all the babies.
	 * 
	 * @returns m_patientDelivered {boolean} -  Returns true if
	 * the patient has delivered all the babies.
	 */
	this.isPatientDelivered = function() {
		return m_patientDelivered;
	};
	/**
	 * This functions returns the calculated EGA based on
	 * whether patient is delivered or not.
	 * 
	 * 
	 * @returns m_patientDelivered {int} -  Returns the
	 * EGA for the patient
	 */
	this.getCalculatedEga = function() {
		return m_calculatedEga;
	}; 
	/** Setters **/
	this.setDelGesAge = function(delgesAge) {
		m_delGesAge = delgesAge;
	};
	this.setDeliveryDate = function(deliveryDt) {
		m_deliveryDt = deliveryDt;
	};
	this.setEddId = function(eddId) {
		m_eddId = eddId;
	};
	this.setEstDeliveryDate = function(eddDt) {
		m_eddDt = eddDt;
	};
	this.setGesAge = function(gesAge) {
		m_gesAge = gesAge;
	};
	this.setLookBack = function(lookBack) {
		m_lookBack = lookBack;
	};
	this.setOnsetDate = function(onsetDate) {
		m_onsetDate = onsetDate;
	};
	this.setPregnancyId = function(pregId) {
		m_pregId = pregId;
	};
	this.setReopenPregInd = function(reopenInd) {
		m_reopenPregInd = reopenInd;
	};
	this.setRtLookBack = function(rtLookBack) {
		m_rtLookBack = rtLookBack;
	};
	/* This function sets patient delivery indicator.
	 * 
	 * @param patientDeliveredInd {int} - indicates whether
	 * all babies are delivered
	 */
	this.setIsPatientDelivered = function(patientDelivered) {
		m_patientDelivered = patientDelivered > 0 ? true : false;
	};
	/* This function calculates the current EGA for the patient 
	 * based on whether patient has single baby or multiple babies.
	 * 
	 * Mutiple Babies:
	 * The CURRENT_GEST_AGE continues to calculate until all the babies
	 * are delivered. Once all the babies are delivered, the CURRENT_GEST_AGE
	 * is set to the latest GEST_AGE_AT_DELIVERY.
	 * 
	 * Single Baby:
	 * CURRENT_GEST_AGE will be zero and GEST_AGE_AT_DELIVERY will be having
	 * delivery gestational age in days.
	 * 
	 */
	this.setCalculatedEga = function() {
		m_calculatedEga = (this.getGesAge() === 0) ? this.getDelGesAge() : this.getGesAge();
	}; 
}

/* The Pregnancy Base Component is to allow for other 'pregnancy' based
 * components to share the same data. */
function PregnancyBaseUtilComponentStyle() {
	this.initByNamespace("pregbase");
}

PregnancyBaseUtilComponentStyle.inherits(ComponentStyle);
var PREGNANCY_BASE_UTIL_O1 = function() {
	this.m_retrievingData = false;
	this.m_label = "PregnancyBaseUtil";
	this.m_componentId = 0.0;
	this.m_criterion = null;
	this.m_deliveryData = null;

	function GetDeliveryData(reply) {
		var replyError = reply.getError();
		if(replyError === "" && replyError.length === 0) {
			var recordData = reply.getResponse();
			var replyStatus = recordData.STATUS_DATA.STATUS;
			if(replyStatus !== "F") {//success
				this.m_deliveryData = recordData;
				return this.m_deliveryData;
			}
		}
		return null;
	}
	function fmtDt(dt, mask) {
		if (dt) {
			var dateTime = new Date();
			dateTime.setISO8601(dt);	
			if (mask) {
				return dateTime.format(mask);
			}
			else {
				return dateTime.format("longDateTime3");
			}
		}
		else {
			return "^^";
		}
	}
	return {
		/**
		 * loads the pregnancy data into a shared resource
		 * @param {Object} criterion - the criterion JSON data
		 * @param {Boolean} asynch - whether the data should be accessed via asynchronous call
		 */
		LoadPregnancyData : function(criterion, asynch) {
			var request = null;
			var sendArr = [];
			var callbackFunc = null;
			//set default value of asynch parameter
			asynch = typeof asynch !== 'undefined' ? asynch : true;

			//Store the criterion object for later use
			this.m_criterion = criterion;

			//Check to see if the data is currently being retrieved
			if(this.m_retrievingData) {
				//Data already being retrieved
				return;
			}

			//Indicate that data is being retrieved
			this.m_retrievingData = true;
			sendArr.push("^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0", criterion.provider_id + ".0", criterion.ppr_cd + ".0", criterion.position_cd + ".0" );
			request = new MP_Core.ScriptRequest(PREGNANCY_BASE_UTIL_O1, "ENG:MPG.PregnancyBaseUtil.O1 - LoadPregnancyData");
			request.setProgramName("MP_GET_EGA_DATA");
			request.setParameters(sendArr);
			request.setAsync(asynch);
			callbackFunc = function(recordData) {
				PREGNANCY_BASE_UTIL_O1.GetPregnancyData(recordData, true);
			};
			MP_Core.XMLCCLRequestCallBack(PREGNANCY_BASE_UTIL_O1, request, callbackFunc);
		},
		LoadDeliveryData : function(sendVal, callback) {
			var request = new MP_Core.ScriptRequest(PREGNANCY_BASE_UTIL_O1, "ENG:MPG.PregnancyBaseUtil.O1 - LoadDeliveryData");
			request.setProgramName("MP_GET_DELIVERY_SUMMARY");
			request.setParameters(sendVal);
			request.setAsync(true);
			MP_Core.XMLCCLRequestCallBack(PREGNANCY_BASE_UTIL_O1, request, function(reply) {
				//The GetDeliveryData function returns the deliveryData information needed
				callback(GetDeliveryData(reply));
			});
		},
		CheckPregnancySummaryLoadRequirement : function(viewPointInd) {
			var patInfo = this.m_criterion.getPatientInfo();
			var errorString = "";
			var addButtonHTML = "";
			var reopenButtonHTML = "";
			var errorOccured = false;
			var helpFile, helpURL;
			var bodyHTML = "";

			//if female
			if(patInfo.getSex().meaning === "FEMALE") {
				//check if the patient is pregnant -- pregnancy id -- if pregnancy id  < 0, show
				// error -- something went wrong
				if(m_pregId < 0) {
					errorString = pregnancyBaseUtili18n.RETREIVING_PREG_ERROR;
					errorOccured = true;
				}
				// pregnancy id -- if pregnancy id  == 0, show error need active preg
				else if(m_pregId === 0) {
					errorString = pregnancyBaseUtili18n.NOACTIVE_PREG_ERROR;
					addButtonHTML = '<input type="button" OnClick="PREGNANCY_BASE_UTIL_O1.addOrReopenPregnancy(0);" value="' + pregnancyBaseUtili18n.ADD_PREGNANCY + '">';
					errorOccured = true;
					if(m_reopenPregInd == 1) {
						reopenButtonHTML = '<input type="button" OnClick="PREGNANCY_BASE_UTIL_O1.addOrReopenPregnancy(1);" value="' + pregnancyBaseUtili18n.REOPEN_PREGNANCY + '">';
					}
				}
			}
			else {//else show not female error
				errorString = pregnancyBaseUtili18n.NOTFEMALE_ERROR;
				errorOccured = true;
			}
			if(errorOccured) {
				//add the help link
				if(this.m_criterion.help_file_local_ind == 1) {
					helpFile = this.m_criterion.static_content + "pregnancysummary/index.html";
				}
				else {
					helpURL = "https://wiki.ucern.com/display/r1mpagesHP/Pregnancy+Summary+Help";
				}

				//add the title
				if(viewPointInd) {
					MP_Util.Doc.AddPageTitle(pregnancyBaseUtili18n.PREGNANCY_SUMMARY, document.body, this.m_criterion.debug_ind, true, null, helpFile, helpURL, this.m_criterion, this.m_criterion.category_mean);
				}
				else {
					MP_Util.Doc.AddPageTitle(pregnancyBaseUtili18n.PREGNANCY_SUMMARY, document.body, this.m_criterion.debug_ind, true, null, helpFile, helpURL, this.m_criterion);
				}
				MP_Util.Doc.AddCustomizeLink(this.m_criterion);

				//store the current document body
				var demoHTML = ["<div class='pregbase-error-content'><span class=pregbase-alert-icon title=", pregnancyBaseUtili18n.ALERT, ":></span><span class=pregbase-error-text>", errorString, "</span><span class=pregbase-addpreg-button>", addButtonHTML, "</span><span class=pregbase-reopenpreg-button>", reopenButtonHTML, "</span></div>"];
				var demoarray = demoHTML.join('');

				if(viewPointInd) {
					bodyHTML = _g(this.m_criterion.category_mean);
					bodyHTML.innerHTML = bodyHTML.innerHTML + demoarray;
				}
				else {
					bodyHTML = document.body.innerHTML;
					document.body.innerHTML = bodyHTML + demoarray;
				}
			}

			return errorOccured;
		},
		addOrReopenPregnancy : function(addOrReOpenFlag) {
			var addOrOpenPregFormObject = null;
			try {
				addOrOpenPregFormObject = window.external.DiscernObjectFactory('PREGNANCY');
				MP_Util.LogDiscernInfo(null, "PREGNANCY", "pregnancybaseutil.js", "addOrOpenPregnancy");
			}
			catch(err) {
				MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.DISCERN_OBJ_FACTORY_FAILURE + ': ' + err.name + ' ' + err.message);
				return;
			}
			if(!addOrOpenPregFormObject && addOrOpenPregFormObject === null) {
				MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.PREG_FORM_OBJ_FAILURE);
				return false;
			}

			var success = false;
			try {
				if(addOrReOpenFlag === 0) {
					success = addOrOpenPregFormObject.AddPregnancy(window, this.m_criterion.person_id, this.m_criterion.encntr_id);
				}
				else if(addOrReOpenFlag === 1) {
					success = addOrOpenPregFormObject.ReopenPregnancy(window, this.m_criterion.person_id, this.m_criterion.encntr_id);
				}
				if(success) {
					PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(this.m_criterion);
				}
				return success;
			}
			catch(error) {
				if(addOrReOpenFlag === 0) {
					MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.ADDPREGNANCY_EXCEPTION);
				}
				else {
					MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.REOPENPREGNANCY_EXCEPTION);
				}
			}
		},
		GetPregnancyData : function(reply, notifyConsumers) {
			var dateDiff = null;
			var daysOfLife = null;
			var deliveryDate = null;
			var pregDeliveredInd = null;
			var pregInfoObj = null;
			var pregResource = null;
			var replyError = null;
			var tempDate = null;
			var todayDate = null;

			//Update the date retrieval flags
			this.m_retrievingData = false;
			replyError = reply.getError();
			if(replyError === "" && replyError.length === 0) {
				var recordData = reply.getResponse();
				var replyStatus = recordData.STATUS_DATA.STATUS;
				if(replyStatus == "S") {//success
					pregInfoObj = new PregnancyInfo();
					pregInfoObj.setPregnancyId(recordData.GESTATION_INFO[0].PREGNANCY_ID);
					pregInfoObj.setLookBack(recordData.LOOKBACK_DAYS);
					pregInfoObj.setReopenPregInd(recordData.REOPEN_PREG_IND);
					pregInfoObj.setGesAge(recordData.GESTATION_INFO[0].CURRENT_GEST_AGE);
					pregInfoObj.setDelGesAge(recordData.GESTATION_INFO[0].GEST_AGE_AT_DELIVERY);
					pregInfoObj.setCalculatedEga();
					pregInfoObj.setEstDeliveryDate(recordData.GESTATION_INFO[0].EST_DELIVERY_DATE_FORMATTED);
					pregInfoObj.setEddId(recordData.GESTATION_INFO[0].EDD_ID);
					pregInfoObj.setIsPatientDelivered(recordData.GESTATION_INFO[0].PATIENT_DELIVERED_IND);
					
					//Set the onset date information
					if(recordData.ONSET_DATE) {
						tempDate = new Date();
						tempDate.setISO8601(recordData.ONSET_DATE);
						pregInfoObj.setOnsetDate(tempDate);
					}

					//timeline lookback = gestational age if not delivered
					pregDeliveredInd = recordData.GESTATION_INFO[0].DELIVERED_IND;
					pregInfoObj.setRtLookBack(pregInfoObj.getCalculatedEga());
					// Check whether patient is delivered
					if(pregInfoObj.isPatientDelivered()) {
						todayDate = new Date();
						var deliveryDateFormatted = recordData.GESTATION_INFO[0].DELIVERY_DATE_FORMATTED;
						pregInfoObj.setDeliveryDate(deliveryDateFormatted);
						pregInfoObj.setRtLookBack(pregInfoObj.getDelGesAge());
						deliveryDate=new Date();
						deliveryDate.setISO8601(deliveryDateFormatted);
						dateDiff = todayDate - deliveryDate;
						daysOfLife = Math.round(dateDiff / (1000 * 60 * 60 * 24));
						pregInfoObj.setRtLookBack(pregInfoObj.getRtLookBack() + daysOfLife);
					}
				}
				else if(recordData.STATUS_DATA.STATUS == "Z") {//no pregnancy
					pregInfoObj = new PregnancyInfo();
					pregInfoObj.setPregnancyId(0);
					pregInfoObj.setReopenPregInd(recordData.REOPEN_PREG_IND);
					var mPageTimer = MP_Util.CreateTimer("CAP:MPG.Pregnancy Data Retrieval");
					if(mPageTimer) {
						mPageTimer.SubTimerName = "Patient Not Pregnant";
						mPageTimer.Stop();
					}
				}
			}
			else {
				pregInfoObj = new PregnancyInfo();
				pregInfoObj.setPregnancyId(-1);
			}

			//Create or update the Shared Resource for all pregnancy components to use.
			pregResource = MP_Resources.getSharedResource("pregnancyInfo");
			if(pregResource) {
				//Update the shared resource and notify consumers
				MP_Resources.setSharedResourceData("pregnancyInfo", pregInfoObj);
			}
			else {
				pregResource = new SharedResource("pregnancyInfo");
				pregResource.setResourceData(pregInfoObj);
				pregResource.setIsAvailable(true);
				pregResource.setIsBeingRetrieved(false);
				pregResource.setEventListenerFlag("pregnancyInfoAvailable");
				//Set to null so all MPages and Components receive the event
				pregResource.setEventListenerObject(new MPageComponent());
				MP_Resources.addSharedResource("pregnancyInfo", pregResource);
			}

			//Need to check this flag because this resource may be retrieved prior to
			// rendering the MPage and
			//notifying the consumers causes them to render.
			if(notifyConsumers) {
				pregResource.notifyResourceConsumers();
			}
		},
		getLabel : function() {
			return this.m_label;
		},
		getComponentId : function() {
			return this.m_componentId;
		},
		getDeliveryData : function(sendAr, callbackFunc) {
			if(!this.m_deliveryData) {
				PREGNANCY_BASE_UTIL_O1.LoadDeliveryData(sendAr, callbackFunc);
			}
			return this.m_deliveryData;
		},
		setCriterion : function(criterion) {
			this.m_criterion = criterion;
		}
	};
}();
/**
 * The partogramInfo object is used to store information about a specific
 * partogram
 */
function PartogramInfo() {
	/* Private members */
	var criterion = null;
	var pregnancyId = 0.0;
	var pregnancyOnsetDate = null;
	var laborOnsetDate = null;
	var partogramStartDate = null;
	var pregnancyDescriptor = null;
	var multipRateInd = 0;
	var gravida = 0;
	var para = 0;
	var paraTerm = 0;
	var paraPremature = 0;
	var paraAbortions = 0;
	var paraLiving = 0;
	var ectopic = 0;
	var spontaneousAbortion = 0;
	var inducedAbortion = 0;
	var multipleBirths = 0;
	
	var epidural = [];

	/**
	 * Sets the pregnancy id.
	 */
	this.setPregnancyId = function (val) {
			pregnancyId = val;
	};
		
	/**
	 * Returns the pregnancy id.
	 */
	this.getPregnancyId = function() {
		return pregnancyId;
	};
	
	/**
	 * Sets the pregnancy onset date.
	 */
	this.setPregnancyOnsetDate = function (val) {
			pregnancyOnsetDate = val;
	};
		
	/**
	 * Returns the pregnancy onset date.
	 */
	this.getPregnancyOnsetDate = function() {
		return pregnancyOnsetDate;
	};

	/**
	 * Sets the labor onset date.
	 */
	this.setLaborOnsetDate = function (val) {
			laborOnsetDate = val;
	};
		
	/**
	 * Returns the labor onset date.
	 */
	this.getLaborOnsetDate = function() {
		return laborOnsetDate;
	};
	
	/**
	 * Sets the partogram start date.
	 */
	this.setPartogramStartDate = function (val) {
			partogramStartDate = val;
	};
		
	/**
	 * Returns the partogram start date.
	 */
	this.getPartogramStartDate = function() {
		return partogramStartDate;
	};
	
	/**
	 * Sets the pregnancy descriptor.
	 */
	this.setPregnancyDescriptor = function (val) {
			pregnancyDescriptor = val;
	};
		
	/**
	 * Returns the pregnancy descriptor.
	 */
	this.getPregnancyDescriptor = function() {
		return pregnancyDescriptor;
	};
	
	/**
	 * Sets the multip rate for labor curve indicator.
	 */
	this.setMultipRateInd = function (val) {
			multipRateInd = val;
	};
		
	/**
	 * Returns whether the patient should use the multip rate for labor curve.
	 */
	this.useMultipRate = function() {
		return (multipRateInd === 1 ? true : false);
	};
	
	/**
	 * Sets the gravida count.
	 */
	this.setGravida = function (val) {
			gravida = val;
	};
		
	/**
	 * Returns the gravida count.
	 */
	this.getGravida = function() {
		return gravida;
	};
	
	/**
	 * Sets the para count.
	 */
	this.setPara = function (val) {
			para = val;
	};
		
	/**
	 * Returns the para count.
	 */
	this.getPara = function() {
		return para;
	};
	
	/**
	 * Sets the para full term count.
	 */
	this.setParaTerm = function (val) {
			paraTerm = val;
	};
		
	/**
	 * Returns the para full term count.
	 */
	this.getParaTerm = function() {
		return paraTerm;
	};
	
	/**
	 * Sets the para premature count.
	 */
	this.setParaPremature = function (val) {
			paraPremature = val;
	};
		
	/**
	 * Returns the para premature count.
	 */
	this.getParaPremature = function() {
		return paraPremature;
	};
	
	/**
	 * Sets the para abortion count.
	 */
	this.setParaAbortions = function (val) {
			paraAbortions = val;
	};
		
	/**
	 * Returns the para abortion count.
	 */
	this.getParaAbortions = function() {
		return paraAbortions;
	};
	
	/**
	 * Sets the para living count.
	 */
	this.setParaLiving = function (val) {
			paraLiving = val;
	};
		
	/**
	 * Returns the para living count.
	 */
	this.getParaLiving = function() {
		return paraLiving;
	};
	
	/**
	 * Sets the ectopic count.
	 */
	this.setEctopic = function (val) {
			ectopic = val;
	};	
	
	/**
	 * Returns the ectopic count.
	 */
	this.getEctopic = function() {
		return ectopic;
	};
	
	/**
	 * Sets the spontaneous abortion count.
	 */
	this.setSpontaneousAbortion = function (val) {
			spontaneousAbortion = val;
	};
		
	/**
	 * Returns the spontaneous abortion count.
	 */
	this.getSpontaneousAbortion = function() {
		return spontaneousAbortion;
	};
	
	/**
	 * Sets the induced abortion count.
	 */
	this.setInducedAbortion = function (val) {
			inducedAbortion = val;
	};
		
	/**
	 * Returns the induced abortion count.
	 */
	this.getInducedAbortion = function() {
		return inducedAbortion;
	};
	
	/**
	 * Sets the multiple births count.
	 */
	this.setMultipleBirths = function (val) {
			multipleBirths = val;
	};
		
	/**
	 * Returns the multiple births count.
	 */
	this.getMultipleBirths = function() {
		return multipleBirths;
	};
	
	/**
	 * Sets the epidural results.
	 */
	this.setEpiduralResults = function (val) {
			epidural = val;
	};
		
	/**
	 * Returns the epidural.
	 */
	this.getEpiduralResults = function() {
		return epidural;
	};
}

/** 
 * The Partogram Base Component is to allow for other 'partogram' based
 * components to share the same data. 
 */
function PartogramBaseComponentStyle() {
	this.initByNamespace("parto-base-wf");
}
PartogramBaseComponentStyle.prototype = new ComponentStyle();
PartogramBaseComponentStyle.prototype.constructor = ComponentStyle;

function PartogramBaseComponent (criterion) {
	this.setCriterion(criterion);
	this.setStyles(new PartogramBaseComponentStyle());
	this.setRefreshEnabled(false);
	 
	this.m_retrievingData = false;
	this.m_partogramViewID = "";
}

PartogramBaseComponent.prototype = new MPageComponent();
PartogramBaseComponent.prototype.constructor = MPageComponent;

/**
 * loads the partogram data into a shared resource
 * @param {Object} criterion - the criterion JSON data
 * @param {Boolean} asynch - whether the data should be accessed via asynchronous call
 */
PartogramBaseComponent.prototype.loadPartogramData = function(criterion, asynch) {
	var callbackFunc = null;
			
	//set default value of asynch parameter
	asynch = typeof asynch !== 'undefined' ? asynch : true;
	        
	//Check to see if the data is currently being retrieved
	if(this.m_retrievingData) {
		//Data already being retrieved
		return;
	}

	//Indicate that data is being retrieved
	this.m_retrievingData = true;
						
	var scriptRequest = new ScriptRequest();
	scriptRequest.setName("Partogram Info Retrieval");
    scriptRequest.setProgramName("MP_GET_PARTOGRAM_INFO");
    scriptRequest.setParameterArray(["^MINE^", criterion.person_id + ".0", criterion.provider_id + ".0", criterion.ppr_cd + ".0", criterion.encntr_id +".0"]);
    scriptRequest.setAsyncIndicator(asynch);
    callbackFunc = function(recordData) {
		PartogramBaseComponent.prototype.getPartogramData(recordData, true);
	};
	scriptRequest.setResponseHandler(callbackFunc);
	scriptRequest.performRequest();
};

/**
 * Retrieves the partogram data and places into a shared resource
 * @param {Object} reply - the JSON script reply
 * @param {Boolean} notifyConsumers - whether the shared resource consumers should be notified
 */
PartogramBaseComponent.prototype.getPartogramData = function(reply, notifyConsumers) {
	var partogramInfoObj = null;
	var partogramResource = null;
	var replyError = null;
	var tempDate = null;

	// Update the date retrieval flags
	this.m_retrievingData = false;
	replyError = reply.getError();
	if(replyError === "" && replyError.length === 0) {
		var recordData = reply.getResponse();
		var replyStatus = recordData.STATUS_DATA.STATUS;
		if(replyStatus == "S") { //success
			partogramInfoObj = new PartogramInfo();
			partogramInfoObj.setPregnancyId(recordData.PREGNANCY_ID);
			partogramInfoObj.setPregnancyDescriptor(recordData.PREG_DESCRIPTOR);
			partogramInfoObj.setGravida(recordData.GRAVIDA);
			partogramInfoObj.setPara(recordData.PARA);
			partogramInfoObj.setParaTerm(recordData.PARA_TERM);
			partogramInfoObj.setParaPremature(recordData.PARA_PREMATURE);
			partogramInfoObj.setParaAbortions(recordData.PARA_ABORTIONS);
			partogramInfoObj.setParaLiving(recordData.PARA_LIVING);
			partogramInfoObj.setEctopic(recordData.ECTOPIC);
			partogramInfoObj.setSpontaneousAbortion(recordData.SPONTANEOUS_ABORT);
			partogramInfoObj.setInducedAbortion(recordData.INDUCED_ABORT);
			partogramInfoObj.setMultipleBirths(recordData.MULTI_BIRTH);
			partogramInfoObj.setMultipRateInd(recordData.MULTIP_RATE_IND);

			// Set the pregnancy onset date information
			if(recordData.PREG_ONSET_DATE) {
				tempDate = new Date();
				tempDate.setISO8601(recordData.PREG_ONSET_DATE);
				partogramInfoObj.setPregnancyOnsetDate(tempDate);
			}
					
			// Set the labor onset date information
			if(recordData.LABOR_ONSET_DATE) {
				tempDate = new Date();
				tempDate.setISO8601(recordData.LABOR_ONSET_DATE);
				partogramInfoObj.setLaborOnsetDate(tempDate);
			}
					
			// Set the partogram start date information
			if(recordData.PARTOGRAM_START_DATE) {
				tempDate = new Date();
				tempDate.setISO8601(recordData.PARTOGRAM_START_DATE);
				partogramInfoObj.setPartogramStartDate(tempDate);
			}
							   
			var epiduralResults = [];
			var epiduralInfo = [];
			var e = 0;
			// Set the epidural information
			if (recordData.EPIDURAL_CNT > 0) {
				for(e = 0; e < recordData.EPIDURAL_CNT; e++) {
					epiduralInfo.push({
						EVENT_NAME : recordData.EPIDURAL[e].EVENT_NAME,
						EVENT_DATE : recordData.EPIDURAL[e].EVENT_DATE,
						EPIDURAL_TYPE : recordData.EPIDURAL[e].EPIDURAL_TYPE,
						EPIDURAL_VALUE : recordData.EPIDURAL[e].EPIDURAL_VALUE
					});
				}
			}
			epiduralResults.push({
				CNT : recordData.EPIDURAL_CNT,
				EPIDURAL_START_NAME : recordData.EPIDURAL_START_NAME,
				EPIDURAL_BOL_ANES_NAME : recordData.EPIDURAL_BOL_ANES_NAME,
				EPIDURAL_BOL_PAT_NAME : recordData.EPIDURAL_BOL_PAT_NAME,
				EPIDURAL_DISCONT_NAME : recordData.EPIDURAL_DISCONT_NAME,
				EPIDURAL_DATA : epiduralInfo
			});
			partogramInfoObj.setEpiduralResults(epiduralResults);
		}
		else if(recordData.STATUS_DATA.STATUS == "Z") { 
			// no partogram data / no active pregnancy
			partogramInfoObj = new PartogramInfo();
			partogramInfoObj.setPregnancyId(0);
		}
	}
	else { // Script error status = F
		partogramInfoObj = new PartogramInfo();
		pregInfoObj.setPregnancyId(-1);
	}

	// Create or update the Shared Resource for all partogram components to use.
	partogramResource = MP_Resources.getSharedResource("partogramInfo");
	if (partogramResource) {
		// Update the shared resource and notify consumers
		MP_Resources.setSharedResourceData("partogramInfo", partogramInfoObj);
	}
	else {
		partogramResource = new SharedResource("partogramInfo");
		partogramResource.setResourceData(partogramInfoObj);
		partogramResource.setIsAvailable(true);
		partogramResource.setIsBeingRetrieved(false);
		partogramResource.setEventListenerFlag("partogramInfoAvailable");
		// Set to null so all MPages and Components receive the event
		partogramResource.setEventListenerObject(new MPageComponent());
		MP_Resources.addSharedResource("partogramInfo", partogramResource);
	}

	// Need to check this flag because this resource may be retrieved prior to
	// rendering the MPage and notifying the consumers causes them to render.
	if (notifyConsumers) {
		partogramResource.notifyResourceConsumers();
	}
};

/**
 * Returns the partogram view id (i.e. category mean)
 */     	
PartogramBaseComponent.prototype.getPartogramViewID = function() {
	return this.m_partogramViewID;
};

/**
 * Sets the partogram view id to the category mean of the view
 * @param {String} partogramViewId - category mean
 */
PartogramBaseComponent.prototype.setPartogramViewID = function(partogramViewId) {
	this.m_partogramViewID = partogramViewId;
};
