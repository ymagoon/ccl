"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultArgs = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _seleniumWebdriver = require("selenium-webdriver");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
   This can be removed once this fix has been released in
   selenium: https://github.com/SeleniumHQ/selenium/pull/5968
 */
if (!Object.getOwnPropertySymbols(_seleniumWebdriver.Condition).some(function (symbol) {
    return symbol === Symbol.hasInstance;
})) {
    Object.defineProperty(_seleniumWebdriver.Condition, Symbol.hasInstance, {
        value: function value(condition) {
            return !!condition && (typeof condition === "undefined" ? "undefined" : _typeof(condition)) === "object" && typeof condition.description === "function" && typeof condition.fn === "function";
        },

        configurable: true
    });
}

/**
 * builds the root css selector
 *
 * when `table.row(3).cell(2)` is accessed,
 * `selectorList` might internally look like this:
 * [
 *     ".mpageui-Table",
 *     ".mpageui-Table-row:nth-child(3)",
 *     ".mpageui-Table-row-cell:nth-child(2)"
 * ]
 *
 * This function simply concatenates these into one selector.
 *
 * It returns a promise in order to handle the edge case in
 * which an element's root selector is a function. In this
 * scenario the element selector is not known until runtime,
 * so its `elementSelector` member returns a function which
 * returns a promise that resolves with the root selector.
 *
 * @param {Array} selectorList - array of element selectors
 * @returns {Promise<String>} selector
 * @private
 */
var buildRootSelector = function buildRootSelector(selectorList) {
    return selectorList.reduce(function (buildPrefix, selector) {
        return buildPrefix.then(function (prefix) {
            return typeof selector === "string" ? Promise.resolve(prefix + " " + selector) : selector(prefix);
        });
    }, Promise.resolve(""));
};

var defaultArgs = exports.defaultArgs = {
    selectorList: [],
    index: 0,
    useExactSelector: false
};

/**
 * The UIComponentPage class
 * @memberOf module:MPageFusion/testing
 * @class module:MPageFusion/testing.UIComponentPage
 */

var UIComponentPage = function () {
    /**
     * @param {Object} driver - The driver which runs the tests in the browser
     * @param {String} selector - a css selector for the root element of the UIComponent
     * @param {Number} index - the index of the item in a list of items
     * @param {Boolean} useExactSelector - this should be set to true when the
     *  root element has already been selected by selectorList (e.g. by a custom css class)
     *  and adding the root element class would cause the selector to become invalid
     * @param {Object} config - Additional configurations for the UIComponent
     */
    function UIComponentPage(driver) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultArgs,
            _ref$selectorList = _ref.selectorList,
            selectorList = _ref$selectorList === undefined ? [] : _ref$selectorList,
            _ref$index = _ref.index,
            index = _ref$index === undefined ? 0 : _ref$index,
            _ref$useExactSelector = _ref.useExactSelector,
            useExactSelector = _ref$useExactSelector === undefined ? false : _ref$useExactSelector,
            _ref$config = _ref.config,
            config = _ref$config === undefined ? {} : _ref$config;

        _classCallCheck(this, UIComponentPage);

        this.driver = driver;
        this.config = config;
        var nthSelector = index ? ":nth-child(" + (index + 1) + ")" : "";
        this.selectorList = useExactSelector ? selectorList : selectorList.concat(typeof this.elementSelector === "function" ? this.elementSelector : "" + this.elementSelector + nthSelector);
    }

    /**
     * returns the css selector (as a string) needed to locate the
     * root element. This property may optionally return a function
     * that -- given a prefix css selector -- returns a promise that
     * resolves with the root css selector. This alternative is
     * available in order to handle the edge case in which an element's
     * selector is not known until runtime or until the element is
     * created. This can be helpful when the construct with which the page
     * object is interacting is composed of nonadjacent DOM elements.
     *
     * @memberOf module:MPageFusion/testing.UIComponentPage
     * @returns {String|Function} selector
     * @abstract
     * @example
     * class TablePage {
     *     // returns the selector needed to locate the table root
     *     get elementSelector() {
     *         return ".mpageui-Table";
     *     }
     *
     *     // ...
     * }
     */


    _createClass(UIComponentPage, [{
        key: "get",


        /**
         * gets a page object attribute
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @param {String} attribute - the page object attribute
         * @returns {Promise} attribute
         */
        value: function get(attribute) {
            return this[attribute];
        }

        /**
         * waits until the root element has been located in the dom
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @returns {WebElementPromise} after root located
         */

    }, {
        key: "waitUntilLocated",
        value: function waitUntilLocated() {
            var _this = this;

            return buildRootSelector(this.selectorList).then(function (rootSelector) {
                return _this.driver.wait(_seleniumWebdriver.until.elementLocated(_seleniumWebdriver.By.css(rootSelector))).then(function () {
                    return rootSelector;
                });
            });
        }

        /**
         * gets the root WebElement
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @returns {WebElementPromise} the root WebElement
         */

    }, {
        key: "getRootElement",
        value: function getRootElement() {
            var _this2 = this;

            return this.waitUntilLocated().then(function (rootSelector) {
                return _this2.driver.findElement(_seleniumWebdriver.By.css(rootSelector));
            });
        }

        /**
         * gets a nested WebElement. returns null if the nested
         * element is not found.
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @param {String} selector - a css selector for the element
         * @returns {WebElementPromise} the WebElement
         */

    }, {
        key: "getNestedElement",
        value: function getNestedElement(selector) {
            return this.getRootElement().then(function (element) {
                return element.findElement(_seleniumWebdriver.By.css(selector))
                /*
                    Only catch nested element. We always
                    want to throw an exception if the root
                    element is not found.
                 */
                .catch(function () {
                    return null;
                });
            });
        }

        /*
         * gets an array of nested WebElements. returns an empty array if the nested
         * elements are not found.
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @param {String} selector - a css selector for the elements
         * @returns {WebElementPromise<Array<WebElement>>} the array of WebElements.
         */

    }, {
        key: "getNestedElements",
        value: function getNestedElements(selector) {
            return this.getRootElement().then(function (element) {
                return element.findElements(_seleniumWebdriver.By.css(selector));
            });
        }

        /**
         * whether or not the element is displayed
         * @memberOf module:MPageFusion/testing.UIComponentPage
         * @returns {Promise<boolean>} whether element is displayed
         */

    }, {
        key: "isDisplayed",
        value: function isDisplayed() {
            var _this3 = this;

            return buildRootSelector(this.selectorList).then(function (rootSelector) {
                return _this3.driver.findElement(_seleniumWebdriver.By.css(rootSelector));
            }).then(function (element) {
                return element.isDisplayed();
            }).catch(function () {
                return false;
            });
        }
    }, {
        key: "elementSelector",
        get: function get() {
            throw new Error("elementSelector not implemented. elementSelector must\n            return a valid css selector identifying the root of the the element\n            OR a function that given a prefix css selector returns a Promise which\n            resolves with a valid css selector identifying the root of the the element.");
        }
    }]);

    return UIComponentPage;
}();

exports.default = UIComponentPage;