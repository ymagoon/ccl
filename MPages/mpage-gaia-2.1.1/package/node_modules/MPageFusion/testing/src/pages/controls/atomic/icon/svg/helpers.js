"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.iconPages = exports.classTypeMap = exports.ICON_TYPES = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _ref;

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _UIComponent = require("../../../../UIComponent.page");

var _UIComponent2 = _interopRequireDefault(_UIComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// converts to MACRO_CASE
var convertToMacroCase = function convertToMacroCase(str) {
    var replacer = function replacer(match, p1, p2) {
        return [p1, p2].join("_");
    };

    return str.replace(new RegExp(/(.)([A-Z][a-z]+)/, "g"), replacer) // handle acronyms
    .replace(new RegExp(/([a-z0-9])([A-Z])/, "g"), replacer).toUpperCase();
};

var iconFolder = _path2.default.join(__dirname, // eslint-disable-line no-undef
"../../../../../../../src/main/js/cerner/mpagedev/mpagefusion/controls/atomic/icon/svg/category");

var iconCategories = _fs2.default.readdirSync(iconFolder).filter(function (fileName) {
    return !fileName.includes(".") || fileName === "helpers";
});

var iconCategoryMap = iconCategories.reduce(function (map, category) {
    map[category] = _fs2.default.readdirSync(iconFolder + "/" + category).map(function (file) {
        return file.split(".js")[0];
    });
    return map;
}, {});

var icons = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.values(iconCategoryMap)));

// dynamically create icon classes
var createIconPageObject = function createIconPageObject(name) {
    var page = function page() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        _UIComponent2.default.call.apply(_UIComponent2.default, [this].concat(args));
    };

    page.prototype = Object.create(_UIComponent2.default.prototype);
    page.prototype.constructor = page;
    Object.defineProperty(page.prototype, "elementSelector", {
        get: function get() {
            return ".mpageui-SvgIcon-" + name;
        }
    });

    return page;
};

/**
 * TYPES
 * @description The set of fusion svg icon types
 * @enum
 * @memberOf module:MPageFusion/testing.atomic.icon.svg.SvgIconPage
 */
var ICON_TYPES = exports.ICON_TYPES = icons.reduce(function (map, icon) {
    map[convertToMacroCase(icon)] = icon;
    return map;
}, {});

/**
 * A mapping of icon css class to icon type
 * @type {Object}
 * @private
 */
var classTypeMap = exports.classTypeMap = icons.reduce(function (map, icon) {
    var className = "mpageui-SvgIcon-" + icon;
    map[className] = ICON_TYPES[convertToMacroCase(icon)];
    return map;
}, {});

/**
 * Page objects for all fusion SvgIcons grouped by category
 * @type {Object}
 * @private
 */
var iconPages = exports.iconPages = Object.entries(iconCategoryMap).reduce(function (map, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        category = _ref3[0],
        iconList = _ref3[1];

    map[category] = iconList.reduce(function (iconMap, iconName) {
        iconMap[iconName + "Page"] = createIconPageObject(iconName);
        return iconMap;
    }, {});
    return map;
}, {});