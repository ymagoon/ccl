/**
 * @fileoverview
 * @author Gyandeep Singh
 */

"use strict";

/**
 * row header size enum
 * @type {{DEFAULT: string, LARGE: string}}
 */
export const ROW_HEADER_SIZE = {
    DEFAULT: "default",
    LARGE: "large"
};

/**
 * Minimum column width
 * @type {int}
 */
export const COLUMN_MIN_WIDTH = 150;
/**
 * Paddles on each side of the table for scrolling
 * @type {{PREVIOUS: string, NEXT: string}}
 */
export const SCROLL_PADDLE_TYPE = {
    PREVIOUS: "prev",
    NEXT: "next"
};
/**
 * Wait time for force horizontal scroll
 * @type {number}
 */
const SCROLL_THROTTLE = 500;
/**
 * Interval time for force horizontal scroll
 * @type {number}
 */
const SCROLL_INTERVAL = 250;

export const eventNames = {
    PRIVATE: {
        ROW_SELECTION_CHANGE: "__Flowsheet::rowSelectionChange__",
        ROW_CELL_SELECTION_CHANGE: "__Flowsheet::rowCellSelectionChange__"
    },
    PUBLIC: {
        ROW_SELECTION_CHANGE: "Flowsheet::rowSelectionChange",
        ROW_CELL_SELECTION_CHANGE: "Flowsheet::rowCellSelectionChange",
        SECTION_HEADER_CLICK: "Flowsheet::sectionHeaderClick"
    }
};

/**
 * Given a row header size this returns
 *  the corresponding css class
 * @param {String} size - the row header size
 * @returns {String} the css class
 */
export const getRowHeaderSizeClass = (size) => {
    switch (size) {
        case ROW_HEADER_SIZE.LARGE:
            return "mpageui-Flowsheet--row-header-large";

        default:
            return "";
    }
};

/**
 * Calculates the minimum width required for flowsheets based on the number of cells in a row
 * @param {Object} cellCnt - Number of cells in a row
 * @param {int} [columnMinWidth=150] - Minimum column width
 * @returns {String} Width in px
 */
export const getFlowsheetMinWidth = (cellCnt, columnMinWidth = COLUMN_MIN_WIDTH) => `${cellCnt * columnMinWidth}px`;

/**
 * Scrolls to next column
 * @param {number} columnMinWidth - Minimum column width
 * @param {{ target: HtmlElement <Object> }} event - click event on scrolling paddle
 * @returns {undefined} returns nothing
 */
const scrollToNextCol = (columnMinWidth, { target }) => {
    target.parentElement.scrollLeft += columnMinWidth;
};

/**
 * Scrolls to previous column
 * @param {number} columnMinWidth - Minimum column width
 * @param {{ target: HtmlElement <Object> }} event - click event on scrolling paddle
 * @returns {undefined} returns nothing
 */
const scrollToPrevCol = (columnMinWidth, { target }) => {
    target.parentElement.scrollLeft -= columnMinWidth;
};

/**
 * Sets the interval for scrolling
 * @param {Function} callbackFn - Shifts columns left or right
 * @param {object} timers - Object containing interval and timeout ids
 * @returns {undefined} returns nothing
 */
const setScrollInterval = (callbackFn, timers) => () => {
    timers.intervalId = setInterval(callbackFn, SCROLL_INTERVAL);
};

/**
 * Sets the timer for waiting before force scrolling
 * @param {Function} callbackFn - Shifts columns left or right
 * @param {object} timers - Object containing interval and timeout ids
 * @returns {undefined} returns nothing
 */
const setScrollTimer = (callbackFn, timers) => {
    timers.timeoutId = setTimeout(setScrollInterval(callbackFn, timers), SCROLL_THROTTLE);
};

/**
 * If the timeout expires then it is treated as "force" scroll and the columns are shifted left
 * or right based on an interval and number of columns, and we scroll one column to indicate progress
 * @param {number} columnMinWidth - Minimum column width
 * @param {object} timers - Object containing interval and timeout ids
 * @param {String} type - SCROLL_PADDLE_TYPE enum - PREVIOUS or NEXT
 * @returns {Function} returns function that handles scrolling previous column
 */
export const handleScroll = (columnMinWidth, timers, type) => (event) => {
    const args = [ columnMinWidth, event ];
    if (type === SCROLL_PADDLE_TYPE.PREVIOUS) {
        scrollToPrevCol(...args);
        setScrollTimer(scrollToPrevCol.bind({}, ...args), timers);
    }
    else {
        scrollToNextCol(...args);
        setScrollTimer(scrollToNextCol.bind({}, ...args), timers);
    }
};

/**
 * Clears the setTimeout and setInterval for horizontal scrolling
 * @param {object} timers - Object containing interval and timeout ids
 * @returns {Function} returns function that clears the interval and timeout instances
 */
export const clearTimers = (timers) => () => {
    clearTimeout(timers.timeoutId);
    clearInterval(timers.intervalId);
    timers.timeoutId = 0;
    timers.intervalId = 0;
};

/**
 * Checks if the provided element has x [horizontal] overflow
 * @param {HtmlElement <Object>} element - flowsheet DOM element
 * @returns {boolean} True if overflows, false otherwise
 */
export const hasXOverflow = (element) => element && element.scrollWidth > element.clientWidth;
