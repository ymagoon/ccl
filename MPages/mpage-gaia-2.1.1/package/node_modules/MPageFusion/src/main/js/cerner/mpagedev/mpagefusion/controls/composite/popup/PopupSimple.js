/**
 * @fileoverview
 * @author Gyandeep Singh
 */

"use strict";

import UIComponent, { mediaQuery } from "../../../base";
import PopupPane from "./PopupPane";
import Container from "../../atomic/container";
import { detectFlipPositionY, detectFlipPositionX } from "../../../helpers/dom/positioning";
import { updateZIndexes } from "../../../helpers/z-index/z-index";
import {
    popupPositions,
    secondaryPositions,
    adjustPopupPanePosition,
    adjustPopupPaneHeight,
    adjustNodeToAnchor,
    adjustPopupArrowPosition,
    isSmallerScreen
} from "./domHelpers";
import classNames from "classnames";
import FullScreenBehavior from "../../../behaviors/FullScreenBehavior";

/*
 Constants
 */
const disclosureIdentifierClass = "mpageui-disclosure-element";
const paneWrapperClass = "mpageui-Popup-pane";
const paneArrowClass = "mpageui-Popup-arrow";
const anchorWrapperClass = "mpageui-Popup-anchor";
const arrowBehavior = "mpageui-Popup--arrow";
const hasArrowClass = "mpageui-Popup--hasArrow";
const floatingPaneClass = "mpageui-Popup-floatingPane";
const popupLayoverClass = "mpageui-Popup-layover";
const popupContentClass = "mpageui-Popup-content";
const paneHeaderCloseEventName = "PopupHeader::close";
const popupOpenEventName = "Popup::open";
const popupCloseEventName = "Popup::close";
const paneFooterClass = "mpageui-Popup-pane-footer";

/*  eslint-disable no-use-before-define */

/**
 * Returns the Appropriate function based on the position to check the flip
 * @param {Popup.POSITION} position - Pane element created by floating pane
 * @returns {Function} Appropriate flip function
 * @private
 */
const getPositionFlipFunc = (position) =>
    position === Popup.POSITION.LEFT || position === Popup.POSITION.RIGHT ?
        detectFlipPositionX : detectFlipPositionY;

/**
 * Gets the secondary default position based on the primary position.
 * @param {Popup.POSITION} position - Pane element created by floating pane
 * @returns {Popup.POSITION} Default secondary position
 * @private
 */
const getSecondaryPositionByPrimary = (position) =>
    position === Popup.POSITION.LEFT || position === Popup.POSITION.RIGHT ?
        Popup.POSITION.BOTTOM : Popup.POSITION.RIGHT;

/**
 * Creates the PopupHeader object with the provided title
 * @param {function} el - vDom creation function
 * @param {Popup.POSITION} position - primary position
 * @param {boolean} isVisible - Is the floating pane visible or not
 * @returns {[*]} Returns collection based on visible flag
 * @private
 */
const getArrowRendered = (el, position, isVisible) => isVisible ?
    ([
        el(
            "div",
            {
                class: classNames({
                    [ paneArrowClass ]: true,
                    [ position ]: true
                })
            },
            []
        )
    ]) : [];

/**
 * Creates the Popup content by wrapping it inside a container
 * @param {Array.<UIComponent>} content - Content for the popup
 * @param {string} contentClassNames - content css class name
 * @returns {Container} Container object
 * @private
 */
const getContentObj = (content, contentClassNames) => new Container({
    classNames: `${popupContentClass} ${contentClassNames}`,
    wrapChildren: true
}, content);

/**
 * Creates children for floating pane
 * @param {Array.<UIComponent>} content - content of the floating pane
 * @param {string} contentClassNames - content css class name
 * @param {UIComponent} headerObj - header uicomponent
 * @returns {Array.<UIComponent>} Collection of UIComponent
 * @private
 */
const createFloatingPaneChildren = (content, contentClassNames, headerObj) => [
    ...( headerObj ? [ { header: headerObj } ] : [] ),
    {
        content: getContentObj(content, contentClassNames)
    }
];

/**
 * Create the FloatingPane object to be consumed by the pop up
 * @param {Array.<UIComponent>} content - Collection of UIComponent for the pane body
 * @param {Function} adjustPositionFn - Function to be called when floating pane is on the dom
 * @param {Function} resizeFn - Function to be called resize happens
 * @param {Popup.SIZE} popupSize - Size of the popup
 * @param {string} contentClassNames - content css class name
 * @param {UIComponent} headerObj - header uicomponent
 * @returns {FloatingPane} FloatingPane Object
 * @private
 */
const getFloatingPaneObject = (content, adjustPositionFn, resizeFn, popupSize, contentClassNames, headerObj) => new PopupPane(
    {
        classNames: `${floatingPaneClass} ${popupSize}`,
        onDomChange: adjustPositionFn,
        onResize: resizeFn
    },
    createFloatingPaneChildren(content, contentClassNames, headerObj)
);

/**
 * If its visible then return a collection of vdom elements else return an empty array.
 * when visible it will contain only Pane element.
 * @param {Function} el - vDom creation function
 * @param {Popup.POSITION} primaryPosition - primary position
 * @param {FloatingPane} pane - FloatingPane object
 * @param {boolean} isVisible - Is the floating pane visible or not
 * @param {boolean} showArrow - Is the arrow available on popup
 * @param {Array<VDom>} layover - The virtual dom of the rendered layover element.
 * @param {String} popupId - the unique popup id
 * @returns {[*]} Returns collection based on visible flag
 * @private
 */
const getPaneRendered = (el, primaryPosition, pane, isVisible, showArrow, layover, popupId) => isVisible ?
    ([
        el(
            "div",
            {
                class: classNames({
                    [ paneWrapperClass ]: true,
                    [ hasArrowClass ]: showArrow,
                    [ primaryPosition ]: true,
                    [ disclosureIdentifierClass ]: true
                }),
                "data-popup-pane-id": popupId,
                oncreate: () => setTimeout(updateZIndexes, 0) // Otherwise the updation logic sometimes executes before DOM is present.
            },
            [
                ...getArrowRendered(el, primaryPosition, isVisible && showArrow),
                ...layover,
                pane.render()
            ]
        )
    ]) : [];

/**
 * Creates a layover div element behind the popup but above all the other stuff on dom.
 * @param {VDom} el - vDom creation function
 * @param {Function} onClickFunc - click function handler
 * @param {boolean} isVisible - when to use layover or not
 * @returns {[*]} Returns collection based on visible flag
 * @private
 */
const getLayoverRendered = (el, onClickFunc, isVisible) => isVisible ?
    ([
        el(
            "div",
            {
                class: popupLayoverClass,
                onclick: onClickFunc
            },
            []
        )
    ]) : [];

export default class Popup extends UIComponent {
    /**
     * Returns the names of all the props
     * @returns {string[]} prop names
     * @static
     */
    static getPropNames() {
        return [
            "visible",
            "anchorControl",
            "size",
            "content",
            "showArrow",
            "closeOnClickAway",
            "defaultClassNames",
            "classNames",
            "anchorClassNames",
            "contentClassNames",
            "position",
            "popupOpenEventName",
            "popupCloseEventName",
            "footerControl",
            "isDisabled"
        ];
    }

    /**
     * @inheritdoc
     */
    constructor(props, children) {
        super(props, children);
        this._screenSizeOnOpen = null;
        this._fullScreen = new FullScreenBehavior(null, {
            adjustHeightElemQuery: `.${floatingPaneClass}`
        });
    }

    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            visible: false,
            anchorControl: null,
            size: Popup.SIZE.MEDIUM,
            content: [],
            showArrow: true,
            closeOnClickAway: true,
            defaultClassNames: "mpageui-Popup",
            classNames: "",
            anchorClassNames: "",
            contentClassNames: "",
            position: Popup.POSITION.BOTTOM,
            popupOpenEventName,
            popupCloseEventName,
            headerObj: null,
            footerControl: null,
            isDisabled: false
        };
    }

    /**
     * Creates the children objects and returns them has an array
     * @returns {Array<UIComponent>} Array of UIComponent
     */
    createChildren() {
        const pane = getFloatingPaneObject(
            this.getProp("content"),
            this._adjustPosition.bind(this),
            this._windowResizeHandler.bind(this),
            this.getProp("size"),
            this.getProp("contentClassNames"),
            this.getProp("headerObj")
        );

        this._popupId = pane.elementId;

        return [
            {
                pane
            }
        ];
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            anchorControl: (anchor) => {
                this.replaceMappedChild("anchor", anchor);
            },
            visible: (isVisible) => {
                this.getChild("pane").setProp("visible", isVisible);

                /*
                 * Reset the pane position to original position on close, so that on the next open it
                 * can load on the original position and not on the previously adjusted position.
                 */
                if (!isVisible) {
                    this.getChild("pane").setProp("position", this.getProp("position"));
                    this._screenSizeOnOpen = null;
                }
                else {
                    this._screenSizeOnOpen = mediaQuery.current().name;
                }
            },
            content: (newContent) => {
                this.getChild("pane").replaceMappedChild("content", getContentObj(newContent, this.getProp("contentClassNames")));
            },
            size: (newSize) => {
                this.getChild("pane").setProp("classNames", `${floatingPaneClass} ${newSize}`);
            },
            headerObj: (newHeaderObj) => {
                if (newHeaderObj) {
                    this.getChild("pane")
                        .replaceMappedChild("header", newHeaderObj);
                }
            },
            footerControl: (newFooterObj) => {
                if (newFooterObj) {
                    // inject our own CSS class name so that its easy to find when trying to get footer height later on
                    newFooterObj.setProp("classNames", `${newFooterObj.getProp("classNames")} ${paneFooterClass}`);
                    this.getChild("pane")
                        .replaceMappedChild("footer", newFooterObj);
                }
                else {
                    this.getChild("pane").removeChild("footer");
                }
            }
        };
    }

    /**
     * Window resize handler, which would close the popup on resize
     * @returns {undefined}
     * @private
     */
    _windowResizeHandler() {
        if (!isSmallerScreen() || ![ "XS", "XXS" ].includes(this._screenSizeOnOpen)) {
            this._closePopupHandler();
        }
    }

    /**
     * Click handler for anchor element
     * Open the pop up
     * @returns {undefined}
     * @private
     */
    _anchorClickHandler() {
        if (!this.getProp("visible")) {
            this.setProp("visible", true);
            this.emit(this.getProp("popupOpenEventName"), this);
            this.update();
        }
        else {
            this._closePopupHandler();
        }
    }

    /**
     * Closes the popup
     * @returns {undefined}
     * @private
     */
    _closePopupHandler() {
        this.setProp("visible", false);
        this.emit(this.getProp("popupCloseEventName"), this);
        this.update();
    }

    /**
     * Adjust the position of popup if its getting cutoff from the screen.
     * @param {HTMLElement} element - floating pane DOM element. The actual popup element
     * is the parent to this element; element.parentNode.
     * @returns {undefined}
     * @private
     */
    _adjustPosition(element) {
        /*
         * Have to attach it to document.body directly because a bug/issue in iOS browsers only (all browser)
         * They do not allow a fixed element inside a scrollable div to cover the whole document.body.
         * More info: http://stackoverflow.com/questions/37605289/layover-with-fixed-position-not-covering-document-body-when-inside-div-with-over
         */
        const anchorElem = element.parentNode.previousSibling;
        const popupPaneElem = element.parentNode;

        this._fullScreen.setElement(popupPaneElem).init();
        adjustNodeToAnchor(popupPaneElem, anchorElem);

        if (isSmallerScreen()) {
            this._fullScreen.update();
        }
        else {
            const currentPos = this.getProp("position");
            const adjustedSecondaryPosition = getSecondaryPositionByPrimary(currentPos);
            const newPrimaryPosition = getPositionFlipFunc(currentPos)(element, currentPos, Popup.POSITION);
            const newSecPosition = getPositionFlipFunc(adjustedSecondaryPosition)(element, adjustedSecondaryPosition, Popup.POSITION);

            popupPaneElem.classList.remove(currentPos);
            popupPaneElem.classList.add(newPrimaryPosition);
            popupPaneElem.classList.add(secondaryPositionClassesMap[ newSecPosition ]);

            const arrowElem = popupPaneElem.querySelector(`.${paneArrowClass}`);

            if (arrowElem) {
                arrowElem.classList.remove(arrowElem.classList.item(1));
                arrowElem.classList.add(newPrimaryPosition);
                adjustPopupArrowPosition(arrowElem, newPrimaryPosition, anchorElem);
            }

            adjustPopupPanePosition(element, newPrimaryPosition, newSecPosition, anchorElem);
            adjustPopupPaneHeight(element);
        }

        this._fullScreen.gc();
    }

    /**
     * @inheritdoc
     */
    afterCreate() {
        this.on(paneHeaderCloseEventName, () => {
            this.stopPropagation(paneHeaderCloseEventName);
            this._closePopupHandler();
        });
    }

    /**
     * @inheritdoc
     */
    view(el, props, children, mChildren) {
        return el(
            "div",
            {
                class: classNames({
                    [ props.defaultClassNames ]: true,
                    [ arrowBehavior ]: props.showArrow,
                    [ props.classNames ]: props.classNames.length > 0
                }),
                "data-popup-id": this._popupId
            },
            [
                el(
                    "div",
                    {
                        onclick: ((props.visible && props.closeOnClickAway) || props.isDisabled) ? null : this._anchorClickHandler.bind(this),
                        class: classNames({
                            [ anchorWrapperClass ]: true,
                            [ props.anchorClassNames ]: props.anchorClassNames.length > 0
                        })
                    },
                    mChildren.anchor.render()
                ),
                ...getPaneRendered(
                    el,
                    props.position,
                    mChildren.pane,
                    props.visible,
                    props.showArrow,
                    getLayoverRendered(
                        el,
                        this._closePopupHandler.bind(this),
                        props.visible && props.closeOnClickAway
                    ),
                    this._popupId
                )
            ]
        );
    }
}

/**
 * Popup events
 * @type {{OPEN: string, CLOSE: string}}
 */
Popup.EVENTS = {
    OPEN: popupOpenEventName,
    CLOSE: popupCloseEventName
};

/**
 * Position enum
 * @type {{LEFT: string, RIGHT: string, TOP: string, BOTTOM: string}}
 */
Popup.POSITION = popupPositions;

/**
 * Popup Sizes
 * @type {{SMALL: string, MEDIUM: string, LARGE: string, CUSTOM: string}}
 */
Popup.SIZE = {
    SMALL: "mpageui-Popup-floatingPane--small",
    MEDIUM: "mpageui-Popup-floatingPane--medium",
    LARGE: "mpageui-Popup-floatingPane--large",
    CUSTOM: "mpageui-Popup-floatingPane--custom"
};

/**
 * Secondary position css classes map based on primary classes
 */
const secondaryPositionClassesMap = (() => Object.keys(Popup.POSITION).reduce((coll, val) => {
    coll[ Popup.POSITION[ val ] ] = secondaryPositions[ val ];
    return coll;
}, {}))();
