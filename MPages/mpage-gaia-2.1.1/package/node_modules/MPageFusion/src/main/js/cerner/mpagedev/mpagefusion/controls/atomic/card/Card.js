"use strict";

import UIComponent from "../../../base";
import CollapseGroup from "../../composite/collapse-group";
import Container from "../container/Container";
import { LoadingSpinner } from "../indicator";
import classNames from "classnames";
import { svg } from "../icon";
import { unique } from "../../../helpers/core/generators";
import { isSelectedClassName, isNotSelectableClassName } from "../../../helpers/const/classNames";

const {
    communication: {
        Comment
    },
    navigation: {
        Select
    }
} = svg;

// Constants
const EVENTS = {
    SELECTION_CHANGE: "Card::selectionChange",
    CLICK: "Card::click"
};

const ACTIONS = {
    STYLE: {
        PRIMARY: CollapseGroup.MODIFIERS.ACTION.STYLE.PRIMARY,
        SECONDARY: CollapseGroup.MODIFIERS.ACTION.STYLE.SECONDARY,
        LINK: CollapseGroup.MODIFIERS.ACTION.STYLE.LINK
    }
};

const NAMESPACE = "mpageui-Card";
const CLASSES = {
    root: `${ NAMESPACE }`,
    bodyContent: `${ NAMESPACE }-base`,
    contentWrapperPad: `${ NAMESPACE }-content-wrapper-pad`,
    cardCenterContent: `${ NAMESPACE }-center-content`,
    cardDataContentWrapper: `${ NAMESPACE }-data-content-wrapper`,
    cardDataContentWrapperIE: `${ NAMESPACE }-data-content-wrapper--ieFix`,
    cardDataItemSingleCol: `${ NAMESPACE }-data-item--singleColumn`,
    cardDataItemDualCol: `${ NAMESPACE }-data-item--dualColumn`,
    cardDataItemRight: `${ NAMESPACE }-data-item--right`,
    cardDataItemPad: `${ NAMESPACE }-data-item-pad`,
    cardDataLabel: `${ NAMESPACE }-data-label`,
    cardDataIcon: `${ NAMESPACE }-data-icon`,
    cardDataContent: `${ NAMESPACE }-data-content`,
    cardDataTruncate: `${ NAMESPACE }--truncate`,
    hover: `${ NAMESPACE }--hover`,
    selected: isSelectedClassName,
    comment: `${ NAMESPACE }-comment`,
    commentIcon: `${ NAMESPACE }-comment-icon`,
    commentText: `${ NAMESPACE }-comment-text`,
    progressiveDisclosure: `${ NAMESPACE }-progressive-disclosure`,
    accessory: `${ NAMESPACE }-accessory`,
    leftAccessory: `${ NAMESPACE }-accessory--left`,
    rightAccessory: `${ NAMESPACE }-accessory--right`,
    accessoryTopAlign: `${ NAMESPACE }-accessory--align-top`,
    footer: `${ NAMESPACE }-footer`,
    footerIconWrapper: `${ NAMESPACE }-footer-icon-wrapper`,
    footerTextWrapper: `${ NAMESPACE }-footer-text-wrapper`,
    footerContentWrapper: `${ NAMESPACE }-footer-content-wrapper`,
    footerContentWrapperNarrow: `${ NAMESPACE }-footer-content-wrapper--narrow`,
    footerText: `${ NAMESPACE }-footer-text`,
    footerActionsWrapper: `${ NAMESPACE }-footer-actions-wrapper`,
    footerActionsWrapperFull: `${ NAMESPACE }-footer-actions-wrapper--full`,
    footerActions: `${ NAMESPACE }-footer-actions`,
    footerLoadingSpinnerWrapper: `${ NAMESPACE }-footer-loading-spinner-wrapper`,
    contentWrapper: `${ NAMESPACE }-content-wrapper`,
    strip: `${ NAMESPACE }-strip`,
    leftStrip: `${ NAMESPACE }--leftStrip`,
    removePad: `${ NAMESPACE }-removePad`
};

const CHEVRON = new Select().render();
const COMMENT = new Comment().render();
const SPINNER = new LoadingSpinner({
    isLoading: true,
    size: LoadingSpinner.SIZE.SMALL
}).render();

/**
 * Checks if there is any footer content
 * @param {object} props - the Card props
 * @returns {boolean} True if a footer will be rendered
 */
const shouldRenderFooterContent = (props) => props.footerText || props.footerIcon || props.isLoading;

/**
 * Checks if footer will be created
 * @param {object} props - the Card props
 * @returns {boolean} True if it is an action footer or will render a footer
 */
const shouldRenderFooter = (props) => props.actions.length || shouldRenderFooterContent(props);

/**
 * Renders an accessory if provided
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {string} side - the left or right side accessory
 * @returns {VDom | null} The virtual dom display of the right accessory or null.
 */
const renderAccessory = (el, props, side) => {
    const accessory = props[ `${ side }Accessory` ];
    return accessory || props[ `${ side }AccessoryPad` ] ?
        el("div",
            {
                class: classNames({
                    [ CLASSES.accessory ]: true,
                    [ CLASSES[ `${ side }Accessory` ] ]: true,
                    [ CLASSES.accessoryTopAlign ]: props[ `${ side }AccessoryTopAlign` ]
                })
            },
            accessory ? accessory.render() : null)
        : null;
};

/**
 * Renders the progressive disclosure area if specified
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @returns {VDom | null} The virtual dom display of the progressive
 *      disclosure area or null.
 */
const renderProgressiveDisclosureArea = (el, props) =>
    props.hasProgressiveDisclosure || props.progressiveDisclosurePad ?
        el("div",
            {
                class: CLASSES.progressiveDisclosure
            },
            props.hasProgressiveDisclosure ? CHEVRON : null)
        : null;

/**
 * Renders the comment section if specified
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @returns {VDom | null} The virtual dom display of the comment section or null.
 */
const renderCommentSection = (el, props) =>
    props.comment !== "" ?
        el("div", { class: CLASSES.comment }, [
            el("div", { class: CLASSES.commentIcon }, COMMENT),
            el("div", { class: CLASSES.commentText }, props.comment)
        ]) : null;

/**
 * Parses the value and return value if its not null
 * otherwise return dash
 * @param {*} val - value to check
 * @returns {*|string} return the val if its not null
 * @private
 */
const parseItemValue = (val) => val === null ? "--" : val;

/**
 * Returns "--" if the datapoint value is null, otherwise returns the value
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} dataPoint - object containing a value property
 * @param {object} customClasses - an object containing custom css classes
 * @returns {String | null} - the value
 */
const getStandardContent = (el, dataPoint, customClasses) =>
    customClasses.length === 0 || dataPoint.value === null ?
        parseItemValue(dataPoint.value) :
        el(
            "span",
            {
                class: customClasses
            },
            dataPoint.value
        );

/**
 * Returns rendered custom content
 * @param {Function} el - A function for creating virtual elements.
 * @param {UIComponent[]} content - Collection of UIComponents
 * @param {string} customCss - custom css
 * @returns {object|object[]} - rendered vdom
 * @private
 */
const renderCustomContent = (el, content, customCss) =>
    customCss.length > 0 // only create a span if their s some custom css otherwise just render them directly
        ? el(
            "span",
            {
                class: customCss
            },
            content.map((c) => c.render())
        )
        : content.map((c) => c.render());

/**
 * Renders the content of a single data point content
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {object} dataPoint - an object containing properties: icon, label, content/value
 * @param {string} customClasses - custom css classes
 * @returns {VDom} The virtual dom display of a data point value
 */
const renderDataPointContent = (el, props, dataPoint, customClasses) =>
    dataPoint.content && dataPoint.content.length ?
        renderCustomContent(el, dataPoint.content, customClasses) : getStandardContent(el, dataPoint, customClasses);

/**
 * Renders the content of a single datapoint
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {object} dataPoint - an object containing properties: icon, label, content/value
 * @param {object} customClasses - an object containing custom css classes
 * @returns {VDom[]} The virtual dom display of a data point
 */
const renderDataItems = (el, props, dataPoint, customClasses) => [
    dataPoint.icon ? el("div", { class: CLASSES.cardDataIcon }, dataPoint.icon.render()) : null,
    el(
        "div",
        {
            class: classNames({
                [ CLASSES.cardDataContentWrapper ]: true,
                [ CLASSES.cardDataContentWrapperIE ]: dataPoint.icon,
                [ CLASSES.cardDataTruncate ]: props.truncate || dataPoint.truncate
            })
        },
        [
            "label" in dataPoint && dataPoint.label !== ""
                ? el("div", { class: CLASSES.cardDataLabel }, `${ dataPoint.label }:`) : null,
            renderDataPointContent(el, props, dataPoint, classNames({
                [ dataPoint.contentClassNames ]: dataPoint.contentClassNames && dataPoint.contentClassNames !== "",
                [ customClasses.content ]: true
            }))
        ]
    )
];

/**
 * Renders an individual data point
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {object} dataPoint - an object containing properties: icon, label, content
 * @param {object} customClasses - an object containing custom css classes
 * @returns {VDom} The virtual dom display of a data point
 */
const renderDataPoint = (el, props, dataPoint, customClasses) =>
    el(
        "div",
        {
            class: customClasses.wrapper
        },
        [
            ...renderDataItems(el, props, dataPoint, customClasses)
        ]
    );

/**
 * Calculates if the first row needs to be emphasised based on
 * - card is single column and there are at least two data points
 * - card is dual column and there are at least three data points
 * @param {boolean} isDualCol - is the layout 2 column or not
 * @param {int} idx - index of the current data item
 * @param {int} itemCount - total number of items inside the cards
 * @returns {boolean} True if first row needs to be emphasised
 * @private
 */
const isFirstRowEmphasised = (isDualCol, idx, itemCount) =>
    isDualCol ? itemCount > 2 && idx <= 1 : itemCount > 1 && idx === 0;

/**
 * Generates CSS classes for each data item
 * based on
 *  - column type
 *  - if item is on the right(for dual col only)
 *  - text size for items which form the first row
 * @param {boolean} isDualCol - Whether its dual column layout or not
 * @param {boolean} isFlat - Whether its flat card
 * @param {int} idx - index of the data tem inside the collection
 * @param {int} itemCount - Total number of items present
 * @returns {string} CSS class names
 * @private
 */
const getDataPointClassByType = (isDualCol, isFlat, idx, itemCount) =>
    classNames({
        [ CLASSES.cardDataItemDualCol ]: isDualCol,
        [ CLASSES.cardDataItemSingleCol ]: !isDualCol,
        [ CLASSES.cardDataItemPad ]: !isFlat && itemCount > 1,
        [ CLASSES.cardDataItemRight ]: isDualCol && idx % 2 !== 0,
        "mpageui-u-text-size-md": !isFlat && isFirstRowEmphasised(isDualCol, idx, itemCount)
    });

/**
 * Generates VDom for all the data items
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - control props
 * @returns {object} VDom for all the data points
 * @private
 */
const renderDataPoints = (el, props) => props.items.map(
    (item, idx, items) => renderDataPoint(el, props, item, {
        wrapper: getDataPointClassByType(props.isDualColumn, props.isFlat, idx, items.length),
        content: idx === 0 || (props.isDualColumn && idx === 1) ? CLASSES.cardDataContent : ""
    })
);

/**
 * Renders the card center content
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @returns {VDom} The virtual dom display of the center content
 */
const renderCenterContent = (el, props) =>
    el(
        "div",
        {
            class: classNames({
                [ CLASSES.cardCenterContent ]: true,
                "mpageui-u-text-color-secondary": !props.isFlat
            })
        },
        [
            renderDataPoints(el, props),
            renderCommentSection(el, props)
        ]
    );

/**
 * Renders the card footerContent
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {Array} children - the Card children
 * @param {object} mappedChildren - the named Card children
 * @returns {VDom} The virtual dom display of the footer content
 */
const renderFooterContent = (el, props, children, mappedChildren) =>
    el("div",
        {
            class: classNames({
                [ CLASSES.footerContentWrapper ]: true,
                [ CLASSES.footerContentWrapperNarrow ]: props.actions.length
            })
        },
        [
            props.footerIcon || props.footerText ?
                el("div",
                    {
                        class: CLASSES.footerTextWrapper,
                        key: "footerText"
                    },
                    [
                        el("div", {}, [
                            props.footerIcon ?
                                el("div", { class: CLASSES.footerIconWrapper },
                                    props.footerIcon.render()
                                ) : null,
                            props.footerText ?
                                el("p", { class: CLASSES.footerText }, props.footerText) : null
                        ])
                    ]
                ) : null,
            props.isLoading ?
                el("div",
                    {
                        class: CLASSES.footerLoadingSpinnerWrapper,
                        key: "footerLoadingIndicator"
                    },
                    SPINNER
                ) : null
        ]
    );

/**
 * Renders the card footer
 * @param {Function} el - A function for creating virtual elements.
 * @param {object} props - the Card props
 * @param {Array} children - the Card children
 * @param {object} mappedChildren - the named Card children
 * @returns {VDom} The virtual dom display of the footer
 */
const renderFooter = (el, props, children, mappedChildren) => {
    const shouldRenderContent = props.footerText || props.footerIcon || props.isLoading;
    return shouldRenderContent || props.actions.length ?
        el("div", { class: CLASSES.footer }, [
            shouldRenderContent ?
                renderFooterContent(el, props, children, mappedChildren)
                : null,
            props.actions.length ?
                el("div",
                    {
                        class: classNames({
                            [ CLASSES.footerActionsWrapper ]: true,
                            [ CLASSES.footerActionsWrapperFull ]: !shouldRenderContent
                        })
                    },
                    el("div",
                        {
                            class: CLASSES.footerActions,
                            key: "footerActions"
                        },
                        mappedChildren.actionGroup.render()
                    )
                ) : null
        ])
        : null;
};

/**
 * Generates a collapse group button from an action
 * @param {object} action - the action object
 * @param {number} index - the index of the action in the actions array
 * @returns {object} the collapse group button json
 */
const generateActionButton = (action, index) =>
    Object.assign({},
        {
            type: CollapseGroup.TYPES.ACTION,
            display: action.display,
            id: index,
            eventName: action.eventName || `Card::action::${ index }::click`
        },
        {
            style: action.style ? action.style : null
        }
    );

/**
 * Generates a collapse group divider if the index of the current action
 * is not the last index
 * @param {object} actionIndex - the action object index
 * @param {number} actionsLength - the length of the actions list
 * @returns {object} the collapse group button json
 */
const generateDivider = (actionIndex, actionsLength) =>
    (actionIndex !== actionsLength - 1) ?
        [ { type: CollapseGroup.TYPES.DIVIDER } ]
        : [];

/**
 * Generates the click handler for the card control
 * @param {Card} control - the card control
 * @returns {undefined} undefined
 */
const generateClickHandler = (control) => (e) => {
    control.emit(control.getProp("clickEventName"), control);

    if (control.getProp("isSelectable")) {
        const isSelected = !control._state.isSelected; // eslint-disable-line no-underscore-dangle

        control._state.isSelected = isSelected; // eslint-disable-line no-underscore-dangle

        control.emit(control.getProp("selectionChangeEventName"), control, isSelected);
        control.update();
    }
};

/**
 * Compiles an array of children UI Components found within an array of Card items
 *
 * @private
 * @function extractChildrenFromItems
 * @param {Array<Object>} items - An array of Card Item configuration objects
 * @returns {UIComponent[]} An array of children UI Components
 */
const extractChildrenFromItems = (items) => items.reduce((foundChildren, item) => [
    ...foundChildren,
    ...(item.content && item.content.length ? item.content : [])
], []);

/**
 * Card class.
 * @class Card
 * @constructor
 */
export default class Card extends UIComponent {
    constructor(props, children) {
        super(props, children);
        this._state = {
            isSelected: false
        };
    }

    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            actions: [],
            clickEventName: EVENTS.CLICK,
            comment: "",
            footerIcon: null,
            footerText: "",
            hasProgressiveDisclosure: false,
            isDualColumn: false,
            isFlat: false,
            isHoverable: false,
            isLoading: false,
            isSelectable: false,
            isSelected: false,
            items: [],
            key: unique(),
            leftAccessory: null,
            leftAccessoryTopAlign: false,
            leftAccessoryPad: false,
            rightAccessory: null,
            rightAccessoryTopAlign: false,
            rightAccessoryPad: false,
            progressiveDisclosurePad: false,
            selectionChangeEventName: EVENTS.SELECTION_CHANGE,
            truncate: false,
            leftStrip: ""
        };
    }

    /**
     * @inheritdoc
     */
    propChangeHandlers() {
        return {
            items: (items) => this.getChild("itemsChildContainer").replaceAllChildren(extractChildrenFromItems(items)),
            isSelected: (isSelected) => {
                this._state.isSelected = isSelected;
            }
        };
    }

    /**
     * @inheritDoc
     */
    dependentPropChangeHandlers() {
        return [
            [ "actions", "footerIcon", "footerText", "isLoading",
                (actions, footerIcon, footerText, isLoading) => {
                    const actionsLength = actions.length;

                    // Early exit. Dont add children if its not needed.
                    // Adding collapse group and not using it is not efficient.
                    if (actionsLength === 0) {
                        this.removeChild("actionGroup");
                        return;
                    }

                    if (!this.getChild("actionGroup")) { // for first run add the child
                        this.addMappedChild("actionGroup", new CollapseGroup({
                            buttonSize: CollapseGroup.MODIFIERS.ACTION.SIZE.THIN
                        }));
                    }

                    // this turns a list of action items into a list of action buttons separated by dividers
                    this.getChild("actionGroup").setProp("items", actions.reduce((actionButtons, action, i) =>
                        [
                            ...actionButtons,
                            generateActionButton(action, i),
                            ...generateDivider(i, actionsLength)
                        ],
                    footerText || footerIcon || isLoading // if there is footer text/icon/loading spinner, add a preceding divider before the buttons
                        ? [ { type: CollapseGroup.TYPES.DIVIDER } ]
                        : []
                    )
                    );
                }
            ]
        ];
    }

    /**
     * @inheritDoc
     */
    createChildren() {
        return [
            {
                itemsChildContainer: new Container()
            }
        ];
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mappedChildren) {
        return el(
            "div",
            {
                class: classNames({
                    [ CLASSES.root ]: true,
                    [ CLASSES.hover ]: props.isHoverable,
                    [ CLASSES.selected ]: this._state.isSelected
                }),
                key: props.key
            },
            [

                el("div", {
                    class: classNames({
                        [ CLASSES.strip ]: props.leftStrip.length > 0,
                        [ isNotSelectableClassName ]: props.leftStrip.length > 0,
                        [ props.leftStrip ]: props.leftStrip.length > 0
                    })
                }, ""),
                el(
                    "div",
                    {
                        class: classNames({
                            [ CLASSES.contentWrapper ]: true,
                            [ CLASSES.contentWrapperPad ]: !props.isFlat,
                            [ CLASSES.leftStrip ]: props.leftStrip.length > 0
                        })
                    },
                    [
                        el("div",
                            {
                                class: classNames({
                                    [ CLASSES.bodyContent ]: true,
                                    [ CLASSES.removePad ]: shouldRenderFooter(props)
                                }),
                                onclick: generateClickHandler(this)
                            },
                            [
                                renderAccessory(el, props, "left"),
                                renderCenterContent(el, props),
                                renderAccessory(el, props, "right"),
                                renderProgressiveDisclosureArea(el, props)
                            ]
                        ),
                        renderFooter(el, props, children, mappedChildren)
                    ]
                )
            ]
        );
    }
}

Card.EVENTS = EVENTS;
Card.ACTIONS = ACTIONS;

