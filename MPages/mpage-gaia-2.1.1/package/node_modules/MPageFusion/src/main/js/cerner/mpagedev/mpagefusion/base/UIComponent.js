/* eslint
 "no-underscore-dangle": [2, { "allowAfterThis": true, "allow": ["_children", "_MPAGE_FUSION_TOOL_", "_MPAGE_FUSION_"] }],
 "no-restricted-imports": [2, "mithril-query"]
 */
/* globals __DEV__ */

/**
 * Virtual Dom
 * @typedef {Object} VDom
 */

/**
 * @typedef {Object} Context
 * @property {Object} [state] - Current state
 * @property {Object} [nextState] - Next state (if applicable)
 * @property {Object} [props] - Current props
 */

import m from "mithril/hyperscript";
import render from "mithril/render";
import EventEmitter from "./EventEmitter";
import { clamp } from "../helpers/core/math";
import {
    checkEmit,
    checkOn,
    checkRemoveListener,
    checkStopPropagation,
    checkMount
} from "./devChecker";

/**
 * Enumeration for standard UIComponent events.
 * @type {{REFRESH: string}}
 */
const EVENTS = {
    REFRESH: "refreshDomContents",
    UPDATE_COMPLETED: "updateCompleted"
};

const mRender = render.render;

/**
 * Adds a downstream event listener to the provided component's parent if
 * the parent exists. Otherwise, nothing happens.
 * @param {UIComponent} uiComponent - The UIComponent for which the parent will be retrieved
 * and a downstream listener will be added to.
 * @param {string} eventName - The name of the event.
 * @returns {undefined} Returns nothing.
 */
const addDownstreamListenerToParent = (uiComponent, eventName) => {
    if (!uiComponent.getParent()) {
        return;
    }
    uiComponent.getParent().addDownstreamListener(eventName, uiComponent);
};

/**
 * Shortcut to decompose the args into parameters to the emit
 * method in an event emitter.
 * @param {EventEmitter} emitter - The emitter that will emit the event.
 * @param {string} eventName - The name of the event to emit.
 * @param {Array<*>} args - An array of arguments to apply to the emit event.
 * @returns {undefined} Returns nothing.
 */
const emit = (emitter, eventName, args) => emitter.emit(eventName, ...args);

/**
 * Removes the specified child from the provided array.
 * @param {Array<UIComponent>} arr - The array of child UIComponent objects.
 * @param {UIComponent} child - The child UIComponent to be removed from
 * the array.
 * @returns {undefined} Returns nothing.
 */
const removeChildFromArr = (arr, child) => {
    const index = arr.indexOf(child);
    if (index === -1) {
        return;
    }
    arr.splice(index, 1);
};

/**
 * Removes the specified child from the provided UIComponent.
 * @param {UIComponent} comp - The UIComponent from which the specified child
 * will be removed from its mapped children hash.
 * @param {UIComponent} child - The child to be removed from the mapping.
 * @returns {undefined} Returns nothing.
 */
const removeChildFromMap = (comp, child) => {
    const childName = comp.getChildName(child);
    if (childName) {
        delete comp._mappedChildren[ childName ]; // eslint-disable-line no-underscore-dangle
    }
};

/**
 * Adds a new children into the component and sets its parent to that
 * component.
 * @param {UIComponent} parent - The parent to the child.
 * @param {UIComponent} child - The child to be added to the parent.
 * @param {Number} [index] - The index at which to add the child.
 * @returns {undefined} Returns nothing.
 */
const pushChild = (parent, child, index) => {
    const existingParent = child.getParent();

    if (existingParent) { // sanitize child to make sure its not in any parent's bucket
        existingParent.removeChild(child);
    }

    if (index !== undefined) {
        parent._children.splice(
            clamp(0, parent._children.length, index), // Index to insert
            0, // Don't delete
            child // Child to insert
        );
    }
    else {
        parent._children.push(child); // eslint-disable-line no-underscore-dangle
    }
    child.setParent(parent);
    child.connectDownstreamEvents();
};

/**
 * Determines if the specified event is currently stopping propagation.
 * @param {Object} stopPropagationLookup - An object of key-value pairs
 * where the key is the eventName and the value is a boolean indicating
 * whether the eventName is currently stopping propagation.
 * @param {String} eventName - The name of the event.
 * @returns {Boolean} True if the event is currently stopping propagation.
 */
const eventShouldStopPropagating = (stopPropagationLookup, eventName) => stopPropagationLookup[ eventName ];

/**
 * Resumes propagation for the specified event name.
 * @param {Object} stopPropagationLookup - An object of key-value pairs
 * where the key is the eventName and the value is a boolean indicating
 * whether the eventName is currently stopping propagation.
 * @param {String} eventName - The name of the event.
 * @returns {Object} The lookup of eventNames mapped to booleans.
 */
const resumePropagation = (stopPropagationLookup, eventName) => {
    stopPropagationLookup[ eventName ] = false;
    return stopPropagationLookup;
};

/**
 * Propagates an event to the parent if it exists, passing the args to the
 * emit.
 * @param {String} eventName - The name of the event.
 * @param {Array} args - The arguments to be passed to the parent emit
 * as a payload.
 * @param {UIComponent} parent - The parent UIComponent on which the emit
 * will be called.
 * @returns {undefined}
 */
const propagateEventToParent = (eventName, args, parent) => {
    if (!parent || !parent.emit) {
        return;
    }
    parent.emit(eventName, ...args);
};

/**
 * Iterates over the keys of the props and attempts to apply setters for
 * each of the props (if a setter exists).
 * @param {UIComponent} uiComponent - The UIComponent for which the props
 * are being parsed.
 * @param {Object} props - The props being parsed.
 * @returns {undefined} Returns nothing.
 */
const parseProps = (uiComponent, props) => {
    Object.keys(props).forEach((key) =>
        uiComponent.setProp(key, props[ key ]));
};

/**
 * Generates a unique id for mpageui components
 * @returns {string} unique id
 * @private
 */
function* idMaker() {
    let cnt = 0;
    while (true) { // eslint-disable-line no-constant-condition
        yield `mpage-ui-${++cnt}`;
    }
}

const gen = idMaker();

/**
 * Converts an array of dependent prop change handlers into a map of
 * props to their respective handler functions. This is needed to speed
 * up the lookup of dependent prop change handlers during syncProps.
 * @param {*} handlers - array of dependent prop change handlers
 * @returns {*} the parsed map
 */
const parseDependentPropChangeHandlers = (handlers) =>
    handlers.reduce(
        (result, handlerArray) => {
            const propNames = handlerArray.slice(0, handlerArray.length - 1);
            const handlerFun = handlerArray[ handlerArray.length - 1 ];
            propNames.forEach((propName) => {
                result[ propName ] = {
                    propNames,
                    handlerFun
                };
            });
            return result;
        },
        {}
    );

/**
 * Fires the handler function associated to the provided handler with
 * the provided control as the context.
 * @param {UIComponent} control - the control
 * @param {*} handler - handler JSON, as made by parseDependentPropChangeHandlers
 * @returns {*} result of the handler function, if any
 */
const triggerDependentPropChangeHandler = (control, handler) =>
    handler.handlerFun.apply(
        control,
        handler.propNames.map(
            (prop) => control._props[ prop ] // eslint-disable-line no-underscore-dangle
        ));

/**
 * Fires the dependent prop change handlers for the specified control
 * @param {UIComponent} control - the control
 * @returns {Array} all the properties that have been fired
 */
const triggerDependentPropChangeHandlers = (control) =>
    Object.keys(control._changedProps).reduce( // eslint-disable-line no-underscore-dangle
        (fired, propName) => {
            if (fired[ propName ]) {
                return fired;
            }
            const handler = control._dependentPropChangeHandlers[ propName ];// eslint-disable-line no-underscore-dangle

            if (!handler) {
                return fired;
            }
            triggerDependentPropChangeHandler(control, handler);
            handler.propNames.forEach(
                (prop) => {
                    fired[ prop ] = true;
                }
            );
            return fired;
        },
        {}
    );

/**
 * This function handles re-rendering a UIComponent into the specified
 * element id (the mount-point).
 * @param {UIComponent} ctrl - The mounted control.
 * @param {string} elementId - The id of the element in which the control
 * is mounted.
 * @returns {function} Function that handles re-rendering a UIComponent
 * control that has been mounted to the specified element id.
 */
const reRender = (ctrl, elementId) => () => {
    const element = document.getElementById(elementId);
    if (!element) {
        return;
    }
    mRender(element, ctrl.render());
    ctrl.emit(EVENTS.UPDATE_COMPLETED);

    /* istanbul ignore next */
    if (__DEV__ && typeof window._MPAGE_FUSION_TOOL_ !== "undefined") {
        window.dispatchEvent(new CustomEvent("mpage-fusion-data-update", {
            detail: {
                context: ctrl,
                elementId
            }
        }));
    }
};

/**
 * The base UIComponent class from which all MPageFusion controls will inherit.
 * @class UIComponent
 */
class UIComponent {
    /**
     * The default constructor for the UIComponent class.
     * @param {Object} [props] - A set of properties being injected into the
     * UIComponent instance.
     * @param {Array<UIComponent>} [children] - An array of children to be
     * added to the UIComponent.
     */
    constructor(props, children) {
        this._id = gen.next().value;
        this._stopPropagation = {};
        this._emitter = new EventEmitter();
        this._parent = null;
        this._children = [];
        this._mappedChildren = {};
        this._parent = null;
        this._props = {};
        this._changedProps = {};
        this._propChangeHandlers = {};
        this._dependentPropChangeHandlers = {};
        this._downstreamEventListeners = {};
        this._state = this.initialState();
        this._stateQueue = [];
        this._upstreamEventNames = [];
        this._upstreamEmitter = new EventEmitter();
        this._timerId = null;
        this.isUIComponent = true;
        this.create(
            Object.assign({}, this.initialProps(), props),
            children
        );
    }

    // -------------------------------------------------------------------------
    // Lifecycle
    // -------------------------------------------------------------------------

    /**
     * First lifecycle method. Called immediately in the constructor.
     * @returns {undefined} Returns nothing.
     */
    beforeCreate() {
    }

    /**
     * Last lifecycle method. Called last in the constructor.
     * @returns {undefined} Returns nothing.
     */
    afterCreate() {
    }

    /**
     * This function is a performance tuning lifecycle function that is called
     * to determine if a UIComponent should be rendered. This function should
     * be overridden by UIComponent objects only in situations that call for
     * granular performance control. This function must return a boolean and
     * should not, in any way, change the state of the UIComponent.
     * @returns {boolean} Whether the UIComponent should render.
     */
    shouldRender() {
        return true;
    }

    /**
     * Called right before the view is generated.
     * @param {Context} [context] - Current context.
     * @returns {undefined} Returns nothing.
     */
    beforeRender(context) {
    }

    /**
     * Called after the view has been generated. This DOES NOT
     * guarantee the view is in the DOM.
     * @returns {undefined} Returns nothing.
     */
    afterRender() {
    }

    /**
     * Returns a mapping of prop names to handler functions which will be triggered
     * immediately prior to a render cycle IF the prop has been changed.
     * @returns {Object} A mapping of prop names to change handlers.
     */
    propChangeHandlers() {
        return {};
    }

    /**
     * Returns a mapping of multiple prop names to a single handler function. The
     * function will be triggered when any of the props change before rendering.
     * @returns {Array} A list of all the dependent prop change handlers
     */
    dependentPropChangeHandlers() {
        return [];
    }

    /**
     * Lifecycle method. Returns the initial set of props for the UIComponent.
     * @returns {Object} The default set of props for the UIComponent.
     */
    initialProps() {
        return {};
    }

    /**
     * Invoked immediately before a UIComponent is removed from a parent.
     * @returns {undefined} Returns nothing.
     */
    beforeRemove() { // eslint-disable-line class-methods-use-this
    }

    /**
     * Creates the UIComponent by calling necessary lifecycle functions.
     * @param {Object} props - The set of props to be parsed for the UIComponent.
     * @param {Array<UIComponent>} children - UIComponents which are children
     * of this instance of UIComponent.
     * @returns {undefined} Returns nothing.
     */
    create(props, children) {
        // Parse the props to call associated setters so that merged props are available within beforeCreate
        parseProps(this, props);

        // Call lifecycle function beforeCreate
        this.beforeCreate();

        // Add the set of children (if any) to the UIComponent
        this.addChildren(this.createChildren({ props: this._props, state: this._state }))
            .addChildren(children);

        // Registers the change handlers
        this._propChangeHandlers = this.propChangeHandlers();

        // Registers dependent prop change handlers
        this._dependentPropChangeHandlers =
            parseDependentPropChangeHandlers(this.dependentPropChangeHandlers());

        // Call lifecycle function afterCreate
        this.afterCreate();
    }

    // -------------------------------------------------------------------------
    // State management
    // -------------------------------------------------------------------------

    /**
     * Sets the value of the specified prop and flags the prop as being changed.
     * @param {String} prop - The name of the prop.
     * @param {*} val - The value of the prop.
     * @returns {UIComponent} Current instance.
     */
    setProp(prop, val) {
        this._props[ prop ] = val;
        this._changedProps[ prop ] = true;
        return this;
    }

    /**
     * Takes a new set of props and merges them into the existing props. This
     * calls setProp for each prop, so any props that are changed will be
     * flagged as changed.
     * @param {object} newProps - The new set of props to set on the UIComponent.
     * @returns {UIComponent} Current instance.
     */
    setProps(newProps) {
        parseProps(this, newProps);
        return this;
    }

    /**
     * Returns the prop with the specified prop name.
     * @param {String} prop - The name of the prop to retrieve.
     * @returns {*} The value of the prop with the specified name.
     */
    getProp(prop) {
        return this._props[ prop ];
    }

    /**
     * Returns the full set of props for the UIComponent.
     * @returns {object} All props for the UIComponent.
     */
    getProps() {
        return this._props;
    }

    /**
     * Lifecycle function to initialize a UIComponent's internal state.
     * @returns {Object} Initial state.
     */
    initialState() { // eslint-disable-line class-methods-use-this
        return {};
    }

    /**
     * Queues up a state change to be resolved during the next render cycle. If the change is
     * an object, we assume a primitive state-change, otherwise the consumer has opted for the
     * updater approach which allows sequential changes to state.
     * @param {Object | Function} change - Either an object to merge into the state or
     * an updater function which receives the previous state and returns an updated state.
     * @returns {UIComponent} Returns self.
     */
    setState(change) {
        let updater = null;
        /*
         * If the change is an object, this is a simple state update, so
         * we simply create a function that merges the object onto the
         * previous state.
         */
        if (typeof change === "object") {
            updater = (prev) => Object.assign({}, prev, change);
        }
        /*
         * If the change is a function then we assume the consumer is
         * using the updater approach.
         */
        else if (typeof change === "function") {
            updater = change;
        }

        this._stateQueue = [
            ...this._stateQueue,
            updater
        ];
        return this;
    }

    /**
     * Using the queued up state changes, computes the next state.
     * @returns {Object} The next state.
     */
    computeNextState() {
        return this._stateQueue.reduce((acc, next) => Object.assign({}, acc, next(acc)), this._state);
    }

    /**
     * Merges the next state into the current state.
     * @param {Object} nextState - The next state.
     * @returns {UIComponent} Returns self.
     */
    mergeState(nextState) {
        this._state = Object.assign({}, this._state, nextState);
        return this;
    }

    /**
     * Synchronizes the state of the UIComponent by iterating over the
     * props that have been changed and calling the appropriate prop change
     * handlers. If no prop change handlers exist, this is a noop.
     * @returns {undefined} Returns nothing.
     */
    syncProps() {
        // Only perform this operation if there is a prop change handler
        if (Object.keys(this._propChangeHandlers).length) {
            Object.keys(this._changedProps)
                .forEach((prop) => {
                    if (this._propChangeHandlers[ prop ]) {
                        this._propChangeHandlers[ prop ](this._props[ prop ]);
                    }
                });
        }
        if (Object.keys(this._dependentPropChangeHandlers).length) {
            triggerDependentPropChangeHandlers(this);
        }
        this._changedProps = {};
        return this;
    }

    // -------------------------------------------------------------------------
    // Child management
    // -------------------------------------------------------------------------

    /**
     * Adds a UIComponent as a child of the current component. The parameter can also be
     * in the form of {key: child}, where key is the string to be used on getChild()
     * to retrieve that particular instance.
     * @param {UIComponent | *} child - The child being added.
     * @param {number} [index] - The index at which to insert the child.
     * @returns {UIComponent} Current instance.
     */
    addChild(child, index) {
        if (!child) {
            return this;
        }
        if (child.isUIComponent) {
            pushChild(this, child, index);
            return this;
        }

        const key = Object.keys(child)[ 0 ];
        this.addMappedChild(key, child[ key ]);

        return this;
    }

    /**
     * Adds a new child associated to a unique ID, which can then be
     * used on getChild(). If a child with the same key already exists,
     * it will not be added.
     * @param {String} key - The key for the child being added.
     * @param {UIComponent} child - The child being added with the specified key.
     * @param {number} [index] - Optional. If specified it replaces a children at the index
     * @returns {UIComponent} Current instance.
     */
    addMappedChild(key, child, index) {
        if (this._mappedChildren[ key ] !== undefined) {
            return this;
        }

        pushChild(this, child, index);
        this._mappedChildren[ key ] = child;
        return this;
    }

    /**
     * Adds children, which can be individual UIComponents, or in the format
     * {key: component}, which will create a child associated to a unique
     * ID that can be later accessed with getChild().
     * @param {UIComponent | *} children - The children to be added.
     * @returns {UIComponent} Current instance.
     */
    addChildren(children) {
        if (!children) {
            return this;
        }
        children.forEach((child) => this.addChild(child));
        return this;
    }

    /**
     * Replace an existing mapped child or creates a new one if it
     * doesn't exist.
     * @param {String} key - The key of the child to be replaced.
     * @param {UIComponent} child - The new child which will replace the child
     * with the provided key.
     * @returns {UIComponent} Current instance.
     */
    replaceMappedChild(key, child) {
        const index = this._children.indexOf(this._mappedChildren[ key ]);
        this.removeChild(key);
        this.addMappedChild(key, child, index);
        return this;
    }

    /**
     * Removes the component from being a child in this object. Takes either
     * a string or a UI component object.
     * @param {String | UIComponent} child - Either the id of the child or the
     * child UIComponent itself. This child will be removed. The beforeRemove
     * function is called on the child prior to being removed.
     * @returns {UIComponent} Current instance.
     */
    removeChild(child) {
        if (!child) {
            return this;
        }

        if (typeof child === "string") {
            this.removeChild(this.getChild(child));
            return this;
        }
        child.beforeRemove();
        removeChildFromArr(this._children, child);
        removeChildFromMap(this, child);
        child.setParent(null);
        this.removeAllDownstreamListeners(child);
        return this;
    }

    /**
     * Removes all the child components.
     * @returns {UIComponent} Current instance.
     */
    removeAllChildren() {
        // Slice is necessary so that the internal forEach will loop
        // through all the items as they are removed
        this.getChildren().slice(0).forEach((child) => this.removeChild(child));
        return this;
    }

    /**
     * Returns a child that was registered with the specified key, either
     * through the constructor or one of the addChild(ren) methods.
     * @param {String} name - The name of the child being retrieved.
     * @returns {UIComponent} The child that was added with the specified key.
     */
    getChild(name) {
        return this._mappedChildren[ name ];
    }

    /**
     * Returns the name of a child as stored in the internal map. Will return
     * null if the child cannot be found.
     * @param {UIComponent} child - The child for which the name will be
     * retrieved, if it exists.
     * @returns {String | null} The name of the child, or null if the specified
     * child has no name.
     */
    getChildName(child) {
        const nameColl = Object.keys(this._mappedChildren)
            .filter((name) => this.getChild(name) === child);
        return nameColl.length ? nameColl[ 0 ] : null;
    }

    /**
     * Returns the parent UIComponent.
     * @returns {UIComponent | null} The parent UIComponent or null.
     */
    getParent() {
        return this._parent;
    }

    /**
     * Sets the parent UIComponent.
     * @param {UIComponent} parent - The parent UIComponent.
     * @returns {UIComponent} Current instance.
     */
    setParent(parent) {
        this._parent = parent;
        return this;
    }

    /**
     * Returns the array of child UIComponents.
     * @returns {Array<UIComponent>} The array of child UIComponents.
     */
    getChildren() {
        return this._children;
    }

    /**
     * Returns the mapping of ids to child UIComponents.
     * @returns {{string: UIComponent}} Mapping of ids to child UIComponents.
     */
    getMappedChildren() {
        return this._mappedChildren;
    }

    /**
     * Returns the id of the UIComponent.
     * @returns {String} Id of the component
     */
    getId() {
        return this._id;
    }

    /**
     * Abstract. When implemented should return any child elements needed
     * by the parent on initialization.
     * @param {Context} [context] - Current context.
     * @returns {Array<UIComponent>} An array of child UIComponent objects
     * must be returned.
     */
    createChildren(context) {
        return [];
    }

    /**
     * Calls render() on all the children and returns the result as
     * a VDom array.
     * @returns {*} The virtual elements rendered by the children.
     */
    renderChildren() {
        return this.getChildren().map((child) => child.render());
    }

    /**
     * Replaces all the children with the provided children
     * @param {Array<UIComponent>} children - New set of children to be added.
     * @returns {UIComponent} Current instance.
     */
    replaceAllChildren(children) {
        this.removeAllChildren();
        this.addChildren(children);
        return this;
    }

    // -------------------------------------------------------------------------
    // Event management
    // -------------------------------------------------------------------------

    /**
     * Emits an event on the UIComponent. If the event should stop propagating,
     * the event ends there. Otherwise, the event will be propagated up the
     * chain to the parent UIComponent (if it exists). After preventing
     * propagation once, propagation will resume for the specified event.
     * @param {String} eventName - The name of the event that occurred;
     * @param {Array | *} args - The arguments to be passed as payload to the
     * emitter.
     * @returns {UIComponent} Current instance.
     */
    emit(eventName, ...args) {
        /* istanbul ignore next */
        if (__DEV__) {
            checkEmit(this.constructor.name, this._isRendering, eventName);
        }

        emit(this._emitter, eventName, args);
        if (eventShouldStopPropagating(this._stopPropagation, eventName)) {
            resumePropagation(this._stopPropagation, eventName);
            return this;
        }
        propagateEventToParent(eventName, args, this._parent);
        return this;
    }

    /**
     * Listens for an event on the event emitter. Events will come from
     * children.
     * @param {String} eventName - The name of the event being listened for.
     * @param {Function} listener - The function to be triggered when an event
     * occurs.
     * @returns {UIComponent} Current instance.
     */
    on(eventName, listener) {
        /* istanbul ignore next */
        if (__DEV__) {
            checkOn(this.constructor.name, eventName, listener);
        }

        this._emitter.on(eventName, listener);
        return this;
    }

    /**
     * Removes the listener for the event with the specified event name. In
     * order for this to actually remove the listener, this must be called
     * with the SAME listener reference that was provided to the "on"
     * function.
     * @param {String} eventName - The name of the event for which the listener
     * will be removed.
     * @param {Function} listener - The listener being removed.
     * @returns {UIComponent} Current instance.
     */
    removeListener(eventName, listener) {
        /* istanbul ignore next */
        if (__DEV__) {
            checkRemoveListener(this.constructor.name, eventName, listener);
        }

        this._emitter.removeListener(eventName, listener);
        return this;
    }

    /**
     * Prevents the specified event from propagating up the tree of UIComponents.
     * @param {String} eventName - The name of the event to prevent propagating.
     * @returns {UIComponent} Current instance.
     */
    stopPropagation(eventName) {
        /* istanbul ignore next */
        if (__DEV__) {
            checkStopPropagation(this.constructor.name, eventName);
        }

        this._stopPropagation[ eventName ] = true;
        return this;
    }

    /**
     * Watches an event and then emits another based on a converter function
     * that converts the event parameters. The converter should take event
     * parameters as arguments and return an array which will be the arguments
     * for the next event.
     * Example: this.convertEvent('click', 'removeItem', (ev) => [item]);
     * @param {String} sourceEvent - The name of the source event.
     * @param {String} destEvent - The name of the destination event, or what
     * the source event is converted to.
     * @param {Function} converter - A function which takes parameters for the
     * original event and returns an array of new arguments to be applied
     * to handlers of the destination event.
     * @returns {UIComponent} Current instance.
     */
    convertEvent(sourceEvent, destEvent, converter) {
        this.on(sourceEvent, (...args) => {
            this.stopPropagation(sourceEvent);
            this.emit(destEvent, ...converter(...args));
        });
        return this;
    }

    /**
     * Watches an event and then emits another while ignoring the first event's
     * parameters and using the ones specified.
     * @param {String} sourceEvent  - The name of the source event.
     * @param {String} destEvent  - The name of the event to fire.
     * @param {*} args - The arguments to be passed to the second event.
     * @returns {UIComponent} Current instance.
     */
    redirectEvent(sourceEvent, destEvent, ...args) {
        this.convertEvent(sourceEvent, destEvent, () => args);
        return this;
    }

    /**
     * Watches an event and then emits another named by the property provided.
     * The converter function will convert the arguments from one event to the other.
     * It takes event parameters as arguments and return an array which will be the
     * arguments for the next event.
     * @param {String} sourceEvent - the source event name
     * @param {String} propName - the property that contains the event name
     * @param {function} converter - the converter function
     * @returns {undefined}
     */
    convertEventUsingProp(sourceEvent, propName, converter) {
        this.on(sourceEvent, (...args) => {
            this.stopPropagation(sourceEvent);
            this.emit(this.getProp(propName), ...converter(...args));
        });
        return this;
    }

    /**
     * Same as convertEventUsingProp except that the arguments are fixed.
     * @param {String} sourceEvent - the source event name
     * @param {String} propName - the property that contains the event name
     * @returns {undefined}
     */
    redirectEventUsingProp(sourceEvent, propName, ...args) {
        this.convertEventUsingProp(sourceEvent, propName, () => args);
    }

    // -------------------------------------------------------------------------
    // Downstream Event Management
    // -------------------------------------------------------------------------

    /**
     * Recursively sets a path on the parent chain to forward evName downstream.
     * Child is only referenced on the current node.
     * @param {String} eventName - The name of the event.
     * @param {UIComponent} child - UIComponent that will forward the event
     * @returns {UIComponent} Current instance.
     */
    addDownstreamListener(eventName, child) {
        if (!this._downstreamEventListeners[ eventName ]) {
            this._downstreamEventListeners[ eventName ] = [];
        }
        const listeners = this._downstreamEventListeners[ eventName ];
        if (listeners.indexOf(child) !== -1) {
            return this;
        }
        listeners.push(child);
        if (this.getParent()) {
            this.getParent().addDownstreamListener(eventName, this);
        }
        return this;
    }

    /**
     * Removes child from the list of children that would be triggered in case
     * evName occurred upstream. Will traverse the parent chain up only if all
     * handlers for evName have been removed.
     * @param {String} eventName - The name of the event.
     * @param {UIComponent} child - Child to be triggered when even occurs
     * @returns {UIComponent} Current instance.
     */
    removeDownstreamListener(eventName, child) {
        const listeners = this._downstreamEventListeners[ eventName ];
        if (!listeners || listeners.length === 0) {
            return this;
        }
        removeChildFromArr(listeners, child);
        if (listeners.length === 0) {
            delete this._downstreamEventListeners[ eventName ];
            if (this.getParent()) {
                this.getParent().removeDownstreamListener(eventName, this);
            }
        }
        return this;
    }

    /**
     * Removes all downstream event listeners that have child as their target.
     * @param {UIComponent} child - child element.
     * @returns {UIComponent} Current instance.
     */
    removeAllDownstreamListeners(child) {
        Object.keys(this._downstreamEventListeners).forEach(
            (key) => this.removeDownstreamListener(key, child));
        return this;
    }

    /**
     * Ensures that the parents know how to route all downstream events
     * listened by this instance. This is usually used to reconnect events
     * after the current node was detached from the tree.
     * @returns {UIComponent} Current instance.
     */
    connectDownstreamEvents() {
        Object.keys(this._downstreamEventListeners).forEach(
            (key) => addDownstreamListenerToParent(this, key));
        this._upstreamEventNames.forEach(
            (evName) => addDownstreamListenerToParent(this, evName));
        return this;
    }

    /**
     * Stops listening to the specified event coming from upstream.
     * @param {string} eventName - The name of the event.
     * @param {Function} listener - The function used on "onUpstream" as the listener.
     * @returns {UIComponent} Current instance.
     */
    removeUpstreamListener(eventName, listener) {
        const emitter = this._upstreamEmitter;
        const eventNames = this._upstreamEventNames;
        emitter.removeListener(eventName, listener);
        if (emitter.listeners(eventName).length === 0) {
            eventNames.splice(eventNames.indexOf(eventName), 1);
            if (this.getParent()) {
                this.getParent().removeDownstreamListener(eventName, this);
            }
        }
        return this;
    }

    /**
     * Listens to events that have occurred anywhere on the parent chain.
     * @param {string} eventName - The event name.
     * @param {Function} listener - The callback function for the event.
     * @returns {UIComponent} Current instance.
     */
    onUpstream(eventName, listener) {
        this._upstreamEmitter.on(eventName, listener);
        this._upstreamEventNames.push(eventName);
        addDownstreamListenerToParent(this, eventName);
        return this;
    }

    /**
     * Emits an event downwards (to the children). While this will give
     * the impression that the event will be passed to all the children,
     * it will actually traverse only the children that are listening to
     * the upstream event.
     * @param {String} eventName - The event name.
     * @param {*} args - any arguments to be passed to the event.
     * @returns {UIComponent} Current instance.
     */
    emitDown(eventName, ...args) {
        if (!this._downstreamEventListeners[ eventName ]) {
            return this;
        }
        this._downstreamEventListeners[ eventName ].forEach(
            (child) => {
                emit(child._upstreamEmitter, eventName, args); // eslint-disable-line no-underscore-dangle

                child.emitDown(eventName, ...args);
            });
        return this;
    }

    // -------------------------------------------------------------------------
    // Rendering
    // -------------------------------------------------------------------------

    /**
     * Creates the content to be rendered in the current component
     * in VDOM format.
     * merged into the UIComponent prior to rendering.
     * @returns {*} Virtual elements returned by the view.
     */
    render() {
        /* istanbul ignore next */
        if (__DEV__) {
            this._isRendering = true;
        }

        this.syncProps();

        const nextState = this.computeNextState();
        this.beforeRender({
            props: this._props,
            state: this._state,
            nextState
        });

        // Merge the next state so it's available by the time the view is called
        this.mergeState(nextState);

        const view = this.view(m, this._props, this.getChildren(), this._mappedChildren, { state: this._state });

        this._stateQueue = [];
        this.afterRender();

        /* istanbul ignore next */
        if (__DEV__) {
            this._isRendering = false;
        }
        return view;
    }

    /**
     * Returns a single VDOM element for the content to be rendered. The first
     * parameter will be function used for generating a single VDOM element.  It
     * accepts the following arguments
     *     htmlTag - A string identifying the HTML tag that will encapsulate
     *         the contents of the VDON element.
     *     htmlAttributes - An object identify the various HTML attributes that
     *         will be applied ot the HTML tag created from htmlTag
     *     domChildren - Child VDOM elements that will be part of this VDOM element
     *
     * Ex.: f("div", {className: "somediv"}, [f("p",{}, "hello!")])
     *
     * The props, children and mappedChildren parameters are provided merely for
     * convenience for use in VDOM generating function el.
     *
     * @param {Function} el - A function that returns a single virtual dom element.
     * @param {object} props - The UIComponent's props.  Provided as a
     * convenience when constructing the htmlAttributes
     * @param {Array<UIComponent>} children - The children of this UIComponent
     * instance provided as a convenience when rendering children elements
     * @param {Map<key, UIComponent>} mappedChildren - The map of children keys
     * to UIComponent objects.  Not all children will be in the mappedChildren
     * Map, but all mappedChildren will be in children.
     * @param {Object} context - Additional rendering context.
     * @returns {*} Virtual elements that represent the view of the UIComponent.
     */
    view(el, props, children, mappedChildren, context) { // eslint-disable-line no-unused-vars
        throw new Error("UIComponent.view(): You need to override the " +
            "view() method before calling render.");
    }

    /**
     * Attaches the current component to a DOM element. Subsequent calls to
     * update() on this component or any of its children will cause this
     * element's contents to be updated automatically.
     * @param {string} elementId - Id of the element
     * @returns {UIComponent} Current instance.
     */
    mount(elementId) {
        /* istanbul ignore next */
        if (__DEV__) {
            checkMount(this.constructor.name, elementId);
        }

        this._emitter.removeAllListeners(EVENTS.REFRESH);
        this.on(EVENTS.REFRESH, (forceUpdate = false) => {
            if (!forceUpdate) {
                clearTimeout(this._timerId);
                this._timerId = setTimeout(reRender(this, elementId), 0);
            }
            else {
                reRender(this, elementId)();
            }
        });
        return this;
    }

    /**
     * Forces the DOM contents to be re-rendered. Normally the update calls
     * will be batched for performance gains. This call will override the
     * batching behavior and force the DOM to be updated. As such, it is
     * not recommended to use this function unless absolutely necessary.
     * @returns {UIComponent} Current instance.
     */
    forceUpdate() {
        this.emit(EVENTS.REFRESH, true);
        return this;
    }

    /**
     * Updates the DOM contents.
     * @returns {UIComponent} Current instance.
     */
    update() {
        this.emit(EVENTS.REFRESH);
        return this;
    }
}

UIComponent.EVENTS = EVENTS;

export default UIComponent;

window._MPAGE_FUSION_ = true; // tells the environment that mpage fusion is present
