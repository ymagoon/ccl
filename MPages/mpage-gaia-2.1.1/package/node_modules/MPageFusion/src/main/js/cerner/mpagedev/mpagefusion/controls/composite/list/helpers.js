import SubList from "./SubList";
import ListSelectGroup from "./ListSelectGroup";
import ListSelectButton from "./ListSelectButton";
import ListDivider from "./ListDivider";
import ListButton from "./ListButton";

const EVENTS = {
    SELECTION_CHANGE_EVENT: "List::Internal::SelectionChange",
    TOGGLE_EVENT: "List::Internal::Toggle",
    CLICK_EVENT: "List::Internal::Click",
    DISMISS_EVENT: "List::Internal::Dismiss"
};

const SUBLIST_ITEM = "mpageui-sublist-item";
const INLINE_LIST_ITEM = "mpageui-inlinelist-item";

/**
 * Returns the appropriate class name string for the item
 * If the item is a part of the root menu, it adds the inline list item class name.
 * If the item is a part of a nested menu, it adds the sublist item class name.
 * @param {*} item the JSON description of a content
 * @returns {String} The correct class name
 */
const getClassName = (item) => {
    const listItemClassName = item.isSublist ? SUBLIST_ITEM : INLINE_LIST_ITEM;
    return [ item.className, listItemClassName ].filter((classString) => Boolean(classString)).join(" ");
};

/**
 * Check whether the provided json will have an icon placed to its left
 * (also known as "decorated")
 * @param {Array<*>} content JSON that describes a single content
 * @returns {Boolean} whether it will be decorated or not
 */
const isDecoratedBasedOnContent = (content) =>
    content.some(
        (item) =>
            item.isSelected !== undefined ||
            item.selectGroup !== undefined ||
            item.icon !== undefined
    );

/**
 * Creates a new SubList object from a JSON content description.
 * Will return false if the content is not fit to generate a SubList.
 * @param {*} item the JSON description of a content
 * @returns {SubList | Boolean} the created sublist or false
 */
const makeSubmenu = (item) =>
    item.submenu === undefined ? false :
        new SubList({
            content: makeContent(item.submenu, { isSublist: true }), // eslint-disable-line no-use-before-define
            display: item.display,
            headerText: item.display,
            item,
            itemClassName: INLINE_LIST_ITEM,
            showDismissButton: item.showDismissButton !== undefined ? item.showDismissButton : true,
            dismissEventName: EVENTS.DISMISS_EVENT,
            isDecorated: item.isDecorated !== undefined ? item.isDecorated : isDecoratedBasedOnContent(item.submenu)
        });

/**
 * Creates a new ListSelectGroup object from a JSON content description.
 * Will return false if the content is not fit to generate a ListSelectGroup.
 * @param {*} item the JSON description of a content
 * @returns {ListSelectGroup | Boolean} the created sublist or false
 */
const makeSelectGroup = (item) =>
    item.selectGroup === undefined ? false :
        new ListSelectGroup({
            classNames: getClassName(item),
            items: item.selectGroup,
            item,
            canDeselect: item.canDeselect,
            multiSelect: item.multiSelect,
            selectionChangeEventName: EVENTS.SELECTION_CHANGE_EVENT
        });

/**
 * Creates a new ListSelectButton object from a JSON content description.
 * Will return false if the content is not fit to generate a ListSelectButton.
 * @param {*} item the JSON description of a content
 * @returns {ListSelectButton | Boolean} the created sublist or false
 */
const makeSelectButton = (item) =>
    item.isSelected === undefined ? false :
        new ListSelectButton({
            classNames: getClassName(item),
            display: item.display,
            isSelected: item.isSelected,
            disabled: item.disabled,
            item,
            selectionChangeEventName: EVENTS.TOGGLE_EVENT
        });

/**
 * Creates a new ListDivider object from a JSON content description.
 * Will return false if the content is not fit to generate a ListDivider.
 * @param {*} item the JSON description of a content
 * @returns {ListDivider | Boolean} the created sublist or false
 */
const makeDivider = (item) =>
    !item.isDivider ? false :
        new ListDivider();

/**
 * Creates a new ListButton object from a JSON content description.
 * Will return false if the content is not fit to generate a ListButton.
 * @param {*} item the JSON description of a content
 * @returns {ListButton} the created listButton
 */
const makeButton = (item) =>
    new ListButton({
        classNames: getClassName(item),
        display: item.display,
        disabled: item.disabled,
        icon: item.icon,
        item,
        clickEventName: EVENTS.CLICK_EVENT
    });

/**
 * Converts a JSON content entry into the appropriate UIComponent control
 * @param {*} item content item JSON
 * @returns {UIComponent} the equivalent control
 */
const makeListItem = (item) => (
    makeSubmenu(item) ||
    makeSelectGroup(item) ||
    makeSelectButton(item) ||
    makeDivider(item) ||
    makeButton(item)
);

/**
 * Converts an array of JSON content into an array of UIComponent controls
 * @param {Array<*>} content array of items
 * @param {Object} config object containing list configuration
 * @returns {Array<UIComponent>} the converted items
 */
const makeContent = (content, config = {}) =>
    content.map((item) => makeListItem(Object.assign(item, config)));

/**
 * Looks up an item with the provided id key in an array.
 * @param {Array<*>} items array of items
 * @param {*} id the id
 * @returns {*} the item with the id
 */
const itemById = (items, id) => items.filter((item) => item.id === id)[ 0 ];

/**
 * Converts the payload provided by the callback of the SelectGroup
 * into a list of selected items.
 * @param {*} item the JSON that describes the selectgroup
 * @param {*} payload the JSON payload that is emitted by the select group
 * @returns {Array<*>} the items that are currently selected
 */
const selectedItems = (item, payload) =>
    payload.selected.ids.map(
        (id) => item.selectGroup[ 0 ].id !== undefined ?
            itemById(item.selectGroup, id) : item.selectGroup[ id ]
    );

/**
 * Transforms an event emitted by a children into a new event withe the specified
 * name. If the source item has a "fire" attribute, another event with that name
 * will also be fired. The transformer is a function that takes in the arguments
 * of the original event and returns an array with the new arguments.
 * @param {UIComponent} control the control to listen to events
 * @param {String} oldEventName - the name of the old event
 * @param {String} eventNameProp - the name of the new event
 * @param {function} transformer - the transforming function
 * @returns {undefined} Returns nothing.
 */
const transformAndForwardEvent = (control, oldEventName, eventNameProp, transformer) =>
    control.on(oldEventName, (...args) => {
        const newArgs = transformer(...args);
        const fireEventName = args[ 0 ].getProp("item").fire;
        control.emit(control.getProp(eventNameProp), ...newArgs);
        if (fireEventName) {
            control.emit(fireEventName, ...newArgs);
        }
        control.update();
    });

/**
 * Transform and forwards the selection change event for the given control.
 * @param {UIComponent} control the control to handle events
 * @returns {undefined} Returns nothing.
 */
const handleSelectionChangeEvent = (control) => transformAndForwardEvent(
    control,
    EVENTS.SELECTION_CHANGE_EVENT,
    "selectionChangeEventName",
    (sourceControl, payload) => {
        if (!sourceControl.getProp("multiSelect") && control.getProp("isOpen") !== undefined) {
            control.setProp("isOpen", false);
        }
        return [
            control,
            selectedItems(sourceControl.getProp("item"), payload),
            payload,
            sourceControl.getProp("item")
        ];
    }
);

/**
 * Transform and forwards the toggle event for the given control.
 * @param {UIComponent} control the control to handle events
 * @returns {undefined} Returns nothing.
 */
const handleToggleEvent = (control) => transformAndForwardEvent(
    control,
    EVENTS.TOGGLE_EVENT,
    "toggleEventName",
    (sourceControl, isSelected) => [ control, sourceControl.getProp("item"), isSelected ]
);

/**
 * Transform and forwards the basic action event for the given control.
 * @param {UIComponent} control the control to handle events
 * @returns {undefined} Returns nothing.
 */
const handleBasicActionEvent = (control) => transformAndForwardEvent(
    control,
    EVENTS.CLICK_EVENT,
    "basicActionEventName",
    (sourceControl) => [ control, sourceControl.getProp("item") ]
);

/**
 * Transform and forwards the selection change event, toggle event,
 * and basic action event for the given control.
 * @param {UIComponent} control the control to handle events
 * @returns {undefined} Returns nothing.
 */
const handleEvents = (control) => {
    handleSelectionChangeEvent(control);
    handleToggleEvent(control);
    handleBasicActionEvent(control);
};

export {
    EVENTS,
    makeContent,
    handleEvents,
    isDecoratedBasedOnContent
};
