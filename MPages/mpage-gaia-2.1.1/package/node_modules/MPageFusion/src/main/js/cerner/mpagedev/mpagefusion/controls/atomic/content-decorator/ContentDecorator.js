import UIComponent from "../../../base";
import classNames from "classnames";
import { unique } from "../../../helpers/core/generators";
import { isSelectedClassName } from "../../../helpers/const/classNames";

const NAMESPACE = "mpageui-ContentDecorator";
const CLASSES = {
    root: `${NAMESPACE}`,
    centerContent: `${NAMESPACE}-center`,
    sideContent: `${NAMESPACE}-side`,
    leftSideContentPad: `${NAMESPACE}-side--left`,
    rightSideContentPad: `${NAMESPACE}-side--right`,
    centerContentPad: `${ NAMESPACE }-center--padding`,
    hover: `${NAMESPACE}--hover`,
    sideContentAlignment: `${NAMESPACE}-side--vertical-align`,
    selected: isSelectedClassName
};

/**
 * ENUM for Alignment
 * @readOnly.
 * @type { { CENTER: string, TOP: string } }.
 */
const ALIGNMENT = {
    CENTER: "center",
    TOP: "top"
};

/**
 * ENUM for Events
 * @readOnly.
 * @type { { SELECTION_CHANGE: string } }.
 */
const EVENTS = {
    SELECTION_CHANGE: "ContentDecorator::selectionChange"
};

/**
 * Generates the selection change handler for the content decorator control
 * @param {ContentDecorator} control - the content decorator control
 * @returns {undefined} undefined
 */
const generateClickHandler = (control) => (e) => {
    const isSelected = !control._state.isSelected; // eslint-disable-line no-underscore-dangle
    control.setState({ isSelected }); // eslint-disable-line no-underscore-dangle
    control.emit(control.getProp("selectionChangeEventName"), control, {
        isSelected
    });
    control.update();
};

/**
 * Small helper to determine when to replace or remove a child of the
 * ContentDecorator.
 * @param {ContentDecorator} contentDecorator - The content decorator instance.
 * @param {string} childKey - The unique child key.
 * @returns {Function} The prop change handler for the content decorator.
 */
const replaceChild = (contentDecorator, childKey) => (child) =>
    (child && child.isUIComponent) ?
        contentDecorator.replaceMappedChild(childKey, child) :
        contentDecorator.removeChild(childKey);

/**
 * The ContentDecorator class can wrap a left, center, and right content
 * to create a UX approved layout. The center content is required
 * and is recommended that either the left or right (usually not both) content
 * also be provided.
 * @class ContentDecorator
 */
export default class ContentDecorator extends UIComponent {
    /**
     * Generates the initial state of the ContentDecorator.
     * @returns {Object} The initial state of the ContentDecorator.
     */
    initialState() {
        return {
            isSelected: false
        };
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            leftContent: null,
            leftContentVerticalAlign: ALIGNMENT.CENTER,
            addLeftContentSection: false,
            leftContentMinimumWidth: "auto",
            centerContent: null,
            centerContentPadding: true,
            rightContent: null,
            rightContentVerticalAlign: ALIGNMENT.CENTER,
            isHoverable: false,
            isSelectable: false,
            isSelected: false,
            key: unique(),
            classNames: "",
            selectionChangeEventName: EVENTS.SELECTION_CHANGE
        };
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            leftContent: replaceChild(this, "leftContent"),
            rightContent: replaceChild(this, "rightContent"),
            centerContent: replaceChild(this, "centerContent"),
            isSelected: (isSelected) => {
                this.setState({ isSelected });
            }
        };
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped) {
        return el( // Wrapper div
            "div",
            {
                class: classNames({
                    [ CLASSES.root ]: true,
                    [ CLASSES.hover ]: props.isHoverable,
                    [ CLASSES.selected ]: this._state.isSelected,
                    [ props.classNames ]: props.classNames.length > 0
                }),
                key: props.key
            },
            [
                // Left
                mapped.leftContent || props.addLeftContentSection ? el(
                    "div",
                    {
                        class: classNames(`${CLASSES.sideContent}`, `${CLASSES.leftSideContentPad}`, {
                            // This should apply a conditional modifier style to vertically align the content
                            [`${CLASSES.sideContentAlignment}-${props.leftContentVerticalAlign}`]: !!props.leftContentVerticalAlign
                        }),
                        style: {
                            "min-width": props.leftContentMinimumWidth
                        }
                    },
                    mapped.leftContent ? mapped.leftContent.render() : null
                ) : null,
                // Center
                el(
                    "div",
                    {
                        class: classNames(`${CLASSES.centerContent}`, {
                            [`${CLASSES.centerContentPad}`]: !!props.centerContentPadding
                        }),
                        onclick: props.isSelectable ? generateClickHandler(this) : null
                    },
                    mapped.centerContent ? mapped.centerContent.render() : null
                ),
                // Right
                mapped.rightContent ? el(
                    "div",
                    {
                        class: classNames(`${CLASSES.sideContent}`, `${CLASSES.rightSideContentPad}`, {
                            // This should apply a conditional modifier style to vertically align the content
                            [`${CLASSES.sideContentAlignment}-${props.rightContentVerticalAlign}`]: !!props.rightContentVerticalAlign
                        })
                    },
                    mapped.rightContent.render()
                ) : null
            ]
        );
    }
}

ContentDecorator.EVENTS = EVENTS;
ContentDecorator.ALIGNMENT = ALIGNMENT;
