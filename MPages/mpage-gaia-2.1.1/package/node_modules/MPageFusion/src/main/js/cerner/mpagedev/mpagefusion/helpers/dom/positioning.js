import { asDomElement } from "./dom";

/**
 * Position enum
 * @type {{LEFT: string, RIGHT: string, TOP: string, BOTTOM: string}}
 */
export const position = {
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom"
};


/**
 * Returns the top of the element relative to the viewport.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const top = (element) =>
    asDomElement(element).getBoundingClientRect().top;

/**
 * Returns the bottom of the element relative to the viewport.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const bottom = (element) =>
    asDomElement(element).getBoundingClientRect().bottom;

/**
 * Returns the left of the element relative to the viewport.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const left = (element) =>
    asDomElement(element).getBoundingClientRect().left;

/**
 * Returns the right of the element relative to the viewport.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const right = (element) =>
    asDomElement(element).getBoundingClientRect().right;

/**
 * Returns the height of the element.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const height = (element) =>
    asDomElement(element).getBoundingClientRect().height;

/**
 * Returns the height of the element.
 *
 * @param {string | HTMLElement} element - the element
 * @returns {HTMLElement} the dom element equivalent to element
 */
export const width = (element) =>
    asDomElement(element).getBoundingClientRect().width;

/**
 * Detects if element1 is touching the top of element2.
 *
 * @param {string | HTMLElement} element1 - top element
 * @param {string | HTMLElement} element2 - bottom element
 * @returns {Boolean} whether they are touching
 */
export const areElementsTouching = (element1, element2) =>
    (bottom(element1) > top(element2));

/**
 * Transforms a top position relative to the viewport into a position
 * suitable to be used with position: absolute for the element.
 * It does the transformation by subtracting the position from the
 * viewport top of the offset parent.
 * If the offset parent is the document body it will not perform the
 * transformation, since position: absolute will position the element
 * relative to the window in that case.
 *
 * @param {number} positionTop - the position relative to the viewport
 * @param {HTMLElement} element - the element to be positioned
 * @returns {number} the absolutely positioned position
 */
export const positionRelativeToOffsetParent = (positionTop, element) =>
    (element.offsetParent === document.body) ? positionTop :
        (positionTop - top(element.offsetParent));

/**
 * Detect if the element needs to be moved on Y-axis if its getting off the screen.
 * Will return the new position if flip is needed otherwise return the original position.
 * @param {HtmlElement} element - Element to evaluate on
 * @param {position} origPos - original position
 * @param {position} [positionEnum=position] - Position enum to be used
 * @returns {position} Positions
 */
export const detectFlipPositionY = (element, origPos, positionEnum = position) => {
    const elemTop = top(element);
    const elemBottom = bottom(element);

    if (elemTop < 0 && elemBottom < window.innerHeight - elemBottom) {
        return positionEnum.BOTTOM;
    }
    else if (elemBottom > window.innerHeight && elemTop > window.innerHeight - elemTop) {
        return positionEnum.TOP;
    }

    return origPos;
};

/**
 * Detect if the element needs to be moved on X-axis if its getting off the screen.
 * Will return the new position if flip is needed otherwise return the original position.
 * @param {HtmlElement} element - Element to evaluate on
 * @param {position} origPos - original position
 * @param {position} [positionEnum=position] - Position enum to be used
 * @returns {position} Positions
 */
export const detectFlipPositionX = (element, origPos, positionEnum = position) => {
    const elemLeft = left(element);
    const elemRight = right(element);

    if (elemLeft < 0 && elemRight < window.innerWidth - elemRight) {
        return positionEnum.RIGHT;
    }
    else if (elemRight > window.innerWidth && elemLeft > window.innerWidth - elemLeft) {
        return positionEnum.LEFT;
    }

    return origPos;
};

/**
 * Returns the sum of the heights of all child elements.
 * This is sometimes needed because the height of the parent element is reported
 * incorrectly when it is absolute positioned inside a overflowed container.
 * Will only work for elements in which the children are placed vertically one after
 * the other.
 *
 * @param {HTMLElement} element - the DOM Element
 * @returns {Integer} the sum of the heights of all the child elements
 */
export const childHeight = (element) =>
    Array.from(element.children)
        .filter((child) => !child.classList.contains("mpageui-NestablePane"))
        .reduce((total, child) => total + height(child), 0);
