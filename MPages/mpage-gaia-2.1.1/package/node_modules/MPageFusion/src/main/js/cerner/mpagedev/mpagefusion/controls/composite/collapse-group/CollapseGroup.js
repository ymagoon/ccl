"use strict";

/**
 * @typedef {Object} CollapseGroupState
 * @property {String[]} selectedIds - Array of currently selected items (across all items)
 */

import UIComponent from "../../../base";
import Container from "../../atomic/container";
import Button from "../../atomic/button";
import { svg } from "../../atomic/icon";
import Menu from "../menu";
import classNames from "classnames";
import { EVENTS, MODIFIERS, NAMESPACE, TYPES } from "./const";
import { makeFaceUpItems, makeMenuItems } from "./helpers/builder";
import { addWindowResizeListener, removeWindowResizeListener } from "../../../helpers/dom/dom";

// Action
import { bindEvents as bindActionEvents } from "./helpers/action";
// Toggle
import { bindEvents as bindToggleEvents } from "./helpers/toggle";
// Select Group
import { bindEvents as bindSelectGroupEvents } from "./helpers/selectGroup";

import { sortElements, updateFaceUpItemVisibility } from "./helpers/dom";

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------
const RESIZE_TIMEOUT = 400;
const { content: { Ellipsis } } = svg;

/**
 * Small helper to handle if the new range is different than the previous range. If so,
 * the next function is called, passing in the new range.
 * @param {number} prevRange - The previous range value.
 * @param {number} newRange - The new range value.
 * @param {Function} next - The function to apply if the range has changed.
 * @returns {* | false} The return value of the next function or false.
 */
const handleRangeChange = (prevRange, newRange, next) => (prevRange !== newRange) ?
    next(newRange) : false;

/**
 * Applies a set of properties to a list of objects
 * @param {array} items - the array
 * @param {object} mappedProperties - the properties and values to map
 * @returns {Object[]} the resulting array
 */
const applyMappedProperties = (items, mappedProperties) =>
    items.map((item) => Object.assign({}, item, mappedProperties));

/**
 * Given the list of items as props, this runs through the items to generate an initial state
 * by extracting the ids of selected items. This will recursively traverse down nested
 * items since the collapse-group supports items with children (select groups, menus, and sub-menus).
 * @param {Object[]} items - List of collapse group items.
 * @returns {String[]} Array of selected ids.
 */
const extractStateFromItems = (items = []) => items.reduce((acc, next) => {
    const toAdd = (next.isSelected) ? [ next.id ] : [];

    // Sub menu within menu
    const subMenus = next.submenu ? extractStateFromItems(next.submenu) : [];

    // Select group within menu
    const selectGroup = next.selectGroup ? extractStateFromItems(next.selectGroup) : [];

    // Menu content
    const menuContent = next.content ? extractStateFromItems(next.content) : [];

    // Select Group
    const itemContent = next.items ? extractStateFromItems(next.items) : [];

    return [
        ...acc,
        ...toAdd,
        ...subMenus,
        ...selectGroup,
        ...menuContent,
        ...itemContent
    ];
}, []);

/**
 * The CollapseGroup class. This UIComponent shows a list of items (items) horizontally and face-up as room allows. As
 * the space available is diminished, the "items" are consumed into the Dropdown. When this occurs, a different
 * visual representation for the items is created and displayed in the dropdown. The state of the face-up control
 * and the drop-down representations are synchronized in this control as well.
 * @class CollapseGroup
 */
class CollapseGroup extends UIComponent {
    /**
     * @inheritDoc
     */
    constructor(props, children) {
        super(props, children);
        this._range = 0;
        this._reset = false;
        this._handleWindowResize = this._handleWindowResize.bind(this);
    }

    /**
     * Initial state for CollapseGroup
     * @returns {CollapseGroupState} Initial state
     */
    initialState() {
        return {
            selectedIds: []
        };
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            buttonSize: "",
            classNames: "",
            items: []
        };
    }

    /**
     * @inheritDoc
     */
    createChildren() {
        return [
            {
                itemContainer: new Container()
            },
            {
                dropdown: new Button({
                    clickEventName: EVENTS.DROPDOWN_CLICK,
                    size: this.getProp("buttonSize"),
                    icon: new Ellipsis()
                })
            },
            {
                menu: new Menu({
                    showHeader: false,
                    basicActionEventName: EVENTS.MENU_ACTION,
                    classNames: classNames(`${NAMESPACE}-menu`),
                    selectionChangeEventName: EVENTS.MENU_SELECTION_CHANGE,
                    toggleEventName: EVENTS.MENU_TOGGLE
                })
            }
        ];
    }

    /**
     * Handles the resize event, simply updates the control.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleWindowResize() {
        // Delay the timeout to account for possible animations that have not yet finished.
        setTimeout(() => {
            this.update();
        }, RESIZE_TIMEOUT);
    }

    /**
     * Places the items appropriately face-up. If there is not enough room, the face-up representation of the item
     * will be hidden.
     * @param {HTMLElement} dom - Dom element for the group
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleGroupDisplay({ dom }) {
        handleRangeChange(
            this._range,
            updateFaceUpItemVisibility(dom, sortElements(Array.from(dom.children))),
            (nextRange) => {
                this._range = nextRange;
                this._resetItems(this._state); // eslint-disable-line no-underscore-dangle
                this.update();
            }
        );
    }

    /**
     * From the items props, re-creates the face-up and menu items.
     * @param {CollapseGroupState} nextState - The next state.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _resetItems(nextState) {
        const items = applyMappedProperties(this.getProp("items"), {
            size: this.getProp("buttonSize")
        });

        // Face Up
        this.getChild("itemContainer")
            .replaceAllChildren(
                makeFaceUpItems(items, nextState)
            );

        // Menu
        this.getChild("menu")
            .setProp(
                "content",
                makeMenuItems(items, this._range, nextState)
            );
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        this._range = this.getProp("items").length;
        bindActionEvents(this);
        bindToggleEvents(this);
        bindSelectGroupEvents(this);

        // Set up the anchor control
        this.getChild("menu").setProp("anchorControl", this.getChild("dropdown"));
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return Object.assign({},
            {
                items: (items) => {
                    /*
                     * When the consumer changes the items on the collapse-group, the
                     * selected state is re-calculated.
                     */
                    this.setState({
                        selectedIds: extractStateFromItems(items)
                    });
                    this._reset = true;
                }
            },
            {
                buttonSize: (size) => {
                    this.getChild("dropdown").setProp("size", size);
                    this.reset = true;
                }
            }
        );
    }

    /**
     * Handle synchronizing state before render.
     * @param {CollapseGroupState} nextState - Incoming state
     * @returns {undefined} Returns nothing.
     */
    beforeRender({ nextState }) {
        if (!this._reset) {
            return;
        }

        this._resetItems(nextState);
        this._reset = false;
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped) {
        return el(
            "div",
            {
                class: classNames(NAMESPACE, {
                    [ props.classNames ]: (props.classNames !== "")
                }),
                oncreate: (vnode) => {
                    addWindowResizeListener(this._handleWindowResize);
                    this._handleGroupDisplay(vnode);
                },
                onupdate: (vnode) => {
                    this._handleGroupDisplay(vnode);
                },
                onremove: () => removeWindowResizeListener(this._handleWindowResize)
            },
            [
                // Face-up items
                mapped.itemContainer.getChildren().map(
                    (c, i) => el(
                        "div",
                        {
                            class: classNames(
                                `${NAMESPACE}-item`
                            ),
                            "aria-hidden": (i > (this._range - 1))
                        },
                        c.render()
                    )
                ),
                // Dropdown
                el(
                    "div",
                    {
                        class: classNames(
                            "mpageui-CollapseGroup-item",
                            "mpageui-CollapseGroup-more"
                        ),
                        "aria-hidden": (this._range >= props.items.length)
                    },
                    [
                        mapped.menu.render()
                    ]
                )
            ]
        );
    }
}

CollapseGroup.TYPES = TYPES;
CollapseGroup.MODIFIERS = MODIFIERS;

export default CollapseGroup;
