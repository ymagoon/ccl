"use strict";

import UIComponent from "../../../base/UIComponent";
import {
    objectMap,
    objectFilter,
    unselectAllItems,
    fireItemEvent,
    getSelected
} from "../../../helpers/core/object";
import { setProp } from "../../../helpers/props/props";
import { isNotNullOrUndefined } from "../../../helpers/core/typeChecks";
import classNames from "classnames";
import ButtonGroup from "../select-group/ButtonGroup";
import Popup from "../popup";
import Button from "../../atomic/button";
import ExpandMore from "../../atomic/icon/svg/category/navigation/ExpandMore";
import Menu from "../menu";

const buttonGroupSelectionChange = "ButtonGroup::selectionChange";
const dropDownMenuSelectionChange = "DropDownMenu::selectionChange";

/**
 * Finds the first item with the provided id.
 *
 * @param {*} id the id value
 * @param {Array<*>} items array of items
 * @returns {*} the first item that matches the id
 */
const itemById = (id, items) =>
    items.filter((item) => item.id === id)[ 0 ];

/**
 * Assigns a sequencial number to the items if there is nothing set in the ID
 * field.
 *
 * @param {*} items any object with an id field
 * @returns {*} the items
 */
const makeItemIds = (items) =>
    items.map((item, i) =>
        item.id !== undefined && item.id !== null
            ? item
            : setProp("id", i, item));

/**
 * Returns the class to be applied to the dropdown to correctly hide
 * and show it depending on the screen size.
 *
 * @param {Array<*>} items list of items
 * @param {*} itemsPerScreenSize mapping of screen size to number of items
 * @returns {String} class to be applied to dropdown
 */
const dropDownClass = (items, itemsPerScreenSize) => classNames({
    "mpageui-u-hide-for-xl-only": items.length <= itemsPerScreenSize.extraLarge,
    "mpageui-u-hide-for-lg-only": items.length <= itemsPerScreenSize.large,
    "mpageui-u-hide-for-md-only": items.length <= itemsPerScreenSize.medium,
    "mpageui-u-hide-for-sm-only": items.length <= itemsPerScreenSize.small,
    "mpageui-u-hide-for-xs-only": items.length <= itemsPerScreenSize.extraSmall
});


/**
 * Appends the specified item to each entry in screenSizes
 *
 * @param {*} item an item
 * @param {*} screenSizes map of screen sizes to item arrays
 * @returns {*} the modified screenSizes map
 */
const appendItem = (item, screenSizes) =>
    objectMap(screenSizes,
        (items) => items.concat(item));

/**
 * Removes an item from the end of each entry in screenSizes
 *
 * @param {*} screenSizes map of screen sizes to item arrays
 * @returns {*} the modified screenSizes map
 */
const removeLastItems = (screenSizes) =>
    objectMap(screenSizes,
        (items) => items.slice(0, -1));

/**
 * Returns only screen sizes where none of the items have isSelected set to
 * true.
 *
 * @param {*} screenSizes map of screen sizes to item arrays
 * @returns {*} the modified screenSizes map
 */
const onlyUnselectedScreenSizes = (screenSizes) =>
    objectFilter(screenSizes,
        (items) => items.every((item) => !item.isSelected));

/**
 * Returns only screen sizes where at least one item has isSelected set to
 * true.
 *
 * @param {*} screenSizes map of screen sizes to item arrays
 * @returns {*} the modified screenSizes map
 */
const onlySelectedScreenSizes = (screenSizes) =>
    objectFilter(screenSizes,
        (items) => items.some((item) => item.isSelected));

/**
 * Converts a mapping of screen sizes to the ammount of items into
 * a mapping of screen sizes to an array of the items that belong into
 * each size. Items will be allocated into the sizes in sequential order.
 *
 * @param {Array<*>} items list of items to be distributed
 * @param {*} itemsCountPerScreenSize mapping of screen sizes to item count
 * @returns {*} map of screen sizes to array of items
 */
const separateItemsIntoScreenSizes = (items, itemsCountPerScreenSize) =>
    objectMap(itemsCountPerScreenSize,
        (quantity, key) => items.slice(0, quantity));

/**
 * Adjusts the items in the screenSizes mappings so that the selected item
 * is present in all screen sizes while at the same time preserving the ammount
 * of items that can be displayed in each breakpoint.
 *
 * @param {*} selectedItem currently selected item
 * @param {Array<*>} items list of all items
 * @param {*} screenSizes adjusted screen size mappings
 * @returns {*} the adjusted screensize mappings
 */
const calculateItemsPerScreenSizeWithSelection = (selectedItem, items, screenSizes) =>
    Object.assign(
        appendItem(selectedItem,
            removeLastItems(
                onlyUnselectedScreenSizes(screenSizes))),
        onlySelectedScreenSizes(screenSizes));

/**
 * Separates the item into screensizes, where each screensize key has the items to be rendered
 * at that breakpoint.
 * @param {*} selectedItem currently selected item
 * @param {Array<*>} items list of all items
 * @param {*} itemsCountPerScreenSize mappings of how many items per screensize
 * @returns {*} items per screen sizes
 */
const calculateMappedItemsPerScreenSize = (selectedItem, items, itemsCountPerScreenSize) =>
    !selectedItem || !selectedItem.length ? (
        separateItemsIntoScreenSizes(items, itemsCountPerScreenSize)
    ) : (
        calculateItemsPerScreenSizeWithSelection(
            selectedItem,
            items,
            separateItemsIntoScreenSizes(items, itemsCountPerScreenSize))
    );

/**
 * Generates the JSON for the popup menu items that will be used in a PopupList.
 *
 * @param {Array<*>} items Array of objects
 * @param {*} itemsPerScreenSize JSON structure that contains an item array
 *                               per screen size
 * @returns {*} JSON structure for the popup items
 */
const makePopupItems = (items, itemsPerScreenSize) =>
    items.map((item, i) => ({
        item,
        display: item.display,
        isSelected: !!item.isSelected,
        classNames: item.isSelected ? (
            "hide"
        ) : (
            classNames({
                "mpageui-u-hide-for-xl-only": itemsPerScreenSize.extraLarge.indexOf(item) !== -1,
                "mpageui-u-hide-for-lg-only": itemsPerScreenSize.large.indexOf(item) !== -1,
                "mpageui-u-hide-for-md-only": itemsPerScreenSize.medium.indexOf(item) !== -1,
                "mpageui-u-hide-for-sm-only": itemsPerScreenSize.small.indexOf(item) !== -1,
                "mpageui-u-hide-for-xs-only": itemsPerScreenSize.extraSmall.indexOf(item) !== -1
            })
        )
    } ));

/**
 * Generates the JSON for each button in the button group.
 *
 * @param {String} buttonType the button type, as per the Button class
 * @param {Array<*>} items the items to be rendered
 * @param {*} itemsPerScreenSize mapping of items per screen size
 * @returns {*} JSON to be used in the button group
 */
const makeButtonsJson = (buttonType, items, itemsPerScreenSize) =>
    items.map((item, i) => ({
        id: item.id,
        item,
        display: item.display,
        type: buttonType,
        isSelected: item.isSelected,
        classNames: item.isSelected ? (
            ""
        ) : (
            classNames({
                "mpageui-u-hide-for-xl-only": itemsPerScreenSize.extraLarge.indexOf(item) === -1,
                "mpageui-u-hide-for-lg-only": itemsPerScreenSize.large.indexOf(item) === -1,
                "mpageui-u-hide-for-md-only": itemsPerScreenSize.medium.indexOf(item) === -1,
                "mpageui-u-hide-for-sm-only": itemsPerScreenSize.small.indexOf(item) === -1,
                "mpageui-u-hide-for-xs-only": itemsPerScreenSize.extraSmall.indexOf(item) === -1
            }))
    }));

/**
 * Creates the main button group and the popup list with the items that do not fit
 * in the group.
 *
 * @param {String} title title of the dropdown popup list
 * @param {String} buttonType type of button
 * @param {Array<*>} items list of items
 * @param {*} itemsPerScreenSize mapping of screen size to number of items
 * @param {*} mappedItemsPerScreenSize mapping of screen size to list of items
 * @returns {Array<UIComponent>} children for responsive button group
 */
const makeChildren = (title, buttonType, items, itemsPerScreenSize, mappedItemsPerScreenSize) => [
    new ButtonGroup({
        canDeselect: false,
        items: makeButtonsJson(buttonType,
            items,
            mappedItemsPerScreenSize),
        selectionChangeEventName: buttonGroupSelectionChange
    }),
    new Menu({
        size: Popup.SIZE.SMALL,
        title,
        showHeader: false,
        autoInsertDividers: false,
        content: makePopupItems(items, mappedItemsPerScreenSize),
        toggleEventName: dropDownMenuSelectionChange,
        anchorControl: new Button({
            icon: new ExpandMore(),
            classNames: `mpageui-ResponsiveButtonGroup-dropDownButton ${dropDownClass(items, itemsPerScreenSize)}`
        })
    }) ];

/**
 * Fired when a single button is clicked. Will unselect all the other buttons
 * and emit the events related to selecting the item specified.
 *
 * @param {ResponsiveButtonGroup} control where the selection took place
 * @param {*} item item that was selected
 * @returns {undefined}
 */
const selectItem = (control, item) => {
    unselectAllItems(control.getProp("items"));
    item.isSelected = true;
    control.replaceAllChildren(control.createChildren());
    control.emit(control.getProp("itemSelectEventName"), item);
    if (isNotNullOrUndefined(item.fire) && item.fire !== "") {
        fireItemEvent(item, control);
    }
    control.update();
};

export default class ResponsiveButtonGroup extends UIComponent {
    constructor(props, children) {
        super(props, children);
    }

    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            itemsPerScreenSize: {
                extraLarge: 10,
                large: 7,
                medium: 5,
                small: 3,
                extraSmall: 0
            },
            buttonType: "",
            defaultClassNames: "mpageui-ResponsiveButtonGroup",
            classNames: "",
            items: [],
            title: "",
            itemSelectEventName: "ResponsiveButtonGroup::itemSelect"
        };
    }

    /**
     * @inheritdoc
     */
    createChildren() {
        this.setProp("items", makeItemIds(this.getProp("items")));
        return makeChildren(this.getProp("title"),
            this.getProp("buttonType"),
            this.getProp("items"),
            this.getProp("itemsPerScreenSize"),
            calculateMappedItemsPerScreenSize(
                getSelected(this.getProp("items")),
                this.getProp("items"),
                this.getProp("itemsPerScreenSize")
            ));
    }

    /**
     * @inheritdoc
     */
    afterCreate() {
        this.on(buttonGroupSelectionChange, (obj, selectionState) =>
            selectItem(this, itemById(
                selectionState.selected.ids[ 0 ], this.getProp("items"))));
        this.on(dropDownMenuSelectionChange, (source, listItem) =>
            selectItem(this, listItem.item));
    }

    /**
     * @inheritdoc
     */
    propChangeHandlers() {
        return {
            items: (items) =>
                this.replaceAllChildren(this.createChildren())
        };
    }

    /**
     * @inheritdoc
     */
    view(el, props) {
        return el("div", {
            class: classNames({
                [props.defaultClassNames]: true,
                [props.classNames]: props.classNames.length > 0
            })
        }, this.renderChildren());
    }
}
