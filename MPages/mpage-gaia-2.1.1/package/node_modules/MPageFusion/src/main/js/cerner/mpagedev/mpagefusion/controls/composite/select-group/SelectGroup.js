"use strict";

import UIComponent from "../../../base";
import MultiItemSelector from "../../../behaviors/MultiItemSelector";
import classNames from "classnames";

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------
const SelectGroupEvents = {
    SELECTION_CHANGE: "SelectGroup::selectionChange"
};

/**
 * Builds the payload object to be emitted upon a selection
 * @param {Array} netSelections - the list of selected items
 * @param {Array} selections - the newly selected items
 * @param {Array} deselections - the newly deselected items
 * @returns {{selected: {ids: Array}, changed: {selections: Array, deselections: Array}}}
 */

const generateSelectEventPayload = (netSelections = [], selections = [], deselections = []) => ({
    selected: {
        ids: netSelections
    },
    changed: {
        selections,
        deselections
    }
});

/**
 * Combine the explicitly set properties and the default properties
 * into a single list of prop objects. Explicitly set props take precedence
 * over default props
 * @param {Array} explicitPropsList - the explicitly defined properties
 * @param {Array} selectedItems - a list of currently selected items
 * @returns {Array} - array of prop objects
 */
const resolveItemProps = (explicitPropsList = [], selectedItems = []) => explicitPropsList.map((explicitProps, i) => Object.assign({
    // the default properties
    id: String(i), // the index of the item is used if an id is not provided
    isSelected: selectedItems.includes(explicitProps.id || String(i)),
    selectionChangeEventName: "itemSelectionChange"
}, explicitProps));

/**
 * Generates an array of selectable UIComponent objects using an array of
 * JSON prop objects and a generator function
 * @param {Array} itemPropsList - array of prop objects
 * @param {function} generator - function that returns a selectable ui
 *      component when passed a prop object
 * @returns {Array<UIComponent>} - array of selectable ui components
 */
const generateSelectItems = (itemPropsList = [], generator) => itemPropsList.map((itemProps) => generator(itemProps));

/**
 * Deselects all items in the selector. A list of items to select after resetting
 * can optionally be passed.
 * @param {MultiItemSelector} selector - the selector object
 * @param {Array} [items=[]] - items to select after resetting the selector
 * @returns {undefined} - undefined
 */
const resetSelector = (selector, items = []) => {
    selector.deselectAll();
    items.forEach((item) => {
        selector.selectItem(item);
    });
};

/**
 * Sets the isSelected prop to true for an array of children if the id
 * of the child is contained within selectedIds
 * @param {Array<UIComponent>} children - the children items
 * @param {Array} selectedIds - the ids of the currently selected children
 * @returns {undefined}
 */
const setChildrenSelected = (children = [], selectedIds = []) => {
    children.forEach((child) => {
        child.setProp("isSelected", selectedIds.includes(child.getProp("id")));
    });
};

/**
 * Returns an array of json objects each of which has its index
 * in the array assigned to the property "id" if it wasn't already set
 * @param {Array} items - an array of json objects
 * @returns {Array} - array of prop objects
 */
const assignIds = (items = []) => items.map((item, i) => Object.assign({
    id: String(i)
}, item));

/**
 * Returns true if any json object in the array has a particular property,
 * otherwise returns false
 * @param {Array} items - a list of objects
 * @param {String} prop - an object property
 * @returns {Boolean} - boolean
 */
const anyItemContainsProp = (items = [], prop = "") => items.some((item) => item.hasOwnProperty(prop));

/**
 * The SelectGroup interface.
 * @interface SelectGroup
 */
export default class SelectGroup extends UIComponent {

    constructor(props, children) {
        super(props, children);
        this._itemGenerator = () => {};
        this._selector = new MultiItemSelector();
        this._selector.setUniqueIdGenerator(
            (item) => item.id !== undefined && item.id !== null ? item.id : item.getProp("id"));
        this._runRefreshItems = false;
        this._items = [];
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            canDeselect: true,
            classNames: "",
            defaultClassNames: "",
            items: [],
            selectionChangeEventName: SelectGroupEvents.SELECTION_CHANGE,
            multiSelect: false,
            itemGenerator: null
        };
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            items: () => { this._runRefreshItems = true; },
            multiSelect: () => { this._runRefreshItems = true; },
            canDeselect: () => { this._runRefreshItems = true; }
        };
    }


    /**
     * @inheritDoc
     */
    _createChildItems() {
        const selectItems = generateSelectItems(this._items, this.getProp("itemGenerator"));
        return selectItems.map((item) => ({
            [item.getProp("id")]: item
        }));
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        this.on("itemSelectionChange", (item) => this._handleItemSelectionChange(item));
    }

    /**
     * @inheritDoc
     */
    beforeRender() {
        if (this._runRefreshItems) {
            this._refreshItems();
            this._runRefreshItems = false;
        }
    }

    /**
     * Handles the selection of an item.
     * @param {object} item - the selected item.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleItemSelectionChange(item) {
        this.stopPropagation(item.getProp("selectionChangeEventName"));

        // get selected items and set children accordingly
        const { selections: netSelections, selected, deselected } = this._selector.toggleItem(item);
        setChildrenSelected(this.getChildren(), netSelections);

        // construct select event payload
        const payload = generateSelectEventPayload(netSelections, selected, deselected);

        this.emit(this.getProp("selectionChangeEventName"), this, payload);
        this.update();
    }

    /**
     * Rebuilds the children based on the items prop.
     * @returns {undefined}
     * @private
     */
    _refreshItems() {
        const items = this.getProp("items");

        this._selector.setMultiSelectEnabled(this.getProp("multiSelect"));
        this._selector.setDeselectEnabled(this.getProp("canDeselect"));

        /**
         * If any items have the isSelected prop, clear the selector and populate it
         * with those that are selected
         */
        if (anyItemContainsProp(items, "isSelected")) {
            resetSelector(this._selector, assignIds(items).filter((item) => item.isSelected));
        }

        this._items = resolveItemProps(items, this._selector.getSelectedItemIds());

        this.replaceAllChildren(this._createChildItems());
    }

    /**
     * @inheritDoc
     */
    view(el, props, children) {
        return el(
            "div",
            {
                class: classNames({
                    [ props.defaultClassNames ]: true,
                    [ props.classNames ]: (props.classNames !== "")
                })
            },
            this.renderChildren()
        );
    }
}

SelectGroup.EVENTS = SelectGroupEvents;
