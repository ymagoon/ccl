"use strict";
import UIComponent from "../../../base";
import classNames from "classnames";
import { focusElement } from "../../../helpers/dom/dom";
import { isIE } from "../../../helpers/core/compatibility";

const TextBoxEvents = {
    INPUT: "TextBox::input",
    KEY_DOWN: "TextBox::keyDown",
    KEY_UP: "TextBox::keyUp",
    BLUR: "TextBox::blur",
    FOCUS: "TextBox::focus"
};
const MAX_LEN = 524288;

/**
 * Handles the oninput event.
 * @param {TextBox} control - the textbox control
 * @returns {function} Returns input handler.
 * @private
 */
const generateInputHandler = (control) => (e) => {
    const payload = e.target.value;
    const textBox = e.target;

    /**
     * IE fires an input event after the focus event
     * when input is empty and placeholder exists
     */
    if (isIE() && e && e.type === "input" && !textBox.value && textBox.value === control._state.value && textBox.placeholder) { // eslint-disable-line no-underscore-dangle
        return;
    }

    control._state.value = payload; // eslint-disable-line no-underscore-dangle
    control.emit(control.getProp("inputEventName"), control, payload);
};

/**
 * Handles the onkeydown event. Event is triggered only when the props is populated
 * @param {TextBox} control - the textbox control
 * @returns {function} Returns keydown handler.
 * @private
 */
const generateKeyDownHandler = (control) => (e) => {
    control.emit(control.getProp("keyDownEventName"), e);
};

/**
 * Handles the blur event
 * @param {TextBox} control - the textbox control
 * @returns {function} Returns blur handler.
 * @private
 */
const generateBlurHandler = (control) => (e) => {
    control.emit(control.getProp("blurEventName"), e);
};

/**
 * Handles the focus event.
 * @param {TextBox} control - the textbox control
 * @returns {function} Returns focus handler.
 * @private
 */
const generateFocusHandler = (control) => (e) => {
    control.emit(control.getProp("focusEventName"), e);
};

/**
 * Creates necessary aria attributes.
 * @param {Object} props - TextBox props
 * @returns {Object} The set of aria attributes for the TextBox.
 */
const ariaAttributes = (props) =>
    Object.assign(
        {},
        props.placeholder ? { "aria-label": props.placeholder } : null,
        props.name ? { "name": props.name } : null
    );

/**
 * Creates the readonly attribute if needed
 * @param {Boolean} isReadOnly - whether the textbox is readonly
 * @returns {Object} an object with readonly set to true or an empty object
 */
const readonly = (isReadOnly) => isReadOnly ? { readonly: true } : {};

/**
 * Saves the HTMLElement so that it can be used to perform operations on the
 * DOM of the input text box, such as focusing
 * @param {Object <UIComponent>} control - TextBox instance
 * @returns {undefined} Returns nothing.
 */
const setFocus = (control) => ({ dom }) => {
    if (control.getProp("hasFocus")) {
        focusElement(dom); // eslint-disable-line no-underscore-dangle
    }
};

/**
 * The TextBox class.
 * @class TextBox
 */
class TextBox extends UIComponent {
    constructor(props, children) {
        super(props, children);
        this._state = {
            value: ""
        };
    }

    /**
     * Focuses on the HTMLElement text box
     * @deprecated use hasFocus prop instead
     * @returns {undefined} Returns nothing.
     */
    focus() {
        this.setProp("hasFocus", true);
        this.update();
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            blurEventName: TextBoxEvents.BLUR,
            classNames: "",
            defaultClassNames: "mpageui-TextBox",
            focusEventName: TextBoxEvents.FOCUS,
            hasFocus: false,
            inputType: "text",
            inputEventName: TextBoxEvents.INPUT,
            isDisabled: false,
            isReadOnly: false,
            keyDownEventName: null,
            keyUpEventName: null,
            maxLength: null,
            name: "",
            placeholder: "",
            value: ""
        };
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            value: (newValue = "") => {
                this._state.value = newValue;
            }
        };
    }

    /**
     * @inheritDoc
     */
    view(el, props, children) {
        return el("input",
            Object.assign({
                type: props.inputType,
                maxlength: typeof props.maxLength === "number" ? props.maxLength : MAX_LEN,
                disabled: props.isDisabled,
                placeholder: props.placeholder,
                value: this._state.value,
                class: classNames({
                    [ props.defaultClassNames ]: true,
                    [ props.classNames ]: (props.classNames !== "")
                }),
                oninput: generateInputHandler(this),
                onkeydown: props.keyDownEventName ? generateKeyDownHandler(this) : "",
                onkeyup: props.keyUpEventName ? (e) => {
                    this.emit(props.keyUpEventName, e);
                } : undefined,
                onblur: generateBlurHandler(this),
                onfocus: generateFocusHandler(this),
                oncreate: setFocus(this),
                onupdate: setFocus(this)
            }, ariaAttributes(props), readonly(props.isReadOnly)),
            []
        );
    }
}

/**
 * Events ENUM
 * @type {{INPUT: string}}
 */
TextBox.EVENTS = TextBoxEvents;
export default TextBox;
