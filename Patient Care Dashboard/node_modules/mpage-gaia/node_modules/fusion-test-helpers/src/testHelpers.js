/* global UIComponent */
/* eslint "no-restricted-imports": 0 */

"use strict";

/**
 * TVDom
 * @typedef {Object} TVDom
 */

/**
 * TVDomArray
 * @typedef {Object} TVDomArray
 */

/**
 * VDom
 * @typedef {Object} VDom
 */
import mq from "mithril-query";
import { assert } from "chai";

/**
 * Performs an assertion that the function provided is truthy.
 * @param {function} f - The function to check.
 * @param {string} [msg] - The testing output message.
 * @returns {undefined} Returns nothing.
 */
export const ok = (f, msg) => assert.isOk(f(), msg);

/**
 * Performs an assertion that the function provided is falsy.
 * @param {function} f - The function to check.
 * @param {string} [msg] - The testing output message.
 * @returns {undefined} Returns nothing.
 */
export const notOk = (f, msg) => assert.isNotOk(f(), msg);

/**
 * Generates a unique id for mpageui components
 * @returns {string} unique id
 * @private
 */
function* idMaker() {
    let cnt = 0;

    while (true) { // eslint-disable-line no-constant-condition
        yield `unique-key-${++cnt}`;
    }
}

export const uniqueKey = idMaker();

/**
 * A function to validate that a value is an actual VDOM object and not null or undefined
 * @param {object} checkVal The value which is being checked
 */
//TODO: Update the name of this function to something more appropriate
export const isVDOMObject = (checkVal) => {
    return typeof checkVal !== "undefined" && checkVal !== null;
};

const canContainChildNodes = (vdom) => {
    return typeof vdom.children !== "string"
        && typeof vdom.children !== "boolean"
        && typeof vdom.children !== "number"
        && vdom.children;
};

/**
 * This check simply sees if the checkVal is an array
 * @param checkVal The value to check for Arrayness
 * @returns {boolean} True if the value is an array, false otherwise
 */
const isChildArray = (checkVal) => Array.isArray(checkVal);

/**
 * A helper function that wraps an array of TVDom in an object with various
 * helper functions for testing purposes.
 * @param {Array<TVDom>} arr - An array of TVDom objects.
 * @returns {TVDomArray} Several TVDom objects wrapped in a helper for managing
 * an array of TVDom.
 */
const fusionDomArray = (arr) => {
    return {
        /**
         * Returns the count of the array of TVDom objects.
         * @returns {number} The length of the array of TVDom.
         */
        count: () => arr.length,
        /**
         * Returns the first TVDom in the array.
         * @returns {TVDom} Test virtual dom.
         */
        first: () => arr[ 0 ],
        /**
         * Returns the last TVDom in the array.
         * @returns {TVDom} Test virtual dom.
         */
        last: () => arr[ Math.max(0, arr.length - 1) ],
        /**
         * Returns TVDom at the specified index. Bounds are clamped to the array.
         * @param {number} index - The index to retrieve.
         * @returns {TVDom} Test virtual dom.
         */
        get: (index) => arr[ Math.min(arr.length - 1, Math.max(index, 0)) ],
        /**
         * Returns the full array.
         * @returns {Array<TVDom>} The array of test virtual dom.
         */
        all: () => arr
    };
};

/**
 * A helper function that wraps virtual dom of a rendered UIComponent with
 * various helper functions for testing purposes.
 * @param {Object} vdom - The virtual dom rendered by a UIComponent.
 * @returns {TVDom} The test virtual dom of a rendered UIComponent.
 */
export const fusionDom = (vdom) => {
    const isVDOM = isVDOMObject(vdom);

    return {
        /**
         * Returns the HTML tag name from the virtual DOM.
         * @returns {string} The HTML tag name.
         */
        tag: () => isVDOM && vdom.tag ? vdom.tag : "",
        /**
         * Returns the HTML tag name from the virtual DOM.
         * @returns {string} The HTML tag name.
         */
        text: () => isVDOM ? vdom.text : undefined,
        /**
         * Returns the set of attributes from the virtual dom.
         * @returns {Object} The set of attributes on the virtual dom.
         */
        attrs: () => isVDOM && vdom.attrs ? vdom.attrs : {},
        /**
         * Returns an attribute from the virtual dom if present.
         * @param {string} name - The attribute name.
         * @returns {* | null} The attribute value or null.
         */
        getAttr: (name) => isVDOM && vdom.attrs ? vdom.attrs[ name ] : undefined,
        /**
         * Retrieves parent of this node.
         *   BEWARE: This function only works on values that have been returned from the 'find',
         *   'findByAttribute' and 'at'
         * @returns {TVDom} Parent node
         */
        parent: () => isVDOM && vdom.parent ? fusionDom(vdom.parent): undefined,
        /**
         * Retrieves direct children virtual elements and wraps in an array
         * for testing purposes.
         * @returns {Array<TVDom>} Array of test virtual dom.
         */
        children: () => {
            if (isVDOM) {
                if (canContainChildNodes(vdom)) {
                    return fusionDomArray(vdom.children.map((result) => fusionDom(result)));
                }
                else if (isChildArray(vdom)) {
                    return fusionDomArray(vdom);
                }
            }
            return fusionDomArray([]);

        },
        /**
         * Finds all elements that match the selector and wraps in an array for
         * testing purposes.
         * @param {string} selector - The selector query.
         * @returns {Array<TVDom>} Array of test virtual dom that matched the
         * selector.
         */
        find: (selector) => {
            if (isVDOM) {
                const foundElements = mq(vdom).find(`${selector}`);
                const mappedElements = foundElements.map((result) => fusionDom(result));
                return fusionDomArray(mappedElements || []);
            }
            return fusionDomArray([]);
        },
        /**
         * Finds all elements where the attribute matches the specified value.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @returns {Array<TVDom>} elements that have the attribute
         */
        findByAttribute: (attribute, value) => {
            if (isVDOM && canContainChildNodes(vdom)) {
                const foundElements = mq(vdom).find(`[${attribute}=${value}]`);
                const mappedElements = foundElements.map((result) => fusionDom(result));
                return fusionDomArray(mappedElements);
            }
            return fusionDomArray([]);
        },
        /**
         * Recursively checks the children for an attribute with the specified value.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @returns {boolean} whether the attribute was found or not
         */
        hasAttributeInChildren: (attribute, value) => {
            return (fusionDom(vdom).findByAttribute(attribute, value).count() !== 0)
        },
        /**
         * Recursively checks the children for an attribute with the specified value and
         * performs an assertion.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @param {string} [message] - Optional message to log upon failure.
         * @returns {undefined} nothing
         */
        verifyHasAttributeInChildren: (attribute, value, message) =>
            ok(() => fusionDom(vdom).hasAttributeInChildren(attribute, value), message),
        /**
         * Recursively checks the children for the absence of an attribute with the specified value
         * and performs an assertion.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @param {string} [message] - Optional message to log upon failure.
         * @returns {undefined} nothing
         */
        verifyDoesNotHaveAttributeInChildren: (attribute, value, message) =>
            notOk(() => fusionDom(vdom).hasAttributeInChildren(attribute, value), message),
        /**
         * Checks if the current virtual element has the specified CSS class name.
         * @param {string} className - The CSS class name to check for.
         * @returns {boolean} True if the virtual dom has the specified css className.
         */
        hasClass: (className) => {
            if(!isVDOM || !vdom.attrs){
                return false;
            }

            //earlier versions of mithril keep the 'class' attribute in place.
            if(vdom.attrs.class){
                return vdom.attrs.class.indexOf(className) > -1
            }
            else{
                return !!vdom.attrs.className && vdom.attrs.className.indexOf(className) > -1;
            }
        },
        /**
         * Returns the virtual dom wrapped in the call to mithril-query. It is not
         * recommended to use.
         * @returns {Object} The virtual dom wrapped in mithril-query.
         */
        el: () => isVDOM ? mq(vdom) : null,
        /**
         * Finds the provided selector in the virtual dom.
         * @param {string} selector - The selector to find virtual elements.
         * @returns {TVDom} The found virtual elements wrapped in the TVDom
         * helper.
         */
        at: (selector) => isVDOM ? fusionDom(mq(vdom).find(selector)[ 0 ]) : fusionDom([]),
        /**
         * Checks if the virtual dom contains the provided string. Useful for
         * searching for text within the virtual dom.
         *   NOTE: mithril-query currently has issues when using the contains functions that
         *   does not match to a result.  https://github.com/StephanHoyer/mithril-query/issues/74
         * @param {string} str - The string to search for.
         * @returns {boolean} True if the virtual dom contains the provided string,
         * otherwise false.
         */
        /*
        Once mithril-query issue 74 is addressed this version of the function can be utilized
        rather than the safety check version directly below
        contains: (str) => isVDOM ? mq(vdom).contains(str) : false,*/
        contains: (str) => {
            try{
                return isVDOM ? mq(vdom).contains(str) : false;
            }
            catch(err){
                // mithril-query throws errors when the selector doesn't hit a match, thus we
                // are simply returning false here
                return false;
            }
        },
        /**
         * Verifies that the virtual dom contains the provided string.
         * @param {string} str - The string to search for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyContains: (str, msg) => ok(() => fusionDom(vdom).contains(str), msg),
        /**
         * Checks that the virtual dom does not contain the provided string.
         *   NOTE: mithril-query currently has issues when using the contains functions that
         *   does not match to a result.  https://github.com/StephanHoyer/mithril-query/issues/74
         * @param {string} str - The string to search for.
         * @returns {boolean} True of the virtual dom does not contain the
         * string, otherwise false.
         */
        /*
         Once mithril-query issue 74 is addressed this version of the function can be utilized
         rather than the safety check version directly below
        doesNotContain: (str) => isVDOM ? !mq(vdom).contains(str): true,*/
        doesNotContain: (str) => {
            try{
                return isVDOM ? !mq(vdom).contains(str): true
            }
            catch(err){
                // mithril-query throws errors when the selector doesn't hit a match, thus we
                // are simply returning true here
                return true;
            }
        },
        /**
         * Verifies the virtual dom does not contain the provided text, str.
         * @param {string} str - The text that the virtual dom should not contain.
         * @param {string} message - The test message to output upon failure.
         * @returns {undefined} Returns nothing.
         */
        verifyDoesNotContain: (str, message) => ok(() => fusionDom(vdom).doesNotContain(str), message),
        /**
         * Checks that the virtual dom has an element that matches the selector.
         * @param {string} selector - The selector string to check for.
         * @returns {boolean} True if the virtual dom has the provided selector.
         */
        has: (selector) => isVDOM && mq(vdom).has(selector),
        /**
         * Verifies that the virtual dom has an element that matches the selector.
         * @param {string} selector - The selector string to check for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyHas: (selector, msg) => ok(() => fusionDom(vdom).has(selector), msg),
        /**
         * Checks that the virtual dom does not have an element that matches the
         * selector.
         * @param {string} selector - The selector string to check for.
         * @returns {boolean} True if the virtual dom does not have the provided selector.
         */
        doesNotHave: (selector) => {
            if(!isVDOM){
                return true;
            }
            return !mq(vdom).has(selector);
        },
        /**
         * Verifies that the virtual dom does not have an element that matches the
         * selector.
         * @param {string} selector - The selector string to check for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyDoesNotHave: (selector, msg) => ok(() => fusionDom(vdom).doesNotHave(selector), msg),
        /**
         * Triggers a fake event on the virtual dom.
         * @param {Array<*>} args - Arguments for the trigger function.
         * Examples
         *
         * trigger(eventTrigger) -> Triggers on `eventTrigger` on the root vdom element
         * trigger(eventTrigger, event) -> Triggers on `eventTrigger` on the root vdom element passing `event`
         * trigger(eventTrigger, childSelector) -> Triggers on `eventTrigger` on first matching child of `childSelector`
         * trigger(eventTrigger, childSelector, event) -> Triggers `eventTrigger` on first matching child of `childSelector` passing `event`
         * @returns {undefined} Returns nothing.
         */
        trigger: (...args) => {
            if(!isVDOM){
                throw new Error("Attempting to trigger events on a null element");
            }

            const eventName = args[ 0 ];
            // trigger("click")
            if (args.length === 1) {
                vdom.attrs[ `on${eventName}` ]();
            }
            // If only 2 args
            else if (args.length === 2) {
                // trigger("click", "[id=test-id]")
                if (typeof args[ 1 ] === "string") {
                    mq(vdom.children).trigger(args[ 1 ], `on${eventName}`);
                }
                // trigger("click", event)
                else {
                    vdom.attrs[ `on${eventName}` ](args[ 1 ]);
                }
            }
            // trigger("click", "span", event)
            else if (args.length === 3) {
                mq(vdom.children).trigger(args[ 1 ], `on${eventName}`, args[ 2 ]);
            }
        },
        /**
         * Triggers the oncreate lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnCreate: (htmlElement) => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.oncreate({ dom: htmlElement });
        },
        /**
         * Triggers the oninit lifecycle method of the virtual dom element.
         * @returns {undefined} Returns nothing.
         */
        triggerOnInit: () => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }

            //  You should never access the vnode.dom from the oninit method (from mithril website)
            // thats hwy we are not supporting passing dom element to the callback
            vdom.attrs.oninit({});
        },
        /**
         * Triggers the onbeforeremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {Promise} Returns nothing.
         */
        triggerOnBeforeUpdate: (htmlElement) => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            return vdom.attrs.onbeforeupdate({ dom: htmlElement });
        },
        /**
         * Triggers the onupdate lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnUpdate: (htmlElement) => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.onupdate({ dom: htmlElement });
        },
        /**
         * Triggers the onbeforeremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {Promise} Returns nothing.
         */
        triggerOnBeforeRemove: (htmlElement) => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            return vdom.attrs.onbeforeremove({ dom: htmlElement });
        },
        /**
         * Triggers the onremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnRemove: (htmlElement) => {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.onremove({ dom: htmlElement });
        }
    };
};

/**
 * Takes a UIComponent and renders it. The resulting virtual dom is wrapped
 * in testing utilities for verification purposes.
 * @param {UIComponent} uiComponent - The UIComponent which will be rendered
 * into test virtual dom.
 * @returns {TVDom} The control rendered as test virtual dom.
 */
export const control = (uiComponent) => fusionDom(uiComponent.render());

/**
 * Wraps the provided function inside a setTimeout
 * @param {Function} fn - function to call
 * @param {int} [time=100] - Timeout milliseconds
 * @returns {int} Timeout identifier
 */
export const delay = (fn, time = 100) => setTimeout(fn, time);
