/* global UIComponent */
/* eslint "no-restricted-imports": 0 */

"use strict";

/**
 * TVDom
 * @typedef {Object} TVDom
 */

/**
 * TVDomArray
 * @typedef {Object} TVDomArray
 */

/**
 * VDom
 * @typedef {Object} VDom
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.delay = exports.control = exports.fusionDom = exports.isVDOMObject = exports.uniqueKey = exports.notOk = exports.ok = undefined;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mithrilQuery = require("mithril-query");

var _mithrilQuery2 = _interopRequireDefault(_mithrilQuery);

var _chai = require("chai");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [idMaker].map(_regenerator2.default.mark);

/**
 * Performs an assertion that the function provided is truthy.
 * @param {function} f - The function to check.
 * @param {string} [msg] - The testing output message.
 * @returns {undefined} Returns nothing.
 */
var ok = exports.ok = function ok(f, msg) {
    return _chai.assert.isOk(f(), msg);
};

/**
 * Performs an assertion that the function provided is falsy.
 * @param {function} f - The function to check.
 * @param {string} [msg] - The testing output message.
 * @returns {undefined} Returns nothing.
 */
var notOk = exports.notOk = function notOk(f, msg) {
    return _chai.assert.isNotOk(f(), msg);
};

/**
 * Generates a unique id for mpageui components
 * @returns {string} unique id
 * @private
 */
function idMaker() {
    var cnt;
    return _regenerator2.default.wrap(function idMaker$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    cnt = 0;

                case 1:
                    if (!true) {
                        _context.next = 6;
                        break;
                    }

                    _context.next = 4;
                    return "unique-key-" + ++cnt;

                case 4:
                    _context.next = 1;
                    break;

                case 6:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked[0], this);
}

var uniqueKey = exports.uniqueKey = idMaker();

/**
 * A function to validate that a value is an actual VDOM object and not null or undefined
 * @param {object} checkVal The value which is being checked
 */
//TODO: Update the name of this function to something more appropriate
var isVDOMObject = exports.isVDOMObject = function isVDOMObject(checkVal) {
    return typeof checkVal !== "undefined" && checkVal !== null;
};

var canContainChildNodes = function canContainChildNodes(vdom) {
    return typeof vdom.children !== "string" && typeof vdom.children !== "boolean" && typeof vdom.children !== "number" && vdom.children;
};

/**
 * This check simply sees if the checkVal is an array
 * @param checkVal The value to check for Arrayness
 * @returns {boolean} True if the value is an array, false otherwise
 */
var isChildArray = function isChildArray(checkVal) {
    return Array.isArray(checkVal);
};

/**
 * A helper function that wraps an array of TVDom in an object with various
 * helper functions for testing purposes.
 * @param {Array<TVDom>} arr - An array of TVDom objects.
 * @returns {TVDomArray} Several TVDom objects wrapped in a helper for managing
 * an array of TVDom.
 */
var fusionDomArray = function fusionDomArray(arr) {
    return {
        /**
         * Returns the count of the array of TVDom objects.
         * @returns {number} The length of the array of TVDom.
         */
        count: function count() {
            return arr.length;
        },
        /**
         * Returns the first TVDom in the array.
         * @returns {TVDom} Test virtual dom.
         */
        first: function first() {
            return arr[0];
        },
        /**
         * Returns the last TVDom in the array.
         * @returns {TVDom} Test virtual dom.
         */
        last: function last() {
            return arr[Math.max(0, arr.length - 1)];
        },
        /**
         * Returns TVDom at the specified index. Bounds are clamped to the array.
         * @param {number} index - The index to retrieve.
         * @returns {TVDom} Test virtual dom.
         */
        get: function get(index) {
            return arr[Math.min(arr.length - 1, Math.max(index, 0))];
        },
        /**
         * Returns the full array.
         * @returns {Array<TVDom>} The array of test virtual dom.
         */
        all: function all() {
            return arr;
        }
    };
};

/**
 * A helper function that wraps virtual dom of a rendered UIComponent with
 * various helper functions for testing purposes.
 * @param {Object} vdom - The virtual dom rendered by a UIComponent.
 * @returns {TVDom} The test virtual dom of a rendered UIComponent.
 */
var fusionDom = exports.fusionDom = function fusionDom(vdom) {
    var isVDOM = isVDOMObject(vdom);

    return {
        /**
         * Returns the HTML tag name from the virtual DOM.
         * @returns {string} The HTML tag name.
         */
        tag: function tag() {
            return isVDOM && vdom.tag ? vdom.tag : "";
        },
        /**
         * Returns the HTML tag name from the virtual DOM.
         * @returns {string} The HTML tag name.
         */
        text: function text() {
            return isVDOM ? vdom.text : undefined;
        },
        /**
         * Returns the set of attributes from the virtual dom.
         * @returns {Object} The set of attributes on the virtual dom.
         */
        attrs: function attrs() {
            return isVDOM && vdom.attrs ? vdom.attrs : {};
        },
        /**
         * Returns an attribute from the virtual dom if present.
         * @param {string} name - The attribute name.
         * @returns {* | null} The attribute value or null.
         */
        getAttr: function getAttr(name) {
            return isVDOM && vdom.attrs ? vdom.attrs[name] : undefined;
        },
        /**
         * Retrieves parent of this node.
         *   BEWARE: This function only works on values that have been returned from the 'find',
         *   'findByAttribute' and 'at'
         * @returns {TVDom} Parent node
         */
        parent: function parent() {
            return isVDOM && vdom.parent ? fusionDom(vdom.parent) : undefined;
        },
        /**
         * Retrieves direct children virtual elements and wraps in an array
         * for testing purposes.
         * @returns {Array<TVDom>} Array of test virtual dom.
         */
        children: function children() {
            if (isVDOM) {
                if (canContainChildNodes(vdom)) {
                    return fusionDomArray(vdom.children.map(function (result) {
                        return fusionDom(result);
                    }));
                } else if (isChildArray(vdom)) {
                    return fusionDomArray(vdom);
                }
            }
            return fusionDomArray([]);
        },
        /**
         * Finds all elements that match the selector and wraps in an array for
         * testing purposes.
         * @param {string} selector - The selector query.
         * @returns {Array<TVDom>} Array of test virtual dom that matched the
         * selector.
         */
        find: function find(selector) {
            if (isVDOM) {
                var foundElements = (0, _mithrilQuery2.default)(vdom).find("" + selector);
                var mappedElements = foundElements.map(function (result) {
                    return fusionDom(result);
                });
                return fusionDomArray(mappedElements || []);
            }
            return fusionDomArray([]);
        },
        /**
         * Finds all elements where the attribute matches the specified value.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @returns {Array<TVDom>} elements that have the attribute
         */
        findByAttribute: function findByAttribute(attribute, value) {
            if (isVDOM && canContainChildNodes(vdom)) {
                var foundElements = (0, _mithrilQuery2.default)(vdom).find("[" + attribute + "=" + value + "]");
                var mappedElements = foundElements.map(function (result) {
                    return fusionDom(result);
                });
                return fusionDomArray(mappedElements);
            }
            return fusionDomArray([]);
        },
        /**
         * Recursively checks the children for an attribute with the specified value.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @returns {boolean} whether the attribute was found or not
         */
        hasAttributeInChildren: function hasAttributeInChildren(attribute, value) {
            return fusionDom(vdom).findByAttribute(attribute, value).count() !== 0;
        },
        /**
         * Recursively checks the children for an attribute with the specified value and
         * performs an assertion.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @param {string} [message] - Optional message to log upon failure.
         * @returns {undefined} nothing
         */
        verifyHasAttributeInChildren: function verifyHasAttributeInChildren(attribute, value, message) {
            return ok(function () {
                return fusionDom(vdom).hasAttributeInChildren(attribute, value);
            }, message);
        },
        /**
         * Recursively checks the children for the absence of an attribute with the specified value
         * and performs an assertion.
         * @param {string} attribute attribute name
         * @param {*} value attribute value
         * @param {string} [message] - Optional message to log upon failure.
         * @returns {undefined} nothing
         */
        verifyDoesNotHaveAttributeInChildren: function verifyDoesNotHaveAttributeInChildren(attribute, value, message) {
            return notOk(function () {
                return fusionDom(vdom).hasAttributeInChildren(attribute, value);
            }, message);
        },
        /**
         * Checks if the current virtual element has the specified CSS class name.
         * @param {string} className - The CSS class name to check for.
         * @returns {boolean} True if the virtual dom has the specified css className.
         */
        hasClass: function hasClass(className) {
            if (!isVDOM || !vdom.attrs) {
                return false;
            }

            //earlier versions of mithril keep the 'class' attribute in place.
            if (vdom.attrs.class) {
                return vdom.attrs.class.indexOf(className) > -1;
            } else {
                return !!vdom.attrs.className && vdom.attrs.className.indexOf(className) > -1;
            }
        },
        /**
         * Returns the virtual dom wrapped in the call to mithril-query. It is not
         * recommended to use.
         * @returns {Object} The virtual dom wrapped in mithril-query.
         */
        el: function el() {
            return isVDOM ? (0, _mithrilQuery2.default)(vdom) : null;
        },
        /**
         * Finds the provided selector in the virtual dom.
         * @param {string} selector - The selector to find virtual elements.
         * @returns {TVDom} The found virtual elements wrapped in the TVDom
         * helper.
         */
        at: function at(selector) {
            return isVDOM ? fusionDom((0, _mithrilQuery2.default)(vdom).find(selector)[0]) : fusionDom([]);
        },
        /**
         * Checks if the virtual dom contains the provided string. Useful for
         * searching for text within the virtual dom.
         *   NOTE: mithril-query currently has issues when using the contains functions that
         *   does not match to a result.  https://github.com/StephanHoyer/mithril-query/issues/74
         * @param {string} str - The string to search for.
         * @returns {boolean} True if the virtual dom contains the provided string,
         * otherwise false.
         */
        /*
        Once mithril-query issue 74 is addressed this version of the function can be utilized
        rather than the safety check version directly below
        contains: (str) => isVDOM ? mq(vdom).contains(str) : false,*/
        contains: function contains(str) {
            try {
                return isVDOM ? (0, _mithrilQuery2.default)(vdom).contains(str) : false;
            } catch (err) {
                // mithril-query throws errors when the selector doesn't hit a match, thus we
                // are simply returning false here
                return false;
            }
        },
        /**
         * Verifies that the virtual dom contains the provided string.
         * @param {string} str - The string to search for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyContains: function verifyContains(str, msg) {
            return ok(function () {
                return fusionDom(vdom).contains(str);
            }, msg);
        },
        /**
         * Checks that the virtual dom does not contain the provided string.
         *   NOTE: mithril-query currently has issues when using the contains functions that
         *   does not match to a result.  https://github.com/StephanHoyer/mithril-query/issues/74
         * @param {string} str - The string to search for.
         * @returns {boolean} True of the virtual dom does not contain the
         * string, otherwise false.
         */
        /*
         Once mithril-query issue 74 is addressed this version of the function can be utilized
         rather than the safety check version directly below
        doesNotContain: (str) => isVDOM ? !mq(vdom).contains(str): true,*/
        doesNotContain: function doesNotContain(str) {
            try {
                return isVDOM ? !(0, _mithrilQuery2.default)(vdom).contains(str) : true;
            } catch (err) {
                // mithril-query throws errors when the selector doesn't hit a match, thus we
                // are simply returning true here
                return true;
            }
        },
        /**
         * Verifies the virtual dom does not contain the provided text, str.
         * @param {string} str - The text that the virtual dom should not contain.
         * @param {string} message - The test message to output upon failure.
         * @returns {undefined} Returns nothing.
         */
        verifyDoesNotContain: function verifyDoesNotContain(str, message) {
            return ok(function () {
                return fusionDom(vdom).doesNotContain(str);
            }, message);
        },
        /**
         * Checks that the virtual dom has an element that matches the selector.
         * @param {string} selector - The selector string to check for.
         * @returns {boolean} True if the virtual dom has the provided selector.
         */
        has: function has(selector) {
            return isVDOM && (0, _mithrilQuery2.default)(vdom).has(selector);
        },
        /**
         * Verifies that the virtual dom has an element that matches the selector.
         * @param {string} selector - The selector string to check for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyHas: function verifyHas(selector, msg) {
            return ok(function () {
                return fusionDom(vdom).has(selector);
            }, msg);
        },
        /**
         * Checks that the virtual dom does not have an element that matches the
         * selector.
         * @param {string} selector - The selector string to check for.
         * @returns {boolean} True if the virtual dom does not have the provided selector.
         */
        doesNotHave: function doesNotHave(selector) {
            if (!isVDOM) {
                return true;
            }
            return !(0, _mithrilQuery2.default)(vdom).has(selector);
        },
        /**
         * Verifies that the virtual dom does not have an element that matches the
         * selector.
         * @param {string} selector - The selector string to check for.
         * @param {string} msg - The test message which is logged on failure.
         * @returns {undefined} Returns nothing.
         */
        verifyDoesNotHave: function verifyDoesNotHave(selector, msg) {
            return ok(function () {
                return fusionDom(vdom).doesNotHave(selector);
            }, msg);
        },
        /**
         * Triggers a fake event on the virtual dom.
         * @param {Array<*>} args - Arguments for the trigger function.
         * Examples
         *
         * trigger(eventTrigger) -> Triggers on `eventTrigger` on the root vdom element
         * trigger(eventTrigger, event) -> Triggers on `eventTrigger` on the root vdom element passing `event`
         * trigger(eventTrigger, childSelector) -> Triggers on `eventTrigger` on first matching child of `childSelector`
         * trigger(eventTrigger, childSelector, event) -> Triggers `eventTrigger` on first matching child of `childSelector` passing `event`
         * @returns {undefined} Returns nothing.
         */
        trigger: function trigger() {
            if (!isVDOM) {
                throw new Error("Attempting to trigger events on a null element");
            }

            var eventName = arguments.length <= 0 ? undefined : arguments[0];
            // trigger("click")
            if (arguments.length === 1) {
                vdom.attrs["on" + eventName]();
            }
            // If only 2 args
            else if (arguments.length === 2) {
                    // trigger("click", "[id=test-id]")
                    if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === "string") {
                        (0, _mithrilQuery2.default)(vdom.children).trigger(arguments.length <= 1 ? undefined : arguments[1], "on" + eventName);
                    }
                    // trigger("click", event)
                    else {
                            vdom.attrs["on" + eventName](arguments.length <= 1 ? undefined : arguments[1]);
                        }
                }
                // trigger("click", "span", event)
                else if (arguments.length === 3) {
                        (0, _mithrilQuery2.default)(vdom.children).trigger(arguments.length <= 1 ? undefined : arguments[1], "on" + eventName, arguments.length <= 2 ? undefined : arguments[2]);
                    }
        },
        /**
         * Triggers the oncreate lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnCreate: function triggerOnCreate(htmlElement) {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.oncreate({ dom: htmlElement });
        },
        /**
         * Triggers the oninit lifecycle method of the virtual dom element.
         * @returns {undefined} Returns nothing.
         */
        triggerOnInit: function triggerOnInit() {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }

            //  You should never access the vnode.dom from the oninit method (from mithril website)
            // thats hwy we are not supporting passing dom element to the callback
            vdom.attrs.oninit({});
        },
        /**
         * Triggers the onbeforeremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {Promise} Returns nothing.
         */
        triggerOnBeforeUpdate: function triggerOnBeforeUpdate(htmlElement) {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            return vdom.attrs.onbeforeupdate({ dom: htmlElement });
        },
        /**
         * Triggers the onupdate lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnUpdate: function triggerOnUpdate(htmlElement) {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.onupdate({ dom: htmlElement });
        },
        /**
         * Triggers the onbeforeremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {Promise} Returns nothing.
         */
        triggerOnBeforeRemove: function triggerOnBeforeRemove(htmlElement) {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            return vdom.attrs.onbeforeremove({ dom: htmlElement });
        },
        /**
         * Triggers the onremove lifecycle method of the virtual dom element.
         * @param {HTMLElement} htmlElement - The faked HTMLElement which triggered the config.
         * @returns {undefined} Returns nothing.
         */
        triggerOnRemove: function triggerOnRemove(htmlElement) {
            if (!isVDOM) {
                throw new Error("Attempting to trigger on-create event on a null element");
            }
            vdom.attrs.onremove({ dom: htmlElement });
        }
    };
};

/**
 * Takes a UIComponent and renders it. The resulting virtual dom is wrapped
 * in testing utilities for verification purposes.
 * @param {UIComponent} uiComponent - The UIComponent which will be rendered
 * into test virtual dom.
 * @returns {TVDom} The control rendered as test virtual dom.
 */
var control = exports.control = function control(uiComponent) {
    return fusionDom(uiComponent.render());
};

/**
 * Wraps the provided function inside a setTimeout
 * @param {Function} fn - function to call
 * @param {int} [time=100] - Timeout milliseconds
 * @returns {int} Timeout identifier
 */
var delay = exports.delay = function delay(fn) {
    var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    return setTimeout(fn, time);
};
