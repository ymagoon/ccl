/**
 * @typedef {Object} ContentServerConfig
 * @property {String} staticContentLocation - The path to the static content which is to be hosted by the content server.
 * @property {String} cssLocation - The location of the artifact CSS (the artifact being developed).
 * @property {String} sourceCodeLocation - The location of the artifact JS (the artifact being developed).
 * @property {Object} gaiaJson - The full gaia json settings.
 */

/**
 * @typedef {Object} InjectorConfig
 * @property {Object} gaiaJson - The gaia settings json.
 * @property {String} sourceCodeLocation - The location of the source code.
 * @property {String} cclProgram - The CCL program to intercept.
 * @property {String} cssLocation - The location of the CSS.
 * @property {Boolean} useWebpackWatcher - Whether to use the webpack configuration.
 */

const path = require("path");

/**
 * Reads the plugin settings config for the contentserver plugin.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command args.
 * @returns {Promise} Resolved when the contentserver settings are retrieved.
 */
const retrieveContentServerConfig = (gaia, args) =>
    gaia.runCommand(
        "contentserver",
        "allFolders"
    ).then((folders) => Promise.resolve({
        cssLocation: folders.css || "",
        i18nLocation: folders.i18n || "",
        sourceCodeLocation: folders.source || "",
        staticContentLocation: folders.staticContent || ""
    }));

/**
 * Adds a folder to the content server config.
 * @param {Object} gaia - Gaia context.
 * @param {Object} gaiaJson - The full gaia json settings.
 * @param {String} alias - The folder alias.
 * @param {String} path - The path to the folder.
 * @returns {Promise} Promise resolved when the folder has been added.
 */
const addFolder = (gaia, gaiaJson, alias, path) =>
    gaia.runCommand("contentserver", "allFolders", { gaiaJson: gaiaJson })
        .then(
            (folders) =>
                folders[ alias ] === path
                    ? Promise.resolve()
                    : gaia.runCommand("contentserver", "addFolder", {
                        alias: alias,
                        path: path,
                        gaiaJson: gaiaJson
                    })
        );

/**
 * Provides configuration to the content server. This is a preliminary step to launching
 * a live-dev application (such as mp_unified_driver) as we need the content server to
 * be hosting the static content locally, if desired.
 * @param {Object} gaia - Gaia context.
 * @param {ContentServerConfig} args - Content server configuration arguments.
 * @returns {Promise} A promise resolved when the config change has succeeded.
 */
const configureContentServer = (gaia, args) =>
    addFolder(gaia, args.gaiaJson, "staticContent", args.staticContentLocation)
        .then(() => addFolder(gaia, args.gaiaJson, "css", args.cssLocation ? path.dirname(args.cssLocation) : ""))
        .then(() => addFolder(gaia, args.gaiaJson, "i18n", args.i18nLocation ? path.dirname(args.i18nLocation) : ""))
        .then(() => addFolder(gaia, args.gaiaJson, "source", args.sourceCodeLocation ? path.dirname(args.sourceCodeLocation) : ""))
        .then(() => addFolder(gaia, args.gaiaJson, "bedrockMocks", (args.isBedrockEnabled && args.bedrockMocksLocation) ? path.dirname(args.bedrockMocksLocation) : ""));

/**
 * Automatically configures the injector with the necessary settings to run
 * the livedev plugin. This sets the target url to the route that the millennium proxy is running
 * and specifies a content request prefix.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command args.
 * @returns {Promise} Resolved when the base injector settings have been saved.
 */
const configureInjectorSettings = (gaia, args) =>
    gaia.runCommand("injector", "readSettings", args)
        .then((settings) => {
            settings.targetUrl = args.webServiceUrl ? args.webServiceUrl : "http://localhost:8081/mil/";
            settings.prefix = "";
            return gaia.runCommand("injector", "saveSettings", {
                gaiaJson: args.gaiaJson,
                settings: settings
            });
        });

/**
 * Given the i18n file, builds the URL for the injector.
 * @param {Object} args - Arguments to build the i18n url.
 * @returns {String[]} - Array containing i18n url.
 */
const buildI18nUrl = (args) => {
    const { i18nLocation, rootUrl } = args;
    const i18nFileName = i18nLocation ? path.basename(i18nLocation) : "";
    return [ i18nFileName ? `${rootUrl}/api/routes/contentserver/content/i18n/${i18nFileName}` : null ].filter(file => !!file);
};

/**
 * Given the bedrock mocks file, builds the URL for the injector.
 * @param {Object} args - Arguments to build the mock url.
 * @returns {String[]} - Array containing mock url.
 */
const buildBedrockMocksUrl = (args) => {
    const { bedrockMocksLocation, rootUrl } = args;
    const bedrockMocksFileName = bedrockMocksLocation ? path.basename(bedrockMocksLocation) : "";
    return [ bedrockMocksFileName ? `${rootUrl}/api/routes/contentserver/content/bedrockMocks/${bedrockMocksFileName}` : null ].filter(file => !!file);
};

/**
 * Given the artifact source code and CSS files, builds the URLs for the injector.
 * This assumes the files can be accessed via the contentserver plugin.
 * @param {Object} args - Arguments to build the injector urls.
 * @returns {String[]} - Array of injector urls.
 */
const buildStaticSourceUrls = (args) => {
    const { cssLocation, sourceCodeLocation, rootUrl } = args;
    const sourceFileName = sourceCodeLocation ? path.basename(sourceCodeLocation) : "";
    const cssFileName = cssLocation ? path.basename(cssLocation) : "";
    return [
        sourceFileName ? `${rootUrl}/api/routes/contentserver/content/source/${sourceFileName}` : null,
        cssFileName ? `${rootUrl}/api/routes/contentserver/content/css/${cssFileName}` : null
    ].filter(file => !!file);
};

/**
 * Builds necessary URLs for webpack configuration.
 * @param {String} bundleFileName - The webpack bundle file name.
 * @param {Boolean} isWebpackAutoRefreshEnabled - If auto-refresh is enabled.
 * @returns {String[]} Webpack urls to inject.
 */
const buildWebpackUrls = ({ bundleFileName, isWebpackAutoRefreshEnabled }) => [
    `http://localhost:7070/${bundleFileName}`,
    isWebpackAutoRefreshEnabled ? `http://localhost:7070/webpack-dev-server.js` : null
].filter(url => !!url);

/**
 * Builds the set of urls to inject based on the livedev configuration.
 * @param {Object} args - Command args.
 * @returns {String[]} Array of urls to inject.
 */
const buildInjectedUrls = (args) =>
    buildI18nUrl(args).concat(args.isWebpackEnabled ?
        buildWebpackUrls({
            bundleFileName: args.webpackTarget.fileName,
            isWebpackAutoRefreshEnabled: args.isWebpackAutoRefreshEnabled
        }) :
        buildStaticSourceUrls(args));

/**
 * returns a new array without duplicates
 * @param {Array} arr - the array
 * @returns {Array} array without duplicates
 */
const removeDuplicatesFromArray = (arr) => {
    const seen = {};
    return arr.filter(item => item in seen ? false : seen[item] = item);
};

/**
 * Goes through the array of urls in the injector and either adds a url for bedrock mocks if bedrock is enabled
 * or removes any urls with "bedrockMocks" in the string
 * @param {Array} urls - the array of urls in the injector
 * @param {InjectorConfig} args - Command arguments
 * @returns {Array} Returns an updated array with new or removed urls
 */
const handleBedrockMockUrls = (urls, args) =>
    args.isBedrockEnabled ?
        urls.concat(buildBedrockMocksUrl(args)) :
        urls.filter(url => url.includes("bedrockMocks") ? false : true);

/**
 * Configures the urls for the injector plugin.
 * @param {Object} gaia - Gaia context.
 * @param {InjectorConfig} args - Command arguments.
 * @returns {Promise} Resolved when the injector urls have been updated.
 */
const configureInjectorUrl = (gaia, args) =>
    args.cclProgram ? gaia.runCommand("injector", "readUrls", args)
        .then((urlMap) => {
            const url = `.*${args.cclProgram}.*`;
            const result = Object.assign({}, urlMap, {
                [url]: {
                    top: urlMap[url] && urlMap[url].top || [],
                    bottom: removeDuplicatesFromArray(
                        handleBedrockMockUrls(
                            (urlMap[url] && urlMap[url].bottom || [])
                                .concat(buildInjectedUrls(args)), args
                        )
                    )
                }
            });
            return gaia.runCommand("injector", "saveUrls", {
                gaiaJson: args.gaiaJson,
                urls: result
            });
        }) : Promise.resolve();


/**
 * Returns the current settings for data retieval of the injector
 * @param {Object} gaia - Gaia context.
 * @param {InjectorConfig} args - Command arguments.
 * @returns {Promise} Resolved when the injector urls have been updated.
 */
const retrieveInjectorSettings = (gaia, args) =>
    gaia.runCommand("injector", "readFullMockSettings");


/**
 * Configures the injector plugin to work with the livedev plugin.
 * @param {Object} gaia - Gaia context.
 * @param {InjectorConfig} args - Command arguments.
 * @returns {Promise} Resolved when the injector plugin has been configured.
 */
const configureInjector = (gaia, args) =>
    configureInjectorSettings(gaia, args)
        .then(() => configureInjectorUrl(gaia, args));

/**
 * Retrieves the default config for the livedev plugin.
 * @param {Object} config - The config retrieved from the config plugin.
 * @returns {Object} Default config for the livedev plugin.
 */
const liveDevDefaultConfig = (config) =>
    Object.assign({}, {
        cclProgram: "",
        programParams: "",
        sourceCodeLocation: ""
    }, config);

/**
 * Retrieves the configuration for the livedev plugin.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when the livedev config has been retrieved.
 */
const retrieveLiveDevConfig = (gaia, args) =>
    gaia.runCommand(
        "config",
        "read",
        Object.assign(args, {
            plugin: "livedev"
        })
    )
        .then(liveDevDefaultConfig)
        .then(config => Promise.resolve(config || {}));

/**
 * Retrieves the full settings from the webpack config.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command args.
 * @returns {Promise} Resolved when webpack settings have been retrieved.
 */
const retrieveWebpackConfig = (gaia, args) =>
    gaia.runCommand(
        "webpack",
        "readFullConfig"
    ).then(config => Promise.resolve(config || {}));


/**
 * Retrieves the credentials from the milproxy config.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command args.
 * @returns {Promise} Resolved when webpack settings have been retrieved.
 */
const retrieveMilProxyConfig = (gaia, args) =>
    gaia.runCommand(
        "milproxy",
        "readConfig"
    ).then(config => Promise.resolve(config || {}));

/**
 * Retrieves all necessary settings for the livedev plugin. This aggregates
 * configuration across this plugin, the contentserver, and injector plugins.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when all settings are retrieved.
 */
const retrieveSettings = (gaia, args) =>
    Promise.all([
        retrieveContentServerConfig(gaia, args),
        retrieveLiveDevConfig(gaia, args),
        retrieveWebpackConfig(gaia, args),
        retrieveInjectorSettings(gaia, args),
        retrieveMilProxyConfig(gaia, args)
    ]).then(([ contentServerConfig, liveDevConfig, webpackConfig, injectorSettings, milProxyConfig ]) => {
        return Promise.resolve({
            webServiceUrl: liveDevConfig.webServiceUrl,
            cclProgram: liveDevConfig.cclProgram,
            cssLocation: liveDevConfig.cssLocation,
            bedrockMocksLocation: liveDevConfig.bedrockMocksLocation,
            isBedrockEnabled: liveDevConfig.isBedrockEnabled,
            i18nLocation : liveDevConfig.i18nLocation,
            programParams: liveDevConfig.programParams,
            sourceCodeLocation: liveDevConfig.sourceCodeLocation,
            staticContentLocation: contentServerConfig.staticContentLocation,
            isWebpackEnabled: liveDevConfig.isWebpackEnabled,
            isWebpackAutoRefreshEnabled: liveDevConfig.isWebpackAutoRefreshEnabled,
            webpackTargets: webpackConfig.targets,
            mockResponseLocation: injectorSettings.mockResponseLocation,
            mockResponseCollection: injectorSettings.mockCollectionName,
            mockCollectionNames: injectorSettings.mockCollectionNames,
            recordMode: injectorSettings.recordState,
            username: milProxyConfig.username,
            domain: milProxyConfig.domain
        });
    });

/**
 * Small helper to save the config for the livedev plugin namespace.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @param {Object} config - The config to be written.
 */
const saveConfig = (gaia, args, config) =>
    gaia.runCommand(
        "config",
        "write",
        {
            config: config,
            plugin: "livedev"
        }
    );

/**
 * Small helper to save the milproxy config
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @param {Object} config - The config to be written.
 */
const saveMilProxyConfig = (gaia, args, config) =>
    gaia.runCommand(
        "milproxy",
        "saveConfig",
        {
            config: config
        }
    );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveProgramParams = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                programParams: args.programParams
            }))
        );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveSourceCodeLocation = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                sourceCodeLocation: args.sourceCodeLocation
            }))
        );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveCSSLocation = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                cssLocation: args.cssLocation
            }))
        );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveI18nLocation = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                i18nLocation: args.i18nLocation
            }))
        );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveBedrockEnabled = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                isBedrockEnabled: args.isBedrockEnabled
            }))
        );

/**
 * Saves the program parameters.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveBedrockLocation = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                bedrockMocksLocation: args.bedrockMocksLocation
            }))
        );

/**
 * Saves the CCL program name.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveCCLProgram = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                cclProgram: args.cclProgram
            }))
        );

/**
 * Saves state of webpack enabled.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when webpack enabled setting is saved.
 */
const saveWebpackEnabled = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                isWebpackEnabled: args.isWebpackEnabled
            }))
        );

/**
 * Saves state of webpack auto-refresh enabled.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when webpack auto-refresh setting is saved.
 */
const saveWebpackAutoRefreshEnabled = (gaia, args) =>
    retrieveLiveDevConfig(gaia, args)
        .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                isWebpackAutoRefreshEnabled: args.isWebpackAutoRefreshEnabled
            }))
        );
/**
 * Saves state of webpack auto-refresh enabled.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when webpack auto-refresh setting is saved.
 */
const saveWebService = (gaia, args) =>
      retrieveLiveDevConfig(gaia, args)
      .then(config =>
            saveConfig(gaia, args, Object.assign({}, config, {
                webServiceUrl: args.webServiceUrl
            }))
           );
/**
 * Saves the username.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveUsername = (gaia, args) =>
    retrieveMilProxyConfig(gaia, args)
        .then(config =>
            saveMilProxyConfig(gaia, args, Object.assign({}, config, {
                username: args.username
            }))
        );
/**
 * Saves the domain.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command arguments.
 * @returns {Promise} Resolved when settings are finished writing.
 */
const saveDomain = (gaia, args) =>
    retrieveMilProxyConfig(gaia, args)
        .then(config =>
            saveMilProxyConfig(gaia, args, Object.assign({}, config, {
                domain: args.domain
            }))
        );
/**
 * Convenience command to configure all aspects of the livedev plugin
 * in sequence.
 * @param {Object} gaia - Gaia context.
 * @param {Object} args - Command args.
 * @returns {Promise} Resolved when all config has been established.
 */
const configureLiveDev = (gaia, args) =>
    [
        () => saveCCLProgram(gaia, args),
        () => saveProgramParams(gaia, args),
        () => saveWebService(gaia, args),
        () => saveSourceCodeLocation(gaia, args),
        () => saveCSSLocation(gaia, args),
        () => saveI18nLocation(gaia, args),
        () => saveWebpackEnabled(gaia, args),
        () => saveWebpackAutoRefreshEnabled(gaia, args),
        () => saveBedrockEnabled(gaia, args),
        () => saveBedrockLocation(gaia, args),
        () => saveUsername(gaia, args),
        () => saveDomain(gaia, args)
    ].reduce((acc, next) => acc.then(() => next()), Promise.resolve());

module.exports = {
    configureContentServer,
    configureInjector,
    configureLiveDev,
    retrieveLiveDevConfig,
    retrieveSettings
};
