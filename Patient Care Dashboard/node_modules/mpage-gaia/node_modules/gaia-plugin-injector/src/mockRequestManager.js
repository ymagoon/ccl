const path = require("path");
const fs = require("fs");
const chalk = require("chalk");
const { RECORD_STATES, MATCHING_MODES } = require("./constants");

/**
 * handleMocks is used to initialize the mockCollection class and return the entire mock collection object.
 * @param {object} config - Configuration of the current route (located in gaia.json).
 * @param {object} args - The plugin arguments
 * @param {object} url - The URL for the current request
 * @param {Number} recordingState - The recording state. If not in replay, this function returns undefined.
 * @param {String} requestParameters - The parameter field of the urlencoded form data of the request.
 * @param {String} requestDataBlob - The dataIn filed of the urlencoded form data of the request.
 * @returns {object|undefined} - The mocked up JSON object that matches the provided request if in a replay state. Undefined otherwise or if not found.
 */
const getMatchingMockRequest = (config, args, url, recordingState, requestParameters, requestDataBlob) => {
    try {
        if (recordingState !== RECORD_STATES.REPLAY) {
            return undefined;
        }
        const cwd = args && args.cwd;
        const requestName = getReportNameFromUrl(url);
        const mockFileLocation = config && config.mockResponses && config.mockResponses.mockResponseLocation;
        const mockCollectionName = config && config.mockResponses && config.mockResponses.mockCollectionName;
        const testCollectionJSON = parseMockResponseCollection(cwd, mockFileLocation);
        const mockResponseCollection = testCollectionJSON && searchMocksCollection(
                testCollectionJSON[Object.keys(testCollectionJSON)[0]],
                "collectionName",
                mockCollectionName
            );
        return mockResponseCollection
            ? findByScriptParameters(
                mockResponseCollection.responseCollection,
                requestName,
                requestParameters,
                requestDataBlob,
                config.matchingMode
            )
            : undefined;
    }
    catch (error) {
        console.log(` ${chalk.bgRed('*** Error in Injector:route:handleMocks: ')}  ${error.message}. `);
    }
};

/**
 * Returns the name of executed CCL report based on the current request
 * @param  {String} req URL or parameters for report being executed
 * @return {String}     CCL Report attempting to be executed
 */
const getReportNameFromUrl = (url) => {
    const reportString = "reports/";
    return url.substring(url.indexOf(reportString) + reportString.length);
};

/**
 * Returns a parsed mocked object based on a static JSON file.
 * Example Structure:
 * {
          "tests": [
            {
              "testType": "graybox",
              "collectionName": "scriptFailure",
              "responseCollection": [{
                "scriptName": "MP_RETRIEVE_DOCUMENTS_JSON_DP",
                "parameterarray": "^MINE^,1073923.0,1049884.0,3038002.0,0,value(4002293.0,4003743.0),0.0,1119.0,0,0,0,1",
                "response": {}
              }]
            }
          ]
      }
 * @returns {object} parsed JSON content of static file location
 */
const parseMockResponseCollection = (cwd = "", mockFileLocation = "") => {
    return fs.existsSync(path.resolve(cwd, mockFileLocation)) &&
        JSON.parse(fs.readFileSync(mockFileLocation, 'utf8'));
};

/**
 * Returns an array of mocked responses based on the collectionName property.
 * @param {array} sourceCollection - The array of objects to search.
 * @param {string} sourceCollectionKey - lookup key of a collection.
 * @param {string} targetCollectionName - target value of a collection.
 * @returns {object} targeted collection
 */
const searchMocksCollection = ((sourceCollection = [], sourceCollectionKey = "", targetCollectionName = "") =>
    sourceCollection.find((testCollection) => {
            return testCollection[sourceCollectionKey] === targetCollectionName
        }
    ));

/**
* This function returns the standard `No data found` data structure and logs the error.
* @param {string} requestName - script name that was searched.
* @param {string} parameters - The parameters specific to this request.
* @param {dataBlob} dataBlob - The data blob specific to this request.
* @returns {Object} The standard no data found data structure.
*/
const returnStandardNoDataReply = (requestName, parameters, dataBlob) => {
    console.log(`Error: No recorded mock found for the script "${requestName}"`);
    const errorString = `Parameters: ${parameters}\nData Blob: ${dataBlob}`;
    console.log(errorString);

    return {
        response: JSON.stringify({ 
            RECORD_DATA: {
                STATUS_DATA: {
                    STATUS: "Z",
                    SUBEVENTSTATUS: [
                        {
                            OPERATIONNAME: requestName,
                            OPERATIONSTATUS: "Z",
                            TARGETOBJECTNAME: "No recorded mock found.",
                            TARGETOBJECTVALUE: errorString
                        }
                    ]
                }
            }
        })
    };
}

/**
* Returns an object matching the request/parameters from a particular mock collection.
* @param {array} mockCollections - The array of objects to search.
* @param {string} requestName - script name to search.
* @param {string} parameters - The parameters specific to this request.
* @param {dataBlob} dataBlob - The data blob specific to this request
* @param {Number} matchingMode - The matching mode to be used
* @returns {object|undefined} targeted script object if found. If no scripts match the name, returns undefined
*/
const findByScriptParameters = (mockCollections = [], requestName = "", parameters = "", dataBlob = "", matchingMode = MATCHING_MODES.STRICT) => {
    const nameMatchedScripts = mockCollections.filter(mockCollection => mockCollection.scriptName === requestName);

    // If parameter and dataBlob is not defined, returns the first script that matches the name
    if (!parameters && !dataBlob) {
        return nameMatchedScripts[0];
    }

    // If dataBlob is defined, match on dataBlob and parameterarray
    let blobMatchedScript;
    if (dataBlob) {
        blobMatchedScript = nameMatchedScripts.find((script) => {
            return script.dataBlob === dataBlob && script.parameterarray === parameters;
        });
    }

    // If found, return that
    return blobMatchedScript
    // else, match on just parameterarray
    || (!dataBlob && nameMatchedScripts.find(script => script.parameterarray === parameters))
    // If nothing is found, and if mock doesn't have any parameters, or return first mode is set, return the first script with matching names
    || (
        (matchingMode === MATCHING_MODES.RETURN_FIRST || nameMatchedScripts.every(script => !script.parameterarray))
        && nameMatchedScripts[0]
    )
    || returnStandardNoDataReply(requestName, parameters, dataBlob); // Otherwise, return a standard `No data found` response.
};

/**
 * Generates JSON Array containing request/response details for the current workflow
 * @param  {String} collectionName   The name of the collection to save the requests/responses as
 * @param  {Array<Object>} capturedRequests Array of objects containing details for captured requests
 * @return {Object}                  Object containing details for the recorded test collection
 */
const generateTest = (collectionName, capturedRequests) => {
    const testJson = {
        collectionName: collectionName,
        responseCollection: [],
        testType: "recorded"
    };
    testJson.responseCollection = capturedRequests.map((captured) => {
        return createRequestJSON(captured);
    });
    return testJson;
};

/**
 * Generates the object containing mock data details for the captured request/response
 * @param  {Object} captured Object containing captured request/response details
 * @return {Object}          Object containing details for use in test collection to replay the request with mock data
 */
const createRequestJSON = (captured) => {
    const responseObject = {
        scriptName: captured.script,
        parameterarray: captured.params,
        dataBlob: captured.blobIn || "",
        response: captured.response,
        latency: 0
    }
    return responseObject;
};

/**
 * Handles saving the current request/reply collection to the file
 * @param {object} config - Configuration of the current route (located in gaia.json).
 * @param {object} args - The plugin arguments
 * @returns {object} - The mocked up JSON object that matches the provided request.
 */
const writeMockFileCollection = (config, args, capturedRequests) => {
    const cwd = args && args.cwd;
    const mockFileLocation = config && config.mockResponses && config.mockResponses.mockResponseLocation;
    const mockCollectionName = config && config.mockResponses && config.mockResponses.mockCollectionName;
    const collectionName = args.collectionName;
    const testCollectionJSON = fileExists(cwd, mockFileLocation) ? JSON.parse(fs.readFileSync(mockFileLocation)) : generateTestCollection(collectionName);
    const currentTestCollection = generateTest(collectionName, capturedRequests);
    testCollectionJSON.tests.push(currentTestCollection);
    fs.writeFileSync(mockFileLocation, JSON.stringify(testCollectionJSON, null, 4), "utf8");
    return testCollectionJSON;
};

/**
 * Creates the base structure for a test collection.  Utilized if test collection is not present in directory
 * @return {Object} Object representing test collection
 */
const generateTestCollection = () => {
    return {
        "tests": []
    }
};

/**
 * Verify that a  file exists.  This function will resolve the file path to support realative filepaths.
 * @param {string} cwd - current working directory.
 * @param {string} filePath - targeted filepath of the mocked JSON objects
 * @returns {boolean} true if the file exists.
 */
const fileExists = (cwd, filePath) => {
    return typeof filePath === "string"
        ? fs.existsSync(path.resolve(cwd, filePath))
        : false;
};

module.exports = {
    getMatchingMockRequest,
    getReportNameFromUrl,
    writeMockFileCollection
};