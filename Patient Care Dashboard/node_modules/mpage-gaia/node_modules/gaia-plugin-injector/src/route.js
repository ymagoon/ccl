const { readConfig } = require("./commands/config");
const { injectUrls } = require("fusion-injector");
const { getMatchingMockRequest } = require("./mockRequestManager");
const {
    getRequestParameters,
    getRequestBlobIn
} = require("./helpers");
const queryString = require("query-string");

// Initialize proxy server
const httpProxy = require("http-proxy").createProxyServer((req,res) => {});
httpProxy.on("error", (err, errReq, errRes) => {
    errRes.writeHead(500, {
        "Content-Type": "text/plain"
    });
    console.log(err);
    errRes.end(JSON.stringify(err));
});

// Write the original request body to the proxy request body.
httpProxy.on("proxyReq", function (proxyReq, req, res, options) {
    // If the request header is of application/x-www-form-urlencode, it may contain
    // request parameters and data blobs that we need to record/match against to replay.
    if (proxyReq.getHeader("Content-Type") === "application/x-www-form-urlencoded") {
        // Parses the url encoded query string
        const bodyData = queryString.stringify(req.body);

        // If parsed body data is present, we restream that object in the proxy request.
        // mpage-gaia has a middleware (`express.urlencoded`) to parse the request body and put it in the 
        // request.body property.
        // Check this example for more details:
        // https://github.com/nodejitsu/node-http-proxy/pull/1264/commits/16ca6b5d987f1b9a812cbd041f24d9b0faa09864
        if (bodyData) {
            proxyReq.setHeader("Content-Length", Buffer.byteLength(bodyData));
            proxyReq.write(bodyData);
        }
    }
});


/**
 * This function routes requests to the httpProxy server.  If a request matches a mocked up response the reply is
 * injected and the http request is bypassed.
 * @param gaia The current gaia object
 * @param args The plugin arguments
 * @param req The http request
 * @param res The http response
 * @param state The current plugin state
 * @param next optional passthrough function
 */
const inject = (gaia, args, req, res, next, state) => {
    readConfig(gaia, args)
        .then(
            (config) => {
                const url = req.params[0] || req.url;
                req.url = req.url.substr("/injector/inject".length);

                // To support matching on both POST and GET requests we are checking if there are parameters and dataBlob
                // in either the query or the body of the request.
                const parameters = getRequestParameters(req);
                const blobIn = getRequestBlobIn(req);

                const mockResponse = getMatchingMockRequest(
                    config,
                    args,
                    url,
                    state.recordingState,
                    parameters,
                    blobIn
                );

                // Included injected URLs in the written response
                injectUrls(
                    config.urls,
                    config.settings.prefix || "",
                    req,
                    res
                );
                if (mockResponse) {
                    const latency = mockResponse.latency || 0;
                    setTimeout(() => {
                        res.send(mockResponse.response);
                    }, latency);
                }
                else {
                    // Send request through proxy to target URL (typically millenium proxy)
                    httpProxy.web(req, res, {target: config.settings.targetUrl, changeOrigin: true});
                }
            }
        );
};

module.exports = {
    inject,
    httpProxy
};
