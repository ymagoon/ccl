/**
 * @fileoverview TableBody Class
 * @author Gyandeep Singh
 */

"use strict";

import { default as UIComponent, mediaQuery } from "../../../base";
import TableSectionContainer from "./TableSectionContainer";
import classNames from "classnames";
import { eventNames } from "./helpers";
import {
    addWindowResizeListener,
    removeWindowResizeListener
} from "../../../helpers/dom/dom";

/**
 * Create row container objects which internally creates TableSectionContainer objects
 * @param {Object} rows - Collection of row objects
 * @param {Object} subSections - collection of subsection objects
 * @param {Object} rowProps - Row properties object
 * @returns {Array} Returns the container object collection
 * @private
 */
const getRowContainerObject = ({ rows, subSections, rowProps, columns, cardView }) => {

    /*
     * This is where we give priority to subSection over rows.
     * If subSections is present then we will create the table with subsections
     */
    if (subSections.length > 0) {
        return subSections.reduce(
            (coll, data) => ({
                sections: [
                    ...coll.sections,
                    new TableSectionContainer({
                        index: coll.index,
                        columns,
                        display: data.display,
                        sectionIcon: data.sectionIcon,
                        key: data.key,
                        rows: data.rows,
                        rowProps,
                        isBodyVisible: data.expand !== false,
                        cardView
                    }, [])
                ],
                index: coll.index + data.rows.length
            }),
            {
                sections: [],
                index: 0
            }
        ).sections;
    }
    else {
        return [
            new TableSectionContainer({
                index: 0,
                columns,
                rows,
                rowProps,
                cardView
            }, [])
        ];
    }
};

/**
 * Update the row selected propert based on the current selection and
 * also based on whether its in multi select mode or not.
 * @param {Array.<object>} rows - rows collection
 * @param {string} key - Key of the row which has changed
 * @param {boolean} isSelected - Select status of the row with provided key
 * @param {boolean} multiSelect - Row multi select mode
 * @param {object} meta - Extra information when shift is click used
 * @returns {Array.<object>} rows - rows collection
 * @private
 */
const updateSelectedPropOnRows = (rows, key, isSelected, multiSelect, meta) => rows.reduce((rowCollection, row, index) => {
    if (meta) {
        // meta information is only present when shift key is used during selection
        // if meta is present and the row index falls within the selection range then mark that row selected
        // else mark that row unselected
        row.isSelected = (index + meta.sectionStartIndex) >= meta.selectionStartIndex &&
            (index + meta.sectionStartIndex) <= meta.selectionEndIndex;
    }
    else if (row.key === key) {
        row.isSelected = isSelected;
    }
    else if (!multiSelect) {
        row.isSelected = false;
    }

    if (row.isSelected) {
        rowCollection.push(row);
    }

    return rowCollection;
}, []);

/**
 * Return selection range as an array where first elem is smaller than other
 * @param {int} start - start index
 * @param {int} end - end index
 * @returns {Array<int>} Array start and end end where start is always smaller than end
 * @private
 */
const shiftSelectionRange = (start, end) => start < end ? [ start, end ] : [ end, start ];

/**
 * Returns a function which generates the meta info required when the shift key is pressed.
 * Otherwise it will return null if the shift is not pressed.
 * @param {Boolean} isShiftKey - True if the shift key is pressed
 * @param {int} shiftClickAnchorPosition - Initial shift key anchor position
 * @param {Array<int>} indexRange - Index range of the shift click
 * @returns {Function} which generates the meta info
 * @private
 */
const metaInfoGeneratorFunc = (isShiftKey, shiftClickAnchorPosition, indexRange) =>
    (sectionStartIndex) => isShiftKey && shiftClickAnchorPosition > -1 ?
        ({
            selectionStartIndex: indexRange[0],
            selectionEndIndex: indexRange[1],
            sectionStartIndex
        }) : null;

/**
 * Updates the sections data when the row selection happens
 * and return the selected rows from all sections
 * @param {Array<object>} sections - Collection of sections data
 * @param {object} options - different option collection
 * @returns {Array<object>} Collection of selected rows
 * @private
 */
const updateSectionsForSelection = (sections, options) =>
    sections.reduce(
        (coll, section) => ({
            sections: [
                ...coll.sections,
                ...updateSelectedPropOnRows(
                    section.rows,
                    options.rowKey,
                    options.isVisible,
                    options.isCtrlKey || options.isShiftKey,
                    options.metaInfoFunc(coll.index)
                )
            ],
            index: coll.index + section.rows.length
        }),
        {
            sections: [],
            index: 0
        }
    ).sections;

/**
 * Check if the current size of the screen is small or not
 * @returns {boolean} True it its small
 * @private
 */
const isSmallerScreen = () => mediaQuery.atMost("SM");

/**
 * Check if the supplied screen size different then current screen size
 * @param {boolean} isSmallView - if current view is mobile view or not
 * @returns {boolean} True if its different
 * @private
 */
const hasScreenSizeChanged = (isSmallView) => isSmallView !== isSmallerScreen();

/**
 * Constructor for TableBody
 * @extends UIComponent
 */
export default class TableBody extends UIComponent {
    /**
     * Constructor for the class
     * @param {Object} props - props accepted by the Table class
     * @param {Array<UIComponent>} children - Collection of UIComponent
     */
    constructor(props, children) {
        super(props, children);
        this._shiftClickAnchorPosition = -1;
        this._isCardView = isSmallerScreen(); // default to current screen size
        this._windowResizeHandler = this._windowResizeHandler.bind(this);
    }

    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            defaultClassNames: "mpageui-Table-body",
            classNames: "",
            rows: [],
            subSections: [],
            rowProps: {},
            columns: [],
            shiftAnchorPosition: -1
        };
    }

    /**
     * Create new instances of all the children with the updated data
     * @returns {undefined}
     * @private
     */
    _updateChildren() {
        this.replaceAllChildren(getRowContainerObject({
            rows: this.getProp("rows"),
            subSections: this.getProp("subSections"),
            rowProps: this.getProp("rowProps"),
            columns: this.getProp("columns"),
            cardView: this._isCardView
        }));
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            shiftAnchorPosition: (pos) => {
                this._shiftClickAnchorPosition = pos;
            }
        };
    }

    /**
     * @inheritDoc
     */
    dependentPropChangeHandlers() {
        return [
            [ "rows", "subSections", "columns", "rowProps", this._updateChildren.bind(this) ]
        ];
    }

    /**
     * Window resize handler, which would close the popup on resize
     * @returns {undefined}
     * @private
     */
    _windowResizeHandler() {
        if (hasScreenSizeChanged(this._isCardView)) { // only make change whenever their is a change in breakpoint
            this._isCardView = isSmallerScreen();
            this._updateChildren();
            this.update();
        }
    }

    /**
     * Event handler for table rows
     * @param {UIComponent} row - Row object
     * @param {boolean} isVisible - is the row visible or not
     * @param {boolean} isCtrlKey - Row is clicked with ctrl key
     * @param {boolean} isShiftKey - Row is clicked with shift key
     * @returns {undefined}
     * @private
     */
    _rowClickHandler(row, isVisible, { ctrlKey: isCtrlKey, shiftKey: isShiftKey }) {
        const subSections = this.getProp("subSections");
        const sections = subSections.length > 0 ? subSections : [ { rows: this.getProp("rows") } ];
        const selectedRows = updateSectionsForSelection(
            sections,
            {
                rowKey: row.getProp("key"),
                isVisible,
                isCtrlKey,
                isShiftKey,
                metaInfoFunc: metaInfoGeneratorFunc(
                    isShiftKey,
                    this._shiftClickAnchorPosition,
                    shiftSelectionRange(this._shiftClickAnchorPosition, row.getProp("index"))
                )
            }
        );

        if (!isShiftKey) {
            // always record the non-shift key clicked row as an anchor
            this._shiftClickAnchorPosition = row.getProp("index");
        }

        if (selectedRows.length === 0) {
            // if none of the rows are selected then basically we dont have an anchor
            this._shiftClickAnchorPosition = -1;
        }

        if (subSections.length > 0) {
            this.setProp("subSections", subSections);
        }
        else {
            this.setProp("rows", sections.pop().rows);
        }
        this.emit(this.getProp("rowProps").rowSelectionChangeEventName || eventNames.PUBLIC.ROW_SELECTION_CHANGE, {
            selected: selectedRows
        });
    }

    /**
     * Event handler for table sub section header
     * @param {UIComponent} sectionHeader - Sub section header object
     * @param {UIComponent} sectionObj - Sub section container object
     * @param {boolean} isVisible - is the row visible or not
     * @returns {undefined}
     * @private
     */
    _sectionHeaderClickHandler(sectionHeader, sectionObj, isVisible) {
        const subSections = this.getProp("subSections");

        subSections.forEach((section) => {
            if (section.key === sectionObj.getProp("key")) {
                section.expand = isVisible;
            }
        });
        this.setProp("subSections", subSections);
    }

    /**
     * @inheritdoc
     */
    afterCreate() {
        /*
         * Row click handling
         */
        this.on(eventNames.PRIVATE.ROW_SELECTION_CHANGE, (...args) => {
            this.stopPropagation(eventNames.PRIVATE.ROW_SELECTION_CHANGE);
            this._rowClickHandler(...args);
        });

        /*
         * Subsection header click handling logic
         */
        this.on(eventNames.PUBLIC.SECTION_HEADER_CLICK, this._sectionHeaderClickHandler.bind(this));
    }

    /**
     * @inheritdoc
     */
    beforeRender() {
        if (hasScreenSizeChanged(this._isCardView)) { // only make change whenever their is a change in breakpoint
            this._isCardView = isSmallerScreen();
            this._updateChildren();
        }
    }

    /**
     * @inheritdoc
     */
    view(el, props) {
        return el(
            "div",
            {
                class: classNames({
                    [ props.defaultClassNames ]: true,
                    [ props.classNames ]: props.classNames.length > 0
                }),
                oncreate: () => addWindowResizeListener(this._windowResizeHandler),
                onremove: () => removeWindowResizeListener(this._windowResizeHandler)
            },
            this.renderChildren()
        );
    }
}
