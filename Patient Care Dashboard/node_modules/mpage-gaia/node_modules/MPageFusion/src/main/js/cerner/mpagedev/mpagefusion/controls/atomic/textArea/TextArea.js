"use strict";
import UIComponent from "../../../base";
import classNames from "classnames";
import { setProp } from "../../../helpers/props/props";
import { isIE } from "../../../helpers/core/compatibility";

const EVENTS = {
    INPUT: "TextArea::input",
    BLUR: "TextArea::blur",
    FOCUS: "TextArea::focus"
};

/**
 * Updates textarea height to display all content.
 * Height of container div flexes as height of hidden span flexes.
 * @param {HTMLElement} elem - The textArea element
 * @param {Object} ctx - The execution context
 * @returns {undefined} Returns nothing.
 * @private
 */
const resizeTextArea = (elem, ctx) => {
    const pre = elem.previousElementSibling;
    // update span content
    pre.firstElementChild.textContent = ctx._state.value; // eslint-disable-line no-underscore-dangle
};

/**
 * Handles the oninput event.
 * @param {Object} e - Event instance oninput from the textArea
 * @returns {undefined} Returns nothing.
 * @private
 */
const handleInput = function(e) {
    const textArea = e.target;

    /**
     * IE fires an input event after the focus event
     * when input is empty and placeholder exists
     */
    if (isIE() && e && e.type === "input" && !textArea.value && textArea.value === this._state.value && textArea.placeholder) {
        return;
    }

    this._state.value = textArea.value; // eslint-disable-line no-underscore-dangle
    resizeTextArea(textArea, this);
    this.emit(this.getProp("inputEventName"), this, textArea.value);
};

/**
 * Handles the onblur event.
 * @param {Object} e - Event instance onblur from the textArea
 * @returns {undefined} Returns nothing.
 * @private
 */
const handleBlur = function(e) {
    const payload = e.target.value;
    this.emit(this.getProp("blurEventName"), this, payload);
};

/**
 * Handles the focus event.
 * @param {Object} e - Event instance onfocus from the textarea
 * @returns {undefined} Returns nothing.
 * @private
 */
const handleFocus = function(e) {
    this.emit(this.getProp("focusEventName"), e);
};

/**
 * returns an onCreate handler given the control context
 * @param {UIComponent} control - the textarea instance
 * @returns {function} onCreate handler
 */
const generateOnCreateTextArea = (control) => ({ dom }) => { /* eslint-disable no-underscore-dangle */
    const span = dom.children[0].children[0];
    const textArea = dom.children[1];

    if (textArea.value !== control._state.value) {
        textArea.value = control._state.value;
        // adjusts height
        span.textContent = control._state.value;
    } /* eslint-enable no-underscore-dangle */
};

/**
 * returns an onUpdate handler given the control context
 * @param {UIComponent} control - the textarea instance
 * @returns {function} onUpdate handler
 */
const generateOnUpdateTextArea = (control) => ({ dom }) => { /* eslint-disable no-underscore-dangle */
    if (control._state.setValue) {
        const span = dom.children[0].children[0];
        const textArea = dom.children[1];

        if (textArea.value !== control._state.value) {
            textArea.value = control._state.value;
            // adjusts height
            span.textContent = control._state.value;
        }
        control._state.setValue = false;
    } /* eslint-enable no-underscore-dangle */
};

/**
 *  Creates the maxlength attribute
 *  @param {Object} props - Textarea props.
 *  @returns {Object} - Contains the maxlength attribute for textarea.
 *  @private
 */
const maxLengthAttribute = (props) => props.maxLength ? setProp("maxlength", props.maxLength, {}) : null;

/**
 *  Creates the hidden mirror elements used in textarea resize.
 *  Span is wrapped inside pre to preserve whitespaces.
 *  Height of span is used to flex height of container div.
 *  Absolute positioned textarea expands to fit size of container div.
 *  @param {VDom} el - vDom creation function.
 *  @returns {VDom} - vdom structure
 *  @private
 */
const mirrorElement = (el) => el(
    "pre",
    {},
    [
        el("span", {}, []),
        el("br", {}, [])
    ]
);

/**
 * The TextArea class.
 * @class TextArea
 */
class TextArea extends UIComponent {
    /**
     * @inheritDoc
     */
    beforeCreate() {
        this._state = {
            setValue: false,
            value: ""
        };
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            blurEventName: EVENTS.BLUR,
            classNames: "",
            focusEventName: EVENTS.FOCUS,
            inputEventName: EVENTS.INPUT,
            isDisabled: false,
            isReadOnly: false,
            maxLength: null,
            placeholder: "",
            value: ""
        };
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            value: (value) => {
                this._state.setValue = true;
                this._state.value = value;
            }
        };
    }

    /**
     * @inheritDoc
     */
    view(el, props, children) {
        return el(
            "div",
            {
                class: classNames({
                    "mpageui-TextArea": true,
                    [ props.classNames ]: (props.classNames !== "")
                }),
                oncreate: generateOnCreateTextArea(this),
                onupdate: generateOnUpdateTextArea(this)
            },
            [
                mirrorElement(el),
                el(
                    "textarea",
                    Object.assign({
                        disabled: props.isDisabled,
                        onblur: handleBlur.bind(this),
                        onfocus: handleFocus.bind(this),
                        oninput: handleInput.bind(this),
                        placeholder: props.placeholder,
                        readOnly: props.isReadOnly
                    }, maxLengthAttribute(props)),
                    []
                )
            ]
        );
    }
}

/**
 * Events ENUM
 * @type {{INPUT: string}}
 * @type {{BLUR: string}}
 * @type {{FOCUS: string}}
 */
TextArea.EVENTS = EVENTS;
export default TextArea;
