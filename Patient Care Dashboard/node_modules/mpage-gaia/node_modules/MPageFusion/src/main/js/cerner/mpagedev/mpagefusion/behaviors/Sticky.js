import { last, nextInArray } from "../helpers/core/array";
import { top,
    height
} from "../helpers/dom/positioning";
import { asDomElement } from "../helpers/dom/dom";

/**
 * Sorts a list of reference content pairs according to the position
 * of the reference element in the DOM.
 * @param {Array<*>} elements - the array of reference content pairs
 * @returns {Array<*>} the sorted Array
 */
const sortElements = (elements) =>
    elements.sort(
        (a, b) => {
            if (a === b) {
                return 0;
            }

            const aElement = asDomElement(a.reference);
            const bElement = asDomElement(b.reference);

            // compareDocumentPosition returns a bitmask. 2^2 is set when
            // a preceds b on the document. Here we check to see if that bit
            // is set.
            if ((aElement.compareDocumentPosition(bElement) & 2) !== 0) {
                return 1;
            }
            return -1;
        }
    );
/**
 * Resets all styling attributes that were set when the element was
 * either stuck or in the transition state.
 *
 * @param {HTMLElement} element element to be reset
 * @returns {HTMLElement} the same element
 */
const resetElement = (element) => {
    const elementDom = asDomElement(element);
    elementDom.style.position = "";
    elementDom.style.top = "";
    elementDom.style.bottom = "";
    elementDom.style.height = "";
    elementDom.style.width = "";
    return element;
};

/**
 * Absolute positions the element. Will automatically calculate its
 * position relative to the offest parent, so position can be provided
 * in window relative pixels.
 *
 * @param {String | HTMLElement} container the scrolling container
 * @param {Object} element the sticky element
 * @param {Integer} position final element position relative to viewport
 * @returns {HTMLElement} the element
 */
const positionElement = (container, element, position) => {
    const content = asDomElement(element.content);
    const reference = asDomElement(element.reference);
    const positionDetails = element.positionDetails;
    const positionRelativeToOffsetParent = position - positionDetails.offsetParentTop;
    const contentHeight =
          positionDetails.contentRect.height;

    reference.style.height = `${contentHeight}px`;
    content.style.position = "absolute";
    content.style.width = "100%";
    content.style.top = `${positionRelativeToOffsetParent}px`;
    return element;
};

const positionOfOffsetParent = (element) =>
    (element.offsetParent === document.body || !element.offsetParent) ? 0 : top(element.offsetParent);


/**
 * Returns object containing position details for a passed element. Cached initially to avoid forcing layout recalculations.
 * @param  {Object} element The object for the element to query position details for
 * @returns {Object} position details for the passed element
 */
const queryPositionDetails = (element) => {
    const content = asDomElement(element.content);
    const reference = asDomElement(element.reference);
    return {
        "contentRect": content.getBoundingClientRect(),
        "referenceRect": reference.getBoundingClientRect(),
        "contentStyle": window.getComputedStyle(content),
        "contentHeight": height(content),
        "offsetParentTop": positionOfOffsetParent(content),
        "position": content.style.position
    };
};

/**
 * Fixes the stuckElement at the top of container.
 * @param {String | HTMLElement} stuckElement the element currently stuck
 * @param {String | HTMLElement} container the scrolling container
 * @param {Integer} containerTop The top position of the container element
 * @returns {undefined} undefined
 */
const stickElementToTop = (stuckElement, container, containerTop) => {
    const content = asDomElement(stuckElement.content);
    const reference = asDomElement(stuckElement.reference);
    const contentRect = stuckElement.positionDetails.contentRect;
    const referenceRect = stuckElement.positionDetails.referenceRect;

    reference.style.height = `${contentRect.height}px`;
    content.style.position = "fixed";
    content.style.width = `${referenceRect.width}px`;
    content.style.top = `${containerTop}px`;
};

/**
 * Returns all elements that are above the container top.
 *
 * @param {Array<String | HTMLElement>} elements list of elements
 * @param {String | HTMLElement} container the scrolling container
 * @param {Number} containerTop The top position of the container element
 * @returns {Array<HTMLElement>} elements above the top of container
 */
const elementsAboveTop = (elements, container, containerTop) =>
    elements.filter((element) => element.positionDetails.referenceRect.top < containerTop);

/**
 * Detects which element should be stuck at the top of the container by
 * checking which one is the last reference to be above the container
 * top.
 *
 * @param {Array<Object>} elements list of elements
 * @param {HTMLElement} container the scrolling container
 * @param {Number} containerTop The top position of the container element
 * @returns {HTMLElement} the stuck element
 */
const detectStuckElement = (elements, container, containerTop) =>
    last(elementsAboveTop(elements, container, containerTop));
/**
 * Detects whether we are in a transitional state between two elements and
 * adjusts the stuck position to be right above or below the previous or next
 * elements.
 *
 * @param {Array<Object>} elements list of elements
 * @param {Object} stuckElement the stuck element
 * @param {String | HTMLElement} container the scrolling container
 * @param {Number} containerTop The top position of the container element
 * @returns {undefined} undefined
 */
const processTransition = (elements, stuckElement, container, containerTop) => {
    const nextElement = nextInArray(elements, stuckElement);
    const stuckElementRect = stuckElement.positionDetails.contentRect;

    if (nextElement) {
        const nextElementRect = nextElement.positionDetails.referenceRect;
        if (nextElementRect.top - containerTop <= stuckElementRect.height) {
            positionElement(container, stuckElement, nextElementRect.top - stuckElementRect.height);
        }
    }
};

/**
 * Determins whether an element is currently fixed
 * @param  {Object} element Object containing details of element to determine if fixed
 * @returns {Boolean}        True if element is fixed, false otherwise
 */
const isFixed = (element) => {
    const position = element.positionDetails.position;
    return position === "fixed" || position === "absolute";
};

/**
 * Sticks the correct element to the top of container taking into account its
 * scroll position. Will also ensure a smooth transition between one stuck
 * element and the next by "gluing" them together.
 *
 * @param {Array<String | HTMLElement>} elements list of elements
 * @param {String | HTMLElement} container the scrolling container
 * @returns {undefined} undefined
 */
const update = (elements, container) => {
    // Cache DOM reads
    elements.forEach((element) => {
        element.positionDetails = queryPositionDetails(element);
    });
    const containerTop = top(container);

    // Sticks the element closest to the container top
    const stuckElement = detectStuckElement(elements, container, containerTop);
    // DOM Writes
    // Reset all elements that should no longer be fixed
    elements.filter((element) => (element !== stuckElement) && isFixed(element)).forEach((element) => {
        resetElement(element.content);
        resetElement(element.reference);
    });

    if (!stuckElement) {
        return;
    }
    stickElementToTop(stuckElement, container, containerTop);
    // Glue elements together if in a transition
    processTransition(elements, stuckElement, container, containerTop);
};

/**
 * Allows a set of elements specified by setElements to be sticked to the top of
 * a specified container (setContainer) when the container scrolls.
 * After each scroll, update() must be called so that the element updates take
 * place.
 */
export default class Sticky {

    constructor() {
        this._elements = [];
        this._container = null;
        this._sorted = false;
    }

    /**
     * Sets the DOM element that contains the sticky elements.
     *
     * @param {String | HTMLElement} container - container ID or Element
     * @returns {undefined} undefined
     */
    setContainer(container) {
        this._container = container;
    }

    /**
     * Sets the elements that will be stuck to the top of the container.
     * This is an array of objects in the format {reference: ..., content: ...}
     * , where reference is a parent of content and content is the element that
     * will be stuck to the top. Reference will never be moved but it
     * is used to detect which elements should be stuck.
     *
     * @param {Array<*>} elements - elements to be stuck
     * @returns {undefined} undefined
     */
    setElements(elements) {
        this._elements = elements;
        this._sorted = false;
    }

    /**
     * Returns the elements to be stuck.
     * @returns {Array<*>} the elements
     */
    getElements() {
        return this._elements;
    }

    /**
     * Inserts an element into the elements array.
     * @see setElements
     * @param {*} element - see setElements for element specification
     * @returns {undefined} undefined
     */
    addElement(element) {
        this._elements.push(element);
        this._sorted = false;
    }

    /**
     * Function to be executed to update headers prior to the next repaint
     * @returns {undefined} undefined
     */
    updateOnAnimationFrame() {
        this._ticking = false;
        update(this._elements, this._container);
    }

    /**
     * Sticks the correct element to the top of container taking into account its
     * scroll position. Will also ensure a smooth transition between one stuck
     * element and the next by "gluing" them together. This should be called
     * everytime there is a scroll event on the container.
     *
     * @returns {undefined} undefined
     */
    update() {
        if (!this._elements.length) {
            return;
        }

        // do not update if the elements are not built
        if (!asDomElement(this._elements[0].content)) {
            return;
        }

        if (!this._sorted) {
            this._elements = sortElements(this._elements);
            this._sorted = true;
        }
        update(this._elements, this._container);
    }
}
