/**
 * @fileoverview TableBody Class
 * @author Gyandeep Singh
 */

"use strict";

import UIComponent from "../../../base";
import FlowsheetSectionContainer from "./FlowsheetSectionContainer";
import classNames from "classnames";
import { eventNames } from "./helpers";

/**
 * Create row container objects which internally creates FlowsheetSectionContainer objects
 * @param {Object} rows - Collection of row objects
 * @param {Object} subSections - collection of subsection objects
 * @param {Object} rowProps - Row properties object
 * @param {Object} cellProps - Row Cell properties object
 * @returns {Array} Returns the container object collection
 * @private
 */
const getRowContainerObject = ({ rows, subSections, rowProps, cellProps }) => {

    /*
     * This is where we give priority to subSection over rows.
     * If subSections is present then we will create the table with subsections
     */
    if (subSections.length > 0) {
        return subSections.reduce(
            (coll, data) => ({
                sections: [
                    ...coll.sections,
                    new FlowsheetSectionContainer({
                        index: coll.index,
                        display: data.display,
                        key: data.key,
                        rows: data.rows,
                        rowProps,
                        cellProps,
                        isBodyVisible: data.isExpanded !== false,
                        isNoResultsSubtitleVisible: data.isNoResultsSubtitleVisible
                    }, [])
                ],
                index: coll.index + data.rows.length
            }),
            {
                sections: [],
                index: 0
            }
        ).sections;
    }
    else {
        return [
            new FlowsheetSectionContainer({
                index: 0,
                rows,
                rowProps,
                cellProps
            }, [])
        ];
    }
};

/**
 * Update the row selected propert based on the current selection and
 * also based on whether its in multi select mode or not.
 * @param {Array.<object>} rows - rows collection
 * @param {string} key - Key of the row which has changed
 * @param {boolean} isSelected - Select status of the row with provided key
 * @param {boolean} multiSelect - Row multi select mode
 * @param {object} meta - Extra information when shift is click used
 * @returns {Array.<object>} rows - rows collection
 * @private
 */
const updateSelectedPropOnRows = (rows, key, isSelected, multiSelect, meta) => rows.reduce((rowCollection, row, index) => {
    if (meta) {
        // meta information is only present when shift key is used during selection
        // if meta is present and the row index falls within the selection range then mark that row selected
        // else mark that row unselected
        row.isSelected = (index + meta.sectionStartIndex) >= meta.selectionStartIndex &&
            (index + meta.sectionStartIndex) <= meta.selectionEndIndex;
    }
    else if (row.key === key) {
        row.isSelected = isSelected;
    }
    else if (!multiSelect) {
        row.isSelected = false;
    }

    row.header.isSelected = row.isSelected;

    if (row.isSelected) {
        rowCollection.push(row);
    }

    return rowCollection;
}, []);

/**
 * Return selection range as an array where first elem is smaller than other
 * @param {int} start - start index
 * @param {int} end - end index
 * @returns {Array<int>} Array start and end end where start is always smaller than end
 * @private
 */
const shiftSelectionRange = (start, end) => start < end ? [ start, end ] : [ end, start ];

/**
 * Returns a function which generates the meta info required when the shift key is pressed.
 * Otherwise it will return null if the shift is not pressed.
 * @param {Boolean} isShiftKey - True if the shift key is pressed
 * @param {int} shiftClickAnchorPosition - Initial shift key anchor position
 * @param {Array<int>} indexRange - Index range of the shift click
 * @returns {Function} which generates the meta info
 * @private
 */
const metaInfoGeneratorFunc = (isShiftKey, shiftClickAnchorPosition, indexRange) =>
    (sectionStartIndex) => isShiftKey && shiftClickAnchorPosition > -1 ?
        ({
            selectionStartIndex: indexRange[ 0 ],
            selectionEndIndex: indexRange[ 1 ],
            sectionStartIndex
        }) : null;

/**
 * Given an array of [row, column] points in the flowsheet, this function creates a
 * bounding box which encloses all points.
 * @param {[number, number][]} points - The list of points.
 * @returns {{ start: [number, number], end: [number, number] }} Bounding box.
 */
const createSelectionBox = (points = []) =>
    points.reduce(
        ({ start, end }, [ row, column ]) => ({
            start: [ Math.min(start[ 0 ], row), Math.min(start[ 1 ], column) ],
            end: [ Math.max(end[ 0 ], row), Math.max(end[ 1 ], column) ]
        }), {
            start: [ Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY ],
            end: [ Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY ]
        }
    );

const isInsideSelectionBox = (box) => (rowIndex, cellIndex) =>
    rowIndex >= box.start[ 0 ] && rowIndex <= box.end[ 0 ]
    && cellIndex >= box.start[ 1 ] && cellIndex <= box.end[ 1 ];

/**
 * Updates the sections data when the row selection happens
 * and return the selected rows from all sections
 * @param {Array<object>} sections - Collection of sections data
 * @param {object} options - different option collection
 * @returns {Array<object>} Collection of selected rows
 * @private
 */
const updateSectionsForSelection = (sections, options) =>
    sections.reduce(
        (coll, section) => ({
            sections: [
                ...coll.sections,
                ...updateSelectedPropOnRows(
                    section.rows,
                    options.rowKey,
                    options.isVisible,
                    options.isCtrlKey || options.isShiftKey,
                    options.metaInfoFunc(coll.index)
                )
            ],
            index: coll.index + section.rows.length
        }),
        {
            sections: [],
            index: 0
        }
    ).sections;

/**
 * Constructor for TableBody
 * @extends UIComponent
 */
export default class FlowsheetBody extends UIComponent {
    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            defaultClassNames: "mpageui-Flowsheet-body",
            classNames: "",
            rows: [],
            subSections: [],
            rowProps: {},
            cellProps: {},
            minWidth: ""
        };
    }

    /**
     * @inheritdoc
     */
    createChildren() {
        return getRowContainerObject({
            rows: this.getProp("rows"),
            subSections: this.getProp("subSections"),
            rowProps: this.getProp("rowProps"),
            cellProps: this.getProp("cellProps")
        });
    }

    /**
     * Create new instances of all the children with the updated data
     * @returns {undefined}
     * @private
     */
    _updateChildren() {
        this.replaceAllChildren(this.createChildren());
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            rows: this._updateChildren.bind(this),
            subSections: this._updateChildren.bind(this)
        };
    }

    /**
     * Create new instances of all the children with the updated data
     * @returns {undefined}
     * @private
     */
    _unSelectSelectedCells() {
        this._selectedCells.forEach((cell) => {
            cell.isSelected = false;
        });
        this._selectedCells = [];
    }

    /**
     * Create new instances of all the children with the updated data
     * @returns {undefined}
     * @private
     */
    _unSelectSelectedRows() {
        this._selectedRows.forEach((row) => {
            row.isSelected = false;
            row.header.isSelected = false;
        });
        this._selectedRows = [];
    }

    /**
     * Event handler for table rows
     * @param {UIComponent} rowObj - Row object
     * @param {boolean} isVisible - is the row visible or not
     * @param {boolean} isHotKeySelect - Row is clicked with ctrl or shift key
     * @returns {undefined}
     * @private
     */
    _rowClickHandler(rowObj, isVisible, { ctrlKey: isCtrlKey, shiftKey: isShiftKey }) {
        const subSections = this.getProp("subSections");
        const sections = subSections.length > 0 ? subSections : [ { rows: this.getProp("rows") } ];

        this._unSelectSelectedCells();
        if (!isCtrlKey && !isShiftKey) {
            this._unSelectSelectedRows();
        }

        this._selectedRows = updateSectionsForSelection(
            sections,
            {
                rowKey: rowObj.getProp("key"),
                isVisible,
                isCtrlKey,
                isShiftKey,
                metaInfoFunc: metaInfoGeneratorFunc(
                    isShiftKey,
                    this._shiftRowClickAnchorPosition,
                    shiftSelectionRange(this._shiftRowClickAnchorPosition, rowObj.getProp("index"))
                )
            }
        );

        /*
         * When selecting rows, we always undo any anchoring for cell clicks.
         */
        this._shiftCellClickAnchorPosition = -1;

        if (!isShiftKey || this._shiftRowClickAnchorPosition === -1) {
            // always record the non-shift key clicked row as an anchor
            this._shiftRowClickAnchorPosition = rowObj.getProp("index");
        }

        if (this._selectedRows.length === 0) {
            // if none of the rows are selected then basically we dont have an anchor
            this._shiftRowClickAnchorPosition = -1;
        }

        if (subSections.length > 0) {
            this.setProp("subSections", subSections);
        }
        else {
            this.setProp("rows", sections.pop().rows);
        }

        this.emit(this.getProp("rowProps").rowSelectionChangeEventName || eventNames.PUBLIC.ROW_SELECTION_CHANGE, {
            selected: this._selectedRows
        });
    }

    /**
     * Event handler for table rows
     * @param {UIComponent} cellObj - Row object
     * @param {boolean} isVisible - is the row visible or not
     * @param {boolean} isHotKeySelect - Row is clicked with ctrl or shift key
     * @returns {undefined}
     * @private
     */
    _rowCellClickHandler(cellObj, isVisible, { ctrlKey: isCtrlKey, shiftKey: isShiftKey }) {
        const subSections = this.getProp("subSections");
        const sections = subSections.length > 0 ? subSections : [ { rows: this.getProp("rows") } ];
        const rowKey = cellObj.getParent().getProp("key");
        const cellKey = cellObj.getProp("key");

        this._unSelectSelectedRows();
        if (!isCtrlKey) {
            this._unSelectSelectedCells();
        }

        /*
         * When selecting cells, we always undo any anchoring for row clicks.
         */
        this._shiftRowClickAnchorPosition = -1;

        if (isShiftKey && this._shiftCellClickAnchorPosition !== -1) {
            /*
             * By keeping track of the [row, column] position of the clicked anchor as well as the new
             * [row, column] that was just clicked, we create a range "box". If a cell falls inside the
             * bounds of this box, it is considered selected.
             */
            const point = cellObj.getProp("index").split("-").map((p) => parseInt(p, 10));
            const anchor = this._shiftCellClickAnchorPosition.split("-").map((p) => parseInt(p, 10));
            const isInsideBox = isInsideSelectionBox(createSelectionBox([
                anchor,
                point
            ]));

            sections.reduce((offset, section, sIndex) => {
                section.rows.forEach((row, rIdx) =>
                    row.cells.forEach((cell, cellIndex) => {
                        cell.isSelected = isInsideBox(offset + rIdx, cellIndex);

                        if (cell.isSelected) {
                            this._selectedCells.push(cell);
                        }
                    })
                );
                return offset + section.rows.length;
            }, 0);
        }
        else {
            sections.some((section) => {
                const parentRow = section.rows.find((row) => row.key === rowKey);

                if (parentRow) {
                    const cell = parentRow.cells.find((cellItem) => cellItem.key === cellKey);

                    if (cell) {
                        cell.isSelected = isVisible;

                        if (isVisible) {
                            this._selectedCells.push(cell);
                        }
                        else {
                            this._selectedCells.splice(this._selectedCells.indexOf(cell), 1);
                        }
                    }

                    return true;
                }

                return false;
            });
        }

        if (!isShiftKey || this._shiftCellClickAnchorPosition === -1) {
            // always record the non-shift key clicked row as an anchor
            this._shiftCellClickAnchorPosition = cellObj.getProp("index");
        }

        if (this._selectedCells.length === 0) {
            // if none of the rows are selected then basically we dont have an anchor
            this._shiftCellClickAnchorPosition = -1;
        }

        if (subSections.length > 0) {
            this.setProp("subSections", subSections);
        }
        else {
            this.setProp("rows", sections.pop().rows);
        }

        this.emit(this.getProp("cellProps").rowCellSelectionChangeEventName || eventNames.PUBLIC.ROW_CELL_SELECTION_CHANGE, {
            selected: this._selectedCells
        });
    }

    /**
     * Event handler for table sub section header
     * @param {UIComponent} sectionHeader - Sub section header object
     * @param {UIComponent} sectionObj - Sub section container object
     * @param {boolean} isVisible - is the row visible or not
     * @returns {undefined}
     * @private
     */
    _sectionHeaderClickHandler(sectionHeader, sectionObj, isVisible) {
        this.setProp("subSections", this.getProp("subSections").map((section) => {
            if (section.key === sectionObj.getProp("key")) {
                section.isExpanded = isVisible;
            }

            return section;
        }));
    }

    /**
     * Update internal selection state for the first run
     * this needs to be done so that we can collect already selected data.
     * @returns {undefined}
     * @private
     */
    _updateSelectionState() {
        const subSections = this.getProp("subSections");
        const sections = subSections.length > 0 ? subSections : [ { rows: this.getProp("rows") } ];

        this._selectedCells = [];
        this._selectedRows = [];

        sections.forEach((section) => section.rows.forEach((row) => {
            if (row.isSelected) {
                this._selectedRows.push(row);
            }

            row.cells.forEach((cell) => {
                if (cell.isSelected) {
                    this._selectedCells.push(cell);
                }
            });
        }));
    }

    /**
     * @inheritdoc
     */
    afterCreate() {
        this._shiftRowClickAnchorPosition = -1;
        this._shiftCellClickAnchorPosition = -1;
        /*
         * Row click handling
         */
        this.on(eventNames.PRIVATE.ROW_SELECTION_CHANGE, (...args) => {
            this.stopPropagation(eventNames.PRIVATE.ROW_SELECTION_CHANGE);
            this._rowClickHandler(...args);
        });

        /*
         * Cell click handling
         */
        this.on(eventNames.PRIVATE.ROW_CELL_SELECTION_CHANGE, (...args) => {
            this.stopPropagation(eventNames.PRIVATE.ROW_SELECTION_CHANGE);
            this._rowCellClickHandler(...args);
        });

        /*
         * Subsection header click handling logic
         */
        this.on(eventNames.PUBLIC.SECTION_HEADER_CLICK, this._sectionHeaderClickHandler.bind(this));

        this._updateSelectionState();
    }

    /**
     * @inheritdoc
     */
    view(el, props, children) {
        return el("div", {
            class: classNames({
                [ props.defaultClassNames ]: true,
                [ props.classNames ]: props.classNames.length > 0
            }),
            style: {
                "min-width": props.minWidth
            }
        }, this.renderChildren());
    }
}
