/**
 * @fileoverview TableRow class
 * @author Gyandeep Singh
 */

"use strict";

import UIComponent from "../../../base";
import TableRowCell from "./TableRowCell";
import TableActionContent from "./TableActionContent";
import Card from "../card";
import classNames from "classnames";
import { dataTypes } from "./helpers";
import {
    isSelectedClassName as selectedClass,
    isNotSelectableClassName
} from "../../../helpers/const/classNames";
import { collapseDocumentSelection } from "../../../helpers/dom/dom";

/*
 * Constants for different values
 */
const hoverClass = "hoverable";
const rowWrapperClass = "mpageui-Table-row-wrapper";
const rowIndicatorClass = "mpageui-Table-row-indicator";

/**
 * CSS classname based on the size span
 * @param {int} [sizeSpan=1] - size of the cell
 * @returns {string} CSS class name
 */
const getSizeSpanClassName = (sizeSpan = 1) => `mpageui-Table-row-cell--size${sizeSpan}`;

/**
 * Merges and return new props for cell
 * default -> column level props for cell -> cell level props
 * @param {Object} columnProps - column props
 * @param {Object} cellProps - cell props
 * @returns {Object} merged props for cell
 * @private
 */
const mergeCellProps = (columnProps, cellProps) => Object.assign({ type: dataTypes.DEFAULT }, columnProps, cellProps);

/**
 * Generates the CSS class names for a cell based on the type of content in it
 * for icon type dont add size class since icon size is always fixed
 * @param {string<dataTypes>} type - data type of the cell
 * @param {int} sizeSpan - size span for the cell
 * @returns {string} CSS class name for the cell
 * @private
 */
const getClassNamesForCell = ({ type, sizeSpan }) =>
    type !== dataTypes.ICON ? `${getSizeSpanClassName(sizeSpan)} ${type}` : type;

/**
 * Sort all the cells based on their types. return the sorted cells.
 * @param {Array<Object>} cells - Cell objects
 * @param {Array<Object>} columnProps - collection of all the columns with their props
 * @returns {Object} Sorted cell collection
 * @private
 */
const sortCellsByDataTypes = (cells, columnProps) => cells.reduce(
    (coll, cell, index) => {
        coll[ mergeCellProps(columnProps[ index ], cell).type ].push(cell);

        return coll;
    },
    {
        [ dataTypes.DEFAULT ]: [],
        [ dataTypes.ICON ]: [],
        [ dataTypes.ACTION ]: []
    }
);

/**
 * Return content of the cell as it unless it is an actionable type then
 * return the content wrapped inside TableActionContent
 * @param {Object} cell - Cell objects
 * @returns {Array<Object>} cell content
 * @private
 */
const getContent = (cell) =>
    cell.type === dataTypes.ACTION ?
        ([
            new TableActionContent({
                content: cell.content
            })
        ]) :
        cell.content;

/**
 * Get the content of the cell if present otherwise return an empty array
 * @param {Object} cell - Cell objects
 * @returns {Array<UIComponent>} cell content
 * @private
 */
const getContentForCell = (cell) =>
    cell.content && cell.content.length > 0 ? getContent(cell) : [];

/**
 * Create the TableRowCell object for each cell based on cell props
 * @param {Object} cell - cell with its props
 * @param {int} index - location inside the cell collection
 * @returns {TableRowCell} TableRowCell object
 * @private
 */
const getTableCell = (cell, index) => new TableRowCell({
    columnNumber: index,
    columnDisplay: cell.label || "",
    display: cell.display,
    title: cell.title || "",
    classNames: `${getClassNamesForCell(cell)}`,
    content: getContentForCell(cell),
    contentClassNames: cell.contentClassNames || "",
    selectable: cell.selectable === true,
    clickEventName: cell.clickEventName || "tableRowCellClick",
    key: cell.key || ""
}, []);

/**
 * Create objects of TableRowCell class
 * @param {Object} cells - cells objects
 * @param {boolean} dualColumn - dual col on smaller view or not
 * @param {Array.<Object>} columns - Collection of columns
 * @returns {Array<TableRowCell>} Collection of TableRowCell objects
 */
const getCellObjects = ({ cells, dualColumn, columns }) =>
    cells.map((cell, index) => getTableCell(mergeCellProps(columns[ index ], cell), index));

/**
 * Create objects of TableRowCell class
 * @param {Object} cells - cells objects
 * @param {Object} props - dual col on smaller view or not
 * @returns {Array} Collection of TableRowCell objects
 */
const getCardObject = ({ cells, props }) => [
    new Card({
        isDualColumn: props.dualColumn,
        isSelectable: false,
        isSelected: props.isSelected,
        hasProgressiveDisclosure: props.selectable,
        truncate: true, // as per current table design
        leftStrip: props.indicator,
        leftAccessory: cells[ dataTypes.ICON ].length > 0 ? cells[ dataTypes.ICON ][ 0 ].content[ 0 ] : null,
        items: cells[ dataTypes.DEFAULT ].map((cell) => ({
            value: cell.display || "",
            label: cell.label || "",
            content: cell.content || [],
            contentClassNames: cell.contentClassNames
        }))
    })
];

/**
 * Constructor for TableRow
 * @extends UIComponent
 */
export default class TableRow extends UIComponent {
    /**
     * @inheritdoc
     */
    initialProps() {
        return {
            key: "",
            defaultClassNames: "mpageui-Table-row",
            classNames: "",
            hoverable: false,
            selectable: false,
            multiSelect: false,
            isSelected: false,
            cells: [],
            dualColumn: false,
            clickEventName: "tableRowClick",
            meta: null,
            columns: [],
            index: 0,
            cardView: false,
            indicator: ""
        };
    }

    /**
     * @inheritdoc
     */
    createChildren() {
        return this.getProp("cardView") ?
            getCardObject({
                cells: sortCellsByDataTypes(this.getProp("cells"), this.getProp("columns")),
                props: this.getProps()
            }) :
            getCellObjects({
                cells: this.getProp("cells"),
                dualColumn: this.getProp("dualColumn"),
                columns: this.getProp("columns")
            });
    }

    /**
     * On click handler for the row
     * @param {Event} event - Click event object
     * @returns {undefined}
     * @private
     */
    _onClick(event) {
        if (event.shiftKey) {
            collapseDocumentSelection();
        }

        this.setProp("isSelected", !this.getProp("isSelected"));
        this.emit(
            this.getProp("clickEventName"),
            this,
            this.getProp("isSelected"),
            {
                ctrlKey: this.getProp("multiSelect") && event.ctrlKey,
                shiftKey: this.getProp("multiSelect") && event.shiftKey
            }
        );
        this.update();
    }

    /**
     * @inheritdoc
     */
    view(el, props) {
        return el(
            "div",
            {
                class: classNames({
                    [ rowWrapperClass ]: true,
                    [ selectedClass ]: !props.cardView && props.isSelected,
                    [ hoverClass ]: props.hoverable === true && props.isSelected === false
                }),
                onclick: props.selectable ? this._onClick.bind(this) : null,
                key: props.key
            },
            [
                !props.cardView ? el(
                    "div",
                    {
                        class: classNames({
                            [ rowIndicatorClass ]: true,
                            [ isNotSelectableClassName ]: true,
                            [ props.indicator ]: props.indicator.length > 0
                        })
                    },
                    ""
                ) : null,
                el(
                    "div",
                    {
                        class: classNames({
                            [ props.defaultClassNames ]: true,
                            [ props.classNames ]: props.classNames.length > 0
                        })
                    },
                    this.renderChildren()
                )
            ]
        );
    }
}
