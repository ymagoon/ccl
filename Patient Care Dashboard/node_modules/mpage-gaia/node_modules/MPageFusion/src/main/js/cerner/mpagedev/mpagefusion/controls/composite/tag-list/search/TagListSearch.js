import UIComponent from "../../../../base";
import TagList from "../base/TagList";
import { InlineDropDown } from "../../../atomic/progressive-disclosure";
import { SearchList } from "../../search";
import { forwardProp } from "../../../../helpers/props/props";
import { isChildOf } from "../../../../helpers/dom/dom";
import { CONFIRM_TYPES, INPUT_TYPES, EVENTS, NAMESPACE, PRIVATE_EVENTS } from "./const";
import KEY_CODES from "../../../../helpers/const/keyCodes";
import { unique } from "../../../../helpers/core/generators";
import { isIE } from "../../../../helpers/core/compatibility";

const { nextIndexFromKeyCode } = SearchList.helpers.result;


/**
 * Small helper to emit optional events.
 * @param {TagListSearch} control - The TagListSearch.
 * @param {String} propName - The event name prop.
 * @param {*[]} params - Emit params.
 * @returns {undefined} Returns nothing.
 */
const optionalEmit = (control, propName, ...params) => {
    if (control.getProp(propName)) {
        control.emit(control.getProp(propName), ...params);
    }
};

/**
 * Small helper to decide if the suggestions should be shown.
 * @param {String} value - Current value of the input.
 * @param {Object[]} suggestions - Suggestion array.
 * @param {Boolean} isCollapsed - The collapsed state.
 * @param {Boolean} isFocused - Focused state.
 * @returns {Boolean} True if the suggestions should be shown, otherwise false.
 */
const shouldShowSuggestionMenu = (value, suggestions, isCollapsed, isFocused) =>
    (isFocused && !isCollapsed && (suggestions && suggestions.length) && value);

/**
 * TagList with built-in search functionality.
 * @class TagListSearch
 */
class TagListSearch extends UIComponent {
    constructor(props, children) {
        super(props, children);

        // Initialize internal state
        this._state = {
            isFocused: false,
            showAll: false,
            showMenu: false,
            wasEmpty: false,
            isCollapsed: true,
            selectedResultIndex: null,
            valueBeforeSuggest: null
        };

        // Event bindings
        this._handleKeyDown = this._handleKeyDown.bind(this);
        this._handleKeyUp = this._handleKeyUp.bind(this);
        this._handleMouseDown = this._handleMouseDown.bind(this);
        this._handleFocus = this._handleFocus.bind(this);
        this._handleBlur = this._handleBlur.bind(this);
        this._handleInput = this._handleInput.bind(this);

        this._mouseDown = false;
    }

    initialProps() {
        return {
            inputBlurEventName: null,
            inputEventName: null, // Required
            inputFocusEventName: null,
            inputPlaceholder: "",
            inputValue: "",
            inputFromSuggestion: (r) => r.data[ 0 ].display,
            key: unique(NAMESPACE),
            requestConfirmEventName: null, // Required
            requestDeleteEventName: null, // Required
            requestSuggestionsEventName: null, // Required
            requestClearSuggestionsEventName: null, // Required
            suggestions: [],
            tags: []
        };
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            tags: forwardProp(this, "tags", "tagList"),
            suggestions: (suggestions) => {
                this._hoistedChildren.searchList.setProp("results", suggestions);
            }
        };
    }

    /**
     * @inheritDoc
     */
    createChildren() {
        /*
         * Hoisted children are those that are passed to another child
         * but we still need direct access to, in order to make changes
         */
        this._hoistedChildren = {
            searchList: new SearchList({
                clickEventName: PRIVATE_EVENTS.RESULT_CLICK,
                shouldAutoScroll: true
            })
        };
        return [
            {
                tagList: new TagList({
                    requestShowAllEventName: PRIVATE_EVENTS.REQUEST_SHOW_ALL,
                    requestDeleteEventName: PRIVATE_EVENTS.REQUEST_DELETE,
                    classNames: `${NAMESPACE}-tagList`
                })
            },
            {
                dropDown: new InlineDropDown({
                    isVisible: false,
                    content: [
                        this._hoistedChildren.searchList
                    ]
                })
            }
        ];
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        this._handleSuggestionClick = this._handleSuggestionClick.bind(this);
        this._handleTagListRequestDelete = this._handleTagListRequestDelete.bind(this);
        this._handleTagListShowAll = this._handleTagListShowAll.bind(this);

        // TagList events
        this.on(PRIVATE_EVENTS.REQUEST_DELETE, this._handleTagListRequestDelete);
        this.on(PRIVATE_EVENTS.REQUEST_SHOW_ALL, this._handleTagListShowAll);

        // SearchList events
        this.on(PRIVATE_EVENTS.RESULT_CLICK, this._handleSuggestionClick);
    }

    /**
     * @inheritDoc
     */
    beforeRender() {
        const { suggestions, inputValue } = this.getProps();
        const { isCollapsed, isFocused, showAll } = this._state;


        // TagList
        this.getChild("tagList")
            .setProp("showAll", showAll);

        // Menu
        this.getChild("dropDown").setProps({
            isVisible: shouldShowSuggestionMenu(inputValue, suggestions, isCollapsed, isFocused)
        });

        // SearchList
        this._hoistedChildren.searchList.setProps({
            searchValue: inputValue,
            selectedIndex: this._state.selectedResultIndex
        });
    }

    /**
     * Helper to emit the input change event name with the value and the type
     * of event that triggered the input change.
     * @param {String} value - The input value.
     * @param {String} type - The type of event that triggered the input.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _emitInputChange(value, type) {
        this.emit(this.getProp("inputEventName"), this, {
            value,
            type
        });
    }

    /**
     * Helper to emit the request for suggestions.
     * @param {Object} payload - Payload for request of suggestions.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _emitRequestSuggestions(payload) {
        this.emit(this.getProp("requestSuggestionsEventName"), this, payload);
    }

    /**
     * Helper to emit the request to clear suggestions.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _emitRequestClearSuggestions() {
        this.emit(this.getProp("requestClearSuggestionsEventName"), this);
    }

    /**
     * Helper to close the suggestions and update any related state.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _closeSuggestions() {
        this._state = Object.assign({}, this._state, {
            isCollapsed: true,
            selectedResultIndex: null,
            valueBeforeSuggest: null
        });
        this.update();
    }

    /**
     * Helper to un-collapse the state of the suggestions.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _showSuggestions() {
        this._state = Object.assign({}, this._state, {
            isCollapsed: false
        });
        this.update();
    }

    /**
     * Handles the suggestion click event.
     * @param {SearchList} src - The source search list.
     * @param {Object} data - Event payload.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleSuggestionClick(src, data) {
        const { result, index } = data;
        const suggestion = Object.assign({}, result);
        const { inputValue } = this.getProps();

        this.stopPropagation(PRIVATE_EVENTS.RESULT_CLICK);

        if (!SearchList.helpers.result.isSelectable(result)) {
            return;
        }

        this.emit(this.getProp("requestConfirmEventName"), this, {
            index,
            value: inputValue,
            suggestion,
            type: CONFIRM_TYPES.CLICK
        });

        this._closeSuggestions();
    }

    /**
     * Handles the input event on the text input.
     * @param {Event} e - Input event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleInput(e) {
        const { value } = e.target;
        this._state = Object.assign({}, this._state, {
            isCollapsed: !e.target.value,
            selectedResultIndex: null,
            valueBeforeSuggest: null
        });
        this._emitInputChange(e.target.value, INPUT_TYPES.TYPE);

        /*
         * If the input has a value, use that to notify consumer
         * of a request for suggestions. Otherwise, consider it a
         * request to clear the suggestions.
         */
        if (e.target.value) {
            this._emitRequestSuggestions({ value });
        }
        else {
            this._emitRequestClearSuggestions();
        }
        this.update();
    }

    /**
     * Handles the mousedown event to make sure events do not trigger a blur
     * if they originated from within the suggestions menu.
     * @param {Event} e - Mousedown event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleMouseDown(e) {
        const belongsToTagList = isChildOf(this._menuElement);
        if (belongsToTagList(e.target)) {
            e.preventDefault();
            // checks if browser is Internet Explorer, if true then set mouseDown flag
            if(isIE(false)) {
                this._mouseDown = true;
            }
        }
    }

    /**
     * Handles the blur event.
     * @param {Event} e - Blur event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleBlur(e) {
        if(!this._mouseDown) {
            this._state = Object.assign({}, this._state, {
                isFocused: false,
                selectedResultIndex: null,
                valueBeforeSuggest: null
            });

            optionalEmit(this, "inputBlurEventName", this);
            this._emitRequestClearSuggestions();

            this.update();
        }
        // do not blur suggestion menu when clicked on scroll bar
        else {
            this._mouseDown = false;
            this._textElement.focus();
        }
    }

    /**
     * Handles the focus event for the tag list input.
     * @param {Event} e - Focus event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleFocus(e) {
        const { inputValue } = this.getProps();

        this._state = Object.assign({}, this._state, {
            isFocused: true,
            isCollapsed: !inputValue,
            showAll: false
        });

        optionalEmit(this, "inputFocusEventName", this);

        if (inputValue) {
            this._emitRequestSuggestions({ value: inputValue });
        }

        this.update();
    }

    /**
     * Handles the key up event.
     * @param {Event} e - The key up event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleKeyUp(e) {
        const { suggestions, inputValue } = this.getProps();
        const { selectedResultIndex, isCollapsed, isFocused, valueBeforeSuggest } = this._state;
        const isOpen = shouldShowSuggestionMenu(inputValue, suggestions, isCollapsed, isFocused);
        const suggestion = suggestions[ selectedResultIndex ];

        switch (e.keyCode) {
            case KEY_CODES.ENTER:
                if (inputValue) {
                    this._closeSuggestions();

                    this.emit(
                        this.getProp("requestConfirmEventName"),
                        this,
                        {
                            index: selectedResultIndex,
                            value: inputValue,
                            suggestion: suggestion ? Object.assign({}, suggestion) : null,
                            type: CONFIRM_TYPES.ENTER
                        }
                    );
                }
                break;
            case KEY_CODES.ESC:
                if (isOpen) {
                    e.preventDefault();
                }
                // Handle input
                if (valueBeforeSuggest === null) {
                    if (!isOpen) {
                        this._emitInputChange("", INPUT_TYPES.ESCAPE);
                        this._emitRequestClearSuggestions();
                    }
                }
                else {
                    this._emitInputChange(valueBeforeSuggest, INPUT_TYPES.ESCAPE);
                }

                // Handle menu state
                if (isOpen) {
                    this._emitRequestClearSuggestions();
                    this._closeSuggestions();
                }
                break;
        }
    }

    /**
     * Handles the key down event.
     * @param {Event} e - Key down event.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleKeyDown(e) {
        const { isCollapsed, valueBeforeSuggest, selectedResultIndex } = this._state;
        const { suggestions, inputValue, inputFromSuggestion } = this.getProps();
        let emitInput = "";

        this._state.wasEmpty = !e.target.value;

        if (e.keyCode !== KEY_CODES.ARROW_UP && e.keyCode !== KEY_CODES.ARROW_DOWN) {
            return;
        }

        // Prevent cursor from moving in the input
        e.preventDefault();

        // If collapsed, don't bother with moving the index, just reveal the suggestions
        if (isCollapsed) {
            if (inputValue) {
                this._emitRequestSuggestions({ value: inputValue });
                this._showSuggestions();
            }
        }
        else if (suggestions.length > 0) {
            // Calculate the next selection index
            const newIndex = nextIndexFromKeyCode(selectedResultIndex, suggestions, e.keyCode, true);

            this._state = Object.assign({}, this._state, {
                selectedResultIndex: newIndex,
                isCollapsed: false,
                valueBeforeSuggest: (!valueBeforeSuggest ? inputValue : valueBeforeSuggest)
            });
            if (newIndex === null) {
                emitInput = this._state.valueBeforeSuggest;
            }
            else {
                emitInput = inputFromSuggestion(suggestions[ newIndex ]);
            }
            this._emitInputChange(
                emitInput,
                e.keyCode === KEY_CODES.ARROW_UP ? INPUT_TYPES.ARROW_UP : INPUT_TYPES.ARROW_DOWN
            );
        }

        this.update();
    }

    /**
     * Handles request to delete a tag.
     * @param {TagList} src - TagList source.
     * @param {Object} data - Payload.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleTagListRequestDelete(src, data) {
        this.stopPropagation(PRIVATE_EVENTS.REQUEST_DELETE);
        this.emit(this.getProp("requestDeleteEventName"), this, data);
    }

    /**
     * Handles request to show all tags.
     * @param {TagList} src - TagList source.
     * @returns {undefined} Returns nothing.
     * @private
     */
    _handleTagListShowAll(src) {
        this.stopPropagation(PRIVATE_EVENTS.REQUEST_SHOW_ALL);
        this._state = Object.assign({}, this._state, {
            showAll: !this._state.showAll
        });
        this.update();
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped) {
        return el(
            "div",
            {
                class: NAMESPACE,
                key: props.key,
                oncreate: ({ dom }) => {
                    this._menuElement = dom.querySelector(".mpageui-InlineDropDown");
                    this._textElement = dom.querySelector(".mpageui-TextBox");
                    document.addEventListener("mousedown", this._handleMouseDown);
                },
                onupdate: ({ dom }) => {
                    this._menuElement = dom.querySelector(".mpageui-InlineDropDown");
                    this._textElement = dom.querySelector(".mpageui-TextBox");
                },
                onremove: () => {
                    this._menuElement = null;
                    this._textElement = null;
                    document.removeEventListener("mousedown", this._handleMouseDown);
                }
            },
            [
                mapped.tagList.render(),
                el(
                    "input",
                    {
                        class: "mpageui-TextBox mpageui-TagListSearch-textBox",
                        type: "text",
                        placeholder: props.inputPlaceholder,
                        value: props.inputValue,
                        oninput: this._handleInput,
                        onkeydown: this._handleKeyDown,
                        onkeyup: this._handleKeyUp,
                        onblur: this._handleBlur,
                        onfocus: this._handleFocus
                    }
                ),
                mapped.dropDown.render()
            ]
        );
    }
}

TagListSearch.EVENTS = EVENTS;
export default TagListSearch;
