import UIComponent from "../../../../base/UIComponent";
import i18n from "../../../../../../../../i18n/cerner/mpagedev/mpagefusion";
import { ListItemCard } from "../../../composite/list";
import { NAMESPACE, EVENTS } from "./const";
import { resultsChange, selectedIndexChange } from "./helpers";
import { top, bottom } from "../../../../helpers/dom/positioning";
import { range } from "../../../../helpers/core/array";
import KEY_CODES from "../../../../helpers/const/keyCodes";

const { ARROW_UP, ARROW_DOWN } = KEY_CODES;
const {
    addFreeText: addFreeTextI18n,
    searchNoResultsFound: searchNoResultsFoundI18n
} = i18n();

/**
 * Checks if a search result is considered selectable.
 * @param {Object} result - An individual search result.
 * @returns {boolean} True if the result is considered selectable.
 */
const isSelectable = (result) =>
    (typeof result.isSelectable === "undefined" || !!result.isSelectable);

/**
 * Will potentially perform an auto-scroll to the item with the selected index
 * if possible.
 * @param {Boolean} shouldScroll - If should auto-scroll.
 * @param {Object[]} results - Array of results.
 * @param {Number} selectedIndex - The currently selected index.
 * @param {HTMLElement} dom - The container element.
 * @returns {undefined} Returns nothing.
 */
const maybeAutoScroll = (shouldScroll, results, selectedIndex, dom) => {
    if(!shouldScroll || !results || !results.length) {
        return;
    }
    const items = dom.querySelectorAll(`.${NAMESPACE}-item`);
    const selectedItem = items[ selectedIndex ];
    if (!selectedItem) {
        return;
    }

    const offsetParent = selectedItem.offsetParent;
    if (!offsetParent || !selectedItem) {
        return;
    }

    if (bottom(selectedItem) > bottom(offsetParent)) {
        // Set search list scroll bar position to the bottom of the selected item.
        offsetParent.scrollTop = (selectedItem.offsetTop + selectedItem.offsetHeight) - offsetParent.offsetHeight;
    }
    else if (top(selectedItem) < top(offsetParent)) {
        // Set search list scroll bar position to the top of the selected item.
        offsetParent.scrollTop = selectedItem.offsetTop;
    }
};


/**
 * The SearchList class.
 * @class SearchList
 */
class SearchList extends UIComponent {
    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            clickEventName: EVENTS.CLICK,
            hasProgressiveDisclosure: false,
            results: [],
            selectedIndex: 0,
            shouldAutoScroll: false,
            shouldTruncate: true,
            searchValue: ""
        };
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        this.on(ListItemCard.EVENTS.LIST_ITEM_CLICK, (src, display, key) => {
            this.stopPropagation(ListItemCard.EVENTS.LIST_ITEM_CLICK);

            this.emit(
                this.getProp("clickEventName"),
                this,
                {
                    index: this.getProp("results").findIndex((r) => r.key === key),
                    key,
                    result: this.getProp("results").find((r) => r.key === key)
                }
            );
        });
    }

    /**
     * @inheritDoc
     */
    dependentPropChangeHandlers() {
        return [
            [ "results", "searchValue", resultsChange(this) ]
        ];
    }

    /**
     * @inheritDoc
     */
    propChangeHandlers() {
        return {
            selectedIndex: selectedIndexChange(this)
        };
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped) {
        return el(
            "ul",
            {
                class: NAMESPACE,
                oncreate: ({ dom }) => {
                    maybeAutoScroll(
                        props.shouldAutoScroll,
                        props.results,
                        props.selectedIndex,
                        dom
                    );
                },
                onupdate: ({ dom }) => {
                    maybeAutoScroll(
                        props.shouldAutoScroll,
                        props.results,
                        props.selectedIndex,
                        dom
                    );
                }
            },
            this.renderChildren()
        );
    }
}

/**
 * Computes the next selected index based on the current index, direction, and
 * whether the index can go into a "null" state.
 * @param {Number | null} currentIndex - The current selected index.
 * @param {Object[]} results - Array of results over which to iterate.
 * @param {Number} direction - The iterate direction (1 or -1)
 * @param {Boolean} escapeBounds - If the index should be allowed to go into a "null" state.
 * @returns {Number | null} The next selection index.
 */
const nextIndex = (currentIndex, results, direction, escapeBounds) => {
    let adjustedIndex = currentIndex;
    /*
     * Edge case: If in the null selection state, depending on the
     * direction, we start the index off at a starting position.
     */
    if(currentIndex === null) {
        adjustedIndex = (direction === 1 ? results.length - 1 : 0);
    }

    const index = range(0, results.length)
        .map((i) => (adjustedIndex + ((i + 1) * direction) + results.length) % results.length)
        .find((i) => isSelectable(results[ i ]));

    /*
     * Edge case: If no items in the results are selectable, it is possible to not
     * find an appropriate index. In that case, we'll revert back to null selection.
     */
    if(typeof index === "undefined") {
        return null;
    }

    if(!escapeBounds) {
        return index;
    }

    /*
     * Edge case: If we allow index boundary escaping and we detect that the index has looped back around
     * then we will go to the null selection state.
     */
    if(currentIndex !== null && (direction === 1 && index <= currentIndex || direction === -1 && index >= currentIndex)) {
        return null;
    }
    else {
        return index;
    }
};

/**
 * Given a current index, results, and a key-code, computes the next selection index.
 * @param {Number | null} currentIndex - The current selected index.
 * @param {Object[]} results - Array of results over which to iterate.
 * @param {Number} keyCode - The key-code from which a direction is derived.
 * @param {Boolean} escapeBounds - If the index should be allowed to go into a "null" state.
 * @returns {Number | null} The next selection index.
 */
const nextIndexFromKeyCode = (currentIndex, results, keyCode, escapeBounds) =>
    (keyCode === ARROW_DOWN || keyCode === ARROW_UP) ?
        nextIndex(currentIndex, results, keyCode === ARROW_UP ? -1 : 1, escapeBounds) :
        currentIndex;

SearchList.helpers = {
    result: {
        isSelectable,
        nextIndex,
        nextIndexFromKeyCode,
        /**
         * Creates a standard object for the add free-text result for the search list.
         * @param {string} searchValue - The current search value.
         * @param {string} [message] - The custom message for adding free-text.
         * @param {string} [key] - The key for the add free-text item.
         * @returns {Object} The add free-text item.
         */
        addFreeText: (searchValue = "", message = "", key = "ADD_FREE_TEXT") => ({
            isSelectable: true,
            key,
            data: [
                {
                    shouldHighlight: false,
                    display: message || addFreeTextI18n.replace("{0}", searchValue)
                }
            ]
        }),
        /**
         * Creates a standard object for the no results item in the search list.
         * @param {string} searchValue - The current search value.
         * @param {string} [message] - The no results found message.
         * @param {string} [key] - The key for the no results item.
         * @returns {Object} The no results found item.
         */
        noResults: (searchValue = "", message = "", key = "NO_RESULTS_FOUND") => ({
            isSelectable: false,
            key,
            data: [
                {
                    shouldHighlight: false,
                    display: message || searchNoResultsFoundI18n.replace("{0}", searchValue)
                }
            ]
        })
    }
};

SearchList.EVENTS = EVENTS;

export default SearchList;
