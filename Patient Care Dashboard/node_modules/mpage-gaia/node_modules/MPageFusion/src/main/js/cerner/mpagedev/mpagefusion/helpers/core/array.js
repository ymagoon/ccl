/**
 * Micro helper to retrieve length of array.
 * @param {Array} array - An array.
 * @returns {length} The length of the array.
 */
export const length = (array) => array.length;

/**
 * Returns the last element of an array.
 * @param {Array<*>} array - An array.
 * @returns {*} The last element in the array.
 */
export const last = (array) =>
    array[ array.length - 1 ];

/**
 * Returns the element in the array immediately after the specified element.
 * @param {Array<*>} array - An array.
 * @param {*} element - The element.
 * @returns {*} The element in the array after the specified element.
 */
export const nextInArray = (array, element) => {
    const index = array.indexOf(element);
    return (index < 0) ? undefined : array[ index + 1 ];
};

/**
 * Returns the element in the array immediately before the specified element.
 * @param {Array<*>} array - An array.
 * @param {*} element - The element.
 * @returns {*} The element in the array before the specified element.
 */
export const previousInArray = (array, element) => {
    const index = array.indexOf(element);
    return (index < 0) ? undefined : array[ index - 1 ];
};

/**
 * Determines if two arrays are equal. This is a naive comparison in that it
 * simply checks that each item in the array corresponds to the same item
 * in the other array at the same index. No deep comparison is performed.
 * @param {Array<*>} lhsArray - The left-hand array.
 * @param {Array<*>} rhsArray - The right-hand array.
 * @returns {boolean} True if the arrays are equal, otherwise false.
 */
export const equals = (lhsArray, rhsArray) => {
    let lhsIndex = lhsArray.length;
    const rhsIndex = rhsArray.length;
    if (lhsIndex !== rhsIndex) {
        return false;
    }
    for (lhsIndex; lhsIndex--;) {
        if (lhsArray[ lhsIndex ] !== rhsArray[ lhsIndex ]) {
            return false;
        }
    }
    return true;
};

/**
 * Create an array of index values.
 * @param {number} start - The start index.
 * @param {number} end - The end index.
 * @returns {Array<number>} An array based on the range.
 */
export const range = (start, end) =>
    Array.from({ length: (end - start) }, (_, i) => i + start);

/**
 * Splits an array into chunks of a specified size.
 * For example, an array might be split into chunks of size 3
 * [ 1, 2, 3, 4, 5, 6, 7 ] => [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7 ] ]
 * @param {Array} array - the array to split into chunks
 * @param {Number} size - the chunk size
 * @returns {Array} the array of chunks
 */
export const chunk = (array, size) => {
    if (!Array.isArray(array) || typeof size !== "number" || size < 1) {
        throw new TypeError("Invalid Chunk Parameter");
    }

    return range(0, Math.ceil(array.length / size))
        .map((value, i) => array.slice(i * size, i * size + size));
};

/**
 * Clones the array
 * @param {Array} arrayToClone - Array to clone
 * @returns {Array} Cloned array
 */
export const clone = (arrayToClone) => arrayToClone.slice(0);

/**
 * Checks if an array is not empty. Can also be used for strings,
 * since they are arrays of chars.
 * @param {Array | String} arr - the array or string
 * @returns {Boolean} whether it is empty
 */
export const isNotEmpty = (arr) => arr && arr.length > 0;

/**
 * Checks if an array is empty. Can also be used for strings,
 * since they are arrays of chars.
 * @param {Array | String} arr - the array or string
 * @returns {Boolean} whether it is empty
 */
export const isEmpty = (arr) => !isNotEmpty(arr);
