"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.defaultArgs = void 0;

var _seleniumWebdriver = require("selenium-webdriver");

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
   This can be removed once this fix has been released in
   selenium: https://github.com/SeleniumHQ/selenium/pull/5968
 */
if (!Object.getOwnPropertySymbols(_seleniumWebdriver.Condition).some(function (symbol) {
  return symbol === Symbol.hasInstance;
})) {
  Object.defineProperty(_seleniumWebdriver.Condition, Symbol.hasInstance, {
    value: function value(condition) {
      return !!condition && _typeof(condition) === "object" && typeof condition.description === "function" && typeof condition.fn === "function";
    },
    configurable: true
  });
}
/**
 * builds the root css selector
 *
 * when `table.row(3).cell(2)` is accessed,
 * `selectorList` might internally look like this:
 * [
 *     ".mpageui-Table",
 *     ".mpageui-Table-row:nth-child(3)",
 *     ".mpageui-Table-row-cell:nth-child(2)"
 * ]
 *
 * This function simply concatenates these into one selector.
 *
 * It returns a promise in order to handle the edge case in
 * which an element's root selector is a function. In this
 * scenario the element selector is not known until runtime,
 * so its `elementSelector` member returns a function which
 * returns a promise that resolves with the root selector.
 *
 * @param {Array} selectorList - array of element selectors
 * @returns {Promise<String>} selector
 * @private
 */


var buildRootSelector = function buildRootSelector(selectorList) {
  return selectorList.reduce(function (buildPrefix, selector) {
    return buildPrefix.then(function (prefix) {
      return typeof selector === "string" ? Promise.resolve(prefix + " " + selector) : selector(prefix);
    });
  }, Promise.resolve(""));
};

var defaultArgs = {
  selectorList: [],
  index: undefined,
  useExactSelector: false
};
/**
 * The UIComponentPage class
 * @memberOf module:MPageFusion/testing
 * @class module:MPageFusion/testing.UIComponentPage
 */

exports.defaultArgs = defaultArgs;

var UIComponentPage =
/*#__PURE__*/
function () {
  /**
   * @param {Object} driver - The driver which runs the tests in the browser
   * @param {String} selector - a css selector for the root element of the UIComponent
   * @param {Number?} index - the index of the item in a list of items
   * @param {Boolean} useExactSelector - this should be set to true when the
   *  root element has already been selected by selectorList (e.g. by a custom css class)
   *  and adding the root element class would cause the selector to become invalid
   * @param {Object} config - Additional configurations for the UIComponent
   */
  function UIComponentPage(driver, _temp) {
    var _ref = _temp === void 0 ? defaultArgs : _temp,
        _ref$selectorList = _ref.selectorList,
        selectorList = _ref$selectorList === void 0 ? [] : _ref$selectorList,
        _ref$index = _ref.index,
        index = _ref$index === void 0 ? undefined : _ref$index,
        _ref$useExactSelector = _ref.useExactSelector,
        useExactSelector = _ref$useExactSelector === void 0 ? false : _ref$useExactSelector,
        _ref$config = _ref.config,
        config = _ref$config === void 0 ? {} : _ref$config;

    this.driver = driver;
    this.config = config;
    var nthSelector = typeof index === "number" ? ":nth-child(" + (index + 1) + ")" : "";
    this.selectorList = useExactSelector ? selectorList : selectorList.concat(typeof this.elementSelector === "function" ? this.elementSelector : "" + this.elementSelector + nthSelector);
  }
  /**
   * returns the css selector (as a string) needed to locate the
   * root element. This property may optionally return a function
   * that -- given a prefix css selector -- returns a promise that
   * resolves with the root css selector. This alternative is
   * available in order to handle the edge case in which an element's
   * selector is not known until runtime or until the element is
   * created. This can be helpful when the construct with which the page
   * object is interacting is composed of nonadjacent DOM elements.
   *
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @returns {String|Function} selector
   * @abstract
   * @example
   * class TablePage {
   *     // returns the selector needed to locate the table root
   *     get elementSelector() {
   *         return ".mpageui-Table";
   *     }
   *
   *     // ...
   * }
   */


  var _proto = UIComponentPage.prototype;

  /**
   * gets a page object attribute
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @param {String} attribute - the page object attribute
   * @returns {Promise} attribute
   */
  _proto.get = function get(attribute) {
    return this[attribute];
  }
  /**
   * waits until the root element has been located in the dom
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @returns {WebElementPromise} after root located
   */
  ;

  _proto.waitUntilLocated = function waitUntilLocated() {
    var _this = this;

    return buildRootSelector(this.selectorList).then(function (rootSelector) {
      return _this.driver.wait(_seleniumWebdriver.until.elementLocated(_seleniumWebdriver.By.css(rootSelector))).then(function () {
        return rootSelector;
      });
    });
  }
  /**
   * gets the root WebElement
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @returns {WebElementPromise} the root WebElement
   */
  ;

  _proto.getRootElement = function getRootElement() {
    var _this2 = this;

    return this.waitUntilLocated().then(function (rootSelector) {
      return _this2.driver.findElement(_seleniumWebdriver.By.css(rootSelector));
    });
  }
  /**
   * gets a nested WebElement. returns null if the nested
   * element is not found.
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @param {String} selector - a css selector for the element
   * @returns {WebElementPromise} the WebElement
   */
  ;

  _proto.getNestedElement = function getNestedElement(selector) {
    return this.getRootElement().then(function (element) {
      return element.findElement(_seleniumWebdriver.By.css(selector))
      /*
          Only catch nested element. We always
          want to throw an exception if the root
          element is not found.
       */
      ["catch"](function () {
        return null;
      });
    });
  }
  /*
   * gets an array of nested WebElements. returns an empty array if the nested
   * elements are not found.
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @param {String} selector - a css selector for the elements
   * @returns {WebElementPromise<Array<WebElement>>} the array of WebElements.
   */
  ;

  _proto.getNestedElements = function getNestedElements(selector) {
    return this.getRootElement().then(function (element) {
      return element.findElements(_seleniumWebdriver.By.css(selector));
    });
  }
  /**
   * whether or not the element is displayed
   * @memberOf module:MPageFusion/testing.UIComponentPage
   * @returns {Promise<boolean>} whether element is displayed
   */
  ;

  _proto.isDisplayed = function isDisplayed() {
    var _this3 = this;

    return buildRootSelector(this.selectorList).then(function (rootSelector) {
      return _this3.driver.findElement(_seleniumWebdriver.By.css(rootSelector));
    }).then(function (element) {
      return element.isDisplayed();
    })["catch"](function () {
      return false;
    });
  }
  /**
   * Scroll the page to the element.
   * @memberof module:MPageFusion/testing.UIComponentPage
   * @returns {Promise} Returns promise that is resolved when scrolling is complete.
   */
  ;

  _proto.scrollIntoView = function scrollIntoView() {
    var _this4 = this;

    return this.getRootElement().then(function (element) {
      return _this4.driver.executeScript("arguments[0].scrollIntoView()", element);
    });
  }
  /**
   * waits until the element has been located in the dom
   * @param {Array} cssSelector -  css selector list.
   * @returns {Promise<WebElement>} after root located
   */
  ;

  _proto.waitUntilElementLocated = function waitUntilElementLocated(cssSelector) {
    var _this5 = this;

    return buildRootSelector(cssSelector).then(function (rootSelector) {
      return _this5.driver.wait(_seleniumWebdriver.until.elementLocated(_seleniumWebdriver.By.css(rootSelector)));
    });
  };

  _createClass(UIComponentPage, [{
    key: "elementSelector",
    get: function get() {
      throw new Error("elementSelector not implemented. elementSelector must\n            return a valid css selector identifying the root of the the element\n            OR a function that given a prefix css selector returns a Promise which\n            resolves with a valid css selector identifying the root of the the element.");
    }
  }]);

  return UIComponentPage;
}();

exports["default"] = UIComponentPage;