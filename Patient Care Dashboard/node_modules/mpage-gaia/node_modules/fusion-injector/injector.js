const transformerProxy = require("./transformerProxy");
const http = require("http");
const connect = require("connect");
const S = require("string");
const { pipe } = require("ramda");

/**
 * @typedef {Object} UrlCollection
 * @property {Array<String>} top list of script/css to be added to the top
 * @property {Array<String>} bottom list of script/css to be added to the bottom
 */

/**
 * Convets a url into the proper HTML tag (link or script)
 * @param {String} url
 * @returns {string}
 */
const makeTag = (url) =>
    S(url).endsWith("css")
      ? `<link rel='stylesheet' type='text/css' href='${url}' />`
      : `<script type='text/javascript' src='${url}'></script>`;

/**
 * Converts a list of urls into a single string with their corresponding html
 * tags.
 * @param {List<String>} urls list of urls
 * @param {String} prefix prefix to be added to each url.
 * @returns {string} resulting HTML
 */
const makeTags = (urls, prefix) =>
    urls
        .map((url) => prefix + url)
        .map(makeTag)
        .join("\n");

/**
 * Adds HTML tags to the top of the HEAD tag of an HTML content
 * @param {String} content - content to be added to the top of HEAD
 * @param {String} html - the HTML content
 * @returns {String} the modified html
 */
const addHtmlToTop = (content) => (html) =>
    html.replace(/(<head[^>]*>)/, "$1" + content);

/**
 * Adds HTML tags to the bottom of the HEAD tag of an HTML content
 * @param {String} content - tags to be added to the top of HEAD
 * @param {String} html - the HTML content
 * @returns {String} the modified html
 */
const addHtmlToBottom = (content) => (html) =>
    html.replace(/(<\/head[^>]*>)/, content + "$1");

/**
 * Creates the middleware that is responsible for injecting a single
 * url target.
 * @param {String} target url regex to intercep
 * @param {UrlCollection} collection the set of urls to be added
 * @param {String} urlPrefix
 */
const createTransformationFunction = (target, collection, urlPrefix) =>
    transformerProxy(
        (data, req, res) =>
            pipe(
                addHtmlToBottom(makeTags(collection.bottom, urlPrefix)),
                addHtmlToTop(makeTags(collection.top, urlPrefix))
            )(data)
        , { match: new RegExp(target) }
    );

/**
 * Takes an array of NodeJS middlewares and makes a single middleware that
 * calls all of them. It uses the "connect" library to glue them together
 * @param {Array<Function>} middlewares array of middlewares
 * @returns {Function} middleware function with all the middlewares
 */
const composeMiddlewares = (middlewares) => {
    const app = connect();
    middlewares.forEach((middleware) => app.use(middleware));
    return app;
};

/**
 * Creates a single midlleware that will inject the urls
 * @param {Array<*>} urls json with the top and bottom urls
 * @param {String} urlPrefix prefix to be added to each url entry
 * @param {Request} request express compatible HTTP request
 * @param {Response} response express compatible HTTP response
 * @param {Function} next middleware function to be executed next
 * @returns {Function} middleware function
 */
const middleware = (urls, urlPrefix) =>
    composeMiddlewares(
        Object.keys(urls).map(
            (url) => createTransformationFunction(url, urls[url], urlPrefix)
        )
    );


/**
 * Reads the URLs JSON and adds instructions into request and
 * response to replace those files with the equivalent HTML
 * tags.
 *
 * @param {Array<*>} urls urls to be intercepted. See createProxyServer().
 * @param {String} urlPrefix prefix to be added to each url
 * @param {Request} req express compatible HTTP request
 * @param {Response} res express compatible HTTP response
 * @returns {Function} express compatible middleware
 */
const injectUrls = (urls, urlPrefix, req, res) =>
    middleware(urls, urlPrefix)(req, res, () => {} );


/**
 * Creates a new injector proxy server that will inject the top and bottom
 * URLs specified in the URLs variable into the <head> section.
 * URLs are in the format:
 *
 * {
 *     "somefile.html": ["myscript1.js", "myscript2.js"]
 *     "somepattern\*.html": ["otherscript.js"]
 * }
 *
 * In the example above, it will intercept calls to somefile.html and any calls
 * matching the second pattern and add the provided files to the header.
 *
 * Custom fun is an optional request response handler that is added to the
 * server. That is useful to add custom behavior to the proxy server.
 *
 * @param {Array<*>} urls urls to be intercepted
 * @param {Integer} proxyServerPort port of the proxy server
 * @param {String} urlPrefix
 * @param {String} proxyTarget
 * @returns {*} the newly created server
 */
const createProxyServer = (
    urls,
    proxyServerPort,
    urlPrefix,
    proxyTarget
) => {
    const proxy = require("http-proxy").createProxyServer({});
    var app = connect();
    app.use(middleware(urls, urlPrefix));
    app.use((req, res) => proxy.web(req, res, { target: proxyTarget }));
    http.createServer(app).listen(proxyServerPort);
    return http;
};

module.exports = { createProxyServer, injectUrls, middleware };
