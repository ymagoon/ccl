const path = require("path");
const webpack = require("webpack");
const ExtractTextPlugin = require("extract-text-webpack-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const baseDir = path.join(__dirname, "../../../../", "node_modules");
const PLUGIN_NAME = "webpack";
const DEFAULT_DEV_SERVER_PORT = 7070;
const replaceMocksPlugin = require("./replaceMocksPlugin");
const glob = require("glob")

const configureEntryPoints = (config) => {
    return config.autoRefresh && Array.isArray(config.entryPoints)
        ? [ `${path.resolve(baseDir, "webpack-dev-server")}/client?http://localhost:${config.port}` ]
              .concat(
                  config.includePolyfills
                      ? require.resolve("@babel/polyfill")
                      : []
              )
              .concat(config.entryPoints)
        : config.entryPoints;
};

/**
 * Get the mock collection to use in the wepback build.
 * @param {String} mockLocation - Relative file path of mock file.
 * @param {String} collectionName - Name of mock collection to find.
 * @param {String} rootDir - The root directory to resolve relative paths.
 * @returns {Object} Returns a mock collection read from configuration.
 */
const getMockCollection = ({ mockLocation, collectionName }, rootDir) => {
    const { mocks } = require(path.resolve(rootDir, mockLocation));
    return collectionName && mocks && mocks.find(mock => mock.collectionName === collectionName);
}

/**
 * Get the mock objects from the mock collection.
 * Will convert the files property of each mock object from a glob pattern to an array of matched files.
 * @param {Object} mockCollection - The found mock collection object.
 * @param {String[]} sourceFolders - Array of paths of the source folders. Specified in config.
 * @param {String} rootDir - The root directory to resolve relative paths.
 * @returns {Object[]?} Returns an array of mock objects to pass to replace mocks plugin.
 */
const getMockObjects = (mockCollection, { sourceFolders }, rootDir) => (
    sourceFolders
    && mockCollection
    && mockCollection.functions
    && mockCollection.functions.map((mockObject) => Object.assign(
        {},
        mockObject,
        mockObject.files && mockObject.files.length
            ? {
                files: sourceFolders.reduce((files, source) => [
                    ...files,
                    ...glob.sync(mockObject.files, {
                        cwd: path.resolve(rootDir, source),
                        matchBase: true,
                        nosort: true
                    })
                ], [])
            }
            : null
    ))
);

/**
 * Converts the configuration format used by the webpack plugin (usually stored
 * in gaia.json) to a JSON that is compatible with webpack.
 * @param {String} rootDir the root directory to resolve relative paths
 * @param {*} config gaia specific webpack config
 * @returns {*} webpack specific JSON config
 */
const convertConfigToWebpackFormat = (rootDir, config) => {
    const mockObjects = config.mockConfig && config.mockConfig.includeMocks
        ? getMockObjects(
            getMockCollection(config.mockConfig, rootDir),
            config,
            rootDir
        )
        : null

    const extractLess = new ExtractTextPlugin({
        filename: config.cssFileName
    });

    return {
        devtool: config.devtool,
        entry: configureEntryPoints(config),
        devServer: config.devtool
            ? Object.assign(
                  { inline: true },
                  config.autoRefresh
                      ? { watchContentBase: config.autoRefresh }
                      : null,
                  config.contentBase
                      ? { contentBase: config.contentBase }
                      : null,
                  config.publicPath ? { publicPath: config.publicPath } : null,
                  config.port ? { port: config.port } : null
              )
            : {},
        output: {
            path: path.join(rootDir, config.outputFolder),
            filename: config.fileName,
            library: config.libraryName,
            libraryTarget: config.libraryTarget
        },
        /*
          * We need resolve loader since webpack looks to project node_modules by default.
          * This tells webpack to look for base directory (folder directly above plugin) node_modules
          * as well as the project node_modules.
          * More here: https://cloud.githubusercontent.com/assets/948896/7745800/6a051802-ffe0-11e4-9177-d1807d792d6b.png
          * */
        resolveLoader: {
            extensions: [".js"],
            moduleExtensions: ["-loader"],
            modules: [baseDir, path.join(rootDir, "node_modules")]
        },
        resolve: {
            modules: [rootDir, "node_modules"]
        },
        module: {
            rules: [
                {
                    test: /\.(js|jsx)$/,
                    include: config.sourceFolders.map((folder) =>
                        path.join(rootDir, folder)
                    ),
                    use: [
                        {
                            loader: "babel-loader",
                            options: {
                                presets: [
                                    [ require.resolve("babel-preset-mpage") ]
                                ],
                                plugins: [].concat(
                                    config.includePolyfills
                                        ? [
                                            [
                                                require.resolve(
                                                    "@babel/plugin-transform-runtime"
                                                ),
                                                {
                                                    corejs: 2,
                                                    helpers: true,
                                                    regenerator: true
                                                }
                                            ]
                                        ]
                                        : [],
                                    // Add replaceMocks babel plugin if mock collection exists and has at least one mock
                                    mockObjects && mockObjects.length
                                        ? [[
                                            replaceMocksPlugin,
                                            { mockObjects }
                                        ]]
                                        : []
                                )
                            }
                        }
                    ]
                },
                config.includeCSS || !config.cssFileName
                    ? {
                          test: /\.(css|less)$/,
                          loader:
                              "style-loader!css-loader?url=false!less-loader"
                      }
                    : {
                          test: /\.(less|css)$/,
                          loader: extractLess.extract([
                              "css-loader?minimize&url=false",
                              "less-loader"
                          ])
                      }
            ]
        },
        plugins: []
            .concat(config.cssFileName ? extractLess : [])
            .concat(new webpack.optimize.ModuleConcatenationPlugin())
            .concat(
                config.isProduction
                    ? new webpack.DefinePlugin({
                          "process.env": {
                              NODE_ENV: JSON.stringify("production")
                          }
                      })
                    : []
            )
            .concat(
                config.minify
                    ? new webpack.optimize.UglifyJsPlugin({
                          compress: {
                              warnings: false
                          },
                          mangle: false,
                          minimize: true
                      })
                    : []
            )
            .concat(
                config.harness
                    ? [
                          new HtmlWebpackPlugin({
                              template: path.join(
                                  __dirname,
                                  "../../assets/index.ejs"
                              ),
                              title: config.harness.title || "Dev Harness",
                              filename: "index.html",
                              inject: "body"
                          })
                      ]
                    : []
            ),
        externals: config.externals
    };
};

/**
 * Override the config object of default target with production build flags.
 * These flags do not honor user setting for default target.
 *
 * @param {Object} config - Configuration of default target
 * @private
 */
const applyProductionFlags = (config) => Object.assign({}, config, {
    isProduction: true,
    devtool: "hidden-source-map",
    includeCSS: false,
    envify: false,
    minify: false,
    includePolyfills: false,
    mockConfig: { includeMocks: false }
});

/**
 * Returns the entire webpack configuration JSON
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments
 * @returns {Promise<*>} the config JSON
 */
const readFullConfig = (gaia, args) =>
    gaia
        .runCommand("config", "read", {
            plugin: PLUGIN_NAME,
            file: args.configFile
        })
        .then(
            (config) => (!config || !config.targets ? { targets: [] } : config)
        );

/**
 * Writes the entire webpack configuration JSON into gaia's configuration file.
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments. The "config" key will contain the
 *                 config JSON to be stored.
 * @returns {Promise<*>} promise that resolves when the command finishes running
 */
const writeFullConfig = (gaia, args) =>
    gaia.runCommand("config", "write", {
        plugin: PLUGIN_NAME,
        file: args.configFile,
        config: args.config
    });

/**
 * Reads the configuration JSON for a single target
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments. The "target" key contains the target.
 * @returns {Promise<*>} promise with the target config
 */
const readTargetConfig = (gaia, args) =>
    readFullConfig(
        gaia,
        Object.assign(args, { target: args.target || "default" })
    ).then((config) =>
        Promise.resolve(config.targets ? config.targets[args.target] : {})
    );

/**
 * Writes gaia.json configuration for a single webpack target.
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments. The "target" key contains the target,
 *                 the "config" key contains the configuration to be saved.
 * @returns {Promise<*>} promise that resolves when the writing is complete
 */
const writeTargetConfig = (gaia, args) =>
    readFullConfig(gaia, args).then((config) => {
        if (!config.targets) {
            config.targets = {};
        }
        config.targets[args.target] = args.config;
        return gaia.runCommand("config", "write", {
            plugin: PLUGIN_NAME,
            file: args.configFile,
            config: config
        });
    });

/**
 * Retrieves a list of the target names for all webpack targets
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments
 * @returns {Array} An array of strings representing the names of all targets
 */
const getTargetList = (gaia, args) =>
    readFullConfig(gaia, args).then((config) =>
        Promise.resolve(Object.keys(config.targets))
    );

/**
 * Retrieves all the externals for a given webpack target
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments. The "target" key contains the target.
 * @returns {Object} The externals for the passed target
 */
const readExternals = (gaia, args) =>
    readTargetConfig(gaia, args).then((config) =>
        Promise.resolve(config.externals)
    );

/**
 * Allows command line args to overwrite config
 * @param {Object} config - the config object
 * @param {Object} args - cli args
 * @returns {Object} config
 */
const overrideConfig = (config, args) => {
    const port = args.port || config.port || DEFAULT_DEV_SERVER_PORT;

    return args.target === "default"
        ? applyProductionFlags(Object.assign({}, config, { port }))
        : Object.assign({}, config, { port });
};

/**
 * Creates a new webpack compiler instance by reading config stored in gaia.json
 * (or any other configuration file specified in args.configFile)
 * @param {*} gaia the gaia context
 * @param {*} args command line arguments. "rootDir" is the webpack root;
 */
const webpackCompiler = (gaia, args) =>
    readTargetConfig(gaia, args).then((config) =>
        Promise.resolve(
            webpack(
                convertConfigToWebpackFormat(
                    args.rootDir || process.cwd(),
                    overrideConfig(config, args)
                )
            )
        )
    );

module.exports = {
    convertConfigToWebpackFormat,
    readFullConfig,
    readTargetConfig,
    writeTargetConfig,
    writeFullConfig,
    getTargetList,
    readExternals,
    webpackCompiler
};
