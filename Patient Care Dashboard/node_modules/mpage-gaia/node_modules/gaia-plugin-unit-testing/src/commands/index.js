const Server = require("karma").Server;
const config = require("../config");
const fs = require("fs");
const path = require("path");
const { spawnSync } = require("child_process");
const { evidencePathConfig } = require("../constants/pathConfiguration");

/**
 * This function checks the evidence folder for the code coverage report. If its there it resolves with the
 * folder path, if not it resolves with false.
 * @function checkCodeCoverage
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that resolves with either a file path or false
 */
const checkCodeCoverage = (gaia, args) =>
    new Promise((ok, err) => {
        const evidenceFolder = path.resolve(process.cwd(), evidencePathConfig.htmlDirectoryPath);
        fs.access(evidenceFolder, fs.constants.R_OK, (error) => error ? err(error) : ok(evidenceFolder));
    });


/**
 * This function attempts to read the JSON file that is output by the JsonResultReporter
 * @function readResults
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that resolves with the data from the report in JSON form
 */
const readResults = (gaia, args) =>
    new Promise((ok, err) => {
        fs.readFile(path.resolve(process.cwd(), evidencePathConfig.jsonFileName), (err, data) => {
            if (err) throw err;
            const obj = JSON.parse(data);
            ok(obj);
        });
    });

/**
 * Run tests in watch mode using nodemon
 * @param  {*} gaia The MPages gaia object
 * @param  {*} args Arguments passed to the command
 * @param  {*} config The gaia.json config for this plugin
 * @return {undefined}
 */
const runJestInWatchMode = (gaia, args, config) => {
    spawnSync(
        "nodemon",
        [
            `"${__dirname}/../jest/run.js"`,
            "--verbose",
            "--watch",
            "./src"
        ].concat(
            config && config.jestSetupFilesDir ?
                [ "--setupDir", `"${config.jestSetupFilesDir}"` ] : [],
            args.testNamePattern ?
                [ "--testNamePattern", `"${args.testNamePattern}"` ]: []
        ),
        {
            stdio: ["inherit", "inherit", "inherit"],
            shell: true
        }
    );
};

/**
 * Runs unit tests on Jest
 * @param  {*} gaia The MPages Gaia Object
 * @param  {*} args The arguments passed to the command
 * @param  {*} config The gaia.json config for this plugin
 * @return {String} Returns stringified output
 */
const runJest = (gaia, args, config) => {
    return new Promise((ok, err) => {
        const nodeArguments = args.debugMode
            ?
            [
                "--inspect-brk",
                `"${__dirname}/../jest/run.js"`,
                "--debug"
            ]
            :
            [
                `"${__dirname}/../jest/run.js"`,
                ""
            ];
        
        if (args.testNamePattern) {
            nodeArguments.push(
                "--testNamePattern",
                `"${args.testNamePattern}"`
            );
        }

        if (config && config.jestSetupFilesDir) {
            nodeArguments.push(
                "--setupDir",
                `"${config.jestSetupFilesDir}"`
            );
        }

        const jestProcess = spawnSync("node", nodeArguments, { stdio: "inherit", shell: true });

        // The child process will exit with code 0 only if tests pass
        const testsPassed = jestProcess.status === 0;

        // When running over command line exit the process, else resolve the promise
        if (args.cli) {
            console.log(`\n Jest has exited with ${jestProcess.status}`);
            return process.exit(testsPassed ? 0 : 1);
        }

        return ok();
    });
};


/**
 * This function defines the 'run' command for the plugin.
 * It checks the gaia.json config file and then passes that config as an arg to the
 * executeKarma function.
 * @function run
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that calls readConfig then executeKarma
 */
const run = (gaia, args) =>
    readConfig(gaia, args)
        .then((config) => {
            switch (config.testRunner) {
                case "JEST":
                    console.log(config);

                    // Run Jest in watch mode only when debugMode command line argument is not passed
                    // AND either watchMode command line argument is passed or singleRun is set to false in gaia config
                    if (!args.debugMode && (args.watchMode || !config.singleRun)) {
                        return runJestInWatchMode(gaia, args, config);
                    }

                    return runJest(gaia, args, config);

                case "KARMA":
                default: {
                    const updatedConfig = args.cli
                        ? Object.assign({}, config, { browser: [ "PhantomJS" ], singleRun: true })
                        : config;
                    Object.assign(args, { config: updatedConfig });

                    console.log(updatedConfig);

                    return executeKarma(gaia, args);
                }
            }
        });

/**
 * This function will start a karma Server and run it with the karma.conf setup.
 * The config should be passed in through the "config" arg.
 * @function executeKarma
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A new promise that starts the karma server
 */
const executeKarma = (gaia, args) =>
    new Promise((ok, err) => {
        const karmaConfig = config.karma(args.config);

        const karmaServer = new Server(karmaConfig, (exitCode) => {
            console.log(`Karma has exited with ${exitCode}`);
            if (args.cli) {
                process.exit(Number(exitCode));
            }
            ok();
        });
        karmaServer.start();
    });

/**
 * This function reads the config file (gaia.json) that may or may not exist
 * and checks for any unit-testing settings
 * @function readConfig
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that contains the config object for unit-testing or {}
 */
const readConfig = (gaia, args) =>
    gaia.runCommand(
        "config",
        "read",
        Object.assign(args, {
            plugin: "unit-testing"
        })
    )
        .then((config) =>
            // setting default value to avoid breaking existing consumers
            "unitTestPath" in config
                ? config
                : Object.assign({}, config, {
                    unitTestPath: "src/__tests__"
                })
        );

/**
 * This function reads the existing gaia.json config then
 * it saves config passed to it from the settings arg. The command line will come in as a string,
 * so it is parsed to JSON. The Config tab is passed as JSON already. The passed config is added to the existing
 * gaia.json settings. Then the config is written out to the gaia.json.
 * NOTE: When sending settings from cmd line, your keys must be in escaped quotes
 * if sending more than one setting you must also escape your brackets
 * ie: npm run gaia unit-testing:saveConfig settings={\"singleRun\":false}
 * ie: npm run gaia unit-testing:saveConfig settings=\{\"singleRun\":false,\"usesFusion\":true\}
 * @function saveConfig
 * @param {*} gaia The MPages Gaia object
 * @param {*} args The arguments passed to the command
 * @returns {Promise} A promise that calls readConfig then writes the config to gaia.json
 */
const saveConfig = (gaia, args) =>
    readConfig(gaia, args)
        .then(
            (config) => gaia.runCommand(
                    "config",
                    "write",
                    {
                        plugin: "unit-testing",
                        config: Object.assign(
                            {},
                            config,
                            typeof args.settings === "string" ? JSON.parse(args.settings) : args.settings
                        )
                    }
                )
        );

module.exports = {
    run,
    readResults,
    saveConfig,
    readConfig,
    checkCodeCoverage
};
