import * as Fusion from "MPageFusion";
import { zip } from "ramda";
import SingleUrl from "./SingleUrl";

const forwardProp = Fusion.helpers.props.forwardProp;
const UIComponent = Fusion.UIComponent;

const URL_CHANGE = "Internal::UrlList::UrlChange";
const URL_DELETE = "Internal::UrlList::UrlDelete";
const TOP_FILES_CHANGE = "Internal::UrlList::TopFilesChange";
const BOTTOM_FILES_CHANGE = "Internal::UrlList::BottomFilesChange";

const injectSelfIntoEvent = (control, sourceEvent, destEventProp) =>
      control.on(sourceEvent, (...args) => {
          control.stopPropagation(sourceEvent);
          const newArgs = [control].concat(args.slice(1));
          control.emit(
              control.getProp(destEventProp),
              ...newArgs
          );
      });

const cloneJson = (json) =>
    JSON.parse(JSON.stringify(json));

const changeUrl = (url, index, urls) => {
    urls[index].url = url;
    return urls;
};

const deleteUrl = (index, urls) => {
    urls.splice(index, 1);
    return urls;
};

const updateTopFiles = (files, index, urls) => {
    urls[index].top = files;
    return urls;
};

const updateBottomFiles = (files, index, urls) => {
    urls[index].bottom = files;
    return urls;
};

const makeSingleUrlProps = (url, index) => ({
    index: index,
    urlToIntercept: url.url,
    topFiles: url.top,
    bottomFiles: url.bottom,
    urlChangeEventName: URL_CHANGE,
    urlDeleteEventName: URL_DELETE,
    topChangeEventName: TOP_FILES_CHANGE,
    bottomChangeEventName: BOTTOM_FILES_CHANGE
});

const makeUrlControls = (urls) =>
    urls.map(
        (url, index) => new SingleUrl(makeSingleUrlProps(url, index))
    );

export default class UrlList extends UIComponent {
    initialProps() {
        return {
            urls: [],
            urlsChangeEventName: null
        };
    }

    propChangeHandlers() {
        return {
            urls: (urls) => {
                // count is different? Blow everything up. Otherwise, just update
                // existing children.
                if (urls.length != this.getChildren().length) {
                    this.replaceAllChildren(makeUrlControls(urls));
                } else {
                    zip(urls, this.getChildren())
                        .forEach(
                            ([url, child], index) =>
                                child.setProps(makeSingleUrlProps(url, index))
                        );
                }
            }
        };
    }

    afterCreate() {
        this.convertEventUsingProp(
            URL_CHANGE,
            "urlsChangeEventName",
            (source, oldUrl, newUrl) =>
                [ this, changeUrl(newUrl, source.getProp("index"), cloneJson(this.getProp("urls"))) ]
        );
        this.convertEventUsingProp(
            URL_DELETE,
            "urlsChangeEventName",
            (source, url) =>
                [ this, deleteUrl(source.getProp("index"), cloneJson(this.getProp("urls"))) ]
        );
        this.convertEventUsingProp(
            TOP_FILES_CHANGE,
            "urlsChangeEventName",
            (source, topFiles) =>
                [
                    this,
                    updateTopFiles(
                        topFiles,
                        source.getProp("index"),
                        cloneJson(this.getProp("urls"))
                    )
                ]
        );
        this.convertEventUsingProp(
            BOTTOM_FILES_CHANGE,
            "urlsChangeEventName",
            (source, bottomFiles) =>
                [
                    this,
                    updateBottomFiles(
                        bottomFiles,
                        source.getProp("index"),
                        cloneJson(this.getProp("urls"))
                    )
                ]
        );
    }

    view(el, props, children, mChildren) {
        // keys are needed here so mithril doesn't go crazy while diffing the vdom
        return children.map(
            (child) =>
                el("#", {key: child.getId()}, child.render())
        );
    }
}
