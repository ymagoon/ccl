const express = require("express");
const request = require("request");

/**
 * Finds and replaces hardcoded assembly and worklist version from the given url.
 * @param {String} url The url to clean.
 * @returns {String} The url with hardcoded versions replaced with user-defined version.
 */
const getVersionedURL = (url) => {
    const HTTP = "HTTP://";
    const HTTPS = "HTTPS://";
    const isSecureProtocol = url.toUpperCase().startsWith(HTTPS);

    // Get all the path names in the url
    const pathNames = url.substr(isSecureProtocol ? HTTPS.length : HTTP.length).split("/")

    // Get the version info and extract the version information
    const versionInfoIndex = pathNames.findIndex(pathName => pathName.startsWith("version={"));
    const versionInfo = pathNames[versionInfoIndex];
    const version = JSON.parse(versionInfo.substr("version=".length));

    // Find the path name that contains the hardcoded assembly version
    const hardCodedAssemblyPathIndex = pathNames.findIndex(pathName => pathName.search(/MPAGES_[A-Z]*_*[0-9]+_[0-9]+/i) === 0 );
    const hardCodedAssemblyPath = pathNames[hardCodedAssemblyPathIndex];
    let versionedAssemblyPath = "";

    // Create the new assembly path with appropriate version
    if (hardCodedAssemblyPath && hardCodedAssemblyPath.startsWith("MPAGES_WORKLISTS")) {
        versionedAssemblyPath = `MPAGES_WORKLISTS_${version.major}_${version.minor}`;
    } else {
        versionedAssemblyPath = `MPAGES_${version.major}_${version.minor}`
    }

    // If url contains hardcoded assembly path
    if(hardCodedAssemblyPathIndex !== -1) {
        // Replace the hardcoded assembly path with the versioned assembly path
        pathNames[hardCodedAssemblyPathIndex] = versionedAssemblyPath;
        pathNames.splice(versionInfoIndex, 1); // Remove the version info
    } else {
        // If there is no hardcoded path name, replace the version info with the versioned assembly path
        pathNames[versionInfoIndex] = versionedAssemblyPath
    }

    const protocol = (isSecureProtocol
        ? HTTPS.substring(0, HTTPS.length - 1) // Remove the last forward last as it will be added by the Array join function
        : HTTP.substring(0, HTTP.length - 1)
    ).toLowerCase();

    return [
        protocol,
        ...pathNames
    ].join("/"); // Recreate the URL
};

const serveStatic = (folders, req, res, next) => {
    const folderName = req.url.split("/")[1];
    req.url = req.url.substr(folderName.length + 1);
    const folder = folders[folderName];

    // If folder is not present, send an 404 response
    if (!folder) {
        res
            .status(404)
            .send([
                `Could not find the alias: "${folderName}". `,
                "Make sure that the alias exists in the plugin ",
                "configuration. This can be done by accessing the ",
                "Content Server settings on the web interface."
            ].join(""));
        return;
    }

    // If folder is a url, forward the request to the url and pipe the response
    if (folder.startsWith("http://") || folder.startsWith("https://")) {
        let url =  `${folder}${req.url}`;

        // If url contains version info
        if (url.includes("version={")) {
            // Replace hardcoded version with the version info
            url = getVersionedURL(url);
        }

        const forwardedRequest = request({
            method: req.method,
            url
        });
        forwardedRequest.pipe(res);
        return;
    }

    // else, serve the static assets
    express.static(folders[folderName])(req, res, next);
};

const content = (gaia, args, req, res, next) => {
    gaia.runCommand(
        "contentserver",
        "allFolders",
        args
    )
    .then(
        (folders) => {
            req.url = req.url.substr("/contentserver/content".length);
            if (req.url == "") {
                req.url = "/";
            }
            serveStatic(folders, req, res, next);
        }
    );
};

module.exports = {
    content
};
