const CLIEngine = require("eslint").CLIEngine;
const path = require("path");
const fs = require("fs");

/**
 * This function reads the config file gaia.json that may or may not exist
 * and checks for any linter settings
 * @param gaia The MPages Gaia object
 * @param args The arguments passed to the plugin
 * @returns {Promise} Contains the config object for the linter or {}
 */
const readConfig = (gaia, args) =>
    gaia.runCommand(
        "config",
        "read",
        Object.assign(args, {
            plugin: "linter"
        })
    )
    .then(config => Promise.resolve(config));

/**
 * This function calls readConfig then returns either the path from that config
 * or the default path of 'src/main'
 * @param gaia The MPages Gaia object
 * @param args The arguments passed to the plugin
 * @returns {Promise} Contains the path of the files to be linted
 */
const determineSrcPath = (gaia, args) =>
    readConfig(gaia, args)
        .then(config => Promise.resolve(config.path ? config.path : "src/main"));

/**
 * This function calls readConfig then saves the passed in path to that config
 * @param gaia The MPages Gaia object
 * @param args The arguments passed to the plugin
 */
const saveSrcPath = (gaia, args) =>
    readConfig(gaia, args)
        .then(
            (config) => {
                config.path = args.srcDir;
                return gaia.runCommand(
                    "config",
                    "write",
                    {
                        plugin: "linter",
                        config: config
                    }
                );
            });

/**
 * This function initializes the eslint CLIEngine and sets it up to use the eslint-plugin-mpages.
 * Then it runs the rules on files in the specified path param. It then outputs the results.
 * @param srcPath The path of the files that should be linted
 * @param webFlag Indicates if the run command was called from command line or web
 * @param fixMode Indicates if the run command was called with fix mode or not
 * @returns {Promise} Contains the json format of the output
 */
const executeLinter = ({ srcPath, webFlag, fixMode = false }) => {
    const cli = new CLIEngine({
        plugins: ["mpages"],
        baseConfig: { extends: ["plugin:mpages/recommended"] },
        ignorePattern: "i18n/",
        fix: fixMode
    });

    // Output types for report
    const cmdFormat = cli.getFormatter("stylish");
    const htmlFormat = cli.getFormatter("html");

    return new Promise((ok) => {
        const report = cli.executeOnFiles([srcPath]);
        // If eslint is run in fix mode, call outputFixes function to fix issues in source code.
        if (fixMode) {
            CLIEngine.outputFixes(report);
        }
        // If the calling ui is not web then print to console
        if (!webFlag) {
            console.log(cmdFormat(report.results));
        }

        createEvidence(htmlFormat(report.results));

        if (report.errorCount === 0) {
            console.log("No linting errors. Good Job!");
        }

        ok(report);
    });
};

/**
 * This function creates the evidence directory then places the html formatted evidence file into that directory
 * if the directory already exists then it will just add the html file to the existing folder.
 * @param theHtml formatted evidence
 * @returns {undefined}
 */
const createEvidence = (theHtml) => {
    const pathForEvidenceDirectory = path.join(process.cwd(), "/evidence");
    const pathForEvidenceFile = path.join(pathForEvidenceDirectory, "theESLintEvidence.html");

    //Create the evidence directory and add eslint output file
    fs.mkdir(pathForEvidenceDirectory, (err) => {
        if (err) {
            // If directory exists already don't return! Create it.
            if (err.code != "EEXIST") {
                console.error(err);
                return;
            }

            console.log("Evidence directory already exists.");
        } else {
            console.log("New evidence directory created. Adding eslint evidence there.");
        }

        //Evidence file is present create eslint evidence with html formatted evidence
        fs.writeFile(pathForEvidenceFile , theHtml, (err) => {
            if (err){
                console.error(err);
            }

            console.log("Added theESLintEvidence to the evidence directory.")
        });
    });
};

/**
 * This function defines the 'run' command for the plugin. If the command line argument
 * srcDir is provided, it executes the linter using that path. Otherwise it returns a Promise
 * that first determines what path to use then executes the linter on that path.
 * @param gaia The MPages Gaia object
 * @param args The arguments passed to the plugin
 * @returns {Promise} Path and linter execution
 */
const run = (gaia, args) => {
    if (args.srcDir) {
        return executeLinter({ srcPath: args.srcDir, webFlag: args.webFlag, fixMode: args.fix });
    }

    // check the gaia.json config file
    return determineSrcPath(gaia, args)
        .then(path => executeLinter({ srcPath: path, webFlag: args.webFlag, fixMode: args.fix }));
};

/**
 * Runs the linter on the command line. It will fail with
 * exit status 1 if any errors are found or if the warnings count exceeds the maximum allowed
 * @param gaia The MPages Gaia object
 * @param args The arguments passed to the plugin
 * @returns {Promise} Path and linter execution
 */
const runCLI = (gaia, args) =>
    (args.srcDir ?
        Promise.resolve(args.srcDir)
        : determineSrcPath(gaia, args))
        .then((path) => executeLinter({ srcPath: path, webFlag: false, fixMode: args.fix }))
        .then((report) => {
            const maxWarnings = Number(args.maxWarnings);

            if (report.errorCount > 0 || (Number.isInteger(maxWarnings) && report.warningCount > args.maxWarnings)) {
                process.exit(1);
            }
        });

module.exports = {
    run,
    runCLI,
    determineSrcPath,
    saveSrcPath
};
