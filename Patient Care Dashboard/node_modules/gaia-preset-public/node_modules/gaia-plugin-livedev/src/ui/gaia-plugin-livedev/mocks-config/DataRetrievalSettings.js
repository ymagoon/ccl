import { UIComponent, composite, helpers } from "MPageFusion";
import { runCommand } from "Gaia";
import RecordContent from "./RecordContent";
import ReplayContent from "./ReplayContent";
import { DISPATCH, RECORD_STATE_CHANGE } from "../actions";

const { props: { forwardProp }} = helpers;
const { button: { ButtonGroup }} = composite;
const RECORD_CLICK = "__DataRetrievalSettings::RecordClick__";

const RECORD_STATES = {
    RECORD: 0,
    LIVE: 1,
    REPLAY: 2
}

/**
 * Returns the current content to be displayed in the data retrieval section
 * @param  {Integer} mode      Current recording mode (based on RECORD_STATES structure)
 * @param  {Object} properties Properties to set on child control
 * @return {String}            Returned content
 */
const contentByMode = (mode, mapped) => ({
    [RECORD_STATES.RECORD]: mapped.recordContent,
    [RECORD_STATES.REPLAY]: mapped.replayContent
}[mode]);

/**
 * Renders the passed UIComponent, or does nothing if none passed
 * @param  {UIComponent} content UIComponent to render
 * @return {*}           VDOM element or null
 */
const renderContent = (content) => content ? content.render() : null;

const forwardToContent = (control, property) =>
        (newValue) => {
            control.getChild("recordContent").setProp(property, newValue);
            control.getChild("replayContent").setProp(property, newValue);
        }

/**
 * Class for creating components that aid in the configuration of data retrieval (Live Data, Recording Requests, and Replaying Requests)
 * @class
 */
export default class DataRetrievalSettings extends UIComponent {

    /**
     * This prop change handler is necessary primarily to update the 'isSelected' property of the items
     * @inheritDoc
     */
    propChangeHandlers() {
        // Forward other properties to both record/replay tabs
        return {
            recordMode: (recordMode) => {
                this.getChild("recordSelector").setProp("items", this.getCurrentItems());
            },
            mockResponseCollectionNames: forwardToContent(this, "mockResponseCollectionNames"),
            mockResponseLocation: forwardToContent(this, "mockResponseLocation"),
            mockResponseCollection: forwardToContent(this, "mockResponseCollection")
        };
    }

    /**
     * Creates the items to be present in the button group
     * @return {Array<Object>} List of items to be present in the button group
     */
    getCurrentItems() {
        return [
            {
                display: "Live",
                id: RECORD_STATES.LIVE,
                isSelected: this.isSelected(RECORD_STATES.LIVE),
                type: "secondary"
            },
            {
                display: "Record",
                id: RECORD_STATES.RECORD,
                isSelected: this.isSelected(RECORD_STATES.RECORD),
                type: "secondary"
            },
            {
                display: "Replay",
                id: RECORD_STATES.REPLAY,
                isSelected: this.isSelected(RECORD_STATES.REPLAY),
                type: "secondary"
            }
        ]
    }

    /**
     * @inheritDoc
     */
    createChildren() {
        return [
            {
                recordSelector: new ButtonGroup({
                    canDeselect: false,
                    multiSelect: false,
                    selectionChangeEventName: RECORD_CLICK,
                    items: this.getCurrentItems()
                }, [])
            },
            {
                recordContent: new RecordContent(this.getReplayProperties())
            },
            {
                replayContent: new ReplayContent(this.getReplayProperties())
            }
        ];
    }

    /**
     * Determines whether the passed record mode is currently selected
     * @param  {Integer}  recordMode The recording mode to compare to
     * @return {Boolean}  Returns whether or not the current record mode should be selected
     */
    isSelected(recordMode) {
        return this.getProp("recordMode") === recordMode;
    }

    /**
     * Returns the replay properties to be passed to child controls
     * @return {Object} Object containing initial properties for child controls
     */
    getReplayProperties() {
        return {
            mockResponseCollectionNames: this.getProp("mockResponseCollectionNames"),
            mockResponseLocation: this.getProp("mockResponseLocation"),
            mockResponseCollection: this.getProp("mockResponseCollection")
        }
    }

    /**
     * @inheritDoc
     */
    afterCreate() {
        this.on(RECORD_CLICK, (source, payload) => {
            this.stopPropagation(RECORD_CLICK);
            const selected = payload.selected.ids[0];
            runCommand("injector", "changeRecordState", {
                recordState: selected,
            }).then(() => {
                this.emit(DISPATCH, {
                    type: RECORD_STATE_CHANGE,
                    payload: selected
                });
            });
        });
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mapped) {
        return el(
            "div",
            {},
            [
                mapped.recordSelector.render(),
                renderContent(contentByMode(props.recordMode, mapped))
            ]
        );
    }
}
