(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("MPageFusion"), require("Gaia"));
	else if(typeof define === 'function' && define.amd)
		define(["MPageFusion", "Gaia"], factory);
	else if(typeof exports === 'object')
		exports["gaia-plugin-milproxy"] = factory(require("MPageFusion"), require("Gaia"));
	else
		root["gaia-plugin-milproxy"] = factory(root["MPageFusion"], root["Gaia"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_16__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_MPageFusion__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_MPageFusion___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_MPageFusion__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MilproxyUI__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_Gaia__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_Gaia___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_Gaia__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_xhr_promise__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_xhr_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_xhr_promise__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var START_SERVER_EVENT = "MilproxyIndex::StartServer";
var STOP_SERVER_EVENT = "MilproxyIndex::StopServer";
var LOGIN_EVENT = "MilproxyIndex::Login";
var SERVER_NOT_STARTED = "ERROR_SERVER_NOT_STARTED";
var UNKNOWN_ERROR = "UNKNOWN_ERROR";

var updateStatus = function updateStatus(control) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "status", {}).then(function (status) {
        return control.getChild("ui").setProp("serverStatus", status).update();
    });
};

var retrieveLogin = function retrieveLogin(control) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "readConfig").then(function (config) {
        return control.getChild("ui").setProp("username", config.username).setProp("domain", config.domain).update();
    });
};

var saveLogin = function saveLogin(login) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "saveConfig", { config: login });
};

var MilproxyIndex = function (_Fusion$UIComponent) {
    _inherits(MilproxyIndex, _Fusion$UIComponent);

    function MilproxyIndex() {
        _classCallCheck(this, MilproxyIndex);

        return _possibleConstructorReturn(this, _Fusion$UIComponent.apply(this, arguments));
    }

    MilproxyIndex.prototype.propChangeHandlers = function propChangeHandlers() {
        return {};
    };

    MilproxyIndex.prototype.createChildren = function createChildren() {
        return [{
            ui: new __WEBPACK_IMPORTED_MODULE_1__MilproxyUI__["a" /* default */]({
                startEventName: START_SERVER_EVENT,
                stopEventName: STOP_SERVER_EVENT,
                loginEventName: LOGIN_EVENT
            })
        }];
    };

    MilproxyIndex.prototype.afterCreate = function afterCreate() {
        var _this2 = this;

        updateStatus(this);
        retrieveLogin(this);

        this.on(START_SERVER_EVENT, function () {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "start", {}).then(updateStatus.bind(null, _this2));
        });
        this.on(STOP_SERVER_EVENT, function () {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "stop", {}).then(updateStatus.bind(null, _this2));
        });
        this.on(LOGIN_EVENT, function (source, credentials) {
            saveLogin({ username: credentials.username, domain: credentials.domain });
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_Gaia__["runCommand"])("milproxy", "login", credentials).then(function (message) {
                return alert("Login successful!");
            }).catch(function (err) {
                return alert("Error: " + err);
            });
        });
    };

    MilproxyIndex.prototype.view = function view(el) {
        return this.renderChildren();
    };

    return MilproxyIndex;
}(__WEBPACK_IMPORTED_MODULE_0_MPageFusion__["UIComponent"]);

;

/* harmony default export */ __webpack_exports__["default"] = ({
    label: "Millennium Proxy",
    control: MilproxyIndex,
    showHelp: true
});

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_MPageFusion__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_MPageFusion___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_MPageFusion__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var forwardProp = __WEBPACK_IMPORTED_MODULE_0_MPageFusion__["helpers"].props.forwardProp;

var Button = __WEBPACK_IMPORTED_MODULE_0_MPageFusion__["atomic"].button.Button;
var FormTextBox = __WEBPACK_IMPORTED_MODULE_0_MPageFusion__["composite"].form.FormTextBox;
var ContentHeader = __WEBPACK_IMPORTED_MODULE_0_MPageFusion__["atomic"].header.ContentHeader;
var BannerItem = __WEBPACK_IMPORTED_MODULE_0_MPageFusion__["composite"].banner.BannerItem;

var START_SERVER_EVENT = "Internal::MilproxyUI::StartServer";
var STOP_SERVER_EVENT = "Internal::MilproxyUI::StopServer";
var USER_VAL_CHANGE_EVENT = "Internal::MilproxyUI::UserChange";
var PASSWORD_VAL_CHANGE_EVENT = "Internal::MilproxyUI::PasswordChange";
var DOMAIN_CHANGE_EVENT = "Internal::MilproxyUI::DomainChange";
var LOGIN_EVENT = "Internal::MilproxyUI::Login";

var MilproxyUI = function (_Fusion$UIComponent) {
    _inherits(MilproxyUI, _Fusion$UIComponent);

    function MilproxyUI(props, children) {
        _classCallCheck(this, MilproxyUI);

        var _this = _possibleConstructorReturn(this, _Fusion$UIComponent.call(this, props, children));

        _this._state = {
            username: "",
            password: "",
            domain: ""
        };
        return _this;
    }

    MilproxyUI.prototype.initialProps = function initialProps() {
        return {
            serverStatus: {},
            startEventName: null,
            stopEventName: null,
            loginEventName: null
        };
    };

    MilproxyUI.prototype.propChangeHandlers = function propChangeHandlers() {
        var _this2 = this;

        return {
            username: function username(value) {
                _this2._state.username = value;
                _this2.getChild("username").setProp("value", value);
            },
            password: function password(value) {
                _this2._state.password = value;
                _this2.getChild("password").setProp("value", value);
            },
            domain: function domain(value) {
                _this2._state.domain = value;
                _this2.getChild("domain").setProp("value", value);
            }
        };
    };

    MilproxyUI.prototype.createChildren = function createChildren() {
        return [{
            startServerButton: new Button({
                display: "Start",
                clickEventName: START_SERVER_EVENT
            })
        }, {
            stopServerButton: new Button({
                display: "Stop",
                clickEventName: STOP_SERVER_EVENT
            })
        }, {
            username: new FormTextBox({
                display: "User",
                valueChangeEventName: USER_VAL_CHANGE_EVENT
            })
        }, {
            password: new FormTextBox({
                display: "Password",
                options: {
                    inputType: "password"
                },
                valueChangeEventName: PASSWORD_VAL_CHANGE_EVENT
            })
        }, {
            domain: new FormTextBox({
                display: "Domain",
                valueChangeEventName: DOMAIN_CHANGE_EVENT
            })
        }, {
            loginButton: new Button({
                display: "Login",
                clickEventName: LOGIN_EVENT
            })
        }];
    };

    MilproxyUI.prototype.afterCreate = function afterCreate() {
        var _this3 = this;

        this.convertEventUsingProp(START_SERVER_EVENT, "startEventName", function () {
            return [_this3];
        });
        this.convertEventUsingProp(STOP_SERVER_EVENT, "stopEventName", function () {
            return [_this3];
        });
        this.convertEventUsingProp(LOGIN_EVENT, "loginEventName", function () {
            return [_this3, {
                username: _this3._state.username,
                password: _this3._state.password,
                domain: _this3._state.domain
            }];
        });
        this.on(USER_VAL_CHANGE_EVENT, function (source, val) {
            _this3._state.username = val.value;
        });
        this.on(PASSWORD_VAL_CHANGE_EVENT, function (source, val) {
            _this3._state.password = val.value;
        });
        this.on(DOMAIN_CHANGE_EVENT, function (source, val) {
            _this3._state.domain = val.value;
        });
    };

    MilproxyUI.prototype.view = function view(el, props, arr, children) {
        return el("div", {
            class: "gaia-root-section"
        }, [new BannerItem({
            title: "Proxy will run at http://localhost:8081/mil",
            description: "CCL can be ran through the reports URL, such as http://localhost:8081/mil/reports/CCL_SCRIPT_NAME?parameters=params",
            enableDismissClick: false
        }).render(), new ContentHeader({ title: "Server" }).render(), el("div", {
            class: "gaia-section"
        }, ["Server status: " + (props.serverStatus.isRunning ? "Running " : "Stopped "), children.startServerButton.render(), " ", children.stopServerButton.render()]), new ContentHeader({ title: "Domain Login" }).render(), el("div", {
            class: "gaia-section"
        }, [children.username.render(), children.password.render(), children.domain.render(), children.loginButton.render()])]);
    };

    return MilproxyUI;
}(__WEBPACK_IMPORTED_MODULE_0_MPageFusion__["UIComponent"]);

/* harmony default export */ __webpack_exports__["a"] = (MilproxyUI);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(5);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var trim = __webpack_require__(11)
  , forEach = __webpack_require__(4)
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}

/***/ }),
/* 8 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â€“8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(8)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(9);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {


exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(13);


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if (global.Promise == null) {
  global.Promise = __webpack_require__(15);
}

if (Object.assign == null) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: __webpack_require__(6)
  });
}

module.exports = __webpack_require__(14);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {


/*
 * Copyright 2015 Scott Brady
 * MIT License
 * https://github.com/scottbrady/xhr-promise/blob/master/LICENSE
 */
var ParseHeaders, XMLHttpRequestPromise;

ParseHeaders = __webpack_require__(7);


/*
 * Module to wrap an XMLHttpRequest in a promise.
 */

module.exports = XMLHttpRequestPromise = (function() {
  function XMLHttpRequestPromise() {}

  XMLHttpRequestPromise.DEFAULT_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=UTF-8';


  /*
   * XMLHttpRequestPromise.send(options) -> Promise
   * - options (Object): URL, method, data, etc.
   *
   * Create the XHR object and wire up event handlers to use a promise.
   */

  XMLHttpRequestPromise.prototype.send = function(options) {
    var defaults;
    if (options == null) {
      options = {};
    }
    defaults = {
      method: 'GET',
      data: null,
      headers: {},
      async: true,
      username: null,
      password: null,
      withCredentials: false
    };
    options = Object.assign({}, defaults, options);
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var e, header, ref, value, xhr;
        if (!XMLHttpRequest) {
          _this._handleError('browser', reject, null, "browser doesn't support XMLHttpRequest");
          return;
        }
        if (typeof options.url !== 'string' || options.url.length === 0) {
          _this._handleError('url', reject, null, 'URL is a required parameter');
          return;
        }
        _this._xhr = xhr = new XMLHttpRequest;
        xhr.onload = function() {
          var responseText;
          _this._detachWindowUnload();
          try {
            responseText = _this._getResponseText();
          } catch (_error) {
            _this._handleError('parse', reject, null, 'invalid JSON response');
            return;
          }
          return resolve({
            url: _this._getResponseUrl(),
            status: xhr.status,
            statusText: xhr.statusText,
            responseText: responseText,
            headers: _this._getHeaders(),
            xhr: xhr
          });
        };
        xhr.onerror = function() {
          return _this._handleError('error', reject);
        };
        xhr.ontimeout = function() {
          return _this._handleError('timeout', reject);
        };
        xhr.onabort = function() {
          return _this._handleError('abort', reject);
        };
        _this._attachWindowUnload();
        xhr.open(options.method, options.url, options.async, options.username, options.password);
        if (options.withCredentials) {
          xhr.withCredentials = true;
        }
        if ((options.data != null) && !options.headers['Content-Type']) {
          options.headers['Content-Type'] = _this.constructor.DEFAULT_CONTENT_TYPE;
        }
        ref = options.headers;
        for (header in ref) {
          value = ref[header];
          xhr.setRequestHeader(header, value);
        }
        try {
          return xhr.send(options.data);
        } catch (_error) {
          e = _error;
          return _this._handleError('send', reject, null, e.toString());
        }
      };
    })(this));
  };


  /*
   * XMLHttpRequestPromise.getXHR() -> XMLHttpRequest
   */

  XMLHttpRequestPromise.prototype.getXHR = function() {
    return this._xhr;
  };


  /*
   * XMLHttpRequestPromise._attachWindowUnload()
   *
   * Fix for IE 9 and IE 10
   * Internet Explorer freezes when you close a webpage during an XHR request
   * https://support.microsoft.com/kb/2856746
   *
   */

  XMLHttpRequestPromise.prototype._attachWindowUnload = function() {
    this._unloadHandler = this._handleWindowUnload.bind(this);
    if (window.attachEvent) {
      return window.attachEvent('onunload', this._unloadHandler);
    }
  };


  /*
   * XMLHttpRequestPromise._detachWindowUnload()
   */

  XMLHttpRequestPromise.prototype._detachWindowUnload = function() {
    if (window.detachEvent) {
      return window.detachEvent('onunload', this._unloadHandler);
    }
  };


  /*
   * XMLHttpRequestPromise._getHeaders() -> Object
   */

  XMLHttpRequestPromise.prototype._getHeaders = function() {
    return ParseHeaders(this._xhr.getAllResponseHeaders());
  };


  /*
   * XMLHttpRequestPromise._getResponseText() -> Mixed
   *
   * Parses response text JSON if present.
   */

  XMLHttpRequestPromise.prototype._getResponseText = function() {
    var responseText;
    responseText = typeof this._xhr.responseText === 'string' ? this._xhr.responseText : '';
    switch ((this._xhr.getResponseHeader('Content-Type') || '').split(';')[0]) {
      case 'application/json':
      case 'text/javascript':
        responseText = JSON.parse(responseText + '');
    }
    return responseText;
  };


  /*
   * XMLHttpRequestPromise._getResponseUrl() -> String
   *
   * Actual response URL after following redirects.
   */

  XMLHttpRequestPromise.prototype._getResponseUrl = function() {
    if (this._xhr.responseURL != null) {
      return this._xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(this._xhr.getAllResponseHeaders())) {
      return this._xhr.getResponseHeader('X-Request-URL');
    }
    return '';
  };


  /*
   * XMLHttpRequestPromise._handleError(reason, reject, status, statusText)
   * - reason (String)
   * - reject (Function)
   * - status (String)
   * - statusText (String)
   */

  XMLHttpRequestPromise.prototype._handleError = function(reason, reject, status, statusText) {
    this._detachWindowUnload();
    return reject({
      reason: reason,
      status: status || this._xhr.status,
      statusText: statusText || this._xhr.statusText,
      xhr: this._xhr
    });
  };


  /*
   * XMLHttpRequestPromise._handleWindowUnload()
   */

  XMLHttpRequestPromise.prototype._handleWindowUnload = function() {
    return this._xhr.abort();
  };

  return XMLHttpRequestPromise;

})();


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {!function(t){"use strict";function e(t){if(t){var e=this;t(function(t){e.resolve(t)},function(t){e.reject(t)})}}function n(t,e){if("function"==typeof t.y)try{var n=t.y.call(i,e);t.p.resolve(n)}catch(o){t.p.reject(o)}else t.p.resolve(e)}function o(t,e){if("function"==typeof t.n)try{var n=t.n.call(i,e);t.p.resolve(n)}catch(o){t.p.reject(o)}else t.p.reject(e)}var r,i,c="fulfilled",u="rejected",s="undefined",f=function(){function e(){for(;n.length-o;){try{n[o]()}catch(e){t.console&&t.console.error(e)}n[o++]=i,o==r&&(n.splice(0,r),o=0)}}var n=[],o=0,r=1024,c=function(){if(typeof MutationObserver!==s){var t=document.createElement("div"),n=new MutationObserver(e);return n.observe(t,{attributes:!0}),function(){t.setAttribute("a",0)}}return typeof setImmediate!==s?function(){setImmediate(e)}:function(){setTimeout(e,0)}}();return function(t){n.push(t),n.length-o==1&&c()}}();e.prototype={resolve:function(t){if(this.state===r){if(t===this)return this.reject(new TypeError("Attempt to resolve promise with self"));var e=this;if(t&&("function"==typeof t||"object"==typeof t))try{var o=!0,i=t.then;if("function"==typeof i)return void i.call(t,function(t){o&&(o=!1,e.resolve(t))},function(t){o&&(o=!1,e.reject(t))})}catch(u){return void(o&&this.reject(u))}this.state=c,this.v=t,e.c&&f(function(){for(var o=0,r=e.c.length;r>o;o++)n(e.c[o],t)})}},reject:function(n){if(this.state===r){this.state=u,this.v=n;var i=this.c;i?f(function(){for(var t=0,e=i.length;e>t;t++)o(i[t],n)}):!e.suppressUncaughtRejectionError&&t.console&&t.console.log("You upset Zousan. Please catch rejections: ",n,n?n.stack:null)}},then:function(t,i){var u=new e,s={y:t,n:i,p:u};if(this.state===r)this.c?this.c.push(s):this.c=[s];else{var l=this.state,a=this.v;f(function(){l===c?n(s,a):o(s,a)})}return u},"catch":function(t){return this.then(null,t)},"finally":function(t){return this.then(t,t)},timeout:function(t,n){n=n||"Timeout";var o=this;return new e(function(e,r){setTimeout(function(){r(Error(n))},t),o.then(function(t){e(t)},function(t){r(t)})})}},e.resolve=function(t){var n=new e;return n.resolve(t),n},e.reject=function(t){var n=new e;return n.reject(t),n},e.all=function(t){function n(n,c){n&&"function"==typeof n.then||(n=e.resolve(n)),n.then(function(e){o[c]=e,r++,r==t.length&&i.resolve(o)},function(t){i.reject(t)})}for(var o=[],r=0,i=new e,c=0;c<t.length;c++)n(t[c],c);return t.length||i.resolve(o),i},typeof module!=s&&module.exports&&(module.exports=e),t.define&&t.define.amd&&t.define([],function(){return e}),t.Zousan=e,e.soon=f}("undefined"!=typeof global?global:this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(10).setImmediate))

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhZjg4NzkyMTJkYTNjMjMwYjcwZiIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIk1QYWdlRnVzaW9uXCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VpL2dhaWEtcGx1Z2luLW1pbHByb3h5L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy91aS9nYWlhLXBsdWdpbi1taWxwcm94eS9NaWxwcm94eVVJLmpzIiwid2VicGFjazovLy8uL34vZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1jYWxsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3RyaW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi94aHItcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3hoci1wcm9taXNlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3hoci1wcm9taXNlL2xpYi94aHItcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pvdXNhbi96b3VzYW4tbWluLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIkdhaWFcIiJdLCJuYW1lcyI6WyJTVEFSVF9TRVJWRVJfRVZFTlQiLCJTVE9QX1NFUlZFUl9FVkVOVCIsIkxPR0lOX0VWRU5UIiwiU0VSVkVSX05PVF9TVEFSVEVEIiwiVU5LTk9XTl9FUlJPUiIsInVwZGF0ZVN0YXR1cyIsImNvbnRyb2wiLCJydW5Db21tYW5kIiwidGhlbiIsInN0YXR1cyIsImdldENoaWxkIiwic2V0UHJvcCIsInVwZGF0ZSIsInJldHJpZXZlTG9naW4iLCJjb25maWciLCJ1c2VybmFtZSIsImRvbWFpbiIsInNhdmVMb2dpbiIsImxvZ2luIiwiTWlscHJveHlJbmRleCIsInByb3BDaGFuZ2VIYW5kbGVycyIsImNyZWF0ZUNoaWxkcmVuIiwidWkiLCJzdGFydEV2ZW50TmFtZSIsInN0b3BFdmVudE5hbWUiLCJsb2dpbkV2ZW50TmFtZSIsImFmdGVyQ3JlYXRlIiwib24iLCJiaW5kIiwic291cmNlIiwiY3JlZGVudGlhbHMiLCJtZXNzYWdlIiwiYWxlcnQiLCJjYXRjaCIsImVyciIsInZpZXciLCJlbCIsInJlbmRlckNoaWxkcmVuIiwibGFiZWwiLCJzaG93SGVscCIsImZvcndhcmRQcm9wIiwicHJvcHMiLCJCdXR0b24iLCJidXR0b24iLCJGb3JtVGV4dEJveCIsImZvcm0iLCJDb250ZW50SGVhZGVyIiwiaGVhZGVyIiwiQmFubmVySXRlbSIsImJhbm5lciIsIlVTRVJfVkFMX0NIQU5HRV9FVkVOVCIsIlBBU1NXT1JEX1ZBTF9DSEFOR0VfRVZFTlQiLCJET01BSU5fQ0hBTkdFX0VWRU5UIiwiTWlscHJveHlVSSIsImNoaWxkcmVuIiwiX3N0YXRlIiwicGFzc3dvcmQiLCJpbml0aWFsUHJvcHMiLCJzZXJ2ZXJTdGF0dXMiLCJ2YWx1ZSIsInN0YXJ0U2VydmVyQnV0dG9uIiwiZGlzcGxheSIsImNsaWNrRXZlbnROYW1lIiwic3RvcFNlcnZlckJ1dHRvbiIsInZhbHVlQ2hhbmdlRXZlbnROYW1lIiwib3B0aW9ucyIsImlucHV0VHlwZSIsImxvZ2luQnV0dG9uIiwiY29udmVydEV2ZW50VXNpbmdQcm9wIiwidmFsIiwiYXJyIiwiY2xhc3MiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZW5hYmxlRGlzbWlzc0NsaWNrIiwicmVuZGVyIiwi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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7QUN2THRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUksY0FBYywrSEFBK0gsb0JBQW9CLGVBQWUsYUFBYSxtREFBbUQsS0FBSywwQkFBMEIsYUFBYSxvQkFBb0IsRUFBRSxTQUFTLHFCQUFxQix5QkFBeUIsdUJBQXVCLHNCQUFzQix1QkFBdUIsZUFBZSxXQUFXLDJCQUEyQixzQkFBc0IsWUFBWSx1QkFBdUIsS0FBSyxhQUFhLEtBQUssRUFBRSxHQUFHLHVCQUF1QixZQUFZLHNCQUFzQixzQkFBc0IsWUFBWSxxQkFBcUIsbUJBQW1CLGdCQUFnQixrRUFBa0UscUNBQXFDLGFBQWEsWUFBWSxFQUFFLDZCQUE2QixXQUFXLGNBQWMsZ0NBQWdDLHFHQUFxRyxTQUFTLHNCQUFzQix5Qzs7Ozs7OztBQ0F4OUUsZ0QiLCJmaWxlIjoiZGlzdC91aS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIk1QYWdlRnVzaW9uXCIpLCByZXF1aXJlKFwiR2FpYVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJNUGFnZUZ1c2lvblwiLCBcIkdhaWFcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZ2FpYS1wbHVnaW4tbWlscHJveHlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJNUGFnZUZ1c2lvblwiKSwgcmVxdWlyZShcIkdhaWFcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImdhaWEtcGx1Z2luLW1pbHByb3h5XCJdID0gZmFjdG9yeShyb290W1wiTVBhZ2VGdXNpb25cIl0sIHJvb3RbXCJHYWlhXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzE2X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYWY4ODc5MjEyZGEzYzIzMGI3MGYiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIk1QYWdlRnVzaW9uXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgRnVzaW9uIGZyb20gXCJNUGFnZUZ1c2lvblwiO1xyXG5pbXBvcnQgTWlscHJveHlVSSBmcm9tIFwiLi9NaWxwcm94eVVJXCI7XHJcbmltcG9ydCB7IHJ1bkNvbW1hbmQgfSBmcm9tIFwiR2FpYVwiO1xyXG5pbXBvcnQgUmVxdWVzdCBmcm9tIFwieGhyLXByb21pc2VcIjtcclxuXHJcbmNvbnN0IFNUQVJUX1NFUlZFUl9FVkVOVCA9IFwiTWlscHJveHlJbmRleDo6U3RhcnRTZXJ2ZXJcIjtcclxuY29uc3QgU1RPUF9TRVJWRVJfRVZFTlQgPSBcIk1pbHByb3h5SW5kZXg6OlN0b3BTZXJ2ZXJcIjtcclxuY29uc3QgTE9HSU5fRVZFTlQgPSBcIk1pbHByb3h5SW5kZXg6OkxvZ2luXCI7XHJcbmNvbnN0IFNFUlZFUl9OT1RfU1RBUlRFRCA9IFwiRVJST1JfU0VSVkVSX05PVF9TVEFSVEVEXCI7XHJcbmNvbnN0IFVOS05PV05fRVJST1IgPSBcIlVOS05PV05fRVJST1JcIjtcclxuXHJcbmNvbnN0IHVwZGF0ZVN0YXR1cyA9IChjb250cm9sKSA9PlxyXG4gICAgICBydW5Db21tYW5kKFwibWlscHJveHlcIiwgXCJzdGF0dXNcIiwge30pXHJcbiAgICAgIC50aGVuKChzdGF0dXMpID0+XHJcbiAgICAgICAgICAgIGNvbnRyb2xcclxuICAgICAgICAgICAgLmdldENoaWxkKFwidWlcIilcclxuICAgICAgICAgICAgLnNldFByb3AoXCJzZXJ2ZXJTdGF0dXNcIiwgc3RhdHVzKVxyXG4gICAgICAgICAgICAudXBkYXRlKClcclxuICAgICAgICAgICApO1xyXG5cclxuY29uc3QgcmV0cmlldmVMb2dpbiA9IChjb250cm9sKSA9PlxyXG4gICAgICBydW5Db21tYW5kKFxyXG4gICAgICAgICAgXCJtaWxwcm94eVwiLFxyXG4gICAgICAgICAgXCJyZWFkQ29uZmlnXCJcclxuICAgICAgKS50aGVuKChjb25maWcpID0+XHJcbiAgICAgICAgICBjb250cm9sXHJcbiAgICAgICAgICAgICAgLmdldENoaWxkKFwidWlcIilcclxuICAgICAgICAgICAgICAuc2V0UHJvcChcInVzZXJuYW1lXCIsIGNvbmZpZy51c2VybmFtZSlcclxuICAgICAgICAgICAgICAuc2V0UHJvcChcImRvbWFpblwiLCBjb25maWcuZG9tYWluKVxyXG4gICAgICAgICAgICAgIC51cGRhdGUoKVxyXG4gICAgICApO1xyXG5cclxuY29uc3Qgc2F2ZUxvZ2luICA9IChsb2dpbikgPT5cclxuICAgICAgcnVuQ29tbWFuZChcclxuICAgICAgICAgIFwibWlscHJveHlcIixcclxuICAgICAgICAgIFwic2F2ZUNvbmZpZ1wiLFxyXG4gICAgICAgICAgeyBjb25maWc6IGxvZ2luIH1cclxuICAgICAgKTtcclxuXHJcbmNsYXNzIE1pbHByb3h5SW5kZXggZXh0ZW5kcyBGdXNpb24uVUlDb21wb25lbnQge1xyXG5cclxuICAgIHByb3BDaGFuZ2VIYW5kbGVycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdWkgOiBuZXcgTWlscHJveHlVSSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudE5hbWU6IFNUQVJUX1NFUlZFUl9FVkVOVCxcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRXZlbnROYW1lOiBTVE9QX1NFUlZFUl9FVkVOVCxcclxuICAgICAgICAgICAgICAgICAgICBsb2dpbkV2ZW50TmFtZTogTE9HSU5fRVZFTlRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGFmdGVyQ3JlYXRlKCkge1xyXG4gICAgICAgIHVwZGF0ZVN0YXR1cyh0aGlzKTtcclxuICAgICAgICByZXRyaWV2ZUxvZ2luKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLm9uKFxyXG4gICAgICAgICAgICBTVEFSVF9TRVJWRVJfRVZFTlQsXHJcbiAgICAgICAgICAgICgpID0+IHJ1bkNvbW1hbmQoXCJtaWxwcm94eVwiLCBcInN0YXJ0XCIsIHt9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlU3RhdHVzLmJpbmQobnVsbCwgdGhpcykpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLm9uKFxyXG4gICAgICAgICAgICBTVE9QX1NFUlZFUl9FVkVOVCxcclxuICAgICAgICAgICAgKCkgPT4gcnVuQ29tbWFuZChcIm1pbHByb3h5XCIsIFwic3RvcFwiLCB7fSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVN0YXR1cy5iaW5kKG51bGwsIHRoaXMpKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5vbihcclxuICAgICAgICAgICAgTE9HSU5fRVZFTlQsXHJcbiAgICAgICAgICAgIChzb3VyY2UsIGNyZWRlbnRpYWxzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlTG9naW4oeyB1c2VybmFtZTogY3JlZGVudGlhbHMudXNlcm5hbWUsIGRvbWFpbjogY3JlZGVudGlhbHMuZG9tYWluIH0pO1xyXG4gICAgICAgICAgICAgICAgcnVuQ29tbWFuZChcIm1pbHByb3h5XCIsIFwibG9naW5cIiwgY3JlZGVudGlhbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKG1lc3NhZ2UpID0+IGFsZXJ0KFwiTG9naW4gc3VjY2Vzc2Z1bCFcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGFsZXJ0KGBFcnJvcjogJHtlcnJ9YCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHZpZXcoZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGxhYmVsOiBcIk1pbGxlbm5pdW0gUHJveHlcIixcclxuXHRjb250cm9sOiBNaWxwcm94eUluZGV4LFxyXG4gIHNob3dIZWxwOiB0cnVlXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91aS9nYWlhLXBsdWdpbi1taWxwcm94eS9pbmRleC5qcyIsImltcG9ydCAqIGFzIEZ1c2lvbiBmcm9tIFwiTVBhZ2VGdXNpb25cIjtcclxuXHJcbmNvbnN0IHsgZm9yd2FyZFByb3AgfSA9IEZ1c2lvbi5oZWxwZXJzLnByb3BzO1xyXG5jb25zdCBCdXR0b24gPSBGdXNpb24uYXRvbWljLmJ1dHRvbi5CdXR0b247XHJcbmNvbnN0IEZvcm1UZXh0Qm94ID0gRnVzaW9uLmNvbXBvc2l0ZS5mb3JtLkZvcm1UZXh0Qm94O1xyXG5jb25zdCBDb250ZW50SGVhZGVyID0gRnVzaW9uLmF0b21pYy5oZWFkZXIuQ29udGVudEhlYWRlcjtcclxuY29uc3QgQmFubmVySXRlbSA9IEZ1c2lvbi5jb21wb3NpdGUuYmFubmVyLkJhbm5lckl0ZW07XHJcblxyXG5jb25zdCBTVEFSVF9TRVJWRVJfRVZFTlQgPSBcIkludGVybmFsOjpNaWxwcm94eVVJOjpTdGFydFNlcnZlclwiO1xyXG5jb25zdCBTVE9QX1NFUlZFUl9FVkVOVCA9IFwiSW50ZXJuYWw6Ok1pbHByb3h5VUk6OlN0b3BTZXJ2ZXJcIjtcclxuY29uc3QgVVNFUl9WQUxfQ0hBTkdFX0VWRU5UID0gXCJJbnRlcm5hbDo6TWlscHJveHlVSTo6VXNlckNoYW5nZVwiO1xyXG5jb25zdCBQQVNTV09SRF9WQUxfQ0hBTkdFX0VWRU5UID0gXCJJbnRlcm5hbDo6TWlscHJveHlVSTo6UGFzc3dvcmRDaGFuZ2VcIjtcclxuY29uc3QgRE9NQUlOX0NIQU5HRV9FVkVOVCA9IFwiSW50ZXJuYWw6Ok1pbHByb3h5VUk6OkRvbWFpbkNoYW5nZVwiO1xyXG5jb25zdCBMT0dJTl9FVkVOVCA9IFwiSW50ZXJuYWw6Ok1pbHByb3h5VUk6OkxvZ2luXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaWxwcm94eVVJIGV4dGVuZHMgRnVzaW9uLlVJQ29tcG9uZW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY2hpbGRyZW4pIHtcclxuICAgICAgICBzdXBlcihwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0ge1xyXG4gICAgICAgICAgICB1c2VybmFtZTogXCJcIixcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IFwiXCIsXHJcbiAgICAgICAgICAgIGRvbWFpbjogXCJcIlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbFByb3BzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlcnZlclN0YXR1czoge30sXHJcbiAgICAgICAgICAgIHN0YXJ0RXZlbnROYW1lOiBudWxsLFxyXG4gICAgICAgICAgICBzdG9wRXZlbnROYW1lOiBudWxsLFxyXG4gICAgICAgICAgICBsb2dpbkV2ZW50TmFtZTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJvcENoYW5nZUhhbmRsZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnVzZXJuYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldENoaWxkKFwidXNlcm5hbWVcIikuc2V0UHJvcChcInZhbHVlXCIsIHZhbHVlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXNzd29yZDogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5wYXNzd29yZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDaGlsZChcInBhc3N3b3JkXCIpLnNldFByb3AoXCJ2YWx1ZVwiLCB2YWx1ZSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG9tYWluOiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmRvbWFpbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDaGlsZChcImRvbWFpblwiKS5zZXRQcm9wKFwidmFsdWVcIiwgdmFsdWUpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U2VydmVyQnV0dG9uIDogbmV3IEJ1dHRvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJTdGFydFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRXZlbnROYW1lOiBTVEFSVF9TRVJWRVJfRVZFTlRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3BTZXJ2ZXJCdXR0b24gOiBuZXcgQnV0dG9uKHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIlN0b3BcIixcclxuICAgICAgICAgICAgICAgICAgICBjbGlja0V2ZW50TmFtZTogU1RPUF9TRVJWRVJfRVZFTlRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBuZXcgRm9ybVRleHRCb3goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiVXNlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlRXZlbnROYW1lOiBVU0VSX1ZBTF9DSEFOR0VfRVZFTlRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBuZXcgRm9ybVRleHRCb3goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiUGFzc3dvcmRcIixcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogXCJwYXNzd29yZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZUV2ZW50TmFtZTogUEFTU1dPUkRfVkFMX0NIQU5HRV9FVkVOVFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluOiBuZXcgRm9ybVRleHRCb3goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiRG9tYWluXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVDaGFuZ2VFdmVudE5hbWU6IERPTUFJTl9DSEFOR0VfRVZFTlRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvZ2luQnV0dG9uOiBuZXcgQnV0dG9uKHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIkxvZ2luXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tFdmVudE5hbWU6IExPR0lOX0VWRU5UXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgYWZ0ZXJDcmVhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0RXZlbnRVc2luZ1Byb3AoXHJcbiAgICAgICAgICAgIFNUQVJUX1NFUlZFUl9FVkVOVCxcclxuICAgICAgICAgICAgXCJzdGFydEV2ZW50TmFtZVwiLFxyXG4gICAgICAgICAgICAoKSA9PiBbIHRoaXMgXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0RXZlbnRVc2luZ1Byb3AoXHJcbiAgICAgICAgICAgIFNUT1BfU0VSVkVSX0VWRU5ULFxyXG4gICAgICAgICAgICBcInN0b3BFdmVudE5hbWVcIixcclxuICAgICAgICAgICAgKCkgPT4gWyB0aGlzIF1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuY29udmVydEV2ZW50VXNpbmdQcm9wKFxyXG4gICAgICAgICAgICBMT0dJTl9FVkVOVCxcclxuICAgICAgICAgICAgXCJsb2dpbkV2ZW50TmFtZVwiLFxyXG4gICAgICAgICAgICAoKSA9PlxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdGhpcy5fc3RhdGUudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9zdGF0ZS5wYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiB0aGlzLl9zdGF0ZS5kb21haW5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLm9uKFxyXG4gICAgICAgICAgICBVU0VSX1ZBTF9DSEFOR0VfRVZFTlQsXHJcbiAgICAgICAgICAgIChzb3VyY2UsIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUudXNlcm5hbWUgPSB2YWwudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMub24oXHJcbiAgICAgICAgICAgIFBBU1NXT1JEX1ZBTF9DSEFOR0VfRVZFTlQsXHJcbiAgICAgICAgICAgIChzb3VyY2UsIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUucGFzc3dvcmQgPSB2YWwudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMub24oXHJcbiAgICAgICAgICAgIERPTUFJTl9DSEFOR0VfRVZFTlQsXHJcbiAgICAgICAgICAgIChzb3VyY2UsIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUuZG9tYWluID0gdmFsLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB2aWV3KGVsLCBwcm9wcywgYXJyLCBjaGlsZHJlbikge1xyXG4gICAgICAgIHJldHVybiBlbChcclxuICAgICAgICAgICAgXCJkaXZcIixcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZ2FpYS1yb290LXNlY3Rpb25cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBuZXcgQmFubmVySXRlbSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiUHJveHkgd2lsbCBydW4gYXQgaHR0cDovL2xvY2FsaG9zdDo4MDgxL21pbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ0NMIGNhbiBiZSByYW4gdGhyb3VnaCB0aGUgcmVwb3J0cyBVUkwsIHN1Y2ggYXMgaHR0cDovL2xvY2FsaG9zdDo4MDgxL21pbC9yZXBvcnRzL0NDTF9TQ1JJUFRfTkFNRT9wYXJhbWV0ZXJzPXBhcmFtc2AsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlRGlzbWlzc0NsaWNrOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSkucmVuZGVyKCksXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29udGVudEhlYWRlcih7IHRpdGxlOiBcIlNlcnZlclwiIH0pLnJlbmRlcigpLFxyXG4gICAgICAgICAgICAgICAgZWwoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImdhaWEtc2VjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTZXJ2ZXIgc3RhdHVzOiAke3Byb3BzLnNlcnZlclN0YXR1cy5pc1J1bm5pbmcgPyBcIlJ1bm5pbmcgXCIgOiBcIlN0b3BwZWQgXCJ9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3RhcnRTZXJ2ZXJCdXR0b24ucmVuZGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zdG9wU2VydmVyQnV0dG9uLnJlbmRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29udGVudEhlYWRlcih7IHRpdGxlOiBcIkRvbWFpbiBMb2dpblwiIH0pLnJlbmRlcigpLFxyXG4gICAgICAgICAgICAgICAgZWwoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImdhaWEtc2VjdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVzZXJuYW1lLnJlbmRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wYXNzd29yZC5yZW5kZXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uZG9tYWluLnJlbmRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5sb2dpbkJ1dHRvbi5yZW5kZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3VpL2dhaWEtcGx1Z2luLW1pbHByb3h5L01pbHByb3h5VUkuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3ItZWFjaC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXMtY2FsbGFibGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RyaW0vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94aHItcHJvbWlzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKGdsb2JhbC5Qcm9taXNlID09IG51bGwpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSByZXF1aXJlKCd6b3VzYW4nKTtcbn1cblxuaWYgKE9iamVjdC5hc3NpZ24gPT0gbnVsbCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4veGhyLXByb21pc2UnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94aHItcHJvbWlzZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLypcbiAqIENvcHlyaWdodCAyMDE1IFNjb3R0IEJyYWR5XG4gKiBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0YnJhZHkveGhyLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG52YXIgUGFyc2VIZWFkZXJzLCBYTUxIdHRwUmVxdWVzdFByb21pc2U7XG5cblBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJ3BhcnNlLWhlYWRlcnMnKTtcblxuXG4vKlxuICogTW9kdWxlIHRvIHdyYXAgYW4gWE1MSHR0cFJlcXVlc3QgaW4gYSBwcm9taXNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3RQcm9taXNlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdFByb21pc2UoKSB7fVxuXG4gIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5ERUZBVUxUX0NPTlRFTlRfVFlQRSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnO1xuXG5cbiAgLypcbiAgICogWE1MSHR0cFJlcXVlc3RQcm9taXNlLnNlbmQob3B0aW9ucykgLT4gUHJvbWlzZVxuICAgKiAtIG9wdGlvbnMgKE9iamVjdCk6IFVSTCwgbWV0aG9kLCBkYXRhLCBldGMuXG4gICAqXG4gICAqIENyZWF0ZSB0aGUgWEhSIG9iamVjdCBhbmQgd2lyZSB1cCBldmVudCBoYW5kbGVycyB0byB1c2UgYSBwcm9taXNlLlxuICAgKi9cblxuICBYTUxIdHRwUmVxdWVzdFByb21pc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRzO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgZGVmYXVsdHMgPSB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgYXN5bmM6IHRydWUsXG4gICAgICB1c2VybmFtZTogbnVsbCxcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZVxuICAgIH07XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBlLCBoZWFkZXIsIHJlZiwgdmFsdWUsIHhocjtcbiAgICAgICAgaWYgKCFYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVFcnJvcignYnJvd3NlcicsIHJlamVjdCwgbnVsbCwgXCJicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnVybCAhPT0gJ3N0cmluZycgfHwgb3B0aW9ucy51cmwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZUVycm9yKCd1cmwnLCByZWplY3QsIG51bGwsICdVUkwgaXMgYSByZXF1aXJlZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3hociA9IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZXNwb25zZVRleHQ7XG4gICAgICAgICAgX3RoaXMuX2RldGFjaFdpbmRvd1VubG9hZCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZVRleHQgPSBfdGhpcy5fZ2V0UmVzcG9uc2VUZXh0KCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlRXJyb3IoJ3BhcnNlJywgcmVqZWN0LCBudWxsLCAnaW52YWxpZCBKU09OIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgIHVybDogX3RoaXMuX2dldFJlc3BvbnNlVXJsKCksXG4gICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogX3RoaXMuX2dldEhlYWRlcnMoKSxcbiAgICAgICAgICAgIHhocjogeGhyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVFcnJvcignZXJyb3InLCByZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVFcnJvcigndGltZW91dCcsIHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVFcnJvcignYWJvcnQnLCByZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fYXR0YWNoV2luZG93VW5sb2FkKCk7XG4gICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCwgb3B0aW9ucy5hc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCk7XG4gICAgICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob3B0aW9ucy5kYXRhICE9IG51bGwpICYmICFvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IF90aGlzLmNvbnN0cnVjdG9yLkRFRkFVTFRfQ09OVEVOVF9UWVBFO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IG9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgZm9yIChoZWFkZXIgaW4gcmVmKSB7XG4gICAgICAgICAgdmFsdWUgPSByZWZbaGVhZGVyXTtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB4aHIuc2VuZChvcHRpb25zLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlRXJyb3IoJ3NlbmQnLCByZWplY3QsIG51bGwsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkodGhpcykpO1xuICB9O1xuXG5cbiAgLypcbiAgICogWE1MSHR0cFJlcXVlc3RQcm9taXNlLmdldFhIUigpIC0+IFhNTEh0dHBSZXF1ZXN0XG4gICAqL1xuXG4gIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5wcm90b3R5cGUuZ2V0WEhSID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5fYXR0YWNoV2luZG93VW5sb2FkKClcbiAgICpcbiAgICogRml4IGZvciBJRSA5IGFuZCBJRSAxMFxuICAgKiBJbnRlcm5ldCBFeHBsb3JlciBmcmVlemVzIHdoZW4geW91IGNsb3NlIGEgd2VicGFnZSBkdXJpbmcgYW4gWEhSIHJlcXVlc3RcbiAgICogaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NlxuICAgKlxuICAgKi9cblxuICBYTUxIdHRwUmVxdWVzdFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hXaW5kb3dVbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmxvYWRIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93VW5sb2FkLmJpbmQodGhpcyk7XG4gICAgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB0aGlzLl91bmxvYWRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cblxuICAvKlxuICAgKiBYTUxIdHRwUmVxdWVzdFByb21pc2UuX2RldGFjaFdpbmRvd1VubG9hZCgpXG4gICAqL1xuXG4gIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5wcm90b3R5cGUuX2RldGFjaFdpbmRvd1VubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cuZGV0YWNoRXZlbnQpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZGV0YWNoRXZlbnQoJ29udW5sb2FkJywgdGhpcy5fdW5sb2FkSGFuZGxlcik7XG4gICAgfVxuICB9O1xuXG5cbiAgLypcbiAgICogWE1MSHR0cFJlcXVlc3RQcm9taXNlLl9nZXRIZWFkZXJzKCkgLT4gT2JqZWN0XG4gICAqL1xuXG4gIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5wcm90b3R5cGUuX2dldEhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUGFyc2VIZWFkZXJzKHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIH07XG5cblxuICAvKlxuICAgKiBYTUxIdHRwUmVxdWVzdFByb21pc2UuX2dldFJlc3BvbnNlVGV4dCgpIC0+IE1peGVkXG4gICAqXG4gICAqIFBhcnNlcyByZXNwb25zZSB0ZXh0IEpTT04gaWYgcHJlc2VudC5cbiAgICovXG5cbiAgWE1MSHR0cFJlcXVlc3RQcm9taXNlLnByb3RvdHlwZS5fZ2V0UmVzcG9uc2VUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlVGV4dDtcbiAgICByZXNwb25zZVRleHQgPSB0eXBlb2YgdGhpcy5feGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycgPyB0aGlzLl94aHIucmVzcG9uc2VUZXh0IDogJyc7XG4gICAgc3dpdGNoICgodGhpcy5feGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSB8fCAnJykuc3BsaXQoJzsnKVswXSkge1xuICAgICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6XG4gICAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQnOlxuICAgICAgICByZXNwb25zZVRleHQgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCArICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlVGV4dDtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZS5fZ2V0UmVzcG9uc2VVcmwoKSAtPiBTdHJpbmdcbiAgICpcbiAgICogQWN0dWFsIHJlc3BvbnNlIFVSTCBhZnRlciBmb2xsb3dpbmcgcmVkaXJlY3RzLlxuICAgKi9cblxuICBYTUxIdHRwUmVxdWVzdFByb21pc2UucHJvdG90eXBlLl9nZXRSZXNwb25zZVVybCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94aHIucmVzcG9uc2VVUkwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5yZXNwb25zZVVSTDtcbiAgICB9XG4gICAgaWYgKC9eWC1SZXF1ZXN0LVVSTDovbS50ZXN0KHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG5cbiAgLypcbiAgICogWE1MSHR0cFJlcXVlc3RQcm9taXNlLl9oYW5kbGVFcnJvcihyZWFzb24sIHJlamVjdCwgc3RhdHVzLCBzdGF0dXNUZXh0KVxuICAgKiAtIHJlYXNvbiAoU3RyaW5nKVxuICAgKiAtIHJlamVjdCAoRnVuY3Rpb24pXG4gICAqIC0gc3RhdHVzIChTdHJpbmcpXG4gICAqIC0gc3RhdHVzVGV4dCAoU3RyaW5nKVxuICAgKi9cblxuICBYTUxIdHRwUmVxdWVzdFByb21pc2UucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKHJlYXNvbiwgcmVqZWN0LCBzdGF0dXMsIHN0YXR1c1RleHQpIHtcbiAgICB0aGlzLl9kZXRhY2hXaW5kb3dVbmxvYWQoKTtcbiAgICByZXR1cm4gcmVqZWN0KHtcbiAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgc3RhdHVzOiBzdGF0dXMgfHwgdGhpcy5feGhyLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQgfHwgdGhpcy5feGhyLnN0YXR1c1RleHQsXG4gICAgICB4aHI6IHRoaXMuX3hoclxuICAgIH0pO1xuICB9O1xuXG5cbiAgLypcbiAgICogWE1MSHR0cFJlcXVlc3RQcm9taXNlLl9oYW5kbGVXaW5kb3dVbmxvYWQoKVxuICAgKi9cblxuICBYTUxIdHRwUmVxdWVzdFByb21pc2UucHJvdG90eXBlLl9oYW5kbGVXaW5kb3dVbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feGhyLmFib3J0KCk7XG4gIH07XG5cbiAgcmV0dXJuIFhNTEh0dHBSZXF1ZXN0UHJvbWlzZTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94aHItcHJvbWlzZS9saWIveGhyLXByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKHQpe2lmKHQpe3ZhciBlPXRoaXM7dChmdW5jdGlvbih0KXtlLnJlc29sdmUodCl9LGZ1bmN0aW9uKHQpe2UucmVqZWN0KHQpfSl9fWZ1bmN0aW9uIG4odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnkpdHJ5e3ZhciBuPXQueS5jYWxsKGksZSk7dC5wLnJlc29sdmUobil9Y2F0Y2gobyl7dC5wLnJlamVjdChvKX1lbHNlIHQucC5yZXNvbHZlKGUpfWZ1bmN0aW9uIG8odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm4pdHJ5e3ZhciBuPXQubi5jYWxsKGksZSk7dC5wLnJlc29sdmUobil9Y2F0Y2gobyl7dC5wLnJlamVjdChvKX1lbHNlIHQucC5yZWplY3QoZSl9dmFyIHIsaSxjPVwiZnVsZmlsbGVkXCIsdT1cInJlamVjdGVkXCIscz1cInVuZGVmaW5lZFwiLGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKDtuLmxlbmd0aC1vOyl7dHJ5e25bb10oKX1jYXRjaChlKXt0LmNvbnNvbGUmJnQuY29uc29sZS5lcnJvcihlKX1uW28rK109aSxvPT1yJiYobi5zcGxpY2UoMCxyKSxvPTApfX12YXIgbj1bXSxvPTAscj0xMDI0LGM9ZnVuY3Rpb24oKXtpZih0eXBlb2YgTXV0YXRpb25PYnNlcnZlciE9PXMpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbj1uZXcgTXV0YXRpb25PYnNlcnZlcihlKTtyZXR1cm4gbi5vYnNlcnZlKHQse2F0dHJpYnV0ZXM6ITB9KSxmdW5jdGlvbigpe3Quc2V0QXR0cmlidXRlKFwiYVwiLDApfX1yZXR1cm4gdHlwZW9mIHNldEltbWVkaWF0ZSE9PXM/ZnVuY3Rpb24oKXtzZXRJbW1lZGlhdGUoZSl9OmZ1bmN0aW9uKCl7c2V0VGltZW91dChlLDApfX0oKTtyZXR1cm4gZnVuY3Rpb24odCl7bi5wdXNoKHQpLG4ubGVuZ3RoLW89PTEmJmMoKX19KCk7ZS5wcm90b3R5cGU9e3Jlc29sdmU6ZnVuY3Rpb24odCl7aWYodGhpcy5zdGF0ZT09PXIpe2lmKHQ9PT10aGlzKXJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdCB0byByZXNvbHZlIHByb21pc2Ugd2l0aCBzZWxmXCIpKTt2YXIgZT10aGlzO2lmKHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0fHxcIm9iamVjdFwiPT10eXBlb2YgdCkpdHJ5e3ZhciBvPSEwLGk9dC50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGkpcmV0dXJuIHZvaWQgaS5jYWxsKHQsZnVuY3Rpb24odCl7byYmKG89ITEsZS5yZXNvbHZlKHQpKX0sZnVuY3Rpb24odCl7byYmKG89ITEsZS5yZWplY3QodCkpfSl9Y2F0Y2godSl7cmV0dXJuIHZvaWQobyYmdGhpcy5yZWplY3QodSkpfXRoaXMuc3RhdGU9Yyx0aGlzLnY9dCxlLmMmJmYoZnVuY3Rpb24oKXtmb3IodmFyIG89MCxyPWUuYy5sZW5ndGg7cj5vO28rKyluKGUuY1tvXSx0KX0pfX0scmVqZWN0OmZ1bmN0aW9uKG4pe2lmKHRoaXMuc3RhdGU9PT1yKXt0aGlzLnN0YXRlPXUsdGhpcy52PW47dmFyIGk9dGhpcy5jO2k/ZihmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9aS5sZW5ndGg7ZT50O3QrKylvKGlbdF0sbil9KTohZS5zdXBwcmVzc1VuY2F1Z2h0UmVqZWN0aW9uRXJyb3ImJnQuY29uc29sZSYmdC5jb25zb2xlLmxvZyhcIllvdSB1cHNldCBab3VzYW4uIFBsZWFzZSBjYXRjaCByZWplY3Rpb25zOiBcIixuLG4/bi5zdGFjazpudWxsKX19LHRoZW46ZnVuY3Rpb24odCxpKXt2YXIgdT1uZXcgZSxzPXt5OnQsbjppLHA6dX07aWYodGhpcy5zdGF0ZT09PXIpdGhpcy5jP3RoaXMuYy5wdXNoKHMpOnRoaXMuYz1bc107ZWxzZXt2YXIgbD10aGlzLnN0YXRlLGE9dGhpcy52O2YoZnVuY3Rpb24oKXtsPT09Yz9uKHMsYSk6byhzLGEpfSl9cmV0dXJuIHV9LFwiY2F0Y2hcIjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKG51bGwsdCl9LFwiZmluYWxseVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW4odCx0KX0sdGltZW91dDpmdW5jdGlvbih0LG4pe249bnx8XCJUaW1lb3V0XCI7dmFyIG89dGhpcztyZXR1cm4gbmV3IGUoZnVuY3Rpb24oZSxyKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cihFcnJvcihuKSl9LHQpLG8udGhlbihmdW5jdGlvbih0KXtlKHQpfSxmdW5jdGlvbih0KXtyKHQpfSl9KX19LGUucmVzb2x2ZT1mdW5jdGlvbih0KXt2YXIgbj1uZXcgZTtyZXR1cm4gbi5yZXNvbHZlKHQpLG59LGUucmVqZWN0PWZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBlO3JldHVybiBuLnJlamVjdCh0KSxufSxlLmFsbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4sYyl7biYmXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50aGVufHwobj1lLnJlc29sdmUobikpLG4udGhlbihmdW5jdGlvbihlKXtvW2NdPWUscisrLHI9PXQubGVuZ3RoJiZpLnJlc29sdmUobyl9LGZ1bmN0aW9uKHQpe2kucmVqZWN0KHQpfSl9Zm9yKHZhciBvPVtdLHI9MCxpPW5ldyBlLGM9MDtjPHQubGVuZ3RoO2MrKyluKHRbY10sYyk7cmV0dXJuIHQubGVuZ3RofHxpLnJlc29sdmUobyksaX0sdHlwZW9mIG1vZHVsZSE9cyYmbW9kdWxlLmV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz1lKSx0LmRlZmluZSYmdC5kZWZpbmUuYW1kJiZ0LmRlZmluZShbXSxmdW5jdGlvbigpe3JldHVybiBlfSksdC5ab3VzYW49ZSxlLnNvb249Zn0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dGhpcyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pvdXNhbi96b3VzYW4tbWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIkdhaWFcIlxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==