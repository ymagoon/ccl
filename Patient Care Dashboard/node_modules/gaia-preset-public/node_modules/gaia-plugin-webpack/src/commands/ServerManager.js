
/**
 * Converts a date into the format suitable to be in the console.
 * @param {Date} date - the date
 * @returns {String} the formatted string
 */
const formatDate = (date) =>
      [date.getFullYear()
       , "-"
       , date.getMonth() + 1
       , "-"
       , date.getDate()
       , " "
       , date.getHours()
       , ":"
       , date.getMinutes()
       , ":"
       , date.getSeconds()
      ].join("");

/**
 * Logs a message using the provided logger and given a timestamp
 * @param {*} logger - object with a log function
 * @param {String} message - message to be logged
 * @param {Date} date - timestamp
 * @returns {undefined}
 */
const log = (logger, message, date) => {
    logger.log(`[${formatDate(date || new Date())}] ${message}`);
};

/**
 * Abstraction layer that allows a server (or any other stateful artifact)
 * to be started and stopped and at the same time keep track of its state
 * and record it on a log.
 */
class ServerManager {

    constructor(startHandler, stopHandler, logger) {
        this._statusLog = [];
        this._startHandler = startHandler;
        this._stopHandler = stopHandler;
        this._serverInstance = null;
        this._logger = logger || console;
    }

    /**
     * Starts the server. The args provided will be piped to the start
     * handler unchanged.
     * @param {*} startHandlerArgs arguments to the startHandler
     * @returns {Promise} promise representing the server start
     */
    start(startHandlerArgs) {
        return this
            ._startHandler(startHandlerArgs, this)
            .then(([serverInstance, message]) => {
                this._serverInstance = serverInstance;
                return Promise.resolve(
                    this.changeStatus({
                        isRunning: true,
                        message: message || "Server running.",
                        error: null
                    })
                );
            })
            .catch((error) =>
                   Promise.reject(
                       this.changeStatus({
                           isRunning: false,
                           message: "Error starting server",
                           error: error
                       })
                   )
            );
    }

    /**
     * Stops the server. The args provided will be piped to the stop
     * handler unchanged.
     * @param {*} stopHandlerArgs arguments to stopHandler
     * @returns {Promise} promise representing the server stop
     */
    stop(stopHandlerArgs) {
        if (!this._serverInstance) {
            log(this._logger, "Server not started. Nothing to stop.");
            return Promise.resolve();
        }
        return this
            ._stopHandler(stopHandlerArgs, this._serverInstance, this)
            .then(() => {
                this._serverInstance = null;
                return Promise.resolve(
                    this.changeStatus({
                        isRunning: false,
                        message: "Server stopped",
                        error: null
                    })
                );
            });
    }

    /**
     * Adds a new entry into the status log with the provided status.
     * @param {*} newStatus JSON representing the new status.
     * @returns {*} the status JSON
     */
    changeStatus(newStatus) {
        const status = Object.assign(
            { timestamp : new Date() },
            newStatus
        );
        this._statusLog.push(status);
        if (status.error) {
            log(this._logger, `ERROR: ${status.error}`, status.timestamp);
        } else {
            log(this._logger, status.message, status.timestamp);
        }
        return status;
    }

    /**
     * Returns the status log
     * @returns {*} the status log
     */
    getStatusLog() {
        return this._statusLog;
    }

    /**
     * The last status that was logged
     * @returns {*} a single status log entry
     */
    getStatus() {
        return this._statusLog[this.statusLog.length - 1];
    }
}

module.exports = ServerManager;
