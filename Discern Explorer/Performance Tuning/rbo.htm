<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<title>Using the Rule-Based Optimizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="en-US">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="robots" content="all" scheme="http://www.robotstxt.org/">
<meta name="doctitle" content="Oracle9i Database Performance Tuning Guide and Reference Release 2 (9.2)">
<meta name="partno" content="A96533-02">
<link href="../../index.htm" rel="Start" title="Home" type="text/html">
<link href="../../dcommon/html/cpyr.htm" rel="Copyright" title="Copyright" type="text/html">
<link href="toc.htm" rel="Contents" title="Contents" type="text/html">
<link href="index.htm" rel="Index" title="Index" type="text/html">
<link href="outlines.htm" rel="Prev" title="Previous" type="text/html">
<link href="part2.htm" rel="Next" title="Next" type="text/html"><!-- link href="../../dcommon/css/doccd.css" rel="Stylesheet"
 title="Default" type="text/css" -->
<link href="../a96533.pdf" title="PDF version" type="application/pdf">
</head>
<body>
<div class="header">
<p><a name="top" href="#BEGIN">Skip Headers</a></p>

<table summary="layout table" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td align="left" valign="top"><font color="#330099" face="Helvetica, Arial, sans-serif"><strong>Oracle9<i>i</i> Database Performance Tuning Guide and Reference<br>
Release 2 (9.2)</strong><br>
Part Number A96533-02</font></td>
<td valign="bottom" align="right">
<table summary="layout table" cellspacing="0" cellpadding="0" width="270">
<tr>
<td align="center" valign="top"><a href="../../index.htm"><img src="../../dcommon/gifs/prodicon.gif" alt="Go to Documentation Home" border="0"><br>
<font size="-2">Home</font></a></td>
<td align="center" valign="top"><a href="../../nav/docindex.htm"><img src="../../dcommon/gifs/bookicon.gif" alt="Go to Book List" border="0"><br>
<font size="-2">Book List</font></a></td>
<td align="center" valign="top"><a href="toc.htm"><img src="../../dcommon/gifs/conticon.gif" alt="Go to Table of Contents" border="0"><br>
<font size="-2">Contents</font></a></td>
<td align="center" valign="top"><a href="index.htm"><img src="../../dcommon/gifs/indxicon.gif" alt="Go to Index" border="0"><br>
<font size="-2">Index</font></a></td>
<td align="center" valign="top"><a href="../../mix.920/a96625/toc.htm"><img src="../../dcommon/gifs/mix.gif" alt="Go to Master Index" border="0"><br>
<font size="-2">Master&nbsp;Index</font></a></td>
<td align="center" valign="top"><a href="../../dcommon/html/feedback.htm"><img src="../../dcommon/gifs/feedback.gif" alt="Go to Feedback page" border="0"><br>
<font size="-2">Feedback</font></a></td>
</tr>
</table>
</td>
</tr>
</table>

<hr>
<table summary="layout table" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td align="left" valign="top">
<table summary="layout table" cellspacing="0" cellpadding="0" align="left" width="90">
<tr>
<td align="center" valign="top"><a href="outlines.htm"><img src="../../dcommon/gifs/larrow.gif" alt="Go to previous page" border="0"></a></td>
<td align="center" valign="top"><a href="part2.htm"><img src="../../dcommon/gifs/rarrow.gif" alt="Go to next page" border="0"></a></td>
</tr>
</table>
</td>
<td align="right" valign="top"><a href="../a96533.pdf"><font size="-2">View PDF</font></a></td>
</tr>
</table>

<a name="BEGIN"></a></div>

<div class="IND"><!-- End Header -->
<a name="721"></a> <!--TOC=Title-"721"-->
<h1 class="Title"><font face="Arial, Helvetica, sans-serif" color="#330099">8<br>
 <a name="PFGRF008">Using the Rule-Based Optimizer</a></font></h1>

<!--/TOC=Title-->
<a name="28908"></a> 

<p class="BP">This chapter discusses Oracle's rule-based optimizer (RBO). In general, always use the cost-based approach. The rule-based approach is available for backward compatibility.</p>

<a name="43761"></a> 

<div align="center">
<table class="Note" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="Note">
<td class="Note">
<hr>
<a name="43787"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="43788"></a> 

<p class="NB">Oracle Corporation strongly advises the use of cost-based optimization. Rule-based optimization will be deprecated in a future release.</p>

<hr>
</td>
</tr>
</table>
</div>

<a name="41321"></a> 

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="41324"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH"><strong class="Bold">See Also</strong>:</strong></font> <a name="41325"></a> 

<p class="NB"><a href="optimops.htm#721">Chapter&nbsp;1, "Introduction to the Optimizer"</a></p>
</td>
</tr>
</table>
</div>

<a name="29099"></a> 

<p class="BP">This chapter contains the following sections:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="41298"></a><a href="rbo.htm#38864">Overview of the Rule-Based Optimizer (RBO)</a></li>

<li class="LB1" type="disc"><a name="41302"></a><a href="rbo.htm#38893">Understanding Access Paths for the RBO</a></li>

<li class="LB1" type="disc"><a name="42310"></a><a href="rbo.htm#41432">Transforming and Optimizing Statements with the RBO</a></li>
</ul>

<a name="38864"></a> <!--TOC=h1-"38864"-->
<h2 class="H1"><font face="Arial, Helvetica, sans-serif" color="#330099">Overview of the Rule-Based Optimizer (RBO)</font></h2>

<!--/TOC=h1-->
<a name="38865"></a> 

<p class="BP">Although Oracle supports the rule-based optimizer, you should design new applications to use the cost-based optimizer (CBO). You should also use the CBO for data warehousing applications, because the CBO supports enhanced features for DSS. Many new performance features, such as partitioned tables, improved star query processing, and materialized views, are only available with the CBO.</p>

<a name="38873"></a> 

<div align="center">
<table class="Note" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="Note">
<td class="Note">
<hr>
<a name="38868"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="38871"></a> 

<p class="NB">If you have developed OLTP applications using Oracle version 6, and if you have tuned the SQL statements carefully based on the rules of the optimizer, then you might want to continue using the RBO when you upgrade these applications to a new Oracle release. <a name="38872"></a></p>

<p class="NB">If you are using applications provided by third-party vendors, then check with the vendors to determine which type of optimizer is best suited to that application.</p>

<hr>
</td>
</tr>
</table>
</div>

<a name="38874"></a> 

<p class="BP">If <code>OPTIMIZER_MODE</code>=<code>CHOOSE</code>, if statistics do not exist, and if you do not add hints to SQL statements, then SQL statements use the RBO. You can use the RBO to access both relational data and object types. If <code>OPTIMIZER_MODE</code>=<code>FIRST_ROWS</code>, <code>FIRST_ROWS_</code><em class="Italic">n</em>, or <code>ALL_ROWS</code> and no statistics exist, then the CBO uses default statistics. Migrate existing applications to use the cost-based approach.</p>

<a name="38875"></a> 

<p class="BP">You can enable the CBO on a trial basis simply by collecting statistics. You can then return to the RBO by deleting the statistics or by setting either the value of the <code>OPTIMIZER_MODE</code> initialization parameter or the <code>OPTIMIZER_MODE</code> clause of the <code>ALTER</code> <code>SESSION</code> statement to <code>RULE</code>. You can also use this value if you want to collect and examine statistics for data without using the cost-based approach.</p>

<a name="38891"></a> 

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="38880"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH"><strong class="Bold">See Also</strong>:</strong></font> <a name="38881"></a> 

<p class="NB"><a href="stats.htm#13547">Chapter&nbsp;3, "Gathering Optimizer Statistics"</a> for an explanation of how to gather statistics</p>
</td>
</tr>
</table>
</div>

<a name="38893"></a> <!--TOC=h1-"38893"-->
<h2 class="H1"><font face="Arial, Helvetica, sans-serif" color="#330099">Understanding Access Paths for the RBO</font></h2>

<!--/TOC=h1-->
<a name="38896"></a> 

<p class="BP">Using the RBO, the optimizer chooses an execution plan based on the access paths available and the ranks of these access paths. Oracle's ranking of the access paths is heuristic. If there is more than one way to execute a SQL statement, then the RBO always uses the operation with the lower rank. Usually, operations of lower rank execute faster than those associated with constructs of higher rank.</p>

<a name="38897"></a> 

<p class="BP">The list shows access paths and their ranking:</p>

<a name="38901"></a> 

<p class="BP"><a href="rbo.htm#38960">RBO Path 1: Single Row by Rowid</a></p>

<a name="38905"></a> 

<p class="BP"><a href="rbo.htm#38979">RBO Path 2: Single Row by Cluster Join</a></p>

<a name="38909"></a> 

<p class="BP"><a href="rbo.htm#39019">RBO Path 3: Single Row by Hash Cluster Key with Unique or Primary Key</a></p>

<a name="38913"></a> 

<p class="BP"><a href="rbo.htm#39041">RBO Path 4: Single Row by Unique or Primary Key</a></p>

<a name="38917"></a> 

<p class="BP"><a href="rbo.htm#39063">RBO Path 5: Clustered Join</a></p>

<a name="38921"></a> 

<p class="BP"><a href="rbo.htm#39095">RBO Path 6: Hash Cluster Key</a></p>

<a name="38925"></a> 

<p class="BP"><a href="rbo.htm#39114">RBO Path 7: Indexed Cluster Key</a></p>

<a name="38929"></a> 

<p class="BP"><a href="rbo.htm#39135">RBO Path 8: Composite Index</a></p>

<a name="38933"></a> 

<p class="BP"><a href="rbo.htm#39156">RBO Path 9: Single-Column Indexes</a></p>

<a name="38937"></a> 

<p class="BP"><a href="rbo.htm#39197">RBO Path 10: Bounded Range Search on Indexed Columns</a></p>

<a name="38941"></a> 

<p class="BP"><a href="rbo.htm#39232">RBO Path 11: Unbounded Range Search on Indexed Columns</a></p>

<a name="38945"></a> 

<p class="BP"><a href="rbo.htm#39269">RBO Path 12: Sort Merge Join</a></p>

<a name="38949"></a> 

<p class="BP"><a href="rbo.htm#39301">RBO Path 13: MAX or MIN of Indexed Column</a></p>

<a name="38953"></a> 

<p class="BP"><a href="rbo.htm#39321">RBO Path 14: ORDER BY on Indexed Column</a></p>

<a name="38957"></a> 

<p class="BP"><a href="rbo.htm#39346">RBO Path 15: Full Table Scan</a></p>

<a name="43890"></a> <!--TOC=h2-"43890"-->
<h3 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Details of the RBO Access Paths</font></h3>

<!--/TOC=h2-->
<a name="43886"></a> 

<p class="BP">Each of the following sections describes an access path, discusses when it is available, and shows the output generated for it by the <code>EXPLAIN</code> <code>PLAN</code> statement.</p>

<a name="38960"></a> <!--TOC=h3-"38960"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 1: Single Row by Rowid</font></h4>

<!--/TOC=h3-->
<a name="38963"></a> 

<p class="BP">This access path is available only if the statement's <code>WHERE</code> clause identifies the selected rows by rowid or with the <code>CURRENT</code> <code>OF</code> <code>CURSOR</code> embedded SQL syntax supported by the Oracle precompilers. To execute the statement, Oracle accesses the table by rowid.</p>

<a name="38964"></a> 

<p class="BP">For example:</p>

<pre class="CE">
<a name="38966"></a>SELECT * FROM emp WHERE ROWID = 'AAAA7bAA5AAAA1UAAA'; 
<a name="38967"></a>
</pre>

<a name="38969"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="38970"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="38971"></a>----------------------------------------------------- 
<a name="38972"></a>SELECT STATEMENT 
<a name="38973"></a>    TABLE ACCESS          BY ROWID       EMP 
</pre>

<a name="38979"></a> <!--TOC=h3-"38979"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 2: Single Row by Cluster Join</font></h4>

<!--/TOC=h3-->
<a name="38980"></a> 

<p class="BP">This access path is available for statements that join tables stored in the same cluster if both of the following conditions are true:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="38981"></a>The statement's <code>WHERE</code> clause contains conditions that equate each column of the cluster key in one table with the corresponding column in the other table.</li>

<li class="LB1" type="disc"><a name="38982"></a>The statement's <code>WHERE</code> clause also contains a condition that guarantees the join returns only one row. Such a condition is likely to be an equality condition on the column(s) of a unique or primary key.</li>
</ul>

<a name="38983"></a> 

<p class="BP">These conditions must be combined with <code>AND</code> operators. To execute the statement, Oracle performs a nested loops operation.</p>

<a name="38994"></a> 

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="38986"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="38987"></a> 

<p class="NB"><a href="optimops.htm#77042">"Nested Loop Outer Joins"</a><a href="optimops.htm#77042"></a></p>
</td>
</tr>
</table>
</div>

<a name="38995"></a> 

<p class="BP">For example, in the following statement, the <code>emp</code> and <code>dept</code> tables are clustered on the <code>deptno</code> column, and the <code>empno</code> column is the primary key of the <code>emp</code> table:</p>

<pre class="CE">
<a name="38997"></a>SELECT * 
<a name="38998"></a>  FROM emp, dept 
<a name="38999"></a>  WHERE emp.deptno = dept.deptno 
<a name="39000"></a>    AND emp.empno = 7900; 
<a name="39001"></a>
</pre>

<a name="39003"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39004"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39005"></a>----------------------------------------------------- 
<a name="39006"></a>SELECT STATEMENT 
<a name="39007"></a>    NESTED LOOPS 
<a name="39008"></a>       TABLE ACCESS       BY ROWID       EMP 
<a name="39009"></a>       INDEX              UNIQUE SCAN    PK_EMP    
<a name="39010"></a>       TABLE ACCESS       CLUSTER        DEPT 
<a name="39011"></a>
</pre>

<a name="39012"></a> 

<p class="BP"><code>pk_emp</code> is the name of an index that enforces the primary key.</p>

<a name="39019"></a> <!--TOC=h3-"39019"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 3: Single Row by Hash Cluster Key with Unique or Primary Key</font></h4>

<!--/TOC=h3-->
<a name="39020"></a> 

<p class="BP">This access path is available if both of the following conditions are true:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39021"></a>The statement's <code>WHERE</code> clause uses all columns of a hash cluster key in equality conditions. For composite cluster keys, the equality conditions must be combined with <code>AND</code> operators.</li>

<li class="LB1" type="disc"><a name="39022"></a>The statement is guaranteed to return only one row, because the columns that make up the hash cluster key also make up a unique or primary key.</li>
</ul>

<a name="39023"></a> 

<p class="BP">To execute the statement, Oracle applies the cluster's hash function to the hash cluster key value specified in the statement to obtain a hash value. Oracle then uses the hash value to perform a hash scan on the table.</p>

<a name="39024"></a> 

<p class="BP">For example:</p>

<a name="39025"></a> 

<p class="BP">In the following statement, the <code>orders</code> and <code>line_items</code> tables are stored in a hash cluster, and the <code>orderno</code> column is both the cluster key and the primary key of the <code>orders</code> table:</p>

<pre class="CE">
<a name="39026"></a>SELECT * 
<a name="39027"></a>    FROM orders 
<a name="39028"></a>    WHERE orderno = 65118968; 
<a name="39029"></a>
</pre>

<a name="39031"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39032"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39033"></a>----------------------------------------------------- 
<a name="39034"></a>SELECT STATEMENT 
<a name="39035"></a>    TABLE ACCESS          HASH           ORDERS 
</pre>

<a name="39041"></a> <!--TOC=h3-"39041"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 4: Single Row by Unique or Primary Key</font></h4>

<!--/TOC=h3-->
<a name="39042"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause uses all columns of a unique or primary key in equality conditions. For composite keys, the equality conditions must be combined with <code>AND</code> operators. To execute the statement, Oracle performs a unique scan on the index on the unique or primary key to retrieve a single rowid, and then accesses the table by that rowid.</p>

<a name="39043"></a> 

<p class="BP">For example:</p>

<a name="39044"></a> 

<p class="BP">In the following statement, the <code>empno</code> column is the primary key of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39045"></a>SELECT * 
<a name="39046"></a>    FROM emp 
<a name="39047"></a>    WHERE empno = 7900; 
<a name="39048"></a>
</pre>

<a name="39050"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39051"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39052"></a>----------------------------------------------------- 
<a name="39053"></a>SELECT STATEMENT 
<a name="39054"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39055"></a>    INDEX                 UNIQUE SCAN    PK_EMP 
<a name="39056"></a>
</pre>

<a name="39057"></a> 

<p class="BP"><code>pk_emp</code> is the name of the index that enforces the primary key.</p>

<a name="39063"></a> <!--TOC=h3-"39063"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 5: Clustered Join</font></h4>

<!--/TOC=h3-->
<a name="39064"></a> 

<p class="BP">This access path is available for statements that join tables stored in the same cluster if the statement's <code>WHERE</code> clause contains conditions that equate each column of the cluster key in one table with the corresponding column in the other table. For a composite cluster key, the equality conditions must be combined with <code>AND</code> operators. To execute the statement, Oracle performs a nested loops operation.</p>

<a name="39075"></a> 

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="39067"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="39068"></a> 

<p class="NB"><a href="optimops.htm#77042">"Nested Loop Outer Joins"</a><a href="optimops.htm#77042"></a></p>
</td>
</tr>
</table>
</div>

<a name="39076"></a> 

<p class="BP">For example:</p>

<a name="39077"></a> 

<p class="BP">In the following statement, the <code>emp</code> and <code>dept</code> tables are clustered on the <code>deptno</code> column:</p>

<pre class="CE">
<a name="39078"></a>SELECT * 
<a name="39079"></a>    FROM emp, dept 
<a name="39080"></a>    WHERE emp.deptno = dept.deptno; 
<a name="39081"></a>
</pre>

<a name="39083"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39084"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39085"></a>----------------------------------------------------- 
<a name="39086"></a>SELECT STATEMENT 
<a name="39087"></a>  NESTED LOOPS 
<a name="39088"></a>    TABLE ACCESS          FULL           DEPT 
<a name="39089"></a>    TABLE ACCESS          CLUSTER        EMP 
</pre>

<a name="39095"></a> <!--TOC=h3-"39095"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 6: Hash Cluster Key</font></h4>

<!--/TOC=h3-->
<a name="39096"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause uses all the columns of a hash cluster key in equality conditions. For a composite cluster key, the equality conditions must be combined with <code>AND</code> operators. To execute the statement, Oracle applies the cluster's hash function to the hash cluster key value specified in the statement to obtain a hash value. Oracle then uses this hash value to perform a hash scan on the table.</p>

<a name="39097"></a> 

<p class="BP">For example: In the following statement, the <code>orders</code> and <code>line_items</code> tables are stored in a hash cluster, and the <code>orderno</code> column is the cluster key:</p>

<pre class="CE">
<a name="39099"></a>SELECT * 
<a name="39100"></a>    FROM line_items 
<a name="39101"></a>    WHERE orderno = 65118968; 
<a name="39102"></a>
</pre>

<a name="39104"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39105"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39106"></a>----------------------------------------------------- 
<a name="39107"></a>SELECT STATEMENT 
<a name="39108"></a>    TABLE ACCESS          HASH           LINE_ITEMS 
</pre>

<a name="39114"></a> <!--TOC=h3-"39114"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 7: Indexed Cluster Key</font></h4>

<!--/TOC=h3-->
<a name="39115"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause uses all the columns of an indexed cluster key in equality conditions. For a composite cluster key, the equality conditions must be combined with <code>AND</code> operators.</p>

<a name="39116"></a> 

<p class="BP">To execute the statement, Oracle performs a unique scan on the cluster index to retrieve the rowid of one row with the specified cluster key value. Oracle then uses that rowid to access the table with a cluster scan. Because all rows with the same cluster key value are stored together, the cluster scan requires only a single rowid to find them all.</p>

<a name="39117"></a> 

<p class="BP">For example:</p>

<a name="39118"></a> 

<p class="BP">In the following statement, the <code>emp</code> table is stored in an indexed cluster, and the <code>deptno</code> column is the cluster key:</p>

<pre class="CE">
<a name="39119"></a>SELECT *  FROM emp 
<a name="39120"></a>  WHERE deptno = 10; 
<a name="39121"></a>
</pre>

<a name="39123"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39124"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39125"></a>----------------------------------------------------- 
<a name="39126"></a>SELECT STATEMENT 
<a name="39127"></a>  TABLE ACCESS            CLUSTER        EMP 
<a name="39128"></a>    INDEX                 UNIQUE SCAN    PERS_INDEX 
<a name="39129"></a>
</pre>

<a name="39130"></a> 

<p class="BP"><code>pers_index</code> is the name of the cluster index.</p>

<a name="39135"></a> <!--TOC=h3-"39135"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 8: Composite Index</font></h4>

<!--/TOC=h3-->
<a name="39136"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause uses all columns of a composite index in equality conditions combined with <code>AND</code> operators. To execute the statement, Oracle performs a range scan on the index to retrieve rowids of the selected rows, and then accesses the table by those rowids.</p>

<a name="39137"></a> 

<p class="BP">For example:</p>

<a name="39138"></a> 

<p class="BP">In the following statement, there is a composite index on the <code>job</code> and <code>deptno</code> columns:</p>

<pre class="CE">
<a name="39139"></a>SELECT * 
<a name="39140"></a>    FROM emp 
<a name="39141"></a>    WHERE job = 'CLERK' 
<a name="39142"></a>      AND deptno = 30; 
<a name="39143"></a>
</pre>

<a name="39145"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39146"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39147"></a>----------------------------------------------------- 
<a name="39148"></a>SELECT STATEMENT 
<a name="39149"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39150"></a>    INDEX                 RANGE SCAN     JOB_DEPTNO_INDEX 
<a name="39151"></a>
</pre>

<a name="39152"></a> 

<p class="BP"><code>job_deptno_index</code> is the name of the composite index on the <code>job</code> and <code>deptno</code> columns.</p>

<a name="39156"></a> <!--TOC=h3-"39156"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 9: Single-Column Indexes</font></h4>

<!--/TOC=h3-->
<a name="39157"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause uses the columns of one or more single-column indexes in equality conditions. For multiple single-column indexes, the conditions must be combined with <code>AND</code> operators.</p>

<a name="39158"></a> 

<p class="BP">If the <code>WHERE</code> clause uses the column of only one index, then Oracle executes the statement by performing a range scan on the index to retrieve the rowids of the selected rows, and then accesses the table by these rowids.</p>

<a name="39159"></a> 

<p class="BP">For example:</p>

<a name="39160"></a> 

<p class="BP">In the following statement, there is an index on the <code>job</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39161"></a>SELECT * 
<a name="39162"></a>    FROM emp 
<a name="39163"></a>    WHERE job = 'ANALYST'; 
<a name="39164"></a>
</pre>

<a name="39166"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39167"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39168"></a>----------------------------------------------------- 
<a name="39169"></a>SELECT STATEMENT 
<a name="39170"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39171"></a>    INDEX                 RANGE SCAN     JOB_INDEX 
<a name="39172"></a>
</pre>

<a name="39173"></a> 

<p class="BP"><code>job_index</code> is the index on <code>emp</code>.<code>job</code>.</p>

<a name="39174"></a> 

<p class="BP">If the <code>WHERE</code> clauses uses columns of many single-column indexes, then Oracle executes the statement by performing a range scan on each index to retrieve the rowids of the rows that satisfy each condition. Oracle then merges the sets of rowids to obtain a set of rowids of rows that satisfy all conditions. Oracle then accesses the table using these rowids.</p>

<a name="39175"></a> 

<p class="BP">Oracle can merge up to five indexes. If the <code>WHERE</code> clause uses columns of more than five single-column indexes, then Oracle merges five of them, accesses the table by rowid, and then tests the resulting rows to determine whether they satisfy the remaining conditions before returning them.</p>

<a name="39177"></a> 

<p class="BP">In the following statement, there are indexes on both the <code>job</code> and <code>deptno</code> columns of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39178"></a>SELECT * 
<a name="39179"></a>    FROM emp 
<a name="39180"></a>    WHERE job = 'ANALYST' 
<a name="39181"></a>      AND deptno = 20; 
<a name="39182"></a>
</pre>

<a name="39184"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39185"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39186"></a>----------------------------------------------------- 
<a name="39187"></a>SELECT STATEMENT 
<a name="39188"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39189"></a>    AND-EQUAL 
<a name="39190"></a>      INDEX               RANGE SCAN     JOB_INDEX 
<a name="39191"></a>      INDEX               RANGE SCAN     DEPTNO_INDEX 
<a name="39192"></a>
</pre>

<a name="39193"></a> 

<p class="BP">The <code>AND</code>-<code>EQUAL</code> operation merges the rowids obtained by the scans of the <code>job_index</code> and the <code>deptno_index</code>, resulting in a set of rowids of rows that satisfy the query.</p>

<a name="39197"></a> <!--TOC=h3-"39197"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 10: Bounded Range Search on Indexed Columns</font></h4>

<!--/TOC=h3-->
<a name="39198"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause contains a condition that uses either the column of a single-column index or one or more columns that make up a leading portion of a composite index:</p>

<pre class="CE">
<a name="39199"></a>column = <em><code>expr</code></em> 
<a name="39200"></a>
<a name="39201"></a>column &gt;[=] <em><code>expr</code></em> AND column &lt;[=] <em><code>expr</code></em> 
<a name="39202"></a>
<a name="39203"></a>column BETWEEN <em><code>expr</code></em> AND <em><code>expr</code></em> 
<a name="39204"></a>
<a name="39205"></a>column LIKE 'c%' 
<a name="39206"></a>
</pre>

<a name="39207"></a> 

<p class="BP">Each of these conditions specifies a bounded range of indexed values that are accessed by the statement. The range is said to be bounded because the conditions specify both its least value and its greatest value. To execute such a statement, Oracle performs a range scan on the index, and then accesses the table by rowid.</p>

<a name="39208"></a> 

<p class="BP">This access path is not available if the expression <em><code>expr</code></em> references the indexed column.&nbsp;</p>

<a name="39209"></a> 

<p class="BP">For example:</p>

<a name="39210"></a> 

<p class="BP">In the following statement, there is an index on the <code>sal</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39211"></a>SELECT * 
<a name="39212"></a>    FROM emp 
<a name="39213"></a>    WHERE sal BETWEEN 2000 AND 3000; 
<a name="39214"></a>
</pre>

<a name="39216"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39217"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39218"></a>----------------------------------------------------- 
<a name="39219"></a>SELECT STATEMENT 
<a name="39220"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39221"></a>    INDEX                 RANGE SCAN     SAL_INDEX 
<a name="39222"></a>
</pre>

<a name="39223"></a> 

<p class="BP"><code>sal_index</code> is the name of the index on <code>emp</code>.<code>sal</code>.</p>

<a name="39225"></a> 

<p class="BP">In the following statement, there is an index on the <code>ename</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39226"></a>SELECT * 
<a name="39227"></a>    FROM emp 
<a name="39228"></a>    WHERE ename LIKE 'S%'; 
</pre>

<a name="39232"></a> <!--TOC=h3-"39232"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 11: Unbounded Range Search on Indexed Columns</font></h4>

<!--/TOC=h3-->
<a name="39233"></a> 

<p class="BP">This access path is available if the statement's <code>WHERE</code> clause contains one of the following conditions that use either the column of a single-column index or one or more columns of a leading portion of a composite index:</p>

<pre class="CE">
<a name="39234"></a>WHERE column &gt;[=] <em><code>expr</code></em> 
<a name="39235"></a>
<a name="39236"></a>WHERE column &lt;[=] <em><code>expr</code></em> 
<a name="39237"></a>
</pre>

<a name="39238"></a> 

<p class="BP">Each of these conditions specifies an unbounded range of index values accessed by the statement. The range is said to be unbounded, because the condition specifies either its least value or its greatest value, but not both. To execute such a statement, Oracle performs a range scan on the index, and then accesses the table by rowid.</p>

<a name="39239"></a> 

<p class="BP">For example:</p>

<a name="39240"></a> 

<p class="BP">In the following statement, there is an index on the <code>sal</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39241"></a>SELECT * 
<a name="39242"></a>    FROM emp 
<a name="39243"></a>    WHERE sal &gt; 2000; 
<a name="39244"></a>
</pre>

<a name="39246"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39247"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39248"></a>----------------------------------------------------- 
<a name="39249"></a>SELECT STATEMENT 
<a name="39250"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39251"></a>    INDEX                 RANGE SCAN     SAL_INDEX 
<a name="39253"></a>
</pre>

<a name="41016"></a> 

<p class="BP">In the following statement, there is a composite index on the <code>order</code> and <code>line</code> columns of the <code>line_items</code> table:</p>

<pre class="CE">
<a name="39254"></a>SELECT * 
<a name="39255"></a>    FROM line_items 
<a name="39256"></a>    WHERE order &gt; 65118968; 
<a name="39257"></a>
</pre>

<a name="39258"></a> 

<p class="BP">The access path is available, because the <code>WHERE</code> clause uses the <code>order</code> column, a leading portion of the index.</p>

<a name="39260"></a> 

<p class="BP">This access path is <em class="Italic">not</em> available in the following statement, in which there is an index on the <code>order</code> and <code>line</code> columns:</p>

<pre class="CE">
<a name="39261"></a>SELECT * 
<a name="39262"></a>    FROM line_items 
<a name="39263"></a>    WHERE line &lt; 4; 
<a name="39264"></a>
</pre>

<a name="39265"></a> 

<p class="BP">The access path is not available because the <code>WHERE</code> clause only uses the <code>line</code> column, which is not a leading portion of the index.</p>

<a name="39269"></a> <!--TOC=h3-"39269"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 12: Sort Merge Join</font></h4>

<!--/TOC=h3-->
<a name="39270"></a> 

<p class="BP">This access path is available for statements that join tables that are not stored together in a cluster if the statement's <code>WHERE</code> clause uses columns from each table in equality conditions. To execute such a statement, Oracle uses a sort-merge operation. Oracle can also use a nested loops operation to execute a join statement.</p>

<a name="39281"></a> 

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="39273"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="39276"></a> 

<p class="NB"><a href="optimops.htm#39473">"Understanding Joins"</a><a href="optimops.htm#39473"></a> for information on these operations</p>
</td>
</tr>
</table>
</div>

<a name="39282"></a> 

<p class="BP">For example:</p>

<a name="39283"></a> 

<p class="BP">In the following statement, the <code>emp</code> and <code>dept</code> tables are not stored in the same cluster:</p>

<pre class="CE">
<a name="39284"></a>SELECT * 
<a name="39285"></a>    FROM emp, dept 
<a name="39286"></a>    WHERE emp.deptno = dept.deptno; 
<a name="39287"></a>
</pre>

<a name="39289"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39290"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39291"></a>----------------------------------------------------- 
<a name="39292"></a>SELECT STATEMENT 
<a name="39293"></a>  MERGE JOIN 
<a name="39294"></a>    SORT                  JOIN 
<a name="39295"></a>      TABLE ACCESS        FULL           EMP 
<a name="39296"></a>    SORT                  JOIN 
<a name="39297"></a>  TABLE ACCESS            FULL           DEPT 
</pre>

<a name="39301"></a> <!--TOC=h3-"39301"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 13: MAX or MIN of Indexed Column</font></h4>

<!--/TOC=h3-->
<a name="39302"></a> 

<p class="BP">This access path is available for a <code>SELECT</code> statement, and all of the following conditions are true:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39303"></a>The query uses the <code>MAX</code> or <code>MIN</code> function to select the maximum or minimum value of either the column of a single-column index or the leading column of a composite index. The index cannot be a cluster index. The argument to the <code>MAX</code> or <code>MIN</code> function can be any expression involving the column, a constant, or the addition operator (+), the concatenation operation (||), or the <code>CONCAT</code> function.</li>

<li class="LB1" type="disc"><a name="39304"></a>There are no other expressions in the select list.</li>

<li class="LB1" type="disc"><a name="39305"></a>The statement has no <code>WHERE</code> clause or <code>GROUP</code> <code>BY</code> clause.</li>
</ul>

<a name="39306"></a> 

<p class="BP">To execute the query, Oracle performs a full scan of the index to find the maximum or minimum indexed value. Because only this value is selected, Oracle need not access the table after scanning the index.</p>

<a name="39307"></a> 

<p class="BP">For example, in the following statement, there is an index on the <code>sal</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39309"></a>SELECT MAX(sal) FROM emp; 
<a name="39310"></a>
</pre>

<a name="39312"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="42492"></a>  0      SELECT STATEMENT Optimizer=CHOOSE 
<a name="42493"></a>  1    0  SORT (AGGREGATE) 
<a name="42473"></a>  2    1    INDEX (FULL SCAN (MIN/MAX)) OF 'SAL_INDEX' (NON-UNIQUE)
</pre>

<a name="39321"></a> <!--TOC=h3-"39321"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 14: ORDER BY on Indexed Column</font></h4>

<!--/TOC=h3-->
<a name="39322"></a> 

<p class="BP">This access path is available for a <code>SELECT</code> statement, and all of the following conditions are true:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39323"></a>The query contains an <code>ORDER</code> <code>BY</code> clause that uses either the column of a single-column index or a leading portion of a composite index. The index cannot be a cluster index.</li>

<li class="LB1" type="disc"><a name="39324"></a>There is a <code>PRIMARY</code> <code>KEY</code> or <code>NOT</code> <code>NULL</code> integrity constraint that guarantees that at least one of the indexed columns listed in the <code>ORDER</code> <code>BY</code> clause contains no nulls.</li>

<li class="LB1" type="disc"><a name="39326"></a>The <code>NLS_SORT</code> initialization parameter is set to <code>BINARY</code>.</li>
</ul>

<a name="39327"></a> 

<p class="BP">To execute the query, Oracle performs a range scan of the index to retrieve the rowids of the selected rows in sorted order. Oracle then accesses the table by these rowids.</p>

<a name="39328"></a> 

<p class="BP">For example:</p>

<a name="39329"></a> 

<p class="BP">In the following statement, there is a primary key on the <code>empno</code> column of the <code>emp</code> table:</p>

<pre class="CE">
<a name="39330"></a>SELECT * 
<a name="39331"></a>    FROM emp 
<a name="39332"></a>    ORDER BY empno; 
<a name="39333"></a>
</pre>

<a name="39335"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39336"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39337"></a>----------------------------------------------------- 
<a name="39338"></a>SELECT STATEMENT 
<a name="39339"></a>  TABLE ACCESS            BY ROWID       EMP 
<a name="39340"></a>    INDEX                 RANGE SCAN     PK_EMP 
<a name="39341"></a>
</pre>

<a name="39342"></a> 

<p class="BP"><code>pk_emp</code> is the name of the index that enforces the primary key. The primary key ensures that the column does not contain nulls.</p>

<a name="39346"></a> <!--TOC=h3-"39346"-->
<h4 class="H3"><font face="Arial, Helvetica, sans-serif" color="#330099">RBO Path 15: Full Table Scan</font></h4>

<!--/TOC=h3-->
<a name="39347"></a> 

<p class="BP">This access path is available for any SQL statement, regardless of its <code>WHERE</code> clause conditions, except when its <code>FROM</code> clause contains <code>SAMPLE</code> or <code>SAMPLE</code> <code>BLOCK</code>.</p>

<a name="39350"></a> 

<p class="BP">Note that the full table scan is the lowest ranked access path on the list. This means that the RBO always chooses an access path that uses an index if one is available, even if a full table scan might execute faster.</p>

<a name="39353"></a> 

<p class="BP">The following conditions make index access paths unavailable:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39354"></a>column1 &gt; column2</li>

<li class="LB1" type="disc"><a name="39355"></a>column1 &lt; column2</li>

<li class="LB1" type="disc"><a name="39356"></a>column1 &gt;= column2</li>

<li class="LB1" type="disc"><a name="39357"></a>column1 &lt;= column2</li>
</ul>

<a name="39358"></a> 

<p class="BP">where <em class="Italic">column1</em> and <em class="Italic">column2</em> are in the same table.</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39359"></a>column <code>IS</code> <code>NULL</code></li>

<li class="LB1" type="disc"><a name="39360"></a>column <code>IS</code> <code>NOT</code> <code>NULL</code></li>

<li class="LB1" type="disc"><a name="39361"></a>column <code>NOT</code> <code>IN</code></li>

<li class="LB1" type="disc"><a name="39362"></a>column != expr</li>

<li class="LB1" type="disc"><a name="39363"></a>column <code>LIKE</code> '%pattern'</li>
</ul>

<a name="39364"></a> 

<p class="BP">regardless of whether <em class="Italic">column</em> is indexed.</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39365"></a>expr = expr2</li>
</ul>

<a name="39366"></a> 

<p class="BP">where <em class="Italic">expr</em> is an expression that operates on a column with an operator or function, regardless of whether the column is indexed.</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="39367"></a><code>NOT</code> <code>EXISTS</code> subquery</li>

<li class="LB1" type="disc"><a name="39371"></a><code>ROWNUM</code> pseudocolumn in a view</li>

<li class="LB1" type="disc"><a name="39372"></a>Any condition involving a column that is not indexed</li>
</ul>

<a name="39373"></a> 

<p class="BP">Any SQL statement that contains only these constructs and no others that make index access paths available must use full table scans.</p>

<a name="39374"></a> 

<p class="BP">For example: The following statement uses a full table scan to access the <code>emp</code> table:</p>

<pre class="CE">
<a name="39376"></a>SELECT * 
<a name="39377"></a>    FROM emp; 
<a name="39378"></a>
</pre>

<a name="39380"></a> 

<p class="BP">The <code>EXPLAIN</code> <code>PLAN</code> output for this statement might look like this:</p>

<pre class="CE">
<a name="39381"></a>OPERATION                 OPTIONS        OBJECT_NAME 
<a name="39382"></a>----------------------------------------------------- 
<a name="39383"></a>SELECT STATEMENT 
<a name="38861"></a>  TABLE ACCESS            FULL           EMP 
</pre>

<a name="41378"></a> <!--TOC=h2-"41378"-->
<h3 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Choosing Execution Plans for Joins with the RBO</font></h3>

<!--/TOC=h2-->
<a name="41410"></a> 

<div align="center">
<table class="Note" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="Note">
<td class="Note">
<hr>
<a name="41414"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="41415"></a> 

<p class="NB">The following considerations apply to both the cost-based and rule-based approaches:</p>

<ul class="NL">
<li class="NL" type="disc"><a name="41416"></a>The optimizer first determines whether joining two or more of the tables definitely results in a row source containing at most one row. The optimizer recognizes such situations based on <code>UNIQUE</code> and <code>PRIMARY</code> <code>KEY</code> constraints on the tables. If such a situation exists, then the optimizer places these tables first in the join order. The optimizer then optimizes the join of the remaining set of tables.</li>

<li class="NL" type="disc"><a name="41417"></a>For join statements with outer join conditions, the table with the outer join operator must come after the other table in the condition in the join order. The optimizer does not consider join orders that violate this rule.</li>
</ul>

<hr>
</td>
</tr>
</table>
</div>

<a name="41381"></a> 

<p class="BP">With the rule-based approach, the optimizer performs the following steps to choose an execution plan for a statement that joins R tables:</p>

<ol class="LN1" type="1">
<li class="LN1" type="1" value="1"><a name="41382"></a>The optimizer generates a set of R join orders, each with a different table as the first table. The optimizer generates each potential join order using this algorithm: 

<ul class="LB2">
<li class="LB2" type="disc"><a name="41383"></a>To fill each position in the join order, the optimizer chooses the table with the most highly ranked available access path according to the ranks for access paths described in <a href="rbo.htm#38893">"Understanding Access Paths for the RBO"</a><a href="rbo.htm#38893"></a>. The optimizer repeats this step to fill each subsequent position in the join order.</li>

<li class="LB2" type="disc"><a name="42520"></a>For each table in the join order, the optimizer also chooses the operation with which to join the table to the previous table or row source in the order. The optimizer does this by ranking the sort-merge operation as access path 12 and applying these rules: 

<ul class="LA3">
<li class="LA3" type="SQUARE"><a name="42521"></a>If the access path for the chosen table is ranked 11 or better, then the optimizer chooses a nested loops operation using the previous table or row source in the join order as the outer table.</li>

<li class="LA3" type="SQUARE"><a name="42522"></a>If the access path for the table is ranked lower than 12, and if there is an equijoin condition between the chosen table and the previous table or row source in join order, then the optimizer chooses a sort-merge operation.</li>

<li class="LA3" type="SQUARE"><a name="42523"></a>If the access path for the chosen table is ranked lower than 12, and if there is not an equijoin condition, then the optimizer chooses a nested loops operation with the previous table or row source in the join order as the outer table.</li>
</ul>
</li>
</ul>
</li>

<li class="LN1" type="1" value="2"><a name="42524"></a>The optimizer then chooses among the resulting set of execution plans. The goal of the optimizer's choice is to maximize the number of nested loops join operations in which the inner table is accessed using an index scan. Because a nested loops join involves accessing the inner table many times, an index on the inner table can greatly improve the performance of a nested loops join. 

<p><a name="41395"></a></p>

<p class="BP1">Usually, the optimizer does not consider the order in which tables appear in the <code>FROM</code> clause when choosing an execution plan. The optimizer makes this choice by applying the following rules in&nbsp;order:</p>

<ul class="LB2">
<li class="LB2" type="disc"><a name="41396"></a>The optimizer chooses the execution plan with the fewest nested-loops operations in which the inner table is accessed with a full table scan.</li>

<li class="LB2" type="disc"><a name="41397"></a>If there is a tie, then the optimizer chooses the execution plan with the fewest sort-merge operations.</li>

<li class="LB2" type="disc"><a name="41398"></a>If there is still a tie, then the optimizer chooses the execution plan for which the first table in the join order has the most highly ranked access path: 

<ul class="LA3">
<li class="LA3" type="SQUARE"><a name="41399"></a>If there is a tie among multiple plans whose first tables are accessed by the single-column indexes access path, then the optimizer chooses the plan whose first table is accessed with the most merged indexes.</li>

<li class="LA3" type="SQUARE"><a name="41400"></a>If there is a tie among multiple plans whose first tables are accessed by bounded range scans, then the optimizer chooses the plan whose first table is accessed with the greatest number of leading columns of the composite index.</li>
</ul>
</li>

<li class="LB2" type="disc"><a name="41401"></a>If there is still a tie, then the optimizer chooses the execution plan for which the first table appears later in the query's <code>FROM</code> clause.</li>
</ul>
</li>
</ol>

<a name="41432"></a> <!--TOC=h1-"41432"-->
<h2 class="H1"><font face="Arial, Helvetica, sans-serif" color="#330099">Transforming and Optimizing Statements with the RBO</font></h2>

<!--/TOC=h1-->
<a name="41434"></a> 

<p class="BP">SQL is a very flexible query language; often, there are many statements you could use to achieve the same goal. Sometimes, the optimizer transforms one such statement into another that achieves the same goal if the second statement can be executed more efficiently.</p>

<a name="42321"></a> 

<p class="BP">This section discusses the following topics:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="42322"></a><a href="rbo.htm#42324">Transforming ORs into Compound Queries with the RBO</a></li>

<li class="LB1" type="disc"><a name="42333"></a><a href="rbo.htm#42251">Using Alternative SQL Syntax</a></li>
</ul>

<a name="42324"></a> <!--TOC=h2-"42324"-->
<h3 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Transforming ORs into Compound Queries with the RBO</font></h3>

<!--/TOC=h2-->
<a name="41472"></a> 

<p class="BP">If a query contains a <code>WHERE</code> clause with multiple conditions combined with <code>OR</code> operators, then the optimizer transforms it into an equivalent compound query that uses the <code>UNION</code> <code>ALL</code> set operator if this makes it execute more efficiently:</p>

<ul class="LB1">
<li class="LB1" type="disc"><a name="41474"></a>If each condition individually makes an index access path available, then the optimizer can make the transformation. The optimizer chooses an execution plan for the resulting statement that accesses the table multiple times using the different indexes, and then puts the results together.</li>

<li class="LB1" type="disc"><a name="41475"></a>If any condition requires a full table scan because it does not make an index available, then the optimizer does not transform the statement. The optimizer chooses a full table scan to execute the statement, and Oracle tests each row in the table to determine whether it satisfies any of the conditions. 

<p><a name="41494"></a></p>

<div align="center">
<table class="NoteAlso" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="NoteAlso">
<td class="NoteAlso"><a name="41480"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">See Also:</strong></font> <a name="44076"></a> 

<p class="NB"><a href="rbo.htm#38893">"Understanding Access Paths for the RBO"</a><a href="rbo.htm#38893"></a> and <a href="opt_ops.htm#1005572">"How the CBO Transforms ORs into Compound Queries"</a><a href="opt_ops.htm#1005572"></a> for information on access paths and how indexes make them available</p>
</td>
</tr>
</table>
</div>
</li>
</ul>

<a name="41514"></a> 

<p class="BP">With the RBO, the optimizer makes this <code>UNION</code> <code>ALL</code> transformation, because each component query of the resulting compound query can be executed using an index. The RBO assumes that executing the compound query using two index scans is faster than executing the original query using a full table scan.</p>

<a name="42251"></a> <!--TOC=h2-"42251"-->
<h3 class="H2"><font face="Arial, Helvetica, sans-serif" color="#330099">Using Alternative SQL Syntax</font></h3>

<!--/TOC=h2-->
<a name="42252"></a> 

<p class="BP">Because SQL is a flexible language, more than one SQL statement can meet the needs of an application. Although two SQL statements can produce the same result, Oracle might process one faster than the other. You can use the results of the <code>EXPLAIN</code> <code>PLAN</code> statement to compare the execution plans and costs of the two statements and determine which is more efficient.</p>

<a name="42255"></a> 

<p class="BP">This example shows the execution plans for two SQL statements that perform the same function. Both statements return all the departments in the <code>dept</code> table that have no employees in the <code>emp</code> table. Each statement searches the <code>emp</code> table with a subquery. Assume there is an index, <code>deptno_index</code>, on the <code>deptno</code> column of the <code>emp</code> table.</p>

<a name="42258"></a> 

<p class="BP">The first statement and its execution plan:</p>

<pre class="CE">
<a name="42259"></a>SELECT dname, deptno
<a name="42260"></a>   FROM dept
<a name="42261"></a>   WHERE deptno NOT IN
<a name="42262"></a>      (SELECT deptno FROM emp);
<a name="44245"></a>
</pre>

<a name="44248"></a> 

<p class="BP">The execution plan for the transformed statement might look like the illustration in <a href="rbo.htm#42263">Figure&nbsp;8-1</a>. The shaded boxes indicate steps that physically retrieve data and the clear boxes indicate steps that operate on data returned from the previous step.</p>

<a name="42263"></a> 

<h4 class="FT"><font face="Arial, Helvetica, sans-serif"><em>Figure 8-1 Execution Plan with Two Full Table Scans</em></font></h4>

<a name="42267"><img src="pfgrf023.gif" alt="Text description of pfgrf023.gif follows"></a><a href="img_text/pfgrf023.htm"><br>
Text description of the illustration pfgrf023.gif</a><br>
<br>
 <a name="42268"></a> 

<p class="BP">Step 3 of the output indicates that Oracle executes this statement by performing a full table scan of the <code>emp</code> table despite the index on the <code>deptno</code> column. This full table scan can be a time-consuming operation. Oracle does not use the index, because the subquery that searches the <code>emp</code> table does not have a <code>WHERE</code> clause that makes the index available.</p>

<a name="42273"></a> 

<p class="BP">However, this SQL statement selects the same rows by accessing the index:</p>

<pre class="CE">
<a name="42274"></a>SELECT dname, deptno
<a name="42275"></a>FROM dept
<a name="42276"></a>WHERE NOT EXISTS
<a name="42277"></a>    (SELECT deptno
<a name="42278"></a>    FROM emp
<a name="42279"></a>    WHERE dept.deptno = emp.deptno);
<a name="44261"></a>
</pre>

<a name="44264"></a> 

<p class="BP">The execution plan for the transformed statement might look like the illustration in <a href="rbo.htm#42280">Figure&nbsp;8-2</a>. The shaded boxes indicate steps that physically retrieve data and the clear boxes indicate steps that operate on data returned from the previous step.</p>

<a name="42280"></a> 

<h4 class="FT"><font face="Arial, Helvetica, sans-serif"><em>Figure 8-2 Execution Plan with a Full Table Scan and an Index Scan</em></font></h4>

<a name="42284"><img src="pfgrf024.gif" alt="Text description of pfgrf024.gif follows"></a><a href="img_text/pfgrf024.htm"><br>
Text description of the illustration pfgrf024.gif</a><br>
<br>
 <a name="42285"></a> 

<p class="BP">The <code>WHERE</code> clause of the subquery refers to the <code>deptno</code> column of the <code>emp</code> table, so the index <code>deptno_index</code> is used. The use of the index is reflected in step 3 of the execution plan. The index range scan of <code>deptno_index</code> takes less time than the full scan of the <code>emp</code> table in the first statement. Furthermore, the first query performs one full scan of the <code>emp</code> table for every <code>deptno</code> in the <code>dept</code> table. For these reasons, the second SQL statement is faster than the first.</p>

<a name="42286"></a> 

<p class="BP">If you have statements in an application that use the <code>NOT</code> <code>IN</code> operator, as the first query in this example does, then consider rewriting them so that they use the <code>NOT</code> <code>EXISTS</code> operator. This allows such statements to use an index if one exists.</p>

<a name="42291"></a> 

<div align="center">
<table class="Note" border="0" width="80%" cellpadding="0" cellspacing="0" dir="ltr" summary="This is a layout table to format a note" title="This is a layout table to format a note">
<tr class="Note">
<td class="Note">
<hr>
<a name="42289"></a><font face="Arial, Helvetica, sans-serif"><strong class="NH">Note:</strong></font> <a name="42290"></a> 

<p class="NB">Alternative SQL syntax is effective only with the rule-based optimizer.</p>

<hr>
</td>
</tr>
</table>
</div>

<!-- Start Footer --></div>

<div class="footer">
<hr>
<table summary="layout table" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td width="33%" align="left">
<table summary="layout table" cellspacing="0" cellpadding="0" align="left" width="90">
<tr>
<td align="center" valign="top"><a href="outlines.htm"><img src="../../dcommon/gifs/larrow.gif" alt="Go to previous page" border="0"></a></td>
<td align="center" valign="top"><a href="part2.htm"><img src="../../dcommon/gifs/rarrow.gif" alt="Go to next page" border="0"></a></td>
</tr>
</table>
</td>
<td width="34%" align="center"><img src="../../dcommon/gifs/oracle.gif" alt="Oracle"><br>
<a href="../../dcommon/html/cpyr.htm"><font size="-2">Copyright &copy; 2000, 2002 Oracle Corporation.</font></a><br>
<font size="-2">All Rights Reserved.</font></td>
<td width="33%" align="right">
<table summary="layout table" cellspacing="0" cellpadding="0" align="right" width="270">
<tr>
<td align="center" valign="top"><a href="../../index.htm"><img src="../../dcommon/gifs/prodicon.gif" alt="Go to Documentation Library" border="0"><br>
<font size="-2">Home</font></a></td>
<td align="center" valign="top"><a href="../../nav/docindex.htm"><img src="../../dcommon/gifs/bookicon.gif" alt="Go to Product List" border="0"><br>
<font size="-2">Book List</font></a></td>
<td align="center" valign="top"><a href="toc.htm"><img src="../../dcommon/gifs/conticon.gif" alt="Go to Table of Contents" border="0"><br>
<font size="-2">Contents</font></a></td>
<td align="center" valign="top"><a href="index.htm"><img src="../../dcommon/gifs/indxicon.gif" alt="Go to Index" border="0"><br>
<font size="-2">Index</font></a></td>
<td align="center" valign="top"><a href="../../mix.920/a96625/toc.htm"><img src="../../dcommon/gifs/mix.gif" alt="Go to Master Index" border="0"><br>
<font size="-2">Master Index</font></a></td>
<td align="center" valign="top"><a href="../../dcommon/html/feedback.htm"><img src="../../dcommon/gifs/feedback.gif" alt="Go to Feedback page" border="0"><br>
<font size="-2">Feedback</font></a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</body>
</html>

