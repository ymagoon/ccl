 ;;Solution_Test/script/PathNet -- BB Transfusion/bb_upd_related_qc_reagents/bb_upd_related_qc_reagents.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
       *                              Technology, Inc.                        *
      *       Revision      (c) 1984-2003 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/

/*****************************************************************************

  Source file name:   bb_upd_related_qc_reagents.prg
  Object name:        bb_upd_related_qc_reagents
  Request #:          225834

  Product:            BBT QC Preferences
  Product Team:       BBT
  HNA Version:        500
  CCL Version:        8.2

  Program purpose:    Add a new related reagent, or update existing ones

  Tables read:        bb_qc_rel_reagent,bb_qc_rel_reagent_detail,
                      bb_qc_expected_result
  Tables updated:     bb_qc_rel_reagent,bb_qc_rel_reagent_detail,
                      bb_qc_expected_result
  Executing from:     BBDQCPreferences

  Special Notes:      This script will be the driver script and will call sub
                      scripts to handle the table inserts and updates.  No longer
                      needs to version the related reagent table.  Also -- use
                      "Scheme 2" versioning with no prev_active_ind.

******************************************************************************/

;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer                     Comment
;    *
;    *--- -------- -------------------- ----------------------------------- *
;    *000 05/26/04 DP9409               Initial Release
;    *
;    *001 06/12/07 Jason Osborn         Replace cnvtalphanum with cnvtupper.*
;~DE~************************************************************************
;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

drop   program bb_upd_related_qc_reagents:dba go
create program bb_upd_related_qc_reagents:dba

set modify predeclare
/*
record request
(
%i cclsource:bb_upd_related_qc_reagents_req.inc
  1 related_reagent_list[*]
    2 related_reagent_id          = f8
    2 reagent_cd                  = f8
    2 related_reagent_name        = c40
    2 active_ind                  = i2
    2 updt_cnt                    = i4
    2 save_flag                   = i2
    2 related_reagent_detail_list[*]
      3 related_reagent_detail_id = f8
      3 enhancement_cd            = f8
      3 control_cd                = f8
      3 phase_cd                  = f8
      3 active_ind                = i2
      3 updt_cnt                  = i4
      3 save_flag                 = i2
      3 expected_result_list[*]
        4 expected_result_id      = f8
        4 nomenclature_id         = f8
      	4 active_ind              = i2
      	4 updt_cnt                = i4
      	4 save_flag               = i4
)
*/

if (not validate(reply, 0))
  record reply
  (
  1 related_reagent_list[*]
    2 id          = f8
    2 related_reagent_detail_list[*]
      3 id = f8
      3 expected_result_list[*]
        4 id      = f8
%i cclsource:status_block.inc
  )
endif

%i cclsource:glb_script_logging.inc

/* Valid save_flag values */
declare nBB_SAVE_NOUPDATE  = i2 with protect, constant(0)
declare nBB_SAVE_NEW       = i2 with protect, constant(1)
declare nBB_SAVE_UPDATE    = i2 with protect, constant(2)
declare nBB_SAVE_DELETE    = i2 with protect, constant(3)
declare nStat              = i2 with protect, noconstant(0)
declare nEND_DATE          = f8 with protect, constant(cnvtdatetime("31-DEC-2100 23:59:59.99"))
declare nSCRIPT_DATE       = f8 with protect, constant(cnvtdatetime(curdate,curtime3))

/*Declare all record structures */
record upd_related_reagents
(
  1 rows[*]
    2 related_reagent_id          = f8
    2 reagent_cd                  = f8
    2 related_reagent_name        = c40
    2 active_ind                  = i2
    2 updt_cnt                    = i4
    2 prev_related_reagent_id     = f8
    2 active_ind                  = i2
    2 prev_active_ind             = i2
    2 beg_effective_dt_tm         = dq8
    2 end_effective_dt_tm         = dq8
) with protect

record ins_related_reagents
(
  1 rows[*]
    2 related_reagent_id          = f8
    2 reagent_cd                  = f8
    2 related_reagent_name        = c40
    2 active_ind                  = i2
    2 updt_cnt                    = i4
    2 prev_related_reagent_id     = f8
    2 active_ind                  = i2
    2 prev_active_ind             = i2
    2 beg_effective_dt_tm         = dq8
    2 end_effective_dt_tm         = dq8
) with protect

record upd_related_reagent_detail
(
  1 rows[*]
    2 related_reagent_detail_id = f8
    2 related_reagent_id        = f8
    2 enhancement_cd            = f8
    2 control_cd                = f8
    2 phase_cd                  = f8
    2 active_ind                = i2
    2 updt_cnt                        = i4
    2 prev_related_reagent_detail_id  = f8
    2 active_ind =i2
    2 prev_active_ind = i2
    2 beg_effective_dt_tm = dq8
    2 end_effective_dt_tm = dq8
) with protect

record ins_related_reagent_detail
(
  1 rows[*]
    2 related_reagent_detail_id = f8
    2 related_reagent_id        = f8
    2 enhancement_cd            = f8
    2 control_cd                = f8
    2 phase_cd                  = f8
    2 active_ind                = i2
    2 updt_cnt                        = i4
    2 prev_related_reagent_detail_id  = f8
    2 active_ind =i2
    2 prev_active_ind = i2
    2 beg_effective_dt_tm = dq8
    2 end_effective_dt_tm = dq8
) with protect

record upd_expected_results
(
  1 rows[*]
    2 expected_result_id          = f8
    2 related_reagent_detail_id   = f8
    2 nomenclature_id             = f8
    2 active_ind                  = i2
    2 updt_cnt                    = i4
    2 prev_expected_result_id     = f8
    2 beg_effective_dt_tm         = dq8
    2 end_effective_dt_tm         = dq8
) with protect

record ins_expected_results
(
 1 rows[*]
    2 expected_result_id          = f8
    2 related_reagent_detail_id   = f8
    2 nomenclature_id             = f8
    2 active_ind                  = i2
    2 updt_cnt                    = i4
    2 prev_expected_result_id     = f8
    2 beg_effective_dt_tm         = dq8
    2 end_effective_dt_tm         = dq8
) with protect

record new_ids
(
 1 rows[*]
    2 id = f8
) with protect

record nomen_ids
(
 1 rows[*]
    2 id = f8
) with protect

/* Script */
set reply->status_data->status = "F"
set reqinfo->commit_ind = 0

/* Perform updates to the RELATED_REAGENT table */
if (not UpdateRELATED_REAGENT(0))
  go to exit_script
endif

/* Perform updates to the RELATED_REAGENT_DETAIL table */
if (not UpdateRELATED_REAGENT_DETAIL(0))
  go to exit_script
endif

/* Perform updates to EXPECTED_RESULTS table */
if (not UpdateEXPECTED_RESULTS(0))
  go to exit_script
endif

/* Perform Transfer New Ids */
if (not TransferNewIds(0))
  go to exit_script
endif

/* Script was successfull */
set reply->status_data->status = "S"
set reqinfo->commit_ind = 1

/**********************************************************
FUNCTION - UpdateRELATED_REAGENT(NULL)
    Performs inserts/updates to the RELATED_REAGENT table.
    PARAMS
        None
    RETURN
        1 - Success
        0 - Error occured
***********************************************************/
declare    UpdateRELATED_REAGENT() = f8
subroutine UpdateRELATED_REAGENT(NULL)

declare i = i4 with protect, noconstant(0)
declare j = i4 with protect, noconstant(0)
declare nEnteredReport = i2 with protect, noconstant(0)
declare UpdCntErrorCnt = i2 with protect, noconstant(0)

  /* lock existing related reagent rows
     build update record with related reagents that require updating
     build archive record rows for related reagents that will be updated */
  set i =0 
  set j = 0
  
  ;generate all the ids that I'll need for this table...
  set nStat = alterlist(new_ids->rows, 0)
  for (i = 1 to value(size(request->related_reagent_list, 5)))
    if (request->related_reagent_list[j].save_flag = nBB_SAVE_NEW)
      set j = j + 1
      if (j > size(new_ids->rows, 5))
        set nStat = alterlist(new_ids->rows, j + 10)
      endif
      
      set new_ids->rows[j].id = GetNextSeq(0)
      
    endif  

  endfor
  set nStat = alterlist(new_ids->rows, j)
  set i =0 
  set j = 0 ;count of where we are in new_id structure...

  select into "nl:"
  from
    bb_qc_rel_reagent bbqcrr,
    (dummyt d with seq = value(size(request->related_reagent_list, 5)))
  plan d
  join bbqcrr
    where bbqcrr.related_reagent_id = request->related_reagent_list[d.seq].related_reagent_id
      and (request->related_reagent_list[d.seq].save_flag = nBB_SAVE_UPDATE or
      request->related_reagent_list[d.seq].save_flag = nBB_SAVE_DELETE)
  detail
    i = i + 1
    if (i > size(upd_related_reagents->rows, 5))
      nStat = alterlist(upd_related_reagents->rows, i + 10)
    endif
    upd_related_reagents->rows[i].related_reagent_id = request->related_reagent_list[d.seq].related_reagent_id
    /* NOTE : Do NOT fill out
                 ins_related_reagents->rows[i].related_reagent_id
              since the new id for the archive row will be generated upon the insert statement */
    upd_related_reagents->rows[i].reagent_cd = request->related_reagent_list[d.seq].reagent_cd
    upd_related_reagents->rows[i].related_reagent_name = request->related_reagent_list[d.seq].related_reagent_name	;added
    
    ;IN THEORY, THIS IS THE ONLY THING THAT WILL CHANGE!
    upd_related_reagents->rows[i].active_ind = request->related_reagent_list[d.seq].active_ind

    if (request->related_reagent_list[d.seq].updt_cnt != bbqcrr.updt_cnt)
      nStat = populate_subeventstatus("SELECT", "F", "bb_qc_rel_reagent",
                                   build("related reagent id=", request->related_reagent_list[d.seq].related_reagent_id,
                                   "with update count=", request->related_reagent_list[d.seq].updt_cnt,
                                   " has been updated."))
      UpdCntErrorCnt = UpdCntErrorCnt + 1
    endif
  with nocounter,
       forupdate(bbqcrr)

  set nStat = alterlist(upd_related_reagents->rows, i)
  set nStat = alterlist(ins_related_reagents->rows, 0)

  if (error_message(1))
    call populate_subeventstatus("SELECT", "F", "bb_qc_rel_reagent",
                                 "Error locking rows for update.")
    return (0)
  endif

  if (UpdCntErrorCnt > 0)
    call populate_subeventstatus("SELECT", "F", "bb_qc_rel_reagent",
                                 build(UpdCntErrorCnt, " related reagent(s) have been updated."))
    return (0)
  endif

  ;add in the newly created rows to the insert structure along with the ones
  ;that are in the insert structure due to versioning
  /* add new rows to insert */
  
  set nEnteredReport = 0
  
  select into "nl:"
    d.seq
  from
    (dummyt d with seq = value(size(request->related_reagent_list, 5)))
  plan d
    where request->related_reagent_list[d.seq].save_flag = nBB_SAVE_NEW
  head report
    i = size(ins_related_reagents->rows, 5)
  detail
    i = i + 1
    if (i > size(ins_related_reagents->rows, 5))
      nStat = alterlist(ins_related_reagents->rows, i + 10)
    endif
    
    nEnteredReport = 1
    
    j = j + 1
    ins_related_reagents->rows[i].related_reagent_id = new_ids->rows[j].id
                                                       
    ;update request structure!
    request->related_reagent_list[d.seq].related_reagent_id = ins_related_reagents->rows[i].related_reagent_id

    ins_related_reagents->rows[i].reagent_cd = request->related_reagent_list[d.seq].reagent_cd
    ins_related_reagents->rows[i].related_reagent_name = request->related_reagent_list[d.seq].related_reagent_name
    ins_related_reagents->rows[i].active_ind = request->related_reagent_list[d.seq].active_ind
    ins_related_reagents->rows[i].prev_active_ind = request->related_reagent_list[d.seq].active_ind
    ins_related_reagents->rows[i].beg_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    ins_related_reagents->rows[i].end_effective_dt_tm = cnvtdatetime(nEND_DATE)
  with nocounter

  if (nEnteredReport = 1)
    set nStat = alterlist(ins_related_reagents->rows, i)
  else
    set nStat = alterlist(ins_related_reagents->rows, 0)
  endif
  
  /* update existing rows */
  if (size(upd_related_reagents->rows, 5) > 0)
    update into
      bb_qc_rel_reagent bbqcrr,
      (dummyt d with seq = value(size(upd_related_reagents->rows, 5)))
    set
      bbqcrr.reagent_cd = upd_related_reagents->rows[d.seq].reagent_cd,
      bbqcrr.related_reagent_name = upd_related_reagents->rows[d.seq].related_reagent_name,
      bbqcrr.related_reagent_name_key = cnvtupper(upd_related_reagents->rows[d.seq].related_reagent_name),
      bbqcrr.active_ind = upd_related_reagents->rows[d.seq].active_ind,
      bbqcrr.updt_applctx = reqinfo->updt_applctx,
      bbqcrr.updt_cnt = bbqcrr.updt_cnt + 1,
      bbqcrr.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcrr.updt_id = reqinfo->updt_id,
      bbqcrr.updt_task = reqinfo->updt_task
    plan d
    join bbqcrr
      where bbqcrr.related_reagent_id = upd_related_reagents->rows[d.seq].related_reagent_id
    with nocounter

    if (error_message(1))
      return (0)
    endif

  endif	;if there are rows to update

  /* insert new rows */
  if (size(ins_related_reagents->rows, 5) > 0)
    insert into
      bb_qc_rel_reagent bbqcrr,
      (dummyt d with seq = value(size(ins_related_reagents->rows, 5)))
    set
      bbqcrr.related_reagent_id = ins_related_reagents->rows[d.seq].related_reagent_id,
      bbqcrr.reagent_cd = ins_related_reagents->rows[d.seq].reagent_cd,
      bbqcrr.related_reagent_name = ins_related_reagents->rows[d.seq].related_reagent_name,
      bbqcrr.related_reagent_name_key = cnvtupper(ins_related_reagents->rows[d.seq].related_reagent_name),
      bbqcrr.active_ind = ins_related_reagents->rows[d.seq].active_ind,
      bbqcrr.updt_applctx = reqinfo->updt_applctx,
      bbqcrr.updt_cnt = 0,
      bbqcrr.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcrr.updt_id = reqinfo->updt_id,
      bbqcrr.updt_task = reqinfo->updt_task
    plan d
    join bbqcrr
    with nocounter

    if (error_message(1))
      return (0)
    endif

  endif ;if there are rows to insert

  if (error_message(1))
    return (0)
  endif

  /* everything was successful */
  return (1)

end ;subroutine UpdateRELATED_REAGENT */

/**********************************************************
FUNCTION - UpdateRELATED_REAGENT_DETAIL(NULL)
    Performs inserts/updates to the RELATED_REAGENT_DETAIL table.
    PARAMS
        None
    RETURN
        1 - Success
        0 - Error occured
***********************************************************/
declare    UpdateRELATED_REAGENT_DETAIL() = f8
subroutine UpdateRELATED_REAGENT_DETAIL(NULL)

declare i = i4 with protect, noconstant(0)
declare i1 = i4 with protect, noconstant(0)
declare j = i4 with protect, noconstant(0)
declare UpdCntErrorCnt = i2 with protect, noconstant(0)

  /* lock existing related reagent details rows
     build update record with reagent details that require updating
     build archive record rows for reagent details that will be updated */
  
  set i =0 
  set i1 = 0
  set j = 0
  
  
  ;generate all the ids that will be needed for this table...
  set nStat = alterlist(new_ids->rows, 0)
  for (i = 1 to value(size(request->related_reagent_list, 5)))
    for (i1 = 1 to value(size(request->related_reagent_list[i]->related_reagent_detail_list, 5)))
      
        if (not(request->related_reagent_list[i]->related_reagent_detail_list[i1].save_flag = 
              nBB_SAVE_NOUPDATE))
          set j = j + 1
          if (j > size(new_ids->rows, 5))
            set nStat = alterlist(new_ids->rows, j + 10)
          endif
        
          set new_ids->rows[j].id = GetNextSeq(0)
        endif
    endfor
  endfor
  set nStat = alterlist(new_ids->rows, j)
  
  set i =0 
  set j = 0 ;count of where we are in new_id structure...
  
  select into "nl:"
  from
    bb_qc_rel_reagent_detail bbqcrrd,
    (dummyt d1 with seq = value(size(request->related_reagent_list, 5))),
    (dummyt d2 with seq = 1)
    
  plan d1
    where maxrec(d2, size(request->related_reagent_list[d1.seq].related_reagent_detail_list, 5))
  join d2
  join bbqcrrd
    where (bbqcrrd.related_reagent_detail_id = request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].
      related_reagent_detail_id
      and (request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].save_flag = nBB_SAVE_UPDATE
      	   or request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].save_flag = nBB_SAVE_DELETE))
  detail
    i = i + 1
    if (i > size(upd_related_reagent_detail->rows, 5))
      nStat = alterlist(upd_related_reagent_detail->rows, i + 10)
      nStat = alterlist(ins_related_reagent_detail->rows, i + 10)
    endif
    upd_related_reagent_detail->rows[i].related_reagent_detail_id = request->related_reagent_list[d1.seq].
        related_reagent_detail_list[d2.seq].related_reagent_detail_id
    /* NOTE : Do NOT fill out
                 ins_related_reagent_detail->rows[i].related_reagent_detail_id
              since the new id for the archive row will be generated upon the insert statement */
    ;no, it's better to generate it here so that it's in the structure when it needs to be referred to later...
    j = j + 1
    ins_related_reagent_detail->rows[i].related_reagent_detail_id = new_ids->rows[j].id 
                                                                  ;GetNextSeq(0);cnvtreal(seq(pathnet_seq, nextval))
                                                              
    upd_related_reagent_detail->rows[i].related_reagent_id = request->related_reagent_list[d1.seq].related_reagent_id
    ins_related_reagent_detail->rows[i].related_reagent_id = bbqcrrd.related_reagent_id
    upd_related_reagent_detail->rows[i].enhancement_cd = request->
                                                   related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].enhancement_cd
    ins_related_reagent_detail->rows[i].enhancement_cd = bbqcrrd.enhancement_cd
    upd_related_reagent_detail->rows[i].control_cd = request->
                                                    related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].control_cd
    ins_related_reagent_detail->rows[i].control_cd = bbqcrrd.control_cd
    upd_related_reagent_detail->rows[i].phase_cd = request->
                                                    related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].phase_cd
    ins_related_reagent_detail->rows[i].phase_cd = bbqcrrd.phase_cd

    upd_related_reagent_detail->rows[i].prev_related_reagent_detail_id = request->
                                        related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id
    ins_related_reagent_detail->rows[i].prev_related_reagent_detail_id = request->
                                        related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id
        
    upd_related_reagent_detail->rows[i].active_ind = request->
                                         related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].active_ind
    ins_related_reagent_detail->rows[i].active_ind = bbqcrrd.active_ind ;MOD
    
    upd_related_reagent_detail->rows[i].beg_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    ins_related_reagent_detail->rows[i].beg_effective_dt_tm = bbqcrrd.beg_effective_dt_tm
    ins_related_reagent_detail->rows[i].end_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    
    if (request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].save_flag = nBB_SAVE_UPDATE)
       upd_related_reagent_detail->rows[i].end_effective_dt_tm = cnvtdatetime(nEND_DATE)
    else	;the save flag is set to nBB_SAVE_DELETE!
       upd_related_reagent_detail->rows[i].end_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)	;this is the only change
    endif
    
    if (request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].updt_cnt != bbqcrrd.updt_cnt)
      nStat = populate_subeventstatus("SELECT", "F", "RELATED_REAGENT_DETAIL",
                                   build("related reagent detail id=", request->
                                   related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id,
                                   "with update count=", request->
                                   related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].updt_cnt,
                                   " has been updated."))
      UpdCntErrorCnt = UpdCntErrorCnt + 1
    endif
  with nocounter,
       forupdate(bbqcrrd)

  set nStat = alterlist(upd_related_reagent_detail->rows, i)
  set nStat = alterlist(ins_related_reagent_detail->rows, i)

  if (error_message(1))
    call populate_subeventstatus("SELECT", "F", "RELATED_REAGENT_DETAIL",
                                 "Error locking rows for update.")
    return (0)
  endif

  if (UpdCntErrorCnt > 0)
    call populate_subeventstatus("SELECT", "F", "RELATED_REAGENT_DETAIL",
                                 build(UpdCntErrorCnt, " reagent detail(s) have been updated."))
    return (0)
  endif

  /* add new rows to insert */
  select into "nl:"
    d.seq
  from
    (dummyt d1 with seq = value(size(request->related_reagent_list, 5))),
    (dummyt d2 with seq = 1)
  plan d1
    where maxrec(d2, size(request->related_reagent_list[d1.seq].related_reagent_detail_list, 5))
  join d2
    where request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].save_flag = nBB_SAVE_NEW
  head report
    i = size(ins_related_reagent_detail->rows, 5)
  detail
    i = i + 1
    if (i > size(ins_related_reagent_detail->rows, 5))
      nStat = alterlist(ins_related_reagent_detail->rows, i + 10)
    endif
    
    j = j + 1
    ins_related_reagent_detail->rows[i].related_reagent_detail_id = new_ids->rows[j].id
    
    ;update the request structure!    
    request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id = 
                                  ins_related_reagent_detail->rows[i].related_reagent_detail_id
    
    ins_related_reagent_detail->rows[i].related_reagent_id = request->related_reagent_list[d1.seq].related_reagent_id
    
    ins_related_reagent_detail->rows[i].enhancement_cd = request->
                  related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].enhancement_cd
    ins_related_reagent_detail->rows[i].control_cd = request->
                  related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].control_cd
    ins_related_reagent_detail->rows[i].phase_cd = request->
                  related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].phase_cd
    
    ;these are equal here...    
    ins_related_reagent_detail->rows[i].prev_related_reagent_detail_id =
                  ins_related_reagent_detail->rows[i].related_reagent_detail_id
    
    ins_related_reagent_detail->rows[i].active_ind = request->
                  related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].active_ind
    ins_related_reagent_detail->rows[i].beg_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    ins_related_reagent_detail->rows[i].end_effective_dt_tm = cnvtdatetime(nEND_DATE)
  with nocounter

  set nStat = alterlist(ins_related_reagent_detail->rows, i)

  /* update existing rows */
  if (size(upd_related_reagent_detail->rows, 5) > 0)

    /* perform update */
    update into
      bb_qc_rel_reagent_detail bbqcrrd,
      (dummyt d with seq = value(size(upd_related_reagent_detail->rows, 5)))
    set
      bbqcrrd.related_reagent_id = upd_related_reagent_detail->rows[d.seq].related_reagent_id,
      bbqcrrd.enhancement_cd = upd_related_reagent_detail->rows[d.seq].enhancement_cd,
      bbqcrrd.control_cd = upd_related_reagent_detail->rows[d.seq].control_cd,
      bbqcrrd.phase_cd = upd_related_reagent_detail->rows[d.seq].phase_cd,
      bbqcrrd.prev_related_reagent_detail_id = upd_related_reagent_detail->rows[d.seq].prev_related_reagent_detail_id,
      bbqcrrd.active_ind = upd_related_reagent_detail->rows[d.seq].active_ind,
      ;bbqcrrd.prev_active_ind = upd_related_reagent_detail->rows[d.seq].prev_active_ind,
      bbqcrrd.beg_effective_dt_tm = cnvtdatetime(upd_related_reagent_detail->rows[d.seq].beg_effective_dt_tm),
      bbqcrrd.end_effective_dt_tm = cnvtdatetime(upd_related_reagent_detail->rows[d.seq].end_effective_dt_tm),
      bbqcrrd.updt_applctx = reqinfo->updt_applctx,
      bbqcrrd.updt_cnt = bbqcrrd.updt_cnt + 1,
      bbqcrrd.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcrrd.updt_id = reqinfo->updt_id,
      bbqcrrd.updt_task = reqinfo->updt_task
    plan d
    join bbqcrrd
      where bbqcrrd.related_reagent_detail_id = upd_related_reagent_detail->rows[d.seq].related_reagent_detail_id
    with nocounter

    if (error_message(1))
      return (0)
    endif
  endif

  /* insert new rows */
  if (size(ins_related_reagent_detail->rows, 5) > 0)
    insert into
      bb_qc_rel_reagent_detail bbqcrrd,
      (dummyt d with seq = value(size(ins_related_reagent_detail->rows, 5)))
    set
      bbqcrrd.related_reagent_detail_id = ins_related_reagent_detail->rows[d.seq].related_reagent_detail_id,
      bbqcrrd.enhancement_cd = ins_related_reagent_detail->rows[d.seq].enhancement_cd,
      bbqcrrd.related_reagent_id = ins_related_reagent_detail->rows[d.seq].related_reagent_id,
      bbqcrrd.control_cd = ins_related_reagent_detail->rows[d.seq].control_cd,
      bbqcrrd.phase_cd = ins_related_reagent_detail->rows[d.seq].phase_cd,
      bbqcrrd.prev_related_reagent_detail_id = ins_related_reagent_detail->rows[d.seq].prev_related_reagent_detail_id,
      bbqcrrd.active_ind = ins_related_reagent_detail->rows[d.seq].active_ind,
      bbqcrrd.beg_effective_dt_tm = cnvtdatetime(ins_related_reagent_detail->rows[d.seq].beg_effective_dt_tm),
      bbqcrrd.end_effective_dt_tm = cnvtdatetime(ins_related_reagent_detail->rows[d.seq].end_effective_dt_tm),
      bbqcrrd.updt_applctx = reqinfo->updt_applctx,
      bbqcrrd.updt_cnt = 0,
      bbqcrrd.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcrrd.updt_id = reqinfo->updt_id,
      bbqcrrd.updt_task = reqinfo->updt_task
    plan d
    join bbqcrrd
    with nocounter

    if (error_message(1))
      return (0)
    endif
  endif

  /* everything was successful */
  return (1)

end ;subroutine UpdateRELATED_REAGENT_DETAIL

/**********************************************************
FUNCTION - UpdateEXPECTED_RESULTS(NULL)
    Performs inserts/updates to the expected_result table.
    PARAMS
        None
    RETURN
        1 - Success
        0 - Error occured
***********************************************************/
declare    UpdateEXPECTED_RESULTS() = f8
subroutine UpdateEXPECTED_RESULTS(NULL)

declare i = i4 with protect, noconstant(0)
declare j = i4 with protect, noconstant(0)
declare i1 = i4 with protect, noconstant(0)
declare i2 = i4 with protect, noconstant(0)
declare UpdCntErrorCnt = i2 with protect, noconstant(0)

  /* lock existing expected result rows
     build update record with expected results that require updating
     build archive record rows for expected results that will be updated */
  
  ;generate all the ids that I'll need for this table...
  set nStat = alterlist(new_ids->rows, 0)
  for (i = 1 to value(size(request->related_reagent_list, 5)))
    for (i1 = 1 to value(size(request->related_reagent_list[i]->related_reagent_detail_list, 5)))
      for (i2 = 1 to value(size(request->related_reagent_list[i]->related_reagent_detail_list[i1]->expected_result_list, 5)))
        if (not(request->related_reagent_list[i]->related_reagent_detail_list[i1]->expected_result_list[i2].save_flag = 
              nBB_SAVE_NOUPDATE))
          set j = j + 1
          if (j > size(new_ids->rows, 5))
            set nStat = alterlist(new_ids->rows, j + 10)
          endif
        
          set new_ids->rows[j].id = GetNextSeq(0)
        
        endif
        
      endfor
    endfor
  endfor
  set nStat = alterlist(new_ids->rows, j)
  
  set i =0 
  set j = 0 ;count of where we are in new_id structure...
  
  select into "nl:"
  from
    bb_qc_expected_result_r bbqcer,
    (dummyt d1 with seq = value(size(request->related_reagent_list, 5))),
    (dummyt d2 with seq = 1),
    (dummyt d3 with seq = 1)
    
  plan d1
    where maxrec(d2, size(request->related_reagent_list[d1.seq].related_reagent_detail_list, 5))
  join d2
    where maxrec(d3, size(request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list, 5))
  join d3
    where (request->
     related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].save_flag = nBB_SAVE_UPDATE or
     request->
     related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].save_flag = nBB_SAVE_DELETE)
  join bbqcer
    where bbqcer.expected_result_id =
          request->
          related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].expected_result_id
    
  detail
    i = i + 1
    if (i > size(upd_expected_results->rows, 5))
      nStat = alterlist(upd_expected_results->rows, i + 10)
      nStat = alterlist(ins_expected_results->rows, i + 10)
    endif
    upd_expected_results->rows[i].expected_result_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].expected_result_id
    
    j = j + 1
    ins_expected_results->rows[i].expected_result_id = new_ids->rows[j].id
    
    upd_expected_results->rows[i].related_reagent_detail_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id
    ins_expected_results->rows[i].related_reagent_detail_id = bbqcer.related_reagent_detail_id
   
    upd_expected_results->rows[i].nomenclature_id  =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].nomenclature_id
    ins_expected_results->rows[i].nomenclature_id = bbqcer.nomenclature_id

    upd_expected_results->rows[i].prev_expected_result_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].expected_result_id
    ins_expected_results->rows[i].prev_expected_result_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].expected_result_id
    
    upd_expected_results->rows[i].active_ind =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].active_ind
    ins_expected_results->rows[i].active_ind = bbqcer.active_ind ;MOD
        
    upd_expected_results->rows[i].beg_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    ins_expected_results->rows[i].beg_effective_dt_tm = bbqcer.beg_effective_dt_tm
    ins_expected_results->rows[i].end_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)

	  if (request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].save_flag = 
	                                                                                                       nBB_SAVE_UPDATE)
       upd_expected_results->rows[i].end_effective_dt_tm = cnvtdatetime(nEND_DATE)
    else	;the save flag is set to nBB_SAVE_DELETE!
       upd_expected_results->rows[i].end_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)	;this is the only change
    endif

    if (request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].updt_cnt != 
                                                                                                              bbqcer.updt_cnt)
      nStat = populate_subeventstatus("SELECT", "F", "expected_result",
                                   build("expected result id=",
                                   request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].
                                            expected_result_list[d3.seq].expected_result_id,
                                   " with update count=",
                                   request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].
                                            expected_result_list[d3.seq].updt_cnt,
                                   " has been updated."))
      UpdCntErrorCnt = UpdCntErrorCnt + 1
    endif
  with nocounter,
       forupdate(bbqcer)

  set nStat = alterlist(upd_expected_results->rows, i)
  set nStat = alterlist(ins_expected_results->rows, i)

  if (error_message(1))
    call populate_subeventstatus("SELECT", "F", "expected_result",
                                 "Error locking rows for update.")
    return (0)
  endif

  if (UpdCntErrorCnt > 0)
    call populate_subeventstatus("SELECT", "F", "expected_result",
                                 build(UpdCntErrorCnt, " expected result(s) have been updated."))
    return (0)
  endif

  /* add new rows to insert */
  select into "nl:"
    d.seq
  from
    (dummyt d1 with seq = value(size(request->related_reagent_list, 5))),
    (dummyt d2 with seq = 1),
    (dummyt d3 with seq = 1)
  plan d1
    where maxrec(d2, size(request->related_reagent_list[d1.seq].related_reagent_detail_list, 5))
  join d2
    where maxrec(d3, size(request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list, 5))
  join d3
    where request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].save_flag = 
                              nBB_SAVE_NEW
  head report
    i = size(ins_expected_results->rows, 5)
  detail
    i = i + 1
    if (i > size(ins_expected_results->rows, 5))
      nStat = alterlist(ins_expected_results->rows, i + 10)
    endif
    
    j = j +1
    ins_expected_results->rows[i].expected_result_id = new_ids->rows[j].id
    
    request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].expected_result_id =
        new_ids->rows[j].id
    
    ins_expected_results->rows[i].related_reagent_detail_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].related_reagent_detail_id
    
    ins_expected_results->rows[i].nomenclature_id =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].nomenclature_id
    
    ins_expected_results->rows[i].prev_expected_result_id =
        ins_expected_results->rows[i].expected_result_id
    
    
    ins_expected_results->rows[i].active_ind =
        request->related_reagent_list[d1.seq].related_reagent_detail_list[d2.seq].expected_result_list[d3.seq].active_ind
         
    ins_expected_results->rows[i].beg_effective_dt_tm = cnvtdatetime(nSCRIPT_DATE)
    ins_expected_results->rows[i].end_effective_dt_tm = cnvtdatetime(nEND_DATE)
  with nocounter

  set nStat = alterlist(ins_expected_results->rows, i)

  /* update existing rows */
  if (size(upd_expected_results->rows, 5) > 0)

    /* perform update */
    update into
      bb_qc_expected_result_r bbqcer,
      (dummyt d with seq = value(size(upd_expected_results->rows, 5)))
    set
      bbqcer.related_reagent_detail_id = upd_expected_results->rows[d.seq].related_reagent_detail_id,
      bbqcer.nomenclature_id = upd_expected_results->rows[d.seq].nomenclature_id,
      bbqcer.prev_expected_result_id = upd_expected_results->rows[d.seq].prev_expected_result_id,
      bbqcer.active_ind = upd_expected_results->rows[d.seq].active_ind,    
      bbqcer.beg_effective_dt_tm = cnvtdatetime(upd_expected_results->rows[d.seq].beg_effective_dt_tm),
      bbqcer.end_effective_dt_tm = cnvtdatetime(upd_expected_results->rows[d.seq].end_effective_dt_tm),
      bbqcer.updt_applctx = reqinfo->updt_applctx,
      bbqcer.updt_cnt = bbqcer.updt_cnt + 1,
      bbqcer.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcer.updt_id = reqinfo->updt_id,
      bbqcer.updt_task = reqinfo->updt_task
    plan d
    join bbqcer
      where bbqcer.expected_result_id = upd_expected_results->rows[d.seq].expected_result_id
    with nocounter

    if (error_message(1))
      return (0)
    endif
  endif

  /* insert new rows */
  if (size(ins_expected_results->rows, 5) > 0)
    insert into
      bb_qc_expected_result_r bbqcer,
      (dummyt d with seq = value(size(ins_expected_results->rows, 5)))
    set
      bbqcer.expected_result_id = ins_expected_results->rows[d.seq].expected_result_id,
      bbqcer.related_reagent_detail_id = ins_expected_results->rows[d.seq].related_reagent_detail_id,
      bbqcer.nomenclature_id = ins_expected_results->rows[d.seq].nomenclature_id,
      bbqcer.prev_expected_result_id = ins_expected_results->rows[d.seq].prev_expected_result_id,
      bbqcer.active_ind = ins_expected_results->rows[d.seq].active_ind,
      bbqcer.beg_effective_dt_tm = cnvtdatetime(ins_expected_results->rows[d.seq].beg_effective_dt_tm),
      bbqcer.end_effective_dt_tm = cnvtdatetime(ins_expected_results->rows[d.seq].end_effective_dt_tm),
      bbqcer.updt_applctx = reqinfo->updt_applctx,
      bbqcer.updt_cnt = 0,
      bbqcer.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      bbqcer.updt_id = reqinfo->updt_id,
      bbqcer.updt_task = reqinfo->updt_task
    plan d
    join bbqcer
    with nocounter

    if (error_message(1))
      return (0)
    endif
  endif

  /* everything was successful */
  return (1)

end ;subroutine UpdateEXPECTED_RESULTS

/**********************************************************
FUNCTION - GetNextSeq(NULL)
    Generate the next valid sequence number from the PathNet sequence bucket.
    PARAMS
        None
    RETURN
        > 0   - Valid sequence
        0     - Error occured
***********************************************************/
declare    GetNextSeq() = f8
subroutine GetNextSeq(NULL)
 
  declare dNextSeq = f8 with protect, noconstant(0.0)
 
  select into "nl:"
    temp_seq = seq(pathnet_seq, nextval)
  from dual
  detail
    dNextSeq = temp_seq
  with nocounter
 
  return(dNextSeq)
 
end /* subroutine GetNextSeq */

/**********************************************************
FUNCTION - TransferNewIds(NULL)
    Transfer the newly generated ids back via the reply structure
    PARAMS
        None
    RETURN
        1 - success
        0 - error
***********************************************************/
declare    TransferNewIds() = f8
subroutine TransferNewIds(NULL)
 
  declare i = i4 with protect, noconstant(0)
  declare j = i4 with protect, noconstant(0)
  declare k = i4 with protect, noconstant(0)
  declare nStat = i2 with protect, noconstant(0)
 
  set nStat = alterlist(reply->related_reagent_list, size(request->related_reagent_list, 5))
  for (i = 1 to size(request->related_reagent_list, 5))
    
    set reply->related_reagent_list[i].id = 
            request->related_reagent_list[i].related_reagent_id
    
    set nStat = alterlist(reply->related_reagent_list[i]->related_reagent_detail_list, size(request->related_reagent_list
                [i].related_reagent_detail_list, 5))
    for (j = 1 to size(request->related_reagent_list[i].related_reagent_detail_list, 5))
      
      set reply->related_reagent_list[i]->related_reagent_detail_list[j].id = 
            request->related_reagent_list[i]->related_reagent_detail_list[j].related_reagent_detail_id
        
      set nStat = alterlist(reply->related_reagent_list[i]->related_reagent_detail_list[j]->expected_result_list, 
                size(request->related_reagent_list[i].related_reagent_detail_list[j].expected_result_list, 5))
      for (k = 1 to size(request->related_reagent_list[i]->related_reagent_detail_list[j]->expected_result_list, 5))
        
        set reply->related_reagent_list[i]->related_reagent_detail_list[j]->expected_result_list[k].id = 
            request->related_reagent_list[i]->related_reagent_detail_list[j]->expected_result_list[k].expected_result_id
        
      endfor
    endfor
  endfor
 
  if (error_message(1))
    return (0)
  else
    return (1)
  endif
 
end /* subroutine TransferNewIds */

/**********************************************************/

#exit_script

free record ins_related_reagents
free record upd_related_reagents
free record ins_related_reagent_detail
free record upd_related_reagent_detail
free record ins_expected_results
free record upd_expected_results
free record new_ids

end
go

;Generated by GNU enscript 1.6.4.
