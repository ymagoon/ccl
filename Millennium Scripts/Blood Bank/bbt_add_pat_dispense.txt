 ;;Solution_Test/script/PathNet -- BB Transfusion/Dispenseassign/bbt_add_pat_dispense.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-2006 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/

/*****************************************************************************

        Author:                 Teresa Davis
        Date Written:           07/01/96

        Source file name:       bbt_add_patient_dispense.prg
        Object name:            bbt_add_pat_dispense
        Request #:              225032

        Product:                Transfusion
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Adds dispense product_event and creates
                                product_dispense record

        Tables read:
        Tables updated:         product_event, patient_disense
        Executing from:         DispenseAssign.exe

        Special Notes:          <none>

******************************************************************************/
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer     Comment                                     *
;    *--- -------- ------------ -----------------------------------         *
;    *001 10/09/98 DS3161       Added fields passed for add_bb_exception    *
;    *002 11/16/98 SN4200       Performance changes.                        *
;    *003 12/11/98 DS3161       Added ability to release InProgress events  *
;    *004 09/22/99 JS4269       Added checking for demographic              *
;    *                          changes during the conversation             *
;    *                          added bbt_chk_pat_demog.inc                 *
;    *005 12/07/99 DS3161       Updated UAR calls to use 12 character long  *
;    *                          cdf_meaning's.                              *
;    *006 11/21/01 JR3725       Enhanced to conform to CCL standards        *
;    *007 11/29/01 JR3725       Removed unused code which was designed to   *
;    *                          quarantine a product based on visual insp.  *
;    *008 07/15/02 CERCPH       Populate reply correctly.  Change alter to  *
;    *                          alterlist.
;    *009 12/30/03 jg7520       39495: Expand SELECT with forupdate to      *
;                                      be a series of single table selects. *  
;    *010 02/01/06 JO7236       Inactivate crossmatch row when releasing.   * 
;    *011 10/27/06 TB012990     Added new param to add_bb_exception         *
;	 *012 02/21/11 AG017309		Add Trigger for Reserve Stock Interface Msg *
;    *013 11/04/13 FA026852     Recorded the date/time on which dispense    *
;    *                          product events are back dated for           *
;    *                          traceability.                               *
;    *014 01/27/14 FA026852     Added support for associating product       *
;    *                          dispenses with product orders.              *
;~DE~************************************************************************

;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************
drop program bbt_add_pat_dispense:dba go
create program bbt_add_pat_dispense:dba

/*********************************************************************
*  Used to dispense a product or a batch of products to a patient
*********************************************************************/

/*
record request
(
  1 order_id                = f8
  1 person_id               = f8
  1 encntr_id               = f8
  1 unknown_patient_text    = vc
  1 unknown_patient_ind     = i2
  1 dispense_prov_id        = f8
  1 dispense_reason_cd      = f8
  1 dispense_to_locn_cd     = f8
  1 dispense_vis_insp_cd    = f8
  1 dispense_cooler_id      = f8
  1 dispense_cooler_text    = c40
  1 bb_id_nbr               = c20
  1 device_id               = f8
  1 courier_id              = f8
  1 courier_text            = vc
  1 dispense_dt_tm          = di8
  1 quar_reason_cd          = f8
  1 bb_comment_id           = f8
  1 bb_comment_updt_cnt     = i4
  1 abo_cd                  = f8
  1 rh_cd                   = f8
  1 transreqlist[*]
    2 requirement_cd        = f8
  1 antibodylist[*]
    2 antibody_cd           = f8
  1 productlist [*]
    2 product_id            = f8
    2 add_assign_ind        = i2
    2 dispense_from_locn_cd = f8
    2 dispense_intl_units   = i4
    2 dispense_qty          = i4
    2 updt_cnt              = i4
    2 ModAssignEventId      = f8
    2 ModAssignUpdtCnt      = i4
    2 dEr_Updt_Cnt          = i4
    2 event_cnt             = i4
    2 eventlist[*]
      3 event_id            = f8
      3 reason_cd           = f8
      3 updt_cnt            = i4
      3 pe_updt_cnt         = i4
      3 xm_ind              = i2
      3 assign_ind          = i2
      3 inprog_ind          = i2
    2 exceptlist[*]
      3 EXCEPTION_TYPE_mean = c20
      3 override_reason_cd  = f8
      3 result_id           = f8
      3 from_abo_cd         = f8
      3 from_rh_cd          = f8
      3 to_abo_cd           = f8
      3 to_rh_cd            = f8
      3 req_cnt             = f8
      3 autodir_req_cnt     = f8
      3 reqslist[*]
        4 special_testing_cd= f8
        4 requirement_cd    = f8
      3 autodir_reqslist[*]
        4 product_id        = f8
      3 order_id            = f8
    2 order_id              = f8
    2 dispense_prov_id      = f8
  1 backdated_ind           = i2
)
*/

record reply
(
  1 productlist[*]
    2 product_id                	= f8
    2 product_event_id          	= f8
    2 assign_event_id           	= f8
    2 status_flag               	= c1
    2 updt_cnt                  	= i4
    2 interface_status_flag			= i2
  1 bb_comment_changed           = c1
  1 pat_aborh_changed            = c1
  1 trans_req_changed            = c1
  1 antibodies_changed           = c1
%i cclsource:status_block.inc
)

record outbound_products
(
	1 product_cnt			= i4
	1 message_name			= vc
	1 products[*]
		2 product_id		= f8
		2 device_id			= f8
		2 person_id			= f8
)

; Declare variables
declare nbr_to_add 			= i4 with noconstant(size(request->productlist,5))
declare code_cnt				= i4 with noconstant(0)
declare x						= i4 with noconstant(0)
declare y						= i4 with noconstant(0)
declare count1 				= i4 with noconstant(0)
declare count2 				= i4 with noconstant(0)
declare count3 				= i4 with noconstant(0)
declare cntr	 				= i4 with noconstant(0)
declare reqs_cntr				= i4 with noconstant(0)
declare cntrnbr_of_excepts	= i4 with noconstant(0)
declare autodir_reqs_cntr	= i4 with noconstant(0)
declare nbr_of_reqs			= i4 with noconstant(0)
declare nbr_of_autodir_reqs= i4 with noconstant(0)
declare event_id 				= f8 with noconstant(0.0)
declare product_event_id 	= f8 with noconstant(0.0)
declare new_product_event_id = f8 with noconstant(0.0)
declare dispense_type_cd	= f8 with noconstant(0.0)
declare transfer_type_cd	= f8 with noconstant(0.0)
declare avail_type_cd		= f8 with noconstant(0.0)
declare xm_type_cd			= f8 with noconstant(0.0)
declare assign_type_cd		= f8 with noconstant(0.0)
declare quarantine_type_cd	= f8 with noconstant(0.0)
declare release_status		= c1 with noconstant(fillstring(1," "))
declare assign_status		= c1 with noconstant(fillstring(1," "))
declare exception_status	= c1 with noconstant(fillstring(1," "))
declare unlock_status		= c1 with noconstant(fillstring(1," "))
declare assign_event_id		= f8 with noconstant(0.0)
declare related_event_id	= f8 with noconstant(0.0)
declare bb_exception_id		= f8 with noconstant(0.0)
declare Inactive_Avail		= i2 with noconstant(0)
declare override_ind			= i2 with noconstant(0)
declare nextrow 				= i4 with noconstant(1)
declare cur_qty 				= i4 with noconstant(0)
declare cur_ius 				= i4 with noconstant(0)
declare STATES_CODE_SET		= i4 with constant(1610)
declare cdf_meaning			= c12 with noconstant(fillstring(12," "))
declare stat					= i2 with noconstant(0)
declare interface_status_flag    = i2 with noconstant(0)
declare interfaced_device_ind	 = i2 with noconstant(0)
declare valid_aborh_ind		 = i2 with noconstant(0)
declare transfer_allocated_reason_cd = f8 with noconstant(0.0)
declare disp_prov_id      = f8 with noconstant(0.0)
declare order_id          = f8 with noconstant(0.0)
declare ModifyAssignQty_ind = i2 with noconstant(0)
 
; Declare subroutines
declare UpdateAvailableQty	(dUpd_prod_id = f8,
									 dEr_Updt_Cnt = i4,
								 	 lQty = i4,
								 	 lIUs = i4) = NULL

declare ModifyAssignQty		(dchgprod_id = f8,
									 dchgevent_id = f8,
								 	 lchgupdt_cnt = i4,
								 	 qty = i4,
								 	 ius = i4) = NULL

declare ReleaseAssign		(drelprod_id = f8,
									 drelevent_id = f8,
									 drelreason_cd = f8,
									 lrelupdt_cnt = i4,
									 lrelpe_updt_cnt = i4,
									 qty             =i4,
									 ius  =i4)  = NULL
declare Insert_AssignRelease_event (drelprod_id = f8,
									 drelevent_id = f8,
									 drelreason_cd = f8)   = NULL
 
declare ReleaseCrossmatch	(dproduct_id = f8,
									 devent_id = f8,
									 dreason_cd = f8,
									 lupdt_cnt = i4,
									 lpe_updt_cnt = i4) = NULL

declare ReleaseInProgress	(dproduct_id = f8,
									 devent_id = f8,
									 dreason_cd = f8,
									 lupdt_cnt = i4,
									 lpe_updt_cnt = i4) = NULL

declare CHG_PRODUCT_EVENT	(dummyx = i2) = NULL

declare Lock_product			(sub_product_id = f8) = NULL

declare UnLock_product		(sub_product_id = f8,
									 dispense_to_locn_cd = f8,
									 sub_updt_id = f8,
									 sub_updt_task = i4,
									 sub_updt_applctx = i4) = NULL

declare Update_Status_Data_Err(message = vc) = NULL
declare Update_Status_Data_Success(updt_product_id = f8,
											  updt_product_event_id = f8,
											  updt_assign_event_id = f8,
											  interface_status_flag = i2) = NULL
											  
declare GetInterfaceFlag(dDeviceId = f8) = i2 
declare GetProductTypeBarcode(dProductId = f8) = vc 
declare SendReserveStockMessage(NULL) = NULL
declare ADD_PRODUCT_TO_OUTBOUND(dProductId = f8,
								dPersonId = f8,
								dDeviceId = f8) = NULL
declare ADD_DEVICE_TRANSFER(dProductEventId = f8,
							dProductId = f8,
							dDeviceId = f8 ) = NULL
declare SetTransferAllocatedReasonCd(NULL) = NULL
declare IsDerivative(dProductId = f8) = i2

; Initialize indicators
set reply->status_data->status = "I"
set reply->bb_comment_changed = "F"
set reply->pat_aborh_changed = "F"
set reply->trans_req_changed = "F"
set reply->antibodies_changed = "F"

;perform demographic checking if dispense a patient, not for emergency dispense
if (request->unknown_patient_ind = 0)

%i cclsource:bbt_chk_pat_demog.inc

	call CHECK_PATIENT_DEMOGRAPHICS(0)
	;The variables are set to "E" if the script in the CHECK_PATIENT_DEMOGRAPHICS failed
	if (sub_bb_comment_changed = "E")
		call Update_Status_Data_Err(sub_bb_comment_changed_error)
		set reply->bb_comment_changed = "T"
		go to exit_program
	endif

	if (sub_pat_aborh_changed = "E")
		call Update_Status_Data_Err(sub_pat_aborh_changed_error)
		set reply->pat_aborh_changed = "T"
		go to exit_program
	endif

	if (sub_trans_req_changed = "E")
		call Update_Status_Data_Err(sub_trans_req_changed_error)
		set reply->trans_req_changed = "T"
		go to exit_program
	endif

	if (sub_antibodies_changed = "E")
		call Update_Status_Data_Err(sub_antibodies_changed_error)
		set reply->antibodies_changed = "T"
		go to exit_program
	endif

	if (sub_bb_comment_changed = "T")
		set reply->bb_comment_changed = "T"
		set reply->status_data->status = "Z"
		go to exit_program
	endif

	if (sub_pat_aborh_changed = "T")
		set reply->pat_aborh_changed = "T"
		set reply->status_data->status = "Z"
		go to exit_program
	endif

	if (sub_trans_req_changed = "T")
		set reply->trans_req_changed = "T"
		set reply->status_data->status = "Z"
		go to exit_program
	endif

	if (sub_antibodies_changed = "T")
		set reply->antibodies_changed = "T"
		set reply->status_data->status = "Z"
		go to exit_program
	endif
endif


; Retrieve the code value for DISPENSED from code_set 1610
set code_cnt = 1
set cdf_meaning = "4"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, dispense_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for dispensed, code set 1610."
	  )
	go to exit_program
endif

set ev_dt_tm = cnvtdatetime(request->dispense_dt_tm)

; Retrieve the code value for AVAILABLE from code_set 1610
set code_cnt = 1
set cdf_meaning = "12"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, avail_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for available, code set 1610."
     )
	go to exit_program
endif

; Retrieve the code value for CROSSMATCHED from code_set 1610
set code_cnt = 1
set cdf_meaning = "3"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, xm_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for crossmatched, code set 1610."
     )
	go to exit_program
endif

; Retrieve the code value for ASSIGNED from code_set 1610
set code_cnt = 1
set cdf_meaning = "1"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, assign_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for assigned, code set 1610."
     )
	go to exit_program
endif

; Retrieve the code value for QUARANTINED from code_set 1610
set code_cnt = 1
set cdf_meaning = "2"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, quarantine_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for quarantined, code set 1610."
     )
	go to exit_program
endif

; Retrieve the code value for TRANSFERRED from code_set 1610
set code_cnt = 1
set cdf_meaning = "6"
set stat = uar_get_meaning_by_codeset(STATES_CODE_SET, cdf_meaning, code_cnt, transfer_type_cd)
if (stat != 0)
	call Update_Status_Data_Err
	  ( "Unable to obtain code value for transferred, code set 1610."
	  )
	go to exit_program
endif

Call SetTransferAllocatedReasonCd(null)

;Basic Checking to see if device is an interface device
if(request->unknown_patient_ind = 0)
	set interfaced_device_ind = GetInterfaceFlag(request->device_id)
	;Check that the patient has a valid ABORH
	if(request->abo_cd > 0 AND request->rh_cd > 0)
		set valid_aborh_ind = 1
	endif
endif


#start_loop
for (x = nextrow to nbr_to_add)
	/***************************************
	*        Lock Product                 *
	**************************************/
	set lock_status = "I"
	Call Lock_Product
	  ( request->productlist[x]->product_id
	  )

	if (lock_status = "F")
		go to next_row
	endif
    set ModifyAssignQty_ind =0
    if(request->productlist[x]->order_id > 0)
        set order_id = request->productlist[x]->order_id
    elseif(request->order_id > 0)
        set order_id = request->order_id
    else
        set order_id = 0.0
    endif
    
    if(request->productlist[x]->dispense_prov_id > 0)
        set disp_prov_id = request->productlist[x]->dispense_prov_id
    elseif(request->dispense_prov_id > 0)
        set disp_prov_id = request->dispense_prov_id
    else
        set disp_prov_id = 0.0
    endif


	if (request->quar_reason_cd > 0)
	
		; Code was removed here that attempted to quarantine the product
		; before dispensing it.  But, Dispense/Assign does not allow the
		; user to dispense a product when the selected visual inspection
		; from the save dialog requires a quarantine.  If the script ever
		; enters this "IF" statement, a warning message will display.
		call Update_Status_Data_Err
		  ( "The quarantine reason code value was greater than zero.  Please investigate."
		  )
		go to next_row

	endif

	/************************************************
	*     Determine if product should be assigned  *
	************************************************/
	set assign_event_id = 0.0
	if (request->productlist[x].add_assign_ind = 1)
		/***************************************
		*        Assign Product               *
		**************************************/
		set assign_status = "I"

		call Add_Assign
		  ( /* product_id             */
			 request->productlist[x].product_id,
			 /* person_id              */
			 request->person_id,
			 /* encntr_id              */
			 request->encntr_id,
			 /* assign_reason_cd       */
			 request->dispense_reason_cd,
			 /* prov_id                */
			 disp_prov_id,
			 /* qty_assigned           */
			 request->productlist[x].dispense_qty,
			 /* INTL_UNITS             */
			 request->productlist[x].dispense_intl_units,
			 /* updt_id                */
			 reqinfo->updt_id,
			 /* updt_task              */
			 reqinfo->updt_task,
			 /* updt_applctx           */
			 reqinfo->updt_applctx,
			 /* active_status_cd       */
			 reqdata->active_status_cd,
			 /* active_status_prsnl_id */
			 reqinfo->updt_id,
			 /* assign date time       */
			 ev_dt_tm
		  )

		if (assign_status != "S")
			call Update_Status_Data_Err
			  ( "Unable to add assign."
			  )
			go to next_row
		endif
	endif

	if (request->productlist[x]->related_event_id = 0)
		set related_event_id = assign_event_id
	else
		set related_event_id = request->productlist[x]->related_event_id
	endif

	set Inactive_Avail = 1
	if (request->productlist[x].dispense_qty > 0)
		set release_status = "I"
		if (request->productlist[x].ModAssignEventId > 0)
			call ModifyAssignQty
			  ( request->productlist[x].product_id,
				 request->productlist[x].ModAssignEventId,
				 request->productlist[x].ModAssignUpdtCnt,
				 request->productlist[x].dispense_qty,
				 request->productlist[x].dispense_intl_units
			  )
		else
			call UpdateAvailableQty
			  ( request->productlist[x].product_id,
				 request->productlist[x].dEr_Updt_Cnt,
				 request->productlist[x].dispense_qty,
				 request->productlist[x].dispense_intl_units
			  )
		endif

		if (release_status != "S")
			call Update_Status_Data_Err
			  ( "Unable to update quantity."
			  )
			go to next_row
		endif
	endif

	if (Inactive_Avail = 1)
		/***************************************
		*        Inactivate Available         *
		**************************************/

		; Lock the PRODUCT_EVENT table for update
		select into "nl:"
			p.seq
		from
			product_event p
		where p.product_id = request->productlist[x]->product_id
		  and p.event_type_cd = avail_type_cd
		  and p.active_ind = 1
		with nocounter, forupdate(p)

		if (curqual = 0)
			Call Update_Status_Data_Err
			  ( "Unable to lock product_event table for updating."
			  )
		endif

		; Update the PRODUCT_EVENT table
		update into product_event p
		set p.active_ind 				  = 0,
			 p.updt_cnt               = p.updt_cnt + 1,
			 p.updt_dt_tm             = cnvtdatetime(curdate,curtime3),
			 p.updt_id                = reqinfo->updt_id,
			 p.updt_task              = reqinfo->updt_task,
			 p.updt_applctx           = reqinfo->updt_applctx

		where p.product_id = request->productlist[x]->product_id
		  and p.event_type_cd = avail_type_cd
		  and p.active_ind = 1
		with nocounter

		if (curqual = 0)
			Call Update_Status_Data_Err
			  ( "Unable to inactivate the available product event."
			  )
		endif
	endif

	/***************************************
	*        Release Crossmatch           *
	**************************************/
	set y = 0
	for (y = 1 to request->productlist[x].event_cnt)
		set release_status = "I"
		if (request->productlist[x].eventlist[y].xm_ind = 1)
			call ReleaseCrossmatch
			  ( request->productlist[x].product_id,
				 request->productlist[x].eventlist[y].event_id,
				 request->productlist[x].eventlist[y].reason_cd,
				 request->productlist[x].eventlist[y].updt_cnt,
				 request->productlist[x].eventlist[y].pe_updt_cnt
			  )
		elseif (request->productlist[x].eventlist[y].assign_ind = 1)
			call ReleaseAssign
			  ( request->productlist[x].product_id,
				 request->productlist[x].eventlist[y].event_id,
				 request->productlist[x].eventlist[y].reason_cd,
				 request->productlist[x].eventlist[y].updt_cnt,
				 request->productlist[x].eventlist[y].pe_updt_cnt,
				 request->productlist[x].dispense_qty,
				 request->productlist[x].dispense_intl_units
			  )
		elseif (request->productlist[x].eventlist[y].inprog_ind = 1)
			call ReleaseInProgress
			  ( request->productlist[x].product_id,
				 request->productlist[x].eventlist[y].event_id,
				 request->productlist[x].eventlist[y].reason_cd,
				 request->productlist[x].eventlist[y].updt_cnt,
				 request->productlist[x].eventlist[y].pe_updt_cnt
			  )
		else
			set release_status = "F"
		endif

		if (release_status = "F")
			call Update_Status_Data_Err
			  ( "Unable to add a product event."
			  )
			go to next_row
		endif
	endfor

	/***************************************
	*        Add Product Event            *
	**************************************/
	if (request->productlist[x].except_cnt > 0)
		set override_ind = 1
	else
		set override_ind = 0
	endif

	call ADD_PRODUCT_EVENT
	  ( /*1 product_id                                           */
		 request->productlist[x]->product_id,
		 /*2 person_id                             */
		 request->person_id,
		 /*3 encntr_id                                            */
		 request->encntr_id,
		 /*4 order_id                                             */
		 order_id,
		 /*5 bb_result_id                                         */
		 0,
		 /*6 event_type_cd                                        */
		 dispense_type_cd,
		 /*7 event_dt_tm                                          */
		 ev_dt_tm,    ;  cnvtdatetime(curdate, curtime3),
		 /*8 event_prsnl_id                                       */
		 ReqInfo->updt_id,
		 /*9 event_status_flag                                    */
		 0,
		 /*10 override_ind                                     */
		 override_ind,
		 /*11 override_reason_cd                                */
		 0,
		 /*12 related_product_event_id                         */
		 related_event_id,
		 /*12 active_ind                                           */
		 1,
		 /*11 active_status_cd                                     */
		 reqdata->active_status_cd,
		 /*12 active_status_dt_tm                                 */
		 cnvtdatetime(curdate, curtime3),
		 /*13 active_status_prsnl_id                              */
		 ReqInfo->updt_id
	  )

	if (curqual = 0)
		call Update_Status_Data_Err
 		  ( "Unable to add a dispense product event."
	  	  )
		go to next_row
	endif
	
	set new_product_event_id = product_event_id

	/***************************************
	*        Dispense Product             *
	**************************************/
	insert into patient_dispense d
	set
	/* update key fields */
		d.product_event_id            = new_product_event_id,
		d.person_id                   = request->person_id,
		d.bb_id_nbr                   = request->bb_id_nbr,
 		d.unknown_patient_ind         = request->unknown_patient_ind,
		d.unknown_patient_text        = request->unknown_patient_text,
		d.dispense_prov_id            = disp_prov_id,
		d.dispense_reason_cd          = request->dispense_reason_cd,
		d.dispense_to_locn_cd         = request->dispense_to_locn_cd,
		d.dispense_vis_insp_cd        = request->dispense_vis_insp_cd,
		d.dispense_cooler_id          = request->dispense_cooler_id,
		d.dispense_cooler_text        = request->dispense_cooler_text,
		d.dispense_courier_id         = request->courier_id,
		d.dispense_courier_text       = request->courier_text,
		d.device_id                   = request->device_id,
		/******************************************
		*  d.dispense_status_flag
		*     values    1 = dispense
		*               2 = transfuse
		*               3 = return
		******************************************/
		d.dispense_status_flag        = 1,
		d.product_id						= request->productlist[x]->product_id,
		d.dispense_from_locn_cd 		= request->productlist[x]->dispense_from_locn_cd,
		d.orig_dispense_qty				= request->productlist[x]->dispense_qty,
		d.cur_dispense_qty 				= request->productlist[x]->dispense_qty,
		d.cur_dispense_intl_units		= request->productlist[x]->dispense_intl_units,
		d.orig_dispense_intl_units		= request->productlist[x]->dispense_intl_units,
		/* update common fields */
		d.updt_cnt                    = 0,
		d.updt_dt_tm                  = cnvtdatetime(curdate,curtime3),
		d.updt_id                     = reqinfo->updt_id,
		d.updt_task                   = reqinfo->updt_task,
		d.updt_applctx                = reqinfo->updt_applctx,
		d.active_ind                  = 1,
		d.active_status_cd            = reqdata->active_status_cd,
		d.active_status_dt_tm         = cnvtdatetime(curdate,curtime3),
		d.active_status_prsnl_id      = reqinfo->updt_id,
        d.backdated_on_dt_tm          = if(request->backdated_ind = 1)
                                            cnvtdatetime(curdate, curtime3)
                                        else
                                            NULL
                                        endif
	with counter

	if (curqual = 0)
		call Update_Status_Data_Err
		  ( "Unable to add patient dispense."
		  )
		go to next_row
	endif

	set nbr_of_excepts = request->productlist[x].except_cnt
	set cntr = 0
	for (cntr = 1 to nbr_of_excepts)
		set exception_status = "I"
		set bb_exception_id = 0.0
		Call Add_bb_Exception
		  ( 0.0, ;001
			 0.0, ;001
			 0.0, ;001
			 cnvtdatetime(""), ;001
			 product_event_id,
			 request->productlist[x].exceptlist[cntr].EXCEPTION_TYPE_MEAN,
			 request->productlist[x].exceptlist[cntr].override_reason_cd,
			 dispense_type_cd,
			 request->productlist[x].exceptlist[cntr].result_id,
			 0, ;perform_result_id is not used by dispense
			 request->productlist[x].exceptlist[cntr].from_abo_cd,
			 request->productlist[x].exceptlist[cntr].from_rh_cd,
			 request->productlist[x].exceptlist[cntr].to_abo_cd,
			 request->productlist[x].exceptlist[cntr].to_rh_cd,
			 0.0
		  )
		if (exception_status != "S")
			call Update_Status_Data_Err
			  ( "Unable to add exception."
			  )
			go to next_row
		endif
        
        if(trim(request->productlist[x].exceptlist[cntr].EXCEPTION_TYPE_MEAN) = "NOVLDPRODORD")
               ;record info for dispensed without valid product order exceptions.
        	  call Add_Invd_Prod_Ord_Exception(request->productlist[x].exceptlist[cntr].order_id)
        	  if (exception_status != "S")
        			call Update_Status_Data_Err
        			  ( "Unable to add bb_invd_prod_order_exception."
        			  )
        			go to next_row
        	  endif
    	endif
    	
		set reqs_cntr = 0
		set nbr_of_reqs = request->productlist[x]->exceptlist[cntr].req_cnt

		for (reqs_cntr = 1 to nbr_of_reqs)
			set exception_status = "I"
			Call Add_Reqs_Exception
			  (
				 request->productlist[x].exceptlist[cntr].reqslist[reqs_cntr].special_testing_cd,
				 request->productlist[x].exceptlist[cntr].reqslist[reqs_cntr].requirement_cd
			  )
			if (exception_status != "S")
				call Update_Status_Data_Err
	 			  ( "Unable to add bb_reqs_exception."
	  			  )
				go to next_row
			endif
		endfor

		set autodir_reqs_cntr = 0
		set nbr_of_autodir_reqs = request->productlist[x]->exceptlist[cntr].autodir_req_cnt

		for (autodir_reqs_cntr = 1 to nbr_of_autodir_reqs)
			set exception_status = "I"
			Call Add_Autodir_Reqs_Exception
			  ( request->productlist[x].exceptlist[cntr].autodir_reqslist[autodir_reqs_cntr].product_id
			  )
			if (exception_status != "S")
				call Update_Status_Data_Err
				  ( "Unable to add bb_autodir_exception."
				  )
				go to next_row
			endif
		endfor
	endfor

	/****************************************
	* check to see if an interface message  *
	* needs to be sent.						*
	****************************************/
	set interface_status_flag = 0
	;Check if device is an interface device
	if(interfaced_device_ind > 0)
		;Exclude Derivatives
		if(IsDerivative(request->productlist[x]->product_id) = 0)
			;Check that the patient has a valid ABORH
			if(valid_aborh_ind > 0)
				;Check that the Product has a Product Type Barcode
				if(size(GetProductTypeBarcode(request->productlist[x]->product_id), 1) > 0)
					;Send a Reserve Stock Message
					set interface_status_flag = 1
				else
					;Product Doesn't have a Product Type Barcode Log An Error
					set interface_status_flag = -2
				endif
			else
				;Patient doesn't have a valid ABORH log an error
				set interface_status_flag = -1
			endif
		endif
	endif

	if(interface_status_flag = 1)
		Call ADD_PRODUCT_TO_OUTBOUND(request->productlist[x]->product_id, request->person_id, request->device_id)
	endif

	/***************************************
	*        Unlock Product               *
	**************************************/
	set unlock_status = "I"
	Call Unlock_Product
	  ( request->productlist[x].product_id,
		 request->dispense_to_locn_cd,
		 reqinfo->updt_id,
		 reqinfo->updt_task,
		 reqinfo->updt_applctx
	  )

	if (unlock_status = "S")
		Call Update_Status_Data_Success
		  ( request->productlist[x].product_id,
			 product_event_id,
			 assign_event_id,
			 interface_status_flag
		  )
	else
		go to next_row
	endif
endfor

if(outbound_products->product_cnt > 0)
	Call SendReserveStockMessage(null)

endif
go to exit_program


#next_row
set nextrow = nextrow + 1
go to start_loop


/***************************************************************
 *              Subroutines
 **************************************************************/
subroutine IsDerivative(dProductId)
	declare nIsDerivative = i2 with noconstant(0)
	select
		d.product_id
	from 
		derivative d
	where d.product_id = dProductId

	if (curqual > 0)
		set nIsDerivative = 1
	endif
	
	return(nIsDerivative)
end ;Is Derivative 
subroutine ADD_PRODUCT_TO_OUTBOUND(dProductId, dPersonId, dDeviceId)
	declare pcnt = i4 with noconstant(0)
	declare transfer_product_event_id = f8 with noconstant(0.0)
	
	;Add A Transfer Event
	call ADD_PRODUCT_EVENT
	  ( /*1 product_id                                           */
		 dProductId,
		 /*2 person_id                             */
		 NULL,
		 /*3 encntr_id                                            */
		 NULL,
		 /*4 order_id                                             */
		 NULL,
		 /*5 bb_result_id                                         */
		 0,
		 /*6 event_type_cd                                        */
		 transfer_type_cd,
		 /*7 event_dt_tm                                          */
		 cnvtdatetime(curdate, curtime3),  
		 /*8 event_prsnl_id                                       */
		 ReqInfo->updt_id,
		 /*9 event_status_flag                                    */
		 0,
		 /*10 override_ind                                     */
		 0,
		 /*11 override_reason_cd                                */
		 0,
		 /*12 related_product_event_id                         */
		 0,
		 /*12 active_ind                                           */
		 0,
		 /*11 inactive_status_cd                                     */
		 reqdata->inactive_status_cd,
		 /*12 active_status_dt_tm                                 */
		 cnvtdatetime(curdate, curtime3),
		 /*13 active_status_prsnl_id                              */
		 ReqInfo->updt_id
	  )
	 if (curqual = 0)
		call Update_Status_Data_Err
 		  ( "Unable to add a Transfer Event."
	  	  )
	endif
	
	set transfer_product_event_id = product_event_id
	call ADD_DEVICE_TRANSFER(transfer_product_event_id, dProductId, dDeviceId)
	 
	if (curqual = 0)
		call Update_Status_Data_Err
 		  ( "Unable to add a Device Transfer Row."
	  	  )
	endif
	  set pcnt = outbound_products->product_cnt + 1
	 
	      if (pcnt > size(outbound_products->products, 5))
	         set stat = alterlist(outbound_products->products, pcnt + 5)
	      endif
	
	  set  outbound_products->product_cnt = pcnt
	  
	  set outbound_products->products[pcnt].device_id = dDeviceId
	  set outbound_products->products[pcnt].product_id = dProductId
	  set outbound_products->products[pcnt].person_id = dPersonId


end ;ADD_PRODUCT_TO_OUTBOUND

subroutine SendReserveStockMessage(NULL)
	
	Set outbound_products->message_name = "RS"
	set stat = alterlist(outbound_products->products, outbound_products->product_cnt)
call echorecord(outbound_products)
	execute bbt_send_products_outbound with replace("REQUEST", "OUTBOUND_PRODUCTS"),
											replace("REPLY", "RS_REPLY")

end ;SendReserveStockMessage

subroutine SetTransferAllocatedReasonCd(NULL)
	/* Find a Code Value with a transfer reason
	with the meaning of Transfer Allocated */
	select 
		cv.code_value
	from 
		code_value cv
	where cv.code_set = 1617
		and cv.cdf_meaning = "TRNSFRALLO"
	Order by cv.code_value asc
	detail
		transfer_allocated_reason_cd = cv.code_value
	with nocounter
end; SetTransferAllocatedReasonCd

subroutine ADD_DEVICE_TRANSFER(dEventId, dProductId, dDeviceId)

	INSERT into
		BB_Device_Transfer bd
	SET
	  bd.product_event_id = dEventId
      ,bd.product_id = dProductId
      ,bd.from_device_id = 0
      ,bd.to_device_id = dDeviceId
      ,bd.reason_cd = transfer_allocated_reason_cd
      ,bd.updt_cnt = 0
      ,bd.updt_dt_tm = cnvtdatetime(curdate,curtime3)
      ,bd.updt_id = reqinfo->updt_id
      ,bd.updt_task = reqinfo->updt_task
      ,bd.updt_applctx = reqinfo->updt_applctx	
    WITH NOCOUNTER
 end; ADD_DEVICE_TRANSFER
subroutine GetInterfaceFlag(dDeviceId) 
	declare interface_flag = i2 with noconstant(0)
	select 
		bbid.interface_flag
	from 
		bb_inv_device bbid
	where bbid.bb_inv_device_id = dDeviceId
	detail
		interface_flag = bbid.interface_flag
	with nocounter
	return (interface_flag)
end ;GetInterfaceFlag

subroutine GetProductTypeBarcode(dProductId) 
	declare barcode = vc with noconstant("")
	select 
		p.product_type_barcode
	from 
		product p
	where p.product_id = dProductId
	detail
		barcode = p.product_type_barcode
	with nocounter
	return (trim(barcode))
end ;GetProductTypeBarcode

/***************************************
*   Update Available Derivative qty   *
***************************************/
subroutine UpdateAvailableQty
  ( dUpd_prod_id,
	 dEr_Updt_Cnt,
	 lQty,
	 lIUs
  )

	set cur_qty = 0
	set cur_ius = 0

	select into "nl:"
		d.seq
	from
		derivative d
	plan d
		where d.product_id = dUpd_prod_id
		  and d.updt_cnt = dEr_Updt_Cnt
	detail
		cur_qty = d.cur_avail_qty
		cur_ius = d.cur_intl_units
	with nocounter, forupdate(d)

	if (curqual = 0)
		set release_status = "F"
	else
		set cur_qty = cur_qty - lQty

 		if (cur_qty > 0)
			set Inactive_Avail = 0
		endif

		if (lIUs > cur_ius)
			set cur_ius = 0
		else
			set cur_ius = cur_ius - lIUs
		endif

		update into derivative d
			set d.cur_avail_qty            = cur_qty,
				 d.cur_intl_units           = cur_ius,
				 d.updt_cnt                 = d.updt_cnt + 1,
				 d.updt_dt_tm               = cnvtdatetime(curdate,curtime3),
				 d.updt_id                  = reqinfo->updt_id,
				 d.updt_task                = reqinfo->updt_task,
				 d.updt_applctx             = reqinfo->updt_applctx
		where d.product_id = dUpd_prod_id
		  and d.updt_cnt = dEr_Updt_Cnt

		if (curqual = 0)
			set release_status = "F"
		else
			set release_status = "S"
		endif
	endif
end


/**************************************************************/
subroutine ModifyAssignQty
  ( dchgprod_id,
	 dchgevent_id,
	 lchgupdt_cnt,
	 qty,
	 ius
  )

	declare remove_assign = i2 with noconstant(0)
	set Inactive_Avail = 0

	/*  lock assign for update */
	set cur_qty = 0
	set cur_ius = 0

	select into "nl:"
		a.seq
	from
		assign a
	plan a
		where a.product_id = dchgprod_id
		  and a.product_event_id   = dchgevent_id
		  and a.updt_cnt   = lchgupdt_cnt
	detail
		cur_qty = a.cur_assign_qty
		cur_ius = a.cur_assign_intl_units
	with nocounter, forupdate(a)

	if (curqual = 0)
		set release_status = "F"
	else
		set cur_qty = cur_qty - qty

		if (cur_qty > 0)
			set remove_assign = 0
		else
			set remove_assign = 1
		endif

		if (ius > cur_ius)
			set cur_ius = 0
		else
			set cur_ius = cur_ius - ius
		endif
        set ModifyAssignQty_ind =1
		; Update the ASSIGN table
		update into assign a
			set a.cur_assign_qty           = cur_qty,
				 a.cur_assign_intl_units    = cur_ius,
				 a.active_ind               = if (remove_assign = 1)
															0
														endif,
				 a.updt_cnt                 = a.updt_cnt + 1,
				 a.updt_dt_tm               = cnvtdatetime(curdate,curtime3),
				 a.updt_id                  = reqinfo->updt_id,
				 a.updt_task                = reqinfo->updt_task,
				 a.updt_applctx             = reqinfo->updt_applctx

		where a.product_id       = dchgprod_id
		  and a.product_event_id = dchgevent_id
		  and a.updt_cnt         = lchgupdt_cnt

		if (curqual = 0)
			set release_status = "F"
		else
			if (remove_assign = 1)

				; Lock the PRODUCT_EVENT table for update
				select into "nl:"
					pe.seq
				from
					product_event pe
				where pe.product_id = dchgprod_id
				  and pe.product_event_id = dchgevent_id
				with nocounter, forupdate(pe)

				; Update the PRODUCT_EVENT table
				update into product_event pe
					set pe.active_ind = 0,
						 pe.updt_cnt = pe.updt_cnt + 1,
						 pe.updt_dt_tm = cnvtdatetime(curdate,curtime3),
						 pe.updt_id = reqinfo->updt_id,
						 pe.updt_task = reqinfo->updt_task,
						 pe.updt_applctx = reqinfo->updt_applctx
					where pe.product_id = dchgprod_id
					  and pe.product_event_id = dchgevent_id
				if (curqual = 0)
					set release_status = "F"
				else
					set release_status = "S"
				endif
			else
				set release_status = "S"
			endif
		endif
	endif
end


/**************************************************************/
subroutine ReleaseAssign
  ( drelprod_id,
	 drelevent_id,
	 drelreason_cd,
	 lrelupdt_cnt,
	 lrelpe_updt_cnt,
	 qty,
	 ius
  )
 
	if(ModifyAssignQty_ind = 0)
		/* Lock product, product_event and assign for update */
		select into "nl:"
			pe.seq
		from
			product_event pe
		plan pe
			where pe.product_id             = drelprod_id
			  and pe.product_event_id       = drelevent_id
			  and pe.updt_cnt               = lrelpe_updt_cnt
		with nocounter, forupdate(pe)

		if (curqual = 0)
			set release_status = "F"
			RETURN
	    endif
 
		select into "nl:"
			a.seq
		from
			assign a
		plan a
			where a.product_id = drelprod_id
			  and a.product_event_id   = drelevent_id
			  and a.updt_cnt   = lrelupdt_cnt
		with nocounter, forupdate(a)

		if (curqual = 0)
			set release_status = "F"
		else
			/* Inactivate Assign product_event row */
			set orig_event_type_cd  = assign_type_cd
			call CHG_PRODUCT_EVENT(0)    ; Inactivate ASSIGNED product_event row
			if (curqual = 0)
				set release_status = "F"
			else
			/* update assign */
				update into assign a
					set a.active_ind               = 0,
						 a.updt_cnt                 = a.updt_cnt + 1,
						 a.updt_dt_tm               = cnvtdatetime(curdate,curtime3),
						 a.updt_id                  = reqinfo->updt_id,
						 a.updt_task                = reqinfo->updt_task,
						 a.updt_applctx             = reqinfo->updt_applctx,
						 a.active_status_cd         = reqdata->active_status_cd,
						 a.active_status_dt_tm      = cnvtdatetime(curdate,curtime3),
						 a.active_status_prsnl_id   = reqinfo->updt_id

					where a.product_id       = drelprod_id
					  and a.product_event_id = drelevent_id
					  and a.updt_cnt         = lrelupdt_cnt

				if (curqual = 0)
					set release_status = "F"
				endif
			endif
		endif
	endif
	if(release_status != "F")
		call Insert_AssignRelease_event(drelprod_id,drelevent_id,drelreason_cd, qty, ius)
 
	endif
end
subroutine Insert_AssignRelease_event
   (
     drelprod_id,
     drelevent_id,
     drelreason_cd,
     drelqty,
     drelius
   )
%i cclsource:bbt_get_pathnet_seq.inc
				insert into assign_release a
				set a.assign_release_id = new_pathnet_seq,
					 a.product_event_id = drelevent_id,
					 a.product_id = drelprod_id,
					 a.release_dt_tm = cnvtdatetime(curdate,curtime3),
					 a.release_prsnl_id         = reqinfo->updt_id,
					 a.release_reason_cd        = drelreason_cd,
					 a.release_qty 		        = if(drelqty>0)
					                                  drelqty
					                              endif,
					 a.release_intl_units       = if(drelius>0)
					                                  drelius
					                              endif,
					 a.active_ind               = 0,
					 a.updt_cnt                 = 0,
					 a.updt_dt_tm             = cnvtdatetime(curdate,curtime3),
					 a.updt_id                  = reqinfo->updt_id,
					 a.updt_task                = reqinfo->updt_task,
					 a.updt_applctx             = reqinfo->updt_applctx,
					 a.active_status_cd         = reqdata->active_status_cd,
					 a.active_status_dt_tm    = cnvtdatetime(curdate,curtime3),
					 a.active_status_prsnl_id   = reqinfo->updt_id
				with nocounter

				if (curqual = 0)
					set release_status = "F"
				else
					set release_status = "S"
				endif
end
/**************************************************************/
 
 
/**************************************************************/
subroutine ReleaseCrossmatch
  ( dproduct_id,
	 devent_id,
	 dreason_cd,
	 lupdt_cnt,
	 lpe_updt_cnt
  )

	/* Lock product, product_event and crossmatch for update */
	select into "nl:"
		pe.product_id
	from
		product_event pe
	plan pe
		where pe.product_id			= dproduct_id
		  and pe.product_event_id	= devent_id
		  and pe.updt_cnt				= lpe_updt_cnt
	with nocounter, forupdate(pe)

	if (curqual = 0)
		set release_status = "F"
		RETURN
	endif
	
	select into "nl:"
		xm.product_id,
		xm.product_event_id
	from
		crossmatch xm
	plan xm
		where xm.product_id = dproduct_id
		  and xm.product_event_id   = devent_id
		  and xm.updt_cnt   = lupdt_cnt
	with nocounter, forupdate(xm)

	if (curqual = 0)
		set release_status = "F"
	else
		/* Inactivate CROSSMATCH product_event row */
		call CHG_PRODUCT_EVENT(0)    ; Inactivate CROSSMATCH product_event row
		if (curqual = 0)
			set release_status = "F"
		else
			/* update assign */
			update into crossmatch xm
				set xm.release_dt_tm = cnvtdatetime(curdate, curtime3),
					 xm.release_prsnl_id         = reqinfo->updt_id,
					 xm.release_reason_cd        = dreason_cd,
					 xm.updt_cnt                 = xm.updt_cnt + 1,
					 xm.updt_dt_tm               = cnvtdatetime(curdate,curtime3),
					 xm.updt_id                  = reqinfo->updt_id,
					 xm.updt_task                = reqinfo->updt_task,
					 xm.updt_applctx             = reqinfo->updt_applctx,
					 xm.active_ind               = 0

				where xm.product_id       = dproduct_id
				  and xm.product_event_id = devent_id
				  and xm.updt_cnt         = lupdt_cnt

			if (curqual = 0)
				set release_status = "F"
			else
				set release_status = "S"
			endif
		endif
	endif
end


/**************************************************************/
subroutine ReleaseInProgress
  ( dproduct_id,
	 devent_id,
	 dreason_cd,
	 lupdt_cnt,
	 lpe_updt_cnt
  )

	/* Lock product_event for update */
	select into "nl:"
		pe.product_id,
		pe.event_dt_tm,
		pe.event_type_cd
	from
		product_event pe
	plan pe
		where   pe.product_id           	= dproduct_id
			 and pe.product_event_id      = devent_id
			 and pe.updt_cnt              = lpe_updt_cnt
	with nocounter, forupdate(pe)

	if (curqual = 0)
		set release_status = "F"
	else
		/* Inactivate CROSSMATCH product_event row */
		call CHG_PRODUCT_EVENT(0)    ; Inactivate INPROGRESS product_event row
		if (curqual = 0)
			set release_status = "F"
		endif
	endif
end ;subroutine ReleaseInProgress


/********************************************************************/
subroutine CHG_PRODUCT_EVENT
  ( dummyx
  )
/* Inactivate product_event row for request-> product_id, event_dt_tm,
   event_type_cd, pe_udpt_cnt */

	update into product_event pe
	set pe.active_ind       = 0,
		 pe.updt_cnt         = pe.updt_cnt + 1,
		 pe.updt_dt_tm       = cnvtdatetime(curdate, curtime),
		 pe.updt_id          = ReqInfo->updt_id,
		 pe.updt_task        = ReqInfo->updt_task,
		 pe.updt_applctx     = ReqInfo->updt_applctx

	plan pe where pe.product_event_id = request->productlist[x].eventlist[y].event_id
	 and pe.product_id = request->productlist[x].product_id
	 and pe.updt_cnt = request->productlist[x]->eventlist[Y]->pe_updt_cnt
	with counter

END         ; end subroutine CHG_PRODUCT_EVENT



/**************************************************************/
subroutine Lock_product
  ( sub_product_id
  )

	select into "nl:"
		p.product_id
	from
		product p
	where (p.product_id = request->productlist[x]->product_id)
	  and (p.updt_cnt = request->productlist[x]->updt_cnt)
	  and (p.locked_ind = 1)
	with nocounter, forupdate(p)

	if (curqual = 0)
		call Update_Status_Data_Err
		  ( "Unable to lock product row for updating."
		  )
		set lock_status = "F"
	else
		set lock_status = "T"
	endif
end


/***************************************************************/
subroutine UnLock_product
  (  sub_product_id,
	 dispense_to_locn_cd,
	 sub_updt_id,
	 sub_updt_task,
	 sub_updt_applctx
  )

 	; Lock the PRODUCT table for update
	select into "nl:"
		p.seq
	from
		product p
	where  p.product_id = sub_product_id
	with nocounter, forupdate(p)

	; Update the PRODUCT table
	update into product p
		set p.locked_ind     			= 0,     /* set to false to unlock the row */
			 p.cur_inv_locn_cd 			= dispense_to_locn_cd,
			 p.cur_dispense_device_id 	= request->device_id,
			 p.updt_cnt       			= p.updt_cnt + 1,
			 p.updt_dt_tm     			= cnvtdatetime(curdate, curtime3),
			 p.updt_id        			= sub_updt_id,
			 p.updt_task      			= sub_updt_task,
			 p.updt_applctx   			= sub_updt_applctx
	where  p.product_id = sub_product_id
	with   nocounter

	if (curqual = 0)
		call Update_Status_Data_Err
		  ( "Unable to unlock the product row."
		  )
		set unlock_status = "F"
	else
		set unlock_status = "S"
	endif
end


/**********************************************************/
subroutine Update_Status_Data_Err( messaged )

	set count1 = count1 + 1
	set count2 = count2 + 1
	if (count1 > 1)
		set stat = alter(reply->status_data->subeventstatus, count1+1)
	endif
	set stat = alterlist(reply->productlist, count2 + 1)
	set reply->productlist[count2].product_id = request->productlist[x].product_id
	set reply->productlist[count2].product_event_id = 0
	set reply->status_data->status = "F"
	set reply->status_data->subeventstatus[count1]->OperationName = "change"
	set reply->status_data->subeventstatus[count1]->OperationStatus = "F"
	set reply->status_data->subeventstatus[count1]->TargetObjectName = "PRODUCT"
	set reply->status_data->subeventstatus[count1]->TargetObjectValue = messaged

	; Rollback changes
	set reqinfo->commit_ind = 0
end


/**********************************************************/
subroutine Update_Status_Data_Success
  ( updt_product_id,
    updt_product_event_id,
    updt_assign_event_id,
    interface_status_flag
  )

	set count1 = count1 + 1
	set count2 = count2 + 1
	if (count1 > 1)
		set stat = alter(reply->status_data->subeventstatus, count1+1)
	endif
	set stat = alterlist(reply->productlist, count2 + 1)
	set reply->productlist[count2].product_id = updt_product_id
	set reply->productlist[count2].product_event_id = updt_product_event_id
	set reply->productlist[count2].assign_event_id = updt_assign_event_id
	set reply->productlist[count2].interface_status_flag = interface_status_flag
	set reply->status_data->status = "S"
	set reply->status_data->subeventstatus[count1]->OperationName = "change"
	set reply->status_data->subeventstatus[count1]->OperationStatus = "S"
	set reply->status_data->subeventstatus[count1]->TargetObjectName = "PRODUCT"
	set reply->status_data->subeventstatus[count1]->TargetObjectValue = "Successfully Updated"

	; Commit changes
	set reqinfo->commit_ind = 1
end

/***************************************************************/
%i cclsource:bbt_add_product_event.inc
END             ; end subroutine ADD_PRODUCT_EVENT


/***************************************************************/
%i cclsource:bbt_add_assign.inc


/***************************************************************/
%i cclsource:bbt_add_bb_exception.inc


/***************************************************************/
#exit_program
if (reply->status_data->status = "S")
	if (count1 > 1)
		set stat = alter(reply->status_data->subeventstatus, count1+1)
	endif
	set reply->status_data->status = "S"
	set reply->status_data->subeventstatus[count1]->OperationName = "add"
	set reply->status_data->subeventstatus[count1]->OperationStatus = "S"
	set reply->status_data->subeventstatus[count1]->TargetObjectName = "product_event & patient_dispense"
	set reply->status_data->subeventstatus[count1]->TargetObjectValue = build(request->person_id)
elseif (reply->status_data->status = "Z")
	set count3 = count3 + 1
	if (count3 > 1)
		set stat = alter(reply->status_data->subeventstatus, count3+1)
	endif
	set reply->status_data->status = "Z"
	set reply->status_data->subeventstatus[count1]->OperationName = "check"
	set reply->status_data->subeventstatus[count1]->OperationStatus = "Z"
	set reply->status_data->subeventstatus[count1]->TargetObjectName = "PATIENT"
	set reply->status_data->subeventstatus[count1]->TargetObjectValue = "Patient Demographics changed"

   ; Rollback changes
	set reqinfo->commit_ind = 0
else
	; Rollback changes
	set reqinfo->commit_ind = 0
endif


#exit_script
call echo(reply->status_data->status)
for (x = 1 to count1)
	call echo("    ")
	call echo(reply->status_data->subeventstatus[x]->OperationName)
	call echo(reply->status_data->subeventstatus[x]->OperationStatus)
	call echo(reply->status_data->subeventstatus[x]->TargetObjectName)
	call echo(reply->status_data->subeventstatus[x]->TargetObjectValue)
endfor
free record outbound_products
end go

;Generated by GNU enscript 1.6.4.
