 ;;Solution_Test/script/PathNet -- BB Transfusion/BBT_OPERATIONS/bbt_ops_batch_release.prg Turn on black mode

/*~BB~************************************************************************
      .                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1994 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved          *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner                                        *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~************************************************************************
      *                   PathNet Blood Bank Transfusion                     *
      *                           V500 Script                                *
      *                   bbt_ops_batch_release.prg                          *
      *                                                                      *
      * PURPOSE:          release expired crossmatch events from a patient and
      					  also release crossmatch, assigned and inprogress events
      					  from a discharged or deceased patient based on the
      					  value set for PATENCSTATUS[n] ops parameter                               *
      * LAST UPDATED BY:  mo2420                                             *
      * DATE CREATED:     10/15/96                                           *
      * LAST MODIFIED:    9/24/96                                            *
      * TABLES USED:      product, product_event, derivative, crossmatch     *
      * PASSED IN:                                                           *
      * PASSED OUT:       status_block.inc                                   *
      * ACTION#:                                                             *
      * REQUEST#:                                                            *
      * APPLICATION#:                                                        *
      * SPECIAL NOTES:                                                       *
      ***********************************************************************/
/******************************************************************************/
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;     001 12/16/98 Shellie Ninemire     Added logic to print the location name
;                                       and address.  Added the address_location_cd to request.
;                                       Added bbt_get_location_info.inc
;                                       Added bbt_print_location_info.inc
;                                       Added uar calls in place of code_value joins
;                                       (Removed 3 code_value table joins)
;                                       Removed the institution name logic.
;     002 05/25/99 Jose Suarez          change cer_temp to cer_print        *
;     003 07/08/99 Jose Suarez          no available states for auto, directed or XM products
;     004 10/21/99 Jose Suarez          check for fields pass from operations
;     005 11/10/99 Jose Suarez          Enhancement when running from ops   *
;                                       added bbt_ops_parm_passed.inc       *
;     006 08/09/00 Lawrence Dsouza      internationalized date and time     *
;     007 02/14/01 Chris Noe            Internationalize text               *
;     008 01/14/02 Sasi Gandham         Add order by for the Head           *
;     009 07/22/02 Jason Osborn         Unique RPT filename project         *
;     009 06/03/03 Jason Osborn         Owner/Inventory area filtering      *
;     010 12/30/03 jg7520             39495: Expand SELECT with forupdate to*
;                                     be a series of single table selects.  *
;     011 05/26/04 Jim Jensen           Format the accession numbers.  Don't*
;                                       add an available event it the unit  *
;                                       was previously assigned or quar'd   *
;     012 07/20/04 David Fifer          Increased the size of the product   *
;                                       sub number variable to accommodate a*
;                                       25 character eurocode prod # and set*
;                                       the maximum columns to 125.         *
;     013 04/27/05 Cedric Daniels       Add check to only bring back active *
;                                       mrn's                               *  
;     014 05/26/05 Jason Osborn         Declare variables and initialize    *
;                                       code_cnt before each uar that uses it*                    
;     015 08/20/10 AS019178             Fix for CR 1-4112965511,to populate *
;                                       reply structure by qualifying       *
;                                       on primary accession for the order  *
;     016 07/11/12 Gayatri Samala       added functionality to relase the   *
;                                       products that are assigned/inprogress*
;										or crossmacthed to either discharged *
;										encounter or deceased patient       *
;~DE~************************************************************************
;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

      drop program bbt_ops_batch_release:dba go
      create program bbt_ops_batch_release:dba
 
        record ops_request
        (
          1 productlist[1]
            2 product_id          = f8             ;information for each product
            2 product_type        = c1             ; B or D
            2 p_updt_cnt          = i4             ;info for product table
            2 der_updt_cnt        = i4             ;update count for derivative
            2 supp_prefix         = c5
            2 productevent[*]
            	3 product_event_id = f8
            	3 event_type_cd    = f8
            	3 pe_updt_cnt      = i4
            	3 updt_cnt         = i4
            	3 order_id         = f8
            	3 person_id        = f8
            	3 release_reason_cd = f8
            	3 release_qty      = i4
            	3 release_iu       = i4
            	3 xm_exp_dt_tm     = dq8
            2 status              = c1
            2 err_message         = c40
        )
 
        record reply
        (
          1 rpt_list[*]
             2 rpt_filename  = vc
%i cclsource:status_block.inc
        )
 
;Ops Parameters Parsing variables
declare temp_string    = vc
declare mode_selection = vc
declare batch_field    = vc
declare rpt_mode       = vc
declare sort_selection = vc
declare sort_field     = vc 

declare nbr_to_update             = i4 with noconstant(0)
declare count1                    = i4 with noconstant(0)                   ;count varible used in 'for' loop
declare failed                    = c1 with noconstant("F")                 ;flag for failure with any part of the script
declare active_quar               = c1 with noconstant("F")                 ;flag for if the product has an active quarantine
declare active_assign             = c1 with noconstant("F")                 ;flag for if the product has an active assignment
declare active_uncfrm             = c1 with noconstant("F")                 ;flag for if the product has an active unconfirmed
declare active_xm                 = c1 with noconstant("F")
declare active_shipped            = c1 with noconstant("F")
declare active_intransit          = c1 with noconstant("F")
declare multiple_xm               = c1 with noconstant("F")                 ;flag for multiple crossmatches on a product
declare error_process             = c40 with noconstant(fillstring(40, " "));holds process description to set reply
declare error_message             = c40 with noconstant(fillstring(40, " "));holds error_message to set reply
declare success_cnt               = i4 with noconstant(0)                   ;count of number of successful updates
declare failure_occured           = c1 with noconstant("F")           ;flag to determine if any part of updates was unsuccessful
declare quantity_val              = i4 with noconstant(0)             ;variable for storing row information while locking row
declare product_event_id          = f8 with noconstant(0.0)                   ;needed for calling add_product_event
declare gsub_product_event_status = c1 with noconstant(" ")                 ;(gsub = global subroutine variable)
declare assign_release_id_val     = f8 with noconstant(0.0)                   ;assign release id generated by system
declare mrn_code                  = f8 with noconstant(0.0)
declare code_cnt                  = i4 with noconstant(0)
declare count2                    = i4 with noconstant(0)
declare nbr_of_events             = i4 with noconstant(0)
declare index                     = i4 with noconstant(0)
declare pe_index                  = i4 with noconstant(0)
declare temp_prod_event_id        = f8 with noconstant(0.0)
declare temp_updt_cnt             = i4 with noconstant(0)
declare temp_pe_updt_cnt          = i4 with noconstant(0)
declare pos                       = i4 with noconstant(0)
declare pos1                      = i4 with noconstant(0)
declare quantity_iu               = i4 with noconstant(0)
declare ops_param_status          = i4 with noconstant(-1)
declare total_xm_events           = i4 with noconstant(0)
declare qual_xm_events            = i4 with noconstant(0)
declare multiple_inprog           = c1 with noconstant("F")
declare total_inprog_events       = i4 with noconstant(0)
declare qual_inprog_events        = i4 with noconstant(0)
declare valid_prod_ind            = c1 with noconstant("F")
declare der_release_qty           = i4 with noconstant(0)
declare der_release_IU            = i4 with noconstant(0)
 
declare xm_expired_reason_cd      = f8 with noconstant(0.0)
declare pat_expired_reason_cd     = f8 with noconstant(0.0)
declare enc_discharged_reason_cd  = f8 with noconstant(0.0)
 
declare quar_event_type_cd        = f8 with noconstant(0.0)
declare assign_event_type_cd      = f8 with noconstant(0.0)
declare xmtch_event_type_cd       = f8 with noconstant(0.0)
declare dispense_event_type_cd    = f8 with noconstant(0.0)
declare avail_event_type_cd       = f8 with noconstant(0.0)
declare uncfrm_event_type_cd      = f8 with noconstant(0.0)
declare inprogress_event_type_cd  = f8 with noconstant(0.0)
declare autologous_event_type_cd  = f8 with noconstant(0.0)
declare directed_event_type_cd    = f8 with noconstant(0.0)   
declare shipped_event_type_cd     = f8 with noconstant(0.0)
declare intransit_event_type_cd   = f8 with noconstant(0.0)


declare MRN_MEANING         = c12 with protected, constant("MRN")
declare XM_EXP_MEANING      = c12 with protected, constant("EXPIRED")
declare PAT_EXP_MEANING     = c12 with protected, constant("PAT_DECEASED")
declare ENC_DISCHARG_MEANING= c12 with protected, constant("SYS_DISCHRG")
declare ASSIGN_MEANING      = c12 with protected, constant("1")
declare QUAR_MEANING        = c12 with protected, constant("2")
declare XM_MEANING          = c12 with protected, constant("3")
declare DISPENSE_MEANING    = c12 with protected, constant("4")
declare AVAILABLE_MEANING   = c12 with protected, constant("12")
declare UNCFRM_MEANING      = c12 with protected, constant("9")
declare INPROG_MEANING      = c12 with protected, constant("16")
declare AUTO_MEANING        = c12 with protected, constant("10")
declare DIR_MEANING         = c12 with protected, constant("11")   
declare SHIP_MEANING        = c12 with protected, constant("15")
declare INTRANSIT_MEANING   = c12 with protected, constant("25")

;Begin 007
/*****************************************************************************
* Internationalization                                                       *
*****************************************************************************/
declare i18nHandle     = i4 with noconstant(0)
declare h              = i4 with noconstant(0)

%i cclsource:i18n_uar.inc

 
set i18nHandle = 0
set h = uar_i18nlocalizationinit(i18nHandle, curprog, "", curcclrev)
 
record captions
(
  1  rpt_batch_crossmatch	 = vc
  1  as_of_time				 = vc
  1  as_of_date				 = vc
  1  blood_bank_owner		 = vc
  1  inventory_area			 = vc
  1  prepared 				 = vc
  1  unit_number			 = vc
  1  medical_number			 = vc
  1  patient_name			 = vc
  1  accession_number		 = vc
  1  product				 = vc
  1  status					 = vc
  1  xm_exp_date			 = vc
  1  report_id				 = vc
  1  rpt_page				 = vc
  1  printed				 = vc
  1  end_of_report			 = vc
  1  rpt_no_crossmatches     = vc
  1  update_and_report		 = vc
  1  report_only			 = vc
  1  reason                  = vc
)
 
set captions->rpt_batch_crossmatch = uar_i18ngetmessage(i18nHandle,
  "rpt_batch_crossmatch",
  "B A T C H    C R O S S M A T C H   R E L E A S E   R E P O R T")
set captions->as_of_time = uar_i18ngetmessage(i18nHandle,
  "as_of_time", "As of Time:")
set captions->as_of_date = uar_i18ngetmessage(i18nHandle,
  "as_of_date", "As of Date:")
set captions->blood_bank_owner = uar_i18ngetmessage(i18nHandle,
  "blood_bank_owner", "Blood Bank Owner: ")
set captions->inventory_area = uar_i18ngetmessage(i18nHandle,
  "inventory_area", "Inventory Area: ")
set captions->prepared = uar_i18ngetmessage(i18nHandle,
  "prepared", "Prepared:")
set captions->unit_number = uar_i18ngetmessage(i18nHandle,
  "unit_number", "UNIT NUMBER")
set captions->medical_number = uar_i18ngetmessage(i18nHandle,
  "medical_number", "MEDICAL NUMBER")
set captions->patient_name = uar_i18ngetmessage(i18nHandle,
  "patient_name", "PATIENT NAME")
set captions->accession_number = uar_i18ngetmessage(i18nHandle,
  "accession_number", "ACCESSION NUMBER")
set captions->product = uar_i18ngetmessage(i18nHandle,
  "product", "PRODUCT")
set captions->status = uar_i18ngetmessage(i18nHandle,
  "status", "STATUS")
set captions->xm_exp_date = uar_i18ngetmessage(i18nHandle,
  "xm_exp_date", "XM EXP DATE")
set captions->report_id = uar_i18ngetmessage(i18nHandle,
  "report_id", "Report ID: BBT_OPS_BATCH_RELEASE")
set captions->rpt_page = uar_i18ngetmessage(i18nHandle,
  "rpt_page", "Page:")
set captions->printed = uar_i18ngetmessage(i18nHandle,
  "printed", "Printed:")
set captions->end_of_report = uar_i18ngetmessage(i18nHandle,
  "end_of_report", "* * * End of Report * * *")
set captions->rpt_no_crossmatches = uar_i18ngetmessage(i18nHandle,
  "rpt_no_crossmatches",
  " * * * No crossmatches to release at this time * * *")
set captions->update_and_report = uar_i18ngetmessage(i18nHandle,
  "update_and_report", "UPDATE AND REPORT")
set captions->report_only = uar_i18ngetmessage(i18nHandle,
  "report_only", "REPORT ONLY")
set captions->reason = uar_i18ngetmessage(i18nHandle,
  "reason", "REASON")
;End 007
 
        ;Modified to flex the sorting of the report by the input the request->batch_slection field. BNK - 02/10/98.
        ;Modified to match the request->batch_selection when entering all necesary fields   JS-07/12/99.
    if (trim(request->batch_selection) > " ")
           ;comment out, needs to select from ops_date
           ;set request->ops_date = cnvtdatetime(curdate,curtime3)    ;set for now
           set temp_string = cnvtupper(trim(request->batch_selection))

           set mode_selection = fillstring(6," ")
           call CHECK_MODE_OPT ("bbt_ops_batch_release")
           if (mode_selection = "UPDATE")
              set batch_field = mode_selection
              set rpt_mode = captions->update_and_report		;007
           elseif (mode_selection = "REPORT")
              set batch_field = mode_selection
              set rpt_mode = captions->report_only				;007
           else
              ;fail script
              set reply->status_data->status = "F"
              set reply->status_data->subeventstatus[1].OperationName = "bbt_ops_batch_release"
              set reply->status_data->subeventstatus[1].OperationStatus = "F"
              set reply->status_data->subeventstatus[1].TargetObjectName = "no mode selection"
              set reply->status_data->subeventstatus[1].TargetObjectValue = "no correct mode selection in string"
              go to exit_script
           endif

           set sort_selection = fillstring(20," ")
           call  CHECK_SORT_OPT ("bbt_ops_batch_release")
           if (sort_selection = "NAME")
              set sort_field = sort_selection
           elseif (sort_selection = "MRN")
              set sort_field = sort_selection
           ;elseif (sort_selection = "ABORH")             ;not used commented out by JS
           ;    set sort_field = sort_selection
           else
              set sort_field = "NAME"
           endif

           call CHECK_LOCATION_CD ("bbt_ops_batch_release")
           ; get the value of PATENCSTATUS[] parameter
           call CHECK_MISC_FUNCTIONALITY ("PATENCSTATUS")
 
    else
        ;comment out, needs to select from ops_date
        ;set request->ops_date = cnvtdatetime(curdate,curtime3)    ;set for now
        set batch_field = "REPORT"
        set rpt_mode = captions->report_only
        set sort_field = "NAME"
        set request->address_location_cd = 0.0
    endif
 
;Process values in the request->batch_selection field when running from operations
%i cclsource:bbt_ops_parm_passed.inc

;001 %i cclsource:bbt_get_inst_name.inc
%i cclsource:bbt_get_location_info.inc

        /* Initialize Variables */
        ;004
        ;set request->ops_date = cnvtdatetime(curdate,curtime3)    ;set for now
        ;set calc_xm_exp_dt_tm = cnvtdatetime(curdate, curtime3)   ;the date and time that crossmatch expiration must
                                                                  ;be greater than
        set nbr_to_update = 0
        set count1 = 0                                    ;count varible used in 'for' loop
        set reply->status_data->status = "F"
        set failed = "F"                                  ;flag for failure with any part of the script
        set active_quar = "F"                             ;flag for if the product has an active quarantine
        set active_assign = "F"                           ;flag for if the product has an active assignment
        set active_uncfrm = "F"                           ;flag for if the product has an active unconfirmed
        set multiple_xm = "F"                             ;flag for multiple crossmatches on a product
        set active_shipped = "F"
        set active_intransit = "F"
        set error_process = "                                      "                ;holds process description to set reply
        set error_message = "                                      "                ;holds error_message to set reply
        set success_cnt = 0                               ;count of number of successful updates
        set failure_occured = "F"                         ;flag to determine if any part of updates was unsuccessful
        set quantity_val = 0                              ;variable for storing row information while locking row
        set product_event_id = 0.0                          ;needed for calling add_product_event
        set gsub_product_event_status = "  "              ;(gsub = global subroutine variable)
        set assign_release_id_val = 0.0                     ;assign release id generated by system
 
        set mrn_code = 0.0
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(4, nullterm(MRN_MEANING), code_cnt, mrn_code)
        if (mrn_code = 0.0)
           set failure_occured = "T"
           set reply->status_data->status = "F"
           set error_process = "get codevalues"
           set error_message = "unable to get MRN codevalue"
        endif
 
        set xm_expired_reason_cd = 0.0
        set pat_expired_reason_cd = 0.0
        set enc_discharged_reason_cd = 0.0
 
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1616, nullterm(XM_EXP_MEANING), code_cnt, xm_expired_reason_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1616, nullterm(PAT_EXP_MEANING), code_cnt, pat_expired_reason_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1616, nullterm(ENC_DISCHARG_MEANING), code_cnt, enc_discharged_reason_cd)
 
        set quar_event_type_cd       = 0.0
        set assign_event_type_cd     = 0.0
        set xmtch_event_type_cd      = 0.0
        set dispense_event_type_cd   = 0.0
        set avail_event_type_cd      = 0.0
        set uncfrm_event_type_cd     = 0.0
        set inprogress_event_type_cd = 0.0
        set autologous_event_type_cd = 0.0
        set directed_event_type_cd   = 0.0
        set shipped_event_type_cd    = 0.0
        set intransit_event_type_cd  = 0.0
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(QUAR_MEANING), code_cnt, quar_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(ASSIGN_MEANING), code_cnt, assign_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(XM_MEANING), code_cnt, xmtch_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(DISPENSE_MEANING), code_cnt, dispense_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(AVAILABLE_MEANING), code_cnt, avail_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(UNCFRM_MEANING), code_cnt, uncfrm_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(INPROG_MEANING), code_cnt, inprogress_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(AUTO_MEANING), code_cnt, autologous_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(DIR_MEANING), code_cnt, directed_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(SHIP_MEANING), code_cnt, shipped_event_type_cd)
        set code_cnt = 1
        set stat = uar_get_meaning_by_codeset(1610, nullterm(INTRANSIT_MEANING), code_cnt, intransit_event_type_cd)
        
        if (quar_event_type_cd = 0.0 OR assign_event_type_cd = 0.0 OR xmtch_event_type_cd = 0.0 OR 
            dispense_event_type_cd = 0.0 OR avail_event_type_cd = 0.0 OR uncfrm_event_type_cd = 0.0 OR 
            inprogress_event_type_cd = 0.0 OR autologous_event_type_cd = 0.0 OR directed_event_type_cd = 0.0 OR
            shipped_event_type_cd = 0.0 OR intransit_event_type_cd = 0.0)
           set reply->status_data->status = "F"
           set error_process = "bbt_ops_batch_release"
           set error_message = "unable to load product_event ids"
           set failure_occured = "T"
           set reply->status_data->status = "F"
           set reply->status_data->subeventstatus[1]->OperationName = "release"
           set reply->status_data->subeventstatus[1]->OperationStatus = "F"
           set reply->status_data->subeventstatus[1]->TargetObjectName = "code value read failed"
           set reply->status_data->subeventstatus[1]->TargetObjectValue = "F"
           go to exit_script
        endif

;001 end
        call CHECK_OWNER_CD("bbt_ops_batch_transfusion.prg")
        call CHECK_INVENTORY_CD("bbt_ops_batch_transfusion.prg")
        set product_count = 0

        /**************************************************************************************************/
        /*  Find all of the products that have expired crossmatches                                       */
        /**************************************************************************************************/
        ;set calc_xm_exp_dt_tm = DATETIMEADD(request->Ops_Date,pref_xm_look_hrs/24.0)
        ; This query is applicable for only blood products, as derivatives cannot be crossmacthed with the current
        ; data model
        select into "nl:"
           xm.product_event_id,
           pe.product_event_id,
           pe.person_id,
           p.product_id,
           p.locked_ind,
           b.product_id
 
           from product p,
                blood_product b,
                product_event pe,
                crossmatch xm
 
           plan xm where ((xm.active_ind = 1)
                           and (CNVTDATETIME(request->Ops_Date) >= (xm.crossmatch_exp_dt_tm))
                         )
           join pe where ( (pe.active_ind = 1)
                            and (xm.product_event_id = pe.product_event_id)
                         )
           join p where  ( (pe.product_id = p.product_id)
                           and ((p.locked_ind = 0) or (p.locked_ind = NULL))
                           and (p.active_ind = 1) and (p.product_id > 0.0))
           join b where b.product_id = p.product_id
 
           order by xm.product_id, xm.product_event_id
 
           head report
                count1 = 0
           ;head pe.person_id
           ;     count1 = count1
           head xm.product_id
           	   valid_prod_ind = "F"
           	   ; check whether qualified product belongs to a particular OWN/INV area location mentioned in batch selection
	           if (((request->cur_owner_area_cd > 0.0 and
	                                 request->cur_owner_area_cd = p.cur_owner_area_cd)
	                            or (request->cur_owner_area_cd = 0.0))
	                           and ((request->cur_inv_area_cd > 0.0 and
	                                 request->cur_inv_area_cd = p.cur_inv_area_cd)
	                            or (request->cur_inv_area_cd = 0.0)))
	           		valid_prod_ind = "T"
	           endif
 
	           if (valid_prod_ind = "T")
 	           		count1 = count1 + 1
	           		count2 = 0
	           		product_count = product_count + 1
	                stat = alter(ops_request->productlist, count1)
 
	                ops_request->productlist[count1].product_type          = "B"
	                ops_request->productlist[count1].supp_prefix           = b.supplier_prefix
	                ops_request->productlist[count1].product_id            = p.product_id
	                ops_request->productlist[count1].p_updt_cnt            = p.updt_cnt
	           endif
 
           head xm.product_event_id
	           if (valid_prod_ind = "T")
		           	count2 = count2 + 1
		           	stat = alterlist(ops_request->productlist[count1].productevent, count2)
	                ops_request->productlist[count1]->productevent[count2].product_event_id    = pe.product_event_id
	                ops_request->productlist[count1]->productevent[count2].event_type_cd       = pe.event_type_cd
	                ops_request->productlist[count1]->productevent[count2].pe_updt_cnt         = pe.updt_cnt
 
	                ops_request->productlist[count1]->productevent[count2].order_id            = pe.order_id
	                ops_request->productlist[count1]->productevent[count2].person_id           = pe.person_id
	                ops_request->productlist[count1]->productevent[count2].release_reason_cd   = xm_expired_reason_cd
	 		   endif
           with nocounter
 
        /**************************************************************************************************/
        /*  Find all the products that are assigned, crossmatched and Inprogress for the discharged or
        /*  deceased patients                                                                             */
        /**************************************************************************************************/
        ; if PATENCSTATUS[] ops parameter value is equal to 1, then release products of discharged or deceased patients
        ; This query is applicable for both blood products and derivatives, as derivatives can be assigned or dispensed
        ; to discharged encounters/deceased patients
        if(ops_param_status = 1)
	        select into "nl:"
	        	pe.product_event_id,
	        	pn.person_id,
	        	en.encntr_id,
	        	p.product_id,
	        	rel_reason = decode(pn.seq, "Patient Expired", en.seq, "Encounter Discharged", "Y"),
	        	prod_type = decode(b.seq, "b", b1.seq, "b", d.seq, "d", de.seq, "d", "x")
 
	        from product_event pe,
	       	 	encounter en,
	        	person pn,
	        	product p,
	        	blood_product b,
	        	blood_product b1,
	        	derivative d,
	        	derivative de,
	        	dummyt d1,
	        	dummyt d2,
	        	dummyt d3,
	        	dummyt d4
 
	        plan pe where pe.event_type_cd in (xmtch_event_type_cd, assign_event_type_cd, inprogress_event_type_cd) and
	        			  pe.active_ind = 1
	        join p where pe.product_id = p.product_id and p.active_ind = 1 and p.product_id > 0.0 and
	        			 (p.locked_ind = 0 or p.locked_ind = NULL)
	        join (d1 where (d1.seq = 1)
	        	  join pn where pe.person_id = pn.person_id and pn.person_id > 0.0 and pn.deceased_dt_tm != NULL
	        	  join (d2 where (d2.seq = 1)
	        	      join (b where b.product_id = p.product_id)
	        	      orjoin (d where d.product_id = p.product_id)))
	        orjoin (d3 where (d3.seq = 1)
	        	  join en where pe.encntr_id = en.encntr_id and en.encntr_id > 0.0 and en.active_ind = 1
	        	  and (en.disch_dt_tm != null and en.disch_dt_tm <= cnvtdatetime(curdate, curtime3))
	        	  join (d4 where (d4.seq = 1)
	        	      join (b1 where b1.product_id = p.product_id)
	        	      orjoin (de where de.product_id = p.product_id)))
 
			order by pe.product_id, pe.product_event_id, rel_reason desc
 
	        head pe.product_id
	            valid_prod_ind = "F"
	            ; check whether qualified product belongs to a particular OWN/INV area location mentioned in batch selection
		        if (((request->cur_owner_area_cd > 0.0 and
	                                 request->cur_owner_area_cd = p.cur_owner_area_cd)
	                            or (request->cur_owner_area_cd = 0.0))
	                           and ((request->cur_inv_area_cd > 0.0 and
	                                 request->cur_inv_area_cd = p.cur_inv_area_cd)
	                            or (request->cur_inv_area_cd = 0.0)))
	           		valid_prod_ind = "T"
	            endif
	            if (valid_prod_ind = "T")
		        	pos = 0
		        	pos = locateval(index, 1, size(ops_request->productlist, 5), p.product_id, ops_request->productlist[index].product_id)
		        	; add all the qualified products to the product list, if it is not already present in the list
		        	if (pos = 0)
		        		count1 = count1 + 1
		           		count2 = 0
		           		product_count = product_count + 1
		            	stat = alter(ops_request->productlist, count1)
			        	ops_request->productlist[count1].product_type = if (prod_type = "d")
			        														"D"
			        													else
			        														"B"
			        													endif
			        	ops_request->productlist[count1].product_id = p.product_id
			        	ops_request->productlist[count1].p_updt_cnt = p.updt_cnt
			        	ops_request->productlist[count1].der_updt_cnt = if (prod_type = "d")
			        														if (rel_reason = "Patient Expired")
			        															d.updt_cnt
			        														else
			        															de.updt_cnt
			        														endif
			        													else
			        														0
			        													endif
			        	if (prod_type = "b")
				        	ops_request->productlist[count1].supp_prefix = if (rel_reason = "Patient Expired")
				        														b.supplier_prefix
				        												   else
				        												   		b1.supplier_prefix
				        												   endif
				        endif
			        endif
			    endif
	        head pe.product_event_id
		        if (valid_prod_ind = "T")
		            ; add qualified events to the product event list, for the products qualified for ENC discharged/
		            ; patient deceased
		        	if (pos = 0)
			        	count2 = count2 + 1
				        stat = alterlist(ops_request->productlist[count1].productevent, count2)
				        ops_request->productlist[count1].productevent[count2].product_event_id = pe.product_event_id
				        ops_request->productlist[count1].productevent[count2].event_type_cd = pe.event_type_cd
				        ops_request->productlist[count1].productevent[count2].pe_updt_cnt = pe.updt_cnt
				        ops_request->productlist[count1].productevent[count2].order_id = pe.order_id
				        ops_request->productlist[count1].productevent[count2].person_id = pe.person_id
				        ops_request->productlist[count1].productevent[count2].release_reason_cd = if (rel_reason = "Patient Expired")
		       																						pat_expired_reason_cd
		       																 			 		  else
		       																 						enc_discharged_reason_cd
		       																 			 		  endif
		       			if (ops_request->productlist[count1].productevent[count2].event_type_cd = inprogress_event_type_cd)
		       				ops_request->productlist[count1].status = "S"
		       			endif
		       		; This is adding events to the product event list, for the products qualified in the expired
		       		; crossmatches query
				    else
				    	pos1 = 0
				    	pos1 = locateval(index,1, size(ops_request->productlist[pos].productevent, 5), pe.product_event_id,
				    					 ops_request->productlist[pos].productevent[index].product_event_id)
				        if (pos1 = 0)
				    		count2 = size(ops_request->productlist[pos].productevent, 5) + 1
				    		stat = alterlist(ops_request->productlist[pos].productevent, count2)
				        	ops_request->productlist[pos].productevent[count2].product_event_id = pe.product_event_id
				        	ops_request->productlist[pos].productevent[count2].event_type_cd = pe.event_type_cd
				        	ops_request->productlist[pos].productevent[count2].pe_updt_cnt = pe.updt_cnt
				        	ops_request->productlist[pos].productevent[count2].order_id = pe.order_id
				        	ops_request->productlist[pos].productevent[count2].person_id = pe.person_id
				        	ops_request->productlist[pos].productevent[count2].release_reason_cd = if (rel_reason = "Patient Expired")
		       																						pat_expired_reason_cd
		       																 			 		  else
		       																 						enc_discharged_reason_cd
		       																 			 		  endif
		       				if (ops_request->productlist[pos].productevent[count2].event_type_cd = inprogress_event_type_cd)
		       					ops_request->productlist[pos].status = "S"
		       				endif
				    	endif
		        	endif
	        	endif
	        with nocounter
        endif
 
        ; for all the products qualified for expired crossmatch/encounter discharged/patient deceased
        ; set the status and all applicable assign or crossmacth values
        for (i = 1 to size(ops_request->productlist, 5))
        	select into "nl:"
        		pe.product_event_id,
        		event = decode(a.seq, "ASSIGN", xm.seq, "XM", "yy"),
        		is_dispensed = if (pe_pd.product_id > 0)
        					   		"pd"
        					   else
        					   		"xx"
        					   endif
 
        	from product_event pe,
        		patient_dispense pe_pd,
        		crossmatch xm,
        		assign a,
        		dummyt d1
 
        	plan pe where expand (index, 1, size(ops_request->productlist[i].productevent, 5), pe.product_event_id,
        						  ops_request->productlist[i].productevent[index].product_event_id)
        	join pe_pd where pe_pd.product_id = outerjoin(pe.product_id) and pe_pd.active_ind = outerjoin(1)
       		join (d1
       			join xm where pe.product_event_id = xm.product_event_id
       			orjoin a where pe.product_event_id = a.product_event_id)
 
       		order by pe.product_event_id
 
        	head pe.product_event_id
        		pos = locateval(index, 1, size(ops_request->productlist[i].productevent, 5), pe.product_event_id,
        					    ops_request->productlist[i].productevent[index].product_event_id)
        		if (event = "ASSIGN")
        			ops_request->productlist[i].productevent[pos].updt_cnt = a.updt_cnt
        		elseif (event = "XM")
        			ops_request->productlist[i].productevent[pos].updt_cnt = xm.updt_cnt
        			ops_request->productlist[i].productevent[pos].xm_exp_dt_tm = CNVTDATETIME(xm.crossmatch_exp_dt_tm)
        		endif
 
 				; this is applicable only for derivatives assigned
        		if (ops_request->productlist[i].product_type = "D")
        			if (event = "ASSIGN")
        				ops_request->productlist[i].productevent[pos].release_qty = a.cur_assign_qty
        				ops_request->productlist[i].productevent[pos].release_iu = a.cur_assign_intl_units
        			endif
        		endif
 
 				; for blood products, if any product is dispensed, do not release the product
 				if (ops_request->productlist[i].product_type = "B")
	        		if (is_dispensed = "pd")         ;product dispensed
		            	ops_request->productlist[i].status                     = "F"
		                ops_request->productlist[i].err_message                = "Product issued"
		            else
		                ops_request->productlist[i].status                     = "S"
		            endif
		        ; for derivatives, do not release only the dispensed quantity, other than that for all the
		        ; qualified events, release the assign and add the quantity back to the current available quantity
		        else
		        	ops_request->productlist[i].status                     = "S"
		        endif
        	with nocounter
        endfor
 
 		set stat = alter(ops_request->productlist,count1)
        if (CNVTUPPER(batch_field) = "UPDATE")
 
           /***************************************************************************************************************/
           /* lock all of the products found, if the lock fails set the status in the reply->result array so that it is   */
           /* not updated by the script                                                                                   */
           /***************************************************************************************************************/
           set nbr_to_update = cnvtint(size(ops_request->productlist,5))
           set stat = alter(reply->status_data->subeventstatus,nbr_to_update)
           set error_process = "                                      "
           set error_message = "                                      "
 
           for (prod = 1 to nbr_to_update)
           	  if (ops_request->productlist[prod].status = "S")
              	 update into product p set
                      p.locked_ind = 1,
                      p.updt_cnt = p.updt_cnt + 1,
                      p.updt_dt_tm = cnvtdatetime(curdate, curtime3),
                      p.updt_id = reqinfo->updt_id,
                      p.updt_task = reqinfo->updt_task,
                      p.updt_applctx = reqinfo->updt_applctx
                 where (p.product_id = ops_request->productlist[prod].product_id)
                               and (p.updt_cnt = ops_request->productlist[prod].p_updt_cnt)
                               and ((p.locked_ind is NULL) or (p.locked_ind = 0))
                 with nocounter
                 if (curqual = 0)
                    ;item not locked
                    set ops_request->productlist[prod]->status = "F"
                    set error_process =  "lock product"
                    set error_message = "Unable to lock product"
                 else
                    ;increment the update count for the product
                    set ops_request->productlist[prod].p_updt_cnt = ops_request->productlist[prod].p_updt_cnt + 1
                    commit product
                 endif
              ;update the ops requst structure with the proper update count for the product table
              else
                 set ops_request->productlist[prod].p_updt_cnt = ops_request->productlist[prod].p_updt_cnt + 1
              endif
            endfor

 
           /***************************************************************************************************************/
           /*   release all of the expired crossmatch products                                                            */
           /***************************************************************************************************************/
           set nbr_to_update = cnvtint(size(ops_request->productlist,5))
 
 
           /* Execute a for loop for every item in the array.  The loop cycle will lock the necessary rows on all the tables
              and then update the tables.  The tables that are updated depend on the information passed in on  the request.
              The plan and join clauses controll which tables are accessed and locked.
              If any of these updates is unsuccessfull any changes made for this item (loop iteration) will be rolled back.
              If all updates are successful for an item (loop iteration) a commit command is issued for all tables
            */
           for (prod = 1 to nbr_to_update)
               set failure_occured = "F"                ;set the failure flag to false
               set active_quar = "F"                    ;default to no active quarantine on product
               set active_assign = "F"                  ;default to no active assignment on product
               set active_uncfrm = "F"                  ;default to no active unconfirmed event on product
               set active_inprogress = "F"              ;default to no active in progress event on product
               set active_autologous = "F"              ;default to no active autologous event on product
               set active_directed = "F"                ;default to no active directed event on product
               set multiple_xm = "F"                    ;flag if other crossmatches exist
 			   set active_xm = "F"
 			   set active_avail = "F"
 			   set active_shipped = "F"
 			   set active_intransit = "F"
 			   set index = 0
 			   set pos = 0
 			   set total_xm_events = 0
 			   set qual_xm_events = 0
 			   set multiple_inprog = "F"
 			   set total_inprog_events = 0
 			   set qual_inprog_events = 0
 
               /***************************************************************************************************************/
               /* Search the product_event table for the active states for this product and if there is an active quarantine  */
               /* or unconfirmed or in progress or autologous or directed state then set the proper flag,                     */
               /* these flags will be checked before creating an available event.                                             */
               /* Also verify that there is not multiple crossmatches on the product.  If the product has multiple            */
               /* crossmatches and all are to be released the last crossmatch in the ops_request array will not set           */
               /* multiple_xm = "T"                                                                                           */
               /***************************************************************************************************************/
               if (ops_request->productlist[prod].status = "S")
                  select into "nl:"
                      pe.product_event_id
                  from product_event pe
                  where (
                         (pe.active_ind = 1)
                         And (pe.product_id = ops_request->productlist[prod]->product_id)
                        )
                  detail
                        if (pe.event_type_cd = quar_event_type_cd)
                            active_quar = "T"
                        elseif (pe.event_type_cd = assign_event_type_cd)
                            active_assign = "T"
                        elseif (pe.event_type_cd = uncfrm_event_type_cd)
                            active_uncfrm = "T"
                       ; This is to check for multiple crossmatch events
                       elseif (pe.event_type_cd = xmtch_event_type_cd)
                       		total_xm_events = total_xm_events + 1
                       		active_xm = "T"
                       		pos = locateval(index, 1, size(ops_request->productlist[prod].productevent, 5), pe.product_event_id,
                       						ops_request->productlist[prod].productevent[index].product_event_id)
							if (pos > 0)
								qual_xm_events = qual_xm_events + 1
							endif
 
                       		if (total_xm_events = qual_xm_events)
                       			multiple_xm = "F"
                       		else
                       			multiple_xm = "T"
                       		endif
                       ; This is to check for multiple inprogress events
                       elseif (pe.event_type_cd = inprogress_event_type_cd)
							total_inprog_events = total_inprog_events + 1
							pos = locateval( index, 1, size(ops_request->productlist[prod].productevent, 5), pe.product_event_id,
											 ops_request->productlist[prod].productevent[index].product_event_id)
							if (pos > 0)
								qual_inprog_events = qual_inprog_events + 1
							endif
 
							if (total_inprog_events = qual_inprog_events)
								multiple_inprog = "F"
							else
								multiple_inprog = "T"
							endif
                       elseif (pe.event_type_cd = autologous_event_type_cd)
                            active_autologous = "T"
                       elseif (pe.event_type_cd = directed_event_type_cd)
                            active_directed = "T"
                       elseif (pe.event_type_cd = avail_event_type_cd)
                       		active_avail = "T"
                       elseif (pe.event_type_cd = shipped_event_type_cd)
                            active_shipped = "T"
                       elseif (pe.event_type_cd = intransit_event_type_cd)
                            active_intransit = "T"
                       endif
                  with counter
               endif
 
               /*********************************************   RELEASE  PRODUCT ************************************************/
               /*This event will occur only for products that have been designated to have the assignment or crossmatch released*/
               /*If the product is flagged to have the crossmatch/assign released the product is returned to available if there */
               /*is not a quarantine put on the product. If the product is a derivative the inactivation of the rows depends on */
               /*if the quantity returned = the cur_quantity fields on the respective tables.  If the product is assinged the   */
               /*information is inserted on the assign_release table.                                                           */
               /*NOTE: This is the only place an availalbe event is written, dispense will assign products to patients if there */
               /*is not a crossmatch. So if there is no assignment or crossmatch and the product is returned                    */
               /*****************************************************************************************************************/
               set nbr_of_events = cnvtint(size(ops_request->productlist[prod]->productevent,5))
 
 			   for (count1 = 1 to nbr_of_events)
               		set temp_prod_event_id = ops_request->productlist[prod]->productevent[count1].product_event_id
               		set temp_updt_cnt = ops_request->productlist[prod]->productevent[count1].updt_cnt
               		set temp_pe_updt_cnt = ops_request->productlist[prod]->productevent[count1].pe_updt_cnt
 
	               ;release crossmatch
	               if (ops_request->productlist[prod].status = "S")
	               	   ; ****************************  Releasing crossmatch *****************************************
		               if ((failure_occured = "F") and
		                   (ops_request->productlist[prod]->productevent[count1].event_type_cd = xmtch_event_type_cd ))
		                  select into "nl:"
		                         xm.product_id,
		                         xm.product_event_id
		                  from crossmatch xm
		                  plan xm where (xm.product_event_id = temp_prod_event_id)
		                               And (xm.product_id = ops_request->productlist[prod]->product_id)
		                               And (xm.updt_cnt = temp_updt_cnt)
		                  with nocounter ,forupdate(xm)
 
		                  if (curqual != 0)
		                     select into "nl:"
		                           pe.product_id
		                        from product_event pe
		                        plan pe where (pe.product_event_id = temp_prod_event_id)
		                                And (pe.product_id = ops_request->productlist[prod]->product_id)
		                                And (pe.event_type_cd = xmtch_event_type_cd)
		                                And (pe.updt_cnt = temp_pe_updt_cnt)
		                        with nocounter , forupdate(pe)
		                  endif
 
		                  if (curqual = 0)
		                     set error_process = "lock crossmatch/product_event"
		                     set error_message = "crossmatch/product_event not locked"
		                     set failure_occured = "T"
		                  else
		                     ;______________________________________ update tables ____________________________________
		                     update into crossmatch xm
		                         set
		                            xm.release_reason_cd = ops_request->productlist[prod].productevent[count1].release_reason_cd,
		                            xm.release_dt_tm = cnvtdatetime(curdate,curtime3),
		                            xm.release_prsnl_ID = reqinfo->updt_id,
		                            xm.release_qty = 0,
		                            xm.crossmatch_qty = 0,
		                            xm.updt_cnt         = xm.updt_cnt + 1,
		                            xm.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
		                            xm.updt_task        = reqinfo->updt_task,
		                            xm.updt_id          = reqinfo->updt_id,
		                            xm.updt_applctx     = reqinfo->updt_applctx,
		                            xm.active_ind       = 0,
		                            xm.active_status_cd = ReqData->inactive_status_cd,
		                            xm.active_status_dt_tm  = cnvtdatetime(curdate, curtime3),
		                            xm.active_status_prsnl_id = ReqInfo->updt_id
		                     plan xm where (xm.product_event_id = temp_prod_event_id)
		                                  And (xm.product_id = ops_request->productlist[prod]->product_id)
		                                  And (xm.updt_cnt = temp_updt_cnt)
		                     with counter
		                     if (curqual = 0)
		                        set error_process = "update crossmatch"
		                        set error_message = "crossmatch not updated"
		                        set failure_occured = "T"
		                     else
		                        update into product_event pe
		                            set
										pe.active_ind             = 0,
										pe.active_status_cd       = ReqData->inactive_status_cd,
		                                pe.active_status_dt_tm    = cnvtdatetime(curdate, curtime3),
		                                pe.active_status_prsnl_id = ReqInfo->updt_id,
		                                pe.updt_cnt               = pe.updt_cnt + 1,
		                                pe.updt_dt_tm             = cnvtdatetime(curdate,curtime3),
		                                pe.updt_task              = reqinfo->updt_task,
		                                pe.updt_id                = reqinfo->updt_id,
		                                pe.updt_applctx           = reqinfo->updt_applctx
		                        plan pe where (pe.product_event_id = temp_prod_event_id)
		                                   And (pe.product_id = ops_request->productlist[prod]->product_id)
		                                      And (pe.event_type_cd = xmtch_event_type_cd)
		                                      And (pe.updt_cnt = temp_pe_updt_cnt)
		                        with counter
		                        if (curqual = 0)
		                           set error_process = "update event"
		                           set error_message = "crossmatch product_event not updated"
		                           set failure_occured = "T"
		                        endif   ;update product event failed
		                     endif   ;update crossmatch
		               endif   ;lock failed
	               endif ;rel_assign_flag = "T"
 				   ; ****************************  Releasing assign **********************************************
 				   if ((failure_occured = "F") and
		                   (ops_request->productlist[prod]->productevent[count1].event_type_cd = assign_event_type_cd))
		                select into "nl:"
                        	a.product_id,
                         	a.product_event_id
		                from assign a
		                plan a where (a.product_event_id = temp_prod_event_id)
		                	and (a.product_id = ops_request->productlist[prod].product_id)
		                    and (a.updt_cnt = temp_updt_cnt)
		                detail
		                	quantity_val = a.cur_assign_qty 		        ;store the quantity xmatched
		                    quantity_iu = a.cur_assign_intl_units
		                with nocounter ,forupdate(a)
 
		                if (curqual != 0)
		                	select into "nl:"
		                    	pe.product_id
		                    from product_event pe
		                    plan pe where (pe.product_event_id = temp_prod_event_id)
		                    	and (pe.product_id = ops_request->productlist[prod].product_id)
		                        and (pe.event_type_cd = assign_event_type_cd)
		                        and (pe.updt_cnt = temp_pe_updt_cnt)
		                    with nocounter , forupdate(pe)
		                endif
 
		                if (curqual = 0)
		                	set error_process = "lock assign/product_event"
		                    set error_message = "assign/product_event not locked"
		                    set failure_occured = "T"
		                else
		                     ;______________________________________ update tables ____________________________________
		                    update into assign a
		                    	set
		                         	a.cur_assign_qty   = if (ops_request->productlist[prod].product_type = "B")
	                                                   		0
	                                elseif (quantity_val <= ops_request->productlist[prod]->productevent[count1].release_qty)
	                                                  		0
	                                                	 else
	                                   (quantity_val - ops_request->productlist[prod]->productevent[count1].release_qty)
	                                                	 endif,
	                          		a.cur_assign_intl_units = if (ops_request->productlist[prod].product_type = "B")
	                                                          	0
	                                    elseif (quantity_iu <= ops_request->productlist[prod]->productevent[count1].release_iu)
	                                                        	0
	                                                     	  else
	                                  (quantity_iu - ops_request->productlist[prod]->productevent[count1].release_iu)
	                                                     	  endif,
		                            a.updt_cnt         = a.updt_cnt + 1,
		                            a.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
		                            a.updt_task        = reqinfo->updt_task,
		                            a.updt_id          = reqinfo->updt_id,
		                            a.updt_applctx     = reqinfo->updt_applctx,
		                            a.active_ind       = if (ops_request->productlist[prod].product_type = "B")
		                                                     0
		                             elseif (quantity_val = ops_request->productlist[prod]->productevent[count1].release_qty)
		                                                     0
		                                                  else
		                                                     1
		                                                  endif,
		                            a.active_status_cd = if (ops_request->productlist[prod].product_type = "B")
		                                                     ReqData->inactive_status_cd
		                               elseif (quantity_val = ops_request->productlist[prod]->productevent[count1].release_qty)
		                                                     ReqData->inactive_status_cd
		                                                  else
		                                                     ReqData->active_status_cd
		                                                  endif,
		                            a.active_status_dt_tm  = cnvtdatetime(curdate, curtime3),
		                            a.active_status_prsnl_id = ReqInfo->updt_id
		                        plan a where (a.product_event_id = temp_prod_event_id)
		                        			  and (a.product_id = ops_request->productlist[prod].product_id)
		                                      and (a.updt_cnt = temp_updt_cnt)
		                        with counter
		                        if (curqual = 0)
			                   		set error_process = "update assign"
		                            set error_message = "assign not updated"
		                            set failure_occured = "T"
		                     	else
		                     	;insert a row into the assign release table
			                     /*
			                     * Retrieve new sequence number for product_event_id
			                     */
			                     	select into "nl:"
			                          seqn        = seq(pathnet_seq,nextval)
			                     	from
			                          dual
			                     	detail
			                          assign_release_id_val   = seqn
			                     	with format, nocounter
			                     	if (curqual = 0)
			                        	set error_process = "insert assign_release_id"
			                        	set error_message = "assign_release_id not generated"
			                        	set failure_occured = "T"
			                     	else
			                     		insert into assign_release ar
			                            set
			                              ar.assign_release_id = assign_release_id_val,
			                              ar.product_id        = ops_request->productlist[prod].product_id,
			                              ar.product_event_id  = temp_prod_event_id,
			                              ar.release_reason_cd = ops_request->productlist[prod].productevent[count1].release_reason_cd,
			                              ar.release_dt_tm     = cnvtdatetime(curdate,curtime3),
			                              ar.release_prsnl_ID  = reqinfo->updt_id,
			                              ar.release_qty       = if (ops_request->productlist[prod].product_type = "B")
			                                                        0
			                                                     else
			                                       ops_request->productlist[prod]->productevent[count1].release_qty
			                                                     endif,
			                              ar.release_intl_units = if (ops_request->productlist[prod].product_type = "B")
			                                                         0
			                                                      else
			                                     ops_request->productlist[prod]->productevent[count1].release_iu
			                                                      endif,
			                              ar.updt_cnt          = 0,
			                              ar.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
			                              ar.updt_task        = reqinfo->updt_task,
			                              ar.updt_id          = reqinfo->updt_id,
			                              ar.updt_applctx     = reqinfo->updt_applctx,
			                              ar.active_ind       = 1,
			                              ar.active_status_cd = ReqData->active_status_cd,
			                              ar.active_status_dt_tm  = cnvtdatetime(curdate, curtime3),
			                              ar.active_status_prsnl_id = ReqInfo->updt_id
			                            with nocounter
			                            ;update the product_event table
			                            if (curqual = 0)
			                        		set error_process = "insert assign_release row"
			                           		set error_message = "assign_release row not updated"
			                           		set failure_occured = "T"
			                        	else
		                     				update into product_event pe
				                            set
				                                pe.active_ind = if (ops_request->productlist[prod]->product_type = "B")
				                                                     0
				                             elseif (quantity_val = ops_request->productlist[prod]->productevent[count1].release_qty)
				                                                     0
				                                                  else
				                                                     1
				                                                  endif,
				                                pe.active_status_cd = if (ops_request->productlist[prod]->product_type = "B")
				                                                         ReqData->inactive_status_cd
				                                elseif (quantity_val = ops_request->productlist[prod]->productevent[count1].release_qty)
				                                                         ReqData->inactive_status_cd
				                                                      else
				                                                         ReqData->active_status_cd
				                                                      endif,
				                                pe.active_status_dt_tm    = cnvtdatetime(curdate, curtime3),
				                                pe.active_status_prsnl_id = ReqInfo->updt_id,
				                                pe.updt_cnt               = pe.updt_cnt + 1,
				                                pe.updt_dt_tm             = cnvtdatetime(curdate,curtime3),
				                                pe.updt_task              = reqinfo->updt_task,
				                                pe.updt_id                = reqinfo->updt_id,
				                                pe.updt_applctx           = reqinfo->updt_applctx
				                            plan pe where (pe.product_event_id = temp_prod_event_id)
				                            			   and (pe.product_id = ops_request->productlist[prod]->product_id)
				                               			   and (pe.event_type_cd = assign_event_type_cd)
				                           				   and (pe.updt_cnt = temp_pe_updt_cnt)
				                            with counter
				                        	if (curqual = 0)
				                           		set error_process = "update event"
				                           		set error_message = "assign product_event not updated"
				                           		set failure_occured = "T"
				                        	endif   ;update product event failed
				                     	endif   ;insert assign release
				          			endif ; insert assign release id
				          		endif ; update assign
		                  endif   ;lock failed
		           endif
		           ; ****************************  Releasing In Progress *****************************************
	               if (failure_occured = "F" and
	                   ops_request->productlist[prod]->productevent[count1].event_type_cd = inprogress_event_type_cd)
	                   ; Inactivate the In Progress event
	                   call CHG_PRODUCT_EVENT
	                   (
	                   		temp_prod_event_id,
	                   		cnvtdatetime(curdate, curtime3),
	                   		ReqInfo->updt_id,
	                   		0,
	                   		0,
	                   		ReqData->inactive_status_cd,
	                   		cnvtdatetime(curdate, curtime3),
	                   		ReqInfo->updt_id,
	                   		temp_pe_updt_cnt,
	                   		1,
	                   		0
	                   	)
 
	                   	if (curqual = 0)
	                   		set error_process = "update event"
	                   		set error_message = "in progress product_event not updated"
	                   		set failure_occured = "T"
	                   	endif
	               endif
	             endif
	          endfor
 
               ;**********************************    CHECK FOR AVAILABLE   ****************************
               If ((failure_occured = "F")
                   and  (((active_quar = "F") and (active_assign = "F" or (active_assign = "T" and active_xm = "F"))
                          and (active_uncfrm = "F") and (multiple_xm = "F") and (multiple_inprog = "F")
                          and (active_autologous = "F") and (active_directed = "F")
                          and (active_shipped = "F") and (active_intransit = "F")
                          and (ops_request->productlist[prod]->product_type = "B")
                         )
                         or (ops_request->productlist[prod]->product_type = "D")
                        )
                   and (active_avail = "F")
                   and (ops_request->productlist[prod].status = "S")
                  )
                  ;add available event
                  call ADD_PRODUCT_EVENT
                       (
                        /* product_id               */ ops_request->productlist[prod]->product_id,
                        /* person_id                */ 0,
                        /* encntr_id                */ 0,
                        /* order_id                 */ 0,
                        /* bb_result_id             */ 0,
                        /* event_type_cd            */ avail_event_type_cd,
                        /* event_dt_tm              */ cnvtdatetime(curdate,curtime3),
                        /* event_prsnl_id           */ ReqInfo->updt_id,
                        /* event_status_flag        */ 0,
                        /* override_ind             */ 0,
                        /* override_reason_cd       */ 0,
                        /* related_product_event_id */ 0,
                        /* active_ind               */ 1,
                        /* active_status_cd         */ ReqData->active_status_cd,
                        /* active_status_dt_tm      */ cnvtdatetime(curdate, curtime3),
                        /* active_status_prsnl_id   */ ReqInfo->updt_id
                        )
                  if (curqual = 0)
                     set error_process = "add product_event"
                     set error_message = "available event not added"
                     set failure_occured = "T"
                  endif
               endif
 
               if ((failure_occured = "F") and (ops_request->productlist[prod]->product_type = "D"))
               		set der_release_qty = 0
               		set der_release_IU = 0
               		; for derivatives, sum the quantity of all released events
                    for (count2 = 1 to nbr_of_events)
                    	if (ops_request->productlist[prod]->productevent[count2].event_type_cd = assign_event_type_cd)
                    		set der_release_qty = der_release_qty + ops_request->productlist[prod]->productevent[count2].release_qty
                    		set der_release_IU = der_release_IU + ops_request->productlist[prod]->productevent[count2].release_iu
                     	endif
     	   			endfor
 
                    ;add all the released quantity to current available quantity
                    ;if derivative update into the derivative cur_avail_qty and not quarantined
                    update into derivative der
                    	set
                        	der.cur_avail_qty = der.cur_avail_qty + der_release_qty,
                        	der.cur_intl_units = der.cur_intl_units + der_release_IU,
                            der.updt_cnt = der.updt_cnt + 1,
                            der.updt_dt_tm = cnvtdatetime(curdate,curtime3),
                            der.updt_task  = reqinfo->updt_task,
                            der.updt_id    = reqinfo->updt_id,
                            der.updt_applctx = reqinfo->updt_applctx
                    plan der where (der.product_id = ops_request->productlist[prod]->product_id)
                                    and (der.updt_cnt = ops_request->productlist[prod]->der_updt_cnt)
                    with counter
                    if (curqual = 0)
                    	set error_process = "updt derivative"
                        set error_message = "available qty not updated"
                        set failure_occured = "T"
                    endif   ;udpate derivative cur_avail_qty failed
               endif   ;product a derivative
 
               /*********************************************   UNLOCK PORDUCT ***************************************************/
               /* This event will occur for every product in the request                                                        */
               /*****************************************************************************************************************/
               ;see if the product has other crossmatches/assignments associated with it that are to be released
               ;if it does do not unlock the product
               if (ops_request->productlist[prod].status = "S")
                  ;unlock the product even if a failure occured before this point
                     select into "nl:"
                        p.product_id
                     from product p
                     plan p  where (p.product_id = ops_request->productlist[prod]->product_id)
                                   and (p.updt_cnt = ops_request->productlist[prod]->p_updt_cnt)
                                   and (p.locked_ind = 1)
                     detail
                          call echo (build("locked_ind: ",p.locked_ind))
                          call echo (build("update_cnt: ",p.updt_cnt))
                     with nocounter, forupdate(p)
                     if (curqual = 0)
                        set error_process = "update product"
                        set error_message = "product not unlocked"
                        set failure_occured = "T"
                     else
                        update into product p
                            set p.locked_ind        = 0,
                                p.updt_cnt          = p.updt_cnt + 1,
                                p.updt_dt_tm        = cnvtdatetime(curdate, curtime3),
                                p.updt_id           = ReqInfo->updt_id,
                                p.updt_task         = ReqInfo->updt_task,
                                p.updt_applctx      = ReqInfo->updt_applctx
                        plan p where (p.product_id = ops_request->productlist[prod]->product_id)
                                     and (p.updt_cnt = ops_request->productlist[prod]->p_updt_cnt)
                                     and (p.locked_ind = 1)
                        with counter
                        if (curqual = 0)
                           set error_process = "update product"
                           set error_message = "product not unlocked"
                           set failure_occured = "T"
                        endif  ;update failed
                     endif   ;lockrow for update failed
                endif   ;(ops_request->productlist[prod].status = "S")
 
                ;commit the changes if a failure did not occur other wise roll back the chages
                if ((failure_occured = "F") and (ops_request->productlist[prod].status = "S"))
                  set reply->status_data->status = "S"
                  set ops_request->productlist[prod].err_message = " "
                  set reply->status_data->subeventstatus[prod]->OperationName = "Complete"
                  set reply->status_data->subeventstatus[prod]->OperationStatus = "S"
                  set reply->status_data->subeventstatus[prod]->TargetObjectName = "Tables Updated"
                  set reply->status_data->subeventstatus[prod]->TargetObjectValue = "S"
                  commit
                  set success_cnt = success_cnt + 1
                else
                  rollback
                  set ops_request->productlist[prod].status = "F"
                  ;copy the error message if one is not already present "product issued"
                  if (ops_request->productlist[prod].err_message  <= " ")
                     set ops_request->productlist[prod].err_message = error_message
                  endif
                  set reply->status_data->subeventstatus[prod]->OperationName = error_process
                  set reply->status_data->subeventstatus[prod]->OperationStatus = "F"
                  set reply->status_data->subeventstatus[prod]->TargetObjectName = error_message
                  set reply->status_data->subeventstatus[prod]->TargetObjectValue = "F"
                endif
           endfor
        endif   ;(CNVTUPPER(batch_field) = "UPDATE") end of if UPDATE was the batch_field

%i cclsource:bbt_add_product_event.inc
END             ; end subroutine ADD_PRODUCT_EVENT
%i cclsource:bbt_chg_product_event.inc
END             ; end subroutine CHG_PRODUCT_EVENT
/****************************************************  Wrap Up Information ********************************************/
if  (success_cnt < nbr_to_update)
   ;updated to "S" per cerlsj to run in operations application
   ;set reply->status_data->status = "P"
   set reply->status_data->status = "S"
else
   set reply->status_data->status = "S"
endif

 
/**********************************************************************************************************************/
/**********************************************************************************************************************/
/*  Print out the results of the script                                                                               */
/**********************************************************************************************************************/
/**********************************************************************************************************************/

;variables for fomatting output to make sure it fits on the page
set number = "                    "
set sub_number = fillstring(5, " ")		;012
set med_num = "                   "
set pat_name = "                                     "
set prod_num = "                         "
set status= fillstring(20, " ")
set prod_disp = "                                     "
set line = fillstring(125, "_")		;012
set cur_owner_area_disp = fillstring(40," ")
set cur_inv_area_disp = fillstring(40, " ")
set msg_error = fillstring(30, " ")
set reason = fillstring(30, " ")
set temp_string = fillstring(15, " ")
 
set count1 = cnvtint(size(ops_request->productlist,5))
 
 /* Retrieve Institution name */
;001   Set Institution_name = GET_INST_NAME(0)
 
set reply->status_data->status = "F"
set select_ok_ind = 0
 
set rpt_cnt = 0

execute cpm_create_file_name_logical "bbt_batchrelease", "txt", "x"   ;009

select into cpm_cfn_info->file_name_logical							;009
      per.person_id,
      per.name_full_formatted,
      pra.person_id,
      pra.alias,
      p.product_id,
      ord.accession,
      c_prod.display,
      sort1 = if (sort_field > " ")
                if (sort_field = "NAME")
                        per.name_full_formatted
                elseif (sort_field = "MRN")
                        pra.alias
                ;elseif (sort_field = "ABORH")                          ;not used commented out by JS
                ;        concat(uar_get_code_display(bp.cur_abo_cd), " ", uar_get_code_display(bp.cur_rh_cd))
                else
                        per.name_full_formatted                         ; if enter bad sort spec, default by NAME, added by JS
                endif
              else
                        per.name_full_formatted
              endif,

      sort2 = if (sort_field > " ")
                if (sort_field = "NAME")
                   " "
                elseif (sort_field = "MRN")
                   per.name_full_formatted
                else
                   " "
                endif
              else
                   " "
              endif
 
from
      product p,
      product_event pe,
      (dummyt d_pra with seq = 1),
      person_alias pra,
      (dummyt d_ord with seq = 1),
      accession_order_r ord,
      person per,
      code_value c_prod,
      (dummyt d1 with seq = 1),
      (dummyt d2 with seq = 1),
      (dummyt d_ar with seq = value(count1))
 
plan d_ar
join p where p.product_id = ops_request->productlist[d_ar.seq]->product_id
join pe where p.product_id = pe.product_id  and
              expand(pe_index, 1, size(ops_request->productlist[d_ar.seq].productevent, 5), pe.product_event_id,
					 ops_request->productlist[d_ar.seq].productevent[pe_index].product_event_id)
join (d1 where d1.seq = 1
	join per where pe.person_id = per.person_id)
join (d2 where d2.seq = 1
	join c_prod where c_prod.code_set = 1604 and p.product_cd = c_prod.code_value)
join (d_pra where d_pra.seq = 1
	join pra where pe.person_id = pra.person_id and (pra.person_alias_type_cd = mrn_code and pra.active_ind != 0))
join (d_ord where d_ord.seq = 1
	join ord where pe.order_id = ord.order_id and ord.primary_flag = 0)
 
order by
        p.cur_owner_area_cd,
        p.cur_inv_area_cd,
        sort1,
        sort2,
        per.person_id,
        p.product_nbr,
        p.product_id,
        pe.product_event_id
 
head report
        cur_owner_area_cd_hd = p.cur_owner_area_cd
        cur_inv_area_cd_hd = p.cur_inv_area_cd
        cur_owner_area_disp = uar_get_code_display(p.cur_owner_area_cd)
        cur_inv_area_disp = uar_get_code_display(p.cur_inv_area_cd)
       select_ok_ind = 0
       formatted_acc = fillstring(25, " ")

head page
      row 0
;;001      col   1, Institution_name  ;"St. John's Health System",
      call center(captions->rpt_batch_crossmatch,1,125)						;;007
      col 104, captions->as_of_time,												;;007
      col 119, request->ops_date  "@TIMENOSECONDS;;M",
      row + 1
      ;call center("(by Patient Name)",1,132)
      col 104, captions->as_of_date,   											;;007
      col 119, request->ops_date "@DATECONDENSED;;d",
      ;row + 1                           ;001
      ;col 111, "Prepared:",             ;001
      ;col 123, curdate "@DATECONDENSED;;d",
 
%i cclsource:bbt_print_location_info.inc
      SAVE_ROW = ROW
      ROW 1
      call center(rpt_mode,1,125)
      row SAVE_ROW
      row + 1
		col  1, captions->blood_bank_owner,											;;007
      col 19, cur_owner_area_disp,
;;001      col 116, "Prepared:",
;;001      col 126, curdate "@DATECONDENSED;;d",         ;"mm/dd/yy;;d",
      row + 1
      col  1, captions->inventory_area,											;;007
      col 17, cur_inv_area_disp,
      row + 1
      col 1, captions->prepared,														;;007
      col 11, curdate "@DATECONDENSED;;d",
      row + 3
      call center(captions->unit_number,58,82)			;012					;;007
      call center(captions->status,98,111)				;012					;;007
      row + 1
      call center(captions->medical_number,1,19)		;012					;;007
      call center(captions->patient_name,21,56)			;012					;;007
      call center(captions->accession_number,58,82)		;012					;;007
      call center(captions->product,84,96)				;012					;;007
      call center(captions->reason,98,111)
      call center(captions->xm_exp_date,113,125)		;012					;;007
      row + 1
      col   1, "-------------------"
      col  21, "------------------------------------"	;012
      col  58, "-------------------------"				;012
      col  84, "-------------"							;012
      col  98, "--------------"							;012
      col 113, "-------------"							;012
      row + 2

head p.cur_owner_area_cd
        if (p.cur_owner_area_cd != cur_owner_area_cd_hd)
            cur_owner_area_disp = uar_get_code_display(p.cur_owner_area_cd)
            cur_owner_area_cd_hd = p.cur_owner_area_cd
        endif

head p.cur_inv_area_cd
        if (p.cur_inv_area_cd != cur_inv_area_cd_hd)
            cur_inv_area_disp = uar_get_code_display(p.cur_inv_area_cd)
            cur_inv_area_cd_hd = p.cur_inv_area_cd
            break
        endif
 
head per.person_id
      med_num =  cnvtalias(pra.alias, pra.alias_pool_cd)
      pat_name = per.name_full_formatted
 
head p.product_id
	 ;make sure there is enough room to print the information
	 if (row >= 58)
         break
     endif
 
     if (ops_request->productlist[d_ar.seq].product_id > 0.0 and product_count > 0)
     	if (ops_request->productlist[d_ar.seq].product_type = "B")
	        number = p.product_nbr
	        sub_number = p.product_sub_nbr
	        prod_num = CONCAT(trim(ops_request->productlist[d_ar.seq].supp_prefix), TRIM(number,3)," ",TRIM(sub_number,3))
	    else
	    	prod_num = p.product_nbr
	    endif
 
        prod_disp = c_prod.display
 		col   1,  med_num,
        col  21, pat_name
     elseif (count1 <= 1)
        ;no crossmatches to release at this time
        row + 1
        call center(captions->rpt_no_crossmatches,1,125)	;012					;;007
     endif
 
head pe.product_event_id
	;make sure there is enough room to print the information
	if (row >= 58)
         break
    endif
	reason = " "
	pos = locateval(index, 1 , size(ops_request->productlist[d_ar.seq].productevent, 5), pe.product_event_id,
	                ops_request->productlist[d_ar.seq].productevent[index].product_event_id)
	; display the status as "XM Released" or "Assign Released" or "Inprog Released" based on the event type
	if (pos > 0)
		if ((ops_request->productlist[d_ar.seq].status = "S") AND (CNVTUPPER(batch_field) = "UPDATE"))
			status = "Released"
			temp_string = " "
		 	if (pe.event_type_cd = xmtch_event_type_cd)
		 		temp_string = "XM"
		 	elseif(pe.event_type_cd = assign_event_type_cd)
		 		temp_string = "Assign"
		 	elseif(pe.event_type_cd = inprogress_event_type_cd)
		 		temp_string = "Inprog"
		 	endif
 
		 	status = concat (temp_string, ' ',status)
			reason = uar_get_code_display(ops_request->productlist[d_ar.seq].productevent[pos].release_reason_cd)
	     	reason = substring(1,15,reason)
 	    else
	    	status = "Not Released"
	    	if (ops_request->productlist[d_ar.seq]->err_message > " ")
            	reason = ops_request->productlist[d_ar.seq]->err_message
            endif
		endif
		col  58, prod_num,
		col  84, prod_disp,
		col  97, status,
		col 113, ops_request->productlist[d_ar.seq].productevent[pos].xm_exp_dt_tm "@DATETIMECONDENSED;;d"
		row + 1
		formatted_acc = cnvtacc(ord.accession)
	    col 58, formatted_acc,
	    col 97, reason
	    row + 1
	endif
 
detail
     row + 0
 
foot page
      row  59
      col   1, line,
      row + 1
      col   1, captions->report_id,														;;007
      col  60, captions->rpt_page,														;;007
      col  67, curpage "###",
      col 101, captions->printed,														;;007
      col 110, curdate "@DATECONDENSED;;d"
      col 119, curtime "@TIMENOSECONDS;;M"
 
 
foot report
      row  62
      col  53, captions->end_of_report													;;007
      select_ok_ind = 1

with  nocounter,
      outerjoin (d1),
      outerjoin (d2),
      outerjoin (d_pra),
      dontcare (pra),
      outerjoin (d_ord),
      maxrow = 63,
      compress,
      nolandscape,
      nullreport,
      expand = 1
 
 
set rpt_cnt = rpt_cnt +1
set stat = alterlist(reply->rpt_list, rpt_cnt)
set reply->rpt_list[rpt_cnt].rpt_filename = cpm_cfn_info->file_name_path   ;009

SET SPOOL = value(reply->rpt_list[rpt_cnt].rpt_filename) VALUE(request->Output_Dist) ;WITH NOTIFY
 
if (select_ok_ind = 1)
    set reply->status_data->status = "S"
endif
#exit_script
end go

;Generated by GNU enscript 1.6.4.
