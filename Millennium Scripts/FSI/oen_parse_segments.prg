1)translate oen_parse_segments go
;*** Generated by TRANSLATE, verify before re-including (Debug:N,Optimize:N,DiffEnd:N,Rdb:N) ***
DROP PROGRAM oen_parse_segments :dba GO
CREATE PROGRAM oen_parse_segments :dba
 SET trace = recpersist
 FREE SET saved_seg
 RECORD saved_seg (
   1 status = i4
   1 seg [* ]
     2 seg_name = vc
     2 full_seg = vc
     2 field [* ]
       3 field_value = vc
       3 repeat [* ]
         4 repeat_value = vc
         4 comp [* ]
           5 comp_value = vc
           5 sub_comp [* ]
             6 sub_value = vc
 )
 SET trace = norecpersist
 RECORD tmp (
   1 msg = vc
   1 comp_count = i4
   1 segment [* ]
     2 seg_name = vc
 )
 SET trace = debug
 SET tmp->comp_count = 0
 SET tmp->msg = request->message
 IF ((size (trim (tmp->msg ) ) = 0 ) )
  CALL echo ("Zero length message passed to parse_segment script" )
  SET saved_seg->status = - (1 )
  GO TO end_of_script
 ENDIF
 SET segs = size (request->segs ,5 )
 IF ((segs = 0 ) )
  CALL echo ("No segment names passed in" )
  SET saved_seg->status = - (1 )
  GO TO end_of_script
 ELSE
  SET stat = alterlist (tmp->segment ,segs )
 ENDIF
 FOR (x = 1 TO segs )
  SET tmp->segment[x ].seg_name = request->segs[x ].seg_name
  CALL echo (build ("Seg_name=" ,tmp->segment[x ].seg_name ) )
 ENDFOR
 FREE SET skip_step
 FOR (x = 1 TO segs )
  CALL echo (build ("Segment Loop #" ,x ) )
  SET skip_step = 0
  IF ((size (trim (tmp->segment[x ].seg_name ) ) != 0 ) )
   SET stat = alterlist (saved_seg->seg ,x )
   SET saved_seg->seg[x ].seg_name = tmp->segment[x ].seg_name
   IF ((tmp->segment[x ].seg_name = "MSH" ) )
    FREE SET cur_string
    SET cur_string = trim (tmp->msg )
    FREE SET seperator
    SET seperator = tmp->segment[x ].seg_name
    CALL find_segment (cur_string ,seperator )
   ELSE
    FREE SET cur_string
    SET cur_string = trim (tmp->msg )
    FREE SET seperator
    SET seperator = concat (char (13 ) ,tmp->segment[x ].seg_name )
    CALL echo ("Executing begin_find_segment" )
    CALL find_segment (cur_string ,seperator )
   ENDIF
   IF ((saved_seg->seg[x ].full_seg != "Empty" ) )
    FREE SET cur_string2
    SET cur_string2 = trim (saved_seg->seg[x ].full_seg )
    CALL echo ("Executing begin_find_fields" )
    CALL find_fields (cur_string2 ,"|" )
   ELSE
    SET skip_step = 1
   ENDIF
   IF ((skip_step != 1 ) )
    FOR (z = 1 TO size (saved_seg->seg[x ].field ,5 ) )
     FREE SET field
     SET field = trim (saved_seg->seg[x ].field[z ].field_value )
     CALL echo ("Executing find_repeat" )
     CALL find_repeat (field ,"~" )
    ENDFOR
   ENDIF
   IF ((skip_step != 1 ) )
    SET stat = findstring ("^" ,saved_seg->seg[x ].full_seg )
    IF ((stat != 0 ) )
     FOR (z = 1 TO size (saved_seg->seg[x ].field ,5 ) )
      FOR (a = 1 TO size (saved_seg->seg[x ].field[z ].repeat ,5 ) )
       FREE SET repeat1
       SET repeat1 = trim (saved_seg->seg[x ].field[z ].repeat[a ].repeat_value )
       CALL echo ("Executing find_comp" )
       CALL find_comp (repeat1 ,"^" )
      ENDFOR
     ENDFOR
    ENDIF
   ENDIF
   IF ((skip_step != 1 ) )
    SET stat = findstring ("&" ,saved_seg->seg[x ].full_seg )
    IF ((stat != 0 ) )
     FOR (z = 1 TO size (saved_seg->seg[x ].field ,5 ) )
      FOR (a = 1 TO size (saved_seg->seg[x ].field[z ].repeat ,5 ) )
       FOR (b = 1 TO size (saved_seg->seg[x ].field[z ].repeat[a ].comp ,5 ) )
        FREE SET repeat1
        SET repeat1 = trim (saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].comp_value )
        CALL echo ("Executing find_comp" )
        CALL find_comp (repeat1 ,"&" )
       ENDFOR
      ENDFOR
     ENDFOR
    ENDIF
   ENDIF
  ELSE
   SET saved_seg->status = 0
   GO TO end_of_script
  ENDIF
 ENDFOR
 GO TO end_of_script
 SUBROUTINE  find_segment (cur_string ,seperator )
  CALL echo ("Starting find_segment" )
  SET stat = findstring (seperator ,cur_string ,1 )
  SET pos1 = findstring (seperator ,cur_string ,1 )
  IF ((pos1 = 0 ) )
   SET saved_seg->seg[x ].full_seg = "Empty"
   RETURN
  ENDIF
  SET pos2 = findstring (char (13 ) ,cur_string ,(pos1 + 1 ) )
  IF ((pos2 = 0 ) )
   SET pos2 = size (trim (cur_string ) )
  ENDIF
  SET saved_seg->seg[x ].full_seg = substring ((pos1 + 1 ) ,(pos2 - pos1 ) ,cur_string )
  CALL echo ("end_find_segment" )
 END ;Subroutine
 SUBROUTINE  find_fields (cur_string2 ,seperator2 )
  CALL echo ("Starting find_fields" )
  FREE SET cur_string3
  FREE SET seperator3
  SET cur_string3 = trim (cur_string2 )
  SET seperator3 = trim (seperator2 )
  CALL echo ("Executing count_components" )
  CALL count_components (cur_string3 ,seperator3 )
  IF ((tmp->comp_count != 0 ) )
   SET stat = alterlist (saved_seg->seg[x ].field ,tmp->comp_count )
   SET start_pos = 1
   FOR (y = 1 TO tmp->comp_count )
    SET true_pos2 = 0
    SET pos1 = findstring (seperator2 ,cur_string2 ,start_pos )
    IF ((pos1 = 0 ) )
     RETURN
    ENDIF
    SET pos2 = findstring (seperator2 ,cur_string2 ,(pos1 + 1 ) )
    IF ((pos2 = 0 ) )
     SET pos2 = size (trim (cur_string2 ) )
     SET true_pos2 = 1
    ENDIF
    SET start_pos = pos2
    IF (((pos2 - pos1 ) > 0 ) )
     IF ((pos2 = size (trim (cur_string2 ) ) )
     AND (true_pos2 = 1 ) )
      SET saved_seg->seg[x ].field[y ].field_value = substring ((pos1 + 1 ) ,(pos2 - pos1 ) ,
       cur_string2 )
     ELSE
      SET saved_seg->seg[x ].field[y ].field_value = substring ((pos1 + 1 ) ,((pos2 - pos1 ) - 1 ) ,
       cur_string2 )
     ENDIF
    ELSE
     SET saved_seg->seg[x ].field[y ].field_value = ""
    ENDIF
   ENDFOR
  ELSE
   RETURN
  ENDIF
  CALL echo ("end_find_fields" )
 END ;Subroutine
 SUBROUTINE  find_repeat (field ,seperator4 )
  CALL echo ("Starting find_repeat" )
  FREE SET cur_string3
  FREE SET seperator3
  SET cur_string3 = trim (field )
  SET seperator3 = trim (seperator4 )
  CALL echo ("Executing count_components" )
  CALL count_components (cur_string3 ,seperator3 )
  IF ((tmp->comp_count != 0 ) )
   SET stat = alterlist (saved_seg->seg[x ].field[z ].repeat ,(tmp->comp_count + 1 ) )
   SET start_pos = 1
   SET pos1 = findstring (seperator4 ,field ,start_pos )
   SET saved_seg->seg[x ].field[z ].repeat[1 ].repeat_value = substring (start_pos ,(pos1 -
    start_pos ) ,field )
   FOR (y = 2 TO (tmp->comp_count + 1 ) )
    SET true_pos2 = 0
    SET pos1 = findstring (seperator4 ,field ,start_pos )
    IF ((pos1 = 0 ) )
     GO TO end_find_repeat
    ENDIF
    SET pos2 = findstring (seperator4 ,field ,(pos1 + 1 ) )
    IF ((pos2 = 0 ) )
     SET pos2 = size (trim (field ) )
     SET true_pos2 = 1
    ENDIF
    SET start_pos = pos2
    IF (((pos2 - pos1 ) > 0 ) )
     IF ((pos2 = size (trim (field ) ) )
     AND (true_pos2 = 1 ) )
      SET saved_seg->seg[x ].field[z ].repeat[y ].repeat_value = substring ((pos1 + 1 ) ,(pos2 -
       pos1 ) ,field )
     ELSE
      SET saved_seg->seg[x ].field[z ].repeat[y ].repeat_value = substring ((pos1 + 1 ) ,((pos2 -
       pos1 ) - 1 ) ,field )
     ENDIF
    ELSE
     SET saved_seg->seg[x ].field[z ].repeat[y ].repeat_value = ""
    ENDIF
   ENDFOR
  ELSE
   SET stat = alterlist (saved_seg->seg[x ].field[z ].repeat ,1 )
   SET saved_seg->seg[x ].field[z ].repeat[1 ].repeat_value = saved_seg->seg[x ].field[z ].
   field_value
  ENDIF
  CALL echo ("end_find_repeat" )
 END ;Subroutine
 SUBROUTINE  find_comp (repeat1 ,seperator5 )
  CALL echo ("Starting find_comp" )
  FREE SET cur_string3
  FREE SET seperator3
  SET cur_string3 = trim (repeat1 )
  SET seperator3 = trim (seperator5 )
  CALL echo ("Executing count_components" )
  CALL count_components (cur_string3 ,seperator3 )
  IF ((tmp->comp_count != 0 ) )
   SET stat = alterlist (saved_seg->seg[x ].field[z ].repeat[a ].comp ,(tmp->comp_count + 1 ) )
   SET start_pos = 1
   SET pos1 = findstring (seperator5 ,repeat1 ,start_pos )
   SET saved_seg->seg[x ].field[z ].repeat[a ].comp[1 ].comp_value = substring (start_pos ,(pos1 -
    start_pos ) ,repeat1 )
   FOR (y = 2 TO (tmp->comp_count + 1 ) )
    SET true_pos2 = 0
    SET pos1 = findstring (seperator5 ,repeat1 ,start_pos )
    IF ((pos1 = 0 ) )
     RETURN
    ENDIF
    SET pos2 = findstring (seperator5 ,repeat1 ,(pos1 + 1 ) )
    IF ((pos2 = 0 ) )
     SET pos2 = size (trim (repeat1 ) )
     SET true_pos2 = 1
    ENDIF
    SET start_pos = pos2
    IF (((pos2 - pos1 ) > 0 ) )
     IF ((pos2 = size (trim (repeat1 ) ) )
     AND (true_pos2 = 1 ) )
      SET saved_seg->seg[x ].field[z ].repeat[a ].comp[y ].comp_value = substring ((pos1 + 1 ) ,(
       pos2 - pos1 ) ,repeat1 )
     ELSE
      SET saved_seg->seg[x ].field[z ].repeat[a ].comp[y ].comp_value = substring ((pos1 + 1 ) ,((
       pos2 - pos1 ) - 1 ) ,repeat1 )
     ENDIF
    ELSE
     SET saved_seg->seg[x ].field[z ].repeat[a ].comp[y ].comp_value = ""
    ENDIF
   ENDFOR
  ENDIF
  CALL echo ("end_find_comp" )
 END ;Subroutine
 SUBROUTINE  find_subcomp (comp ,seperator6 )
  CALL echo ("Starting find_subcomp" )
  FREE SET cur_string3
  FREE SET seperator3
  SET cur_string3 = trim (comp )
  SET seperator3 = trim (seperator6 )
  CALL echo ("Executing count_components" )
  CALL count_components (cur_string3 ,seperator3 )
  IF ((tmp->comp_count != 0 ) )
   SET stat = alterlist (saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].sub_comp ,(tmp->comp_count
    + 1 ) )
   SET start_pos = 1
   SET pos1 = findstring (seperator6 ,comp ,start_pos )
   SET saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].sub_comp[1 ].sub_value = substring (
    start_pos ,(pos1 - start_pos ) ,field )
   FOR (y = 2 TO (tmp->comp_count + 1 ) )
    SET true_pos2 = 0
    SET pos1 = findstring (seperator6 ,comp ,start_pos )
    IF ((pos1 = 0 ) )
     RETURN
    ENDIF
    SET pos2 = findstring (seperator6 ,comp ,(pos1 + 1 ) )
    IF ((pos2 = 0 ) )
     SET pos2 = size (trim (comp ) )
     SET true_pos2 = 1
    ENDIF
    SET start_pos = pos2
    IF (((pos2 - pos1 ) > 0 ) )
     IF ((pos2 = size (trim (comp ) ) )
     AND (true_pos2 = 1 ) )
      SET saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].sub_comp[y ].sub_value = substring ((pos1
       + 1 ) ,(pos2 - pos1 ) ,comp )
     ELSE
      SET saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].sub_comp[y ].sub_value = substring ((pos1
       + 1 ) ,((pos2 - pos1 ) - 1 ) ,comp )
     ENDIF
    ELSE
     SET saved_seg->seg[x ].field[z ].repeat[a ].comp[b ].sub_comp[y ].sub_value = ""
    ENDIF
   ENDFOR
  ENDIF
  CALL echo ("end_find_subcomp" )
 END ;Subroutine
 SUBROUTINE  count_components (cur_string3 ,seperator3 )
  CALL echo ("Starting count_components" )
  SET tmp->comp_count = 0
  SET stat = 0
  SET start_pos = 1
  SET stat = findstring (seperator3 ,cur_string3 ,start_pos )
  IF ((stat != 0 ) )
   SET start_pos = (stat + 1 )
   SET tmp->comp_count = 1
   WHILE ((stat != 0 )
   AND (start_pos <= size (cur_string3 ) ) )
    SET stat = findstring (seperator3 ,cur_string3 ,start_pos )
    IF ((stat != 0 ) )
     SET start_pos = (stat + 1 )
     SET tmp->comp_count = (tmp->comp_count + 1 )
    ENDIF
   ENDWHILE
  ENDIF
  CALL echo (build ("End_count_components, count=" ,tmp->comp_count ) )
 END ;Subroutine
#end_of_script
END GO
1)

190910:104929 B134316_DVD1              Cost 0.00 Cpu 0.00 Ela 0.00 Dio   0 O0M0R0 P1R0