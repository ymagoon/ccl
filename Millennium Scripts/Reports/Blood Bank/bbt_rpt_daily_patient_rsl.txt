 ;;Solution_Test/script/PathNet -- BB Transfusion/Bbt_Reportselection/bbt_rpt_daily_patient_rsl.prg Turn on black mode

/*****************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-2007 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
   ***************************************************************************/
 
/*****************************************************************************
 
        Source file name:       BBT_RPT_DAILY_PATIENT_RSL.PRG
        Object name:            bbt_rpt_daily_patient_rsl.prg
        Request #:              225087
 
        Product:                Blood Bank
        Product Team:           BBT
        HNA Version:            500
        CCL Version:            4.0
 
        Program purpose:
 
        Tables read:            result_event
                                perform_result
                                result
                                result_comment
                                person
                                orders
                                task_assay_cd
                                person_alias
                                discrete_task_assay
                                prsnl
                                accession
                                accession_order_r
                                data_map
                                resource_group
 
        Tables updated:         none
 
        Executing from:         Blood Bank Reports
 
        Special Notes:          n/a
 
******************************************************************************/
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;     000 11/18/96 Linda DeJong         Initial Release                     *
;     001 03/07/97 Jon Weekes           Modified to retrieve alias from
;                                       encntr_alias instead of
;                                       person_alias
;     002 04/07/98 Matt Benson          Modified to retrieve Institution
;                                       name from preferences
;     003 12/18/98 Jose Suarez          Added logic to print the location name                                *
;                                       and address.  Added the address_location_cd to request.               *
;                                       Added bbt_get_location_info.inc                                       *
;                                       Added bbt_print_location_info.inc                                     *
;     004 05/11/99 Matt Benson          Made UAR changes                    *
;     005 05/21/99 Jose Suarez          Changed CER_TEMP to CER_PRINT       *
;     006 09/02/99 Badari Kopparapu     Modified to use ops_date for computing
;                                       the report date range.              *
;     007 09/08/99 Badari Kopparapu     Modified to parse for SVC[ , ,] in  *
;                                       the batch_selection field to retrieve
;                                       service resource codes when run from*
;                                       Operations.                         *
;     008 11/10/99 Jose Suarez          Enhancement when running from ops   *
;                                       added bbt_ops_parm_passed.inc       *
;     009 01/07/00 Doug Saus            Performance enhancements
;     010 01/24/00 Doug Saus            Added support of date/time assay result type
;     011 10/24/00 Wally Wester         Correction to get result comments and
;                                       result notes to print on the report.
;                                       Added MEMSORT control option.
;     012 08/10/00 Lawrence Dsouza      internationalized date and time     *
;     013 02/16/01 Chris Noe                   Internationalize text                           *
;     014 09/17/01 Christi Ditmars      Added product_sub_nbr to product    *
;                                       number display.  Corrected comments *
;                                       displaying in duplicate             *
;     015 07/24/02 Jason Osborn         Unique RPT filename project         *
;     016 04/22/04 Ronda Zheng          Fixed defect CAPEP00011411, 41820, 46849, 48629, 74014, 74016,      *
;                                       50772, 98465. Print "Unknown" if the patient doesn't have gender.   *
;                                       Print proper data at the bottom of each page. Print out most        *
;                                       current result comments and notes. Read data_map and format numeric *
;                                       results. Prevent printing duplicate antibody results.               *
;     017 05/10/04 Ronda Zheng          Fixed defect CAPEP00126357. When patient doesn't have MRN, bad data *
;                                       was printed out.                                                    *
;     018 05/17/04 Jim Jensen           Add CNVTALIAS for mrn display.      *
;                                       Add CNVTACC for accession number.   *
;     019 09/13/04 David Fifer          Rearranged the report to handle a 25*
;                                       character eurocode product number.  *
;     020 09/16/04 Ronda Zheng          Print out the test site passed in when*
;                                       no data is avaiable                 *
;     021 09/29/04 Jason Coy            Adjust starting position and width  *
;                                       of long text.                       *
;     022 10/20/04 Jim Jensen           Add clinical validation display for *
;                                       result status In-Review/CorrInReview*
;     023 01/12/04 Jason Coy            Correct clin val issues.            *
;     024 04/17/05 Jason Osborn         tech_name no longer prints <null>   *
;                                       character if there is no perform    *
;                                       tech (MDI results). (Feature 42209) *
;     025 10/11/05 Jason Coy            Updated report to display the       *
;                                       front end username.                 *
;     026 01/25/06 Matt Schile          Fixed script to only return BBT results *
;     027 02/02/06 Matt Schile          Removed previous mod and changed script to only exclude Helix results*
;     028 04/05/07 Jason Osborn         Enhance Service Resource Security   *
;                                       logic and script performance.       *
;     029 05/30/07 Matt Cummings        Fixed CRs 1-607507572 and           *
;                                       1-688460741.                        *
;     030 07/24/07 Tom Brecht           Fixed CR 1-1218568271               *
;     031 10/22/09 Archita S            Fixed CR 1-3523646211               *
;     032 04/26/11 Archita S            Fixed errant character printing by  *
;                                       third party printers, when no data qualifies* 
;     033 07/16/13 Gayatri Samala       Fix for CR 1-7027895211,to populate reply   *
;										structure by qualifying on primary accession*
;										for the order						*
;~DE~************************************************************************
;~END~*******************  END OF ALL MODCONTROL BLOCKS  ********************
 
     drop program bbt_rpt_daily_patient_rsl:dba go
     create program bbt_rpt_daily_patient_rsl:dba
     
/********************************************************************/
/*  Request Record                                                  */
/********************************************************************

record request
(
  1 dt_tm_begin = dq8
  1 dt_tm_end = dq8
  1 printer_name = vc
  1 ops_date = dq8
  1 batch_selection = vc
  1 output_dist = vc
  1 address_location_cd = f8
  1 qual[*]
    2 service_resource_cd = f8
)

/********************************************************************/
/*  Include files (Unless specific %i placement needed)             */
/********************************************************************/
%i cclsource:pcs_format_age.inc       ;For FormatAge Sub    
%i cclsource:bbt_get_username.inc     ;For GET_USERNAME Sub
%i cclsource:bbt_rpt_subs.inc
%i cclsource:bbt_get_code_value.inc
%i cclsource:mic_expand_subs.inc
          
;Internationalization
%i cclsource:i18n_uar.inc  
   set i18nHandle = 0
   set h = uar_i18nlocalizationinit(i18nHandle, curprog, "", curcclrev)

;Service Resource Security
%i cclsource:pcs_resource_security.inc
%i cclsource:bb_get_serv_res_access.inc
   declare nSecurityInd = i2 with project, noconstant(CONST_SECURITY_ON)    ;Init security ON
   declare nReturnStat  = i2 with protect, noconstant(CONST_RETURN_INVALID) ;Init to invalid return

;Process Batch Selection Params
%i cclsource:bbt_ops_parm_passed.inc
   record ops_params
   (
     1 qual[*]
       2 param = c100
   )

/********************************************************************/
/*  Record Structure Definitions                                    */
/********************************************************************/

record reply
(
  1 rpt_list[*]
    2 rpt_filename  = vc
%i cclsource:status_block.inc
)

; List of in-range verified or corrected results.
record perf_results
(
  1 qual[*]
     2 result_id = f8
     2 order_id = f8
     2 catalog_cd = f8
     2 task_assay_cd = f8
     2 perform_result_id = f8
     2 service_resource_cd = f8
     2 detail_mnemonic = c12
     2 drawn_time = c12
     2 bb_result_id = f8
     2 product_nbr = c25
     2 bb_processing_cd = f8
     2 event_sequence = i4
     2 long_text_id = f8
     2 result_status_cd = f8
     2 arg_min_digits          = i4
     2 arg_max_digits          = i4
     2 arg_min_dec_places      = i4
     2 arg_less_great_flag     = i2
)

; List of most recent chartable result comments
record r_long_text
(
  1 qual[*]
    2 result_id = f8
    2 perform_result_id = f8
    2 event_sequence = i4
    2 order_id = f8
    2 task_assay_cd = f8
    2 result_status_cd = f8
    2 comment_text = vc
    2 note_text = vc
    2 text_result = vc
)
 
record captions
(
  1  rpt_date                            = vc
  1  rpt_time                            = vc
  1  rpt_by                              = vc
  1  page_no                             = vc
  1  test_site                           = vc
  1  beg_date                            = vc
  1  end_date                            = vc
  1  person_name                         = vc
  1  order_proc                          = vc
  1  number                              = vc
  1  accession                           = vc
  1  age_sex                             = vc
  1  collect_dt_tm                       = vc
  1  performed                           = vc
  1  verified                            = vc
  1  provider                            = vc
  1  priority                            = vc
  1  cell_product                        = vc
  1  procedure                           = vc
  1  result                              = vc
  1  tech_id                             = vc
  1  date                                = vc
  1  time                                = vc
  1  end_of_report                       = vc
  1  title_text                          = vc
  1  report_id                           = vc
  1  unknown                             = vc
  1  comment                             = vc
  1  note                                = vc
  1  text_result                         = vc
  1  text_result_correct                 = vc
  1  not_on_file                         = vc
)

set captions->rpt_date = uar_i18ngetmessage(i18nHandle, "rpt_date", "DATE:")
set captions->rpt_time = uar_i18ngetmessage(i18nHandle, "rpt_time", "TIME:")
set captions->rpt_by = uar_i18ngetmessage(i18nHandle, "rpt_by", "  BY:")
set captions->page_no = uar_i18ngetmessage(i18nHandle, "page_no", "PAGE:")
set captions->test_site = uar_i18ngetmessage(i18nHandle, "test_site", "TEST SITE:")
set captions->beg_date = uar_i18ngetmessage(i18nHandle, "beg_date", "Beginning Date:")
set captions->end_date = uar_i18ngetmessage(i18nHandle, "end_date", "Ending Date:")
set captions->person_name = uar_i18ngetmessage(i18nHandle, "person_name", "PERSON NAME/")
set captions->order_proc = uar_i18ngetmessage(i18nHandle, "order_proc", "ORDERED PROC/")
set captions->number = uar_i18ngetmessage(i18nHandle, "number", "NUMBER")
set captions->accession = uar_i18ngetmessage(i18nHandle, "accession", "ACCESSION #")
set captions->age_sex = uar_i18ngetmessage(i18nHandle, "age_sex", "AGE/SEX/")
set captions->collect_dt_tm = uar_i18ngetmessage(i18nHandle, "collect_dt_tm", "COLLECT DATE/TIME")
set captions->performed = uar_i18ngetmessage(i18nHandle, "performed", "PERFORMED")
set captions->verified = uar_i18ngetmessage(i18nHandle, "verified", "VERIFIED")
set captions->provider = uar_i18ngetmessage(i18nHandle, "provider", "PROVIDER")
set captions->priority = uar_i18ngetmessage(i18nHandle, "priority", "PRIORITY")
set captions->cell_product = uar_i18ngetmessage(i18nHandle, "cell_product", "CELL/PRODUCT")
set captions->procedure = uar_i18ngetmessage(i18nHandle, "procedure", "PROCEDURE")
set captions->result = uar_i18ngetmessage(i18nHandle, "result", "RESULT")
set captions->tech_id = uar_i18ngetmessage(i18nHandle, "tech_id", "TECH ID")
set captions->date = uar_i18ngetmessage(i18nHandle, "date", "DATE")
set captions->time = uar_i18ngetmessage(i18nHandle, "time", "TIME")
set captions->end_of_report = uar_i18ngetmessage(i18nHandle, "end_of_report", "*** END OF REPORT ***")
set captions->title_text = uar_i18ngetmessage(i18nHandle, "title_text", "BLOOD BANK PATIENT RESULTS ACTIVITY REPORT")
set captions->report_id = uar_i18ngetmessage(i18nHandle, "report_id", "Report ID: BBT_RPT_DAILY_PATIENT_RSL")
set captions->unknown = uar_i18ngetmessage(i18nHandle, "unknown", "Unknown")
set captions->comment = uar_i18ngetmessage(i18nHandle, "comment", "Comment:  ")
set captions->note = uar_i18ngetmessage(i18nHandle, "note", "Note:  ")
set captions->text_result = uar_i18ngetmessage(i18nHandle, "text_result", "Text Result:  ")
set captions->text_result_correct = uar_i18ngetmessage(i18nHandle, "text_result_correct", "Text Result (Corrected): ")
set captions->not_on_file = uar_i18ngetmessage(i18nHandle, "not_on_file", "<Not on File>")

/********************************************************************/
/*  Variable Definitions                                            */
/********************************************************************/

declare CONST_RESULT_EVENT_CS   = i4  with protect, constant(1901)
declare CONST_ALIAS_TYPE_CS     = i4  with protect, constant(319)
declare CONST_COMMENT_TYPE_CS   = i4  with protect, constant(14)
declare CONST_BB_PROCESSING_CS  = i4  with protect, constant(1635)
declare CONST_ACTIVITY_TYPE_CS  = i4  with protect, constant(106)
declare CONST_XM_CDF            = c2  with protect, constant("XM")
declare CONST_PAT_ABO_CDF       = c11 with protect, constant("PATIENT ABO")
declare CONST_ANTIGEN_CDF       = c7  with protect, constant("ANTIGEN")
declare CONST_ANTIBODY_CDF      = c11 with protect, constant("ANTIBODY ID")
declare CONST_ABSC_CDF          = c12 with protect, constant("ANTIBDY SCRN")
declare CONST_RH_PHEN_CDF       = c12 with protect, constant("RH PHENOTYPE")
declare CONST_HLX_CDF           = c3  with protect, constant("HLX")
declare CONST_MRN_CDF           = c3  with protect, constant("MRN")
declare CONST_PERFORMED_CDF     = c9  with protect, constant("PERFORMED")
declare CONST_VERIFIED_CDF      = c8  with protect, constant("VERIFIED")
declare CONST_CORRECTED_CDF     = c9  with protect, constant("CORRECTED")
declare CONST_OLDCORRECTED_CDF  = c12 with protect, constant("OLDCORRECTED")
declare CONST_INREVIEW_CDF      = c8  with protect, constant("INREVIEW")
declare CONST_OLDINREVIEW_CDF   = c11 with protect, constant("OLDINREVIEW")
declare CONST_CORRINREV_CDF     = c9  with protect, constant("CORRINREV")
declare CONST_OLDCORRINREV_CDF  = c12 with protect, constant("OLDCORRINREV")
declare CONST_RES_COMMENT_CDF   = c11 with protect, constant("RES COMMENT")
declare CONST_RES_NOTE_CDF      = c8  with protect, constant("RES NOTE")

declare crossmatch_cd           = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_XM_CDF))
declare patient_abo_cd          = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_PAT_ABO_CDF))
declare antigen_cd              = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_ANTIGEN_CDF))
declare antibody_id_cd          = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_ANTIBODY_CDF))
declare antibody_scrn_cd        = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_ABSC_CDF))
declare rh_phenotype_cd         = f8 with protect, constant(get_code_value(CONST_BB_PROCESSING_CS, CONST_RH_PHEN_CDF))
declare dHelixCd                = f8 with protect, constant(get_code_value(CONST_ACTIVITY_TYPE_CS, CONST_HLX_CDF))
declare aliastype_cd            = f8 with protect, constant(get_code_value(CONST_ALIAS_TYPE_CS, CONST_MRN_CDF))
declare performed_cd            = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_PERFORMED_CDF))
declare verified_cd             = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_VERIFIED_CDF))
declare corrected_cd            = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_CORRECTED_CDF))
declare oldcorrected_cd         = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_OLDCORRECTED_CDF))
declare inreview_cd             = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_INREVIEW_CDF))
declare oldinreview_cd          = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_OLDINREVIEW_CDF))
declare corrinreview_cd         = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_CORRINREV_CDF))
declare oldcorrinrev_cd         = f8 with protect, constant(get_code_value(CONST_RESULT_EVENT_CS, CONST_OLDCORRINREV_CDF))
declare chartabletype_cd        = f8 with protect, constant(get_code_value(CONST_COMMENT_TYPE_CS, CONST_RES_COMMENT_CDF))
declare notetype_cd             = f8 with protect, constant(get_code_value(CONST_COMMENT_TYPE_CS, CONST_RES_NOTE_CDF))
declare hyphen_line             = c131 with protect, constant(fillstring(131, "-"))

declare nbr_prs                 = i4 with protect, noconstant(0)
declare nbr_comments            = i4 with protect, noconstant(0)
declare resultflagstr           = vc with protect, noconstant(" ")
declare offset                  = i2 with protect, noconstant(0); position within a reportstuff row to insert a report item
declare order_row               = i2 with protect, noconstant(0)
declare detail_row              = i2 with protect, noconstant(0)
declare store_perform_result_id = f8 with protect, noconstant(0.0)
declare store_perfresultids     = c50 with protect, noconstant("")
declare dont_print_proc         = i2 with protect, noconstant(0)
declare procedure_row_hold      = i2 with protect, noconstant(0)
declare ts_cnt                  = i4 with protect, noconstant(0)
declare reportByUsername        = vc with protect, constant(GET_USERNAME(reqinfo->updt_id))
declare i_idx                   = i4 with protect, noconstant(0)
declare first_service_resource  = vc with protect, noconstant(fillstring(50, " "))

if (crossmatch_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "XM CDF_Meaning not found on 1635"
   go to exit_script
endif
if (patient_abo_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "PATIENT ABO CDF_Meaning not found on 1635"
   go to exit_script
endif
if (antigen_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "ANTIGEN CDF_Meaning not found on 1635"
   go to exit_script
endif
if (antibody_id_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "ANTIBODY ID CDF_Meaning not found on 1635"
   go to exit_script
endif
if (antibody_scrn_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "ANTIBODY SCRN CDF_Meaning not found on 1635"
   go to exit_script
endif
if (rh_phenotype_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get BB Proc Codes"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "RH PHENOTYPE CDF_Meaning not found on 1635"
   go to exit_script
endif
if (aliastype_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get MRN Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "MRN CDF_Meaning not found on 319"
   go to exit_script
endif
if (performed_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get PERFORMED Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "PERFORMED CDF_Meaning not found on 1901"
   go to exit_script
endif
if (verified_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get VERIFIED Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "VERIFIED CDF_Meaning not found on 1901"
   go to exit_script
endif
if (corrected_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get CORRECTED Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "CORRECTED CDF_Meaning not found on 1901"
   go to exit_script
endif
if (oldcorrected_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get OLDCORRECTED Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "OLDCORRECTED CDF_Meaning not found on 1901"
   go to exit_script
endif
if (inreview_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get INREVIEW Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "INREVIEW CDF_Meaning not found on 1901"
   go to exit_script
endif
if (oldinreview_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get OLDINREVIEW Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "OLDINREVIEW CDF_Meaning not found on 1901"
   go to exit_script
endif
if (corrinreview_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get CORRINREVIEW Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "CORRINREVIEW CDF_Meaning not found on 1901"
   go to exit_script
endif
if (oldcorrinrev_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get OLDCORRINREVIEW Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "OLDCORRINREVIEW CDF_Meaning not found on 1901"
   go to exit_script
endif
if (chartabletype_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get RES COMMENT Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "RES COMMENT CDF_Meaning not found on 14"
   go to exit_script
endif
if (notetype_cd <= 0.0)
   set reply->status_data->status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "Get RES NOTE Code"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "RES NOTE CDF_Meaning not found on 14"
   go to exit_script
endif

set nSecurityInd = CONST_SECURITY_ON
if (size(trim(request->batch_selection), 1) > 0)
  set nSecurityInd = CONST_SECURITY_OFF ;Call is from Ops, turn security OFF.
  set begday = request->ops_date
  set endday = request->ops_date
  set temp_string = cnvtupper(trim(request->batch_selection))
  CALL CHECK_OPT_DATE_PASSED("bbt_rpt_daily_patient_rsl")
  if (reply->status_data->status != "F")
        set request->dt_tm_begin = begday
        set request->dt_tm_end = endday
  endif

  call CHECK_SVC_OPT ("bbt_rpt_daily_patient_rsl")
  call CHECK_LOCATION_CD ("bbt_rpt_daily_patient_rsl")
 
  SET request->printer_name = request->output_dist
endif

;Call get location after Batch Params processing
%i cclsource:bbt_get_location_info.inc

if (InitServResRoutine(nSecurityInd) = CONST_RETURN_INVALID)
   set reply->status_data.status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "InitServResRoutine()"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "Invalid Status Returned."
   go to exit_script
endif

set nReturnStat = DetermineServResAccess(request->qual[1]->service_resource_cd)

if (nReturnStat = CONST_RETURN_INVALID)
   set reply->status_data.status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "DetermineServResAccess()"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "Invalid Service Resource"
   go to exit_script
elseif (nReturnStat = CONST_RETURN_NO_SECURITY)
   set reply->status_data.status = "F"
   set reply->status_data.subeventstatus[1].OperationName = "bbt_rpt_daily_patient_rsl"
   set reply->status_data.subeventstatus[1].OperationStatus = "F"
   set reply->status_data.subeventstatus[1].TargetObjectName = "DetermineServResAccess()"
   set reply->status_data.subeventstatus[1].TargetObjectValue = "No security access for specified Service Resource"
   go to exit_script
endif

set first_service_resource = uar_get_code_display(request->qual[1]->service_resource_cd)

;Begin to build the perf_results structure, which will contain all results that should display on the report.
select into "nl:"
   perfresultids = build(pr.result_id, pr.perform_result_id, re.event_sequence)
  ,drawntime = format(c.drawn_dt_tm, "@DATETIMECONDENSED;;d")
from result_event re
    ,perform_result pr
    ,container c
plan re where re.event_dt_tm between cnvtdatetime(request->dt_tm_begin) and cnvtdatetime(request->dt_tm_end)
join pr where pr.perform_result_id = re.perform_result_id 
          and pr.result_status_cd not in (oldinreview_cd, oldcorrinrev_cd)
          and expand(ts_cnt,1,size(testsites->qual,5),pr.service_resource_cd,testsites->qual[ts_cnt].service_resource_cd)
join c  where c.container_id = pr.container_id

order perfresultids

head report
   stat = alterlist(perf_results->qual,100)
   nbr_prs = 0 
   
head perfresultids
   nbr_prs = nbr_prs + 1
   if (size(perf_results->qual, 5) < nbr_prs)
      stat = alterlist(perf_results->qual,nbr_prs + 99)
   endif
   perf_results->qual[nbr_prs].perform_result_id   = pr.perform_result_id
   perf_results->qual[nbr_prs].result_id           = pr.result_id
   perf_results->qual[nbr_prs].service_resource_cd = pr.service_resource_cd
   perf_results->qual[nbr_prs].event_sequence      = re.event_sequence
   perf_results->qual[nbr_prs].long_text_id        = pr.long_text_id
   perf_results->qual[nbr_prs].result_status_cd    = pr.result_status_cd      
   perf_results->qual[nbr_prs].arg_less_great_flag = pr.less_great_flag  
   perf_results->qual[nbr_prs].drawn_time          = drawntime       

foot perfresultids
   row+0
foot report
   stat = alterlist(perf_results->qual,nbr_prs)     
with nocounter

;Fill out the rest of the perf_results info.  
;First determine the values to be used to loop through the structure via expand/locateval logic.
set expandStart = 1  
set expandSize = DetermineExpandSize(nbr_prs, 100)
set expandTotal = DetermineExpandTotal(nbr_prs, expandSize)
;Pad the perf_results structure = expandTotal. For example, if perf_results is 690 elements, 
;expandTotal will = 700 and expandSize will = 100.  Padding perf_results to be 700 elements
;will allow oracle to cache the query, resulting in better performance.
set stat = alterlist(perf_results->qual,expandTotal)

for (i_idx = nbr_prs + 1 to expandTotal)
    ;Set the "pad" elements to -1 to ensure the select won't qualify on the result_id's.
    set perf_results->qual[i_idx].result_id = -1
endfor

select into "nl:"
   r.result_id
  ,r.order_id
  ,detail_mnem = substring(1,12,uar_get_code_display(r.task_assay_cd))
  ,pe.product_id
  ,p.product_nbr
  ,sd.bb_processing_cd
  ,sd.seq
  ,locateStart = expandStart
  ,result_id_expand = build(r.result_id, expandStart)
from (dummyt d_r with seq = value(expandTotal/expandSize))
     ,result r
     ,discrete_task_assay dta
     ,service_directory sd
     ,dummyt d_pe
     ,product_event pe
     ,product p
     ,blood_product bp
plan d_r where assign(expandStart, evaluate(d_r.seq, 1, 1, expandStart + expandSize))
join   r where expand(i_idx,expandStart, expandStart + expandSize - 1, r.result_id, perf_results->qual[i_idx].result_id)
join dta where dta.task_assay_cd = r.task_assay_cd and dta.activity_type_cd+0 != dHelixCd
join  sd where r.catalog_cd = sd.catalog_cd
join d_pe
  join pe where pe.order_id=r.order_id and sd.bb_processing_cd=crossmatch_cd and
   pe.bb_result_id+0 = r.bb_result_id and pe.bb_result_id+0 != 0
  join  p where pe.product_id = p.product_id
  join bp where bp.product_id = p.product_id

order by result_id_expand

head report 
   row+0

head result_id_expand
   i = 0
   locateEnd = locateStart + expandSize - 1
   ;Go find the first perf_results item that matches r.result_id
   PerfResIndex = locateval(i, locateStart, locateEnd, r.result_id, perf_results->qual[i].result_id)
   while (PerfResIndex > 0)
      ;Found a match, copy over the rest of the data
      perf_results->qual[PerfResIndex]->order_id = r.order_id
      perf_results->qual[PerfResIndex]->catalog_cd = r.catalog_cd
      perf_results->qual[PerfResIndex]->task_assay_cd = r.task_assay_cd
      perf_results->qual[PerfResIndex]->detail_mnemonic = detail_mnem
      perf_results->qual[PerfResIndex]->bb_result_id = r.bb_result_id
      perf_results->qual[PerfResIndex]->product_nbr = 
         concat(trim(bp.supplier_prefix), trim(p.product_nbr), " ", trim(p.product_sub_nbr))
      perf_results->qual[PerfResIndex]->bb_processing_cd = sd.bb_processing_cd
      
      ;Go find the next perf_results item that matches r.result_id ( PerfResIndex will = 0 if not found)
      PerfResIndex = locateval(i, PerfResIndex+1, locateEnd,r.result_id, perf_results->qual[i].result_id)
   endwhile

detail
   row+0
   
foot r.result_id
   row+0
   
foot report
   ;remove padding
   stat = alterlist(perf_results->qual,nbr_prs)
 
with nocounter 
    ,outerjoin = d_pe

/* get the data map */
select into "nl:"
    dm.task_assay_cd
    , dm.service_resource_cd
    , data_map_exists = decode(dm.seq, "Y", "N")
    , rg_exists = decode(rg.seq, "Y", "N")
 
from
   (dummyt d with seq = value(nbr_prs))
    , (dummyt d_dm with seq = 1)
    , data_map dm
    , (dummyt d_rg with seq = 1)
    , resource_group rg
 
plan d where d.seq <= nbr_prs and perf_results->qual[d.seq].result_id > 0.0

join d_dm where   d_dm.seq = 1
join dm   where dm.task_assay_cd      = perf_results->qual[d.seq]->task_assay_cd
            and dm.data_map_type_flag = 0
            and dm.active_ind         = 1
join d_rg where d_rg.seq = 1
join rg   where rg.parent_service_resource_cd = dm.service_resource_cd
            and rg.child_service_resource_cd  = perf_results->qual[d.seq]->service_resource_cd
            and rg.resource_group_type_cd     = dServResSubsectionCd
            and rg.root_service_resource_cd+0 = 0.0
order by    d.seq, d_dm.seq
 
head d.seq
        perf_results->qual[d.seq]->arg_min_digits     = 1
        perf_results->qual[d.seq]->arg_max_digits     = 14
        perf_results->qual[d.seq]->arg_min_dec_places = 0
        data_map_level = 0
 
head d_dm.seq
       if (data_map_exists = "Y")  ; Data_Map found, now we'll check to see if we can use it 
          if (data_map_level <= 2 and dm.service_resource_cd > 0 and
              dm.service_resource_cd = perf_results->qual[d.seq]->service_resource_cd)  ;Exact match found
              data_map_level = 3
             perf_results->qual[d.seq]->arg_min_digits = dm.min_digits
             perf_results->qual[d.seq]->arg_max_digits = dm.max_digits
             perf_results->qual[d.seq]->arg_min_dec_places = dm.min_decimal_places
          endif
 
          if (data_map_level <= 1 and dm.service_resource_cd > 0.0
             and rg_exists = "Y" and rg.parent_service_resource_cd = dm.service_resource_cd
             and rg.child_service_resource_cd = perf_results->qual[d.seq]->service_resource_cd)
             data_map_level = 2
             perf_results->qual[d.seq]->arg_min_digits = dm.min_digits
             perf_results->qual[d.seq]->arg_max_digits = dm.max_digits
             perf_results->qual[d.seq]->arg_min_dec_places = dm.min_decimal_places
          endif
 
          if (data_map_level = 0 and dm.service_resource_cd = 0)
             data_map_level = 1
             perf_results->qual[d.seq]->arg_min_digits = dm.min_digits
             perf_results->qual[d.seq]->arg_max_digits = dm.max_digits
             perf_results->qual[d.seq]->arg_min_dec_places = dm.min_decimal_places
          endif
       endif
 
with nocounter
     , outerjoin(d_dm)
     , outerjoin(d_rg)
 
 
; get the latest comment for each result and put it into an array
; (this assumes the elements of the perf_results array are ordered
; by result_id)
 
; the selects for chartable and non-chartable comments are done
; separately because this has to get the most recent chartable
; comment and the most recent non-chartable comment.
 
      SELECT INTO "nl:"
        rc.result_id
        , rc.action_sequence
        , lt.seq
        , lt.long_text_id
      FROM
         (dummyt d1 with seq = value(nbr_prs))
       ,  result_comment rc
       , long_text lt
      PLAN d1
      JOIN rc
        WHERE rc.result_id = perf_results->qual[d1.seq]->result_id
          and (rc.comment_type_cd = chartabletype_cd
               or rc.comment_type_cd = notetype_cd)
      JOIN lt
        WHERE rc.long_text_id = lt.long_text_id
          and lt.long_text_id > 0
 
      ORDER rc.result_id, rc.comment_type_cd, rc.action_sequence DESC
 
      head rc.result_id
        row + 0
 
      head rc.comment_type_cd
          nbr_comments = nbr_comments + 1
          stat = alterlist(r_long_text->qual, nbr_comments)
            r_long_text->qual[nbr_comments]->result_id = rc.result_id
            r_long_text->qual[nbr_comments]->perform_result_id = perf_results->qual[d1.seq]->perform_result_id
            r_long_text->qual[nbr_comments]->event_sequence = perf_results->qual[d1.seq]->event_sequence
            r_long_text->qual[nbr_comments]->order_id = perf_results->qual[d1.seq]->order_id
            r_long_text->qual[nbr_comments]->task_assay_cd = perf_results->qual[d1.seq]->task_assay_cd
            if (rc.comment_type_cd = chartabletype_cd)
                r_long_text->qual[nbr_comments]->comment_text = trim(lt.long_text)
            elseif (rc.comment_type_cd = notetype_cd)
                r_long_text->qual[nbr_comments]->note_text = trim(lt.long_text)
            endif
 
      WITH
        NOCOUNTER

      SELECT INTO "nl:"
        result_id = perf_results->qual[d1.seq]->result_id
        ,perf_result = perf_results->qual[d1.seq]->perform_result_id
        , lt.seq
        , lt.long_text_id
        , lt_long_text = substring(1, 32000, lt.long_text)
      FROM
         (dummyt d1 with seq = value(nbr_prs))
       , long_text lt
      PLAN d1
        WHERE perf_results->qual[d1.seq]->long_text_id > 0
      JOIN lt
        WHERE perf_results->qual[d1.seq]->long_text_id = lt.long_text_id
      ORDER result_id, perf_result DESC
 
      HEAD REPORT
%i cclsource:bbt_remove_rtf.inc
 
      detail

          nbr_comments = nbr_comments + 1
          stat = alterlist(r_long_text->qual, nbr_comments)
            r_long_text->qual[nbr_comments]->result_id = perf_results->qual[d1.seq]->result_id
            r_long_text->qual[nbr_comments]->perform_result_id = perf_results->qual[d1.seq]->perform_result_id
            r_long_text->qual[nbr_comments]->event_sequence = perf_results->qual[d1.seq]->event_sequence
            r_long_text->qual[nbr_comments]->order_id = perf_results->qual[d1.seq]->order_id
            r_long_text->qual[nbr_comments]->task_assay_cd = perf_results->qual[d1.seq]->task_assay_cd
            r_long_text->qual[nbr_comments]->result_status_cd = perf_results->qual[d1.seq]->result_status_cd
            if (lt.seq != NULL and lt.seq > 0)
                call REMOVE_RTF2(lt_long_text)
                r_long_text->qual[nbr_comments]->text_result = trim(rtf_out_text)
            endif
      WITH
        NOCOUNTER

; get the result information and print the report
      SET begin_date = format(request->dt_tm_begin, "@DATETIMECONDENSED;;d") ;"ddmmmyy hhmm;;d")
      SET end_date = format(request->dt_tm_end, "@DATETIMECONDENSED;;d") ;"ddmmmyy hhmm;;d")
 
;declare psex = c12
;declare shortpri = c12

set select_ok_ind = 0
set rpt_cnt = 0

	 execute cpm_create_file_name_logical "bbt_dailypatrsl", "txt", "x"
 
     select into cpm_cfn_info->file_name_logical
     pr.result_id
        , p.person_id
        , p.name_full_formatted
        , re.event_type_cd
        , pr.result_status_cd
        , re.perform_result_id
        , cv_oc.display
        , detail_mnem = perf_results->qual[d_pr.seq]->detail_mnemonic
        , alpha_result = trim(substring(1, 14, pr.result_value_alpha))		;019
        , result_code_set_disp = trim(substring(1, 14, uar_get_code_display(pr.result_code_set_cd)))		;019
        , profile_task_yn = decode(ptr.seq, "Y", pr.seq, "N", "Z")
        , order_cell_yn = decode(oc.seq, "Y", pr.seq, "N", "Z")
        , cell_yn = decode(cv_oc.seq, "Y", pr.seq, "N", "Z")
        , product_yn = decode(prod.seq, "Y", pr.seq, "N", "Z")
        , type_cdf_meaning = decode(pr.seq, uar_get_code_meaning(pr.result_type_cd), " ")
        , ptr.sequence
        , phs_grp.sequence
        , re.event_sequence
        , re.event_dt_tm
        , nowtime = format(curtime, "@TIMENOSECONDS;;M") ;"hh:mm;;m")
        , nowdate = format(curdate, "@DATECONDENSED;;d") ;"mm/dd/yyyy;;d")
        , drawntime = perf_results->qual[d_pr.seq]->drawn_time
        , event_date = format(re.event_dt_tm, "@DATETIMECONDENSED;;d") ;"ddmmmyy hhmm;;d")
        , ascii_text = trim(substring(1, 13, pr.ascii_text))
        , pr.result_value_numeric
        , text_results = trim(substring(1, 14, pr.ascii_text))
        , date_result = format(pr.result_value_dt_tm, "@DATECONDENSED;;d") ;"ddmmmyy;;d")
        , date_time_result = format(pr.result_value_dt_tm, "@DATETIMECONDENSED;;d") ;"ddmmmyy hhmm;;d")
        , norm_display = decode(pr.seq, uar_get_code_display(pr.normal_cd), " ")        ;004
        , crit_display = decode(pr.seq, uar_get_code_display(pr.critical_cd), " ")      ;004
        , notify_disp = decode(pr.seq, uar_get_code_display(pr.notify_cd), " ")
        , revw_display = decode(pr.seq, uar_get_code_display(pr.review_cd), " ")        ;004
        , delta_display = decode(pr.seq, uar_get_code_display(pr.delta_cd), " ")        ;004
        , tech_name = if (nullind(pl.username) = 0)
                         substring(1, 7, pl.username)
                      else 
                         fillstring(7, " ")
                      endif
        , ord_mnem = trim(substring(1, 19, o.order_mnemonic))				;019
        , short_name = trim(substring(1, 20, p.name_full_formatted))		;019
        , aor.accession
        , ea.alias
        , doctor_name = concat("DR. ", substring(1, 19, p_doc.name_full_formatted))
        , bb_processing_cd = perf_results->qual[d_pr.seq]->bb_processing_cd
        , product_nbr = perf_results->qual[d_pr.seq]->product_nbr
        , pr.result_id
        , o.order_id
        , orderunique = build(o.catalog_cd, o.order_id)
        , o.person_id
        , personunique = build(trim(p.name_full_formatted), p.person_id)
        , pr.perform_result_id
        , psex = decode(p.seq, uar_get_code_display(p.sex_cd), " ")
        ;, psex = substring(1, 7, psex)
        , p_doc_exists = decode(p_doc.seq, "Y", "N")
        , shortpri = decode(ol.seq, uar_get_code_display(ol.report_priority_cd), " ")
        ;, shortpri = substring(1, 10, shortpri)
        , ol_exists = decode(ol.seq, "Y", "N")
        , test_site2 = decode(pr.seq, uar_get_code_display(pr.service_resource_cd), " ") ;004
        , oc.bb_result_id
        , oc.order_cell_id
        , prod.product_nbr
        , oc.cell_cd
        , pr.long_text_id
;JOWbeg
        , perfresultids = build(pr.result_id, pr.perform_result_id, re.event_sequence)
;JOWend
        , performDtTm = format(pr.perform_dt_tm, "@DATETIMECONDENSED;;d")
        , perfTechName = if (nullind(pl2.username) = 0)
                            substring(1, 7, pl2.username)
                         else
                            fillstring(7, " ")
                         endif
      FROM
        (dummyt d_pr with seq = value(nbr_prs))
        , result_event re
        , perform_result pr
        , (dummyt d_result with seq = 1)
        , orders o
        , person p
        , accession_order_r aor
        , person p_doc
        , order_laboratory ol
        , (dummyt d_ea with seq = 1)
        , encntr_alias ea
        , (dummyt d_ea2 with seq = 1)
        , prsnl pl
        , (dummyt d_ptr with seq = 1)
        , profile_task_r ptr
        , bb_order_cell oc
        , (dummyt d_cv_oc with seq = 1)
        , code_value cv_oc
        , product prod
        , (dummyt d_bp2 with seq = 1)
        , blood_product bp2
        , (dummyt d_phs_grp with seq = 1)
        , bb_order_phase op
        , phase_group phs_grp
        , (dummyt d_phase with seq = 1)
        , prsnl pl2
     PLAN d_pr WHERE perf_results->qual[d_pr.seq]->result_id > 0.0
      JOIN pr
        WHERE (pr.perform_result_id = perf_results->qual[d_pr.seq]->perform_result_id)
      JOIN pl2 
        WHERE (pl2.person_id = pr.perform_personnel_id)
      JOIN d_result
        WHERE d_result.seq = 1
      JOIN re
        WHERE (re.result_id = perf_results->qual[d_pr.seq]->result_id)
        AND (re.perform_result_id = perf_results->qual[d_pr.seq]->perform_result_id)
        AND (re.event_sequence = perf_results->qual[d_pr.seq]->event_sequence)
      JOIN o
        WHERE o.order_id = perf_results->qual[d_pr.seq]->order_id
      JOIN ol
        WHERE ol.order_id = perf_results->qual[d_pr.seq]->order_id
      JOIN p
        WHERE p.person_id = o.person_id
          and (o.person_id > 0
          and  o.person_id != null)
      JOIN (d_ea        where d_ea.seq = 1
      JOIN ea
        where (ea.encntr_id = o.encntr_id)
          and (ea.encntr_alias_type_cd = aliastype_cd))
      JOIN d_ea2        where d_ea2.seq = 1
      JOIN aor
        WHERE aor.order_id = perf_results->qual[d_pr.seq]->order_id and aor.primary_flag = 0
      JOIN p_doc
        WHERE (p_doc.person_id = o.last_update_provider_id)
      JOIN pl
        WHERE pl.person_id = re.event_personnel_id
  JOIN (d_ptr
        WHERE d_ptr.seq = 1
      JOIN (ptr
        WHERE (ptr.catalog_cd = perf_results->qual[d_pr.seq]->catalog_cd
        AND ptr.task_assay_cd = perf_results->qual[d_pr.seq]->task_assay_cd
        AND ((perf_results->qual[d_pr.seq]->bb_processing_cd != antigen_cd
        AND  perf_results->qual[d_pr.seq]->bb_processing_cd != antibody_scrn_cd)
              OR perf_results->qual[d_pr.seq]->bb_processing_cd = crossmatch_cd
              OR perf_results->qual[d_pr.seq]->bb_processing_cd = patient_abo_cd
         OR perf_results->qual[d_pr.seq]->bb_result_id = 0)))
      ORJOIN (oc
             WHERE oc.order_id = perf_results->qual[d_pr.seq]->order_id
               AND oc.bb_result_id = perf_results->qual[d_pr.seq]->bb_result_id
             JOIN d_phs_grp where d_phs_grp.seq = 1
             JOIN (op
               WHERE op.order_id = perf_results->qual[d_pr.seq]->order_id
               JOIN d_phase where d_phase.seq = 1
               JOIN phs_grp
                 WHERE op.phase_grp_cd = phs_grp.phase_group_cd
                   AND op.phase_grp_cd > 0
                   AND phs_grp.task_assay_cd = perf_results->qual[d_pr.seq]->task_assay_cd)
           JOIN (d_cv_oc
             WHERE d_cv_oc.seq = 1
                JOIN (cv_oc
                WHERE cv_oc.code_value = oc.cell_cd
                            and oc.cell_cd > 0)
                ORJOIN (prod
                WHERE prod.product_id = oc.product_id
                        and oc.product_id > 0
        JOIN d_bp2 WHERE d_bp2.seq = 1                          ;BNK - 11/01/97
        JOIN bp2 WHERE bp2.product_id = prod.product_id))))         ;BNK - 11/01/97
 
      ORDER test_site2, personunique, aor.accession, orderunique,
        oc.bb_result_id, product_nbr, ptr.sequence, phs_grp.sequence, perfresultids     ; perform_result_id
        ; re.event_sequence
 
      HEAD REPORT
%i cclsource:bbt_rpt_macros.inc
        CALL clear_reportstuff(' ')
        first_page     = "Y"
        select_ok_ind  = 0
        pat_nbr        = fillstring(20, " ")		;019
        status_disp    = fillstring(21, " ")
        numeric_result = fillstring(50, " ")
 
      HEAD PAGE
; print top-of-page stuff that tells what this report is and where it comes from
 
        CALL CENTER(captions->title_text, 1, 132)
        col 114, captions->rpt_date
        col + 1, curdate "@DATECONDENSED;;d" ;"mm/dd/yyyy;;d"
 
        row + 1
;        col 0, "DIRECTORY:"
        col 114, captions->rpt_time
        col + 1, curtime "@TIMENOSECONDS;;M" ;"hh:mm;;m"
 
        row + 1
        col 114, captions->rpt_by   ;114                                ;018
        col 120, reportByUsername "##########;L"        
        row + 1
        col 114, captions->page_no
        col + 1, curpage "##"
 
%i cclsource:bbt_print_location_info.inc
 
        SAVE_ROW = ROW
        ROW 1
        ROW SAVE_ROW
        ROW + 1
        col 0, captions->test_site
        if(textlen(trim(test_site2)) = 0)
    		col + 1, first_service_resource
    	else								
    		col + 1, test_site2
    	endif

        row + 2
        col 20 captions->beg_date
        col 36 begin_date
        col 60 captions->end_date
        col 74 end_date
        row + 2
 
; print column headers
        row + 1
        col 4, captions->person_name
        col 25, captions->order_proc	;019
        row + 1
        col 7, captions->number
        col 26, captions->accession		;019
        row + 1
        col 6, captions->age_sex
        col 22 captions->collect_dt_tm	;019
        col 94, captions->performed
        col 116, captions->verified
        row + 1
        col 5, captions->provider
        col 27, captions->priority		;019
        col 43, captions->cell_product
        col 62, captions->procedure
        col 75, captions->result
        col 90, captions->tech_id
        col 99, captions->date
        col 106, captions->time
        col 111, captions->tech_id
        col 120, captions->date
        col 127, captions->time
        row + 1
        col 0, hyphen_line
        col 20, " "			;019
        col 42, " "
        col 61, " "
        col 74, " "
        col 89, " "
        col 97, " "
        col 105, " "
        col 110, " "
        col 118, " "
        col 126, " "
        row + 1
 
      HEAD test_site2
        if (first_page = "N")
            break
        else
           first_page = "N"
        endif
        first_person = "Y"
 
      HEAD personunique
        if (trim(ea.alias, 3) = "")
          pat_nbr = captions->not_on_file
        else
          pat_nbr = cnvtalias(ea.alias, ea.alias_pool_cd)
        endif
          short_age = FormatAge(p.birth_dt_tm, p.deceased_dt_tm, "LABRPTAGE")
          CALL store_item(0, 1, short_name)       ; patient name
          CALL store_item(0, 2, pat_nbr)          ; patient number
          CALL store_item(0, 3, short_age)        ; patient age
          if (trim(psex) > "")
          CALL store_item(9, 3, psex)             ; patient sex
          else
              CALL store_item(9, 3, captions->unknown)
          endif
          IF (trim(doctor_name) != "DR.")
             CALL store_item(0, 4, doctor_name)      ; ordering physician
          ENDIF
          order_row = 0
          detail_row = 0
 
      HEAD orderunique
; start new order on line following last detail of previous order
        IF (detail_row > order_row)
          order_row = detail_row
; start 1st detail of each order on 1st line of order
        ELSE
          detail_row = order_row
        ENDIF
        order_row = order_row + 1
        detail_row = detail_row + 1
; remember 1st detail line of current order
        save1stline = order_row
            CALL store_item(21, order_row, ord_mnem)                ; order mnemonic		;019
            order_row = order_row + 1
            CALL store_item(21, order_row, cnvtacc(aor.accession))           ; accession	;019
            order_row = order_row + 1
            IF (size(trim(drawntime), 3) > 0)
               CALL store_item(21, order_row, drawntime)             ; collection date		;019
               order_row = order_row + 1
            ENDIF
        IF (ol_exists = "Y")
          CALL store_item(21, order_row, shortpri)              ; report priority			;019
          order_row = order_row + 1
        ENDIF
 
 
      HEAD oc.bb_result_id
        if (cell_yn = "Y" and product_yn = "N")
              CALL store_item(43, detail_row, cv_oc.display)          ; cell	;019
        elseif (cell_yn = "N" and product_yn = "Y")
	       ;this gets called for antigen type orders when products are added
               prod_nbr_display = concat(trim(bp2.supplier_prefix), trim(prod.product_nbr), " ", trim(prod.product_sub_nbr)) ;019
	       CALL store_item(43, detail_row, prod_nbr_display)        ;BNK - 11/01/97prod.product_nbr)  ; product		;019
        endif
 
     HEAD product_nbr
       if (product_nbr > " ")
            CALL store_item(43, detail_row, product_nbr)          ; product		;019
       endif
 
      HEAD ptr.sequence
          no_op = 0
 
      HEAD phs_grp.sequence
            no_op = 0
 
;JOWbeg

head perfresultids
 
      ;DDH (Prevents "duplicate" information)
      IF (store_perform_result_id = pr.perform_result_id)
        dont_print_proc = 1
      ELSE
        dont_print_proc = 0
      ENDIF   
 
      if ((pr.result_id > 0) and (dont_print_proc = 0))

        store_perform_result_id = pr.perform_result_id
        procedure_row_hold = detail_row
 
        CALL store_item(62, detail_row, detail_mnem)            ; detail mnemonic		;019
        IF (type_cdf_meaning IN ("1", "7"))
           IF (pr.long_text_id = 0)
                CALL store_item(75, detail_row, text_results)               ; text result	;019
                offset = size(trim(text_results),3) + 75		;019
          ELSE
                no_op = 0
                offset = 78
          ENDIF
        ELSEIF (type_cdf_meaning = "2"
           OR (type_cdf_meaning = "4"
           AND bb_processing_cd != patient_abo_cd))
          CALL store_item(75, detail_row, alpha_result)         ; alpha result		;019
          offset = size(trim(alpha_result), 3) + 75									;019
        ELSEIF (type_cdf_meaning IN ("3", "8"))
           arg_min_digits       = perf_results->qual[d_pr.seq]->arg_min_digits
           arg_max_digits       = perf_results->qual[d_pr.seq]->arg_max_digits
           arg_min_dec_places   = perf_results->qual[d_pr.seq]->arg_min_dec_places
           arg_less_great_flag  = perf_results->qual[d_pr.seq]->arg_less_great_flag
           arg_raw_value        = pr.result_value_numeric
           numeric_result       = cnvtstring(pr.result_value_numeric)
           numeric_result       = uar_fmt_result(arg_min_digits, arg_max_digits,
                                    arg_min_dec_places, arg_less_great_flag, arg_raw_value)
          CALL store_item(75, detail_row, numeric_result)       ; numeric result			;019
          offset = size(trim(numeric_result), 3) + 75										;019
        ELSEIF (type_cdf_meaning = "6")
          CALL store_item(75, detail_row, date_result)          ; date result         		;019
         offset = size(trim(date_result), 3) + 75											;019
;010 begin
        ELSEIF (type_cdf_meaning = "11")                                ;date time result
          call store_item(75, detail_row, date_time_result)									;019
          offset = size(trim(date_time_result), 3) + 75										;019
;010 end
        ELSE  ;IF (type_cdf_meaning = "9")
             CALL store_item(75, detail_row, result_code_set_disp)          ; code set result	;019
             offset = size(trim(result_code_set_disp), 3) + 75									;019
        ENDIF
; build a string of result flags
        IF (pr.result_status_cd IN (corrected_cd, oldcorrected_cd))
                correction_flag = "Y"
        ELSE
                correction_flag = " "
        ENDIF
; display field may be empty, so add a blank so subroutine will have something to pass
; (blank must go first because catting something onto an empty string returns an empty string)
          resultflagstr = bldresultflagstr(norm_display, crit_display, revw_display, delta_display,
                          "N", "N", correction_flag, notify_disp)
        IF (size(trim(resultflagstr), 3) > 0)
;JOW HELP!!!  What is this test for (1 = Text, 7 = FreeText, or vica-versa).  I could not get flags to
;             print with out comment this test out.  I think, perhaps, some test needs to be here but
;             I don't quite think this is right.
;           IF (type_cdf_meaning IN ("1", "7")
;                AND pr.long_text_id = 0)
 
;              row + 1
;              col 58, "X"
;              col 60, resultflagstr
;              col 73, "X"
 
                offset = offset + 1
               CALL store_item(offset, detail_row, resultflagstr)    ; string of result flags
;            ELSE
               no_op = 0
;            ENDIF
        ENDIF
       ENDIF
 
      DETAIL
 
;JOWbeg
   IF (store_perfresultids != perfresultids)
      store_perfresultids = perfresultids
;JOWend
 
      IF (pr.result_id > 0)
 
        IF (re.event_type_cd IN (verified_cd, corrected_cd))
          offset = 111
          CALL clear_item(110, procedure_row_hold, fillstring(21," "))
          if (tech_name > " ")
             CALL store_item(offset, procedure_row_hold,tech_name)          ; technician userid
          endif
          offset = offset + 8
          CALL store_item(offset, procedure_row_hold, event_date)        ; verify date
          IF (dont_print_proc = 0)
            detail_row = detail_row + 1
          ENDIF
        ELSEIF (re.event_type_cd IN (performed_cd))
          offset = 90
          CALL clear_item(110, procedure_row_hold, fillstring(21," ")) 
          if (tech_name > " ")
             CALL store_item(offset, procedure_row_hold, tech_name)        ; technician userid
          endif
          offset = offset + 8
          CALL store_item(offset, procedure_row_hold, event_date)       ; perform date
          IF (dont_print_proc = 0)
            detail_row = detail_row + 1       
          ENDIF
        ELSEIF (re.event_type_cd = inreview_cd)
          offset = 90
          CALL clear_item(offset, procedure_row_hold, fillstring(20, " "))
          if (perfTechName > " ")
             CALL store_item(offset, procedure_row_hold, perfTechName)        ; technician userid  
          endif
          offset = offset + 8
          CALL store_item(offset, procedure_row_hold, performDtTm)       ; perform date 
          status_disp = substring(1, 20, concat("<<< ", trim(uar_get_code_display(re.event_type_cd)), " >>>"))
          offset = 112
          CALL store_item(offset, procedure_row_hold, status_disp) 
          IF (dont_print_proc = 0)
            detail_row = detail_row + 1
          ENDIF
        ELSEIF (re.event_type_cd = corrinreview_cd)
          status_disp = substring(1, 21, concat("<<< ", trim(uar_get_code_display(re.event_type_cd)), " >>>"))
          offset = 110
          CALL store_item(offset, procedure_row_hold, status_disp)
          IF (dont_print_proc = 0)
            detail_row = detail_row + 1 
          ENDIF
        ENDIF
      endif
 ENDIF
 
;JOWbeg
;      FOOT pr.perform_result_id
foot perfresultids
;JOWend
      IF (dont_print_proc = 0)
          ;prints textual result first
          FOR (i = 1 to nbr_comments)
            IF (r_long_text->qual[i]->perform_result_id = pr.perform_result_id
            and r_long_text->qual[i]->event_sequence = re.event_sequence
            and r_long_text->qual[i]->text_result > " ")
                IF (r_long_text->qual[i]->result_status_cd IN (corrected_cd, oldcorrected_cd))
                     CALL store_item(67, detail_row, captions->text_result_correct)		;019
                     vcstring =  r_long_text->qual[i]->text_result
                     detail_row =  store_varchar_item2(detail_row, 92, 39, 1) 
                ELSE
                     CALL store_item(67, detail_row, captions->text_result)		;019
                     vcstring = r_long_text->qual[i]->text_result
                     detail_row =  store_varchar_item2(detail_row, 80, 51, 1) 
                ENDIF
             ENDIF
          ENDFOR
          FOR (i = 1 to nbr_comments)
            IF (r_long_text->qual[i]->perform_result_id = pr.perform_result_id
            and r_long_text->qual[i]->event_sequence = re.event_sequence)
               IF (r_long_text->qual[i]->comment_text > " ")
                    detail_row = detail_row +1
                    CALL store_item(67, detail_row, captions->comment)			;019
                    vcstring = r_long_text->qual[i]->comment_text
                    detail_row =  store_varchar_item2(detail_row, 76, 55, 1) 
               ENDIF
               IF (r_long_text->qual[i]->note_text > " ")
                    detail_row = detail_row +1
                    CALL store_item(67, detail_row, captions->note)		;019
                    vcstring = r_long_text->qual[i]->note_text
                    detail_row =  store_varchar_item2(detail_row, 76, 55, 1) 
               ENDIF
             ENDIF
          ENDFOR
      ENDIF

      FOOT orderunique
; for the first line in this order, give the number of total lines
        reportstuff->qual[save1stline]->detailcount = detail_row - save1stline + 1
      FOOT personunique
; print out previous patient info and erase it from reportstuff array
        if (first_person = "Y")
            first_person = "N"
        else
            row + 2
        endif
        print_stuff
 
      FOOT PAGE
        row 59
        col   0, hyphen_line,
        row + 1
        col   1, captions->report_id,
        col  58, captions->page_no,
        col  64, curpage "###",
        col 110, curdate "@DATECONDENSED;;d"
        col 120, curtime "@TIMENOSECONDS;;M"
 
      FOOT REPORT
; print out last patient info and erase it from reportstuff array
        print_stuff
        row + 2
CALL CENTER(captions->end_of_report, 1, 132)
        select_ok_ind = 1
      WITH
        NOCOUNTER
        , DONTCARE = p_doc
        , OUTERJOIN = d_ptr
        , OUTERJOIN = ptr
        , OUTERJOIN = oc
        , OUTERJOIN = d_phs_grp
        , DONTCARE = bp2                ;BNK - 11/01/97
        , DONTCARE = op
        , DONTCARE = phs_grp
        , OUTERJOIN = d_cv_oc
        , DONTCARE = cv_oc
        , DONTCARE = prod
        , OUTERJOIN = d_ea
        , DONTCARE = ea
        , OUTERJOIN = d_ea2
        , compress, nolandscape ;BNK - 10/31/97
        , NULLREPORT
        , maxrow = 63
 
      IF (nbr_prs = 0)
        SET reply->status_data->status = "Z"
      ELSE
        SET reply->status_data->status = "S"
      ENDIF
 
      set rpt_cnt = rpt_cnt +1
      set stat = alterlist(reply->rpt_list, rpt_cnt)
      set reply->rpt_list[rpt_cnt].rpt_filename = cpm_cfn_info->file_name_path
 
      if (trim(request->batch_selection) > " ")
        set spool value(reply->rpt_list[rpt_cnt].rpt_filename) value(request->printer_name)
      endif
 
      if (select_ok_ind = 1)
         set reply->status_data->status = "S"
      endif
 
#exit_script
      free set testsites
 
END GO

;Generated by GNU enscript 1.6.4.
