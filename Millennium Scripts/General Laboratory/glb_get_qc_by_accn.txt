 ;;Solution_Test/script/PathNet -- Gen Lab/glb_get_qc_by_accn/glb_get_qc_by_accn.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1998 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/

/*****************************************************************************

        Source file name:       glb_get_qc_by_accn.prg
        Object name:            glb_get_qc_by_accn
        Request #:              257526

        Product:                General Lab
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Retrieve assays to be performed for a QC
                                accession.        

        Tables read:            resource_accession_r
                                control_material
                                control_lot
                                resource_lot_r
                                assay_resource_lot
                                assay_resource_translation
                                assay_processing_r
                                discrete_task_assay
                                qc_alpha_responses
                                nomenclature
                                data_map

        Tables updated:         None
        Executing from:         

        Special Notes:          

******************************************************************************/

;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;    *000 08/06/96 Kevin Brunner        Initial Release                     *
;    *001 09/15/97 Kevin Brunner        Add processing of arl_id            *
;    *002 11/17/97 Hal Patchen          Add subsection level data map check *
;    *003 12/12/97 Kevin Brunner        Add auto verify logic               *
;    *004 05/05/98 Hal Patchen          Verify subsection level data map    *
;    *                                  is associated with route test site  *
;    *005 03/22/99 Hal Patchen          Return control short desc and result*
;    *                                  processing meaning                  *
;    *006 09/06/00 Gary Runde           If pref perf results found, ignore  *
;    *                                  lot expiration dt/tm                *
;    *007 09/02/10 Oliver Barbara       Allow selection based on group_id.  *
;    *008 11/11/10 Steve Hendrick       Add worklist_id to Reply            *
;    *009 11/16/10 Oliver Barbara       Added check for older performed QC  *
;    *010 01/10/11 Hal Patchen          Derive alpha response sequences.    *
;    *011 08/22/08 Javed Khan           Add decimal_movement_nbr to reply   * 
;    *012 09/14/12 Rajini               declare the variable to double      *
;    *013 06/19/13 Prasath V Nair       Fix for CR 1-6636588997:Missing     * 
;    *                                  some alpha responses in ARE         *
;    *014 10/22/13 Balaji Murali        Fix for CR 1-7417939991             *
;~DE~************************************************************************


;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

             drop program GLB_GET_QC_BY_ACCN:dba go    
             create program GLB_GET_QC_BY_ACCN:dba
     
      /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
      /*
      record request
      (
         1  accession_id                  = f8
         1  service_resource_cd           = f8
         1  preactive_ind                 = i2
         1  previous_qc_ind               = i2
         1  qc_group_id                   = f8
      )
      */
      /***********************************************************************
      * Reply Record                                                         *
      ***********************************************************************/
      record reply
      ( 
         1  control_id                = f8
         1  control_desc              = vc
         1  control_short_desc        = vc                             ;005
         1  found_inactive_ind        = i2                             ;006
         1  manufacturer_cd           = f8
         1  manufacturer_disp         = vc
         1  control_type_cd           = f8
         1  control_type_disp         = vc
         1  group_id                  = f8
         1  group_dt_tm               = dq8
         1  lot_id                    = f8
         1  lot_number                = vc
         1  assay_list[20]
            2  display_sequence         = i4
            2  task_assay_cd            = f8
            2  qc_result_id             = f8
            2  mnemonic                 = vc
            2  qc_result_type_cd        = f8
            2  qc_result_type_disp      = c40
            2  qc_result_type_desc      = c60
            2  qc_result_type_mean      = c12
            2  instr_cnt                = i4
            2  instr[*]
               3  upld_assay_alias        = c25
               3  process_sequence        = i4
               3  default_result_type_cd  = f8
               3  post_zero_result_ind    = i2
	       3  decimal_movement_nbr    = i4	 ;007 
            2  data_map_ind             = i2
            2  max_digits               = i4
            2  min_decimal_places       = i4
            2  min_digits               = i4
            2  mean                     = f8
            2  arl_id                   = f8     ;001...
            2  clinical_std_dev         = f8
            2  statistical_std_dev      = f8
            2  abs_low                  = f8
            2  abs_high                 = f8
            2  rule_id                  = f8
            2  result_status_cd         = f8
            2  result_status_disp       = c40
            2  result_status_desc       = c60
            2  result_status_mean       = c12
            2  perform_personnel_id     = f8
            2  perform_personnel_name   = vc
            2  perform_dt_tm            = dq8
            2  result_value_numeric     = f8
            2  numeric_raw_value        = f8
            2  result_value_alpha       = c25
            2  result_process_cd        = f8
            2  result_process_disp      = c40                          ;005
            2  result_process_mean      = c12                          ;005
            2  comment_ind              = i2
            2  long_text                = vc
            2  nomenclature_id          = f8
            2  nbr_alpha_responses      = i4
            2  updt_cnt                 = i4
            2  alpha_list[*]
               3  nomenclature_id         = f8
               3  nomenclature_desc       = vc
               3  nomenclature_mnemonic   = c25
               3  result_process_cd       = f8
               3  result_process_disp     = vc
               3  default_ind             = i2
               3  reference_range_factor_id = f8
               3  sequence                = i4
            2  service_resource_cd        = f8
            2  service_resource_disp      = vc
            2  worklist_id                = f8
            2  copy_forward_worklist_id   = f8
%i cclsource:status_block.inc
         1  older_active_qc_exists      = i2
         1  dependent_group_id          = f8
      )

      /***********************************************************************
      * Check for group to be selected as previously performed               *
      ***********************************************************************/
        declare sel_qc_group( none ) = i4
        subroutine sel_qc_group( none )

          set curr_qc_group = 0
          set reply->group_id = 0
          set reply->group_dt_tm = 0
          select into "nl:"
            qrg.qc_group_id,
            qrg.accession_id,
            qrg.group_dt_tm

          from
            qc_result_grp qrg

          plan qrg
            where qrg.accession_id = request->accession_id
              and ((request->qc_group_id = 0 and qrg.status_flag < 2) or 
                   (request->qc_group_id > 0 and qrg.qc_group_id = request->qc_group_id))

          order
            cnvtdatetime(qrg.group_dt_tm) asc

          detail
            if (curr_qc_group = 0)
              curr_qc_group = qrg.qc_group_id
              reply->group_id = qrg.qc_group_id
              reply->group_dt_tm = qrg.group_dt_tm
            endif

          with nocounter

          return(curqual)
        end
        
       
      /***********************************************************************
      * Find older QC results that have not been completed                   *
      ***********************************************************************/
        declare find_older_active_qc( none ) = f8
        subroutine find_older_active_qc( none )

          set dependent_group_id = 0.0

          select into "nl:"

          from
            qc_result_grp qrg

          plan qrg
            where qrg.accession_id = request->accession_id
              and qrg.status_flag < 2 
              and qrg.group_dt_tm < cnvtdatetime(reply->group_dt_tm)
          order by qrg.group_dt_tm desc
          head qrg.accession_id
            dependent_group_id = qrg.qc_group_id

          with nocounter

          return(dependent_group_id)
        end
      
/***************************;006 BEGIN NEW CODE ****************************/      
      /***********************************************************************
      * Check to see if qc result is for lot that is expired                 *
      ***********************************************************************/
        subroutine check_for_expired_lot( none )

          set return_value = 0
          
          select into "nl:"
            qrg.qc_group_id,
            qr.qc_group_id,
            cl.lot_id
          from
            qc_result_grp qrg,
            qc_result qr,
            resource_lot_r rlr
          plan qrg
            where qrg.qc_group_id = curr_qc_group
          join qr
            where qr.qc_group_id = qrg.qc_group_id
          join rlr
            where rlr.lot_id = qr.lot_id
              and rlr.service_resource_cd = qr.service_resource_cd
          order
            qr.lot_id
          head qr.lot_id
            if (cnvtdatetime(curdate,curtime3) >= rlr.defined_inactive_dt_tm)
              return_value = 1
            else
              return_value = 0
            endif
          with nocounter

          if (curqual = 0)
            return(curqual)
          else
          	return (value(return_value))
          endif
        end
/***************************;006 END NEW CODE ****************************/      
      
      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
      #Script
         set alpha_cnt = 0
         set assay_cnt = 0
         
         set reply->status_data.status = "F"

         declare result_status_pending_cd = f8
         declare result_status_old_perf_cd = f8
         declare result_status_performed_cd = f8
         declare result_status_verified_cd = f8
         declare result_status_auto_verf_cd = f8  ;003
         declare result_status_corrected_cd = f8
         declare result_status_change_cd   = f8
         declare result_status_old_chg_cd  = f8
         declare result_status_accept_cd   = f8
         declare result_status_reject_cd   = f8
         declare result_status_discard_cd   = f8
         declare serv_res_subsection_cd    = f8                           ;004
         declare qc_comment_cd             = f8
         declare assay_idx                  = i4 with protect, noconstant(0)
         declare a_idx                      = i4 with protect, noconstant(0)
         declare curr_qc_group = f8 with protect, noconstant(0)
 
         declare alpha_response_idx = i4 with protect, noconstant(0)  
         declare start_idx = i4 with protect, noconstant(0)				
         declare pos = i4 with protect, noconstant(0)
 
         set curr_qc_group = 0     
         set COMMENT_CODESET             = 14
         set QC_COMMENT_CDF              = "QC FTNT"
         set RESULT_STATUS_CODESET       = 1901
         set RESULT_STATUS_PENDING_CDF   = "PENDING"
         set RESULT_STATUS_PERFORMED_CDF = "PERFORMED"
         set RESULT_STATUS_OLD_PERF_CDF  = "OLDPERFORMED"
         set RESULT_STATUS_VERIFIED_CDF  = "VERIFIED"
         set RESULT_STATUS_AUTO_VERF_CDF = "AUTOVERIFIED"  ;003
         set RESULT_STATUS_CORRECTED_CDF = "CORRECTED"
         set RESULT_STATUS_CHANGE_CDF    = "CHANGE"
         set RESULT_STATUS_OLD_CHG_CDF   = "OLD CHANGE"
         set RESULT_STATUS_ACCEPT_CDF    = "ACCEPT"
         set RESULT_STATUS_REJECT_CDF    = "REJECT"
         set RESULT_STATUS_DISCARD_CDF    = "DISCARD"
         set SERV_RES_TYPE_CODESET       = 223                         ;004
         set SERV_RES_SUBSECTION_CDF     = "SUBSECTION"                ;002
      /***********************************************************************
      * Load result status code sets                                         *
      ***********************************************************************/
         select into "nl:"
            cv.code_set,
            cv.code_value  
         from
            code_value cv
         where cv.code_set in ( RESULT_STATUS_CODESET,
                                SERV_RES_TYPE_CODESET,                 ;004
                                COMMENT_CODESET )
           and cv.active_ind = 1
           and (cv.begin_effective_dt_tm <= cnvtdatetime(curdate, curtime3)
             and  cv.end_effective_dt_tm >= cnvtdatetime(curdate, curtime3))

         detail
            if (cv.code_set = RESULT_STATUS_CODESET)
               case (cv.cdf_meaning)
                 of RESULT_STATUS_PENDING_CDF:
                    result_status_pending_cd = cv.code_value
                 of RESULT_STATUS_PERFORMED_CDF:
                    result_status_performed_cd = cv.code_value
                 of RESULT_STATUS_OLD_PERF_CDF:
                    result_status_old_perf_cd = cv.code_value
                 of RESULT_STATUS_VERIFIED_CDF:
                    result_status_verified_cd = cv.code_value
                    result_status_verified_disp = cv.display
                 of RESULT_STATUS_AUTO_VERF_CDF:  ;003
                    result_status_auto_verf_cd = cv.code_value  ;003
                 of RESULT_STATUS_CORRECTED_CDF:
                    result_status_corrected_cd = cv.code_value
                 of RESULT_STATUS_CHANGE_CDF:
                    result_status_change_cd = cv.code_value
                 of RESULT_STATUS_OLD_CHG_CDF:
                    result_status_old_chg_cd = cv.code_value
                 of RESULT_STATUS_ACCEPT_CDF:
                    result_status_accept_cd = cv.code_value
                 of RESULT_STATUS_REJECT_CDF:
                    result_status_reject_cd = cv.code_value
                 of RESULT_STATUS_DISCARD_CDF:
                    result_status_discard_cd = cv.code_value
               endcase
            endif
            if (cv.code_set = COMMENT_CODESET)
               case (cv.cdf_meaning)
                 of QC_COMMENT_CDF:
                    qc_comment_cd = cv.code_value
               endcase
            endif
            if (cv.code_set = SERV_RES_TYPE_CODESET)                   ;004
               case (cv.cdf_meaning)                                   ;004
                 of SERV_RES_SUBSECTION_CDF:                           ;004
                    serv_res_subsection_cd = cv.code_value             ;004
               endcase                                                 ;004
            endif                                                      ;004
         with nocounter
      
/***************************;006 BEGIN NEW CODE ****************************/      
        ;set reply ind to default of no inactive info found
        set reply->found_inactive_ind = 0
        ;set flag to tell whether previous qc results have been found
        set found_expired_results = 0
        ;set flag to tell whether previous qc results are for a lot that is expired
        set found_perf_qc_results = 0
        if (request->previous_qc_ind = 1)
	        if (sel_qc_group( 0 ) != 0)           
	           ;set flag to tell script that previous qc results have been found
	           set found_perf_qc_results = 1
	           ;set flag to return value from sub to look for expired lot
	           set found_expired_results = check_for_expired_lot( 0 )
               set reply->found_inactive_ind = found_expired_results
               
               set reply->dependent_group_id = find_older_active_qc( 0 )
               if (reply->dependent_group_id > 0.0)
                 set reply->older_active_qc_exists = 1
               endif
	        endif
	    endif
      /***********************************************************************
      * Select QC information based on accession id                          *
      ***********************************************************************/

      if (found_expired_results = 1)
         ;if previous qc results have been found then use the qc_results table
         ;as the driver for the select
         
         select into "nl:"        
             qr.control_id,
             cm.control_id,
             cl.control_id,
             arl.lot_id,
             apr.display_sequence,
             dta.task_assay_cd
         from
           qc_result qr,
           control_material cm,
           control_lot cl,
           assay_resource_lot arl,
           assay_processing_r apr,
           discrete_task_assay dta
         plan qr
             where qr.qc_group_id = curr_qc_group
               and qr.service_resource_cd = request->service_resource_cd
         join cm
             where cm.control_id = qr.control_id
         join cl
             where cl.lot_id = qr.lot_id
         join arl
             where arl.lot_id = cl.lot_id
               and arl.service_resource_cd = qr.service_resource_cd
               and arl.active_ind = 1
         join apr
             where apr.service_resource_cd = arl.service_resource_cd
               and apr.task_assay_cd = arl.task_assay_cd
         join dta
             where apr.task_assay_cd = dta.task_assay_cd
         order
            cm.control_id,
            apr.display_sequence,
            dta.task_assay_cd
         head report
            assay_cnt = 0
            alpha_cnt = 0

         head cm.control_id
            reply->control_id = cm.control_id
            reply->control_desc = cm.description
            reply->control_short_desc = cm.short_description
            reply->manufacturer_cd = cm.manufacturer_cd
            reply->control_type_cd = cm.control_type_cd
            reply->lot_id = cl.lot_id
            reply->lot_number = cl.lot_number
         head dta.task_assay_cd
            assay_cnt = assay_cnt + 1
            if (mod(assay_cnt,20) = 1 and assay_cnt != 1)
               stat = alter(reply->assay_list, assay_cnt + 20)
            endif
            reply->assay_list[assay_cnt].display_sequence = apr.display_sequence
            reply->assay_list[assay_cnt].task_assay_cd = dta.task_assay_cd
            reply->assay_list[assay_cnt].mnemonic = dta.mnemonic
            reply->assay_list[assay_cnt].qc_result_id = 0
            reply->assay_list[assay_cnt].result_status_cd =
                   result_status_pending_cd
            if (apr.qc_result_type_cd = Null or
               apr.qc_result_type_cd = 0)
                reply->assay_list[assay_cnt].qc_result_type_cd =
                       apr.default_result_type_cd
            else
                reply->assay_list[assay_cnt].qc_result_type_cd =
                       apr.qc_result_type_cd
            endif
            reply->assay_list[assay_cnt].arl_id = arl.arl_id
            reply->assay_list[assay_cnt].mean = arl.mean
            reply->assay_list[assay_cnt].clinical_std_dev =
                                     arl.clinical_std_dev
            reply->assay_list[assay_cnt].statistical_std_dev =
                                     arl.statistical_std_dev
            reply->assay_list[assay_cnt].abs_low = arl.abs_low
            reply->assay_list[assay_cnt].abs_high = arl.abs_high
            reply->assay_list[assay_cnt].rule_id = arl.rule_id
            reply->assay_list[assay_cnt].worklist_id = qr.worklist_id 
            reply->assay_list[assay_cnt].copy_forward_worklist_id = qr.copy_forward_worklist_id 

         with 
            nocounter
      else
         ;if the qc_results were either not found or they are not for a 
         ;expired lot, then just get the reference information set up on the database
/***************************;006  END NEW CODE ****************************/
         select into "nl:"        
             cm.control_id,
             apr.display_sequence,
             dta.task_assay_cd
/* Selection fields
             rar.accession_id,
             rar.service_resource_cd,
             rar.control_id,
             cm.description,
             cm.manufacturer_cd,
             cm.control_type_cd,
             cl.lot_id,
             cl.lot_number,
             cl.control_id,
             rlr.lot_id,
             rlr.service_resource_cd,
             rlr.defined_active_dt_tm,
             rlr.defined_inactive_dt_tm,
             arl.task_assay_cd,
             arl.mean,
             arl.arl_id,   ;001...
             arl.clinical_std_dev,
             arl.statistical_std_dev,
             arl.abs_low,
             arl.abs_high,
             arl.rule_id,
             apr.service_resource_cd,
             apr.task_assay_cd,
             apr.qc_result_type_cd,
             apr.upld_assay_alias,
             dta.mnemonic
*/

         from
           resource_accession_r rar,
           control_material cm,
           control_lot cl,
           resource_lot_r rlr,
           assay_resource_lot arl,
           assay_processing_r apr,
           discrete_task_assay dta

         plan rar
             where rar.accession_id = request->accession_id
               and rar.service_resource_cd = request->service_resource_cd
         join cm
             where cm.control_id = rar.control_id
         join cl
             where cl.control_id = rar.control_id
               and (cnvtdatetime(curdate,curtime3) between
                    cl.receive_dt_tm and
                    cl.expiration_dt_tm)
         join rlr
             where rlr.lot_id = cl.lot_id
               and rlr.service_resource_cd = rar.service_resource_cd
               and ((request->preactive_ind = 0 
                    and cnvtdatetime(curdate,curtime3) between
                        rlr.defined_active_dt_tm and
                        rlr.defined_inactive_dt_tm))
                   or
                    (request->preactive_ind = 1
                    and cnvtdatetime(curdate,curtime3) <=
                                          rlr.defined_active_dt_tm)
         join arl
             where arl.lot_id = rlr.lot_id
               and arl.service_resource_cd = rar.service_resource_cd
               and arl.active_ind = 1
         join apr
             where apr.service_resource_cd = arl.service_resource_cd
               and apr.task_assay_cd = arl.task_assay_cd
         join dta
             where apr.task_assay_cd = dta.task_assay_cd

         order
            cm.control_id,
            apr.display_sequence,
            dta.task_assay_cd

         head report
            assay_cnt = 0
            alpha_cnt = 0

         head cm.control_id
            reply->control_id = cm.control_id
            reply->control_desc = cm.description
            reply->control_short_desc = cm.short_description           ;005
            reply->manufacturer_cd = cm.manufacturer_cd
            reply->control_type_cd = cm.control_type_cd
            reply->lot_id = cl.lot_id
            reply->lot_number = cl.lot_number
            
         head dta.task_assay_cd
            assay_cnt = assay_cnt + 1
            if (mod(assay_cnt,20) = 1 and assay_cnt != 1)
               stat = alter(reply->assay_list, assay_cnt + 20)
            endif
            reply->assay_list[assay_cnt].display_sequence = apr.display_sequence
            reply->assay_list[assay_cnt].task_assay_cd = dta.task_assay_cd
            reply->assay_list[assay_cnt].mnemonic = dta.mnemonic
            reply->assay_list[assay_cnt].qc_result_id = 0
            reply->assay_list[assay_cnt].result_status_cd =
                   result_status_pending_cd
            if (apr.qc_result_type_cd = Null or
               apr.qc_result_type_cd = 0)
                reply->assay_list[assay_cnt].qc_result_type_cd =
                       apr.default_result_type_cd
            else
                reply->assay_list[assay_cnt].qc_result_type_cd =
                       apr.qc_result_type_cd
            endif
            reply->assay_list[assay_cnt].arl_id = arl.arl_id  ;001...
            reply->assay_list[assay_cnt].mean = arl.mean
            reply->assay_list[assay_cnt].clinical_std_dev =
                                     arl.clinical_std_dev
            reply->assay_list[assay_cnt].statistical_std_dev =
                                     arl.statistical_std_dev
            reply->assay_list[assay_cnt].abs_low = arl.abs_low
            reply->assay_list[assay_cnt].abs_high = arl.abs_high
            reply->assay_list[assay_cnt].rule_id = arl.rule_id

         with 
            nocounter
      endif

      /***********************************************************************
      * Select instrument upload information.                                *
      ***********************************************************************/
        if (request->previous_qc_ind != 1)

         select into "nl:"
            d1.seq,
            apr.seq,
            art.seq

            /* Selection fields:
            d1.seq,
            apr.service_resource_cd,
            apr.task_assay_cd,
            apr.default_result_type_cd,
            art.upld_assay_alias,
            art.process_sequence,
            art.post_zero_result_ind
            */

         from
            (dummyt d1 with seq = value(assay_cnt)),
            assay_processing_r apr,
            assay_resource_translation art

         plan d1
         join apr where apr.service_resource_cd =
                          request->service_resource_cd
                    and apr.task_assay_cd =
                          reply->assay_list[d1.seq].task_assay_cd
         join art where art.task_assay_cd = apr.task_assay_cd
                    and art.service_resource_cd = apr.service_resource_cd
                    and art.active_ind > 0

         head report
            a_cnt = 0
            i_cnt = 0
            
         head d1.seq
            a_cnt = d1.seq
            i_cnt = 0

         detail
            i_cnt = i_cnt + 1
            stat = alterlist(reply->assay_list[a_cnt].instr, i_cnt)
            reply->assay_list[a_cnt].instr_cnt = i_cnt
            reply->assay_list[a_cnt].instr[i_cnt].upld_assay_alias =
              art.upld_assay_alias
            reply->assay_list[a_cnt].instr[i_cnt].process_sequence = 
              art.process_sequence
	    reply->assay_list[a_cnt].instr[i_cnt]. decimal_movement_nbr = 
              art. decimal_movement_nbr                                             ;011
            if (apr.qc_result_type_cd = Null or
               apr.qc_result_type_cd = 0)
                reply->assay_list[a_cnt].instr[i_cnt].default_result_type_cd =
                       apr.default_result_type_cd
            else
                reply->assay_list[a_cnt].instr[i_cnt].default_result_type_cd =
                       apr.qc_result_type_cd
            endif
;            reply->assay_list[a_cnt].instr[i_cnt].default_result_type_cd = 
;              apr.default_result_type_cd
            reply->assay_list[a_cnt].instr[i_cnt].post_zero_result_ind = 
              art.post_zero_result_ind
            
         with nocounter
        endif

      /***********************************************************************
      * Select numeric map                                                   *
      ***********************************************************************/
         select into "nl:"
             d1.seq,
             d2.seq,
             dm_exists = decode(dm.seq, "Y", "N"),
             dm.service_resource_cd,
             dm.task_assay_cd,
             dm.data_map_type_flag,
             dm.max_digits,
             dm.min_digits,
             dm.min_decimal_places,
             d_rg.seq,
             rg_exists = decode(rg.seq, "Y", "N"),
             rg.parent_service_resource_cd,
             rg.child_service_resource_cd,
             rg.resource_group_type_cd,
             rg.root_service_resource_cd

         from
            (dummyt d1 with seq = value(assay_cnt)),
            (dummyt d2 with seq = 1),
            data_map dm,
            (dummyt d_rg with seq = 1),
            resource_group rg

         plan    d1
         join   (d2
                  where d2.seq = 1
                join dm
                  where dm.task_assay_cd =
                        reply->assay_list[d1.seq].task_assay_cd
                    and dm.data_map_type_flag in (0, 1)
                    and dm.active_ind = 1
                join d_rg
                  where d_rg.seq = 1
                join rg
                  where rg.parent_service_resource_cd =
                        dm.service_resource_cd
                    and rg.child_service_resource_cd =
                        request->service_resource_cd
                    and rg.resource_group_type_cd =
                        serv_res_subsection_cd
                    and rg.root_service_resource_cd = 0.0)

         head d1.seq
            reply->assay_list[d1.seq].data_map_ind = 0
            data_map_level = 0

         detail
            if (dm_exists = "Y")
                ;* Check for exact match on QC data map
                if (data_map_level <= 3
                and dm.data_map_type_flag = 1
                and dm.service_resource_cd > 0.0
                and dm.service_resource_cd =
                  request->service_resource_cd)
                   data_map_level = 4
                   reply->assay_list[d1.seq].data_map_ind = 1
                   reply->assay_list[d1.seq].max_digits =
                     dm.max_digits
                   reply->assay_list[d1.seq].min_digits =
                     dm.min_digits
                   reply->assay_list[d1.seq].min_decimal_places =
                     dm.min_decimal_places
                endif
                ;* Check for exact match on data map
                if (data_map_level <= 2
                and dm.data_map_type_flag = 0
                and dm.service_resource_cd > 0.0
                and dm.service_resource_cd =
                  request->service_resource_cd)
                   data_map_level = 3
                   reply->assay_list[d1.seq].data_map_ind = 1
                   reply->assay_list[d1.seq].max_digits =
                     dm.max_digits
                   reply->assay_list[d1.seq].min_digits =
                     dm.min_digits
                   reply->assay_list[d1.seq].min_decimal_places =
                     dm.min_decimal_places
                endif
                ;* Check for subsection level data map
                if (data_map_level <= 1
                and dm.data_map_type_flag = 0
                and dm.service_resource_cd > 0.0
                and rg_exists = "Y"
                and rg.parent_service_resource_cd =
                            dm.service_resource_cd
                and rg.child_service_resource_cd =
                            request->service_resource_cd)
                   data_map_level = 2
                   reply->assay_list[d1.seq].data_map_ind = 1
                   reply->assay_list[d1.seq].max_digits =
                     dm.max_digits
                   reply->assay_list[d1.seq].min_digits =
                     dm.min_digits
                   reply->assay_list[d1.seq].min_decimal_places =
                     dm.min_decimal_places
                endif
                ;* Check for default all resources level data map
                if (data_map_level = 0
                and dm.data_map_type_flag = 0
                and dm.service_resource_cd = 0.0)
                   data_map_level = 1
                   reply->assay_list[d1.seq].data_map_ind = 1
                   reply->assay_list[d1.seq].max_digits =
                     dm.max_digits
                   reply->assay_list[d1.seq].min_digits =
                     dm.min_digits
                   reply->assay_list[d1.seq].min_decimal_places =
                     dm.min_decimal_places
                endif
            endif
             
         foot d1.seq
            row + 1

         with nocounter,
              outerjoin = d2,
              dontcare = dm,
              outerjoin = d_rg,
              dontcare = rg

      /***********************************************************************
      * Select alpha responses                                               *
      ***********************************************************************/
         select into "nl:"
             a_cnt = locateval(a_idx, 1, assay_cnt, qar.task_assay_cd, reply->assay_list[a_idx].task_assay_cd),
             qar.nomenclature_id,
             qar.result_process_cd,
             qar.default_ind,
             n.nomenclature_id,
             n.source_string,
             rrf.reference_range_factor_id,
             rrf.task_assay_cd,
             rrf.precedence_sequence,
             rrf.service_resource_cd,
             ar.sequence

         from
            qc_alpha_responses qar,
            nomenclature n,
            (dummyt d_rrf with seq = 1),
            reference_range_factor rrf,
            alpha_responses ar

         plan qar   where expand(assay_idx, 1, assay_cnt, qar.task_assay_cd, reply->assay_list[assay_idx].task_assay_cd)
                      and qar.service_resource_cd = request->service_resource_cd
                      and qar.control_id = reply->control_id
                      and qar.nomenclature_id > 0.0
         join n     where n.nomenclature_id = qar.nomenclature_id
         join d_rrf where d_rrf.seq = 1
         join rrf   where rrf.task_assay_cd = qar.task_assay_cd
                      and (rrf.service_resource_cd = qar.service_resource_cd 
                       or rrf.service_resource_cd = 0)
                      and rrf.active_ind = 1
                      and rrf.beg_effective_dt_tm <= cnvtdatetime(curdate, curtime3)
                      and rrf.end_effective_dt_tm >= cnvtdatetime(curdate, curtime3)
         join ar    where ar.reference_range_factor_id = rrf.reference_range_factor_id
                      and ar.nomenclature_id = n.nomenclature_id

         order by 
            a_cnt,
            rrf.service_resource_cd desc,
            rrf.precedence_sequence,
            ar.sequence
         
         head report
            alpha_cnt = 0
            ref_range_level = 0
            add_alpha_responses_ind = 0
            
         head a_cnt
            alpha_cnt = 0
            ref_range_level = 0
            add_alpha_responses_ind = 0
 
         head rrf.service_resource_cd
            add_alpha_responses_ind = 0
            ref_range_level = 0
 
         head rrf.precedence_sequence
            add_alpha_responses_ind = 0
            ref_range_level = 0				;013
            alpha_response_idx = 0
            start_idx = 0 
            
            ;* Check for no reference range factor rows.  If none exist, the alpha response sequence
            ;* cannot be determined.  Just add the defined QC alpha responses.
            if (rrf.reference_range_factor_id = 0.0)
               add_alpha_responses_ind = 1
            endif

            ;* Check for reference range factor row sequenced first.  Sequence
            ;* the alpha responses based on the first row when an ALL service
            ;* resource row or a match on a specific service resource row does not exist.
            if (ref_range_level < 1
            and rrf.reference_range_factor_id > 0.0
            and rrf.service_resource_cd > 0.0
            and rrf.service_resource_cd != request->service_resource_cd)
               ref_range_level = 1
               add_alpha_responses_ind = 1
            endif

            ;* Check for reference range factor row defined for ALL service resources.
            ;* Sequence the alpha responses based on the first ALL service resource row
            ;* found when a match on a specific service resource row does not exist.
            if (ref_range_level < 2
            and rrf.reference_range_factor_id > 0.0
            and rrf.service_resource_cd = 0.0
            and rrf.service_resource_cd != request->service_resource_cd)
               ref_range_level = 2
               add_alpha_responses_ind = 1
            endif

            ;* Check for reference range factor row that matches on the specific service resource.
            ;* Sequence the alpha responses based on the first specific service resource row found.
            if (ref_range_level < 3
            and rrf.reference_range_factor_id > 0.0
            and rrf.service_resource_cd > 0.0
            and rrf.service_resource_cd = request->service_resource_cd)
               ref_range_level = 3
               add_alpha_responses_ind = 1
            endif

         
         detail
            if (add_alpha_responses_ind = 1)
               pos = 0
               
               if(alpha_cnt > 0)
                 pos = locateval(alpha_response_idx, start_idx, size(reply->assay_list[a_cnt].alpha_list, 5),
                    qar.nomenclature_id, reply->assay_list[a_cnt].alpha_list[alpha_response_idx].nomenclature_id)                 
               endif
 
               if(pos = 0)
                 alpha_cnt = alpha_cnt + 1
                 stat = alterlist(reply->assay_list[a_cnt].alpha_list, alpha_cnt)
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].nomenclature_id = qar.nomenclature_id
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].nomenclature_desc = n.short_string
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].nomenclature_mnemonic = n.mnemonic
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].result_process_cd = qar.result_process_cd
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].default_ind = qar.default_ind
                 reply->assay_list[a_cnt].alpha_list[alpha_cnt].reference_range_factor_id = rrf.reference_range_factor_id
                 if (ar.reference_range_factor_id > 0.0)
                   reply->assay_list[a_cnt].alpha_list[alpha_cnt].sequence = ar.sequence
                 endif
               endif
            endif
            
         foot rrf.precedence_sequence
            row + 0
            
         foot a_cnt
            reply->assay_list[a_cnt].nbr_alpha_responses = alpha_cnt

         with nocounter,
              outerjoin = d_rrf,
              dontcare = rrf,
              dontcare = ar
      
      
      /***********************************************************************
      * Check for previously performed qc results                            *
      ***********************************************************************/
        if (request->previous_qc_ind = 1)

;006          if (sel_qc_group( 0 ) != 0)
          ;the sel_qc_group sub was called above so just check the flag it returned
          ;instead of calling the script again
          if (found_perf_qc_results = 1)
            select into "nl:"
              d1.seq,
              d2.seq,
              qr.qc_result_id,
              qc.action_sequence,
              qc_exists = decode(qc.seq, "Y", "N")
/* Selection fields
              qr.lot_id,
              qr.service_resource_cd,
              qr.task_assay_cd,
              qr.result_status_cd,
              qr.perform_personnel_id,
              qr.perform_dt_tm,
              qr.result_type_cd,
              qr.result_value_numeric,
              qr.result_value_alpha,
              qr.nomenclature_id,
              pl.name_full_formatted,
              qc.qc_result_id,
              qc.comment_type_cd,
              l.long_text_id,
              l.long_text
*/

            from
              qc_result qr,
              prsnl pl,
              (dummyt d1 with seq = value(assay_cnt)),
              dummyt d2,
              qc_comment qc,
              long_text l

            plan qr
              where qr.qc_group_id = curr_qc_group
                and qr.lot_id = reply->lot_id
                and qr.service_resource_cd = request->service_resource_cd
                and qr.result_status_cd in ( result_status_performed_cd,
                                             result_status_verified_cd,
                                             result_status_auto_verf_cd,  ;003
                                             result_status_corrected_cd,
                                             result_status_change_cd,
                                             result_status_accept_cd,
                                             result_status_reject_cd,
                                             result_status_discard_cd)
            join pl
              where pl.person_id = qr.perform_personnel_id
            join d1
              where qr.task_assay_cd = reply->assay_list[d1.seq].task_assay_cd
            join d2
              where d2.seq = 1
            join qc
              where qc.qc_result_id = qr.qc_result_id
                and qc.comment_type_cd = qc_comment_cd
            join l
              where l.long_text_id = qc.long_text_id

            order d1.seq,
                  qr.qc_result_id,
                  qc.action_sequence desc

            head d1.seq

              reply->assay_list[d1.seq].qc_result_id =
                     qr.qc_result_id
;              reply->assay_list[d1.seq].qc_result_type_cd =
;                     qr.result_type_cd
              reply->assay_list[d1.seq].result_status_cd =
                     qr.result_status_cd
              reply->assay_list[d1.seq].perform_personnel_id =
                     qr.perform_personnel_id
              reply->assay_list[d1.seq].perform_personnel_name =
                     pl.name_full_formatted
              reply->assay_list[d1.seq].perform_dt_tm =
                     qr.perform_dt_tm
              reply->assay_list[d1.seq].result_value_numeric =
                     qr.result_value_numeric
              reply->assay_list[d1.seq].numeric_raw_value =
                     qr.numeric_raw_value
              reply->assay_list[d1.seq].result_value_alpha =
                     qr.result_value_alpha
              reply->assay_list[d1.seq].nomenclature_id =
                     qr.nomenclature_id
              reply->assay_list[d1.seq].result_process_cd =
                     qr.result_process_cd
              reply->assay_list[d1.seq].updt_cnt = qr.updt_cnt
              if (qc_exists = "Y")
                reply->assay_list[d1.seq].comment_ind = 1
                reply->assay_list[d1.seq].long_text = l.long_text
              else
                reply->assay_list[d1.seq].comment_ind = 0
              endif
              reply->assay_list[d1.seq].service_resource_cd = qr.service_resource_cd
              reply->assay_list[d1.seq].worklist_id = qr.worklist_id 
              reply->assay_list[d1.seq].copy_forward_worklist_id = qr.copy_forward_worklist_id 

            with nocounter,
                 outerjoin = d2

          endif
        endif
      /***********************************************************************
      * Resize reply record                                                  *
      ***********************************************************************/
      
      #Resize_Reply
         if (assay_cnt > 0)
            set reply->status_data.status = "S"    ;Successful
         else
            set reply->status_data.status = "Z"    ;Zero
            set assay_cnt = 1
         endif
         set stat = alter(reply->assay_list, assay_cnt)

         end
         go      






;Generated by GNU enscript 1.6.4.
