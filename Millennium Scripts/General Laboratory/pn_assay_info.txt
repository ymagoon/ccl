 ;;Solution_Test/script/PathNet -- Common Services/pfmt_250074/pn_assay_info.inc Turn on black mode

;************************************************************************
;*                      MODIFICATION CONTROL LOG                        *
;************************************************************************
;*                                                                      *
;*Mod Date     Engineer             Comment                             *
;*--- -------- -------------------- ----------------------------------- *
;*000 01/17/05 Nick Smith           Initial release                     *
;************************************************************************
 
/***********************************************************************
* PN_ASSAY_INFO.INC                                                    *
* This file contains subroutines used in conjuction with the           *
* pn_assay_info structure to obtain assay information.                 *
***********************************************************************/

/***********************************************************************
* This subroutine is used to read the discrete_task_assay table and    *
* load the pn_assay_info structure.                                    *
***********************************************************************/
declare load_pn_assay_info() = i2
subroutine load_pn_assay_info(null)

  call log_message("called into load_pn_assay_info", log_level_debug)

  declare lEIdx = i4 with protect, noconstant(0)
  declare lOldCnt = i4 with protect, noconstant(0)
  declare lNewCnt = i4 with protect, noconstant(0)
  declare lIdx = i4 with protect, noconstant(0)
  declare nEXPAND_SIZE = i2 with protect, constant(50)
  declare lLoopCnt = i4 with protect, noconstant(0)
  declare lStart = i4 with protect, noconstant(0)
  declare lPos = i4 with protect, noconstant(0)

  set lOldCnt = size(pn_assay_info->assays, 5)
  
  if (lOldCnt > 0)
    set lLoopCnt = ceil(cnvtreal(lOldCnt) / nEXPAND_SIZE)
    set lNewCnt = lLoopCnt * nEXPAND_SIZE
    set stat = alterlist(pn_assay_info->assays, lNewCnt)
    set lStart = 1
    
    for (lIdx = lOldCnt + 1 to lNewCnt)
      set pn_assay_info->assays[lIdx].task_assay_cd = pn_assay_info->assays[lOldCnt].task_assay_cd
    endfor
    
    select into "nl:"
    from discrete_task_assay dta,
         (dummyt d with seq = value(lLoopCnt))
    plan d   where assign(lStart, evaluate(d.seq, 1,1, lStart + nEXPAND_SIZE))
    join dta where expand(lEIdx, lStart, lStart + (nEXPAND_SIZE - 1), 
                          dta.task_assay_cd, pn_assay_info->assays[lEIdx].task_assay_cd)
    detail
      lPos = locateval(lIdx, 1, lOldCnt, dta.task_assay_cd, pn_assay_info->assays[lIdx].task_assay_cd)
      
      if (lPos > 0)
        pn_assay_info->assays[lPos].sci_notation_ind = dta.sci_notation_ind
      endif
    with nocounter
    
    set stat = alterlist(pn_assay_info->assays, lOldCnt)
  endif
  
  ;check for CCL error in above logic
  if (error_message(0) > 0)
    return(0)
  endif

  call log_message("end of load_pn_assay_info", log_level_debug)

  return(1)
end

/***********************************************************************
* This subroutine is used to read the pn_assay_info structure and      *
* return the sci_notation_ind setting for the given task_assay_cd.     *
* If pn_assay_info structure does not exist or the task_assay_cd       *
* cannot be found, then 0 is returned.                                 *
***********************************************************************/
declare get_sci_notation_ind(dTaskAssayCd = f8) = i2
subroutine get_sci_notation_ind(dTaskAssayCd)

  call log_message("called into get_sci_notation_ind", log_level_debug)

  declare lPos = i4 with protect, noconstant(0)
  declare lIdx = i4 with protect, noconstant(0)
  declare nReturnValue = i2 with protect, noconstant(0)

  set nReturnValue = 0

  if (validate(pn_assay_info) = 1)
    set lPos = locateval(lIdx, 1, size(pn_assay_info->assays, 5), dTaskAssayCd, pn_assay_info->assays[lIdx].task_assay_cd)
    
    if (lPos > 0)
      set nReturnValue = pn_assay_info->assays[lPos].sci_notation_ind
    endif
  endif

  call log_message(build("return value =", nReturnValue, " for task_assay_cd =", dTaskAssayCd), log_level_debug) 

  call log_message("end of get_sci_notation_ind", log_level_debug)

  return (nReturnValue)
end

;Generated by GNU enscript 1.6.4.
