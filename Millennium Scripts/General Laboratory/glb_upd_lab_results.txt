 ;;Solution_Test/script/PathNet -- Gen Lab/glb_upd_lab_results/glb_upd_lab_results.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1999 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/
 
/*****************************************************************************
 
        Source file name:       glb_upd_lab_results.prg
        Object name:            glb_upd_lab_results
        Request #:              250074
 
        Product:                General Lab
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0
 
        Program purpose:        Update lab results.
 
        Tables read:            code_value
 
        Tables updated:         included_components
                                interp_data
                                long_text
                                perform_result
                                result
                                result_comment
                                result_event
        Executing from:
 
        Special Notes:
 
******************************************************************************/
 
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;    *000 04/05/96 Hal Patchen          Initial Release                     *
;    *001 07/29/97 Jeff Fry             Add Feasible/Linear Ranges          *
;    *002 08/06/97 Kevin Brunner        Add autoverify (doc only)           *
;    *003 08/14/97 Jeff Fry             Add advanced_delta_id               *
;    *004 09/02/97 Hal Patchen          Add repeat logic                    *
;    *005 09/08/97 Hal Patchen          Add autoverify logic                *
;    *006 09/16/97 Jeff Fry             Add instr_accn_queue support for    *
;    *                                  autoverify results                  *
;    *007 10/02/97 Hal Patchen          Add interpretive data               *
;    *008 09/18/97 Todd Gugler          New variables for event processing  *
;    *009 12/09/97 Hal Patchen          Add subsection level interpretive   *
;    *010 12/19/97 Hal Patchen          Add use request date & time ind     *
;    *011 12/19/97 Jeff Fry             Add fields for Outreach Service use *
;    *012 02/24/98 Hal Patchen          Forward interp data id to clinical  *
;    *                                  events on perform_result updates    *
;    *013 05/18/98 Hal Patchen          Return fail reason flag             *
;    *014 06/04/98 Hal Patchen          Instr_Accn_Queue performance change *
;    *015 07/20/98 Hal Patchen          Improve Instr_Accn_Queue clean-up   *
;    *016 12/07/99 Chris Heil           Write ROP results to instrument que *
;    *017 12/16/98 Hal Patchen          Add autoverification error cd logic *
;    *018 07/07/99 Hal Patchen          Add Lab Management logic            *
;    *019 03/03/00 Hal Patchen          Add validation of status updates    *
;    *020 06/02/00 Gary Runde           Do not set signatue_line_ind on perf*
;    *021 06/22/00 Gary Runde           Write perform_personnel_id of user  *
;    *                                  assigned to instrument              *
;    *022 08/01/00 Gary Runde           Write app_mode_ind on perf_result   *
;    *023 07/03/00 Chris Heil           Save multiple av error cds per assay*
;    *024 10/27/00 Gary Runde           Check for ANY perf results when     *
;    *                                  writing to the instrument_queue     *
;    *025 08/09/01 Mike Gabrick         RLI assay result_status_cd changes  *
;    *026 09/04/01 Gary Runde           Result Recovery logic               *
;    *027 03/20/02 Gary Runde           Result Recovery Logic               *
;    *028 04/29/02 Gary Runde           Add Clinical Validation Interceptor *
;    *029 06/10/02 Michael Caldwell     Add EXECUTE call to                 *
;    *                                  PCS_MAINTAIN_REVIEW_ITEMS           *
;    *030 12/31/02 Sara Halse		        Add logic to disable IQ Subsection  *
;    *                                  lookup                              *
;    *031 02/10/02 Nick Smith           Rename insert_result_comment sub to *
;    *                                  ins_upd_result_comment and update   *
;    *                                  to handle MDI result comments/notes *
;    *032 04/04/03 Ekta Agarwal         UTC Phase II changes                *
;    *033 07/09/03 Nirmal Sanganee      Adding check for corrected-InReview *
;    *034 12/03/03 Scott Haven          Add bb_result_code_set_cd           *
;    *035 04/19/06 Matt Schile          Fixed cancel order issue            *
;    *036 05/20/06 Kevin Power          Update to post Helix MDI results    *
;    *037 07/17/06 Ryan Manuel          Added notify_cd to the reply        *
;    *039 09/12/06 David Fifer			Added result image logic for the    *
;    *                                  scattergram enhancement.            *
;    *040 08/09/07 Scott Haven          Fix MDI Linear issue CR 1-1238131361*
;    *041 11/05/07 Scott Haven          Handle Helix prompt test results.   *
;    *042 11/21/07 Abraham Areguy       Added insert statement for received *
;    *                                  date and time project               *
;    *043 11/02/10 Balaji Murali        Fix for CR 1-3993840231             *
;    *044 12/10/10 Steve Hendrick       Carry forward automatic worklist ID *
;                                       if result type and result value have*
;                                       not changed.                        *
;    *045 02/07/11 Abhroneel Chowdhury  Instrument Queue CR 1-319109258     *
;    *046 06/13/13 Kiran Shimpi         RLI/HL7 CR 1-7000732951             *
;    *047 04/29/14 Hal Patchen          Check fixed width font preference   *
;~DE~************************************************************************
 
 
;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************
 
drop program GLB_UPD_LAB_RESULTS:dba go
create program GLB_UPD_LAB_RESULTS:dba
 
%i CCLSOURCE:GLB_SCRIPT_LOGGING.INC                                  ;025
%i CCLSOURCE:pcs_get_time_zone.inc
%i CCLSOURCE:pcs_preference_manager.inc
set LOG_PROGRAM_NAME = "glb_upd_lab_results"                         ;025
 
     /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
      /*
      record request
      (
         1  use_req_dt_tm_ind            = i2      ;0 = Use system dt  ;010
         1  event_dt_tm                  = dq8
         1  event_personnel_id           = f8
         1  app_mode_ind                 = i2               ;022
         1  auto_verify_ind              = i2                 ;002
         1  orders[x]
            2  complete_ind              = i2 ;Temp fix to clean up OSRC
            2  cs_order_id               = f8      ;Used by process server
            2  order_id                  = f8
*JDF*       2  updt_cnt                  = i4      ;Used by order server
            2  catalog_cd                = f8
*JDF*       2  catalog_type_cd           = f8      ;Used by order server
            2  person_id                 = f8
            2  encntr_id                 = f8      ;Used to update OCF
            2  accession_id              = f8      ;Used by process server
            2  accession                 = c20     ;Used to update OCF
            2  review_required_ind       = i2      ;From order_laboratory table
            2  pending_review_ind        = i2      ;From order_laboratory table
            2  activity_type_mean        = c12     ;Used in OCF process ;008
            2  do_not_chart_ind          = i2      ;Used to update OCF  ;008
            2  ord_dr_id                 = f8      ;Used by Outreach    ;011
            2  pat_location_cd           = f8      ;Used by Outreach    ;011
            2  organization_id           = f8      ;Used by Outreach    ;011
            2  rpt_priority_cd           = f8      ;Used by Outreach    ;011
            2  encounter_type_cd         = f8      ;Used by Outreach    ;011
            2  assays_cnt                = i4
            2  assays[x]
               3  result_id                 = f8
               3  task_assay_cd             = f8
               3  event_cd                  = f8   ;Used to update OCF
               3  units_cd                  = f8
               3  container_id              = f8
*JDF*          3  in_lab_dt_tm              = dq8  :Used by AFC server
               3  drawn_dt_tm               = dq8  ;Used by process server
               3  service_resource_cd       = f8
               3  interface_flag            = i2
                  ; 0=PathNet
                  ; 1=MDI Instrument
                  ; 2=PtoP (PathNet to PathNet) / RLI                                   ;025
                  ; 3=Review Queue
                  ; 4=ROP (Prompt)
                  ; 5=Unknown ROP                                                       ;025
                  ; 6=EKS (Discern Expert)
                  ; 7=MDI ROP                                                           ;025
                  ; 8=Point of Care                                                     ;025
               3  interface_av_ind          = i2                        ;002
               3  perform_result_id         = f8
               3  repeat_ind                = i2  ;1 = repeating a test ;004
               3  repeat_nbr                = i4  ; next repeat nbr     ;004
               3  perform_personnel_id      = f8
               3  perform_dt_tm             = dq8
               3  perform_ind               = i2  ;1 = performed/reperformed
               3  result_status_cd          = f8
               3  result_status_disp        = vc
               3  result_type_cd            = f8
               3  nomenclature_id           = f8
               3  result_value_numeric      = f8
               3  max_digits                = i4
               3  min_decimal_places        = i4
               3  min_digits                = i4
               3  numeric_raw_value         = f8
               3  less_great_flag           = i2
               3  result_value_alpha        = vc
               3  result_value_dt_tm        = dq8
               3  rtf_text                  = vc
               3  ascii_text                = vc
               3  normal_cd                 = f8
               3  critical_cd               = f8
               3  review_cd                 = f8
               3  linear_cd                 = f8  ;001
               3  feasible_cd               = f8  ;001
               3  delta_cd                  = f8
               3  normal_range_flag         = i2  ;1 = Low, 2 = High, 3 = Both
               3  normal_low                = f8
               3  normal_high               = f8
               3  normal_alpha              = vc
               3  critical_range_flag       = i2  ;1 = Low, 2 = High, 3 = Both
               3  critical_low              = f8
               3  critical_high             = f8
               3  notify_cd                 = f8
               3  signature_line_ind        = i2
               3  call_back_ind             = i2
               3  chartable_flag            = i2
               3  security_level_cd         = f8
;004           3  repeat_number             = i4
               3  reference_range_factor_id = f8
               3  advanced_delta_id         = f8                        ;003
               3  dilution_factor           = f8
;023           3  av_error_cd               = f8                        ;017
               3  resource_error_codes      = vc
               3  equation_id               = f8
               3  multiplex_resource_cd     = f8
               3  result_updt_cnt           = i4
               3  perform_result_updt_cnt   = i4
               3  result_key                = f8  ;Pass back in reply
               3  perform_result_key        = f8  ;Pass back in reply
               3  components_cnt            = i4
               3  components[x]
                  4  included_assay_cd      = f8
                  4  result_type_cd         = f8
                  4  used_order_id          = f8                       ;004
                  4  used_perform_result_id = f8
               3  result_comment_cnt        = i4
               3  result_comment[x]
                  4  comment_type_cd        = f8
                  4  comment_text           = vc
                  4  comment_prsnl_id       = f8
                  4  comment_id             = f8                       ;031
               3  auto_verify_code_cnt      = i4                      ;023
               3  auto_verify_codes[x]                                ;023
                  4  auto_verify_cd         = f8                      ;023
               3  bb_result_code_set_cd     = f8                      ;034
               3  qc_override_cd            = f8
               3  result_image[x]
                  4  result_image_name      = c64
                  4  result_image_version   = i4
               3 image_cnt                  = i4
               3 images[*]
                  4 blob_ref_id             = f8
                  4 blob_handle             = vc
                  4 storage_cd              = f8
                  4 format_cd               = f8
                  4 blob_title              = vc
                  4 sequence_nbr            = i4
                  4 publish_flag            = i2
                  4 valid_from_dt_tm        = dq8
                  4 valid_until_dt_tm       = dq8
                  4 delete_ind              = i2
                  4 key_value               = i4
%i cclsource:pcs_maintain_review_items_req.inc							   ;029
      )
      */
 
      /***********************************************************************
      * Reply Record                                                         *
      ***********************************************************************/
if (validate(reply->interface_flag, -1) = -1)
      record reply
      (
/*jdf*/  1  interface_flag               = i2
/*kdb*/  1  event_dt_tm                  = dq8
         1  event_tz                     = i4
         1  orders[*]
            2  complete_ind              = i2
            2  order_id                  = f8
            2  review_hierarchy_id       = f8      ;Used by process server
            2  create_review_ind         = i2      ;for the initiation of
            2  update_review_ind         = i2      ;reviews.
            2  assays_cnt                = i4
            2  pn_recovery_id            = f8      ;used for result recovery        ;026
            2  assays[*]
               3  task_assay_cd             = f8
               3  result_id                 = f8
               3  perform_result_id         = f8
               3  parent_perform_result_id  = f8
               3  interp_data_id            = f8                       ;007
               3  perform_dt_tm             = dq8                      ;010
               3  perform_tz                = i4
               3  perform_personnel_id      = f8                       ;018
               3  updt_id                   = f8
               3  result_updt_cnt           = i4
               3  perform_result_updt_cnt   = i4
               3  result_key                = f8
               3  perform_result_key        = f8
               3  result_status_cd          = f8
               3  result_status_disp        = vc
               3  result_status_mean        = vc
               3  service_resource_cd       = f8
               3  service_resource_disp     = vc
               3  service_resource_desc     = vc
               3  components_cnt            = i4
               3  components[*]
                  4  included_assay_cd      = f8
                  4  result_type_cd         = f8
                  4  used_order_id          = f8                       ;004
                  4  used_perform_result_id = f8
               3  fail_reason_flag          = i2                       ;025
               3 image_cnt                  = i4
               3 images[*]
                  4 blob_ref_id             = f8
                  4 blob_handle             = vc
                  4 storage_cd              = f8
                  4 format_cd               = f8
                  4 blob_title              = vc
                  4 sequence_nbr            = i4
                  4 publish_flag            = i2
                  4 valid_from_dt_tm        = dq8
                  4 valid_until_dt_tm       = dq8
                  4 delete_ind              = i2
                  4 key_value               = i4
               3 worklist_id                = f8
         1  fail_reason_flag             = i2                          ;013
            ; 1 = result update count changed
            ; 2 = invalid attempt to update result status.             ;019
            ;     (e.g. perform to corrected, verified to corrected, etc);019
            ; 3 = invalid result status                                ;025
            ; 4 = posting RLI as second verified                       ;025
         1  pn_recovery_ind                 = i2
            ; 1 = pn_recovery_enabled.
            ; 0 = pn_recovery disabled.
%i cclsource:status_block.inc
      )
endif
 
      /***********************************************************************
      * Equation Processing Record                                           *
      ***********************************************************************/
      record equation
      (
         1  qual[*]
            2  task_assay_cd             = f8
            2  equation_id               = f8
            2  equation_processed_ind    = i2
            2  orders_idx                = i4
            2  assays_idx                = i4
            2  components_cnt            = i4
            2  components[*]
               3  included_assay_cd         = f8
               3  result_type_cd            = f8
               3  used_order_id             = f8                       ;004
               3  used_perform_result_id    = f8
      )
 
      /***********************************************************************
      * Review Item Processing Records                                      *
      ***********************************************************************/
      record review_maintain_rep				       ;029
      (
%i cclsource:status_block.inc
      )
 
      /***********************************************************************
      * Instrument Queue Subsection Except Records                           *
      ***********************************************************************/
      record iq_subsection_except
      (
         1  qual[*]
            2   subsection_cd = f8
      )
 
      /***********************************************************************
      * Orders structure used to determine if any orders are in a cancel     *
      * status                                                               *
      ***********************************************************************/
      record orders
      (
         1  qual[*]
            2   order_id = f8
      )
 
      /***********************************************************************
      * DTA structure used to determine if the sci note ind for each DTA     *
      ***********************************************************************/
      record sci_note_inds
      (
        1 dtas[*]
          2 task_assay_cd = f8
          2 sci_notation_ind = i2
      )
 
      /***********************************************************************
      * Structures used to ensure Helix results are pre-exploded in case     *
      * prop server attempts to write results prior to login result explosion*
      ***********************************************************************/
      free record explode_results_req
      record explode_results_req
      (
%i cclsource:ucm_explode_results_req.inc
      ) with protect

      free record explode_results_rep
      record explode_results_rep
      (
%i cclsource:status_block.inc
      ) with protect
 
      /***********************************************************************
      * Variable Declaration                                                 *
      ***********************************************************************/
         record current
         (
            1  system_dt_tm              = dq8
            1  perform_dt_tm             = dq8                         ;010
            1  perform_tz                = i4
            1  perform_personnel_id      = f8                          ;018
            1  result_type_cd            = f8
            1  nomenclature_id           = f8
            1  numeric_raw_value         = f8
            1  less_great_flag           = i2
            1  result_value_dt_tm        = dq8
            1  ascii_text                = vc
            1  long_text_id              = f8
            1  worklist_id               = f8
         )
         set current->system_dt_tm = cnvtdatetime(curdate, curtime3)
         if (request->use_req_dt_tm_ind = 1)                           ;010
            set reply->event_dt_tm = cnvtdatetime(request->event_dt_tm) ;010
         else                                                          ;010
            set request->event_dt_tm = cnvtdatetime(current->system_dt_tm)
            set reply->event_dt_tm = cnvtdatetime(current->system_dt_tm)
         endif                                                         ;010
;005         set CV_REQUIRED_RECS            = 17
;009         set CV_REQUIRED_RECS            = 19                          ;005
         set CV_REQUIRED_RECS            = 24
         declare cv_cnt                  = i4
         declare RESULT_STATUS_CORR_IN_REVIEW_DISP = vc with protect, noconstant("")
         set LOCATION_TYPE_CODESET         = 222
         set LOC_TYPE_FACILITY_CDF         = "FACILITY"
         set SERVICE_RESOURCE_TYPE_CODESET = 223                       ;009
         set SERV_RES_SUBSECTION_CDF     = "SUBSECTION"                ;009
         set SERV_RES_INSTR_CDF          = "INSTRUMENT"                ;015
         set SERV_RES_BENCH_CDF          = "BENCH"                     ;015
         set RESULT_TYPE_CODESET         = 289
         set RESULT_TYPE_TEXT_CDF        = "1"
         set RESULT_TYPE_ALPHA_CDF       = "2"
         set RESULT_TYPE_NUMERIC_CDF     = "3"
         set RESULT_TYPE_INTERP_CDF      = "4"
         set RESULT_TYPE_DATE_CDF        = "6"
         set RESULT_TYPE_FREETEXT_CDF    = "7"
         set RESULT_TYPE_CALC_CDF        = "8"
         set RESULT_STATUS_CODESET       = 1901
         set RESULT_STATUS_PENDING_CDF   = "PENDING"
         set RESULT_STATUS_IN_LAB_CDF    = "INLAB"
         set RESULT_STATUS_PERFORMED_CDF = "PERFORMED"
         set RESULT_STATUS_OLD_PERF_CDF  = "OLDPERFORMED"
         set RESULT_STATUS_VERIFIED_CDF  = "VERIFIED"
         set RESULT_STATUS_OLD_VERF_CDF  = "OLDVERIFIED"
         set RESULT_STATUS_AUTOVERIFIED_CDF  = "AUTOVERIFIED"          ;005
         set RESULT_STATUS_OLD_AUTOVERF_CDF  = "OLDAUTOVERF"           ;005
         set RESULT_STATUS_CORRECTED_CDF = "CORRECTED"
         set RESULT_STATUS_OLD_CORR_CDF  = "OLDCORRECTED"
         set RESULT_STATUS_IN_REVIEW_CDF = "INREVIEW"
         set RESULT_STATUS_CORR_IN_REVIEW_CDF = "CORRINREV"
         set RESULT_STATUS_OLD_CORR_IN_REVIEW_CDF = "OLDCORRINREV"
         set RESULT_STATUS_OLD_IN_REV_CDF = "OLDINREVIEW"
         set result_status_performed_disp = "            "
         set result_status_verified_disp = "            "
         set result_status_in_review_disp = "            "
         set result_status_corr_in_review_disp = "            "
         declare nbr_of_orders           = i4
         declare nbr_of_assays           = i4
         declare nbr_of_components       = i4
         declare nbr_of_result_comments  = i4
         declare lNbr_of_result_images   = i4 with protect, noconstant(0)
         declare oidx                    = i4
         declare aidx                    = i4
         declare cidx                    = i4
         declare eidx                    = i4
         declare ecidx                   = i4
         declare rcidx                   = i4
         declare lRiidx                  = i4 with protect, noconstant(0)
         declare pref_use_fixed_width_font = vc with protect, noconstant(" ")
         declare pref_idx                = i4 with protect, noconstant(0)
         declare loc_type_facility_cd    = f8 with protect, noconstant(0.0)
         declare loc_facility_cd         = f8 with protect, noconstant(0.0)
         declare serv_res_subsection_cd  = f8                          ;009
         declare result_type_text_cd     = f8
         declare result_type_alpha_cd    = f8
         declare result_type_numeric_cd  = f8
         declare result_type_interp_cd   = f8
         declare result_type_date_cd     = f8
         declare result_type_freetext_cd = f8
         declare result_type_calc_cd     = f8
         declare result_status_pending_cd   = f8
         declare result_status_in_lab_cd    = f8
         declare result_status_performed_cd = f8
         declare result_status_old_perf_cd  = f8
         declare result_status_verified_cd  = f8
         declare result_status_old_verf_cd  = f8
         declare result_status_autoverified_cd  = f8                   ;005
         declare result_status_old_autoverf_cd  = f8                   ;005
         declare result_status_corrected_cd = f8
         declare result_status_old_corr_cd  = f8
         declare result_status_in_review_cd = f8
         declare result_status_corr_in_review_cd = f8
         declare result_status_old_in_rev_cd = f8
         declare result_status_old_corr_in_rev_cd = f8
         declare parent_perf_result_id   = f8
         declare curr_result_status_cd   = f8
         declare curr_parent_perf_result_id = f8
         declare curr_interp_data_id     = f8                          ;012
         declare curr_order_id           = f8
         declare curr_task_assay_cd      = f8
         declare equation_cnt            = i4
         declare equations_processed     = i4
         declare curr_equation_eidx      = i4
         declare curr_equation_assay_cd  = f8
         declare curr_equation_perf_rslt_id = f8
         declare last_action_seq         = i4
         declare last_event_seq          = i4
         declare iSkipAssayInd           = i2                          ;025
         declare pn_recovery_type_cd      = f8  with protect, noconstant(0.0)            ;026
         declare PN_RECOVERY_TYPE_CDF     = c12 with protect, constant("PNRESULT    ")  ;026
         declare PN_RECOVERY_TYPE_CODESET = i4  with protect, constant(28600)           ;026
 
         declare PN_RECOVERY_INFO_DOMAIN = vc with protect, constant("PATHNET")
         declare PN_RECOVERY_INFO_NAME   = vc with protect, constant("GLB_RESULT_RECOVERY")
         declare SIMULATE_INSTRUMENT_DOMAIN = vc with protect, constant("HELIX")
         declare SIMULATE_INSTRUMENT_NAME = vc with protect, constant("SIMULATE_INSTRUMENT")
         declare lSubSection_IQ_Option_Flag	= i4 with protect, noconstant(0)
         declare remove_acc_until_verified_ind = i2 with protect, noconstant(0)
         declare dOrderCanceledCd = f8 with protect, constant(uar_get_code_by("MEANING", 6004, "CANCELED"))
         declare lIndex = i4 with protect, noconstant(0)
         declare lCurListSize = i4 with protect, noconstant(0)
         declare lLoopCnt = i4 with protect, noconstant(0)
         declare lNewListSize = i4 with protect, noconstant(0)
         declare lStart = i4 with protect, noconstant(0)
         declare lBatchSize = i4 with protect, constant(20)
         declare HELIX_MEAN = c12 with constant("HLX"), protect
         declare HELIX_CD = f8 with constant(uar_get_code_by("MEANING", 106, "HLX"))
         declare dInstrument_image_id = f8 with protect, noconstant(0.0)
 
         declare sErrorMessage       = vc with protect, noconstant(" ")
         declare lErrorCode          = i4 with protect, noconstant(0) 
 
         execute accrtl_sci_note
 
         declare ConvertRTF(NULL) = i2
         subroutine ConvertRTF(NULL)
         /***************************************************************************
         *Purpose: Converting the Plain Text to RTF Format for the text result type *
         ***************************************************************************/
           declare ord_idx = i4 with noconstant(0)
           declare ass_idx = i4 with noconstant(0)
 
           declare WR         = vc with constant(" \plain \f0 \fs24 \cb2 ")
           declare RTFEOF     = vc with constant("}")
           declare RHEAD      = vc with
           constant("{\rtf1\ansi\deff0{\fonttbl{\f0\fswiss Microsoft Sans Serif;}{\f1\fswiss Tahoma;}}\deflang2057\deflange2057")
           declare RHEAD_FIXED = vc with
           constant("{\rtf1\ansi\deff0{\fonttbl{\f0\fmodern\fcharset0\fprq1 Courier New;}}\plain\f0\fs24")
 
           call LOG_MESSAGE ("Inside ConvertRTF Subroutine",  LOG_LEVEL_DEBUG)
 
           for (ord_idx = 1 to size(request->orders, 5))
              for (ass_idx = 1 to size(request->orders[ord_idx].assays, 5))
               call LOG_MESSAGE (build("RTF text = ", request->orders[ord_idx].assays[ass_idx].rtf_text),LOG_LEVEL_DEBUG)
               if (request->orders[ord_idx].assays[ass_idx].result_type_cd = result_type_text_cd)
                   call LOG_MESSAGE (build("Order Id : ", request->orders[ord_idx].order_id),LOG_LEVEL_DEBUG)
                   if (substring(1, 5, request->orders[ord_idx].assays[ass_idx].rtf_text) != asis("{\rtf"))
                       /* Get the facility of the perform location */
                       select into "nl:"
                          l.location_cd
                       from
                          service_resource sr,
                          location l
                       plan sr where sr.service_resource_cd = request->orders[ord_idx].assays[ass_idx].service_resource_cd
                       join l  where l.organization_id = sr.organization_id
                                 and l.location_type_cd = loc_type_facility_cd
                                 and l.active_ind = 1
                       detail
                          loc_facility_cd = l.location_cd
                       with nocounter
                          
                       /* Load the used fixed width font preference value */
                       if (LoadPreferences("system", trim(cnvtstring(loc_facility_cd,32,2)), 
                                           "", "", "config", "laboratory") = 1)
                          set pref_idx = FindPreference("use fixed width font for text results")
                          set pref_use_fixed_width_font = GetPreferenceValue(pref_idx)
                       else
                          set pref_use_fixed_width_font = "No"
                       endif
                       call LOG_MESSAGE (build("Preference use fixed width font for text results = ", 
                           pref_use_fixed_width_font),LOG_LEVEL_DEBUG)
                       /* Apply RTF formatting and font to the plain text */
                       if (pref_use_fixed_width_font = "Yes")
                          set request->orders[ord_idx].assays[ass_idx].rtf_text =
                            concat(RHEAD_FIXED, " ", request->orders[ord_idx].assays[ass_idx].rtf_text, RTFEOF)
                       else
                          set request->orders[ord_idx].assays[ass_idx].rtf_text =
			                concat(RHEAD, WR, " ", request->orders[ord_idx].assays[ass_idx].rtf_text, WR, RTFEOF)
                       endif
                       call LOG_MESSAGE (build("RTF text inside if block = ", 
                           request->orders[oidx].assays[aidx].rtf_text),LOG_LEVEL_DEBUG)
                   endif
               endif
             endfor
           endfor
         end  ;ConvertRTF()
 
      /***********************************************************************
      * Load sci note subroutine                                             *
      ***********************************************************************/
         declare load_sci_note( none_sci_note ) = i4
         subroutine load_sci_note( none_sci_note )
 
           declare i = i4 with noconstant(0), protect
           declare j = i4 with noconstant(0), private
           declare k = i4 with noconstant(0), private
 
           for (i = 1 to size(request->orders, 5))
            for (j = 1 to size(request->orders[i].assays, 5))
              set k = locateval(k, 1, size(sci_note_inds->dtas, 5),
                                request->orders[i].assays[j].task_assay_cd, sci_note_inds->dtas[k].task_assay_cd)
              if (k <= 0)
                /* not found */
                set k = size(sci_note_inds->dtas, 5) + 1
                set stat = alterlist(sci_note_inds->dtas, k)
                set sci_note_inds->dtas[k].task_assay_cd = request->orders[i].assays[j].task_assay_cd
              endif
            endfor
           endfor
 
           select into "nl:"
           from
             discrete_task_assay dta
           plan dta
             where expand(i, 1, size(sci_note_inds->dtas, 5), dta.task_assay_cd,
                          sci_note_inds->dtas[i].task_assay_cd)
           detail
             i = locateval(i, 1, size(sci_note_inds->dtas, 5),
                           dta.task_assay_cd, sci_note_inds->dtas[i].task_assay_cd)
             sci_note_inds->dtas[i].sci_notation_ind = dta.sci_notation_ind
           with nocounter
         end ;subroutine load_sci_note
 
      /***********************************************************************
      * Load sci note subroutine                                             *
      ***********************************************************************/
         declare get_sci_note_ind( sci_note_task_assay_cd ) = i2
         subroutine get_sci_note_ind( sci_note_task_assay_cd )
 
           declare i = i4 with noconstant(0), protect
 
           if (size(sci_note_inds->dtas, 5) = 0)
             call load_sci_note(0)
           endif
 
           set i = locateval(i, 1, size(sci_note_inds->dtas, 5),
                            sci_note_task_assay_cd, sci_note_inds->dtas[i].task_assay_cd)
           if (i > 0)
             return (sci_note_inds->dtas[i].sci_notation_ind)
           endif
         end ;subroutine get_sci_note_ind
 
      /***********************************************************************
      * Insert result subroutine                                             *
      ***********************************************************************/
         declare insert_result( none1 ) = i4
         subroutine insert_result( none1 )
 
            /* Insert result record */
            insert into
               result r
            set
               r.result_id = request->orders[oidx]->assays[aidx]->result_id,
/*JDF*/        r.person_id = request->orders[oidx].person_id,
               r.order_id = request->orders[oidx].order_id,
               r.catalog_cd = request->orders[oidx].catalog_cd,
               r.task_assay_cd =
                 request->orders[oidx].assays[aidx].task_assay_cd,
               r.call_back_ind =
                 request->orders[oidx].assays[aidx].call_back_ind,
               r.result_status_cd =
                 request->orders[oidx].assays[aidx].result_status_cd,
               r.chartable_flag =
                 request->orders[oidx].assays[aidx].chartable_flag,
               r.security_level_cd =
                 request->orders[oidx].assays[aidx].security_level_cd,
;004               r.repeat_number =
;004                 request->orders[oidx].assays[aidx].repeat_number,
               r.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               r.updt_id = reqinfo->updt_id,
               r.updt_task = reqinfo->updt_task,
               r.updt_applctx = reqinfo->updt_applctx,
               r.updt_cnt = 0
            plan r
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for result_id =",
                  request->orders[oidx]->assays[aidx]->result_id)
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Update result subroutine                                             *
      ***********************************************************************/
         declare curr_updt_cnt           = i4
         declare curr_r_status_cd        = f8                          ;019
         declare update_result( arg_result_id ) = i4
         subroutine update_result( arg_result_id )
            /************************/
            /* Lock rows for update */
            /************************/
            set curr_updt_cnt = -1
            select into "nl:"
            from result r
            plan r  where r.result_id = arg_result_id
            detail
               curr_updt_cnt = r.updt_cnt
               curr_r_status_cd = r.result_status_cd                   ;019
            with nocounter, forupdate(r)
 
call echo(build("***CUR_UPDT_CNT=",curr_updt_cnt))
call echo(build("***REQUEST_UPDT_CNT=",
    request->orders[oidx].assays[aidx].result_updt_cnt))
 
            /***************************************************/
            /* Check to make sure rows haven't been update yet */
            /***************************************************/
            if (curr_updt_cnt !=
                request->orders[oidx].assays[aidx].result_updt_cnt)
               set reply->status_data.subeventstatus[1].OperationName =
                  "SELECT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Result update count has already been updated",
                        " for result_id =", arg_result_id)
               set reply->fail_reason_flag = 1                         ;013
               return(0)
            endif
 
            /*******************************************************/  ;019
            /* Check to make sure result status isn't being        */  ;019
            /* updated improperly from the current status.         */  ;019
            /* (e.g. performed/in-review to corrected              */  ;019
            /*       (auto)verified      to performed/in-review    */  ;019
            /*       (auto)verified      to (auto)verified         */  ;019
            /*       corrected           to perf/in-rev/(auto)verf */  ;019
            /*******************************************************/  ;019
            if (request->orders[oidx].assays[aidx].interface_flag = 2)     ;025
              set iSkipAssayInd = 0                                        ;025
              if ((curr_r_status_cd in (result_status_verified_cd, 
              							result_status_corrected_cd,
              							result_status_autoverified_cd,
              							result_status_corr_in_review_cd))  ;025 ;46
                  and (request->orders[oidx].assays[aidx].                 ;025
                       result_status_cd in (result_status_verified_cd, 
                       						result_status_performed_cd,
                       						result_status_in_review_cd,
                       						result_status_autoverified_cd )));025
                set iSkipAssayInd = 1                                      ;025
                return(0)                                                  ;025
              endif                                                        ;025
            endif                                                          ;025
            if ((curr_r_status_cd in (result_status_performed_cd,      ;019
                                      result_status_in_review_cd)      ;019
              and request->orders[oidx].assays[aidx]                   ;019
                 .result_status_cd = result_status_corrected_cd        ;019
			    and request->orders[oidx].assays[aidx].interface_flag != 2)  ;025
            or
              (curr_r_status_cd in (result_status_autoverified_cd,     ;019
                                      result_status_verified_cd,
                                      result_status_corrected_cd,
                                      result_status_corr_in_review_cd) ;019
              and request->orders[oidx].assays[aidx]                   ;019
                 .result_status_cd in (result_status_performed_cd,     ;019
                                       result_status_in_review_cd,     ;019
                                       result_status_autoverified_cd,  ;019
                                       result_status_verified_cd)))    ;019
               set reply->status_data.subeventstatus[1]                ;019
                  .OperationName = "SELECT"                            ;019
               set reply->status_data.subeventstatus[1]                ;019
                  .OperationStatus = "F"                               ;019
               set reply->status_data.subeventstatus[1]                ;019
                  .TargetObjectName = "RESULT TABLE"                   ;019
               set reply->status_data.subeventstatus[1]                ;019
                  .TargetObjectValue = build(                          ;019
                  "Invalid attempt to update result status to status", ;019
                  "_cd =", request->orders[oidx].assays[aidx]          ;019
                  .result_status_cd, " for result_id =", arg_result_id);019
               set reply->fail_reason_flag = 2                         ;019
               return(0)                                               ;019
            endif                                                      ;019
            /*****************/
            /* Update record */
            /*****************/
 
            update into
               result r
            set
               r.call_back_ind =
                 request->orders[oidx].assays[aidx].call_back_ind,
               r.result_status_cd =
                 request->orders[oidx].assays[aidx].result_status_cd,
               r.chartable_flag =
                 request->orders[oidx].assays[aidx].chartable_flag,
               r.security_level_cd =
                 request->orders[oidx].assays[aidx].security_level_cd,
;004               r.repeat_number =
;004                 request->orders[oidx].assays[aidx].repeat_number,
               r.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               r.updt_id = reqinfo->updt_id,
               r.updt_task = reqinfo->updt_task,
               r.updt_applctx = reqinfo->updt_applctx,
               r.updt_cnt = r.updt_cnt + 1
            plan r  where r.result_id = arg_result_id
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "UPDATE"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to update record for result_id =",
                        arg_result_id)
            endif
 
            return(curqual)
         end
      /***********************************************************************
      * Read result subroutine.  Determine if a result record already exists *
      ***********************************************************************/
         declare read_result( arg_order_id,
                              arg_task_assay_cd ) = i4
 
         subroutine read_result( arg_order_id,
                                 arg_task_assay_cd )
 
            declare dResultId  = f8 with noconstant(0.0), protect
            declare lResultUpdtCnt = i4 with noconstant(0), protect
 
            select into "nl:"
               r.order_id,
               r.task_assay_cd
 
            from
               result r
 
            plan r  where r.order_id = arg_order_id
                      and r.task_assay_cd = arg_task_assay_cd
            detail
              dResultId  = r.result_id
              lResultUpdtCnt = r.updt_cnt
            with nocounter
 
            if (curqual > 0)
               ;* don't fail is this is Helix and from MDI ...
               if (request->orders[oidx].assays[aidx].interface_flag > 0
               and request->orders[oidx].activity_type_mean = HELIX_MEAN)
                  ;* found a hlx, lets return that fact.
                  set request->orders[oidx]->assays[aidx]->result_id = dResultId
                  set request->orders[oidx]->assays[aidx]->result_updt_cnt = lResultUpdtCnt
                  return(-1)
               else
                  declare lNumberOfExistingResults = i4 with protect, noconstant(0)
                  set lNumberOfExistingResults = curqual
                  
                  select into "nl:"
                  from
                    perform_result pr,
                    result_event re,
                    result r
                  plan r  where r.result_id = dResultId
                            and r.result_status_cd = 0.0
                  join pr where pr.result_id = dResultId
                  join re where re.result_id = pr.result_id
                            and re.perform_result_id = pr.perform_result_id
                            and re.event_type_cd = result_status_old_perf_cd
                            and re.event_reason = "Discarded"
                  with nocounter
                  
                  ;* found a discarded result, this scenario is treated the same as a hlx result.
                  if (curqual > 0)
                    set request->orders[oidx]->assays[aidx]->result_id = dResultId
                    set request->orders[oidx]->assays[aidx]->result_updt_cnt = lResultUpdtCnt
                    return(-1)
                  endif
               
                  ;* standard error otherwise.
                  set reply->status_data.subeventstatus[1].OperationName =
                     "SELECT"
                  set reply->status_data.subeventstatus[1].OperationStatus =
                     "F"
                  set reply->status_data.subeventstatus[1].TargetObjectName =
                     "RESULT TABLE"
                  set reply->status_data.subeventstatus[1].TargetObjectValue =
                     build("Result record already exists for order_id =",
                           arg_order_id, " and task_assay_cd =",
                           arg_task_assay_cd)
                  set reply->fail_reason_flag = 1                         ;013
                  return(lNumberOfExistingResults)
               endif
            endif
 
            return(0)
         end
 
      /***********************************************************************
      * Insert result image subroutine.                                      *
      ***********************************************************************/
         declare insert_result_image(none6) = i4
         subroutine insert_result_image(none6)

           /**************************************/
           /* Read new instrument image sequence.*/
           /**************************************/
            select into "nl:"
               next_seq_nbr = seq(pathnet_seq, nextval)
            from dual
            detail
               dInstrument_image_id = next_seq_nbr
            with nocounter, format
 
            /* Insert result image. */
            insert into
               instrument_image ii
            set
               ii.instrument_image_id = dInstrument_image_id,
               ii.result_id = request->orders[oidx].assays[aidx]->result_id,
               ii.perform_dt_tm = cnvtdatetime(request->orders[oidx].assays[aidx].perform_dt_tm),
               ii.result_image_name = request->orders[oidx].assays[aidx].result_image[lRiidx].result_image_name,
               ii.result_image_vrsn_nbr = request->orders[oidx].assays[aidx].result_image[lRiidx].result_image_version,
               ii.service_resource_cd = request->orders[oidx].assays[aidx].service_resource_cd,
               ii.repeat_nbr = request->orders[oidx].assays[aidx].repeat_nbr,
               ii.active_ind = 1,
               ii.active_status_cd = reqdata->active_status_cd,
               ii.active_status_dt_tm = cnvtdatetime(curdate, curtime3),
               ii.active_status_prsnl_id = reqinfo->updt_id,
               ii.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               ii.updt_id = reqinfo->updt_id,
               ii.updt_task = reqinfo->updt_task,
               ii.updt_applctx = reqinfo->updt_applctx,
               ii.updt_cnt = 0
            plan ii
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "INSTRUMENT IMAGE TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for instrument_image_id = ", dInstrument_image_id)
            endif
 
            return(curqual)
         end
 
/*********021 start new code ************************/
      /********************************************************************************
      * Get person_id of user assigned to instrument to write perform_personnel_id    *
      ********************************************************************************/
         subroutine get_perform_personnel_id( nonePerfID )
 
             ;if the interface flag is greater than zero then this came from the instrument
             if ((request->orders[oidx].assays[aidx].interface_flag > 0) and
                 (request->orders[oidx].assays[aidx].perform_personnel_id = 0.0))
                   ;if from instrument read the INSTRUMENT_ASSIGNMENT table to see
                   ;if anyone is logged into this instrument currently
                   select into "nl:"
                      ia.service_resource_cd,
                      ia.prsnl_id
                   from
                      instrument_assignment ia
                   plan ia where ia.service_resource_cd =
                                      request->orders[oidx].assays[aidx].service_resource_cd
                             and ia.active_ind = 1
                             and cnvtdatetime(curdate,curtime3) between
                                      ia.beg_effective_dt_tm and ia.end_effective_dt_tm
                   detail
                       ;if a person is found, then use it as the perform_personnel_id on the
                       ;perform_result table
                       request->orders[oidx].assays[aidx].perform_personnel_id =
                                      ia.prsnl_id
                   with nocounter
             endif
         end
/*********021 end new code ************************/
 
 
      /***********************************************************************
      * Insert perform_result subroutine                                     *
      ***********************************************************************/
         declare perf_result_seq         = f8
         declare interpretive_data_id    = f8                          ;007
         declare insert_perform_result( arg_result_id,
                                        arg_parent_perf_rslt_id ) = i4
 
         subroutine insert_perform_result( arg_result_id,
                                           arg_parent_perf_rslt_id )
 
            declare nCarryForwardWklstID = i2 with protect, noconstant(0)
            
            /*********************************/
            /* If result contains rtf_text,  */
            /* read new long_text_id before  */
            /* inserting perform result rec. */
            /*********************************/
            if (request->orders[oidx].assays[aidx].result_type_cd
                in (result_type_freetext_cd, result_type_text_cd,
                    result_type_interp_cd)
            and request->orders[oidx].assays[aidx].rtf_text > " ")
               if (read_long_data_seq( 0 ) = 0)
             call echo("INSERT_PERFORM_RESULT: READ_LONG_DATA_SEQ failed.")
                  return(0)
               endif
            else
               set long_text_seq = 0.0
            endif
 
            /*********************************/                        ;007
            /* Derive interpretive data id   */                        ;007
            /*********************************/                        ;007
            set interpretive_data_id = 0.0                             ;007
            set subsect_cd = 0.0                                       ;009
            select into "nl:"                                          ;009
               rg.parent_service_resource_cd                           ;009
            from                                                       ;009
               resource_group rg                                       ;009
            where rg.child_service_resource_cd = request->orders[oidx] ;009
                  .assays[aidx].service_resource_cd                    ;009
              and rg.resource_group_type_cd = serv_res_subsection_cd   ;009
              and rg.root_service_resource_cd = 0.0                    ;009
            detail                                                     ;009
               subsect_cd = rg.parent_service_resource_cd              ;009
            with nocounter                                             ;009
                                                                       ;009
            select into "nl:"                                          ;007
               id.interp_data_id                                       ;007
            from                                                       ;007
               interp_data id                                          ;007
            where id.task_assay_cd =                                   ;007
                  request->orders[oidx].assays[aidx].task_assay_cd     ;007
              and (id.service_resource_cd = 0.0                        ;007
                or id.service_resource_cd = subsect_cd                 ;009
                or id.service_resource_cd = request->orders[oidx]      ;007
                  .assays[aidx].service_resource_cd)                   ;007
              and id.active_ind = 1                                    ;007
              and id.beg_effective_dt_tm <=                            ;007
                  cnvtdatetime(current->system_dt_tm)                  ;007
              and id.end_effective_dt_tm >=                            ;007
                  cnvtdatetime(current->system_dt_tm)                  ;007
            head report                                                ;007
               interpretive_data_id = 0.0                              ;007
               interpretive_level = 0                                  ;009
            detail                                                     ;007
;009               ;* Use interp_data_id off all service resource record   ;007
;009               ;* unless a specific service resource record exists.    ;007
;009               if ((interpretive_data_id = 0.0                         ;007
;009                 and id.service_resource_cd = 0.0)                     ;007
;009               or (id.service_resource_cd > 0.0))                      ;007
;009                  interpretive_data_id = id.interp_data_id             ;007
;009               endif                                                   ;007
               ;* Check for specific service resource match            ;009
               if (interpretive_level < 3                              ;009
               and id.service_resource_cd > 0.0                        ;009
               and id.service_resource_cd != subsect_cd)               ;009
                  interpretive_data_id = id.interp_data_id             ;009
                  interpretive_level = 3                               ;009
               endif                                                   ;009
               ;* Check for subsection level match                     ;009
               if (interpretive_level < 2                              ;009
               and id.service_resource_cd > 0.0                        ;009
               and id.service_resource_cd = subsect_cd)                ;009
                  interpretive_data_id = id.interp_data_id             ;009
                  interpretive_level = 2                               ;009
               endif                                                   ;009
               ;* Check for all service resource level match           ;009
               if (interpretive_level < 1                              ;009
               and id.service_resource_cd = 0.0)                       ;009
                  interpretive_data_id = id.interp_data_id             ;009
                  interpretive_level = 1                               ;009
               endif                                                   ;009
            with nocounter                                             ;007
 
            /************************************/                     ;021
            /* Get assigned user                */                     ;021
            /************************************/                     ;021
            call get_perform_personnel_id(0)                           ;021
 
            /***************************************************/
            /* Determine if this is a Helix MDI Numeric result */
            /***************************************************/
            if (request->orders[oidx].activity_type_mean = HELIX_MEAN
            and request->orders[oidx].assays[aidx].result_type_cd
                   in (result_type_numeric_cd, result_type_calc_cd))
              if (request->orders[oidx].assays[aidx].interface_flag = 0)
                ;Check dm_info to see if we should simulate an instrument interface.
                select into "nl:"
                  dm.info_domain
                from dm_info dm
                plan dm where dm.info_domain = SIMULATE_INSTRUMENT_DOMAIN
                 and dm.info_name = SIMULATE_INSTRUMENT_NAME
                detail
                  request->orders[oidx].assays[aidx].interface_flag = 1
                with nocounter
              endif
              if (request->orders[oidx].assays[aidx].interface_flag > 0)
                set request->orders[oidx].assays[aidx].ascii_text =
                    uar_AccFormatResultStringSciNote(request->orders[oidx].assays[aidx].min_digits,
                                                     request->orders[oidx].assays[aidx].max_digits,
                                                     request->orders[oidx].assays[aidx].min_decimal_places,
                                                     request->orders[oidx].assays[aidx].result_value_numeric,
                                                     request->orders[oidx].assays[aidx].less_great_flag,
                                                     get_sci_note_ind(request->orders[oidx].assays[aidx].task_assay_cd))
                call echo(build("New ascii text = ", request->orders[oidx].assays[aidx].ascii_text))
              endif
            endif
 
            /************************************/
            /* Read new perform_result sequence */
            /************************************/
            select into "nl:"
               next_seq_nbr = seq(pathnet_seq,nextval)
            from dual
            detail
               perf_result_seq = next_seq_nbr
            with nocounter, format
 
            ;if there is an existing result and it is on an automatic worklist, we want to carry forward the worklist ID 
            ;if the result value and result type have not changed.
            set nCarryForwardWklstID = 0
            if ( request->orders[oidx].assays[aidx].perform_result_id > 0.0 
                                                    and current->worklist_id > 0.0 ) ;existing result on a worklist
              if ( request->orders[oidx].assays[aidx].result_type_cd = current->result_type_cd ) ;result type not changed
                if ( request->orders[oidx].assays[aidx].result_type_cd = result_type_text_cd )   ;result type text
                  select into "nl:"
                    from long_text lt
                    plan lt where lt.long_text_id = current->long_text_id
                    detail
                      if (trim(request->orders[oidx].assays[aidx].rtf_text) = trim(lt.long_text))
                        nCarryForwardWklstID = 1
                      endif
                  with nocounter
                else  ;result type not text
                      ;result type alpha or interp and result value has not changed
                  if ( (request->orders[oidx].assays[aidx].result_type_cd in ( result_type_alpha_cd, result_type_interp_cd )
                        and request->orders[oidx].assays[aidx].nomenclature_id = current->nomenclature_id )
                      ;result type numeric or calc and result value has not changed
                      or (request->orders[oidx].assays[aidx].result_type_cd in ( result_type_numeric_cd, result_type_calc_cd  )
                          and (request->orders[oidx].assays[aidx].numeric_raw_value = current->numeric_raw_value 
                               and request->orders[oidx].assays[aidx].less_great_flag = current->less_great_flag) )
                      ;result type date and result value has not changed
                      or (request->orders[oidx].assays[aidx].result_type_cd = result_type_date_cd 
                          and cnvtdatetime(request->orders[oidx].assays[aidx].result_value_dt_tm) 
                                                  = cnvtdatetime(current->result_value_dt_tm) )
                      ;result type freetext and result value has not changed    
                      or (request->orders[oidx].assays[aidx].result_type_cd = result_type_freetext_cd 
                          and request->orders[oidx].assays[aidx].ascii_text = current->ascii_text))
                          
                    set nCarryForwardWklstID = 1
                    
                  endif
                endif
              endif
            endif
            /************************************/
            /* Insert new perform_result record */
            /************************************/
            insert into
               perform_result pr
            set
               pr.perform_result_id = perf_result_seq,
               pr.result_id = arg_result_id,
               pr.parent_perform_result_id = arg_parent_perf_rslt_id,
               pr.container_id =
                 request->orders[oidx].assays[aidx].container_id,
               pr.app_mode_ind = request->app_mode_ind,                 ;022
               pr.service_resource_cd =
                 request->orders[oidx].assays[aidx].service_resource_cd,
               pr.interface_flag =
                 request->orders[oidx].assays[aidx].interface_flag,
               pr.repeat_nbr =                                         ;004
                 request->orders[oidx].assays[aidx].repeat_nbr,        ;004
               pr.perform_personnel_id =
                 request->orders[oidx].assays[aidx].perform_personnel_id,
;hdp - Use system date/time instead of pc date/time until date issue is resolved
;hdp           pr.perform_dt_tm =
;hdp             cnvtdatetime(request->orders[oidx].assays[aidx].perform_dt_tm),
;010               pr.perform_dt_tm = cnvtdatetime(current->system_dt_tm),
               pr.perform_dt_tm = cnvtdatetime(                        ;010
                 request->orders[oidx].assays[aidx].perform_dt_tm),    ;010
 
               pr.perform_tz = reply->orders[oidx].assays[aidx].perform_tz,
               pr.result_status_cd =
                 request->orders[oidx].assays[aidx].result_status_cd,
               pr.result_type_cd =
                 request->orders[oidx].assays[aidx].result_type_cd,
               pr.nomenclature_id =
                 request->orders[oidx].assays[aidx].nomenclature_id,
               pr.result_value_alpha =
                 if (request->orders[oidx].assays[aidx].result_type_cd
                   in (result_type_text_cd, result_type_alpha_cd,
                       result_type_interp_cd))
                    request->orders[oidx].assays[aidx].result_value_alpha
                 else
                    NULL
                 endif,
               pr.result_value_numeric =
                 if (request->orders[oidx].assays[aidx].result_type_cd
                   in (result_type_numeric_cd, result_type_calc_cd))
                    request->orders[oidx].assays[aidx].result_value_numeric
                 else
                    NULL
                 endif,
               pr.numeric_raw_value =
                 if (request->orders[oidx].assays[aidx].result_type_cd
                   in (result_type_numeric_cd, result_type_calc_cd))
                    request->orders[oidx].assays[aidx].numeric_raw_value
                 else
                    NULL
                 endif,
               pr.less_great_flag =
                 if (request->orders[oidx].assays[aidx].less_great_flag
                   in (0,1,2))
                    request->orders[oidx].assays[aidx].less_great_flag
                 else
                    0
                 endif,
               pr.result_value_dt_tm =
                 if (request->orders[oidx].assays[aidx].result_type_cd = result_type_date_cd)
                    cnvtdatetime(request->orders[oidx].assays[aidx].result_value_dt_tm)
                 else
                    NULL
                 endif,
               pr.long_text_id = long_text_seq,
               pr.ascii_text =
                 if (request->orders[oidx].assays[aidx].result_type_cd
                   in (result_type_freetext_cd, result_type_text_cd,
                       result_type_interp_cd, result_type_numeric_cd,
                       result_type_calc_cd))
                    request->orders[oidx].assays[aidx].ascii_text
                 else
                    NULL
                 endif,
               pr.reference_range_factor_id =
                 request->orders[oidx].assays[aidx].reference_range_factor_id,
               pr.advanced_delta_id =                                   ;003
                 request->orders[oidx].assays[aidx].advanced_delta_id,  ;003
               pr.normal_cd =
                 request->orders[oidx].assays[aidx].normal_cd,
               pr.critical_cd =
                 request->orders[oidx].assays[aidx].critical_cd,
               pr.review_cd =
                 request->orders[oidx].assays[aidx].review_cd,
               pr.linear_cd =                                    ;001
                 request->orders[oidx].assays[aidx].linear_cd,   ;001
               pr.feasible_cd =                                  ;001
                 request->orders[oidx].assays[aidx].feasible_cd, ;001
               pr.delta_cd =
                 request->orders[oidx].assays[aidx].delta_cd,
               pr.notify_cd =
                 request->orders[oidx].assays[aidx].notify_cd,
               pr.normal_low =
                 if (request->orders[oidx].assays[aidx]
                   .normal_range_flag in (1,3))
                    request->orders[oidx].assays[aidx].normal_low
                 else
                    NULL
                 endif,
               pr.normal_high =
                 if (request->orders[oidx].assays[aidx]
                   .normal_range_flag in (2,3))
                    request->orders[oidx].assays[aidx].normal_high
                 else
                    NULL
                 endif,
               pr.normal_alpha =
                 if (trim(request->orders[oidx].assays[aidx].normal_alpha) >" ")
                    request->orders[oidx].assays[aidx].normal_alpha
                 else
                    NULL
                 endif,
               pr.units_cd =
                 request->orders[oidx].assays[aidx].units_cd,
               pr.dilution_factor =
                 request->orders[oidx].assays[aidx].dilution_factor,
;023               pr.av_error_cd =                                        ;017
;023                 if (validate(request->orders[oidx].assays[aidx]       ;017
;023                   .av_error_cd, -1) != -1)                            ;017
;023                    request->orders[oidx].assays[aidx].av_error_cd     ;017
;023                 else                                                  ;017
;023                    0.0                                                ;017
;023                 endif,                                                ;017
               pr.resource_error_codes =
                 request->orders[oidx].assays[aidx].resource_error_codes,
               pr.equation_id =
                 request->orders[oidx].assays[aidx].equation_id,
               pr.multiplex_resource_cd =
                 request->orders[oidx].assays[aidx].multiplex_resource_cd,
               pr.result_code_set_cd =                                     ;034
                 request->orders[oidx].assays[aidx].bb_result_code_set_cd, ;034
               pr.qc_override_cd =
                 request->orders[oidx].assays[aidx].qc_override_cd,
               pr.interp_data_id = interpretive_data_id,               ;007
               pr.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               pr.updt_id = reqinfo->updt_id,
               pr.updt_task = reqinfo->updt_task,
               pr.updt_applctx = reqinfo->updt_applctx,
               pr.updt_cnt = 0,
               pr.worklist_id = 
                  if ( nCarryForwardWklstID = 1 )
                    current->worklist_id 
                  else
                    0.0
                  endif
            plan pr
            with nocounter
            
            if ( nCarryForwardWklstID = 1 )
              set reply->orders[oidx].assays[aidx].worklist_id = current->worklist_id
            else
              set reply->orders[oidx].assays[aidx].worklist_id = 0.0
            endif
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "PERFORM_RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for perform_result_id =",
                        perf_result_seq, " and result_id =", arg_result_id)
               return(0)
            endif
 
            /*********************************/
            /* If result contains rtf_text,  */
            /* insert new long_text record.  */
            /*********************************/
            if (long_text_seq > 0.0)
               insert into
                  long_text lt
               set
                  lt.long_text_id = long_text_seq,
                  lt.parent_entity_name = "PERFORM_RESULT",
                  lt.parent_entity_id = perf_result_seq,
                  lt.long_text = request->orders[oidx].assays[aidx].rtf_text,
                  lt.active_ind = 1,
                  lt.active_status_cd = reqdata->active_status_cd,
                  lt.active_status_dt_tm = cnvtdatetime(curdate, curtime3),
                  lt.active_status_prsnl_id = reqinfo->updt_id,
                  lt.updt_dt_tm = cnvtdatetime(curdate, curtime3),
                  lt.updt_id = reqinfo->updt_id,
                  lt.updt_task = reqinfo->updt_task,
                  lt.updt_applctx = reqinfo->updt_applctx,
                  lt.updt_cnt = 0
               plan lt
               with nocounter
               if (curqual = 0)
                  set reply->status_data.subeventstatus[1].OperationName =
                     "INSERT"
                  set reply->status_data.subeventstatus[1].OperationStatus =
                     "F"
                  set reply->status_data.subeventstatus[1].TargetObjectName =
                     "LONG_TEXT TABLE"
                  set reply->status_data.subeventstatus[1].TargetObjectValue =
                     build("Unable to insert record for long_text_id =",
                           long_text_seq)
                  return(0)
               endif
            endif
 
            return(1)
         end
 
      /***********************************************************************
      * Update perform_result subroutine.  Update the result_status_cd on    *
      * reperforms.                                                          *
      ***********************************************************************/
         declare update_perform_result( arg_result_id,
                                        arg_perf_result_id,
                                        arg_result_status_cd ) = i4
 
         subroutine update_perform_result( arg_result_id,
                                           arg_perf_result_id,
                                           arg_result_status_cd )
            update into
               perform_result pr
            set
               pr.result_status_cd = arg_result_status_cd,
               pr.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               pr.updt_id = reqinfo->updt_id,
               pr.updt_task = reqinfo->updt_task,
               pr.updt_applctx = reqinfo->updt_applctx,
               pr.qc_override_cd = if (arg_result_status_cd in (result_status_verified_cd,
                                                                result_status_autoverified_cd,
                                                                result_status_in_review_cd) and
                                                                request->review_queue_ind = 0)
                                     request->orders[oidx].assays[aidx].qc_override_cd
                                   else
                                     pr.qc_override_cd
                                   endif,
               pr.updt_cnt = pr.updt_cnt + 1
            plan pr where pr.perform_result_id = arg_perf_result_id
                      and pr.result_id = arg_result_id
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "UPDATE"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "PERFORM_RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to update record for perform_result_id =",
                        arg_perf_result_id, " and result_id =", arg_result_id)
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Update repeated perform_result subroutine.  Update the               *
      * result_status_cd to old_perform.                                     *
      ***********************************************************************/
         declare update_repeated_perform_result( arg_result_id ) = i4  ;004
                                                                       ;004
         subroutine update_repeated_perform_result( arg_result_id )    ;004
            update into                                                ;004
               perform_result pr                                       ;004
            set                                                        ;004
               pr.result_status_cd = result_status_old_perf_cd,        ;004
               pr.updt_dt_tm = cnvtdatetime(curdate, curtime3),        ;004
               pr.updt_id = reqinfo->updt_id,                          ;004
               pr.updt_task = reqinfo->updt_task,                      ;004
               pr.updt_applctx = reqinfo->updt_applctx,                ;004
               pr.updt_cnt = pr.updt_cnt + 1                           ;004
            plan pr where pr.result_id = arg_result_id                 ;004
                      and pr.result_status_cd =                        ;004
                                         result_status_performed_cd    ;004
            with nocounter                                             ;004
                                                                       ;004
            return(1)                                                  ;004
         end                                                           ;004
 
 
      /***********************************************************************
      * Read perform_result subroutine.  Gets current result status.         *
      ***********************************************************************/
         declare read_perform_result( arg_result_id,
                                      arg_perf_result_id ) = i4
 
         subroutine read_perform_result( arg_result_id,
                                         arg_perf_result_id )
            set curr_result_status_cd = 0.0
            set curr_parent_perf_result_id = 0.0
            set current->perform_dt_tm = 0                             ;010
            set current->perform_tz = 0
            set current->perform_personnel_id = 0.0                    ;018
            set current->result_type_cd = 0.0
            set current->nomenclature_id = 0.0
            set current->numeric_raw_value = 0.0
            set current->less_great_flag = 0
            set current->result_value_dt_tm = 0
            set current->ascii_text = ""
            set current->long_text_id = 0.0
            set current->worklist_id = 0.0
            set curr_interp_data_id = 0.0                              ;012
 
            select into "nl:"
               pr.result_status_cd,
               pr.parent_perform_result_id
 
            from
               perform_result pr
 
            plan pr where pr.perform_result_id = arg_perf_result_id
                      and pr.result_id = arg_result_id
            detail
               curr_result_status_cd = pr.result_status_cd
               curr_parent_perf_result_id = pr.parent_perform_result_id
               current->perform_dt_tm = cnvtdatetime(pr.perform_dt_tm) ;010
               current->perform_tz = pr.perform_tz
               current->perform_personnel_id = pr.perform_personnel_id ;018
               current->result_type_cd = pr.result_type_cd 
               current->nomenclature_id = pr.nomenclature_id 
               current->numeric_raw_value = pr.numeric_raw_value 
               current->less_great_flag = pr.less_great_flag 
               current->result_value_dt_tm = pr.result_value_dt_tm 
               current->ascii_text = pr.ascii_text 
               current->long_text_id = pr.long_text_id 
               current->worklist_id = pr.worklist_id 
               curr_interp_data_id = pr.interp_data_id                 ;012
 
            with nocounter
            
            set reply->orders[oidx].assays[aidx].worklist_id = current->worklist_id
            
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "SELECT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "PERFORM_RESULT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to read record for perform_result_id =",
                        arg_perf_result_id, " and result_id =", arg_result_id)
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Insert result_event subroutine                                       *
      ***********************************************************************/
         declare event_type_cd           = f8
         declare event_prsnl_id          = f8
         declare insert_result_event( arg_result_id,
                                      arg_perf_result_id,
                                      arg_event_type_cd,
                                      arg_event_prsnl_id,
                                      arg_event_reason ) = i4
 
         subroutine insert_result_event( arg_result_id,
                                         arg_perf_result_id,
                                         arg_event_type_cd,
                                         arg_event_prsnl_id,
                                         arg_event_reason )
 
            /****************************/
            /* Find last event sequence */
            /****************************/
            set last_event_seq = 0
            select into "nl:"
               re.result_id,
               re.event_sequence
            from result_event re
            plan re where re.result_id = arg_result_id
                      and re.perform_result_id = arg_perf_result_id
            order re.event_sequence desc
            head re.result_id
               last_event_seq = re.event_sequence
            with nocounter
 
            ;if performed event, do not set signature_line_ind           ;020
            if (arg_event_reason = result_status_performed_disp)         ;020
                 set sign_line_ind = 0                                   ;020
            else                                                         ;020
                 ;else set the signatue_line_ind to what was passed in from the script   ;020
                 set sign_line_ind =                                     ;020
                          request->orders[oidx].assays[aidx].signature_line_ind        ;020
            endif                                                        ;020
 
            /***************************/
            /* Insert new result_event */
            /***************************/
            insert into
               result_event re
            set
               re.result_id = arg_result_id,
               re.perform_result_id = arg_perf_result_id,
               re.event_sequence = last_event_seq + 1,
;hdp - Use system date/time instead of pc date/time until date issue is resolved
;hdp               re.event_dt_tm = cnvtdatetime(request->event_dt_tm),
;010               re.event_dt_tm = cnvtdatetime(current->system_dt_tm),
               re.event_dt_tm = cnvtdatetime(request->event_dt_tm),    ;010
               re.event_personnel_id = arg_event_prsnl_id,
               re.event_reason = arg_event_reason,
;do not use the signature_line_ind passed in if this is a performed event         ;020
               re.signature_line_ind = sign_line_ind,                      ;020
;020                 request->orders[oidx].assays[aidx].signature_line_ind,
               re.called_back_ind =
                 request->orders[oidx].assays[aidx].call_back_ind,
               re.event_type_cd = arg_event_type_cd,
               re.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               re.updt_id = reqinfo->updt_id,
               re.updt_task = reqinfo->updt_task,
               re.updt_applctx = reqinfo->updt_applctx,
               re.updt_cnt = 0
            plan re
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "RESULT_EVENT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for perform_result_id =",
                        arg_perf_result_id, " and result_id =", arg_result_id,
                        " and event_sequence =", last_event_seq + 1)
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Insert included_components subroutine                                *
      ***********************************************************************/
         declare insert_included_components( arg_result_id,
                                             arg_perf_rslt_id,
                                             arg_used_perf_rslt_id ) = i4
 
         subroutine insert_included_components( arg_result_id,
                                                arg_perf_rslt_id,
                                                arg_used_perf_rslt_id )
            insert into
               included_components ic
            set
               ic.result_id = arg_result_id,
               ic.perform_result_id = arg_perf_rslt_id,
               ic.used_perform_result_id = arg_used_perf_rslt_id,
               ic.activity_flag = 0,
               ic.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               ic.updt_id = reqinfo->updt_id,
               ic.updt_task = reqinfo->updt_task,
               ic.updt_applctx = reqinfo->updt_applctx,
               ic.updt_cnt = 0
            plan ic
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "INCLUDED_COMPONENTS TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for perform_result_id =",
                        arg_perf_rslt_id, " and result_id =", arg_result_id)
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Insert auto_verify_code subroutine                                   *
      ***********************************************************************/
         declare insert_auto_verify_cd( arg_perf_result_id ) = i4             ;023
 
         subroutine insert_auto_verify_cd( arg_perf_result_id )               ;023
            declare nCnt = i2 with protect, noconstant(0)
 
            insert into auto_verify_code avc,                                 ;023
                        (dummyt d1 with seq = value(request->orders[oidx]->   ;023
                                                    assays[aidx]->auto_verify_code_cnt)) set;023
              avc.parent_entity_id = arg_perf_result_id,                         ;023
              avc.parent_entity_name = "PERFORM_RESULT",                         ;023
              avc.auto_verify_cd = request->orders[oidx]->assays[aidx]->           ;023
                                            auto_verify_codes[d1.seq]->auto_verify_cd, ;023
              avc.updt_dt_tm = cnvtdatetime(curdate, curtime3),                        ;023
              avc.updt_id = reqinfo->updt_id,                                         ;023
              avc.updt_task = reqinfo->updt_task,                                     ;023
              avc.updt_applctx = reqinfo->updt_applctx,                               ;023
              avc.updt_cnt = 0                                                        ;023
            plan d1                                                                   ;023
            where (locateval(nCnt, 1, request->orders[oidx]->assays[aidx]->auto_verify_code_cnt,
                   request->orders[oidx]->assays[aidx]->auto_verify_codes[d1.seq]->auto_verify_cd,
                   request->orders[oidx]->assays[aidx]->auto_verify_codes[nCnt]->auto_verify_cd) = d1.seq)
            join avc                                                                  ;023
            with nocounter                                                            ;023
 
            if (curqual = 0)                                                          ;023
               set reply->status_data.subeventstatus[1].OperationName =      ;023
                  "INSERT"                                                              ;023
               set reply->status_data.subeventstatus[1].OperationStatus =                ;023
                  "F"                                                                   ;023
               set reply->status_data.subeventstatus[1].TargetObjectName =                ;023
                  "AUTO_VERIFY_CODE TABLE"                                                ;023
               set reply->status_data.subeventstatus[1].TargetObjectValue =                ;023
                  build("Unable to insert auto_verify_code record for =",                          ;023
                        perf_result_seq)                                                           ;023
               return(0)                                                                           ;023
            endif                                                                                  ;023
 
            return(curqual)                                                                        ;023
         end                                                                                       ;023
 
       /***********************************************************************
      * Insert result image subroutine                                        *
      ***********************************************************************/
         declare insert_images( none ) = i4
 
         subroutine insert_images( none )
            declare nCnt = i2 with protect, noconstant(0)
            declare i    = i4 with protect, noconstant(0)
            
            ; lock rows for update or delete
            select into "nl:"
            
            from blob_reference br,
                 (dummyt d with seq = value(request->orders[oidx]->assays[aidx]->image_cnt))
            
            plan d where request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id > 0.0
            join br where br.blob_ref_id = request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id
         
            with forupdate(br)
            
            set lErrorCode = error(sErrorMessage, 0)
            if (lErrorCode > 0)
                set reply->status_data.subeventstatus[1].OperationName = "lock failed"
                set reply->status_data.subeventstatus[1].OperationStatus = "F"
                set reply->status_data.subeventstatus[1].TargetObjectName = "blob_reference"
                set reply->status_data.subeventstatus[1].TargetObjectValue = "locking blob_reference failed"
                return(0)
            endif 
           
            ; delete records where blob_ref_id > 0.0 and delete_ind = 1 and in a status
            delete from blob_reference br,
                        (dummyt d with seq = value(request->orders[oidx]->assays[aidx]->image_cnt))
            
            set br.seq = 1
            
            plan d where request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id > 0.0
                     and (request->orders[oidx]->assays[aidx]->images[d.seq].delete_ind = 1 and
                         request->orders[oidx]->assays[aidx]->result_status_cd in(result_status_verified_cd, 
                         result_status_autoverified_cd, result_status_in_review_cd, result_status_performed_cd))
            
            join br where br.blob_ref_id = request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id
                      and br.parent_entity_id = request->orders[oidx]->assays[aidx]->result_id
           
            with nocounter
           
            set lErrorCode = error(sErrorMessage, 0)
            if (lErrorCode > 0)
                set reply->status_data.subeventstatus[1].OperationName = "delete failed"
                set reply->status_data.subeventstatus[1].OperationStatus = "F"
                set reply->status_data.subeventstatus[1].TargetObjectName = "blob_reference"
                set reply->status_data.subeventstatus[1].TargetObjectValue = "deleting from blob_reference failed"
                return(0)
            endif 
           
            ; update records where blob_ref_id > 0.0
            update into blob_reference br,
                        (dummyt d with seq = value(request->orders[oidx]->assays[aidx]->image_cnt))
            
              set br.blob_handle          = request->orders[oidx]->assays[aidx]->images[d.seq].blob_handle,
                  br.storage_cd           = request->orders[oidx]->assays[aidx]->images[d.seq].storage_cd,
                  br.format_cd            = request->orders[oidx]->assays[aidx]->images[d.seq].format_cd,
                  br.blob_title           = request->orders[oidx]->assays[aidx]->images[d.seq].blob_title,
                  br.sequence_nbr         = request->orders[oidx]->assays[aidx]->images[d.seq].sequence_nbr,
                  br.publish_flag         = request->orders[oidx]->assays[aidx]->images[d.seq].publish_flag,
                  br.valid_until_dt_tm    = if (request->orders[oidx]->assays[aidx]->images[d.seq].delete_ind = 0)
                                              cnvtdatetime("31-DEC-2100")
                                            else
                                              cnvtlookbehind("1,S",cnvtdatetime(curdate, curtime3))
                                            endif,
                  br.parent_entity_name   = "RESULT",
                  br.parent_entity_id     = request->orders[oidx]->assays[aidx].result_id,
                  br.updt_dt_tm           = cnvtdatetime(curdate, curtime3),
                  br.updt_id              = reqinfo->updt_id,
                  br.updt_task            = reqinfo->updt_task,
                  br.updt_applctx         = reqinfo->updt_applctx,
                  br.updt_cnt             = br.updt_cnt + 1  
            
            plan d where request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id > 0.0
                     and request->orders[oidx]->assays[aidx]->images[d.seq].delete_ind = 0
                      or (request->orders[oidx]->assays[aidx]->images[d.seq].delete_ind = 1 and
                          not (request->orders[oidx]->assays[aidx]->result_status_cd in(result_status_verified_cd, 
                          result_status_autoverified_cd, result_status_in_review_cd, result_status_performed_cd)))
            
            join br where br.blob_ref_id = request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id
                       
            with nocounter
 
            set lErrorCode = error(sErrorMessage, 0)
            if (lErrorCode > 0)
                set reply->status_data.subeventstatus[1].OperationName = "update failed"
                set reply->status_data.subeventstatus[1].OperationStatus = "F"
                set reply->status_data.subeventstatus[1].TargetObjectName = "blob_reference"
                set reply->status_data.subeventstatus[1].TargetObjectValue = "update of blob_reference failed"
                return(0)
            endif
            
            ; determine the number of new ids to be generated
            for (i = 1 to request->orders[oidx]->assays[aidx]->image_cnt)
               if (request->orders[oidx]->assays[aidx]->images[i].blob_ref_id = 0.0)
                  set nCnt = nCnt + 1
               endif
            endfor
            
            if (nCnt > 0)
            
              ; retrieve new ids for records to be inserted
              record m_dm2_seq_stat
              (
      		      1 n_status    = i4
      		      1 s_error_msg = vc
              ) with protect
  
              record new_ids
              (
                1 qual[*]
                  2 id   = f8
              )
            
              record ids
              (
                1 qual[*]
                  2 id   = f8
              )          
              
              set stat = alterlist(ids->qual, request->orders[oidx]->assays[aidx]->image_cnt)
              
              ; get ids
              execute dm2_dar_get_bulk_seq "new_ids->qual", nCnt, "id", 1, "reference_seq"
              
              ; populate request with new ids, also create a second temporary list to plan on for the insert
              set nCnt = 0
              for (i = 1 to request->orders[oidx]->assays[aidx]->image_cnt)
                 if (request->orders[oidx]->assays[aidx]->images[i].blob_ref_id = 0.0)
                    set nCnt = nCnt + 1
                    set ids->qual[i].id = new_ids->qual[nCnt].id
                    set request->orders[oidx]->assays[aidx]->images[i].blob_ref_id = ids->qual[i].id 
                    set request->orders[oidx]->assays[aidx]->images[i].valid_from_dt_tm = cnvtdatetime(curdate, curtime3)
                    set request->orders[oidx]->assays[aidx]->images[i].valid_until_dt_tm = cnvtdatetime("31-DEC-2100")
                 endif
              endfor
              
              call echorecord(new_ids)
              call echorecord(ids)
              
              ; insert
              insert into blob_reference br,
                          (dummyt d with seq = value(size(ids->qual, 5)))
              
                set br.blob_ref_id          = request->orders[oidx]->assays[aidx]->images[d.seq].blob_ref_id,
                    br.blob_handle          = request->orders[oidx]->assays[aidx]->images[d.seq].blob_handle,
                    br.storage_cd           = request->orders[oidx]->assays[aidx]->images[d.seq].storage_cd,
                    br.format_cd            = request->orders[oidx]->assays[aidx]->images[d.seq].format_cd,
                    br.blob_title           = request->orders[oidx]->assays[aidx]->images[d.seq].blob_title,
                    br.sequence_nbr         = request->orders[oidx]->assays[aidx]->images[d.seq].sequence_nbr,
                    br.publish_flag         = request->orders[oidx]->assays[aidx]->images[d.seq].publish_flag,
                    br.parent_entity_name   = "RESULT",
                    br.parent_entity_id     = request->orders[oidx]->assays[aidx].result_id,
                    br.valid_from_dt_tm     = cnvtdatetime(request->orders[oidx]->assays[aidx]->images[d.seq].valid_from_dt_tm),
                    br.valid_until_dt_tm    = cnvtdatetime(request->orders[oidx]->assays[aidx]->images[d.seq].valid_until_dt_tm),
                    br.updt_dt_tm           = cnvtdatetime(curdate, curtime3),
                    br.updt_id              = reqinfo->updt_id,
                    br.updt_task            = reqinfo->updt_task,
                    br.updt_applctx         = reqinfo->updt_applctx,
                    br.updt_cnt             = 0 
              
              plan d where ids->qual[d.seq].id > 0.0
              join br
              
              with nocounter
              
              set lErrorCode = error(sErrorMessage, 0)
              if (lErrorCode > 0)
                  set reply->status_data.subeventstatus[1].OperationName = "insert failed"
                  set reply->status_data.subeventstatus[1].OperationStatus = "F"
                  set reply->status_data.subeventstatus[1].TargetObjectName = "blob_reference"
                  set reply->status_data.subeventstatus[1].TargetObjectValue = "insert into blob_reference failed"
                  return(0)
              endif
 
              free set m_dm2_seq_stat
              free set new_ids
              free set ids
              
            endif
            
            ; update reply structure
            set reply->orders[oidx]->assays[aidx]->image_cnt = request->orders[oidx]->assays[aidx]->image_cnt
            set stat = alterlist(reply->orders[oidx]->assays[aidx]->images, reply->orders[oidx]->assays[aidx]->image_cnt)
            for (i = 1 to reply->orders[oidx]->assays[aidx]->image_cnt)
                set reply->orders[oidx]->assays[aidx]->images[i].blob_ref_id = 
                             request->orders[oidx]->assays[aidx]->images[i].blob_ref_id
                set reply->orders[oidx]->assays[aidx]->images[i].blob_handle = 
                             request->orders[oidx]->assays[aidx]->images[i].blob_handle
                set reply->orders[oidx]->assays[aidx]->images[i].storage_cd = 
                             request->orders[oidx]->assays[aidx]->images[i].storage_cd
                set reply->orders[oidx]->assays[aidx]->images[i].format_cd = 
                             request->orders[oidx]->assays[aidx]->images[i].format_cd
                set reply->orders[oidx]->assays[aidx]->images[i].blob_title = 
                             request->orders[oidx]->assays[aidx]->images[i].blob_title
                set reply->orders[oidx]->assays[aidx]->images[i].sequence_nbr = 
                             request->orders[oidx]->assays[aidx]->images[i].sequence_nbr
                set reply->orders[oidx]->assays[aidx]->images[i].publish_flag = 
                             request->orders[oidx]->assays[aidx]->images[i].publish_flag
                set reply->orders[oidx]->assays[aidx]->images[i].valid_from_dt_tm = 
                             request->orders[oidx]->assays[aidx]->images[i].valid_from_dt_tm
                set reply->orders[oidx]->assays[aidx]->images[i].valid_until_dt_tm = 
                             request->orders[oidx]->assays[aidx]->images[i].valid_until_dt_tm
                set reply->orders[oidx]->assays[aidx]->images[i].delete_ind = 
                             request->orders[oidx]->assays[aidx]->images[i].delete_ind
                set reply->orders[oidx]->assays[aidx]->images[i].key_value = 
                             request->orders[oidx]->assays[aidx]->images[i].key_value
            endfor
 
            return(1)
    
         end     
 
      /***********************************************************************
      * Insert result_comment subroutine                                     *
      ***********************************************************************/
         declare ins_upd_result_comment( arg_result_id ) = i4        ;031
         subroutine ins_upd_result_comment( arg_result_id )	         ;031
 
            /*****************************************/
            /* Check for existing comment in request */
            /*****************************************/              ;031
            if (request->orders[oidx].assays[aidx]
                 .result_comment[rcidx].comment_id > 0.0)
 
              /*********************************/
              /* Get long_text_id from request */
              /*********************************/                    ;031
              set long_text_seq = request->orders[oidx].assays[aidx]
                .result_comment[rcidx].comment_id
 
              /***********************/
              /* Lock row for update */
              /***********************/
              select into "nl:"
              from long_text lt
              plan lt where lt.long_text_id = long_text_seq
              with nocounter, forupdate(lt)
 
              if (curqual = 0)
                set reply->status_data.subeventstatus[1].OperationName =
                   "LOCKED"
                set reply->status_data.subeventstatus[1].OperationStatus =
                   "F"
                set reply->status_data.subeventstatus[1].TargetObjectName =
                   "LONG_TEXT TABLE"
                set reply->status_data.subeventstatus[1].TargetObjectValue =
                   build("RECORD LOCKED - Unable to update record with long_text_id =",
                         long_text_seq)
                return(0)
              endif
 
              /*************************************************/
              /* Update long_text record with comment text     */
              /*************************************************/    ;031
              update into
                 long_text lt
              set
                 lt.parent_entity_name = "RESULT_COMMENT",
                 lt.parent_entity_id = arg_result_id,
                 lt.active_ind = 1,
                 lt.updt_dt_tm = cnvtdatetime(curdate, curtime3),
                 lt.updt_id = reqinfo->updt_id,
                 lt.updt_task = reqinfo->updt_task,
                 lt.updt_applctx = reqinfo->updt_applctx,
                 lt.updt_cnt = lt.updt_cnt + 1
              plan lt where lt.long_text_id = long_text_seq
              with nocounter
 
              if (curqual = 0)
                set reply->status_data.subeventstatus[1].OperationName =
                   "UPDATE"
                set reply->status_data.subeventstatus[1].OperationStatus =
                   "F"
                set reply->status_data.subeventstatus[1].TargetObjectName =
                   "LONG_TEXT TABLE"
                set reply->status_data.subeventstatus[1].TargetObjectValue =
                   build("Unable to update record for long_text_id =",
                         long_text_seq)
                return(0)
              endif
 
            /**********************************************/
            /* New comment being added to long_text table */
            /**********************************************/         ;031
            else
 
              /****************************************/
              /* Get new long_text_id for new comment */
              /****************************************/             ;031
              set long_text_seq = 0.0
              if (read_long_data_seq( 0 ) = 0)
                return(0)
              endif
 
              /*************************************************/
              /* Insert new long_text record with comment text */
              /*************************************************/    ;031
              insert into
                 long_text lt
              set
                 lt.long_text_id = long_text_seq,
                 lt.parent_entity_name = "RESULT_COMMENT",
                 lt.parent_entity_id = arg_result_id,
                 lt.long_text = request->orders[oidx].assays[aidx]
                   .result_comment[rcidx].comment_text,
                 lt.active_ind = 1,
                 lt.active_status_cd = reqdata->active_status_cd,
                 lt.active_status_dt_tm = cnvtdatetime(curdate, curtime3),
                 lt.active_status_prsnl_id = reqinfo->updt_id,
                 lt.updt_dt_tm = cnvtdatetime(curdate, curtime3),
                 lt.updt_id = reqinfo->updt_id,
                 lt.updt_task = reqinfo->updt_task,
                 lt.updt_applctx = reqinfo->updt_applctx,
                 lt.updt_cnt = 0
              plan lt
              with nocounter
 
              if (curqual = 0)
                set reply->status_data.subeventstatus[1].OperationName =
                   "INSERT"
                set reply->status_data.subeventstatus[1].OperationStatus =
                   "F"
                set reply->status_data.subeventstatus[1].TargetObjectName =
                   "LONG_TEXT TABLE"
                set reply->status_data.subeventstatus[1].TargetObjectValue =
                   build("Unable to insert record for long_text_id =",
                         long_text_seq)
                return(0)
              endif
            endif
 
            /************************************************/
            /* Find the last result comment action sequence */
            /************************************************/
            set last_action_seq = 0
            select into "nl:"
               rc.result_id,
               rc.action_sequence
            from result_comment rc
            plan rc where rc.result_id = arg_result_id
                      and rc.comment_type_cd = request->orders[oidx]
                            .assays[aidx].result_comment[rcidx].comment_type_cd
            order rc.action_sequence desc
            head rc.result_id
               last_action_seq = rc.action_sequence
            with nocounter
 
            /********************************/
            /* Insert result comment record */
            /********************************/
 
            insert into
               result_comment rc
            set
               rc.result_id = arg_result_id,
               rc.action_sequence = last_action_seq + 1,
               rc.comment_type_cd = request->orders[oidx].assays[aidx]
                 .result_comment[rcidx].comment_type_cd,
               rc.long_text_id = long_text_seq,
;hdp *** Use id off reqinfo until result entry passed the prsnl_id
;hdp               rc.comment_prsnl_id = request->orders[oidx].assays[aidx]
;hdp                 .result_comment[rcidx].comment_prsnl_id,
/*hdp*/        rc.comment_prsnl_id = reqinfo->updt_id,
               rc.comment_dt_tm = cnvtdatetime(curdate, curtime3),
               rc.comment_tz = reply->event_tz,
               rc.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               rc.updt_id = reqinfo->updt_id,
               rc.updt_task = reqinfo->updt_task,
               rc.updt_applctx = reqinfo->updt_applctx,
               rc.updt_cnt = 0
            plan rc
            with nocounter
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "RESULT_COMMENT TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  build("Unable to insert record for result_id =",
                        arg_result_id, " and action_sequence =",
                        last_action_seq + 1, " and comment_type_cd =",
                        request->orders[oidx].assays[aidx]
                        .result_comment[rcidx].comment_type_cd)
               return(0)
            endif
 
            return(1)
         end
 
      /***********************************************************************
      * Read long_data_seq subroutine                                        *
      ***********************************************************************/
         declare long_text_seq           = f8
         declare read_long_data_seq( none2 ) = i4
         subroutine read_long_data_seq( none2 )
            set long_text_seq = 0.0
            select into "nl:"
               next_seq_nbr =
                 seq(long_data_seq,nextval)
            from dual
            detail
               long_text_seq = next_seq_nbr
            with nocounter, format
 
            if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "SELECT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "LONG_DATA_SEQ"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  "Unable to get next long_data_seq value"
            endif
 
            return(curqual)
         end
 
      /***********************************************************************
      * Process an new result                                                *
      ***********************************************************************/
         declare process_new_result( none3 ) = i2
 
         subroutine process_new_result( none3 )
 
            declare lReadResultStatus = i4 with noconstant(0), protect
 
            /***************************************/
            /* Verify that no result record exists */
            /* before new result is inserted       */
            /***************************************/
            if (request->orders[oidx].assays[aidx].interface_flag = 2)
              if (request->orders[oidx].assays[aidx].result_status_cd =                    ;025
                  result_status_corrected_cd)                                              ;025
                call LOG_MESSAGE ("WARNING: Posting CORRECTED result which had no previous result status.",  ;025
                                  LOG_LEVEL_DEBUG)										   ;025
              endif                                                                        ;025
            endif                                                                          ;025
 
            set curr_order_id =
                 request->orders[oidx].order_id
            set curr_task_assay_cd =
                 request->orders[oidx].assays[aidx].task_assay_cd
            set lReadResultStatus = read_result( curr_order_id, curr_task_assay_cd )
            if (lReadResultStatus > 0)
               return(0)
            elseif (lReadResultStatus = -1)
              ;* we found a Helix, which will always have a result id that got filled out in the read result function.
              if (update_result(request->orders[oidx]->assays[aidx]->result_id) = 0)
                 return(0)
              endif
            else
              if (insert_result( 0 ) = 0)
                 return(0)
              endif
            endif
 
            set reply->orders[oidx].assays[aidx].result_id = request->orders[oidx]->assays[aidx]->result_id
            set reply->orders[oidx].assays[aidx].result_updt_cnt = 0
 
            if (insert_perform_result( request->orders[oidx]->assays[aidx]->result_id, 0.0 ) = 0)
               return(0)
            else
              set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
              for (lRiidx = 1 to lNbr_of_result_images)
                if (insert_result_image(0) = 0)
                   return(0)
                endif
              endfor
            endif
            set reply->orders[oidx].assays[aidx].perform_result_id =
              perf_result_seq
            set reply->orders[oidx].assays[aidx].parent_perform_result_id = 0.0
            set reply->orders[oidx].assays[aidx].interp_data_id =      ;007
              interpretive_data_id                                     ;007
            set reply->orders[oidx].assays[aidx].perform_result_updt_cnt = 0
            /************************************/
            /* If autoverification codes exist, */
            /* insert new auto_verify_code(s).  */
            /************************************/
            if (request->orders[oidx]->assays[aidx]->auto_verify_code_cnt > 0)                       ;023
               if (insert_auto_verify_cd( perf_result_seq ) = 0)                                     ;023
                  return(0)                                                                          ;023
               endif                                                                                 ;023
            endif
 
            ; insert images
            if (request->orders[oidx]->assays[aidx]->image_cnt > 0)
               if (insert_images(0) = 0)
                  return(0)
               endif
            endif
 
            /*********************************/
            /* If result comments exists,    */
            /* insert new result comment     */
            /*********************************/
            set nbr_of_result_comments =
              request->orders[oidx].assays[aidx].result_comment_cnt
            if (nbr_of_result_comments > 0
            and request->orders[oidx].assays[aidx].result_status_cd
                                 in (result_status_performed_cd,
                                     result_status_in_review_cd,
                                     result_status_autoverified_cd,    ;005
                                     result_status_verified_cd,
                                     result_status_corrected_cd,
                                     result_status_corr_in_review_cd))
               for (rcidx = 1 to nbr_of_result_comments)
                  if (ins_upd_result_comment( request->orders[oidx]->assays[aidx]->result_id ) = 0)  ;031
                     return(0)
                  endif
               endfor
            endif
 
            /******************************/
            /* Insert result_event record */
            /******************************/
 
            /* If new result is being performed & verified at the same time, */
            /* write a perform result event before verifying                 */
;005            if (request->orders[oidx].assays[aidx].result_status_cd =
;005                                     result_status_verified_cd)
            if (request->orders[oidx].assays[aidx].result_status_cd    ;005
                                 in (result_status_verified_cd,        ;005
                                     result_status_autoverified_cd))   ;005
               set event_type_cd = result_status_performed_cd
               set event_prsnl_id =
                 request->orders[oidx].assays[aidx].perform_personnel_id
               if (insert_result_event( request->orders[oidx]->assays[aidx]->result_id,
                                        perf_result_seq,
                                        event_type_cd,
                                        event_prsnl_id,
                                        result_status_performed_disp ) = 0)
                  return(0)
               endif
            endif
 
            set event_type_cd =
              request->orders[oidx].assays[aidx].result_status_cd
            set event_prsnl_id = request->event_personnel_id
            set event_reason =
              request->orders[oidx].assays[aidx].result_status_disp
            if (insert_result_event( request->orders[oidx]->assays[aidx]->result_id,
                                     perf_result_seq,
                                     event_type_cd,
                                     event_prsnl_id,
                                     event_reason ) = 0)
               return(0)
            endif
 
            if (update_current_result_counter(0) = 0)
              return (0)
            endif
 
            /**************************/
            /* Process was successful */
            /**************************/
            return(1)
         end
 
      /***********************************************************************
      * Process an updated result                                            *
      ***********************************************************************/
         declare process_updated_result( none4 ) = i2
        
         subroutine process_updated_result( none4 )
            
            if (update_result( request->orders[oidx].assays[aidx].result_id ) = 0)
               return(0)
            endif
            set reply->orders[oidx].assays[aidx].result_id = request->orders[oidx].assays[aidx].result_id
            set reply->orders[oidx].assays[aidx].result_updt_cnt =
              request->orders[oidx].assays[aidx].result_updt_cnt + 1
 
            /***************************************/
            /* If no perform_result record exists, */
            /* write a new perform_result record   */
            /***************************************/
            if (request->orders[oidx].assays[aidx].perform_result_id = 0.0)
               if (insert_perform_result( request->orders[oidx].assays[aidx].result_id, 0.0 ) = 0)
                  return(0)
               else
                 set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                 for (lRiidx = 1 to lNbr_of_result_images)
                   if (insert_result_image(0) = 0)
                      return(0)
                   endif
                 endfor
               endif
               set reply->orders[oidx].assays[aidx].perform_result_id =
                 perf_result_seq
               set reply->orders[oidx].assays[aidx]
                 .parent_perform_result_id = 0.0
               set reply->orders[oidx].assays[aidx].interp_data_id =   ;007
                 interpretive_data_id                                  ;007
               set reply->orders[oidx].assays[aidx]
                 .perform_result_updt_cnt = 0
 
               /************************************/
               /* If autoverification codes exist, */
               /* insert new auto_verify_code(s).  */
               /************************************/
               if (request->orders[oidx]->assays[aidx]->auto_verify_code_cnt > 0)                    ;023
                  if (insert_auto_verify_cd( perf_result_seq ) = 0)                                  ;023
                     return(0)                                                                       ;023
                  endif                                                                              ;023
               endif                                                                                 ;023
 
               if (update_current_result_counter(0) = 0)
                 return (0)
               endif
 
            endif
 
            /***********************************************/
            /* If perform_result record exists, the result */
            /* is either being repeated, reperformed,      */
            /* verified, or corrected.                     */
            /***********************************************/
            if (request->orders[oidx].assays[aidx].perform_result_id > 0.0)
               set perf_result_seq =
                 request->orders[oidx].assays[aidx].perform_result_id
               if (read_perform_result( request->orders[oidx].assays[aidx].result_id, perf_result_seq ) =0) ;010
                  return(0)                                            ;010
               endif                                                   ;010
               ;* If result is not being reperformed, use the actual   ;010
               ;* previous perform date off the perform_result instead ;010
               ;* of relying on the request value.                     ;010
               if (request->orders[oidx].assays[aidx].perform_ind = 0) ;010
                  set request->orders[oidx].assays[aidx].perform_dt_tm = ;010
                    cnvtdatetime(current->perform_dt_tm)               ;010
                  set reply->orders[oidx].assays[aidx].perform_tz =
                    current->perform_tz
                  set reply->orders[oidx].assays[aidx].perform_dt_tm = ;010
                    cnvtdatetime(current->perform_dt_tm)               ;010
                  set reply->orders[oidx].assays[aidx]                 ;018
                    .perform_personnel_id =                            ;018
                    current->perform_personnel_id                      ;018
               endif                                                   ;010
               if (request->orders[oidx].assays[aidx].result_status_cd
                                   in (result_status_performed_cd,
                                       result_status_in_review_cd,
                                       result_status_verified_cd,
                                       result_status_autoverified_cd,  ;005
                                       result_status_corr_in_review_cd,
                                       result_status_corrected_cd))
;010                  if (read_perform_result( result_seq, perf_result_seq ) =0)
;010                     return(0)
;010                  endif
                  /**************************************************/
                  /* If the result is being reperformed, update the */
                  /* status on the existing perform_result record   */
                  /* to "old perform" and write a new perform_result*/
                  /* record with the current status.                */
                  /*                                                */ ;004
                  /* If the result is being repeated, write a new   */ ;004
                  /* perform_result record with the current status. */ ;004
                  /**************************************************/
                  if (curr_result_status_cd in (result_status_performed_cd,
                                                result_status_in_review_cd)
                  and request->orders[oidx].assays[aidx].result_status_cd
                                   in (result_status_performed_cd,
                                       result_status_in_review_cd,
                                       result_status_autoverified_cd,  ;005
                                       result_status_verified_cd)
                  and request->orders[oidx].assays[aidx].perform_ind > 0)
;004                     if (curr_result_status_cd = result_status_performed_cd)
                     if (curr_result_status_cd = result_status_performed_cd ;004
                     and request->orders[oidx].assays[aidx].repeat_ind = 0) ;004
                        if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                   perf_result_seq,
                                                   result_status_old_perf_cd ) =0)
                           return(0)
                        endif
                     endif                                             ;004
;004                     else
                     if (curr_result_status_cd = result_status_in_review_cd) ;004
                        if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                   perf_result_seq,
                                                   result_status_old_in_rev_cd ) =0)
                           return(0)
                        endif
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
 
                     /************************************/
                     /* If autoverification codes exist, */
                     /* insert new auto_verify_code(s).  */
                     /************************************/
                     if (request->orders[oidx]->assays[aidx]->auto_verify_code_cnt > 0)              ;023
                        if (insert_auto_verify_cd( perf_result_seq ) = 0)                            ;023
                           return(0)                                                                 ;023
                        endif                                                                        ;023
                     endif                                                                           ;023
                     
                     /**************************************************/ ;004
                     /* In case the task assay was previously repeated,*/ ;004
                     /* set all extra perform_result records to        */ ;004
                     /* "old perform" status.                          */ ;004
                     /**************************************************/ ;004
;005                     if (request->orders[oidx].assays[aidx]            ;004
;005                        .result_status_cd = result_status_verified_cd) ;004
                     if (request->orders[oidx].assays[aidx].result_status_cd ;005
                                   in (result_status_verified_cd,      ;005
                                       result_status_autoverified_cd)) ;005
                        if (update_repeated_perform_result( request->orders[oidx].assays[aidx].result_id ) = 0) ;004
                           return(0)                                   ;004
                        endif                                          ;004
                     endif                                             ;004
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
 
                     if (update_current_result_counter(0) = 0)
                        return (0)
                     endif
 
                  endif
                  /******************************************************/
                  /* If the result is being corrected from a performed  */
                  /* status and has an interface_flag of 2 meaning from */
                  /* a PTOP/RLI, then update the perform_result record  */
                  /* to be corrected.                                   */
                  /******************************************************/
                  if (curr_result_status_cd = result_status_performed_cd            ;025
                     and request->orders[oidx].assays[aidx].result_status_cd =      ;025
                        result_status_corrected_cd                                  ;025
                     and (request->orders[oidx].assays[aidx].interface_flag = 2))   ;025
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,                         ;025
                                               perf_result_seq,                     ;025
                                               result_status_old_perf_cd ) =0)      ;025
                        return(0)                                                   ;025
                     endif                                                          ;025
                     set parent_perf_result_id = perf_result_seq                    ;025
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,                         ;025
                                                parent_perf_result_id ) = 0)        ;025
                        return(0)                                                   ;025
                     endif                                                          ;025
                     call LOG_MESSAGE ("WARNING: Posting CORRECTED result which was previously PERFORMED.",  ;025
                          LOG_LEVEL_DEBUG)										    ;025
                   endif                                                            ;025
                  /**************************************************/
                  /* If the result is being verified without being  */
                  /* reperformed, update the perform_result record  */
                  /* to a verified status.                          */
                  /**************************************************/
                  if (curr_result_status_cd in (result_status_performed_cd,
                                                result_status_in_review_cd)
                  and request->orders[oidx].assays[aidx].result_status_cd
                                   in (result_status_in_review_cd,
                                       result_status_autoverified_cd,  ;005
                                       result_status_verified_cd)
                  and request->orders[oidx].assays[aidx].perform_ind = 0)
                     if (request->orders[oidx].assays[aidx].result_status_cd
                        = result_status_verified_cd)
                        if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                   perf_result_seq,
                                                   result_status_verified_cd ) =0)
                           return(0)
                        endif
                        /********************************************/ ;004
                        /* In case the task assay was previously    */ ;004
                        /* repeated, set all extra perform_result   */ ;004
                        /* records to "old perform" status.         */ ;004
                        /********************************************/ ;004
                        if (update_repeated_perform_result( request->orders[oidx].assays[aidx].result_id ) = 0) ;004
                           return(0)                                   ;004
                        endif                                          ;004
                     elseif (request->orders[oidx].assays[aidx]        ;005
                        .result_status_cd = result_status_autoverified_cd) ;005
                        if (update_perform_result( request->orders[oidx].assays[aidx].result_id,         ;005
                                                   perf_result_seq,    ;005
                                   result_status_autoverified_cd ) =0) ;005
                           return(0)                                   ;005
                        endif                                          ;005
                        /********************************************/ ;005
                        /* In case the task assay was previously    */ ;005
                        /* repeated, set all extra perform_result   */ ;005
                        /* records to "old perform" status.         */ ;005
                        /********************************************/ ;005
                        if (update_repeated_perform_result( request->orders[oidx].assays[aidx].result_id ) = 0) ;005
                           return(0)                                   ;005
                        endif                                          ;005
                     else
                        if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                   perf_result_seq,
                                                   result_status_in_review_cd ) =0)
                           return(0)
                        endif
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = curr_parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;012
                       .interp_data_id = curr_interp_data_id           ;012
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = request->orders[oidx]
                       .assays[aidx].perform_result_updt_cnt + 1
                  endif
                  /***************************************************/
                  /* If verified result is being corrected, update   */
                  /* the status on the existing perform_result record*/
                  /* to "old verified" and write a new perform_result*/
                  /* record with the corrected status.               */
                  /***************************************************/
                  if (curr_result_status_cd = result_status_verified_cd
                  and request->orders[oidx].assays[aidx].result_status_cd
                                             = result_status_corrected_cd)
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                                result_status_old_verf_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
 
                  /***************************************************/
                  /* If verified result is now in corr_inrev, update */
                  /* the status on the existing perform_result record*/
                  /* to "old verified" and write a new perform_result*/
                  /* record with the corr_inrev status.              */
                  /***************************************************/
                 if (curr_result_status_cd = result_status_verified_cd
                  and request->orders[oidx].assays[aidx].result_status_cd
                                  = result_status_corr_in_review_cd)
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                                result_status_old_verf_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
 
                  /**************************************************/ ;005
                  /* If auto verified result is being corrected,    */ ;005
                  /* update the status on the existing              */ ;005
                  /* perform_result record to "old autoverified"    */ ;005
                  /* and write a new perform_result record with the */ ;005
                  /* corrected status.                              */ ;005
                  /**************************************************/ ;005
                  if (curr_result_status_cd = result_status_autoverified_cd ;005
                  and request->orders[oidx].assays[aidx]               ;005
                    .result_status_cd = result_status_corrected_cd)    ;005
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,            ;005
                                                perf_result_seq,       ;005
                                  result_status_old_autoverf_cd ) =0)  ;005
                        return(0)                                      ;005
                     endif                                             ;005
                     set parent_perf_result_id = perf_result_seq       ;005
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,            ;005
                                                parent_perf_result_id ) = 0) ;005
                        return(0)                                      ;005
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif                                             ;005
                     set reply->orders[oidx].assays[aidx]              ;005
                       .perform_result_id = perf_result_seq            ;005
                     set reply->orders[oidx].assays[aidx]              ;005
                       .parent_perform_result_id = parent_perf_result_id ;005
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]              ;005
                       .perform_result_updt_cnt = 0                    ;005
                  endif                                                ;005
 
                  /**************************************************/
                  /* If auto verified result is in corr_in_review,  */
                  /* update the status on the existing              */
                  /* perform_result record to "old autoverified"    */
                  /* and write a new perform_result record with the */
                  /* corr-in-rev status.                            */
                  /**************************************************/
                  if (curr_result_status_cd = result_status_autoverified_cd
                  and request->orders[oidx].assays[aidx]
                    .result_status_cd = result_status_corr_in_review_cd)
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                  result_status_old_autoverf_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]
                       .interp_data_id = interpretive_data_id
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
 
                  /****************************************************/
                  /* If a corrected result is being corrected again,  */
                  /* update the status on the existing perform_result */
                  /* record to "old corrected" and write a new        */
                  /* perform_result record with the corrected status. */
                  /****************************************************/
                  if (curr_result_status_cd = result_status_corrected_cd
                  and request->orders[oidx].assays[aidx].result_status_cd
                                             = result_status_corrected_cd)
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                                result_status_old_corr_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
 
                  /****************************************************/
                  /* If a corr-in reivew result is being re corrected */
                  /* or being put in corr-inreview again, update the  */
                  /* status on the existing perform_result record to  */
                  /* "old corr-inreview" and write a new              */
                  /* perform_result record with the corrected status. */
                  /****************************************************/
 
                  if (curr_result_status_cd = result_status_corr_in_review_cd
                  and (request->orders[oidx].assays[aidx].result_status_cd
                                             = result_status_corrected_cd
                       or request->orders[oidx].assays[aidx].result_status_cd
                                             =result_status_corr_in_review_cd))
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                                result_status_old_corr_in_rev_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
 
                  /****************************************************/
                  /* If a corrected result is in corr-in review,      */
                  /* update the status on the existing perform_result */
                  /* record to "old corrected" and write a new        */
                  /* perform_result record with the corr-in rev status*/
                  /****************************************************/
                  if (curr_result_status_cd = result_status_corrected_cd
                  and request->orders[oidx].assays[aidx].result_status_cd
                                             = result_status_corr_in_review_cd)
                     if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                perf_result_seq,
                                                result_status_old_corr_cd ) =0)
                        return(0)
                     endif
                     set parent_perf_result_id = perf_result_seq
                     if (insert_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                parent_perf_result_id ) = 0)
                        return(0)
                     else
                        set lNbr_of_result_images = size(request->orders[oidx].assays[aidx].result_image, 5)
                        for (lRiidx = 1 to lNbr_of_result_images)
                          if (insert_result_image(0) = 0)
                             return(0)
                          endif
                        endfor
                     endif
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_id = perf_result_seq
                     set reply->orders[oidx].assays[aidx]
                       .parent_perform_result_id = parent_perf_result_id
                     set reply->orders[oidx].assays[aidx]              ;007
                       .interp_data_id = interpretive_data_id          ;007
                     set reply->orders[oidx].assays[aidx]
                       .perform_result_updt_cnt = 0
                  endif
                 /***********************************************/
                 /* If the assay is in corr_in_rev status and   */
                 /* is approved to be corrected, then update    */
                 /* perform_result to show the corrected status */
                 /***********************************************/
                  if (curr_result_status_cd = result_status_corr_in_review_cd
                    and request->orders[oidx].assays[aidx].result_status_cd
                                             = result_status_corrected_cd)
 
                   if (update_perform_result( request->orders[oidx].assays[aidx].result_id,
                                                  perf_result_seq,
                                                  result_status_corrected_cd) =0)
                          return(0)
                   endif
                   set reply->orders[oidx].assays[aidx]
                     .perform_result_id = perf_result_seq
                   set reply->orders[oidx].assays[aidx]
                     .parent_perform_result_id = curr_parent_perf_result_id
                   set reply->orders[oidx].assays[aidx]              ;012
                     .interp_data_id = curr_interp_data_id           ;012
                   set reply->orders[oidx].assays[aidx]
                     .perform_result_updt_cnt = request->orders[oidx]
                     .assays[aidx].perform_result_updt_cnt + 1
                  endif
               endif
 
            endif
 
            /*********************************/
            /* If result comments exists,    */
            /* insert updated result comment */
            /*********************************/
            set nbr_of_result_comments =
              request->orders[oidx].assays[aidx].result_comment_cnt
            if (nbr_of_result_comments > 0
            and request->orders[oidx].assays[aidx].result_status_cd
                                in (result_status_performed_cd,
                                    result_status_in_review_cd,
                                    result_status_verified_cd,
                                    result_status_autoverified_cd,     ;005
                                    result_status_corrected_cd,
                                    result_status_corr_in_review_cd))
               for (rcidx = 1 to nbr_of_result_comments)
                  if (ins_upd_result_comment( request->orders[oidx].assays[aidx].result_id ) = 0)   ;031
                     return(0)
                  endif
               endfor
            endif
            
            ; insert images
            if (request->orders[oidx]->assays[aidx]->image_cnt > 0)
               if (insert_images(0) = 0)
                  return(0)
               endif
            endif
 
            /******************************/
            /* Insert result_event record */
            /******************************/
            set event_type_cd =
              request->orders[oidx].assays[aidx].result_status_cd
            set event_prsnl_id = request->event_personnel_id
            set event_reason =
              request->orders[oidx].assays[aidx].result_status_disp
            if (insert_result_event( request->orders[oidx].assays[aidx].result_id,
                                     perf_result_seq,
                                     event_type_cd,
                                     event_prsnl_id,
                                     event_reason ) = 0)
               return(0)
            endif
 
            /**************************/
            /* Process was successful */
            /**************************/
            return(1)
         end
 
      /***********************************************************************
      * Update Current Result counter on qc_step_status table                *
      ***********************************************************************/
 
         declare update_current_result_counter( none5 ) = i2
         subroutine update_current_result_counter( none5 )
         
         
         declare verify_results_nbr  = i4 with protect, noconstant(0)
         declare current_results_nbr = i4 with protect, noconstant(0)
         declare step_status_id      = f8 with protect, noconstant(0.0)
         declare lAssayIdx           = i4 with protect, noconstant(0)
         declare lEIdx               = i4 with protect, noconstant(0)
         declare lCurIdx             = i4 with protect, noconstant(0)
         declare lLocIdx             = i4 with protect, noconstant(0)
         declare qss_found           = i2 with protect, noconstant(0)
                  
         record equiv_assays
         (
           1 qual[*]
             2  task_assay_cd        = f8
             2  verify_results_nbr   = i4
             2  current_results_nbr  = i4
             2  step_status_id       = f8
         )
 
           set lAssayIdx = 1
           set stat = alterlist(equiv_assays->qual, lAssayIdx)
           set equiv_assays->qual[lAssayIdx].task_assay_cd = request->orders[oidx].assays[aidx].task_assay_cd        
 
           ;Get all the equivalent assays for this assay
           select into "nl:"
           from related_assay ra1,
                related_assay ra2
           plan ra1 
             where ra1.task_assay_cd = equiv_assays->qual[1].task_assay_cd
           join ra2
             where ra2.related_entity_id = ra1.related_entity_id
             and ra2.task_assay_cd != ra1.task_assay_cd
           order by ra2.task_assay_cd
           head ra2.task_assay_cd
             lAssayIdx = lAssayIdx + 1
             if (lAssayIdx > size(equiv_assays->qual, 5))
               stat = alterlist(equiv_assays->qual, lAssayIdx + 3)
             endif
             equiv_assays->qual[lAssayIdx].task_assay_cd = ra2.task_assay_cd
           with nocounter
           
           set stat = alterlist(equiv_assays->qual, lAssayIdx)
           
           ;Find the current, unexpired QC_STEP_STATUS rows across the equivalent assays
           select into "nl:"
             qss.verify_results_nbr,
             qss.current_results_nbr,
             qss.qc_step_status_id
           from qc_step_status qss
           plan qss
             where expand(lEIdx, 1, lAssayIdx,qss.task_assay_cd, equiv_assays->qual[lEIdx].task_assay_cd)
             and qss.service_resource_cd = request->orders[oidx].assays[aidx].service_resource_cd
             and cnvtdatetime(curdate, curtime3) <= qss.step_expire_dt_tm
           order qss.step_complete_dt_tm desc, qss.task_assay_cd
           head qss.task_assay_cd
             if (qss.verify_results_nbr > 0 and qss.current_results_nbr < qss.verify_results_nbr)
               qss_found = 1
               lCurIdx = locateval(lLocIdx, 1, lAssayIdx, qss.task_assay_cd, equiv_assays->qual[lLocIdx].task_assay_cd)
               equiv_assays->qual[lCurIdx].verify_results_nbr = qss.verify_results_nbr
               equiv_assays->qual[lCurIdx].current_results_nbr = qss.current_results_nbr
               equiv_assays->qual[lCurIdx].step_status_id = qss.qc_step_status_id
             endif
           with nocounter
           
           set lCurIdx = 0
           set lEIdx = 0
           
           ;If we found QC Step Status Rows, update them.  We could probably only update the most current row,
           ;but since it's theoretically possible that there are multiple rows that were completed at the same time
           ;we might as well just update the current, unexpired, row for each resource/assay combination. 
           if (qss_found = 1)
             set qss_found = 0
             
             select into "nl:"
             from qc_step_status qss
             plan qss
               where expand(lEIdx, 1, lAssayIdx,qss.qc_step_status_id , equiv_assays->qual[lEIdx].step_status_id)
             with nocounter, forupdate(qss)
           
             update into
               qc_step_status qss,
               (dummyt d with seq = value(size(equiv_assays->qual, 5)))
             set
               qss.current_results_nbr = equiv_assays->qual[d.seq].current_results_nbr + 1,
               qss.step_expire_dt_tm = if (equiv_assays->qual[d.seq].current_results_nbr + 1 = 
                                           equiv_assays->qual[d.seq].verify_results_nbr)
                                         cnvtdatetime(curdate,curtime3)
                                       else
                                         qss.step_expire_dt_tm
             			               endif,
               qss.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               qss.updt_id = reqinfo->updt_id,
               qss.updt_task = reqinfo->updt_task,
               qss.updt_applctx = reqinfo->updt_applctx,
               qss.updt_cnt = qss.updt_cnt + 1,
               qss.updt_task = reqinfo->updt_task
             plan d
             join qss
               where qss.qc_step_status_id = equiv_assays->qual[d.seq].step_status_id
               and qss.qc_step_status_id > 0
             with nocounter
             if (error_message (1) > 0)
               return(0)
             endif
           endif
 
           return(1)
         end
 
      /***********************026 START NEW CODE ************************/
 
      /*****************************************************************************
      * This subroutine will write the necessary rows to the pn_recovery_* tables  *
      ******************************************************************************/
         declare insert_pn_recovery_data( noneIPR ) = i4
         subroutine insert_pn_recovery_data( noneIPR )
 
call LOG_MESSAGE (build(" insert_pn_recovery_data---ASSAY_CD=",
      request->orders[oidx].assays[aidx].task_assay_cd),LOG_LEVEL_DEBUG)
 
           declare pn_recovery_child_id  = f8 with protect, noconstant(0.0)
 
           ;declare variables to hold the pn_recovery_detail information
           declare pn_recovery_detail_id     = f8 with protect, noconstant( 0.0)
           declare pn_dtl_cnt                = i4 with protect, noconstant(0)
           declare detail_parent_entity_name = vc with protect, noconstant("")
           declare detail_parent_entity_id   = f8 with protect, noconstant(0.0)
           declare detail_mean               = vc with protect, noconstant("")
           declare detail_value              = i4 with protect, noconstant(0)
 
           ;if this is the first assay for the order, write the pn_recovery rows
           if (reply->orders[oidx].pn_recovery_id = 0.0)
             ;retrieve a pn_recovery_id for this order
             select into "nl:"
               next_seq_nbr = seq(pathnet_recovery_seq ,nextval)
             from dual
             detail
               reply->orders[oidx].pn_recovery_id = next_seq_nbr
             with nocounter, format
 
             if (error_message (1) > 0)
               return(0)
             endif
 
             if (reply->orders[oidx].pn_recovery_id = 0)
               return(0)
             endif
 
             ;insert pn_recovery row
             insert into
               pn_recovery pr
             set
               pr.pn_recovery_id       = reply->orders[oidx].pn_recovery_id,
               pr.parent_entity_name   = "ORDERS",
               pr.parent_entity_id     = reply->orders[oidx].order_id,
               pr.recovery_type_cd     = pn_recovery_type_cd,
               pr.in_process_flag      = 0,
               pr.expire_dt_tm         = cnvtdatetime(curdate, curtime3),
               pr.failure_cnt          = 0,
               pr.first_failure_dt_tm  = NULL,
               pr.last_failure_dt_tm   = NULL,
               pr.updt_dt_tm           = cnvtdatetime(curdate, curtime3),
               pr.updt_id              = reqinfo->updt_id,
               pr.updt_task            = reqinfo->updt_task,
               pr.updt_applctx         = reqinfo->updt_applctx,
               pr.updt_cnt             = 0
             with nocounter
 
             if (error_message (1) > 0)
               return(0)
             endif
 
             if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "PN_RECOVERY TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  "Unable to insert pn_recovery record"
               return(0)
             endif
 
             ;insert the pn_recovery_detail rows with the correct data
             for (pn_dtl_cnt = 1 to 3)
 
             ;retrieve a pn_recovery_detail_id
               select into "nl:"
                 next_seq_nbr = seq(pathnet_recovery_seq ,nextval)
               from dual
               detail
                 pn_recovery_detail_id = next_seq_nbr
               with nocounter, format
 
               if (error_message (1) > 0)
                 return(0)
               endif
 
               if (pn_recovery_detail_id = 0)
                 return(0)
               endif
 
               ;fill out the values that are to be written to the pn_recovery_detail table
               case (pn_dtl_cnt)
               of 1:
               ;insert pn_recovery_detail row for the Event_dt_Tm
               ;we only want to insert one event_dt_tm for each order
               set detail_mean               = "EVENT_DT_TM"
               set detail_parent_entity_name = "PN_RECOVERY"
               set detail_parent_entity_id   = reply->orders[oidx].pn_recovery_id
               set detail_value              = reply->event_tz
 
               of 2:
               ;insert pn_recovery_detail row for the complete_ind
               ;we only want to insert one event_dt_tm for each order
               set detail_mean               = "COMPLETE_IND"
               set detail_parent_entity_name = "PN_RECOVERY"
               set detail_parent_entity_id   = reply->orders[oidx].pn_recovery_id
               set detail_value              = reply->orders[oidx].complete_ind
 
               of 3:
               ;insert pn_recovery_detail row for the do_not_chart_ind
               ;we only want to insert one event_dt_tm for each order
               set detail_mean               = "DO_NOT_CHART"
               set detail_parent_entity_name = "PN_RECOVERY"
               set detail_parent_entity_id   = reply->orders[oidx].pn_recovery_id
               set detail_value              = request->orders[oidx].do_not_chart_ind
               endcase
 
               insert into
                 pn_recovery_detail prd
               set
                 prd.pn_recovery_detail_id   = pn_recovery_detail_id,
                 prd.parent_entity_name      = detail_parent_entity_name,
                 prd.parent_entity_id        = detail_parent_entity_id,
                 prd.detail_mean             = detail_mean,
                 prd.detail_dt_tm            = cnvtdatetime(reply->event_dt_tm),
                 prd.detail_value            = detail_value,
                 prd.updt_dt_tm              = cnvtdatetime(curdate, curtime3),
                 prd.updt_id                 = reqinfo->updt_id,
                 prd.updt_task               = reqinfo->updt_task,
                 prd.updt_applctx            = reqinfo->updt_applctx,
                 prd.updt_cnt                = 0
               with nocounter
 
               if (error_message (1) > 0)
                 return(0)
               endif
 
               if (curqual = 0)
                 set reply->status_data.subeventstatus[1].OperationName =
                    "INSERT"
                 set reply->status_data.subeventstatus[1].OperationStatus =
                    "F"
                 set reply->status_data.subeventstatus[1].TargetObjectName =
                    "PN_RECOVERY_DETAIL TABLE"
                 set reply->status_data.subeventstatus[1].TargetObjectValue =
                    "Unable to insert pn_recovery_detail record"
                 return(0)
               endif
             endfor
           endif
 
           ;retrieve a pn_recovery_child_id
           select into "nl:"
             next_seq_nbr = seq(pathnet_recovery_seq ,nextval)
           from dual
           detail
             pn_recovery_child_id = next_seq_nbr
           with nocounter, format
 
           if (error_message (1) > 0)
             return(0)
           endif
 
           if (pn_recovery_child_id = 0)
             return(0)
           endif
 
           ;insert pn_Recovery_child row
           insert into
             pn_recovery_child prc
           set
             prc.pn_recovery_id       = reply->orders[oidx].pn_recovery_id,
             prc.pn_recovery_child_id = pn_recovery_child_id,
             prc.child_entity_name    = "PERFORM_RESULT",
             prc.child_entity_id      = reply->orders[oidx].assays[aidx].perform_result_id,
             prc.updt_dt_tm           = cnvtdatetime(curdate, curtime3),
             prc.updt_id              = reqinfo->updt_id,
             prc.updt_task            = reqinfo->updt_task,
             prc.updt_applctx         = reqinfo->updt_applctx,
             prc.updt_cnt             = 0
           with nocounter
 
           if (error_message (1) > 0)
             return(0)
           endif
 
           if (curqual = 0)
             set reply->status_data.subeventstatus[1].OperationName =
                "INSERT"
             set reply->status_data.subeventstatus[1].OperationStatus =
                "F"
             set reply->status_data.subeventstatus[1].TargetObjectName =
                "PN_RECOVERY_CHILD TABLE"
             set reply->status_data.subeventstatus[1].TargetObjectValue =
                "Unable to insert pn_recovery_child record"
             return(0)
           endif
 
           ;insert the pn_recovery_detail rows with the correct data
           for (pn_dtl_cnt = 1 to 4)
 
             ;retrieve a pn_recovery_detail_id
             select into "nl:"
               next_seq_nbr = seq(pathnet_recovery_seq ,nextval)
             from dual
             detail
               pn_recovery_detail_id = next_seq_nbr
             with nocounter, format
 
             if (error_message (1) > 0)
               return(0)
             endif
 
             if (pn_recovery_detail_id = 0)
               return(0)
             endif
 
             ;fill out the values that are to be written to the pn_recovery_detail table
             case (pn_dtl_cnt)
             of 1:
               set detail_mean               = "EVENT_SEQUENCE"
               set detail_parent_entity_name = "PN_RECOVERY_CHILD"
               set detail_parent_entity_id   = pn_recovery_child_id
               set detail_value              = last_event_seq + 1
             of 2:
               set detail_mean               = "MAX_DIGITS"
               set detail_parent_entity_name = "PN_RECOVERY_CHILD"
               set detail_parent_entity_id   = pn_recovery_child_id
               set detail_value              = request->orders[oidx].assays[aidx].max_digits
             of 3:
               set detail_mean               = "MIN_DIGITS"
               set detail_parent_entity_name = "PN_RECOVERY_CHILD"
               set detail_parent_entity_id   = pn_recovery_child_id
               set detail_value              = request->orders[oidx].assays[aidx].min_digits
             of 4:
               set detail_mean               = "MIN_DEC_PLACES"
               set detail_parent_entity_name = "PN_RECOVERY_CHILD"
               set detail_parent_entity_id   = pn_recovery_child_id
               set detail_value              = request->orders[oidx].assays[aidx].min_decimal_places
             endcase
 
             insert into
               pn_recovery_detail prd
             set
               prd.pn_recovery_detail_id   = pn_recovery_detail_id,
               prd.parent_entity_name      = detail_parent_entity_name,
               prd.parent_entity_id        = detail_parent_entity_id,
               prd.detail_mean             = detail_mean,
               prd.detail_value            = detail_value,
               prd.updt_dt_tm              = cnvtdatetime(curdate, curtime3),
               prd.updt_id                 = reqinfo->updt_id,
               prd.updt_task               = reqinfo->updt_task,
               prd.updt_applctx            = reqinfo->updt_applctx,
               prd.updt_cnt                = 0
             with nocounter
 
             if (error_message (1) > 0)
               return(0)
             endif
 
             if (curqual = 0)
               set reply->status_data.subeventstatus[1].OperationName =
                  "INSERT"
               set reply->status_data.subeventstatus[1].OperationStatus =
                  "F"
               set reply->status_data.subeventstatus[1].TargetObjectName =
                  "PN_RECOVERY_DETAIL TABLE"
               set reply->status_data.subeventstatus[1].TargetObjectValue =
                  "Unable to insert pn_recovery_detail record"
               return(0)
             endif
           endfor
             
             if(request->orders[oidx].assays[aidx].interface_flag = 2 and 
	                cnvtdatetime(request->orders[oidx].assays[aidx].in_lab_dt_tm) > 0.0)    
               ;retrieve a pn_recovery_detail_id
               select into "nl:"
                 next_seq_nbr = seq(pathnet_recovery_seq ,nextval)
               from dual
               detail
                 pn_recovery_detail_id = next_seq_nbr
               with nocounter, format
 
               if (error_message (1) > 0)
                 return(0)
               endif
 
               if (pn_recovery_detail_id = 0)
                 return(0)
               endif
         
               insert into
                 pn_recovery_detail prd
               set
                 prd.pn_recovery_detail_id  = pn_recovery_detail_id,
	             prd.parent_entity_name 	= "PN_RECOVERY_CHILD",
	             prd.parent_entity_id 	    = pn_recovery_child_id,
	             prd.detail_mean 		    = "RLI_IN_LAB_DT_TM",
	             prd.detail_dt_tm 		    = cnvtdatetime(request->orders[oidx].assays[aidx].in_lab_dt_tm),
	             prd.updt_dt_tm             = cnvtdatetime(curdate, curtime3),
	             prd.updt_id                = reqinfo->updt_id,
	             prd.updt_task              = reqinfo->updt_task,
	             prd.updt_applctx           = reqinfo->updt_applctx,
	             prd.updt_cnt               = 0        
               with nocounter
             endif
           
           if (size(request->orders[oidx].assays[aidx].ref_cd_list, 5) > 0)
              insert into
                pn_recovery_detail prd,
                (dummyt d with seq = size(request->orders[oidx].assays[aidx].ref_cd_list, 5))
              set
                prd.pn_recovery_detail_id = seq(pathnet_recovery_seq ,nextval),
                prd.parent_entity_name    = "PN_RECOVERY_CHILD",
                prd.parent_entity_id      = pn_recovery_child_id,
                prd.detail_mean           = "RES_CD_ARG",
                prd.detail_value          = request->orders[oidx].assays[aidx].ref_cd_list[d.seq].nomenclature_id,
                prd.updt_dt_tm            = cnvtdatetime(curdate, curtime3),
                prd.updt_id               = reqinfo->updt_id,
                prd.updt_task             = reqinfo->updt_task,
                prd.updt_applctx          = reqinfo->updt_applctx,
                prd.updt_cnt              = 0
              plan d
              join prd
              with nocounter
           endif
           ;subroutine was successfull, return one
           return(1)
         end
                          
			
 
      /***********************026 END NEW CODE ************************/
 
 
      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
      #Script
         set reply->status_data.status = "F"
 
         ;indicator to indicate whether each assay is new or not
         declare new_result_ind = i2 with protect, noconstant(0)
 
         ;declare flat structure to hold the indexes of the new
         ;result_id's that we have created
         ;This list will be used in the setting of the new_result_ind for
         ;each assay
 
         declare nNew_Results_Cnt = i4 with protect, noconstant(0)
         declare nNew_Results_Idx = i4 with protect, noconstant(0)
         record NewResults
         (
           1 qual[*]
             2 oidx = i4
             2 aidx = i4
         )
 
         declare sResult_Failure    = c1 with protect, noconstant("F")
         declare nReplySubEvent_Cnt = i4 with protect, noconstant(0)
         declare nReplySubEvent_Idx = i4 with protect, noconstant(0)
 
      /***********************************************************************
      * Load result type and result status code sets                         *
      ***********************************************************************/
         set cv_cnt = 0
 
         select into "nl:"
            cv.code_set,
            cv.code_value
         from
            code_value cv
;009         where cv.code_set in ( RESULT_TYPE_CODESET, RESULT_STATUS_CODESET )
         where ((cv.code_set = RESULT_TYPE_CODESET)                    ;009
             or (cv.code_set = RESULT_STATUS_CODESET )                 ;009
             or (cv.code_set = LOCATION_TYPE_CODESET
               and cv.cdf_meaning = LOC_TYPE_FACILITY_CDF)
             or (cv.code_set = SERVICE_RESOURCE_TYPE_CODESET           ;009
               and cv.cdf_meaning = SERV_RES_SUBSECTION_CDF)           ;009
             or (cv.code_set = PN_RECOVERY_TYPE_CODESET                ;026
               and cv.cdf_meaning = PN_RECOVERY_TYPE_CDF)              ;026
             )                                                         ;009
           and cv.active_ind = 1
           and (cv.begin_effective_dt_tm <= cnvtdatetime(curdate, curtime3)
             and  cv.end_effective_dt_tm >= cnvtdatetime(curdate, curtime3))
         detail
            if (cv.code_set = RESULT_TYPE_CODESET)
               case (cv.cdf_meaning)
                 of RESULT_TYPE_TEXT_CDF:
                    result_type_text_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_ALPHA_CDF:
                    result_type_alpha_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_NUMERIC_CDF:
                    result_type_numeric_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_INTERP_CDF:
                    result_type_interp_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_DATE_CDF:
                    result_type_date_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_FREETEXT_CDF:
                    result_type_freetext_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_TYPE_CALC_CDF:
                    result_type_calc_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
               endcase
            endif
            if (cv.code_set = RESULT_STATUS_CODESET)
               case (cv.cdf_meaning)
                 of RESULT_STATUS_PENDING_CDF:
                    result_status_pending_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_IN_LAB_CDF:
                    result_status_in_lab_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_PERFORMED_CDF:
                    result_status_performed_cd = cv.code_value
                    result_status_performed_disp = cv.display
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_OLD_PERF_CDF:
                    result_status_old_perf_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_VERIFIED_CDF:
                    result_status_verified_cd = cv.code_value
                    result_status_verified_disp = cv.display
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_OLD_VERF_CDF:
                    result_status_old_verf_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_AUTOVERIFIED_CDF:                    ;005
                    result_status_autoverified_cd = cv.code_value      ;005
                    cv_cnt = cv_cnt + 1                                ;005
                 of RESULT_STATUS_OLD_AUTOVERF_CDF:                    ;005
                    result_status_old_autoverf_cd = cv.code_value      ;005
                    cv_cnt = cv_cnt + 1                                ;005
                 of RESULT_STATUS_CORRECTED_CDF:
                    result_status_corrected_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_OLD_CORR_CDF:
                    result_status_old_corr_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_IN_REVIEW_CDF:
                    result_status_in_review_cd = cv.code_value
                    result_status_in_review_disp = cv.display
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_CORR_IN_REVIEW_CDF:
                    result_status_corr_in_review_cd = cv.code_value
                    result_status_corr_in_review_disp = cv.display
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_OLD_IN_REV_CDF:
                    result_status_old_in_rev_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
                 of RESULT_STATUS_OLD_CORR_IN_REVIEW_CDF:
                    result_status_old_corr_in_rev_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
               endcase
            endif
            if (cv.code_set = LOCATION_TYPE_CODESET)
               case (cv.cdf_meaning)
                 of LOC_TYPE_FACILITY_CDF:
                    loc_type_facility_cd = cv.code_value
                    cv_cnt = cv_cnt + 1
               endcase
            endif
            if (cv.code_set = SERVICE_RESOURCE_TYPE_CODESET)           ;009
               case (cv.cdf_meaning)                                   ;009
                 of SERV_RES_SUBSECTION_CDF:                           ;009
                    serv_res_subsection_cd = cv.code_value             ;009
                    cv_cnt = cv_cnt + 1                                ;009
               endcase                                                 ;009
            endif                                                      ;009
 
            if (cv.code_set = PN_RECOVERY_TYPE_CODESET)                ;026
               case (cv.cdf_meaning)                                   ;026
                 of PN_RECOVERY_TYPE_CDF:                              ;026
                    pn_recovery_type_cd = cv.code_value                ;026
                    cv_cnt = cv_cnt + 1                                ;026
               endcase                                                 ;026
            endif                                                      ;026
         with nocounter
 
         ;* Verify that all required code value records were read.
         if (cv_cnt != CV_REQUIRED_RECS)
            set reply->status_data.subeventstatus[1].OperationName =
               "SELECT"
            set reply->status_data.subeventstatus[1].OperationStatus =
               "F"
            set reply->status_data.subeventstatus[1].TargetObjectName =
               "CODE_VALUE TABLE"
            set reply->status_data.subeventstatus[1].TargetObjectValue =
               "Unable to read all required code values for script execution"
            go to Exit_Script
         endif
 
      /***********************************************************************
      * Check to see if the result recovery logic is enabled                 *
      ***********************************************************************/
 
      ;default as the pn_recovery enabled.
      set reply->pn_recovery_ind = 1
 
      select into "nl:"
        dm.info_domain
      from
        dm_info dm
      plan dm
        where dm.info_domain = PN_RECOVERY_INFO_DOMAIN
          and dm.info_name   = PN_RECOVERY_INFO_NAME
      detail
        ;if row found on the dm_info table, pn_recovery logic is disabled.
        reply->pn_recovery_ind = 0
      with nocounter
 
      if (reply->pn_recovery_ind = 0)
        call LOG_MESSAGE ("The pn_recovery logic has been disabled.",LOG_LEVEL_DEBUG)
      endif
 
      if (error_message (1) > 0)
        go to Exit_Script
      endif
 
      /***********************************************************************
      *If any of the orders are in a cancel status, exit the script          *
      ***********************************************************************/
      set lCurListSize = size(request->orders,5)
      set lLoopCnt = ceil(cnvtreal(lCurListSize) / lBatchSize)
      set lNewListSize = lLoopCnt * lBatchSize
      set stat = alterlist(orders->qual,lNewListSize)
      set lStart = 1
 
      ;pad request with the last item
      for(lIndex = 1 to lNewListSize)
        if(lIndex <= lCurListSize)
          set orders->qual[lIndex].order_id = request->orders[lIndex].order_id
        else
          set orders->qual[lIndex].order_id = request->orders[lCurListSize].order_id
        endif
      endfor
 
      select into "nl:"
      from (dummyt d1 with seq = value(lLoopCnt)),
            orders o
      plan d1 where initarray(lStart,evaluate(d1.seq,1,1,lStart+lBatchSize))
      join o where expand(lIndex, lStart, lStart + (lBatchSize - 1), o.order_id, orders->qual[lIndex].order_id)
             and o.order_status_cd = dOrderCanceledCd
 
      if(curqual > 0)
        set reply->status_data.subeventstatus[1].OperationName =
          "SELECT"
        set reply->status_data.subeventstatus[1].OperationStatus =
          "F"
        set reply->status_data.subeventstatus[1].TargetObjectName =
          "ORDERS"
        set reply->status_data.subeventstatus[1].TargetObjectValue =
          "Cannot update orders because an order has been canceled"
        set reply->fail_reason_flag = 1
 
        go to Exit_Script
      endif
 
      /* since some Helix / MDI logic will require it, lets make sure the
         request->orders[].activity_type_mean is filled out */
      select into "nl:"
      from
        (dummyt d1 with seq = value(lLoopCnt)),
        orders o
      plan d1 where initarray(lStart,evaluate(d1.seq,1,1,lStart+lBatchSize))
      join o where expand(lIndex, lStart, lStart + (lBatchSize - 1), o.order_id, orders->qual[lIndex].order_id)
          and o.activity_type_cd+0.0 = HELIX_CD
      detail
        lIndex = locateval(lIndex, 1, lCurListSize, o.order_id, orders->qual[lIndex].order_id)
        while (lIndex > 0)
          request->orders[lIndex].activity_type_mean = HELIX_MEAN
          lIndex = locateval(lIndex, lIndex+1, lCurListSize, o.order_id, orders->qual[lIndex].order_id)
        endwhile
      with nocounter
 
      call ConvertRTF(0)
 
      set stat = alterlist(orders->qual, lCurListSize)
 
      /***********************************************************************
      * For each order, determine if a review is always required.  Change    *
      * results status from Verified to In-Review as necessary.  Mark order  *
      * for review initiation if it is complete and then mark order as not   *
      * complete.                                                            *
      ***********************************************************************/
      set nbr_of_orders = size(request->orders,5)
      set stat = alterlist(reply->orders, nbr_of_orders)
 
      if (request->orders[1].assays[1].interface_flag != 3)
        ;Not called from the review queue application - when this script IS
        ;called from the review queue application, skip this section
        ;since orders should be processed normally regardless of review
        ;requirements.
        set nbr_of_orders = size(request->orders,5)
        for (oidx = 1 to nbr_of_orders)
          if (request->orders[oidx].review_required_ind = 1)
            ;Logic moved into pfmt_gl_upd_order script to determine 
            ;if the update_review_ind should be set to one or not
            ;Mark order as not complete so that the process server won't
            ;update it.
            set request->orders[oidx].complete_ind = 0
            ;Loop through assays and change those with an updated status
            ;of Verified to a status of In-Review.
            set nbr_of_assays = request->orders[oidx].assays_cnt
            for (aidx = 1 to nbr_of_assays)
;005                 if (request->orders[oidx].assays[aidx].result_status_cd =
;005                 result_status_verified_cd)
              if (request->orders[oidx].assays[aidx].result_status_cd  ;005
                         in (result_status_verified_cd,             ;005
                             result_status_autoverified_cd))        ;005
                set request->orders[oidx].assays[aidx].result_status_cd =
                result_status_in_review_cd
                set request->orders[oidx].assays[aidx].result_status_disp =
                result_status_in_review_disp
              endif
            endfor
          endif
        endfor
      endif
 
      /***********************************************************************
      * Retrieve the result_id's for all of the assays in the list           *
      ***********************************************************************/
 
      set nbr_of_orders = size(request->orders,5)
      set stat = alterlist(explode_results_req->orders, nbr_of_orders)
      for (oidx = 1 to nbr_of_orders)
        set explode_results_req->orders[oidx].order_id = request->orders[oidx].order_id
        set nbr_of_assays = size(request->orders[oidx]->assays, 5)
 
        for (aidx = 1 to nbr_of_assays)
 
          ;fill out the result id if this is a new result
          if (request->orders[oidx]->assays[aidx]->result_id = 0.0)
 
            select into "nl:"
              next_seq_nbr = seq(pathnet_seq,nextval)
            from dual
            detail
              request->orders[oidx]->assays[aidx]->result_id = next_seq_nbr
            with nocounter, format
 
            if ((error_message (1) > 0) or
                (request->orders[oidx]->assays[aidx]->result_id = 0.0))
              set sResult_Failure = "T"
              set aidx = nbr_of_assays + 1
              set oidx = nbr_of_orders + 1
            endif
 
            ;add item to the the NewResults->qual list to indicate to
            ;the rest of the script that this order/assay index is new
            set nNew_Results_Cnt = nNew_Results_Cnt + 1
            if (nNew_Results_Cnt  > size(NewResults->qual, 5))
              set stat = alterlist(NewResults->qual, nNew_Results_Cnt + 10)
            endif
 
            set NewResults->qual[nNew_Results_Cnt]->oidx = oidx
            set NewResults->qual[nNew_Results_Cnt]->aidx = aidx
 
          endif
 
        endfor      ;aidx
      endfor      ;oidx
 
      if (nNew_Results_Cnt > 0)
        set stat = alterlist(NewResults->qual, nNew_Results_Cnt)
      endif
 
 
      if (size(explode_results_req->orders, 5) > 0)
        execute ucm_explode_results with replace("REQUEST", "EXPLODE_RESULTS_REQ"),
                                         replace("REPLY", "EXPLODE_RESULTS_REP")
        ;* Check status from script call
        if (explode_results_rep->status_data.status = "F")
          call LOG_MESSAGE ("Error performing script ucm_explode_results.", LOG_LEVEL_AUDIT)
        endif
      endif
 
      /***********************************************************************
      * Execute script to load the Interceptor Request and to call the       *
        Interceptor and the Pcs_upd_review_Items Script                      *
      ***********************************************************************/
%I cclsource:pcs_load_interceptor.inc
 
      ;check status from Interceptor script
      if (reply->status_data->status = "F")
         go to Exit_Script
      endif
 
      ;default the initial status of the script to be false to
      ;process the rest of the script
      set reply->status_data->status = "F"
 
      /***********************************************************************
      * Process new results by inserting new result, perform_result, and     *
      * result_event records.  Update existing results by updating result    *
      * records and adding new perform_result and result_event records.      *
      * If new result comment exists, insert the new result_comment records. *
      ***********************************************************************/
         set equation_cnt = 0
 
         ;initialize flag to indicate whether performed         ;024
         ;results have been found in the request structure      ;024
         set found_perf_results = 0                             ;024
 
         if(curutc = 1)
           set reply->event_tz = curtimezoneapp
         endif
 
         for (oidx = 1 to nbr_of_orders)
           set nbr_of_assays = request->orders[oidx].assays_cnt
           set reply->orders[oidx].complete_ind = request->orders[oidx].complete_ind
           set reply->orders[oidx]->order_id = request->orders[oidx].order_id
           set reply->orders[oidx]->assays_cnt = nbr_of_assays
           set stat = alterlist(reply->orders[oidx].assays, nbr_of_assays)
 
           if(curutc = 1)
             if(request->orders[oidx].assays[1].interface_flag = 0 or
                request->orders[oidx].assays[1].interface_flag = 4 or
                request->orders[oidx].assays[1].interface_flag = 6)
               set reply->orders[oidx].assays[1].perform_tz = curtimezoneapp
             else
 
               call AddTimeZoneRequest(request->orders[oidx].assays[1].service_resource_cd)
 
               if(LoadRequestedTimeZone(0) = 1)
                 set reply->orders[oidx].assays[1].perform_tz =
                     GetRequestedTimeZone(request->orders[oidx].assays[1].service_resource_cd)
               else
                 set reply->orders[oidx].assays[1].perform_tz = curtimezoneapp
               endif
             endif
             if(request->orders[oidx].assays[1].interface_flag = 2 or
                request->orders[oidx].assays[1].interface_flag = 8)
                set reply->event_tz = reply->orders[oidx].assays[1].perform_tz
             endif
           endif
 
 
            for (aidx = 1 to nbr_of_assays)
 
              if(curutc = 1)
                set reply->orders[oidx].assays[aidx].perform_tz = reply->orders[oidx].assays[1].perform_tz
              endif
 
              set reply->orders[oidx].assays[aidx].fail_reason_flag = 0
 
              ;default this assay as not a new result
              set new_result_ind = 0
 
              ;loop through each item in the NewResults->qual list
              ;looking for this order and assay index as a new result
              for (nNew_Results_Idx = 1 to nNew_Results_Cnt)
 
                if ((NewResults->qual[nNew_Results_Idx]->oidx = oidx) and
                    (NewResults->qual[nNew_Results_Idx]->aidx = aidx))
                  ;set new result indicator to show this is
                  ;a new assay
                  set new_result_ind = 1
                elseif ((NewResults->qual[nNew_Results_Idx]->oidx >= oidx) and
                        (NewResults->qual[nNew_Results_Idx]->aidx > aidx))
                  ;if we have passed this order/assay index, we can
                  ;stop looking because the oidx / aidx values were added
                  ;sequentially
                  set nNew_Results_Idx = nNew_Results_Cnt + 1
                endif
              endfor
 
              call LOG_MESSAGE (build("aidx -->", aidx), LOG_LEVEL_DEBUG)
              call LOG_MESSAGE (build("new_result_ind -->", new_result_ind), LOG_LEVEL_DEBUG)
 
              if (request->orders[oidx].assays[aidx].result_status_cd
                not in(result_status_pending_cd,                                ;025
                       result_status_in_lab_cd,                                 ;025
                       result_status_performed_cd,                              ;025
                       result_status_old_perf_cd,                               ;025
                       result_status_verified_cd,                               ;025
                       result_status_old_verf_cd,                               ;025
                       result_status_autoverified_cd,                           ;025
                       result_status_old_autoverf_cd,                           ;025
                       result_status_corrected_cd,                              ;025
                       result_status_old_corr_cd,                               ;025
                       result_status_in_review_cd,
                       result_status_corr_in_review_cd,                         ;025
                       result_status_old_in_rev_cd)                             ;025
                or (request->orders[oidx].assays[aidx].result_status_cd = 0))   ;025
                if (request->orders[oidx].assays[aidx].interface_flag = 2)      ;025
                  set reply->orders[oidx].assays[aidx].fail_reason_flag = 3     ;025
                endif                                                           ;025
                set reply->fail_reason_flag = 3                                 ;025
                go to Exit_Script  ;fail all results
              endif                                                             ;025
 
              ;check each assay to see if it is in a performed status for         ;024
              ;the instr_que logic                                                ;024
              if (request->orders[oidx]->assays[aidx]->result_status_cd =         ;024
                                      result_status_performed_cd)                 ;024
                 set found_perf_results = 1                                       ;024
              endif                                                               ;024
 
 /*jdf*/      if (oidx = 1 and aidx = 1 )
 /*jdf*/         set reply->interface_flag =
 /*jdf*/           request->orders[1].assays[1].interface_flag
 /*jdf*/      endif
              set reply->orders[oidx].assays[aidx].task_assay_cd =
                request->orders[oidx].assays[aidx].