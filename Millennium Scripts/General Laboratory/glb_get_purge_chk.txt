 ;;Solution_Test/script/PathNet -- Gen Lab/glb_get_purge_chk/glb_get_purge_chk.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1996 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/

/*****************************************************************************

        Source file name:       glb_get_purge_chk.prg 
        Object name:            glb_get_purge_chk
        Request #:              250193

        Product:                General Lab
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Check to see how many rows will be purged

        Tables read:            encounter
                                orders
                                accession_order_r
                                result
                                perform_result
                                result_comment
                                person

        Tables purged:          long_text 
                                result_comment 
                                included_components 
                                result_event 
                                perform_result 
                                result 
                                order_serv_res_container 
                                order_container_r 
                                pending_collection 
                                order_laboratory 
                                order_procedure_exception 
                                accession_order_r 
         
        Executing from:         Operations

        Special Notes:          

******************************************************************************/

;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;    *000 02/23/98 Kevin Brunner        Initial Release                     *
;    *001 12/10/99 Gary Runde           Clean up code                       *
;~DE~************************************************************************


;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

             drop program GLB_GET_PURGE_CHK:dba go    
             create program GLB_GET_PURGE_CHK:dba
   
; I18N INCLUDE FILE                                                   
%i cclsource:i18n_uar.inc                                             

; INITIALIZE VARIABLE THAT KEEPS HANDLE TO I18N DATA                  
set i18nHandle = 0                                                    

; CALL uar_i18nlocalizationinit                                       
set h = uar_i18nlocalizationinit(i18nHandle, curprog, "", curcclrev)  

record I18N_Captions (
	1 NumOrders = vc
	1 PersonID = vc
	1 EncounterID = vc
	1 ReportNo = vc
	1 GenLabHead = vc
        1 ReportDate = vc
	1 DateFrom = vc
	1 RepTime = vc
	1 DateTo = vc
 	1 PageNum = vc
	1 BatchSelect = vc
	1 Name = vc
	1 LtInfo = vc
	1 ReInfo = vc
	1 PRInfo = vc
	1 RInfo = vc
	1 OSRCInfo = vc
	1 OLInfo = vc
	1 AORInfo = vc
	1 DeleteSummary = vc
	1 TableName = vc
	1 Rows = vc
	1 MEGS = vc
	1 astk = vc
	1 TotMegs = vc
	1 TotEncounters = vc
	1 EndoReport = vc
	1 DischDtTm = vc
)
call echo("3")

      set I18N_Captions->NumOrders = uar_i18ngetmessage(i18nHandle, "NumOrders",  
		"Number of Orders:")
      set I18N_Captions->DischDtTm = uar_i18ngetmessage(i18nHandle, "DischDtTm",  
		"Discharged Date/Time:")
      set I18N_Captions->PersonID = uar_i18ngetmessage(i18nHandle, "PersonID", 
                "Person ID:")
      set I18N_Captions->EncounterID = uar_i18ngetmessage(i18nHandle, "EncounterID", 
		"Encounter ID:")
      set I18N_Captions->BatchSelect = uar_i18ngetmessage(i18nHandle, "BatchSelect", 
		"BATCH SELECTION: ")
      set I18N_Captions->ReportNo = uar_i18ngetmessage(i18nHandle, 
		"ReportNo", "REPORT NO:  GLB_GET_PURGE_CHK.PRG") 
      set I18N_Captions->GenLabHead = uar_i18ngetmessage(i18nHandle, 
		"GenLabHeader", "General Laboratory Activity Purge")
      set I18N_Captions->ReportDate = uar_i18ngetmessage(i18nHandle, 
		"Reportdate", "DATE:")
      set I18N_Captions->DateFrom = uar_i18ngetmessage(i18nHandle, 
		"DateFrom", "DATE FROM:")
      set I18N_Captions->RepTime = uar_i18ngetmessage(i18nHandle, "TIME", "TIME:")
      set I18N_Captions->DateTo = uar_i18ngetmessage(i18nHandle, 
		"Dateto", "DATE TO:")      
      set I18N_Captions->PageNum = uar_i18ngetmessage(i18nHandle, "Page", "PAGE:")          
      set I18N_Captions->astk = uar_i18ngetmessage(i18nHandle, "ask", "*")
      set I18N_Captions->Name = uar_i18ngetmessage(i18nHandle, "Name", "Name")              
      set I18N_Captions->LtInfo = uar_i18ngetmessage(i18nHandle, "LTINFO", 
		"Relationship with comment/interp/text (long_text_id)")   
      set I18N_Captions->ReInfo = uar_i18ngetmessage(i18nHandle, "REINfo", 
		"Relationship with result event (result_id)")             
      set I18N_Captions->PRInfo = uar_i18ngetmessage(i18nHandle, "PR", 
		"Relationship with perform result (result_id)")        
      set I18N_Captions->RInfo =uar_i18ngetmessage(i18nHandle, "R", 
		"Relationship with result (result_id)")             
      set I18N_Captions->OSRCInfo = uar_i18ngetmessage(i18nHandle, "osrc", 
		"Relationship with order/service resource/container (order_id)")  
      set I18N_Captions->OLInfo = uar_i18ngetmessage(i18nHandle, "OL", 
		"Relationship with order laboratory (order_id)")       
      set I18N_Captions->AORInfo = uar_i18ngetmessage(i18nHandle, "aor",  
		"Relationship with accession/order (order_id)")
      set I18N_Captions->DeleteSummary = uar_i18ngetmessage(i18nHandle, 
		"GenlabSummary", "General Lab Purge Summary")         
      set I18N_Captions->TableName = uar_i18ngetmessage(i18nHandle, 
		"TableName", "Table Name")
      set I18N_Captions->Rows = uar_i18ngetmessage(i18nHandle, "Rows", "Rows")             
      set I18N_Captions->MEGS = uar_i18ngetmessage(i18nHandle, "MGS", "Megabytes") 
      set I18N_Captions->TotMegs = uar_i18ngetmessage(i18nHandle, "MEGRetrieved", 
		"Estimated total meg retrieved from delete:  ")  
      set I18N_Captions->TotEncounters = uar_i18ngetmessage(i18nHandle, "EncountersDeleted", 
		"Number person encounters with data deleted:")  
      set I18N_Captions->EndoReport = uar_i18ngetmessage(i18nHandle, 
		"key_67","##### END OF REPORT #####")

      /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
;      record request
;      ( 
;         1  beg_nbr_days               = i2
;         1  end_nbr_days               = i2
;         1  purge_commit_ind           = i2
;         1  print_list_flag           = i2
;         1  print_count_flag           = i2
;         1  batch_selection            = vc 
;         1  output_dist                = vc 
;         1  ops_date                   = dq8
;         1  printer_name               = vc
;      )


      record reply
      ( 
%i cclsource:status_block.inc
)

      /***********************************************************************
      * Purge Record                                                         *
      ***********************************************************************/
      record purge
      ( 
         1  encntrs[*]
           2  purge_flag                = i2            
           2  encntr_id                 = f8            
           2  problem_id                = f8
           2  num_orders                = i2
;001           2  accns[*]
;001              3 accession_id
           2  orders[*]
              3  order_id            = f8
              3  results[*]
                 4  result_id        = f8
                 4  textuals[*]                              ;001
                    5  long_text_id  = f8                   ;001
                 4  comments[*]                             ;001
                    5  long_text_id  = f8                   ;001
      )

      record temp
      ( 
         1  beg_dt_tm               = dq8
         1  end_dt_tm               = dq8
      )

      record ops_params                                                                 ;001
      (                                                                                 ;001
         1  qual[5]                                                                     ;001
            2  param                     = c100                                         ;001
      )                                                                                 ;001

      declare del_lt_cnt     = i4
      declare del_rc_cnt     = i4
      declare del_ic_cnt     = i4
      declare del_re_cnt     = i4
      declare del_pr_cnt     = i4
      declare del_r_cnt      = i4
      declare del_osrc_cnt   = i4
      declare del_ocr_cnt    = i4
      declare del_pc_cnt     = i4
      declare del_ol_cnt     = i4
      declare del_ope_cnt    = i4
      declare del_aor_cnt    = i4
      set del_lt_cnt = 0
      set del_rc_cnt = 0
      set del_ic_cnt = 0
      set del_re_cnt = 0
      set del_pr_cnt = 0
      set del_r_cnt = 0
      set del_osrc_cnt = 0
      set del_ocr_cnt = 0
      set del_pc_cnt = 0
      set del_ol_cnt = 0
      set del_ope_cnt = 0
      set del_aor_cnt = 0

      set meg_cnt = 0.0
      set meg_tot_cnt = 0.0
      set del_encounter_nbr = 0

      set o_tab = 1
      set aor_tab = 2
      set ope_tab = 3
      set ol_tab = 4
      set pc_tab = 5
      set ocr_tab = 6
      set osrc_tab = 7
      set r_tab = 8
      set pr_tab = 9
      set lt_tab = 10
      set re_tab = 11
      set ic_tab = 12
      set rc_tab = 13

      set e_cnt = 0
      set a_cnt = 0
      set o_cnt = 0
      set r_cnt = 0
      set interp_cnt = 0
      set rc_cnt = 0
      set purge_success = 0

      set reply->status_data->status = "F"

 /***********************************************************************
 * Load operations parameter list                                       *
 ***********************************************************************/
;001 Start New Code
;ops param list
;output_dist = printer_name
;1 = nbr_days
;2 = purge_commit_ind
;3 = print_list_flag
;4 = print_count_flag

         if (trim(request->batch_selection) > " ")                                              
            set batch_selection_cd = cnvtreal(trim(request->batch_selection))                   
            set parm_string = fillstring(100, " ")                                              
            set display = fillstring(100, " ")                                              
    
            select into "nl:"                                                                   
              cv.code_value                                                                     
            from                                                                                
              code_value cv                                                                     
                where cv.code_set = 1950 and cv.active_ind = 1 
		and cv.cdf_meaning = "PURGE" and  
                trim(cv.display_key) = trim(cnvtupper(cnvtalphanum(request->batch_selection)))        
            detail                                                                              
               cdf_string = trim(cv.cdf_meaning)                                                
               parm_string = trim(cv.definition)                                                
               display = trim(cv.display)                                                
            with                                                                                
               nocounter                                                                        
                        
            if (curqual = 0)                                                                    
                select into "nl:"                                                               
                        cv.code_value                                                           
                from                                                                            
                        code_value cv                                                           
                where cv.code_set = 1950 and cv.active_ind = 1 
		and cv.cdf_meaning = "PURGE"
                and cv.code_value = batch_selection_cd                                          
                detail                                                                          
                        cdf_string = trim(cv.cdf_meaning)                                       
                        parm_string = trim(cv.definition)                                       
                        display = trim(cv.display)                                                
                with                                                                            
                nocounter                                                                       
                if (curqual = 0)                                                                
                        set reply->status_data->status = "Z"                                    
                        go to exit_script                                                           
                endif                                                                           
            endif                                                                               

            ;* Locate the individual parameters in parm_string                                  
            ;* and put them in the ops_params array.                                            
            set ptr = 1                                                                         
            set start_ptr = 1                                                                   
            set param_idx = 1                                                                   
            for (param_idx = 1 TO 5)                                                            
               set ptr = findstring(",", parm_string, start_ptr)                                
               if (ptr < 1)                                                                     
                  set ptr = 100                                                                 
               endif                                                                            
               set parm_len = ptr - start_ptr                                                   
               set ops_params->qual[param_idx].param =                                          
                 trim(substring(start_ptr, value(parm_len), parm_string), 3)                    
               set start_ptr = ptr + 1                                                          
            endfor                                                                              

            ;* Use array of ops parameters to set request fields.                               
            set request->beg_nbr_days = cnvtint(ops_params->qual[1].param)                       
            set request->end_nbr_days = cnvtint(ops_params->qual[2].param)                       
            set request->purge_commit_ind = cnvtint(ops_params->qual[3].param)              
            set request->print_list_flag = cnvtint(ops_params->qual[4].param)                    
            set request->print_count_flag = cnvtint(ops_params->qual[5].param)                    
            set request->printer_name = request->output_dist 

         endif                                                                                  

;001 End New Code

      /***********************************************************************
      * Subroutine - Status update                                           *
      ***********************************************************************/
;001 Start New Code
      ;pass_status = the delete that had the problem (result, perform_result, etc.)
      ;pass_id = either the result_id or the order_id with the problem
      ;pass_index = the index of the encounter that had the problem
      ;this is filled out if there was a error with the purge

;001 End New Code
       subroutine purge_status( pass_status, pass_id, pass_index )
         if (purge->encntrs[pass_index].purge_flag = 0)
           set purge->encntrs[pass_index].purge_flag = pass_status          
           set purge->encntrs[pass_index].problem_id = pass_id
         endif
       end

      /***********************************************************************
      * Subroutine - Stat Count                                              *
      ***********************************************************************/
       declare stat_count( pass_tab, pass_count ) = i4
       subroutine stat_count( pass_tab, pass_count )
         if (request->print_count_flag = 1)
           case (pass_tab)
             of lt_tab:
               set del_lt_cnt = del_lt_cnt + pass_count
             of rc_tab:
               set del_rc_cnt = del_rc_cnt + pass_count
             of ic_tab:
               set del_ic_cnt = del_ic_cnt + pass_count
             of re_tab:
               set del_re_cnt = del_re_cnt + pass_count
             of pr_tab:
               set del_pr_cnt = del_pr_cnt + pass_count
             of r_tab:
               set del_r_cnt = del_r_cnt + pass_count
             of osrc_tab:
               set del_osrc_cnt = del_osrc_cnt + pass_count
             of ocr_tab:
               set del_ocr_cnt = del_ocr_cnt + pass_count
             of pc_tab:
               set del_pc_cnt = del_pc_cnt + pass_count
             of ol_tab:
               set del_ol_cnt = del_ol_cnt + pass_count
             of ope_tab:
               set del_ope_cnt = del_ope_cnt + pass_count
             of aor_tab:
               set del_aor_cnt = del_aor_cnt + pass_count
           endcase
         endif
       end

      /***********************************************************************
      * Subroutine - Delete long_text                                        *
      ***********************************************************************/
       ;nbr_items = number of rows to delete
       ;type_ind = 0-textuals, 1-comments
       declare delete_longtext_rows( nbr_items, type_ind ) = i4      
       subroutine delete_longtext_rows( nbr_items, type_ind )
         set status_ind = 1
         set long_text_id = 0.0
         for (t = 1 to nbr_items)
           if (type_ind = 0) 
              set long_text_id = 
                    purge->encntrs[e].orders[o].results[r].textuals[t].long_text_id
           else
              set long_text_id = 
                    purge->encntrs[e].orders[o].results[r].comments[t].long_text_id
           endif
;purge long text rows
           delete from long_text lt
           where lt.long_text_id = long_text_id
           with nocounter

           call stat_count( lt_tab, curqual )

           if (curqual = 0)
call echo(build("problem deleting long_text_id: ", long_text_id))
             set status_ind = 0             
             call purge_status( lt_tab, long_text_id, e )
           endif
         endfor
         return(status_ind)
       end

      /***********************************************************************
      * Subroutine - Delete result_comment, included_components,             *
      *                     result_event, perform_result, result             *
      ***********************************************************************/
       declare delete_result( arg_result_id ) = i4
       subroutine delete_result( arg_result_id )

         set status_ind = 1

call echo(build("Working on ResultID: ", arg_result_id))
;purge result_comment
         delete from result_comment rc_d
           where rc_d.result_id = arg_result_id
         with
           nocounter
         call stat_count( rc_tab, curqual )

;purge included_components
         delete from included_components ic_d
           where ic_d.result_id = arg_result_id
         with
           nocounter
         call stat_count( ic_tab, curqual )

;purge result_event
         delete from result_event re_d
           where re_d.result_id = arg_result_id
         with
           nocounter
         call stat_count( re_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting RE result_id: ", arg_result_id))
           set status_ind = 0
           call purge_status( re_tab, arg_result_id, e )
         endif

;purge perform_result
         delete from perform_result pr_d
           where pr_d.result_id = arg_result_id
         with
           nocounter
         call stat_count( pr_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting PR result_id: ", arg_result_id))
           set status_ind = 0
           call purge_status( pr_tab, arg_result_id, e )
         endif

;purge result
         delete from result r_d
           where r_d.result_id = arg_result_id
         with
           nocounter
         call stat_count( r_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting RESULT result_id: ", arg_result_id))
           set status_ind = 0
           call purge_status( r_tab, arg_result_id, e )
         endif
         return(status_ind)
       end

      /***********************************************************************
      * Subroutine - Delete order_serv_res_container,                        *
      *                     order_container_r, pending_collection,           *
      *                     order_laboratory, order_procedure_exception,     *
      *                     accession_order_r                                *
      ***********************************************************************/
       declare delete_order( arg_order_id ) = i4
       subroutine delete_order( arg_order_id )
         set status_ind = 1
call echo(build("Working on OrderID: ", arg_order_id))

;purge order_serv_res_container
         delete from order_serv_res_container osrc_d
           where osrc_d.order_id = arg_order_id
         with
           nocounter
         call stat_count( osrc_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting OSRC order_id: ", arg_order_id))
           set status_ind = 0
           call purge_status( osrc_tab, arg_order_id, e )
         endif

;purge order_container_r
         delete from order_container_r oc_d
           where oc_d.order_id = arg_order_id
         with
           nocounter
         call stat_count( ocr_tab, curqual )

;purge pending_collection
         delete from pending_collection pc_d
           where pc_d.order_id = arg_order_id
         with
           nocounter
         call stat_count( pc_tab, curqual )

;purge order_laboratory
         delete from order_laboratory ol_d
           where ol_d.order_id = arg_order_id
         with
           nocounter
         set purge->encntrs[e].num_orders = purge->encntrs[e].num_orders + curqual
         call stat_count( ol_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting OL order_id: ", arg_order_id))
           set status_ind = 0
           call purge_status( ol_tab, arg_order_id, e )
         endif

;purge order_procedure_exception
         delete from order_procedure_exception ope_d
           where ope_d.order_id = arg_order_id
         with
           nocounter
         call stat_count( ope_tab, curqual )

;purge accession_order_r
         delete from accession_order_r ao_d
           where ao_d.order_id = arg_order_id
         with
           nocounter
         call stat_count( aor_tab, curqual )
         if (curqual = 0)
call echo(build("problem deleting AOR order_id: ", arg_order_id))
           set status_ind = 0
           call purge_status( aor_tab, arg_order_id, e )
         endif

         return(status_ind)
       end

      /***********************************************************************
      * Select rows to purge                                                 *
      ***********************************************************************/
     #Script 
      /***********************************************************************
      * Load result status code sets                                         *
      ***********************************************************************/

      declare gen_lab_activity_cd    = f8

      set ACTIVITY_CODESET           = 106
      set GEN_LAB_ACTIVITY_CDF       = "GLB"

      set stat = uar_Get_meaning_by_codeset(ACTIVITY_CODESET, GEN_LAB_ACTIVITY_CDF,
                                1, gen_lab_activity_cd)
            
            
      /***********************************************************************
      * Load date/time to purge                                              *
      ***********************************************************************/

      set temp->end_dt_tm = cnvtdatetime(concat(format(curdate-(value(request->beg_nbr_days)),"dd-mmm-yyyy;;d")," 23:59:59"))
      set temp->beg_dt_tm = cnvtdatetime(concat(format(curdate-(value(request->end_nbr_days)),"dd-mmm-yyyy;;d")," 00:00"))
      set BeginDate = format(temp->beg_dt_tm, "@SHORTDATETIME;;Q")
      set EndDate = format(temp->end_dt_tm, "@SHORTDATETIME;;Q")
call echo(build("begin: ", format(temp->beg_dt_tm, "@LONGDATETIME")))
call echo(build("end: ", format(temp->end_dt_tm, "@LONGDATETIME")))
      /*****7******************************************************************
      * Select Purge information                                             *
      ***********************************************************************/

call echo("43")

      select into "nl:"
        e.encntr_id,
        o.order_id,
	aor.order_id,
        d1.seq,
        r.result_id,
        pr.perform_result_id,
        result_exists = decode(r.seq, "Y", "N"),
        d2.seq,
        comment_exists = decode(rc.seq, "Y", "N"),
        rc.result_id
      from
        encounter e,
        orders o,
	accession_order_r aor,
        dummyt d1,
        result r, 
        perform_result pr,       ;001
        dummyt d2,		 ;001
        result_comment rc        ;001 
      plan e
        where e.disch_dt_tm >= cnvtdatetime(temp->beg_dt_tm) and
              e.disch_dt_tm <= cnvtdatetime(temp->end_dt_tm)
;        where e.disch_dt_tm between cnvtdatetime(temp->beg_dt_tm) 
;		and cnvtdatetime(temp->end_dt_tm)
      join o
        where e.encntr_id = o.encntr_id and 
              o.activity_type_cd+0 = gen_lab_activity_cd
      join aor
        where aor.order_id = o.order_id                       ;join here to qualify things out that have already been deleted
      join d1
        where d1.seq = 1
      join r
        where r.order_id = o.order_id            
      join pr                                               ;001
        where pr.result_id = r.result_id                    ;001
      join d2                                               ;001
        where d2.seq = 1                                    ;001
      join rc                                               ;001 
        where rc.result_id = r.result_id                    ;001
      order        
        e.encntr_id,
        o.order_id,
        r.result_id,
        pr.perform_result_id,
        rc.result_id
      head report
        e_cnt = 0
      head e.encntr_id
        e_cnt = e_cnt + 1
        if (mod(e_cnt, 50) = 1)
          stat = alterlist(purge->encntrs, e_cnt + 50)
        endif
        purge->encntrs[e_cnt].encntr_id = e.encntr_id
        purge->encntrs[e_cnt].num_orders = 0
        o_cnt = 0
      head o.order_id
        o_cnt = o_cnt + 1
        if (mod(o_cnt, 10) = 1)
          stat = alterlist(purge->encntrs[e_cnt]->orders, o_cnt + 10)
        endif
        purge->encntrs[e_cnt].orders[o_cnt].order_id = o.order_id
        r_cnt = 0
      head r.result_id
        if (result_exists = "Y")
          r_cnt = r_cnt + 1
          if (mod(r_cnt,10) = 1)
            stat = alterlist(purge->encntrs[e_cnt]->orders[o_cnt]->results, r_cnt + 10)
          endif
          purge->encntrs[e_cnt].orders[o_cnt].results[r_cnt].result_id = r.result_id
          interp_cnt = 0
          rc_cnt = 0
          prev_comment_result_id = 0.0
        endif
      head pr.perform_result_id
        if ((result_exists = "Y") and (pr.long_text_id > 0) and (r_cnt > 0))
          interp_cnt = interp_cnt + 1
          if (mod(interp_cnt,10) = 1)
            stat = alterlist(purge->encntrs[e_cnt]->
                                  orders[o_cnt]->results[r_cnt]->textuals, interp_cnt + 10)
          endif
          purge->encntrs[e_cnt].orders[o_cnt].results[r_cnt].textuals[interp_cnt].long_text_id = pr.long_text_id
        endif         
      head rc.result_id
        if ((comment_exists = "Y") and (r_cnt > 0) 
        and (prev_comment_result_id != rc.result_id) 
        and (rc.long_text_id > 0))
          rc_cnt = rc_cnt + 1
          if (mod(rc_cnt,10) = 1)
            stat = alterlist(purge->encntrs[e_cnt]->orders[o_cnt]->results[r_cnt]->comments, rc_cnt + 10)
          endif
          purge->encntrs[e_cnt].orders[o_cnt].results[r_cnt].comments[rc_cnt].long_text_id = rc.long_text_id
          prev_comment_result_id = rc.result_id
        endif
      DETAIL
        ROW +0           
      foot rc.result_id
         ROW +0
      foot pr.perform_result_id
         ROW +0
      foot r.result_id
        if (result_exists = "Y")
         stat = alterlist(purge->encntrs[e_cnt].orders[o_cnt].results[r_cnt].textuals, interp_cnt) 
        endif
        if ((result_exists = "Y") and (comment_exists = "Y") and (r_cnt > 0))
            stat = alterlist(purge->encntrs[e_cnt].orders[o_cnt].results[r_cnt].comments, rc_cnt)                 
        endif

      foot o.order_id
        if (r_cnt > 0)
         stat = alterlist(purge->encntrs[e_cnt].orders[o_cnt].results, r_cnt)
        endif

      foot e.encntr_id
         stat = alterlist(purge->encntrs[e_cnt].orders, o_cnt)

      foot report
         stat = alterlist(purge->encntrs, e_cnt)
call echo("made it to the end of the select")

      with
        nocounter,
        outerjoin = d1,
        dontcare = r,
        dontcare = pr,
        outerjoin = d2,
        dontcare = rc

;001 Start New Code
call echo(build("num encounters found: ", e_cnt))

      if (e_cnt = 0)                                                   ;if no encounters were found, stop
        set reply->status_data->subeventstatus[1]->operationname = 
           "select"
        set reply->status_data->subeventstatus[1]->operationstatus = 
           "Z"
        set reply->status_data->subeventstatus[1]->targetobjectname = 
           "encounters"
        set reply->status_data->subeventstatus[1]->targetObjectValue = 
           "nothing to purge"
        set reply->status_data->status = "Z"
        go to exit_script
      endif


      for (e = 1 to e_cnt)                                             ;loop through the encounters retrieve
        if (purge->encntrs[e].purge_flag = 0)                          ;if this has had a error with deleting, do nothing
          set purge_success = 1                                        ;flag to see if to commit or rollback          
          set o_cnt = size(purge->encntrs[e].orders, 5)
          for (o = 1 to o_cnt)                                       ;loop through this accession's orders 
              set r_cnt = size(purge->encntrs[e].orders[o].results, 5) 
              for (r = 1 to r_cnt)                                     ;loop through this order's results, if exist
                  set interp_cnt = size(purge->encntrs[e].orders[o].results[r].textuals, 5) 
	          if (interp_cnt > 0 )                                 ;check if for textuals
                     if (delete_longtext_rows( interp_cnt, 0 ) = 0)    ;if found delete long_text rows 
                        set purge_success = 0
                     endif
                  endif
                  set rc_cnt = size(purge->encntrs[e].orders[o].results[r].comments, 5) 
                  if (rc_cnt > 0 )                                     ;check if for result comments
                     if (delete_longtext_rows( rc_cnt, 1 ) = 0)        ;if found delete long_text rows
                        set purge_success = 0
                     endif
                  endif
                  if (delete_result(purge->encntrs[e].orders[o].results[r].result_id) = 0)      ;delete results
                    set purge_success = 0
                  endif
              endfor                                                   ;endfor for results loop (r)
              
              if (delete_order( (purge->encntrs[e].orders[o].order_id) ) = 0)                    ;delete the order
                 set purge_success = 0
              endif              
          endfor                                                     ;endfor for orders loop (o)
          if (purge_success = 0 or request->purge_commit_ind = 0)      ;if user doesn't want to commit or one of the 
            rollback                                                   ;deletes was unsuccessful, rollback
          else                                                         
            commit                                                     ;else commit changes to database
          endif
        endif                                                          ;endif from checking the purge flag at the beginning
      endfor                                                           ;endfor for encounters loop (e)               

;001 End New Code
    
      /***********************************************************************
      * Display rows purged                                                  *
      ***********************************************************************/
      set FootReport = 0                      ;001
call echo("44")
      select into trim(request->printer_name)
        d1.seq,
        e.encntr_id,
        e.person_id,
        p.person_id,
        p.name_full_formatted
      from
        (dummyt d1 with seq = value(e_cnt)),
        encounter e,
        person p
      plan d1
      join e
        where e.encntr_id = purge->encntrs[d1.seq].encntr_id
      join p
        where p.person_id = e.person_id
      order
        p.name_last_key,
        p.name_first_key
      head page
/*001        call center("General Laboratory Activity Deletion", 0, 125)
        col 0, "REPORT:  GLB_GET_PURGE_CHK.PRG"
        col 109, "DATE:"
        col + 1, nowdate
        row + 1
        col 0, "DIRECTORY:"
        col 109, "TIME:"
        col + 1, nowtime
        row + 1
        col 109, "PAGE:"
        col + 1, curpage "####;l;i"
        row + 1
        col 4, "Name"
        row + 1
        col 4, "--------------------------------------------------------------------------------------------------------------"
001 */
        col 0 I18N_Captions->ReportNo                     ;001
        call center(I18N_Captions->GenLabHead, 0, 125)    ;001
        col 109 I18N_Captions->ReportDate                 ;001
        col + 1, curdate                                  ;001 
        row + 1                                           ;001
        COL 0 I18N_Captions->DateFrom                     ;001
        COL 12  BeginDate                                 ;001
        col 109 I18N_Captions->RepTime                    ;001
        col + 1, curtime                                  ;001
        row + 1                                           ;001
        COL 0  I18N_Captions->DateTo                      ;001
        COL 12  EndDate                                   ;001
        col 109 I18N_Captions->pageNum                    ;001
        col + 1, curpage "####;l;i"                       ;001
        row +1                                            ;001
        Col 0 I18N_Captions->BatchSelect                  ;001
        col +1 display                                    ;001
        if (FootReport = 0 and request->print_list_flag = 1)       ;001
           row + 2                                        ;001
           col 18 I18N_Captions->Name                     ;001
           col 42 I18N_Captions->PersonID                 ;001
           col 57 I18N_Captions->EncounterID              ;001
           col 77 I18N_Captions->DischDtTm                ;001
           col 107 I18N_Captions->NumOrders                ;001
           row + 1                                        ;001
           col 4, "---------------------------------"     ;001
           col 40, "-------------"                        ;001
           col 55, "----------------"                     ;001
           col 75, "-------------------------"                ;001
           col 105, "---------------------"                ;001
        endif                                             ;001
      detail
        if (purge->encntrs[d1.seq]->purge_flag = 0) 
            del_encounter_nbr = del_encounter_nbr + 1
        endif
        if (request->print_list_flag = 1)
          if ((row + 5) > maxrow) 
              BREAK
          endif
          row + 1
	  name = substring(1, 35, p.name_full_formatted)
          col 4, name
          col 36 p.person_id                                       ;001
          col 53 e.encntr_id                                       ;001
          DisDtTm = format(e.disch_dt_tm, "@SHORTDATETIME;;Q")     ;001
          col 77 DisDtTm                                           ;001
          col 107 purge->encntrs[d1.seq].num_orders                 ;001
          if (purge->encntrs[d1.seq]->purge_flag > 0) 
            col 1, I18N_Captions->astk
            row + 1
            col 0, purge->encntrs[d1.seq]->problem_id
            case (purge->encntrs[d1.seq]->purge_flag)
              of lt_tab:
                col + 1, I18N_Captions->LTINFO                                             ;001
              of re_tab:
                col + 1, I18N_Captions->ReInfo                                             ;001
              of pr_tab:
                col + 1, I18N_Captions->PRInfo                                             ;001
              of r_tab:
                col + 1, I18N_Captions->RInfo                                             ;001
              of osrc_tab:
                col + 1, I18N_Captions->OSRCInfo                                             ;001
              of ol_tab:
                col + 1, I18N_Captions->OLInfo                                             ;001
              of aor_tab:
                col + 1, I18N_Captions->AORInfo                                             ;001
            endcase
          endif
	endif
      foot report
        if (request->print_count_flag = 1)               ;if user has choosen to show the delete counts 
;NOTE: THE MEG COUNT INCLUDES ROWS FROM ENCOUNTERS THAT MAY HAVE BEEN ROLLED BACK
          FootReport = 1
          if ((row + 20) > maxrow)
              BREAK
          endif
          row + 2
          col 0, I18N_Captions->DeleteSummary                                             ;001

          row + 1
          col 10, I18N_Captions->TableName                                             ;001
          col 47, I18N_Captions->Rows                                             ;001
          col 74, I18N_Captions->MEGS                                             ;001

          row + 1
          col 2, "--------------------------"
          col 42, "--------------"
          col 69, "-------------------"

          row + 1
          meg_cnt = del_aor_cnt * 141
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "accession_order_r"
          col 47, del_aor_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_ope_cnt * 190
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "order_procedure_exception"
          col 47, del_ope_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_ol_cnt * 81
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "order_laboratory"
          col 47, del_ol_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_pc_cnt * 155
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "pending_collection"
          col 47, del_pc_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_ocr_cnt * 129
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "order_container_r"
          col 47, del_ocr_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_osrc_cnt * 233
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "order_serv_res_container"
          col 47, del_osrc_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_r_cnt * 191
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "result"
          col 47, del_r_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_pr_cnt * 282
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "perform_result"
          col 47, del_pr_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_re_cnt * 144
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "result_event"
          col 47, del_re_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_rc_cnt * 136
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "result_comment"
          col 47, del_rc_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_ic_cnt * 187
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "included_components"
          col 47, del_ic_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 1
          meg_cnt = del_lt_cnt * 532
          meg_cnt = meg_cnt / 1000
          meg_tot_cnt = meg_tot_cnt + meg_cnt
          col 2, "long_text"
          col 47, del_lt_cnt "########;l;i"
          col 72, meg_cnt "######.###;r"

          row + 2
;001          col 5, "Estimated total meg retreived from delete:  "
          col 0, I18N_Captions->TotMegs                                             ;001
          col 47, meg_tot_cnt "###############.###;l"

          row + 1
;001          col 5, "Estimated total meg retreived from delete:  "
          col 0, I18N_Captions->TotEncounters                                             ;001
          col 47, del_encounter_nbr "###################;l;i"
        endif

        row + 2                                                                                   ;001
        call center(I18N_Captions->EndoReport, 0, 125)  ;001

      with
        nocounter

      set reply->status_data->status = "S"

#EXIT_SCRIPT
end
go

;Generated by GNU enscript 1.6.4.
