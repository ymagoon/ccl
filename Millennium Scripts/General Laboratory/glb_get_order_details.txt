 ;;Solution_Test/script/PathNet -- Gen Lab/glb_get_order_details/glb_get_order_details.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1998 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/

/*****************************************************************************

        Source file name:       glb_get_order_details.prg
        Object name:            glb_get_order_details
        Request #:              250068

        Product:                General Lab                     
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Retrieve assay and result information for
                                given order_id.  If the entire_accession_ind
                                has a value of 1, all related order_id for
                                the accession will be returned.
                                
        Tables read:            accession_order_r
                                code_value
                                container
                                data_map
                                discrete_task_assay
                                long_text
                                orders
                                perform_result
                                profile_task_r
                                prsnl
                                result
                                result_comment
                                result_event

        Tables updated:         none
        Executing from:

        Special Notes:          none
******************************************************************************/
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;     000 03/15/96 Hal Patchen          Initial Release                     *
;    *001 08/08/97 Hal Patchen          Add Feasible/Linear Ranges          *
;    *002 09/29/97 Hal Patchen          Add drawn date/time                 *
;    *003 10/02/97 Hal Patchen          Return interpretive data            *
;    *004 10/27/97 Hal Patchen          Add check for accession primary_flag*
;    *005 11/12/97 Hal Patchen          Add subsection level data map check *
;    *006 02/12/98 Hal Patchen          Fix data map's across orderables    *
;    *007 05/05/98 Hal Patchen          Verify subsection level data map    *
;    *                                  is associated with route test site  *
;    *008 08/23/99 Hal Patchen          Return catalog_type_cd and          *
;    *                                  activity_type_cd                    *
;    *009 04/26/00 Gary Runde           Return perf dt/tm on performs       *
;    *010 02/02/02 Nirmal Sanganee      OuterJoin on reference_range_factor *
;    *011 01/16/05 Matt Schile          Added sci_notation_ind to reply     *
;    *012 04/25/06 Matt Schile          Reworked units_cd for prompt tests  *
;    *013 09/25/06 Rahul Patel          Added event username, result codeset*
;    *                                  and activity type display to reply &*
;    *                                  changed request to accept order_id list*
;    *014 08/14/07 Vibhor Mathur		Removed joining of Data_map table by*
;    *									specific service_resource_cd        *
;	 *015 07/04/08 Rahul Deshmukh       Added nomenclature_id to reply      *	
;    *016 03/04/10 Kiran Vankadaru      Split the query to increase the performance*	
;~DE~************************************************************************
;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

             drop program GLB_GET_ORDER_DETAILS:dba go
             create program GLB_GET_ORDER_DETAILS:dba

      /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
      /*
      record request
      (
         1  orders[*]
		    2 order_id = f8
         1  order_id = f8
         1  entire_accession_ind         = i2
      )
      */

      /***********************************************************************
      * Reply Record                                                         *
      ***********************************************************************/
      record reply
      ( 
         1  qual[*]
            2  order_id                  = f8
            2  catalog_cd                = f8
            2  order_mnemonic            = vc
            2  catalog_type_cd           = f8                          ;008
            2  activity_type_cd          = f8                          ;008
            2  activity_type_disp        = c40  ;013
            2  activity_type_mean        = c12  ;013
            2  assays_cnt                = i4
            2  assays[*]
               3  task_assay_cd          = f8
               3  mnemonic               = vc
               3  sequence               = i4
               3  pending_ind            = i2
               3  result_ind             = i2
               3  result_id              = f8
               3  service_resource_cd    = f8
               3  service_resource_disp  = c40
               3  drawn_dt_tm            = dq8                         ;002
               3  result_status_cd       = f8
               3  result_status_disp     = c40
               3  result_status_mean     = c12
               3  result_type_cd         = f8
               3  result_type_disp       = c40
               3  result_type_mean       = c12
               3  result_value_dt_tm     = dq8
               3  result_value_numeric   = f8
               3  numeric_raw_value      = f8
               3  less_great_flag        = i2
               3  result_value_alpha     = vc
               3  long_text_id           = f8
               3  rtf_text               = vc
               3  ascii_text             = vc
               3  event_dt_tm            = dq8
               3  event_personnel_id     = f8
               3  event_name_full_formatted = vc
               3  event_username         = vc   ;013
               3  perform_dt_tm          = dq8
               3  perform_personnel_id   = f8
               3  name_full_formatted    = vc
               3  normal_cd              = f8
               3  normal_disp            = c40
               3  normal_mean            = c12
               3  critical_cd            = f8
               3  critical_disp          = c40
               3  critical_mean          = c12
               3  review_cd              = f8
               3  review_disp            = c40
               3  review_mean            = c12
               3  linear_cd              = f8                          ;001
               3  linear_disp            = c40                         ;001
               3  linear_mean            = c12                         ;001
               3  feasible_cd            = f8                          ;001
               3  feasible_disp          = c40                         ;001
               3  feasible_mean          = c12                         ;001
               3  delta_cd               = f8
               3  delta_disp             = c40
               3  delta_mean             = c12
               3  normal_range_flag      = i2  ;1 = Low, 2 = High, 3 = Both
               3  normal_low             = f8
               3  normal_high            = f8
               3  normal_alpha           = vc
               3  units_cd               = f8
               3  units_disp             = c40
               3  dilution_factor        = f8                          ;001
               3  data_map_ind           = i2
               3  max_digits             = i4
               3  min_digits             = i4
               3  min_decimal_places     = i4
               3  result_comment_ind     = i2
               3  interp_data_id         = f8                          ;003
               3  interp_data_text       = vc                          ;003
               3  qc_override_cd         = f8
               3  qc_override_disp       = c40
               3  qc_override_mean       = c12
               3  sci_notation_ind       = i2
               3  assay_type_flag        = i2  ; 0 = normal assay, 1 = prompt assay
               3  notify_cd              = f8
               3  notify_disp            = vc
               3  notify_mean            = c12
               3  result_code_set_cd     = f8   ;013
               3  result_code_set_disp   = c40  ;013
               3  nomenclature_id        = f8
%i cclsource:status_block.inc
      )
      
      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
      #Script
;007         set CV_REQUIRED_RECS            = 3
;009         set CV_REQUIRED_RECS            = 4                       ;007
         set COMMENT_TYPE_CODESET        = 14
         set RESULT_COMMENT_CDF          = "RES COMMENT" ;chartable
         set RESULT_NOTE_CDF             = "RES NOTE"    ;non-chartable
         set ORDER_STATUS_CODESET        = 6004
         set ORDER_STATUS_CANCELED_CDF   = "CANCELED"
         set DATA_MAP_TYPE_FLAG          = 0
         set SERV_RES_TYPE_CODESET       = 223                         ;007
         set SUBSECTION_CDF              = "SUBSECTION"                ;005
         declare serv_res_subsection_cd  = f8                          ;007
         declare result_comment_cd       = f8
         declare result_note_cd          = f8
         declare order_status_canceled_cd = f8
         declare q_cnt                   = i4
         declare a_cnt                   = i4
         declare max_a_cnt               = i4                          ;003
         declare qidx                    = i4                          ;003
         declare aidx                    = i4                          ;003
         declare stat                    = i4
         declare units_found    = i2 with protect, noconstant(0)
         declare lIndex = i4 with protect, noconstant(0)  ;013
         
         
         declare result_status_performed_cd = f8                       ;009
         set RESULT_STATUS_CODESET       = 1901                        ;009
         set RESULT_STATUS_PERFORMED_CDF = "PERFORMED"                 ;009
         
         set reply->status_data.status = "F"
         set q_cnt = 0
         set max_a_cnt = 0                                             ;003

      /***********************************************************************
      * Load result type and result status code sets                         *
      ***********************************************************************/
         
         set result_comment_cd = uar_get_code_by("MEANING", COMMENT_TYPE_CODESET, NullTerm(RESULT_COMMENT_CDF))
         set result_note_cd = uar_get_code_by("MEANING", COMMENT_TYPE_CODESET, NullTerm(RESULT_NOTE_CDF))
         set serv_res_subsection_cd = uar_get_code_by("MEANING", SERV_RES_TYPE_CODESET, NullTerm(SUBSECTION_CDF))
         set result_status_performed_cd = uar_get_code_by("MEANING", RESULT_STATUS_CODESET, NullTerm(RESULT_STATUS_PERFORMED_CDF))
         set order_status_canceled_cd = uar_get_code_by("MEANING", ORDER_STATUS_CODESET, NullTerm(ORDER_STATUS_CANCELED_CDF))
         
         ;* Verify that all required code value records were read.
         if (result_comment_cd <= 0.0 or 
         	result_note_cd <= 0.0 or 
         	serv_res_subsection_cd <= 0.0 or 
         	result_status_performed_cd <= 0.0 or 
         	order_status_canceled_cd <= 0.0)
         	go to Exit_Script
         endif

          /* make sure that if an order was given in request->order_id, add it to the request->orders list
             so that all selects can utilize just the request->orders list */
         if(request->order_id > 0.0)    ;013
           set lIndex = locateval(lIndex, 1, size(request->orders, 5), request->order_id, 
                                  request->orders[lIndex].order_id)
           if (lIndex = 0)
             /* it is not in the list, so add it */
             set lIndex = size(request->orders, 5) + 1
             set stat = alterlist(request->orders, lIndex)
             set request->orders[lIndex].order_id = request->order_id
           endif
         endif

      /***********************************************************************
      * Determine if all related orderable procedures for the accession      *
      * relating to the order_id passed should be returned (ind = 1).        *
      * Otherwise, load only the ordered procedure specified by the order_id *
      * passed (ind = 0)                                                     *
      ***********************************************************************/
         if (request->entire_accession_ind = 1)
            ;* Load all orderables for the accession
            select into "nl:"
               aor1.order_id,
               aor1.accession,
               aor2.accession,
               aor2.order_id,
               o.order_id,
               o.catalog_cd,
               o.order_mnemonic

            from
               accession_order_r aor1,
               accession_order_r aor2,
               orders o

            plan aor1 where expand(lIndex, 1, size(request->orders, 5), aor1.order_id, request->orders[lIndex].order_id)	;013
                        and aor1.primary_flag = 0                      ;004
            join aor2 where aor2.accession = aor1.accession
            join o    where o.order_id = aor2.order_id
                        and o.order_status_cd != order_status_canceled_cd
           
            head report
               q_cnt = 0

            detail
               q_cnt = q_cnt + 1
               if (mod(q_cnt,10) = 1)
                  stat = alterlist(reply->qual, q_cnt + 10)
               endif
               reply->qual[q_cnt].order_id = o.order_id
               reply->qual[q_cnt].catalog_cd = o.catalog_cd
               reply->qual[q_cnt].order_mnemonic = o.order_mnemonic
               reply->qual[q_cnt].catalog_type_cd = o.catalog_type_cd  ;008
               reply->qual[q_cnt].activity_type_cd =                   ;008
                 o.activity_type_cd                                    ;008
               reply->qual[q_cnt].assays_cnt = 0

            foot report
               stat = alterlist(reply->qual, q_cnt)
            
            with nocounter

         else

            ;* Load the specific ordered procedure based on the order_id
            select into "nl:"
               o.order_id,
               o.catalog_cd,
               o.order_mnemonic

            from
               orders o

            plan o where expand(lIndex, 1, size(request->orders, 5), o.order_id, request->orders[lIndex].order_id)	;013
                     and o.order_status_cd != order_status_canceled_cd

            head report
               q_cnt = 0

            detail
               q_cnt = q_cnt + 1
               if (mod(q_cnt,10) = 1)	;013
                  stat = alterlist(reply->qual, q_cnt + 10)
               endif
               reply->qual[q_cnt].order_id = o.order_id
               reply->qual[q_cnt].catalog_cd = o.catalog_cd
               reply->qual[q_cnt].order_mnemonic = o.order_mnemonic
               reply->qual[q_cnt].assays_cnt = 0
           
            foot report	;013
               stat = alterlist(reply->qual, q_cnt)

            with nocounter
         endif

         if (q_cnt = 0)
            set reply->status_data.status = "Z"   ;Zero qualified
            go to Exit_Script
         endif

         select into "nl:"
            d.seq,
            result_yn = decode(r.seq,"Y","N"),
            ptr.sequence,
            ptr.pending_ind,
            dta.task_assay_cd,
            r.seq,
            pr.seq,
            normal_low_null = nullind(pr.normal_low),
            normal_high_null = nullind(pr.normal_high),
            p.seq,
            lt.seq,
            re.event_sequence,
            p_re.seq,
            rc_exists = decode(rc.seq, "Y", "N"),
            d4.seq,
            rc.seq
         from
            (dummyt d with seq = value(q_cnt)),
            profile_task_r ptr,
            discrete_task_assay dta,
            dummyt d1,            
            result r,
            perform_result pr,
            prsnl p,
            long_text lt,
            container c,
            result_event re,
            prsnl p_re,
            dummyt d4,
            result_comment rc
         plan    d
         join    ptr where ptr.catalog_cd = reply->qual[d.seq].catalog_cd
         join    dta where dta.task_assay_cd = ptr.task_assay_cd
         join    d1  where d1.seq = 1
         join    r   where r.order_id = reply->qual[d.seq].order_id
                       and r.task_assay_cd = dta.task_assay_cd
         join    pr  where pr.result_id = r.result_id 
                       and pr.result_status_cd = r.result_status_cd
         join    p   where p.person_id = pr.perform_personnel_id
         join    lt  where lt.long_text_id = pr.long_text_id
         join    c   where c.container_id = pr.container_id
         join    re  where re.result_id = pr.result_id
                       and re.perform_result_id = pr.perform_result_id
         join    p_re where p_re.person_id = re.event_personnel_id
         join    d4  where d4.seq = 1
         join    rc  where rc.result_id = r.result_id
                       and rc.comment_type_cd in (result_comment_cd,
                                                  result_note_cd)
                                                         
       ; We don't have ORDER BY because it will cause unix error exceeding 32892.
         head report
            cnt = 0,
            a_cnt = 0,
            event_seq = 0

         head d.seq
            cnt = d.seq,
            a_cnt = 0

         head dta.task_assay_cd
            if ((dta.active_ind = 1) or (result_yn = "Y"))
              event_seq = -1
              a_cnt = a_cnt + 1
              if (mod(a_cnt,10) = 1)
                 stat = alterlist(reply->qual[cnt].assays, a_cnt + 10)
              endif
              if (a_cnt > max_a_cnt)                                     ;003
                 max_a_cnt = a_cnt                                       ;003
              endif                                                      ;003
              reply->qual[cnt].assays_cnt = a_cnt
              reply->qual[cnt].assays[a_cnt].task_assay_cd = dta.task_assay_cd  
              reply->qual[cnt].assays[a_cnt].mnemonic = dta.mnemonic
              reply->qual[cnt].assays[a_cnt].sequence = ptr.sequence
              reply->qual[cnt].assays[a_cnt].pending_ind = ptr.pending_ind
              reply->qual[cnt].assays[a_cnt].sci_notation_ind = dta.sci_notation_ind
              reply->qual[cnt].assays[a_cnt].assay_type_flag = ptr.item_type_flag
              ;* Set defaults
              reply->qual[cnt].assays[a_cnt].result_ind = 0
              reply->qual[cnt].assays[a_cnt].result_comment_ind = 0
              reply->qual[cnt].assays[a_cnt].interp_data_id = 0.0        ;003
            endif
         detail 
            if ((dta.active_ind = 1) or (result_yn = "Y"))
              if (result_yn = "Y"
              and ((reply->qual[cnt].assays[a_cnt].result_ind = 0)
                or (reply->qual[cnt].assays[a_cnt].result_ind = 1
                  and re.event_sequence > event_seq)))
                 event_seq = re.event_sequence
                 reply->qual[cnt].assays[a_cnt].result_ind = 1  
                 reply->qual[cnt].assays[a_cnt].result_id = 
                   r.result_id
                 reply->qual[cnt].assays[a_cnt].service_resource_cd = 
                   pr.service_resource_cd
                 if (c.container_id > 0.0)                               ;002
                    reply->qual[cnt].assays[a_cnt].drawn_dt_tm =         ;002
                      c.drawn_dt_tm                                      ;002
                 endif                                                   ;002
                 reply->qual[cnt].assays[a_cnt].result_status_cd = 
                   r.result_status_cd
                 reply->qual[cnt].assays[a_cnt].result_type_cd = 
                   pr.result_type_cd
                 reply->qual[cnt].assays[a_cnt].result_value_dt_tm = 
                   pr.result_value_dt_tm
                 reply->qual[cnt].assays[a_cnt].result_value_numeric = 
                   pr.result_value_numeric
                 reply->qual[cnt].assays[a_cnt].numeric_raw_value = 
                   pr.numeric_raw_value
                 reply->qual[cnt].assays[a_cnt].less_great_flag = 
                   pr.less_great_flag
                 reply->qual[cnt].assays[a_cnt].result_value_alpha = 
                   pr.result_value_alpha
                 if (pr.long_text_id > 0.0)
                    reply->qual[cnt].assays[a_cnt].rtf_text = 
                      lt.long_text
                 endif
                    reply->qual[cnt].assays[a_cnt].nomenclature_id = 
                    pr.nomenclature_id   
                    reply->qual[cnt].assays[a_cnt].long_text_id = 
                    pr.long_text_id
                 reply->qual[cnt].assays[a_cnt].ascii_text = 
                   pr.ascii_text
  
                 if (r.result_status_cd = result_status_performed_cd)                ;009
                     reply->qual[cnt].assays[a_cnt].event_dt_tm =                    ;009
                       pr.perform_dt_tm                                              ;009
                 else                                                                ;009
                     reply->qual[cnt].assays[a_cnt].event_dt_tm = 
                       re.event_dt_tm
                 endif                                                               ;009
                 reply->qual[cnt].assays[a_cnt].event_personnel_id = 
                   re.event_personnel_id
                 if (re.event_personnel_id > 0.0)
                    reply->qual[cnt].assays[a_cnt].event_name_full_formatted = 
                      p_re.name_full_formatted
                    reply->qual[cnt].assays[a_cnt].event_username = p_re.username    ;013
                 endif
                 reply->qual[cnt].assays[a_cnt].perform_dt_tm = 
                   pr.perform_dt_tm
                 reply->qual[cnt].assays[a_cnt].perform_personnel_id =
                   pr.perform_personnel_id
                 if (pr.perform_personnel_id > 0.0)
                    reply->qual[cnt].assays[a_cnt].name_full_formatted = 
                      p.name_full_formatted
                 endif
                 reply->qual[cnt].assays[a_cnt].normal_cd = 
                   pr.normal_cd
                 reply->qual[cnt].assays[a_cnt].critical_cd = 
                   pr.critical_cd
                 reply->qual[cnt].assays[a_cnt].review_cd = 
                   pr.review_cd
                 reply->qual[cnt].assays[a_cnt].linear_cd =              ;001
                   pr.linear_cd                                          ;001
                 reply->qual[cnt].assays[a_cnt].feasible_cd =            ;001
                   pr.feasible_cd                                        ;001
                 reply->qual[cnt].assays[a_cnt].delta_cd = 
                   pr.delta_cd
                 reply->qual[cnt].assays[a_cnt].notify_cd =
                   pr.notify_cd
                 reply->qual[cnt].assays[a_cnt].result_code_set_cd = pr.result_code_set_cd  ;013
                 if (normal_low_null = 0 
                 and normal_high_null = 1)
                    ;* Normal low only exists
                    reply->qual[cnt].assays[a_cnt].normal_range_flag = 1
                 elseif (normal_low_null = 1 
                     and normal_high_null = 0)
                    ;* Normal high only exists
                    reply->qual[cnt].assays[a_cnt].normal_range_flag = 2
                 elseif (normal_low_null = 0
                     and normal_high_null = 0)
                    ;* Both normal low and high exists
                    reply->qual[cnt].assays[a_cnt].normal_range_flag = 3
                 else
                    reply->qual[cnt].assays[a_cnt].normal_range_flag = 0
                 endif
                 reply->qual[cnt].assays[a_cnt].normal_low = 
                   pr.normal_low
                 reply->qual[cnt].assays[a_cnt].normal_high = 
                   pr.normal_high
                 reply->qual[cnt].assays[a_cnt].normal_alpha = 
                   pr.normal_alpha
                
                 ; if the assay is a prompt and the result was entered during order entry, set the assay_type_flag to 1
                 ; else use the units from the perform_result table and set the assay_type_flag to 0
                 if(ptr.item_type_flag = 1 and pr.units_cd = 0.0 and pr.reference_range_factor_id = 0.0)
                   reply->qual[cnt].assays[a_cnt].units_cd = 0.0
                   reply->qual[cnt].assays[a_cnt].assay_type_flag = 1
                 else
                   reply->qual[cnt].assays[a_cnt].units_cd = pr.units_cd
                   reply->qual[cnt].assays[a_cnt].assay_type_flag = 0
                 endif
              endif
              reply->qual[cnt].assays[a_cnt].dilution_factor =        ;001
                pr.dilution_factor                                    ;001
              reply->qual[cnt].assays[a_cnt].interp_data_id =         ;003
                pr.interp_data_id                                     ;003
              reply->qual[cnt].assays[a_cnt].data_map_ind = 0         ;005
              reply->qual[cnt].assays[a_cnt].max_digits = 0           ;005
              reply->qual[cnt].assays[a_cnt].min_digits = 0           ;005
              reply->qual[cnt].assays[a_cnt].min_decimal_places = 0   ;005
              reply->qual[cnt].assays[a_cnt].qc_override_cd =  pr.qc_override_cd
              if (rc_exists = "Y")
                reply->qual[cnt].assays[a_cnt].result_comment_ind = 1
              else
                reply->qual[cnt].assays[a_cnt].result_comment_ind = 0
              endif
            endif
         foot dta.task_assay_cd
            row+0

         foot d.seq
            stat = alterlist(reply->qual[cnt].assays, a_cnt)
         with 
            nocounter,
            outerjoin = d1,
        		dontcare = rc,            
            outerjoin = d4,
   
            maxqual(rc,1)
            
      /***********************************************************************
      * Load data maps                                                       *
      ***********************************************************************/
         select into "nl:"                                             ;005
            d1.seq,                                                    ;005
            d2.seq,                                                    ;005
            rg_exists = evaluate(nullind(rg.seq), 1, "N", "Y"),
            rg.seq                                                     ;007
         from                                                          ;005
            (dummyt d1 with seq = value(q_cnt)),                       ;005
            (dummyt d2 with seq = value(max_a_cnt)),                   ;005
            reference_range_factor rrf,                                ;007
            resource_group rg                                          ;007
         plan d1  where d1.seq <= q_cnt                                ;005
         join d2  where d2.seq <= reply->qual[d1.seq].assays_cnt       ;005
         join rrf where rrf.task_assay_cd = reply->qual[d1.seq].assays[d2.seq].task_assay_cd
                    and rrf.active_ind = 1
                    and rrf.beg_effective_dt_tm <= cnvtdatetime(curdate,curtime3)
                    and rrf.end_effective_dt_tm >= cnvtdatetime(curdate,curtime3)
         join rg  where rg.parent_service_resource_cd = outerjoin(rrf.service_resource_cd)
                    and rg.child_service_resource_cd = outerjoin(reply->qual[d1.seq].assays[d2.seq].service_resource_cd)
                    and rg.resource_group_type_cd = outerjoin(serv_res_subsection_cd)
                    and rg.beg_effective_dt_tm <= outerjoin(cnvtdatetime(curdate,curtime3))
                    and rg.end_effective_dt_tm >= outerjoin(cnvtdatetime(curdate,curtime3))
                    and rg.root_service_resource_cd = outerjoin(0.0)
         head d2.seq                                                   ;005
            units_found  = 0
         detail                                                        ;005
            cnt = d1.seq                                               ;005
            a_cnt = d2.seq                                             ;005
            ;* When determining the units_cd by service resource,
            ;* Use the units_cd at the testing site level if it
            ;* exits, otherwise use the exits_cd at the testing
            ;* site group level if it exists.
            if(reply->qual[cnt].assays[a_cnt].assay_type_flag = 1)
               if (rrf.service_resource_cd > 0.0)
                  ;* If service resource passed in is a testing site
                  ;* or a testing site group, use the units_cd
                  ;* when an identical match is found.
                  if (rrf.service_resource_cd = reply->qual[cnt].assays[a_cnt].service_resource_cd)
                     reply->qual[cnt].assays[a_cnt].units_cd = rrf.units_cd
                     units_found = 1
                  endif
                  ;* If service resource passed in is a testing site and
                  ;* belongs to a ts group, attempt to use the units_cd
                  ;* for the testing site group if one exists.
                  if (rg_exists = "Y" and rrf.service_resource_cd = rg.parent_service_resource_cd and units_found = 0)
                     reply->qual[cnt].assays[a_cnt].units_cd = rrf.units_cd
                     units_found = 1
                  endif
               elseif(rrf.service_resource_cd = 0.0 and units_found = 0)
                  ;* All service resources.
                  reply->qual[cnt].assays[a_cnt].units_cd = rrf.units_cd
               endif
            endif
         with nocounter

         select into "nl:"                                             ;005
            d1.seq,                                                    ;005
            d2.seq,                                                    ;005
            dm_exists = evaluate(nullind(dm.seq), 1, "N", "Y"),
            dm.seq,                                                    ;005
            rg_exists = evaluate(nullind(rg.seq), 1, "N", "Y"),
            rg.seq                                                     ;007
         from                                                          ;005
            (dummyt d1 with seq = value(q_cnt)),                       ;005
            (dummyt d2 with seq = value(max_a_cnt)),                   ;005
            data_map dm,                                               ;005
            resource_group rg                                          ;007
         plan d1  where d1.seq <= q_cnt                                ;005
         join d2  where d2.seq <= reply->qual[d1.seq].assays_cnt       ;005
         join dm  where dm.task_assay_cd = outerjoin(reply->qual[d1.seq].assays[d2.seq].task_assay_cd)
                    and dm.data_map_type_flag = outerjoin(DATA_MAP_TYPE_FLAG)     ;005
                    and dm.active_ind = outerjoin(1)                              ;005
                    and dm.beg_effective_dt_tm <= outerjoin(cnvtdatetime(curdate,curtime3))
                    and dm.end_effective_dt_tm >= outerjoin(cnvtdatetime(curdate,curtime3))
         join rg  where rg.parent_service_resource_cd = outerjoin(dm.service_resource_cd)
                    and rg.child_service_resource_cd = outerjoin(reply->qual[d1.seq].assays[d2.seq].service_resource_cd)
                    and rg.resource_group_type_cd = outerjoin(serv_res_subsection_cd)
                    and rg.beg_effective_dt_tm <= outerjoin(cnvtdatetime(curdate,curtime3))
                    and rg.end_effective_dt_tm >= outerjoin(cnvtdatetime(curdate,curtime3))
                    and rg.root_service_resource_cd = outerjoin(0.0)
         head report                                                   ;005
            data_map_level = 0                                         ;005
                                                                       ;005
         head d1.seq                                                   ;006
            data_map_level = 0                                         ;006
         head d2.seq                                                   ;005
            data_map_level = 0                                         ;005
         detail                                                        ;005
            cnt = d1.seq                                               ;005
            a_cnt = d2.seq                                             ;005
            
            if(dm_exists = "Y")
              ;* Check for exact match on data map                       ;005
              if (data_map_level <= 2                                    ;005
              and dm.service_resource_cd > 0.0                           ;005
              and dm.service_resource_cd =                               ;005
                    reply->qual[cnt].assays[a_cnt].service_resource_cd)  ;005
                 data_map_level = 3                                      ;005
                 reply->qual[cnt].assays[a_cnt].data_map_ind = 1         ;005
                 reply->qual[cnt].assays[a_cnt].max_digits =             ;005
                   dm.max_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_digits =             ;005
                   dm.min_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_decimal_places =     ;005
                   dm.min_decimal_places                                 ;005
              endif                                                      ;005
              ;* Check for subsection level data map                     ;005
              if (data_map_level <= 1                                    ;005
              and dm.service_resource_cd > 0.0                           ;005
              and rg_exists = "Y"                                        ;007
              and rg.parent_service_resource_cd = dm.service_resource_cd ;007
              and rg.child_service_resource_cd =                         ;007
                    reply->qual[cnt].assays[a_cnt].service_resource_cd)  ;007
                 data_map_level = 2                                      ;005
                 reply->qual[cnt].assays[a_cnt].data_map_ind = 1         ;005
                 reply->qual[cnt].assays[a_cnt].max_digits =             ;005
                   dm.max_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_digits =             ;005
                   dm.min_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_decimal_places =     ;005
                   dm.min_decimal_places                                 ;005
              endif                                                      ;005
              ;* Check for default all resources level data map          ;005
              if (data_map_level = 0 and dm.service_resource_cd = 0.0)            
                 data_map_level = 1                                      ;005
                 reply->qual[cnt].assays[a_cnt].data_map_ind = 1         ;005
                 reply->qual[cnt].assays[a_cnt].max_digits =             ;005
                   dm.max_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_digits =             ;005
                   dm.min_digits                                         ;005
                 reply->qual[cnt].assays[a_cnt].min_decimal_places =     ;005
                   dm.min_decimal_places                                 ;005
              endif                                                      ;005
            endif
         with nocounter


      /***********************************************************************
      * Load interpretive data if necessary                                  *
      ***********************************************************************/
         if (q_cnt > 0 and max_a_cnt > 0)                              ;003
            for (qidx = 1 to q_cnt)                                    ;003
               set a_cnt = reply->qual[qidx].assays_cnt                ;003
               if (a_cnt > 0)                                          ;003
                  for (aidx = 1 to a_cnt)                              ;003
                     if (reply->qual[qidx].assays[aidx].interp_data_id > 0.0) ;003
                        select into "nl:"                              ;003
                           id.interp_data_id,                          ;003
                           lt.long_text_id                             ;003
                        from                                           ;003
                           interp_data id,                             ;003
                           long_text lt                                ;003
                        plan id                                        ;003
                          where id.interp_data_id = reply->qual[qidx]  ;003
                                .assays[aidx].interp_data_id           ;003
                        join lt                                        ;003
                          where lt.long_text_id = id.long_text_id      ;003
                        detail                                         ;003
                           reply->qual[qidx].assays[aidx]              ;003
                             .interp_data_text = lt.long_text          ;003
                        with nocounter                                 ;003
                     endif                                             ;003
                  endfor                                               ;003
               endif                                                   ;003
            endfor                                                     ;003
         endif                                                         ;003

         if (q_cnt > 0)
            set reply->status_data.status = "S"   ;Successful
         else
            set reply->status_data.status = "Z"   ;Zero qualified
         endif

      #Exit_Script        
         end
         go      

;Generated by GNU enscript 1.6.4.
