 ;;Solution_Test/script/PathNet -- Gen Lab/glb_rpt_worklist/glb_rpt_worklist.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-2000 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/
/*****************************************************************************
 
        Source file name:       glb_rpt_worklist.prg
        Object name:            glb_rpt_worklist
        Request #:              250197
 
        Product:                General Lab
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0
 
        Program purpose:        Print a worklist or worksheet.
 
        Tables read:            assay_processing_r
                                assay_resource_lot
                                code_value
                                container
                                data_map
                                encntr_alias
                                encntr_info
                                encounter
                                long_text
                                orders
                                order_comment
                                order_procedure_exception
                                order_serv_res_container
                                perform_result
                                person
                                person_info
                                profile_task_r
                                prsnl
                                resource_group
                                result
                                result_comment
                                result_event
                                worklist_group
                                worklist_ref
                                [Call to GLB_GET_WKLST_REF]
                                worklist_ref
                                worklist
                                [Call to GLB_GET_WKLST_REF_DETAILS]
                                accession,
                                worklist_ref_priority,
                                worklist_ref_procedure,
                                worklist_ref_qc
                                [Call to GLB_GET_ELIG_ALL]
                                accession_order_r
                                code_value
                                encntr_alias
                                orders
                                order_laboratory
                                order_procedure_exception
                                order_serv_res_container
                                pending_collection
                                person
                                profile_task_r
                                resource_group
                                worklist
                                worklist_order_r
                                worklist_ref
                                [Call to GLB_GET_WKLST_QC_ACCNS]
                                accession
                                code_value
                                control_lot
                                control_material
                                resource_accession_r
                                resource_group
                                resource_lot_r
                                worklist_ref_qc
 
        Tables updated:         [Call to GLB_ADD_WKLST_ELE]
                                worklist
                                worklist_elements
                                worklist_order_r
                                worklist_accession_r
 
        Executing from:         Worklist Request or Operations
 
        Special Notes:          This script can be run from a client app
                                or from Operations.  If running from
                                Operations, the request->batch_selection
                                should contain the description associated
                                with a given set of worklist operation
                                parameters from code set 1950.
 
*****************************************************************************/
/*~DB~************************************************************************
      *                      GENERATED MODIFICATION CONTROL LOG              *
      ************************************************************************
      *                                                                      *
      *Mod Date     Engineer             Comment                             *
      *--- -------- -------------------- ----------------------------------- *
      *000 03/22/00 Hal Patchen          Initial Release                     *
      *001 12/02/02 Nirmal Sanganee      Extra Join on Profile_Task_Assay    *
      *002 07/07/04 Craig Sumrall        Added logic to ignore inactive mrn  *
      *003 05/09/05 Catherine Boeding    Removed extra join from 12/02/02    *
      *004 01/25/06 Matt Schile          Made changes for Helix scientific   *
      *                                  notation                            *
      *005 01/19/07 Paul Lessin          Get printer name from output dest   *
      *006 02/07/07 Paul Lessin          Update Reply250184 and req250183    *
      *007 02/23/07 Abraham Areguy       Made changes for                    *
      *                                  GLB: Worklist Sequence Project      *
      *008 03/16/07 Paul Lessin          Get 250083 req/reply from inc file  *
      *009 02/25/07 David Fifer          Added print preview logic.          *
      *010 03/08/07 Mark Brooks          Changes for showing pending only    *
      *011 04/23/07 Paul Lessin          Get req/reply250183 from inc files  *
      *012 04/17/08 Oliver Barbara       Added code to handle client_alias   *
      *013 07/28/08 Rahul Deshmukh       Added functionality to print interp *
      *                                  text                                *
      *014 08/15/08 Rahul Deshmukh       Fixed defect for horizontal worklist*
      *                                  print                               *
      *015 09/08/08 Matt Hlavaty         qualify oragnization_alias on       *
      *                                  active_ind                          *
      *016 11/10/08 Jason Osborn         Correct issue w/printing interp text*
      *017 11/19/08 Jason Osborn         Correct syntax error                *
      *018 12/02/08 Oliver Barbara       Added sort by service resource logic*
      *019 03/16/09 Jason Osborn         Correct QC issue with print groups. *
      *020 08/13/10 Sharada K            Fix for CR# 1-4082871767            *
      *021 04/04/11 Ryan Manuel          Display pending date/time for auto  *
      *                                  worklists                           *
      *022 05/02/11 Manikandan T	 Fix for CR# 1-4788731285 	     *
      *023 09/19/11 Pradeep Reddy	 Fix for CR# 1-4147298761 	     *
  ~DE~************************************************************************
 
~END~ ******************  END OF ALL MODCONTROL BLOCKS  *********************/
 
      drop program GLB_RPT_WORKLIST:dba go
      create program GLB_RPT_WORKLIST:dba
 
      /***********************************************************************
      * Internationalization                                                 *
      ***********************************************************************/
      ;* i18n include file
%i cclsource:i18n_uar.inc
%i cclsource:pcs_format_age.inc
      ;* Initialize variable that keeps handle to i18n data
      set i18nHandle = 0
 
      ;* Call uar_i18nlocalizationinit
      set h = uar_i18nlocalizationinit(i18nHandle, curprog, "", curcclrev)
 
      record i18n_captions
      (
         1  rpt_report                 = vc
         1  rpt_report_desc            = vc
         1  rpt_name                   = vc
         1  rpt_id                     = vc
         1  rpt_test_site              = vc
         1  rpt_worklist               = vc
         1  rpt_worksheet              = vc
         1  rpt_date                   = vc
         1  rpt_time                   = vc
         1  rpt_by                     = vc
         1  rpt_page                   = vc
         1  rpt_cross_test_site        = vc
         1  accession                  = vc
         1  demographics               = vc
         1  location                   = vc
         1  collected                  = vc
         1  procedure                  = vc
         1  orderable_procedure        = vc
         1  result                     = vc
         1  tech                       = vc
         1  perf                       = vc
         1  verf                       = vc
         1  control                    = vc
         1  lot                        = vc
         1  dr                         = vc
         1  visit_reason               = vc
         1  person_comments            = vc
         1  person_notes               = vc
         1  encounter_comments         = vc
         1  encounter_notes            = vc
         1  order_comments             = vc
         1  order_notes                = vc
         1  result_comments            = vc
         1  result_notes               = vc
         1  text                       = vc
         1  repeats                    = vc
         1  abbrev_years               = vc
         1  abbrev_months              = vc
         1  abbrev_weeks               = vc
         1  abbrev_days                = vc
         1  abbrev_hours               = vc
         1  abbrev_minutes             = vc
         1  saved_when                 = vc
         1  saved_by                   = vc
         1  downloaded_when            = vc
         1  downloaded_by              = vc
         1  pending_only               = vc
         1  interp_text_flag           = vc
         1  qc_range                   = vc
         1  system                     = vc
      )
      declare LOCALE = vc with protect, noconstant( "" )
      set LOCALE = cnvtupper(logical("CCL_LANG"))
      if (LOCALE = "")
        set LOCALE = cnvtupper(logical("LANG"))
      endif
      set LOCALE = substring(1, 5, LOCALE)      
      declare localeObjectName = vc with protect, noconstant("EN_US")
      set i18n_captions->rpt_report = uar_i18ngetmessage(i18nHandle,
        "rpt_report", "REPORT:")
      set i18n_captions->rpt_report_desc =
        uar_i18ngetmessage(i18nHandle,
        "rpt_report_desc", "GLB_RPT_WORKLIST")
      set i18n_captions->rpt_name = uar_i18ngetmessage(i18nHandle,
        "rpt_name", "NAME:")
      set i18n_captions->rpt_id = uar_i18ngetmessage(i18nHandle,
        "rpt_id", "ID:")
      set i18n_captions->rpt_test_site = uar_i18ngetmessage(i18nHandle,
        "rpt_test_site", "TEST SITE:")
      set i18n_captions->rpt_worklist = uar_i18ngetmessage(i18nHandle,
        "rpt_worklist", "LABORATORY WORKLIST")
      set i18n_captions->rpt_worksheet = uar_i18ngetmessage(i18nHandle,
        "rpt_worksheet", "LABORATORY WORKSHEET")
      set i18n_captions->rpt_date = uar_i18ngetmessage(i18nHandle,
        "rpt_date", "DATE:")
      set i18n_captions->rpt_time = uar_i18ngetmessage(i18nHandle,
        "rpt_time", "TIME:")
      set i18n_captions->rpt_by = uar_i18ngetmessage(i18nHandle,
        "rpt_by", "BY:")
      set i18n_captions->rpt_page = uar_i18ngetmessage(i18nHandle,
        "rpt_page", "PAGE:")
      set i18n_captions->rpt_cross_test_site =
        uar_i18ngetmessage(i18nHandle,
        "rpt_cross_test_site", "CROSS TEST SITE")
      set i18n_captions->accession = uar_i18ngetmessage(i18nHandle,
        "accession", "ACCESSION")
      set i18n_captions->demographics = uar_i18ngetmessage(i18nHandle,
        "demographics", "DEMOGRAPHICS")
      set i18n_captions->location = uar_i18ngetmessage(i18nHandle,
        "location", "LOCATION")
      set i18n_captions->collected = uar_i18ngetmessage(i18nHandle,
        "collected", "COLLECTED")
      set i18n_captions->procedure = uar_i18ngetmessage(i18nHandle,
        "procedure", "PROCEDURE")
      set i18n_captions->orderable_procedure =
        uar_i18ngetmessage(i18nHandle,
        "orderable_procedure", "ORDERABLE PROCEDURE")
      set i18n_captions->result = uar_i18ngetmessage(i18nHandle,
        "result", "RESULT")
      set i18n_captions->tech = uar_i18ngetmessage(i18nHandle,
        "tech", "TECH")
      set i18n_captions->perf = uar_i18ngetmessage(i18nHandle,
        "perf", "PERF")
      set i18n_captions->verf = uar_i18ngetmessage(i18nHandle,
        "verf", "VERF")
      set i18n_captions->control = uar_i18ngetmessage(i18nHandle,
        "control", "CONTROL:")
      set i18n_captions->lot = uar_i18ngetmessage(i18nHandle,
        "lot", "LOT:")
      set i18n_captions->dr = uar_i18ngetmessage(i18nHandle,
        "dr", "DR:")
      set i18n_captions->visit_reason = uar_i18ngetmessage(i18nHandle,
        "visit_reason", "VISIT REASON:")
      set i18n_captions->person_comments =
        uar_i18ngetmessage(i18nHandle,
        "person_comments", "PATIENT COMMENTS:")
      set i18n_captions->person_notes =
        uar_i18ngetmessage(i18nHandle,
        "person_notes", "PATIENT NOTES:")
      set i18n_captions->encounter_comments =
        uar_i18ngetmessage(i18nHandle,
        "encounter_comments", "ENCOUNTER COMMENTS:")
      set i18n_captions->encounter_notes =
        uar_i18ngetmessage(i18nHandle,
        "encounter_notes", "ENCOUNTER NOTES:")
      set i18n_captions->order_comments =
        uar_i18ngetmessage(i18nHandle,
        "order_comments", "ORDER COMMENTS:")
      set i18n_captions->order_notes = uar_i18ngetmessage(i18nHandle,
        "order_notes", "ORDER NOTES:")
      set i18n_captions->result_comments =
        uar_i18ngetmessage(i18nHandle,
        "result_comments", "RESULT COMMENTS:")
      set i18n_captions->result_notes = uar_i18ngetmessage(i18nHandle,
        "result_notes", "RESULT NOTES:")
      set i18n_captions->text = uar_i18ngetmessage(i18nHandle,
        "text", "(Text)")
      set i18n_captions->repeats = uar_i18ngetmessage(i18nHandle,
        "repeats", "(r)")
      set i18n_captions->abbrev_years = uar_i18ngetmessage(i18nHandle,
        "abbrev_years", "YRS")
      set i18n_captions->abbrev_months = uar_i18ngetmessage(i18nHandle,
        "abbrev_months", "MOS")
      set i18n_captions->abbrev_weeks = uar_i18ngetmessage(i18nHandle,
        "abbrev_weeks", "WKS")
      set i18n_captions->abbrev_days = uar_i18ngetmessage(i18nHandle,
        "abbrev_days", "DYS")
      set i18n_captions->abbrev_hours = uar_i18ngetmessage(i18nHandle,
        "abbrev_hours", "HRS")
      set i18n_captions->abbrev_minutes = uar_i18ngetmessage(i18nHandle,
        "abbrev_minutes", "MINS")
      set i18n_captions->saved_when = uar_i18ngetmessage(i18nHandle,
        "saved_at", "Saved at:")
      set i18n_captions->saved_by = uar_i18ngetmessage(i18nHandle,
        "saved_by", "Saved by:")
      set i18n_captions->downloaded_when = uar_i18ngetmessage(i18nHandle,
        "down_at", "Downloaded at:")
      set i18n_captions->downloaded_by = uar_i18ngetmessage(i18nHandle,
        "down_by", "Downloaded by:")
      set i18n_captions->pending_only = uar_i18ngetmessage(i18nHandle,
        "pending_only", "(pending orders only)")
      set i18n_captions->interp_text_flag = uar_i18ngetmessage(i18nHandle,
        "interp_text_flag", "(t)")
      set i18n_captions->qc_range = uar_i18ngetmessage(i18nHandle, "qc_range", "EXPECTED RANGE:")
      set i18n_captions->system = uar_i18ngetmessage(i18nHandle, "SYSTEM", "SYSTEM")
 
;Include files to be able to dynamically create requests and replies
%i cclsource:pm_dynamic_query.inc
%i cclsource:pm_create_request.inc
 
      /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
      /*
      record request
      (
         1  worklist_ref_id            = f8
         1  worklist_ref_disp          = vc
         1  worklist_id                = f8
         1  worklist_alias             = vc
         1  service_resource_cd        = f8
         1  service_resource_disp      = vc
         1  parent_ind                 = i2
         1  group_cnt                  = i4
         1  group[*]
            2  child_worklist_ref_id   = f8
         1  procedure_inc_flag         = i2  ;0=All, 1=Group, 2=Detail
         1  include_flag               = i2  ;0=No QC, 1=QC Only, 2=Include QC
         1  report_format_ind          = i2  ;0=Vertical 1=Horizontal
         1  cumulative_ind             = i2
         1  in_lab_ind                 = i2
         1  person_comments_ind        = i2
         1  order_comments_ind         = i2
         1  result_comments_ind        = i2
         1  result_space_ind           = i2  ;0=Worklist 1=Worksheet
         1  previous_result_ind        = i2
         1  visit_reason_ind           = i2
         1  order_status_ind           = i2
         1  reporting_priority_ind     = i2
         1  facility_ind               = i2
         1  nurse_unit_ind             = i2
         1  cross_resource_ind         = i2
         1  look_ahead_hours           = i4
         1  priority_ind               = i2
         1  pending_only_ind           = i2
         1  qual_cnt                   = i4
         1  qual[*]
            2  accession_id            = f8
            2  order_id                = f8
            2  accession               = vc
            2  catalog_cd              = f8
            2  order_mne               = vc
            2  person_id               = f8
            2  name_full_formatted     = vc
            2  order_status_cd         = f8
            2  order_status_disp       = vc
            2  dept_status_cd          = f8
            2  dept_status_disp        = vc
            2  reporting_priority_cd   = f8
            2  reporting_priority_disp = vc
            2  control_id              = f8
            2  control_name            = vc
            2  lot_id                  = f8
            2  lot_number              = vc
            2  service_resource_cd     = f8  ;QC Accn serv resource
            2  sequence_ident          = c20
         1  procs_cnt                  = i4
         1  procs[*]
            2  procedure_cd            = f8
            2  procedure_disp          = vc
         1  priors_cnt                 = i4
         1  priors[*]
            2  priority_cd             = f8
            2  priority_disp           = vc
         1  printer                    = vc
         1  copies                     = i4
         1  spacing_ind                = i2  ;0=Single spaced 1=Double spaced
         1  landscape_ind              = i2
         1  blank_lines                = i4
         1  batch_selection            = vc  ;OPS worklist name/group name
         1  output_dist                = vc  ;OPS output device
         1  ops_date                   = dq8 ;OPS operations date
         1  fin_ind                    = i2
         1  race_ind                   = i2
         1  specimen_type_ind          = i2
         1  text_freetext_ind          = i2
         1  mrn_ind                    = i2
         1  age_ind                    = i2
         1  sex_ind                    = i2
         1  room_bed_ind               = i2
         1  collect_dt_tm_ind          = i2
         1  ordering_physician_ind     = i2
         1  output_dest_cd             = f8
         1  accn_seq_ind               = i2
         1  print_seq_left_ind         = i2
         1  print_preview_ind          = i2
         1  client_alias_ind           = i2
         1  interp_text_ind            = i2
         1  serv_res_sort_ind          = i2
         1  qc_ranges_ind              = i2
         1  filter_qc_assays_ind       = i2
      )
      */
 
      /***********************************************************************
      * Reply Record                                                         *
      ***********************************************************************/
      record reply
      (
        1 file_name = vc
%i cclsource:status_block.inc
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_REF Request 250183                                     *
      ***********************************************************************/
      record req250183
      (
%i cclsource:glb_get_wklst_ref_req.inc
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_REF Reply Record                                       *
      ***********************************************************************/
      record reply250183
      (
%i cclsource:glb_get_wklst_ref_rep.inc
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_REF_DETAILS Request 250184                             *
      ***********************************************************************/
      record req250184
      (
         1  worklist_ref_id            = f8
         1  worklist_id                = f8
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_REF_DETAILS Reply 250184                               *
      ***********************************************************************/
      record reply250184
      (
            1  procs_cnt               = i4
            1  procs[*]
               2  catalog_cd           = f8
               2  catalog_disp         = vc
               2  task_assay_cd        = f8
               2  task_assay_disp      = vc
            1  priorities_cnt          = i4
            1  priorities[*]
               2  priority_cd          = f8
               2  priority_disp        = vc
               2  priority_mean        = vc
            1  qc_cnt                  = i4
            1  qc[*]
               2  accession_id         = f8
               2  accession            = c20
               2  pos                  = i4
               2  begin_ind            = i2
               2  end_ind              = i2
               2  interval_ind         = i2
               2  interval             = i4
               2  short_description	   = vc
            1  pos_cnt                 = i4
            1  positions[*]
               2  numeric_position     = vc
               2  order_id             = f8
               2  accession_id         = f8
            1  ref_pos_cnt             = i4
            1  position_ref[*]
               2  numeric_position     = vc
               2  accession_id         = f8
               2  position_id          = f8
               2  accession            = vc
               2  short_description    = vc
               2  dilution_cd          = f8
               2  dilution_disp        = c40
               2  sequence_nbr         = i4
               2  position_disp        = vc
%i cclsource:status_block.inc
      )
 
      /***********************************************************************
      * GLB_GET_ELIG_ALL Request 250083                                      *
      ***********************************************************************/
      record req250083
      (
%i cclsource:glb_get_elig_all_req.inc
      )
 
      /***********************************************************************
      * GLB_GET_ELIG_ALL Reply 250083                                        *
      ***********************************************************************/
      record reply250083
      (
%i cclsource:glb_get_elig_all_rep.inc
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_QC_ACCNS Request 250102                                *
      ***********************************************************************/
      record req250102
      (
        1 worklist_ref_id = f8
        1 service_resource_cd = f8
        1 qc_accns [*]
          2 accession_id = f8
      )
 
      /***********************************************************************
      * GLB_GET_WKLST_QC_ACCNS Reply 250102                                        *
      ***********************************************************************/
      record reply250102
      (
         1  qual[*]
            2  accession                 = c20
            2  unformat_accn             = c20
            2  accession_id              = f8
            2  pos                       = i4
            2  begin_ind                 = i2
            2  end_ind                   = i2
            2  interval_ind              = i2
            2  interval                  = i4
            2  service_resource_cd       = f8
            2  service_resource_disp     = vc
            2  control_id                = f8
            2  control_name              = c20
            2  lot_id                    = f8
            2  lot_number                = vc
%i cclsource:status_block.inc
      )
 
      /***********************************************************************
      * GLB_ADD_WKLST_ELE Request 250085                                     *
      ***********************************************************************/
      record req250085
      (
          1 worklist_prsnl_id = f8
          1 status_cd = f8
          1 service_resource_cd = f8
          1 worklist_ref_id = f8
          1 worklist_type_flag = i2
          1 worklist_alias = c25
          1 components [*]
            2 catalog_cd = f8
            2 task_assay_cd = f8
            2 worklist_seq = i4
          1 orders [*]
            2 order_id = f8
            2 accession_id = f8
            2 sequence = i4
            2 sequence_ident = c20
            2 positions [*]
              3 position_id = f8
          1 template_ind = i2
          1 auto_assign_ind = i2
          1 seq_ident_ind          = i2 
          1 seq_ident_start_nbr    = i4    
          1 seq_ident_beg_range_nbr= i4
          1 seq_ident_end_range_nbr= i4
      )
 
      /***********************************************************************
      * GLB_ADD_WKLST_ELE Reply 250085                                       *
      ***********************************************************************/
      record reply250085
      (
         1  worklist_id                = f8
         1  worklist_alias             = vc
%i cclsource:status_block.inc
      )
 
      /***********************************************************************
      * Print Group Record                                                   *
      ***********************************************************************/
      record print_grp
      (
         1  group_cnt                  = i4
         1  group[*]
            2  child_worklist_ref_id   = f8
            2  ref_data_loaded_ind     = i2
      )
 
      /***********************************************************************
      * GLB_GET_DATA_MAP Request and Reply 250145                            *
      ***********************************************************************/
      call cr_createRequest(0, 250145, "req250145")
      record reply250145
      (
%i cclsource:glb_get_data_map_reply.inc
      ) with protect
 
      /***********************************************************************
      * GLB_GET_ASSAYS_BY_CAT_SERV_RES Request and Reply 250073              *
      ***********************************************************************/
      call cr_createRequest(0, 250073, "req250073")
      record reply250073
      (
%i cclsource:glb_get_assays_by_cat_serv_res_reply.inc
      ) with protect
 
      /***********************************************************************
      * Adjust orders list subroutine                                        *
      ***********************************************************************/
%i cclsource:aps_uar_rtf.inc   ;* For converting rtf to ascii
      declare adjust_orders_list( arg_o_cnt ) = i2
      subroutine adjust_orders_list( arg_o_cnt )
         declare nAdjustSortSeq = i2 with noconstant(0)
         
         set ocnt = 0
         ;*
         ;* Extend orders list
         ;*
         set ocnt = rpt->orders_cnt
         set ocnt = ocnt + 1
         set stat = alterlist(rpt->orders, ocnt)
         set rpt->orders_cnt = ocnt
         ;*
         ;* If new item is at end of the orders list,
         ;* no data needs to be moved.
         ;*
         if (arg_o_cnt >= rpt->orders_cnt)
            return(1)
         endif
         
         if (arg_o_cnt < nLastPatientOrder) ;If we are inserting before the last patient order, bump the stored value
            set nLastPatientOrder = nLastPatientOrder + 1
         endif
         
         ;Determine if we are splitting apart an accession by inserting QC.
         ;If so, we need to adjust the sort_seq accordingly.  If the first accession being moved is QC nAdjustSortSeq needs to = 0.
         if ((arg_o_cnt > rpt->orders[arg_o_cnt].accession_start_pos) and (rpt->orders[arg_o_cnt].order_id > 0.0))
            set nAdjustSortSeq = 1
         endif
         ;*
         ;* Move data down in orders list until the
         ;* new item position (i.e. arg_o_cnt) is reached.
         ;*
         set ocnt = rpt->orders_cnt - 1
         while (ocnt > (arg_o_cnt - 1))
            set rpt->orders[ocnt + 1].accession_id =
              rpt->orders[ocnt].accession_id
            set rpt->orders[ocnt + 1].order_id =
              rpt->orders[ocnt].order_id
            set rpt->orders[ocnt + 1].accession =
              rpt->orders[ocnt].accession
            set rpt->orders[ocnt + 1].catalog_cd =
              rpt->orders[ocnt].catalog_cd
            set rpt->orders[ocnt + 1].order_mne =
              rpt->orders[ocnt].order_mne
            set rpt->orders[ocnt + 1].person_id =
              rpt->orders[ocnt].person_id
            set rpt->orders[ocnt + 1].name_full_formatted =
              rpt->orders[ocnt].name_full_formatted
            set rpt->orders[ocnt + 1].order_status_cd =
              rpt->orders[ocnt].order_status_cd
            set rpt->orders[ocnt + 1].order_status_disp =
              rpt->orders[ocnt].order_status_disp
            set rpt->orders[ocnt + 1].dept_status_cd =
              rpt->orders[ocnt].dept_status_cd
            set rpt->orders[ocnt + 1].dept_status_disp =
              rpt->orders[ocnt].dept_status_disp
            set rpt->orders[ocnt + 1].reporting_priority_cd =
              rpt->orders[ocnt].reporting_priority_cd
            set rpt->orders[ocnt + 1].reporting_priority_disp =
              rpt->orders[ocnt].reporting_priority_disp
            set rpt->orders[ocnt + 1].control_id =
              rpt->orders[ocnt].control_id
            set rpt->orders[ocnt + 1].control_name =
              rpt->orders[ocnt].control_name
            set rpt->orders[ocnt + 1].lot_id =
              rpt->orders[ocnt].lot_id
            set rpt->orders[ocnt + 1].lot_number =
              rpt->orders[ocnt].lot_number
            set rpt->orders[ocnt + 1].service_resource_cd =
              rpt->orders[ocnt].service_resource_cd
            set rpt->orders[ocnt + 1].sequence_ident =
              rpt->orders[ocnt].sequence_ident
            set rpt->orders[ocnt + 1].client_alias =
              rpt->orders[ocnt].client_alias
           
            if (rpt->orders[ocnt].order_id > 0.0) ;If we are moving a patient accession
               if (nAdjustSortSeq = 1) ;If we need to adjust accession_sort_seq
                  set rpt->orders[ocnt + 1].accession_sort_seq = rpt->orders[ocnt].accession_sort_seq + 1
                  if (arg_o_cnt > rpt->orders[ocnt].accession_start_pos)
                     ;We are splitting apart an accession, start new accession_start_pos
                     set rpt->orders[ocnt + 1].accession_start_pos = arg_o_cnt + 1
                  else
                     ;We are NOT splitting apart an accession, just bump it once to account for the QC insertion.
                     set rpt->orders[ocnt + 1].accession_start_pos = rpt->orders[ocnt].accession_start_pos + 1
                  endif
               else ;Don't need to adjust accession_sort_seq, just increment accession_start_pos
                  set rpt->orders[ocnt + 1].accession_sort_seq = rpt->orders[ocnt].accession_sort_seq
                  set rpt->orders[ocnt + 1].accession_start_pos = rpt->orders[ocnt].accession_start_pos + 1
               endif
            endif

            ;*
            ;* Clear open array occurance.
            ;*
            set rpt->orders[ocnt].accession_id = 0.0
            set rpt->orders[ocnt].order_id = 0.0
            set rpt->orders[ocnt].accession = " "
            set rpt->orders[ocnt].catalog_cd = 0.0
            set rpt->orders[ocnt].order_mne = " "
            set rpt->orders[ocnt].person_id = 0.0
            set rpt->orders[ocnt].name_full_formatted = " "
            set rpt->orders[ocnt].order_status_cd = 0.0
            set rpt->orders[ocnt].order_status_disp = " "
            set rpt->orders[ocnt].dept_status_cd = 0.0
            set rpt->orders[ocnt].dept_status_disp = " "
            set rpt->orders[ocnt].reporting_priority_cd = 0.0
            set rpt->orders[ocnt].reporting_priority_disp = " "
            set rpt->orders[ocnt].control_id = 0.0
            set rpt->orders[ocnt].control_name = " "
            set rpt->orders[ocnt].lot_id = 0.0
            set rpt->orders[ocnt].lot_number = " "
            set rpt->orders[ocnt].service_resource_cd = 0.0
            set rpt->orders[ocnt].sequence_ident = " "
            set rpt->orders[ocnt].client_alias = " "
            set rpt->orders[ocnt].accession_sort_seq = 0
            set rpt->orders[ocnt].accession_start_pos = 0
            set ocnt = ocnt - 1
         endwhile
         return(1)
      end
 
      /***********************************************************************
      * Build Result Flags String Subroutine                                 *
      ***********************************************************************/
      ;* Build a string of result flags to follow a result on a report.
      ;* Prints only the 1st char of each result flag.
      ;* When calling this function, remember that the contents of the
      ;* display field for the 1902 codeset can be an empty string.
      ;* This routine will check to see whether the display flag = " ",
      ;* and if not, will look at the 1st character in the string.
      declare bldresultflagstr(fnorm, fcrit, frevw, flin, ffeas,
                               fdelta, fcomment, fnote, fcorr, fnotify, finterp) = vc
 
      subroutine bldresultflagstr(fnorm, fcrit, frevw, flin, ffeas,
                                  fdelta, fcomment, fnote, fcorr, fnotify, finterp)
 
         declare flagstr = vc with protect, noconstant(" ")
 
         ;* Add abnormal flag
         if (fnorm != " ")
            set flagstr = fnorm
         endif
 
         ;* Add critical flag
         if (fcrit != " ")
            set flagstr = concat(flagstr, fcrit)
         endif
 
         ;* Add review flag
         if (frevw != " ")
            set flagstr = concat(flagstr, frevw)
         endif
 
         ;* Add linear flag
         if (flin != " ")
            set flagstr = concat(flagstr, flin)
         endif
 
         ;* Add feasible flag
         if (ffeas != " ")
            set flagstr = concat(flagstr, ffeas)
         endif
 
         ;* Add delta flag
         if (fdelta != " ")
            set flagstr = concat(flagstr, fdelta)
         endif
 
         ;* Add corrected flag
         if (fcorr = "Y")
            set flagstr = concat(flagstr, "c")
         endif
 
         ; Add footnote flag
         if ((fcomment = "Y") or (fnote = "Y"))
            set flagstr = concat(flagstr, "f")
         endif
 
         ; Add notify flag
         if(fnotify != " ")
           set flagstr = concat(flagstr, fnotify)
         endif
 
         ;* Add interp flag
         if (finterp = 1)
            set flagstr = concat(flagstr, i18n_captions->interp_text_flag)
         endif
 
         return(flagstr)
      end
      /***********************************************************************
      * Get printer name subroutine                                          *
      ***********************************************************************/
 
      declare get_printer_name(output_dest_cd = f8) = vc with private
      subroutine get_printer_name(output_dest_cd)
        declare sPrinterName = vc with protect, noconstant(" ")
 
        select into "nl:"
            d.name
        from output_dest od,
             device d
        plan od
          where od.output_dest_cd = output_dest_cd
        join d
          where d.device_cd = od.device_cd
        detail
          sPrinterName = trim(d.name)
        with nocounter
 
        return(sPrinterName)
      end
 
      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
      #Script
         set reply->status_data.status     = "F"
         ;*
         ;* Code set variables
         ;*
         set COMMENT_TYPE_CODESET          = 14
         set COMMENT_TYPE_ORD_COMMENT_CDF  = "ORD COMMENT"
         set COMMENT_TYPE_ORD_NOTE_CDF     = "ORD NOTE"
         set COMMENT_TYPE_RES_COMMENT_CDF  = "RES COMMENT"
         set COMMENT_TYPE_RES_NOTE_CDF     = "RES NOTE"
         set SERV_RES_TYPE_CODESET         = 223
         set SERV_RES_INSTITUTION_CDF      = "INSTITUTION"
         set SERV_RES_DEPARTMENT_CDF       = "DEPARTMENT"
         set SERV_RES_SECTION_CDF          = "SECTION"
         set SERV_RES_SUBSECTION_CDF       = "SUBSECTION"
         set SERV_RES_INSTRUMENT_CDF       = "INSTRUMENT"
         set SERV_RES_BENCH_CDF            = "BENCH"
         set RESULT_TYPE_CODESET           = 289
         set RESULT_TYPE_TEXT_CDF          = "1"
         set RESULT_TYPE_ALPHA_CDF         = "2"
         set RESULT_TYPE_NUMERIC_CDF       = "3"
         set RESULT_TYPE_INTERP_CDF        = "4"
         set RESULT_TYPE_DATE_CDF          = "6"
         set RESULT_TYPE_FREETEXT_CDF      = "7"
         set RESULT_TYPE_CALC_CDF          = "8"
         set ENCNTR_ALIAS_TYPE_CODESET     = 319
         set ALIAS_TYPE_MRN_CDF            = "MRN"
         set ALIAS_TYPE_FIN_CDF            = "FIN NBR"
         declare alias_type_fin_cd = f8 with protect, noconstant(0.0)
         set INFO_TYPE_CODESET             = 355
         set INFO_TYPE_COMMENT_CDF         = "COMMENT"
         set INFO_TYPE_NOTE_CDF            = "NOTE"
         set RESULT_STATUS_CODESET         = 1901
         set RESULT_STATUS_PERFORMED_CDF   = "PERFORMED"
         set RESULT_STATUS_VERIFIED_CDF    = "VERIFIED"
         set RESULT_STATUS_AUTOVERIFIED_CDF = "AUTOVERIFIED"
         set RESULT_STATUS_CORRECTED_CDF   = "CORRECTED"
         set RESULT_PRCSS_CODESET          = 1902
         set RESULT_PRCSS_ALP_ABNORMAL_CDF = "ALP_ABNORMAL"
         set RESULT_PRCSS_ALP_CRITICAL_CDF = "ALP_CRITICAL"
         set RESULT_PRCSS_ALP_REVIEW_CDF   = "ALP_REVIEW"
         set RESULT_PRCSS_NORMAL_HIGH_CDF  = "NORMAL_HIGH"
         set RESULT_PRCSS_NORMAL_LOW_CDF   = "NORMAL_LOW"
         set RESULT_PRCSS_CRITICAL_CDF     = "CRITICAL"
         set RESULT_PRCSS_REVIEW_CDF       = "REVIEW"
         set RESULT_PRCSS_LINEAR_CDF       = "LINEAR"
         set RESULT_PRCSS_FEASIBLE_CDF     = "FEASIBLE"
         set RESULT_PRCSS_DELTA_FAIL_CDF   = "DELTA_FAIL"
         set GLB_OPS_PARAMS_CODESET        = 1950
         set GLB_OPS_PARAMS_WLR_CDF        = "WLR"
         set ORG_ALIAS_CODESET             = 334
         set ORG_ALIAS_CLIENT_CDF          = "CLIENT"
         set code_set = 0
         set meaning = fillstring(12, " ")
         set code_cnt = 1
 
         declare found_curr_text_ind       = i2 with protect, noconstant(0)
         declare found_prev_text_ind       = i2 with protect, noconstant(0)
 
         declare notify_cd                 = f8 with protect, noconstant(0.0)
         declare alp_notify_cd             = f8 with protect, noconstant(0.0)
         declare sPrinterName              = vc with protect, noconstant(" ")
         declare i                         = i4 with protect, noconstant(0)
         declare j                         = i4 with protect, noconstant(0)
         declare o_pos                     = i4 with protect, noconstant(0)
         declare a_pos                     = i4 with protect, noconstant(0)
 
            ; Variables used for the service resource sort option
         declare prev_accession            = vc with noconstant(" ")
         declare curr_accession_sort_seq   = i4 with noconstant(0)
         declare curr_accession_start_pos  = i4 with noconstant(0)
         declare nLastPatientOrder         = i4 with noconstant(0)
 
         ;*
         ;* Initialize variables.
         ;*
         set grp_nbr = 0
         set displaykey = fillstring(100, " ")
         set ops_worklist_ref_id = 0.0
         set o_cnt = 0
         set a_cnt = 0
         set r_cnt = 0
         set max_a_cnt = 0
         set max_r_cnt = 0
         set max_pc_cnt = 0
         set max_ec_cnt = 0
         set max_oc_cnt = 0
         set max_rc_cnt = 0
         set cnt = 0
         set q_cnt = 0
         set ptr = 0
         set idx = 0
         set interval_cnt = 0
         set arg_min_digits = 0
         set arg_max_digits = 0
         set arg_min_dec_places = 0
         set arg_less_great_flag = 0
         set arg_raw_value = 0.0
         set nbr_mins = 0.0
         set max_nbr_cols = 0
         set max_nbr_rows = 0
         set time_hrs = "  "
         set time_mins = "  "
         set serv_res_mean = fillstring(12, " ")
         set dilution_val = fillstring(6, " ")
         set username = fillstring(10, " ")
 
         record vctext
         (
            1  txt                     = vc
            1  rpt_title               = vc
         )
 
         record curr
         (
            1  system_dt_tm            = dq8
         )
         set curr->system_dt_tm = cnvtdatetime(curdate, curtime3)
 
         set modify = cnvtage(90, 0, 24)
 
      /***********************************************************************
      * Load Code Values                                                     *
      ***********************************************************************/
         ;*
         ;* Load Service Resource Types - Institution, Department, Section,
         ;* Subsection, Instrument, Bench code values.
         ;*
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_INSTITUTION_CDF
         set serv_res_institution_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_institution_cd)
 
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_DEPARTMENT_CDF
         set serv_res_department_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_department_cd)
 
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_SUBSECTION_CDF
         set serv_res_subsection_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_subsection_cd)
 
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_SECTION_CDF
         set serv_res_section_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_section_cd)
 
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_INSTRUMENT_CDF
         set serv_res_instrument_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_instrument_cd)
 
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_BENCH_CDF
         set serv_res_bench_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_bench_cd)
 
         ;*
         ;* Load Result Types - Text, Alpha, Numeric, Interpretation,
         ;* Date, Freetext, and Calculation code values.
         ;*
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_TEXT_CDF
         set result_type_text_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_text_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_ALPHA_CDF
         set result_type_alpha_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_alpha_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_NUMERIC_CDF
         set result_type_numeric_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_numeric_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_INTERP_CDF
         set result_type_interp_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_interp_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_DATE_CDF
         set result_type_date_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_date_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_FREETEXT_CDF
         set result_type_freetext_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_freetext_cd)
 
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_CALC_CDF
         set result_type_calc_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_calc_cd)
 
         ;*
         ;* Load Encounter Alias Type - Med Rec Nbr code value.
         ;*
         set code_set = ENCNTR_ALIAS_TYPE_CODESET
         set meaning = ALIAS_TYPE_MRN_CDF
         set alias_type_mrn_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, alias_type_mrn_cd)
 
         set meaning = ALIAS_TYPE_FIN_CDF
         set alias_type_fin_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, alias_type_fin_cd)
 
         ;*
         ;* Load Info Type Code - Comment and Note code values.
         ;*
         set code_set = INFO_TYPE_CODESET
         set meaning = INFO_TYPE_COMMENT_CDF
         set info_type_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, info_type_comment_cd)
 
         set code_set = INFO_TYPE_CODESET
         set meaning = INFO_TYPE_NOTE_CDF
         set info_type_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, info_type_note_cd)
 
         ;*
         ;* Load Comment Type - Order Comment, Order Note, Result Comment
         ;* Result Note code values.
         ;*
         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_ORD_COMMENT_CDF
         set comment_type_ord_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_ord_comment_cd)
 
         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_ORD_NOTE_CDF
         set comment_type_ord_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_ord_note_cd)
 
         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_RES_COMMENT_CDF
         set comment_type_res_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_res_comment_cd)
 
         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_RES_NOTE_CDF
         set comment_type_res_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_res_note_cd)
 
         ;*
         ;* Load Result Statuses - Performed, Verified, Auto-verified,
         ;* and corrected code values.
         ;*
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_PERFORMED_CDF
         set performed_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, performed_cd)
 
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_VERIFIED_CDF
         set verified_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, verified_cd)
 
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_AUTOVERIFIED_CDF
         set autoverified_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, autoverified_cd)
 
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_CORRECTED_CDF
         set corrected_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, corrected_cd)

         set code_set = ORG_ALIAS_CODESET
         set meaning = ORG_ALIAS_CLIENT_CDF
         set org_alias_client_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, org_alias_client_cd)
 
         set notify_cd = uar_get_code_by("MEANING", RESULT_PRCSS_CODESET, "NOTIFY")
         set alp_notify_cd = uar_get_code_by("MEANING", RESULT_PRCSS_CODESET, "ALP_NOTIFY")
 
         ;Execute accrtl_sci_note to define UAR_AccFormatResultStringSciNote
         execute accrtl_sci_note
 
      /***********************************************************************
      * Build Print Group when running from Operations                       *
      ***********************************************************************/
         if (trim(request->batch_selection) > " ")
            set displaykey =
              trim(cnvtupper(cnvtalphanum(request->batch_selection)))
            set ops_worklist_ref_id = 0.0
 
            select into "nl:"
               cv.code_value
            from
               code_value cv
            plan cv
              where cv.code_set = GLB_OPS_PARAMS_CODESET
                and cv.cdf_meaning = GLB_OPS_PARAMS_WLR_CDF
                and cv.display_key = displaykey
                and cv.active_ind = 1
            detail
               ops_worklist_ref_id = cnvtreal(trim(cv.definition))
            with
               nocounter
 
            if (curqual = 0)
               ;* Operation parameters not found
               set reply->status_data.subeventstatus[1]
                 .OperationName = "SELECT"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "CODE_VALUE"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue =
                 "Unable to load operation parameters."
               go to Exit_Script
            endif
 
            select into "nl:"
               wr.worklist_ref_id
              ,d.seq
              ,wg_exists = decode(wg.seq, "Y", "N")
              ,wg.child_worklist_ref_id
            from
               worklist_ref wr
              ,(dummyt d with seq = 1)
              ,worklist_group wg
            plan wr
              where wr.worklist_ref_id = ops_worklist_ref_id
                and wr.active_ind = 1
            join d
              where d.seq = 1
            join wg
              where wg.parent_worklist_ref_id = wr.worklist_ref_id
                and wg.active_ind = 1
                and wr.parent_ind = 1
            head report
               grp_nbr = 0
            detail
               grp_nbr = grp_nbr + 1
               stat = alterlist(print_grp->group, grp_nbr)
               print_grp->group_cnt = grp_nbr
               if (wg_exists = "Y")
                  print_grp->group[grp_nbr].child_worklist_ref_id =
                    wg.child_worklist_ref_id
               else
                  print_grp->group[grp_nbr].child_worklist_ref_id =
                    wr.worklist_ref_id
               endif
               print_grp->group[grp_nbr].ref_data_loaded_ind = 0
            with
               nocounter
              ,outerjoin = d
              ,dontcare = wg
 
            if (curqual = 0)
               set reply->status_data.status = "Z"
               go to Exit_Script
            endif
            set grp_nbr = 1
            go to Process_Worklist
         endif
 
      /***********************************************************************
      * Build Print Group when running from Client Application               *
      ***********************************************************************/
         if (request->parent_ind = 1)
            set print_grp->group_cnt = request->group_cnt
            set stat = alterlist(print_grp->group, request->group_cnt)
            for (grp_nbr = 1 to request->group_cnt)
               set print_grp->group[grp_nbr].child_worklist_ref_id =
                  request->group[grp_nbr].child_worklist_ref_id
               set print_grp->group[grp_nbr].ref_data_loaded_ind = 0
            endfor
         else
            set print_grp->group_cnt = 1
            set stat = alterlist(print_grp->group, 1)
            set print_grp->group[1].child_worklist_ref_id =
               request->worklist_ref_id
            set print_grp->group[grp_nbr].ref_data_loaded_ind = 1
         endif
 
      /***********************************************************************
      * Process Next Worklist in Group                                       *
      ***********************************************************************/
         set grp_nbr = 1
 
      #Process_Worklist
         set o_cnt = 0
         set a_cnt = 0
         set r_cnt = 0
         set max_a_cnt = 0
         set max_r_cnt = 0
         set max_pc_cnt = 0
         set max_ec_cnt = 0
         set max_oc_cnt = 0
         set max_rc_cnt = 0
         set cnt = 0
 
         free set rpt
         record rpt
         (
            1  worklist_ref_id         = f8
            1  worklist_ref_disp       = vc
            1  worklist_id             = f8
            1  worklist_alias          = vc
            1  service_resource_cd     = f8
            1  service_resource_disp   = vc
            1  parent_ind              = i2
            1  procedure_inc_flag      = i2  ;0=All, 1=Group, 2=Detail
            1  include_flag            = i2  ;0=No QC, 1=QC Only, 2=Include QC
            1  report_format_ind       = i2  ;0=Vertical 1=Horizontal
            1  cumulative_ind          = i2
            1  in_lab_ind              = i2
            1  person_comments_ind     = i2
            1  order_comments_ind      = i2
            1  result_comments_ind     = i2
            1  result_space_ind        = i2  ;0=Worklist 1=Worksheet
            1  previous_result_ind     = i2
            1  visit_reason_ind        = i2
            1  order_status_ind        = i2
            1  reporting_priority_ind  = i2
            1  facility_ind            = i2
            1  nurse_unit_ind          = i2
            1  cross_resource_ind      = i2
            1  look_ahead_hours        = i4
            1  priority_ind            = i2
            1  orders_cnt              = i4
            1  fin_ind                 = i2
            1  race_ind                = i2
            1  specimen_type_ind       = i2
            1  text_freetext_ind       = i2
            1  mrn_ind                 = i2
            1  age_ind                 = i2
            1  sex_ind                 = i2
            1  room_bed_ind            = i2
            1  collect_dt_tm_ind       = i2
            1  ordering_physician_ind  = i2
            1  client_alias_ind        = i2
            1  interp_text_ind         = i2
            1  serv_res_sort_ind       = i2
            1  orders[*]
               2  accession_id            = f8
               2  order_id                = f8
               2  accession               = vc
               2  catalog_cd              = f8
               2  order_mne               = vc
               2  resource_route_level_flag = i2
               2  person_id               = f8
               2  name_full_formatted     = vc
               2  encntr_id               = f8
               2  med_rec_nbr             = vc
               2  sex_cd                  = f8
               2  sex_disp                = vc
               2  age                     = vc
               2  location_cd             = f8
               2  location_mean           = vc
               2  facility_cd             = f8
               2  facility_disp           = vc
               2  nurse_unit_cd           = f8
               2  nurse_unit_disp         = vc
               2  room_cd                 = f8
               2  room_disp               = vc
               2  bed_cd                  = f8
               2  bed_disp                = vc
               2  roombed_disp            = vc
               2  order_status_cd         = f8
               2  order_status_disp       = vc
               2  dept_status_cd          = f8
               2  dept_status_disp        = vc
               2  last_update_provider_id = f8
               2  provider_name           = vc
               2  reporting_priority_cd   = f8
               2  reporting_priority_disp = vc
               2  drawn_dt_tm             = dq8
               2  visit_reason            = vc
               2  person_info_id          = f8
               2  person_comment_cnt      = i4
               2  person_comment[*]
                  3  comment_type_cd      = f8
                  3  long_text_id         = f8
                  3  comment              = vc
               2  encntr_comment_cnt      = i4
               2  encntr_comment[*]
                  3  comment_type_cd      = f8
                  3  long_text_id         = f8
                  3  comment              = vc
               2  order_comment_cnt       = i4
               2  order_comment[*]
                  3  comment_type_cd      = f8
                  3  long_text_id         = f8
                  3  comment              = vc
               2  control_id              = f8
               2  control_name            = vc
               2  lot_id                  = f8
               2  lot_number              = vc
               2  service_resource_cd     = f8  ;QC Accn serv resource
               2  sequence_ident          = c20
               2  fin                     = vc
               2  race                    = c40
               2  specimen_type_disp      = c40
               2  client_alias            = vc
               2  assays_cnt              = i4
               2  assays[*]
                  3  task_assay_cd           = f8
                  3  task_assay_disp         = vc
                  3  cross_resource_ind      = i2
                  3  results_cnt             = i4
                  3  results[*]
                     4  result_id               = f8
                     4  perform_result_id       = f8
                     4  result_status_cd        = f8
                     4  result_type_cd          = f8
                     4  less_great_flag         = i2
                     4  numeric_raw_value       = f8
                     4  result_value            = vc
                     4  result_flags            = vc
                     4  dilution_factor         = f8
                     4  dilution_value          = vc
                     4  perf_tech_id            = f8
                     4  perf_dt_tm              = dq8
                     4  perf_username           = vc
                     4  verf_tech_id            = f8
                     4  verf_dt_tm              = dq8
                     4  verf_username           = vc
                     4  result_comment_cnt      = i4
                     4  result_comment[*]
                        5  comment_type_cd      = f8
                        5  long_text_id         = f8
                        5  comment              = vc
                     4 text_long_text_id        = f8
                     4  interp_text             = vc
                     4  interp_text_ind         = i2
                  3  prev_result_id          = f8
                  3  prev_perform_result_id  = f8
                  3  prev_result_status_cd   = f8
                  3  prev_result_type_cd     = f8
                  3  prev_less_great_flag    = i2
                  3  prev_numeric_raw_value  = f8
                  3  prev_result_value       = vc
                  3  prev_result_flags       = c10
                  3  prev_dilution_factor    = f8
                  3  prev_dilution_value     = vc
                  3  prev_elapse_time        = vc
                  3  prev_text_long_text_id  = f8
                  3  prev_interp_text        = vc
                  3  prev_interp_text_ind    = i2
                  3  qc_result_type_cd       = f8
                  3  qc_abs_high             = f8
                  3  qc_abs_low              = f8
                  3  data_map_ind            = i2 ;Currently only populated for qc results.
                  3  max_digits              = i4 ;Currently only populated for qc results.
                  3  min_digits              = i4 ;Currently only populated for qc results.
                  3  min_decimal_places      = i4 ;Currently only populated for qc results.
               2  accession_sort_seq      = i4
               2  accession_start_pos     = i4
            1  procs_cnt                  = i4
            1  procs[*]
               2  procedure_cd            = f8
               2  procedure_disp          = vc
            1  priors_cnt                 = i4
            1  priors[*]
               2  priority_cd             = f8
               2  priority_disp           = vc
            1  qc_accns_cnt               = i4
            1  qc_accns[*]
               2  accession_id            = f8
               2  accession               = c20
               2  pos                     = i4
               2  begin_ind               = i2
               2  end_ind                 = i2
               2  interval_ind            = i2
               2  interval                = i4
            1  printer                 = vc
            1  copies                  = i4
            1  spacing_ind             = i2  ;0=Single spaced 1=Double spaced
            1  landscape_ind           = i2
            1  blank_lines             = i4
            1  saved_name              = c10
            1  saved_dt_tm             = vc
            1  download_name           = c10
            1  download_dt_tm          = vc
            1  accn_seq_ind            = i2
            1  print_seq_left_ind      = i2
            1  qc_ranges_ind           = i2
            1  filter_qc_assays_ind    = i2
         )
 
      /***********************************************************************
      * If reference data was passed in script.  Build report record.        *
      ***********************************************************************/
         if (print_grp->group[grp_nbr].ref_data_loaded_ind = 1)
            set rpt->worklist_ref_id = request->worklist_ref_id
            set rpt->worklist_ref_disp = request->worklist_ref_disp
            set rpt->worklist_id = request->worklist_id
            set rpt->worklist_alias = request->worklist_alias
            set rpt->service_resource_cd = request->service_resource_cd
            set rpt->service_resource_disp = request->service_resource_disp
            set rpt->parent_ind = request->parent_ind
            set rpt->procedure_inc_flag = request->procedure_inc_flag
            set rpt->include_flag = request->include_flag
            set rpt->report_format_ind = request->report_format_ind
            set rpt->cumulative_ind = request->cumulative_ind
            set rpt->in_lab_ind = request->in_lab_ind
            set rpt->person_comments_ind = request->person_comments_ind
            set rpt->order_comments_ind = request->order_comments_ind
            set rpt->fin_ind = request->fin_ind
            set rpt->race_ind = request->race_ind
            set rpt->specimen_type_ind = request->specimen_type_ind
            set rpt->text_freetext_ind = request->text_freetext_ind
            set rpt->mrn_ind = request->mrn_ind
            set rpt->age_ind = request->age_ind
            set rpt->sex_ind = request->sex_ind
            set rpt->room_bed_ind = request->room_bed_ind
            set rpt->collect_dt_tm_ind = request->collect_dt_tm_ind
            set rpt->ordering_physician_ind = request->ordering_physician_ind
            set rpt->client_alias_ind = request->client_alias_ind
            set rpt->interp_text_ind = request->interp_text_ind
            set rpt->serv_res_sort_ind = request->serv_res_sort_ind
            set rpt->result_comments_ind = request->result_comments_ind
            set rpt->result_space_ind = request->result_space_ind
            set rpt->previous_result_ind = request->previous_result_ind
            set rpt->visit_reason_ind = request->visit_reason_ind
            set rpt->order_status_ind = request->order_status_ind
            set rpt->reporting_priority_ind = request->reporting_priority_ind
            set rpt->facility_ind = request->facility_ind
            set rpt->nurse_unit_ind = request->nurse_unit_ind
            set rpt->cross_resource_ind = request->cross_resource_ind
            set rpt->look_ahead_hours = request->look_ahead_hours
            set rpt->priority_ind = request->priority_ind
            set rpt->orders_cnt = request->qual_cnt
            set rpt->accn_seq_ind = request->accn_seq_ind
            set rpt->print_seq_left_ind = request->print_seq_left_ind
 
            set stat = alterlist(rpt->orders, request->qual_cnt)
            if (request->qual_cnt > 0)
               set curr_accession_sort_seq = 0
               set curr_accession_start_pos = 0
               set prev_accession = " "
               for (o_cnt = 1 to request->qual_cnt)
                  set rpt->orders[o_cnt].accession_id =
                    request->qual[o_cnt].accession_id
                  set rpt->orders[o_cnt].order_id =
                    request->qual[o_cnt].order_id
                  set rpt->orders[o_cnt].accession =
                    request->qual[o_cnt].accession
                  set rpt->orders[o_cnt].catalog_cd =
                    request->qual[o_cnt].catalog_cd
                  set rpt->orders[o_cnt].order_mne =
                    request->qual[o_cnt].order_mne
                  set rpt->orders[o_cnt].person_id =
                    request->qual[o_cnt].person_id
                  set rpt->orders[o_cnt].name_full_formatted =
                    request->qual[o_cnt].name_full_formatted
                  set rpt->orders[o_cnt].order_status_cd =
                    request->qual[o_cnt].order_status_cd
                  set rpt->orders[o_cnt].order_status_disp =
                    request->qual[o_cnt].order_status_disp
                  set rpt->orders[o_cnt].dept_status_cd =
                    request->qual[o_cnt].dept_status_cd
                  set rpt->orders[o_cnt].dept_status_disp =
                    request->qual[o_cnt].dept_status_disp
                  set rpt->orders[o_cnt].reporting_priority_cd =
                    request->qual[o_cnt].reporting_priority_cd
                  set rpt->orders[o_cnt].reporting_priority_disp =
                    request->qual[o_cnt].reporting_priority_disp
                  set rpt->orders[o_cnt].control_id =
                    request->qual[o_cnt].control_id
                  set rpt->orders[o_cnt].control_name =
                    request->qual[o_cnt].control_name
                  set rpt->orders[o_cnt].lot_id =
                    request->qual[o_cnt].lot_id
                  set rpt->orders[o_cnt].lot_number =
                    request->qual[o_cnt].lot_number
                  set rpt->orders[o_cnt].service_resource_cd =
                    request->qual[o_cnt].service_resource_cd
                  set rpt->orders[o_cnt].sequence_ident =
                    request->qual[o_cnt].sequence_ident
                  set rpt->orders[o_cnt].assays_cnt = 0
                  
                    ; We iterate the sequence number if the accession has changed from
                    ; the previous order.       
                  if((trim(rpt->orders[o_cnt].accession) != trim(prev_accession)) or textlen(trim(rpt->orders[o_cnt].accession))=0
                  )
                    set curr_accession_sort_seq = curr_accession_sort_seq + 1
                    set curr_accession_start_pos = o_cnt
                    set prev_accession = rpt->orders[o_cnt].accession
                  endif
                  set rpt->orders[o_cnt].accession_sort_seq = curr_accession_sort_seq
                  set rpt->orders[o_cnt].accession_start_pos = curr_accession_start_pos        
               endfor
            endif 
             
            if (request->procs_cnt > 0)
               for (cnt = 1 to request->procs_cnt)
                  set rpt->procs_cnt = request->procs_cnt
                  set stat = alterlist(rpt->procs, request->procs_cnt)
                  set rpt->procs[cnt].procedure_cd =
                    request->procs[cnt].procedure_cd
                  set rpt->procs[cnt].procedure_disp =
                    request->procs[cnt].procedure_disp
               endfor
            endif
            if (request->priors_cnt > 0)
               for (cnt = 1 to request->priors_cnt)
                  set rpt->priors_cnt = request->priors_cnt
                  set stat = alterlist(rpt->priors, request->priors_cnt)
                  set rpt->priors[cnt].priority_cd =
                    request->priors[cnt].priority_cd
                  set rpt->priors[cnt].priority_disp =
                    request->priors[cnt].priority_disp
               endfor
            endif
            set sPrinterName = " "
            if (request->output_dest_cd > 0)
                set sPrinterName = get_printer_name(request->output_dest_cd)
            endif
            if (trim(sPrinterName) > " ")
              set rpt->printer = sPrinterName
            else
                set rpt->printer = request->printer
            endif
            set rpt->copies = request->copies
            set rpt->spacing_ind = request->spacing_ind
            set rpt->landscape_ind = request->landscape_ind
            set rpt->blank_lines = request->blank_lines
            set rpt->qc_ranges_ind = request->qc_ranges_ind
            set rpt->filter_qc_assays_ind = request->filter_qc_assays_ind
         endif
 
      /***********************************************************************
      * Load reference data if necessary (i.e. Processing a worklist group   *
      * or running from operations).                                         *
      ***********************************************************************/
         if (print_grp->group[grp_nbr].ref_data_loaded_ind = 0)
            ;*
            ;* Call GLB_GET_WKLST_REF
            ;*
            set req250183->worklist_ref_id =
              print_grp->group[grp_nbr].child_worklist_ref_id
            set req250183->service_resource_cd = 0.0
            set req250183->display_key = " "
            set req250183->include_inactive_ind = 0
            set req250183->suppress_worklist_ref_pos_ind = 1
            execute GLB_GET_WKLST_REF with
              replace(request, req250183),
              replace(reply, reply250183)
            if (reply250183->status_data.status = "F")
               ;* Script failure.
               set reply->status_data.subeventstatus[1]
                 .OperationName = "EXECUTE"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "GLB_GET_WKLST_REF"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue =
                 "Unable to load worklist reference data."
               go to Exit_Script
            endif
            if (reply250183->status_data.status = "Z")
               ;* No worklist ref info found.
               go to Next_Worklist
            endif
            set rpt->worklist_ref_id =
              reply250183->qual[1].worklist_ref_id
            set rpt->worklist_ref_disp =
              reply250183->qual[1].display
            set rpt->worklist_id = 0.0
            if (trim(request->batch_selection) > " ")
               set rpt->worklist_alias = concat(
                 trim(substring(1,10, reply250183->qual[1].display)),
                 " ID", format(
                 cnvtdatetime(request->ops_date), "YYYYMMDDHHMM;;Q"))
            else
               set rpt->worklist_alias = concat(
                 trim(substring(1,10, reply250183->qual[1].display)),
                 " ID", format(
                 cnvtdatetime(curdate,curtime3), "YYYYMMDDHHMM;;Q"))
            endif
            set rpt->service_resource_cd =
              reply250183->qual[1].service_resource_cd
            set rpt->service_resource_disp =
              uar_get_code_display(
              reply250183->qual[1].service_resource_cd)
            set rpt->parent_ind =
              reply250183->qual[1].parent_ind
            set rpt->procedure_inc_flag =
              reply250183->qual[1].procedure_inc_flag
            set rpt->include_flag =
              reply250183->qual[1].include_flag
            set rpt->report_format_ind =
              reply250183->qual[1].report_format_ind
            set rpt->cumulative_ind =
              reply250183->qual[1].cumulative_ind
            set rpt->in_lab_ind =
              reply250183->qual[1].in_lab_ind
            set rpt->person_comments_ind =
              reply250183->qual[1].person_comments_ind
            set rpt->order_comments_ind =
              reply250183->qual[1].order_comments_ind
            set rpt->fin_ind                    = reply250183->qual[1].fin_ind
            set rpt->race_ind                   = reply250183->qual[1].race_ind
            set rpt->specimen_type_ind          = reply250183->qual[1].specimen_type_ind
            set rpt->text_freetext_ind          = reply250183->qual[1].text_freetext_ind
            set rpt->mrn_ind                    = reply250183->qual[1].mrn_ind
            set rpt->age_ind                    = reply250183->qual[1].age_ind
            set rpt->sex_ind                    = reply250183->qual[1].sex_ind
            set rpt->room_bed_ind               = reply250183->qual[1].room_bed_ind
            set rpt->collect_dt_tm_ind          = reply250183->qual[1].collect_dt_tm_ind
            set rpt->ordering_physician_ind     = reply250183->qual[1].ordering_physician_ind
            set rpt->accn_seq_ind               = reply250183->qual[1].accn_seq_ind
            set rpt->print_seq_left_ind         = reply250183->qual[1].print_seq_left_ind
            set rpt->client_alias_ind           = reply250183->qual[1].client_alias_ind
            set rpt->interp_text_ind            = reply250183->qual[1].interp_text_ind
            set rpt->serv_res_sort_ind          = reply250183->qual[1].serv_res_sort_ind
 
            set rpt->result_comments_ind =
              reply250183->qual[1].result_comments_ind
            set rpt->result_space_ind =
              reply250183->qual[1].result_space_ind
            set rpt->previous_result_ind =
              reply250183->qual[1].previous_result_ind
            set rpt->visit_reason_ind =
              reply250183->qual[1].visit_reason_ind
            set rpt->order_status_ind =
              reply250183->qual[1].order_status_ind
            set rpt->reporting_priority_ind =
              reply250183->qual[1].reporting_priority_ind
            set rpt->facility_ind =
              reply250183->qual[1].facility_ind
            set rpt->nurse_unit_ind =
              reply250183->qual[1].nurse_unit_ind
            set rpt->cross_resource_ind =
              reply250183->qual[1].cross_resource_ind
            set rpt->look_ahead_hours =
              reply250183->qual[1].look_ahead_hours
            set rpt->priority_ind =
              reply250183->qual[1].priority_ind
            set rpt->orders_cnt = 0
            set rpt->priors_cnt = 0
            if (trim(request->batch_selection) > " ")
               set rpt->printer = request->output_dist
            else
                set sPrinterName = get_printer_name(reply250183->qual[1].output_dest_cd)
                if (trim(sPrinterName) > " ")
                   set rpt->printer = sPrinterName
                else
                set rpt->printer = reply250183->qual[1].printer
              endif
            endif
            set rpt->copies =
              reply250183->qual[1].copies
            set rpt->spacing_ind =
              reply250183->qual[1].spacing_ind
            set rpt->landscape_ind =
              reply250183->qual[1].landscape_ind
            set rpt->blank_lines =
              reply250183->qual[1].blank_lines
            set rpt->qc_ranges_ind = reply250183->qual[1].qc_ranges_ind
            set rpt->filter_qc_assays_ind = reply250183->qual[1].filter_qc_assays_ind
            ;*
            ;* Call GLB_GET_WKLST_REF_DETAILS
            ;*
            if (rpt->procedure_inc_flag > 0
            or  rpt->priority_ind > 0
            or  rpt->include_flag > 0)
               set req250184->worklist_ref_id =
                 print_grp->group[grp_nbr].child_worklist_ref_id
               execute GLB_GET_WKLST_REF_DETAILS with
                 replace(request, req250184),
                 replace(reply, reply250184)
               if (reply250184->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_WKLST_REF_DETAILS"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue =
                    "Unable to load worklist reference detail data."
                  go to Exit_Script
               endif
               if (reply250184->status_data.status = "Z")
                  ;* No worklist ref detail info found.
                  go to Next_Worklist
               endif
               if (reply250184->procs_cnt > 0)
                  set cnt = reply250184->procs_cnt
                  set rpt->procs_cnt = cnt
                  set stat = alterlist(rpt->procs, cnt)
                  for (cnt = 1 to reply250184->procs_cnt)
                     if (rpt->procedure_inc_flag = 1)
                        set rpt->procs[cnt].procedure_cd =
                          reply250184->procs[cnt].catalog_cd
                        set rpt->procs[cnt].procedure_disp =
                          uar_get_code_display(
                          reply250184->procs[cnt].catalog_cd)
                     endif
                     if (rpt->procedure_inc_flag = 2)
                        set rpt->procs[cnt].procedure_cd =
                          reply250184->procs[cnt].task_assay_cd
                        set rpt->procs[cnt].procedure_disp =
                          uar_get_code_display(
                          reply250184->procs[cnt].task_assay_cd)
                     endif
                  endfor
               endif
               if (reply250184->priorities_cnt > 0)
                  set cnt = reply250184->priorities_cnt
                  set rpt->priors_cnt = cnt
                  set stat = alterlist(rpt->priors, cnt)
                  for (cnt = 1 to reply250184->priorities_cnt)
                     set rpt->priors[cnt].priority_cd =
                       reply250184->priorities[cnt].priority_cd
                     set rpt->priors[cnt].priority_disp =
                       uar_get_code_display(
                       reply250184->priorities[cnt].priority_cd)
                  endfor
               endif
               if (reply250184->qc_cnt > 0)
                  set cnt = reply250184->qc_cnt
                  set rpt->qc_accns_cnt = cnt
                  set stat = alterlist(rpt->qc_accns, cnt)
                  for (cnt = 1 to reply250184->qc_cnt)
                     set rpt->qc_accns[cnt].accession_id =
                       reply250184->qc[cnt].accession_id
                     set rpt->qc_accns[cnt].accession =
                       reply250184->qc[cnt].accession
                     set rpt->qc_accns[cnt].pos =
                       reply250184->qc[cnt].pos
                     set rpt->qc_accns[cnt].begin_ind =
                       reply250184->qc[cnt].begin_ind
                     set rpt->qc_accns[cnt].end_ind =
                       reply250184->qc[cnt].end_ind
                     set rpt->qc_accns[cnt].interval_ind =
                       reply250184->qc[cnt].interval_ind
                     set rpt->qc_accns[cnt].interval =
                       reply250184->qc[cnt].interval
                  endfor
               endif
            endif
            ;*
            ;* Call GLB_GET_ELIG_ALL
            ;*
            if (rpt->include_flag != 1)
               set req250083->worklist_ref_id =
                 rpt->worklist_ref_id
               set req250083->service_resource_cd =
                 rpt->service_resource_cd
               set req250083->procedure_inc_flag =
                 rpt->procedure_inc_flag
               set req250083->priority_ind =
                 rpt->priority_ind
               set req250083->cumulative_ind =
                 rpt->cumulative_ind
               set req250083->in_lab_ind =
                 rpt->in_lab_ind
               set nbr_mins = cnvtreal(rpt->look_ahead_hours) * 60.0
               set req250083->lookahead_dt_tm_end = datetimeadd(
                 cnvtdatetime(curr->system_dt_tm), (nbr_mins / 1440.0))
               if (rpt->procedure_inc_flag = 1
               and rpt->procs_cnt > 0)
                  set cnt = rpt->procs_cnt
                  set stat = alterlist(req250083->procs, cnt)
                  for (cnt = 1 to rpt->procs_cnt)
                     set req250083->procs[cnt].procedure_cd =
                       rpt->procs[cnt].procedure_cd
                     set req250083->procs[cnt].grpdetail = 0
                  endfor
               endif
               if (rpt->procedure_inc_flag = 2
               and rpt->procs_cnt > 0)
                  set cnt = rpt->procs_cnt
                  set stat = alterlist(req250083->procs, cnt)
                  for (cnt = 1 to rpt->procs_cnt)
                     set req250083->procs[cnt].procedure_cd =
                       rpt->procs[cnt].procedure_cd
                     set req250083->procs[cnt].grpdetail = 1
                  endfor
               endif
               if (rpt->priority_ind = 1
               and rpt->priors_cnt > 0)
                  set cnt = rpt->priors_cnt
                  set stat = alterlist(req250083->pris, cnt)
                  for (cnt = 1 to rpt->priors_cnt)
                     set req250083->pris[cnt].priority_cd =
                       rpt->priors[cnt].priority_cd
                  endfor
               endif
               execute GLB_GET_ELIG_ALL with
                 replace(request, req250083),
                 replace(reply, reply250083)
               if (reply250083->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_ELIG_ALL"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue =
                    "Unable to load eligible orders for worklist."
                  go to Exit_Script
               endif
               if (reply250083->status_data.status = "S"
               and reply250083->n_orders > 0)
                  select into "nl:"
                     d.seq
                    ,accn =
                      reply250083->qual[d.seq].accession
                    ,catalogcd =
                      reply250083->qual[d.seq].catalog_cd
                    ,orderstatus_disp = uar_get_code_display(
                      reply250083->qual[d.seq].order_status_cd)
                    ,deptstatus_disp = uar_get_code_display(
                      reply250083->qual[d.seq].dept_status_cd)
                    ,reportpriority_disp = uar_get_code_display(
                      reply250083->qual[d.seq].report_priority_cd)
                    ,reportpriority_mean = uar_get_code_meaning(
                      reply250083->qual[d.seq].report_priority_cd)
                  from
                     (dummyt d with seq = value(reply250083->n_orders))
                  plan d
                    where d.seq <= reply250083->n_orders
                  order by
                     reportpriority_mean
                    ,accn
                    ,catalogcd
                  head report
                     o_cnt = 0
                     curr_accession_sort_seq = 0
                     curr_accession_start_pos = 0
                     prev_accession = " "
                  detail
                     o_cnt = o_cnt + 1
                     if (mod(o_cnt, 100) = 1)
                        stat = alterlist(rpt->orders, o_cnt + 100)
                     endif
                     rpt->orders_cnt = o_cnt
                     rpt->orders[o_cnt].accession_id = 0.0
                     rpt->orders[o_cnt].order_id =
                       reply250083->qual[d.seq].order_id
                     rpt->orders[o_cnt].accession =
                       reply250083->qual[d.seq].accession
                     rpt->orders[o_cnt].catalog_cd =
                       reply250083->qual[d.seq].catalog_cd
                     rpt->orders[o_cnt].order_mne =
                       reply250083->qual[d.seq].order_mnemonic
                     rpt->orders[o_cnt].person_id =
                       reply250083->qual[d.seq].person_id
                     rpt->orders[o_cnt].name_full_formatted =
                       reply250083->qual[d.seq].name_full_formatted
                     rpt->orders[o_cnt].order_status_cd =
                       reply250083->qual[d.seq].order_status_cd
                     rpt->orders[o_cnt].order_status_disp =
                       orderstatus_disp
                     rpt->orders[o_cnt].dept_status_cd =
                       reply250083->qual[d.seq].dept_status_cd
                     rpt->orders[o_cnt].dept_status_disp =
                       deptstatus_disp
                     rpt->orders[o_cnt].reporting_priority_cd =
                       reply250083->qual[d.seq].report_priority_cd
                     rpt->orders[o_cnt].reporting_priority_disp =
                       reportpriority_disp
                     rpt->orders[o_cnt].sequence_ident = " "
                     
                        ; We iterate the sequence number if the accession has changed 
                        ; from the previous order.
                     if((trim(rpt->orders[o_cnt].accession) != trim(prev_accession))or textlen(trim(rpt->orders[o_cnt].accession))
                     =0)
                       curr_accession_sort_seq = curr_accession_sort_seq + 1
                       curr_accession_start_pos = o_cnt
                       prev_accession = rpt->orders[o_cnt].accession
                     endif
                     rpt->orders[o_cnt].accession_sort_seq = curr_accession_sort_seq
                     rpt->orders[o_cnt].accession_start_pos = curr_accession_start_pos
                     
                  foot report
                     stat = alterlist(rpt->orders, o_cnt)
                  with
                     nocounter
               endif
            endif
            ;*
            ;* Call GLB_GET_WKLST_QC_ACCNS
            ;*
            if (rpt->include_flag in (1, 2)
            and rpt->qc_accns_cnt > 0)
               set req250102->worklist_ref_id =
                 rpt->worklist_ref_id
               set req250102->service_resource_cd =
                 rpt->service_resource_cd
               execute GLB_GET_WKLST_QC_ACCNS with
                 replace(request, req250102),
                 replace(reply, reply250102)
               if (reply250102->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_WKLST_QC_ACCNS"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue =
                    "Unable to load QC accessions for worklist."
                  go to Exit_Script
               endif
               if (reply250102->status_data.status = "S")
                  ;*
                  ;* Insert QC accessions.
                  ;*
                  set ptr = size(reply250102->qual,5)
                  set nLastPatientOrder = rpt->orders_cnt
                  while (ptr > 0)
                     for (cnt = 1 to size(reply250102->qual,5))
                        if (reply250102->qual[cnt].pos = ptr)
                           ;* Check for QC accession insertion at
                           ;* beginning of orders list.
                           if (reply250102->qual[cnt].begin_ind = 1)
                              set o_cnt = 1
                              set stat = adjust_orders_list(o_cnt)
                              set rpt->orders[o_cnt].accession_id =
                                 reply250102->qual[cnt].accession_id
                              set rpt->orders[o_cnt].accession =
                                 reply250102->qual[cnt].unformat_accn
                              set rpt->orders[o_cnt].control_id =
                                 reply250102->qual[cnt].control_id
                              set rpt->orders[o_cnt].control_name =
                                 reply250102->qual[cnt].control_name
                              set rpt->orders[o_cnt].lot_id =
                                 reply250102->qual[cnt].lot_id
                              set rpt->orders[o_cnt].lot_number =
                                 reply250102->qual[cnt].lot_number
                              set rpt->orders[o_cnt]
                                 .service_resource_cd =
                                 reply250102->qual[cnt]
                                 .service_resource_cd
                           endif
                           ;* Check for QC accession insertion at
                           ;* a given patient accession interval into
                           ;* the orders list.
                           if (reply250102->qual[cnt].interval_ind = 1)
                              set interval_cnt = 0
                              set idx = 1
                              set prev_accession = "-1"
                              while (idx <= rpt->orders_cnt)
                                 if (rpt->orders[idx].order_id > 0.0)
                                 
                                    if (rpt->accn_seq_ind = 1)
                                    
                                       ;This is an accession level worklist only, count QC intervals for each accession
                                       if (trim(prev_accession) = "-1")
                                          set prev_accession = rpt->orders[idx].accession
                                       elseif (rpt->orders[idx].accession != prev_accession)
                                          ;accession has changed, increment the interval count.
                                          set interval_cnt = interval_cnt + 1
                                          set prev_accession = rpt->orders[idx].accession
                                       elseif (idx = nLastPatientOrder)
                                          ;We are processing the last patient accession, bump the interval to 
                                          ;see if QC needs to be added at the end of the list due to interval.
                                          set interval_cnt = interval_cnt + 1
                                       endif
                                    else
                                       ;This is an order level worklist only, count QC intervals for each order
                                       set interval_cnt = interval_cnt + 1
                                    endif
                                    if (reply250102->qual[cnt]
                                       .interval = interval_cnt)
                                       if (rpt->accn_seq_ind = 1 and idx < nLastPatientOrder)
                                          set o_cnt = idx
                                       else
                                          set o_cnt = idx + 1
                                       endif
                                       set stat = adjust_orders_list(o_cnt)
                                       set rpt->orders[o_cnt]
                                         .accession_id =
                                         reply250102->qual[cnt]
                                         .accession_id
                                       set rpt->orders[o_cnt]
                                         .accession =
                                         reply250102->qual[cnt]
                                         .unformat_accn
                                       set rpt->orders[o_cnt]
                                         .control_id =
                                         reply250102->qual[cnt]
                                         .control_id
                                       set rpt->orders[o_cnt]
                                         .control_name =
                                         reply250102->qual[cnt]
                                         .control_name
                                       set rpt->orders[o_cnt]
                                         .lot_id =
                                         reply250102->qual[cnt]
                                         .lot_id
                                       set rpt->orders[o_cnt]
                                         .lot_number =
                                         reply250102->qual[cnt]
                                         .lot_number
                                       set rpt->orders[o_cnt]
                                        .service_resource_cd =
                                        reply250102->qual[cnt]
                                        .service_resource_cd
                                        set interval_cnt = 0
                                    endif
                                 endif
                                 set idx = idx + 1
                              endwhile
                           endif
                        endif
                     endfor
                     set ptr = ptr - 1
                  endwhile
                  for (ptr = 1 to size(reply250102->qual,5))
                     for (cnt = 1 to size(reply250102->qual,5))
                        if (reply250102->qual[cnt].pos = ptr)
                           ;* Check for QC accession insertion at
                           ;* end of orders list.
                           if (reply250102->qual[cnt].end_ind = 1)
                              set o_cnt = rpt->orders_cnt + 1
                              set stat = adjust_orders_list(o_cnt)
                              set rpt->orders[o_cnt].accession_id =
                                 reply250102->qual[cnt].accession_id
                              set rpt->orders[o_cnt].accession =
                                 reply250102->qual[cnt].unformat_accn
                              set rpt->orders[o_cnt].control_id =
                                 reply250102->qual[cnt].control_id
                              set rpt->orders[o_cnt].control_name =
                                 reply250102->qual[cnt].control_name
                              set rpt->orders[o_cnt].lot_id =
                                 reply250102->qual[cnt].lot_id
                              set rpt->orders[o_cnt].lot_number =
                                 reply250102->qual[cnt].lot_number
                              set rpt->orders[o_cnt]
                                 .service_resource_cd =
                                 reply250102->qual[cnt]
                                 .service_resource_cd
                           endif
                        endif
                     endfor
                  endfor
               endif
            endif
         endif
 
      /***********************************************************************
      * Load Additional Order Information.                                   *
      ***********************************************************************/
         if (rpt->orders_cnt = 0)
            go to Report_Prep
         endif
 
         if (rpt->include_flag = 1)
            go to Load_QC_Info
         endif
 
         select into "nl:"
            d1.seq
           ,o.order_id
           ,ol.resource_route_level_flag
           ,p.person_id
           ,sexdisp = uar_get_code_display(p.sex_cd)
           ,e.encntr_id
           ,locationmean = uar_get_code_meaning(e.location_cd)
           ,facilitydisp = uar_get_code_display(e.loc_facility_cd)
           ,nurseunitdisp = uar_get_code_display(e.loc_nurse_unit_cd)
           ,roomdisp = uar_get_code_display(e.loc_room_cd)
           ,beddisp = uar_get_code_display(e.loc_bed_cd)
           ,d_pl.seq
           ,pl_exists = decode(pl.seq, "Y", "N")
           ,providername = concat(i18n_captions->dr,
             trim(pl.name_full_formatted))
           ,d_ea.seq
           ,eafin_exists = decode(ea_fin.seq, "Y", "N")
           ,ea_exists = decode(ea.seq, "Y", "N")
           ,mrn = cnvtalias(ea.alias, ea.alias_pool_cd)
           ,fin = cnvtalias(ea_fin.alias, ea_fin.alias_pool_cd)
           ,d_osrc.seq
           ,osrc_exists = decode(osrc.seq, "Y", "N")
           ,osrc.order_id
           ,oa_exists = decode(oa.seq, "Y", "N")
           ,client_alias = cnvtalias(oa.alias, oa.alias_pool_cd)
           ,c_exists = decode(c.seq, "Y", "N")
           ,c.container_id
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,orders o
           ,order_laboratory ol
           ,person p
           ,encounter e
           ,(dummyt d_pl with seq = 1)
           ,prsnl pl
           ,(dummyt d_ea_fin with seq = 1)
           ,encntr_alias ea_fin
           ,(dummyt d_ea with seq = 1)
           ,encntr_alias ea
           ,(dummyt d_osrc with seq = 1)
           ,order_serv_res_container osrc
           ,organization_alias oa
           ,(dummyt d_oa with seq = 1)
           ,container c
           ,v500_specimen vs
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join o
            where o.order_id = rpt->orders[d1.seq].order_id
         join ol
            where ol.order_id = o.order_id
         join p
            where p.person_id = o.person_id
         join e
            where e.encntr_id = o.encntr_id
         join d_pl
            where d_pl.seq = 1
         join pl
            where pl.person_id = o.last_update_provider_id
         join d_ea_fin
            where d_ea_fin.seq = 1
         join ea_fin
            where ea_fin.encntr_id = o.encntr_id
              and ea_fin.encntr_alias_type_cd = alias_type_fin_cd
              and ea_fin.active_ind = 1
              and (cnvtdatetime(curdate,curtime3) between ea_fin.beg_effective_dt_tm and ea_fin.end_effective_dt_tm)
         join d_ea
            where d_ea.seq = 1
         join ea
            where ea.encntr_id = o.encntr_id
              and ea.encntr_alias_type_cd = alias_type_mrn_cd
              and ea.active_ind = 1
              and (cnvtdatetime(curdate,curtime3) between ea.beg_effective_dt_tm and ea.end_effective_dt_tm)
         join d_osrc
            where d_osrc.seq = 1
         join osrc
            where osrc.order_id = o.order_id
         join c
            where c.container_id = osrc.container_id
         join vs
            where vs.specimen_id = c.specimen_id
         join d_oa
            where d_oa.seq = 1
         join oa
            where e.organization_id = oa.organization_id
              and oa.org_alias_type_cd = org_alias_client_cd
              and oa.active_ind = 1
              and oa.beg_effective_dt_tm <= cnvtdatetime(curdate, curtime3)
              and oa.end_effective_dt_tm >= cnvtdatetime(curdate, curtime3)
         order by
            d1.seq
 
         head report
            person_age = fillstring(12, " ")
 
         head d1.seq
            o_cnt = d1.seq
            rpt->orders[o_cnt].catalog_cd = o.catalog_cd
            rpt->orders[o_cnt].resource_route_level_flag =
              ol.resource_route_level_flag
            rpt->orders[o_cnt].encntr_id = o.encntr_id
            if (eafin_exists = "Y")
              rpt->orders[o_cnt].fin = fin
            endif
            rpt->orders[o_cnt].sex_cd = p.sex_cd
            rpt->orders[o_cnt].sex_disp = sexdisp
            rpt->orders[o_cnt].race = uar_get_code_display(p.race_cd)
            rpt->orders[o_cnt].location_cd = e.location_cd
            rpt->orders[o_cnt].location_mean = locationmean
            rpt->orders[o_cnt].facility_cd = e.loc_facility_cd
            rpt->orders[o_cnt].facility_disp = facilitydisp
            rpt->orders[o_cnt].nurse_unit_cd = e.loc_nurse_unit_cd
            rpt->orders[o_cnt].nurse_unit_disp = nurseunitdisp
            rpt->orders[o_cnt].room_cd = e.loc_room_cd
            rpt->orders[o_cnt].room_disp = roomdisp
            rpt->orders[o_cnt].bed_cd = e.loc_bed_cd
            rpt->orders[o_cnt].bed_disp = beddisp
            if (e.loc_room_cd > 0.0
            and e.loc_bed_cd > 0.0)
               rpt->orders[o_cnt].roombed_disp = concat(
                 trim(roomdisp), "-", trim(beddisp))
            elseif (e.loc_room_cd > 0.0
            and e.loc_bed_cd = 0.0)
               rpt->orders[o_cnt].roombed_disp = trim(roomdisp)
            elseif (e.loc_room_cd = 0.0
            and e.loc_bed_cd = 0.0)
               rpt->orders[o_cnt].roombed_disp = trim(beddisp)
            endif
            rpt->orders[o_cnt].visit_reason = e.reason_for_visit
            rpt->orders[o_cnt].last_update_provider_id =
              o.last_update_provider_id
            if (pl_exists = "Y")
               rpt->orders[o_cnt].provider_name = providername
            else
               rpt->orders[o_cnt].provider_name = i18n_captions->dr
            endif
            if (ea_exists = "Y")
               rpt->orders[o_cnt].med_rec_nbr = mrn
            endif
            if (osrc_exists = "Y"
            and c_exists = "Y")
               rpt->orders[o_cnt].drawn_dt_tm = cnvtdatetime(c.drawn_dt_tm)
               rpt->orders[o_cnt].specimen_type_disp = uar_get_code_display(vs.specimen_type_cd)
            endif
            ;*
            ;* Calculate person age.
            ;*
            rpt->orders[o_cnt].age = FormatAge(p.birth_dt_tm, p.deceased_dt_tm, "LABRPTAGE")
 
            if (oa_exists = "Y")
                rpt->orders[o_cnt].client_alias = client_alias
            endif

         with
            nocounter
           ,outerjoin = d_pl
           ,dontcare = pl
           ,outerjoin = d_ea_fin
           ,dontcare = ea_fin
           ,outerjoin = d_ea
           ,dontcare = ea
           ,outerjoin = d_osrc
           ,dontcare = osrc
           ,outerjoin = d_oa
           ,dontcare = c
           ,dontcare = vs
 
      /***********************************************************************
      * Load Person Comments.                                                *
      ***********************************************************************/
         if (rpt->person_comments_ind = 0)
            go to Load_Order_Comments
         endif
 
         set max_pc_cnt = 0
 
         ;*
         ;* Determine if person comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,pi.person_id
           ,pi.beg_effective_dt_tm
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,person_info pi
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join pi
            where pi.person_id = rpt->orders[d1.seq].person_id
              and pi.info_type_cd = info_type_comment_cd
              and pi.active_ind = 1
 
         order by
            d1.seq
           ,pi.person_id
           ,cnvtdatetime(pi.beg_effective_dt_tm) desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].person_comment_cnt
            cnt = cnt + 1
            if (cnt > max_pc_cnt)
               max_pc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].person_comment, cnt)
            rpt->orders[o_cnt].person_comment_cnt = cnt
            rpt->orders[o_cnt].person_comment[cnt].comment_type_cd =
              pi.info_type_cd
            rpt->orders[o_cnt].person_comment[cnt].long_text_id =
              pi.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Determine if person notes exist.
         ;*
         select into "nl:"
            d1.seq
           ,pi.person_id
           ,pi.beg_effective_dt_tm
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,person_info pi
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join pi
            where pi.person_id = rpt->orders[d1.seq].person_id
              and pi.info_type_cd = info_type_note_cd
              and pi.active_ind = 1
 
         order by
            d1.seq
           ,pi.person_id
           ,cnvtdatetime(pi.beg_effective_dt_tm) desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].person_comment_cnt
            cnt = cnt + 1
            if (cnt > max_pc_cnt)
               max_pc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].person_comment, cnt)
            rpt->orders[o_cnt].person_comment_cnt = cnt
            rpt->orders[o_cnt].person_comment[cnt].comment_type_cd =
              pi.info_type_cd
            rpt->orders[o_cnt].person_comment[cnt].long_text_id =
              pi.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Load person comments & notes
         ;*
         if (max_pc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,lt.long_text_id
 
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_pc_cnt))
              ,long_text lt
 
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].person_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].person_comment_cnt
            join lt
               where lt.long_text_id =
                 rpt->orders[d1.seq].person_comment[d2.seq].long_text_id
 
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].person_comment[cnt].comment =
                 lt.long_text
 
            with
               nocounter
         endif
 
      /***********************************************************************
      * Load Encounter Comments.                                             *
      ***********************************************************************/
         if (rpt->person_comments_ind = 0)
            go to Load_Order_Comments
         endif
 
         set max_ec_cnt = 0
 
         ;*
         ;* Determine if encounter comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,ei.encntr_id
           ,ei.beg_effective_dt_tm
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,encntr_info ei
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ei
            where ei.encntr_id = rpt->orders[d1.seq].encntr_id
              and ei.info_type_cd = info_type_comment_cd
              and ei.active_ind = 1
 
         order by
            d1.seq
           ,ei.encntr_id
           ,cnvtdatetime(ei.beg_effective_dt_tm) desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].encntr_comment_cnt
            cnt = cnt + 1
            if (cnt > max_ec_cnt)
               max_ec_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].encntr_comment, cnt)
            rpt->orders[o_cnt].encntr_comment_cnt = cnt
            rpt->orders[o_cnt].encntr_comment[cnt].comment_type_cd =
              ei.info_type_cd
            rpt->orders[o_cnt].encntr_comment[cnt].long_text_id =
              ei.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Determine if encounter notes exist.
         ;*
         select into "nl:"
            d1.seq
           ,ei.encntr_id
           ,ei.beg_effective_dt_tm
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,encntr_info ei
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ei
            where ei.encntr_id = rpt->orders[d1.seq].encntr_id
              and ei.info_type_cd = info_type_note_cd
              and ei.active_ind = 1
 
         order by
            d1.seq
           ,ei.encntr_id
           ,cnvtdatetime(ei.beg_effective_dt_tm) desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].encntr_comment_cnt
            cnt = cnt + 1
            if (cnt > max_ec_cnt)
               max_ec_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].encntr_comment, cnt)
            rpt->orders[o_cnt].encntr_comment_cnt = cnt
            rpt->orders[o_cnt].encntr_comment[cnt].comment_type_cd =
              ei.info_type_cd
            rpt->orders[o_cnt].encntr_comment[cnt].long_text_id =
              ei.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Load encounter comments & notes
         ;*
         if (max_ec_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,lt.long_text_id
 
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_ec_cnt))
              ,long_text lt
 
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].encntr_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].encntr_comment_cnt
            join lt
               where lt.long_text_id =
                 rpt->orders[d1.seq].encntr_comment[d2.seq].long_text_id
 
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].encntr_comment[cnt].comment =
                 lt.long_text
 
            with
               nocounter
         endif
 
      /***********************************************************************
      * Load Order Comments and Order Footnotes.                             *
      ***********************************************************************/
      #Load_Order_Comments
         if (rpt->order_comments_ind = 0)
            go to Load_Cross_Res_Results
         endif
 
         set max_oc_cnt = 0
         ;*
         ;* Determine if order comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,oc.order_id
           ,oc.action_sequence
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,order_comment oc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join oc
            where oc.order_id = rpt->orders[d1.seq].order_id
              and oc.action_sequence >= 0
              and oc.comment_type_cd = comment_type_ord_comment_cd
 
         order by
            d1.seq
           ,oc.order_id
           ,oc.action_sequence desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].order_comment_cnt
            cnt = cnt + 1
            if (cnt > max_oc_cnt)
               max_oc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].order_comment, cnt)
            rpt->orders[o_cnt].order_comment_cnt = cnt
            rpt->orders[o_cnt].order_comment[cnt].comment_type_cd =
              oc.comment_type_cd
            rpt->orders[o_cnt].order_comment[cnt].long_text_id =
              oc.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Determine if order footnotes exist.
         ;*
         select into "nl:"
            d1.seq
           ,oc.order_id
           ,oc.action_sequence
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,order_comment oc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join oc
            where oc.order_id = rpt->orders[d1.seq].order_id
              and oc.action_sequence >= 0
              and oc.comment_type_cd = comment_type_ord_note_cd
 
         order by
            d1.seq
           ,oc.order_id
           ,oc.action_sequence desc
 
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].order_comment_cnt
            cnt = cnt + 1
            if (cnt > max_oc_cnt)
               max_oc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].order_comment, cnt)
            rpt->orders[o_cnt].order_comment_cnt = cnt
            rpt->orders[o_cnt].order_comment[cnt].comment_type_cd =
              oc.comment_type_cd
            rpt->orders[o_cnt].order_comment[cnt].long_text_id =
              oc.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Load order comments and order footnotes
         ;*
         if (max_oc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,lt.long_text_id
 
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_oc_cnt))
              ,long_text lt
 
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].order_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].order_comment_cnt
            join lt
               where lt.long_text_id =
                 rpt->orders[d1.seq].order_comment[d2.seq].long_text_id
 
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].order_comment[cnt].comment =
                 lt.long_text
 
            with
               nocounter
         endif
         

 
      /***********************************************************************
      * Load Cross Resource Results.                                         *
      ***********************************************************************/
      #Load_Cross_Res_Results
         set max_a_cnt = 0
         set max_r_cnt = 0
 
         if (rpt->result_space_ind = 0)
            go to Load_QC_Info
         endif
 
         if (rpt->cross_resource_ind = 0)
            go to Load_Current_Results
         endif
 
         select into "nl:"
            d1.seq
           ,ptr.catalog_cd
           ,ptr.task_assay_cd
           ,task_assay_disp = uar_get_code_display(ptr.task_assay_cd)
           ,ope.service_resource_cd
           ,apr.display_sequence
           ,d_r.seq
           ,r_exists = decode(r.seq, "Y", "N")
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,notify_disp = uar_get_code_display(pr.notify_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,re.event_personnel_id
           ,pl_pr.username
           ,pl_re.username
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
           ,accession_order_sort = evaluate(rpt->serv_res_sort_ind, 0, d1.seq, 1, rpt->orders[d1.seq].accession_sort_seq)
           ,service_resource_sort = apr.service_resource_cd
           ,ptr_secondary_sort = evaluate(rpt->serv_res_sort_ind, 0, 1, 1, d1.seq)
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,profile_task_r ptr
           ,order_procedure_exception ope
           ,assay_processing_r apr
           ,(dummyt d_r with seq = 1)
           ,result r
           ,perform_result pr
           ,result_event re
           ,prsnl pl_pr
           ,prsnl pl_re
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ptr
            where ptr.catalog_cd = rpt->orders[d1.seq].catalog_cd
              and ptr.active_ind = 1
         join ope
            where ope.order_id = rpt->orders[d1.seq].order_id
              and ope.task_assay_cd = ptr.task_assay_cd
              and ope.service_resource_cd != rpt->service_resource_cd
         join apr
            where apr.task_assay_cd = ptr.task_assay_cd
              and apr.service_resource_cd = ope.service_resource_cd
              and apr.active_ind = 1
         join d_r
            where d_r.seq = 1
         join r
            where r.order_id = rpt->orders[d1.seq].order_id
              and r.task_assay_cd = ptr.task_assay_cd
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join re
            where re.result_id = pr.result_id
              and re.perform_result_id = pr.perform_result_id
              and re.event_type_cd = r.result_status_cd
         join pl_pr
            where pl_pr.person_id = pr.perform_personnel_id
         join pl_re
            where pl_re.person_id = re.event_personnel_id
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id
 
 ;*      Changes made to allow service resource order sorting:
 ;
 ;* accession_order_sort is now the top-level sort
 ;  When serv_res_sort_ind is passed with a value of 0, we sort on d1.seq as it did 
 ;  before the change.
 ;  When serv_res_sort_ind is passed with a value of 1, we sort on accession_sort_seq
 ;  so that when the same accession is added to a list in consecutive positions, the
 ;  orders on both the accessions are sorted together.
 ;
 ;* Sorting on service_resource_sort causes orders to group by SR
 ;
 ;* ptr_secondary_sort is used to maintain the original functionality of sorting on
 ;  d1.seq when accession_order_sort is not equal to d1.seq. 
 ;  When accession_order_sort = d1.seq, ptr_secondary_sort is set to a constant (1),
 ;  causing no sort to occur at this level. 
         order by
            accession_order_sort    
           ,service_resource_sort
           ,apr.display_sequence
           ,ptr.task_assay_cd
           ,ptr_secondary_sort
           ,r.result_id
           ,pr.repeat_nbr
 
         head accession_order_sort
            o_cnt = evaluate(rpt->serv_res_sort_ind, 0, d1.seq, 1, rpt->orders[d1.seq].accession_start_pos)
            a_cnt = 0
            r_cnt = 0
            idx = 0
            dta_match_found = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            notifyflag = " "
            correctflag = " "
            a_cnt = rpt->orders[o_cnt].assays_cnt
 
         head service_resource_sort
            row+0
            
         head apr.display_sequence
            row+0
            
         head ptr.task_assay_cd
            row+0
         
         head ptr_secondary_sort        
            dta_match_found = 0
            if (rpt->procedure_inc_flag = 2)
               ;* Detail (i.e. task assay) level.  Validate
               ;* that the task assay qualifies for the report.
               if (rpt->procs_cnt > 0)
                 for (cnt = 1 to rpt->procs_cnt)
                     if (rpt->procs[cnt].procedure_cd = ptr.task_assay_cd)
                        dta_match_found = 1
                     endif
                  endfor
               endif
            else
               ;* Group (i.e. orderable) level.
               ;* All discrete task assays qualify for the report.
               dta_match_found = 1
            endif
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd =
                  ptr.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp        
               rpt->orders[o_cnt].assays[a_cnt].cross_resource_ind = 1
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_perform_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_status_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_type_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_less_great_flag = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_numeric_raw_value = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_flags = fillstring(10, " ")
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_factor = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_elapse_time = " "
            endif
 
         head r.result_id
            r_cnt = rpt->orders[o_cnt].assays[a_cnt].results_cnt
 
         head pr.repeat_nbr
            if (dta_match_found = 1
            and r_exists = "Y"
            and r.result_id > 0.0)
               r_cnt = r_cnt + 1
               if (r_cnt > max_r_cnt)
                  max_r_cnt = r_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
                 .results, r_cnt)
               rpt->orders[o_cnt].assays[a_cnt].results_cnt = r_cnt
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_id = r.result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perform_result_id = pr.perform_result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_status_cd = r.result_status_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_type_cd = pr.result_type_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .less_great_flag = pr.less_great_flag
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .dilution_factor = pr.dilution_factor
               if (pr.dilution_factor > 0.0)
                  dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
                  idx = 1
                  ;* Remove leading zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx + 1
                  endwhile
                  idx = 6
                  ;* Remove trailing zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx - 1
                  endwhile
                  ;* Remove decimal point if not needed
                  if (substring(idx, 1, dilution_val )= ".")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                  endif
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .dilution_value = concat("x", trim(dilution_val,3))
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_tech_id = pr.perform_personnel_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_dt_tm = cnvtdatetime(pr.perform_dt_tm)
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_username = pl_pr.username
               if (r.result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = re.event_personnel_id
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_dt_tm = cnvtdatetime(re.event_dt_tm)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = pl_re.username
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = 0.0
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = " "
               endif
               if (pr.result_type_cd = result_type_text_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = i18n_captions->text
 
                  if (rpt->text_freetext_ind = 1 and pr.long_text_id > 0.0)
                    rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].text_long_text_id = pr.long_text_id
                    found_curr_text_ind = 1
                  endif
               endif
               if (pr.result_type_cd = result_type_alpha_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.result_value_alpha
               endif
               if (pr.result_type_cd = result_type_numeric_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               if (pr.result_type_cd = result_type_interp_cd)
                  if (trim(pr.result_value_alpha) > " ")
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = pr.result_value_alpha
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = i18n_captions->text
                  endif
               endif
               if (pr.result_type_cd = result_type_date_cd)
				if(LOCALE = localeObjectName)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value =
                    format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
                 else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value =
                    format(pr.result_value_dt_tm, "YYYY/MM/DD;;d")
                 endif
               endif
               if (pr.result_type_cd = result_type_freetext_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.ascii_text
               endif
               if (pr.result_type_cd = result_type_calc_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               ;*
               ;* Build result flags string
               ;*
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = fillstring(10, " ")
               if (pr.normal_cd > 0.0
               and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                   RESULT_PRCSS_NORMAL_LOW_CDF,
                                   RESULT_PRCSS_ALP_ABNORMAL_CDF))
                  normflag = substring(1,1,normal_disp)
               else
                  normflag = " "
               endif
               if (pr.critical_cd > 0.0
               and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                     RESULT_PRCSS_ALP_CRITICAL_CDF))
                  critflag = substring(1,1,critical_disp)
               else
                  critflag = " "
               endif
               if (pr.review_cd > 0.0
               and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                   RESULT_PRCSS_ALP_REVIEW_CDF))
                  revwflag = substring(1,1,review_disp)
               else
                  revwflag = " "
               endif
               if (pr.linear_cd > 0.0
               and linear_mean = RESULT_PRCSS_LINEAR_CDF)
                  linearflag = substring(1,1,linear_disp)
               else
                  linearflag = " "
               endif
               if (pr.feasible_cd > 0.0
               and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
                  feasflag = substring(1,1,feasible_disp)
               else
                  feasflag = " "
               endif
               if (pr.delta_cd > 0.0
               and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
                  deltaflag = substring(1,1,delta_disp)
               else
                  deltaflag = " "
               endif
               if(pr.notify_cd in(notify_cd, alp_notify_cd))
                  notifyflag = substring(1, 1, notify_disp)
               else
                  notifyflag = " "
               endif
 
               if (rc_exists = "Y")
                  rcommentflag = "Y"
                  rnoteflag = "Y"
               else
                  rcommentflag = "N"
                  rnoteflag = "N"
               endif
               if (r.result_status_cd = corrected_cd)
                  correctflag = "Y"
               else
                  correctflag = "N"
               endif
               if ((pr.nomenclature_id > 0.0) and (pr.long_text_id > 0.0))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind = 1
                  if (rpt->interp_text_ind = 1)
                     found_curr_text_ind = 1
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].text_long_text_id = pr.long_text_id
                  endif
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind = 0
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = bldresultflagstr(normflag,
                 critflag, revwflag, linearflag, feasflag,
                 deltaflag, rcommentflag, rnoteflag, correctflag, notifyflag, 
                 rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind)
            endif
            
            
         foot pr.repeat_nbr
            row+0
            
         foot r.result_id
            row+0
         
         foot ptr_secondary_sort
            row+0
         
         foot ptr.task_assay_cd
            row+0
         
         foot apr.display_sequence
            row+0
         
         foot service_resource_sort
            row+0
         
         foot accession_order_sort
            row+0
         
 
         with
            nocounter
           ,outerjoin = d_r
           ,dontcare = r
           ,dontcare = pr
           ,dontcare = re
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
 
      /***********************************************************************
      * Load Current Results.                                                *
      ***********************************************************************/
      #Load_Current_Results
         select into "nl:"
            d1.seq
           ,ptr.catalog_cd
           ,ptr.task_assay_cd
           ,task_assay_disp = uar_get_code_display(ptr.task_assay_cd)
           ,apr.service_resource_cd
           ,apr.display_sequence
           ,d_ope.seq
           ,ope_exists = decode(ope.seq, "Y", "N")
           ,d_r.seq
           ,r_exists = decode(r.seq, "Y", "N")
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,notify_disp = uar_get_code_display(pr.notify_cd)
           ,re.event_personnel_id
           ,pl_pr.username
           ,pl_re.username
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
           ,accession_order_sort = evaluate(rpt->serv_res_sort_ind, 0, d1.seq, 1, rpt->orders[d1.seq].accession_sort_seq)
           ,ptr_secondary_sort = evaluate(rpt->serv_res_sort_ind, 0, 1, 1, d1.seq)
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,profile_task_r ptr
           ,assay_processing_r apr
           ,(dummyt d_ope with seq = 1)
           ,order_procedure_exception ope
           ,(dummyt d_r with seq = 1)
           ,result r
           ,perform_result pr
           ,result_event re
           ,prsnl pl_pr
           ,prsnl pl_re
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ptr
            where ptr.catalog_cd = rpt->orders[d1.seq].catalog_cd
              and ptr.active_ind = 1
         join apr
            where apr.task_assay_cd = ptr.task_assay_cd
              and apr.service_resource_cd = rpt->service_resource_cd
              and apr.active_ind = 1
         join d_ope
            where d_ope.seq = 1
         join ope
            where ope.order_id = rpt->orders[d1.seq].order_id
              and ope.task_assay_cd = apr.task_assay_cd
              and ope.service_resource_cd +0 = rpt->service_resource_cd
              and rpt->orders[d1.seq].resource_route_level_flag = 2
         join d_r
            where d_r.seq = 1
         join r
            where r.order_id = rpt->orders[d1.seq].order_id
              and r.task_assay_cd = ptr.task_assay_cd
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join re
            where re.result_id = pr.result_id
              and re.perform_result_id = pr.perform_result_id
              and re.event_type_cd = r.result_status_cd
         join pl_pr
            where pl_pr.person_id = pr.perform_personnel_id
         join pl_re
            where pl_re.person_id = re.event_personnel_id
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id


 ;*      Changes made to allow service resource order sorting:
 ;
 ;* accession_order_sort is now the top-level sort
 ;  When serv_res_sort_ind is passed with a value of 0, we sort on d1.seq as it did 
 ;  before the change.
 ;  When serv_res_sort_ind is passed with a value of 1, we sort on accession_sort_seq
 ;  so that when the same accession is added to a list in consecutive positions, the
 ;  orders on both the accessions are sorted together.
 ;
 ;* ptr_secondary_sort is used to maintain the original functionality of sorting on
 ;  d1.seq when accession_order_sort is not equal to d1.seq. 
 ;  When accession_order_sort = d1.seq, ptr_secondary_sort is set to a constant (1),
 ;  causing no sort to occur at this level. 
         order by
            accession_order_sort
           ,apr.display_sequence
           ,ptr.task_assay_cd
           ,ptr_secondary_sort
           ,r.result_id
           ,pr.repeat_nbr
 
         head accession_order_sort
            o_cnt = evaluate(rpt->serv_res_sort_ind, 0, d1.seq, 1, rpt->orders[d1.seq].accession_start_pos)
            a_cnt = 0
            r_cnt = 0
            idx = 0
            dta_match_found = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            correctflag = " "
            notifyflag = " "
            a_cnt = rpt->orders[o_cnt].assays_cnt
 
         head apr.display_sequence
            row+0
 
         head ptr.task_assay_cd
            row+0
         
         head ptr_secondary_sort
            ;* Determine if discrete task assay qualifies.
            dta_match_found = 0
            if (rpt->procedure_inc_flag = 2)
               ;* Detail (i.e. task assay) level.  Validate
               ;* that the task assay qualifies for the report.
               if (rpt->procs_cnt > 0)
                  for (cnt = 1 to rpt->procs_cnt)
                     if (rpt->procs[cnt].procedure_cd = ptr.task_assay_cd)
                        dta_match_found = 1
                     endif
                  endfor
               endif
            else
               ;* Group (i.e. orderable) level.
               ;* All discrete task assays qualify for the report.
               dta_match_found = 1
            endif
            ;* Validate that task assay wasn't previously loaded
            ;* during cross resource results load.
            if (rpt->orders[o_cnt].assays_cnt > 0)
                for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                    if (rpt->orders[o_cnt].assays[a_cnt]
                      .task_assay_cd = ptr.task_assay_cd
                    and rpt->orders[o_cnt].assays[a_cnt]
                      .cross_resource_ind = 1)
                       dta_match_found = 0
                    endif
                endfor
            endif
            ;* Validate that the task assay was routed to the
            ;* service resource associate with the worklist
            ;* for level 2 orders.
            if (rpt->orders[d1.seq].resource_route_level_flag = 2
            and ope_exists = "N")
               dta_match_found = 0
            endif
            ;* Check for new assay to add to report.
            if (dta_match_found = 1)
               a_cnt = rpt->orders[o_cnt].assays_cnt
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd =
                  ptr.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
               rpt->orders[o_cnt].assays[a_cnt].cross_resource_ind = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_perform_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_status_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_type_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_less_great_flag = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_numeric_raw_value = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_flags = fillstring(10, " ")
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_factor = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_elapse_time = " "

            endif                   
 
         head r.result_id
            if (dta_match_found = 1)
               r_cnt = rpt->orders[o_cnt].assays[a_cnt].results_cnt
            endif
 
         head pr.repeat_nbr
            if (dta_match_found = 1
            and r_exists = "Y"
            and r.result_id > 0.0)
               r_cnt = r_cnt + 1
               if (r_cnt > max_r_cnt)
                  max_r_cnt = r_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
                 .results, r_cnt)
               rpt->orders[o_cnt].assays[a_cnt].results_cnt = r_cnt
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_id = r.result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perform_result_id = pr.perform_result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_status_cd = r.result_status_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_type_cd = pr.result_type_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .less_great_flag = pr.less_great_flag
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .dilution_factor = pr.dilution_factor
               if (pr.dilution_factor > 0.0)
                  dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
                  idx = 1
                  ;* Remove leading zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx + 1
                  endwhile
                  idx = 6
                  ;* Remove trailing zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx - 1
                  endwhile
                  ;* Remove decimal point if not needed
                  if (substring(idx, 1, dilution_val )= ".")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                  endif
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .dilution_value = concat("x", trim(dilution_val,3))
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_tech_id = pr.perform_personnel_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_dt_tm = cnvtdatetime(pr.perform_dt_tm)
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_username = pl_pr.username
               if (r.result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = re.event_personnel_id
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_dt_tm = cnvtdatetime(re.event_dt_tm)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = pl_re.username
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = 0.0
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = " "
               endif
               if (pr.result_type_cd = result_type_text_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = i18n_captions->text
                  if (rpt->text_freetext_ind = 1 and pr.long_text_id > 0.0)
                    rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].text_long_text_id = pr.long_text_id
                    found_curr_text_ind = 1
                  endif
               endif
               if (pr.result_type_cd = result_type_alpha_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.result_value_alpha
               endif
               if (pr.result_type_cd = result_type_numeric_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               if (pr.result_type_cd = result_type_interp_cd)
                  if (trim(pr.result_value_alpha) > " ")
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = pr.result_value_alpha
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = i18n_captions->text
                  endif
               endif
               if (pr.result_type_cd = result_type_date_cd)
				if(LOCALE = localeObjectName)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value =
                    format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
                else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value =
                    format(pr.result_value_dt_tm, "YYYY/MM/DD;;d")
                endif
               endif
               if (pr.result_type_cd = result_type_freetext_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.ascii_text
               endif
               if (pr.result_type_cd = result_type_calc_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               ;*
               ;* Build result flags string
               ;*
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = fillstring(10, " ")
               if (pr.normal_cd > 0.0
               and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                   RESULT_PRCSS_NORMAL_LOW_CDF,
                                   RESULT_PRCSS_ALP_ABNORMAL_CDF))
                  normflag = substring(1,1,normal_disp)
               else
                  normflag = " "
               endif
               if (pr.critical_cd > 0.0
               and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                     RESULT_PRCSS_ALP_CRITICAL_CDF))
                  critflag = substring(1,1,critical_disp)
               else
                  critflag = " "
               endif
               if (pr.review_cd > 0.0
               and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                   RESULT_PRCSS_ALP_REVIEW_CDF))
                  revwflag = substring(1,1,review_disp)
               else
                  revwflag = " "
               endif
               if (pr.linear_cd > 0.0
               and linear_mean = RESULT_PRCSS_LINEAR_CDF)
                  linearflag = substring(1,1,linear_disp)
               else
                  linearflag = " "
               endif
               if (pr.feasible_cd > 0.0
               and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
                  feasflag = substring(1,1,feasible_disp)
               else
                  feasflag = " "
               endif
               if (pr.delta_cd > 0.0
               and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
                  deltaflag = substring(1,1,delta_disp)
               else
                  deltaflag = " "
               endif
               if(pr.notify_cd in(notify_cd, alp_notify_cd))
                  notifyflag = substring(1, 1, notify_disp)
               else
                  notifyflag = " "
               endif
 
               if (rc_exists = "Y")
                  rcommentflag = "Y"
                  rnoteflag = "Y"
               else
                  rcommentflag = "N"
                  rnoteflag = "N"
               endif
               if (r.result_status_cd = corrected_cd)
                  correctflag = "Y"
               else
                  correctflag = "N"
               endif
               if ((pr.nomenclature_id > 0.0) and (pr.long_text_id > 0.0))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind = 1
                  if (rpt->interp_text_ind = 1)
                     found_curr_text_ind = 1
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].text_long_text_id = pr.long_text_id
                  endif
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind = 0
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = bldresultflagstr(normflag,
                 critflag, revwflag, linearflag, feasflag,
                 deltaflag, rcommentflag, rnoteflag, correctflag, notifyflag, 
                 rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text_ind)
            endif
            
         foot pr.repeat_nbr
            row+0
            
         foot r.result_id
            row+0
                  
         foot ptr_secondary_sort
            row+0
 
         foot ptr.task_assay_cd
            row+0

         foot apr.display_sequence
            row+0            
               
         foot accession_order_sort
            row+0
 
         with
            nocounter
           ,outerjoin = d_ope
           ,dontcare = ope
           ,outerjoin = d_r
           ,dontcare = r
           ,dontcare = pr
           ,dontcare = re
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
           
 
         /***********************************************************************
         * Load Current Text results.                                           *
         ***********************************************************************/
         if (found_curr_text_ind = 1)
           select into "nl:"
              d1.seq
             ,d2.seq
             ,d3.seq
             ,d4.seq
             ,lt.long_text_id
  
           from
              (dummyt d1 with seq = value(rpt->orders_cnt))
             ,(dummyt d2 with seq = value(max_a_cnt))
             ,(dummyt d3 with seq = value(max_r_cnt))
             ,long_text lt
 
           plan d1
              where d1.seq <= rpt->orders_cnt
                and rpt->orders[d1.seq].order_id > 0.0
           join d2
              where d2.seq <= rpt->orders[d1.seq].assays_cnt
           join d3
              where d3.seq <= rpt->orders[d1.seq].assays[d2.seq]
                            .results_cnt
           join lt
              where lt.long_text_id = rpt->orders[d1.seq]
                            .assays[d2.seq].results[d3.seq]
                            .text_long_text_id
 
           detail
              if (lt.long_text_id > 0.0)
                if (rpt->orders[d1.seq].assays[d2.seq].results[d3.seq].interp_text_ind = 1)
             	   rpt->orders[d1.seq].assays[d2.seq].results[d3.seq].interp_text = lt.long_text
                else
                   call RTF_TO_TEXT(lt.long_text, 0, 0)
                	rpt->orders[d1.seq].assays[d2.seq].results[d3.seq].result_value = NoRtfText
                endif
              endif
           with
              nocounter
         endif           
 
         if (max_a_cnt = 0)
            go to Load_QC_Info
         endif
 
         if (max_r_cnt = 0)
            go to Load_Prev_Results
         endif
 
      /***********************************************************************
      * Format Numeric & Calculated Current Results                          *
      ***********************************************************************/
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,d_dm.seq
           ,dm_exists = decode(dm.seq, "Y", "N")
           ,dm.service_resource_cd
           ,dm.task_assay_cd
           ,dm.data_map_type_flag
           ,dm.max_digits
           ,dm.min_decimal_places
           ,dm.min_digits
           ,d_rg.seq
           ,rg_exists = decode(rg.seq, "Y", "N")
           ,rg.parent_service_resource_cd
           ,rg.child_service_resource_cd
           ,rg.resource_group_type_cd
           ,rg.root_service_resource_cd
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,(dummyt d_dm with seq = 1)
           ,data_map dm
           ,(dummyt d_rg with seq = 1)
           ,resource_group rg
           ,discrete_task_assay dta
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
              and rpt->orders[d1.seq].assays[d2.seq].results[d3.seq]
                   .result_type_cd in (result_type_numeric_cd,
                                       result_type_calc_cd)
         join dta
            where dta.task_assay_cd = rpt->orders[d1.seq].assays[d2.seq].task_assay_cd
         join d_dm
            where d_dm.seq = 1
         join dm
            where dm.task_assay_cd = rpt->orders[d1.seq]
                             .assays[d2.seq].task_assay_cd
              and dm.data_map_type_flag = 0
              and dm.active_ind = 1
         join d_rg
            where d_rg.seq = 1
         join rg
            where rg.parent_service_resource_cd =
                             dm.service_resource_cd
              and rg.child_service_resource_cd =
                             rpt->service_resource_cd
              and rg.resource_group_type_cd =
                            serv_res_subsection_cd
              and rg.root_service_resource_cd + 0 = 0.0
 
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
 
         head report
            data_map_level = 0
            arg_max_digits = 0
            arg_min_digits = 0
            arg_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
 
         head d1.seq
            o_cnt = d1.seq
 
         head d2.seq
            a_cnt = d2.seq
 
         head d3.seq
            r_cnt = d3.seq
            ;*
            ;* Set default data map parameters
            ;*
            data_map_level = 0
            arg_max_digits = 8
            arg_min_digits = 1
            arg_min_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
 
         detail
            ;*
            ;* Check for exact match on data map
            ;*
            if (data_map_level <= 2
            and dm.service_resource_cd > 0.0
            and dm.service_resource_cd = rpt->service_resource_cd)
               data_map_level = 3
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for subsection level data map
            ;*
            if (data_map_level <= 1
            and dm.service_resource_cd > 0.0
            and rg_exists = "Y"
            and rg.parent_service_resource_cd =
                             dm.service_resource_cd
            and rg.child_service_resource_cd =
                             rpt->service_resource_cd)
               data_map_level = 2
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for default all resources level data map
            ;*
            if (data_map_level = 0
            and dm.service_resource_cd = 0.0)
               data_map_level = 1
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
 
         foot d3.seq
            arg_less_great_flag = rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].less_great_flag
            arg_raw_numeric_result = rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].numeric_raw_value
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_value = uar_AccFormatResultStringSciNote(arg_min_digits,
                                             arg_max_digits,
                                             arg_min_decimal_places,
                                             arg_raw_numeric_result,
                                             arg_less_great_flag,
                                             dta.sci_notation_ind)
         with
            nocounter
           ,outerjoin = d_dm
           ,dontcare = dm
           ,outerjoin = d_rg
           ,dontcare = rg
 
      /***********************************************************************
      * Load Result Comments and Result Footnotes.                           *
      ***********************************************************************/
         if (rpt->result_comments_ind = 0)
            go to Load_Prev_Results
         endif
 
         set max_rc_cnt = 0
         ;*
         ;* Determine if result comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,result_comment rc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
         join rc
            where rc.result_id = rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_id
              and rc.action_sequence >= 0
              and rc.comment_type_cd = comment_type_res_comment_cd
 
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence desc
 
         head d1.seq
            o_cnt = d1.seq
 
         head d2.seq
            a_cnt = d2.seq
 
         head d3.seq
            r_cnt = d3.seq
            cnt = rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt
            cnt = cnt + 1
            if (cnt > max_rc_cnt)
               max_rc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].result_comment, cnt)
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt = cnt
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].comment_type_cd = rc.comment_type_cd
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].long_text_id = rc.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Determine if result footnotes exist.
         ;*
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,result_comment rc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
         join rc
            where rc.result_id = rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_id
              and rc.action_sequence >= 0
              and rc.comment_type_cd = comment_type_res_note_cd
 
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence desc
 
         head d1.seq
            o_cnt = d1.seq
 
         head d2.seq
            a_cnt = d2.seq
 
         head d3.seq
            r_cnt = d3.seq
            cnt = rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt
            cnt = cnt + 1
            if (cnt > max_rc_cnt)
               max_rc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].result_comment, cnt)
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt = cnt
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].comment_type_cd = rc.comment_type_cd
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].long_text_id = rc.long_text_id
 
         with
            nocounter
 
         ;*
         ;* Load result comments and result footnotes
         ;*
            if (max_rc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,d3.seq
              ,d4.seq
              ,lt.long_text_id
 
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_a_cnt))
              ,(dummyt d3 with seq = value(max_r_cnt))
              ,(dummyt d4 with seq = value(max_rc_cnt))
              ,long_text lt
 
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
            join d2
               where d2.seq <= rpt->orders[d1.seq].assays_cnt
            join d3
               where d3.seq <= rpt->orders[d1.seq].assays[d2.seq]
                             .results_cnt
                 and rpt->orders[d1.seq].assays[d2.seq].results[d3.seq]
                             .result_comment_cnt > 0
            join d4
               where d4.seq <= rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_comment_cnt
            join lt
               where lt.long_text_id = rpt->orders[d1.seq]
                             .assays[d2.seq].results[d3.seq]
                             .result_comment[d4.seq].long_text_id
 
            detail
               o_cnt = d1.seq
               a_cnt = d2.seq
               r_cnt = d3.seq
               cnt = d4.seq
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_comment[cnt].comment = lt.long_text
 
            with
               nocounter
         endif
 
      /***********************************************************************
      * Load Previous Results.                                               *
      ***********************************************************************/
      #Load_Prev_Results
         if (rpt->previous_result_ind = 0)
            go to Load_QC_Info
         endif
         select into "nl:"
            d1.seq
           ,d2.seq
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,c.drawn_dt_tm
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
           ,notify_disp = uar_get_code_display(pr.notify_cd)
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,result r
           ,perform_result pr
           ,container c
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join r
            where r.person_id = rpt->orders[d1.seq].person_id
              and r.task_assay_cd =
                rpt->orders[d1.seq].assays[d2.seq].task_assay_cd
              and r.result_status_cd in (verified_cd,
                                         autoverified_cd,
                                         corrected_cd)
              and r.order_id + 0 != rpt->orders[d1.seq].order_id
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join c
            where c.container_id = pr.container_id
              and c.drawn_dt_tm <
                cnvtdatetime(rpt->orders[d1.seq].drawn_dt_tm)
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id
 
         order by
            d1.seq
           ,d2.seq
           ,cnvtdatetime(c.drawn_dt_tm) desc
 
         head d1.seq
            o_cnt = d1.seq
            idx = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            correctflag = " "
            notifyflag = " "
            fnotify = " "
            specimen_age = fillstring(12, " ")
 
         head d2.seq
            a_cnt = d2.seq
            rpt->orders[o_cnt].assays[a_cnt].prev_result_id =
               r.result_id
            rpt->orders[o_cnt].assays[a_cnt].prev_perform_result_id =
               pr.perform_result_id
            rpt->orders[o_cnt].assays[a_cnt].prev_result_status_cd =
               pr.result_status_cd
            rpt->orders[o_cnt].assays[a_cnt].prev_result_type_cd =
               pr.result_type_cd
            rpt->orders[o_cnt].assays[a_cnt].prev_less_great_flag =
               pr.less_great_flag
            rpt->orders[o_cnt].assays[a_cnt].prev_dilution_factor =
               pr.dilution_factor
            if (pr.dilution_factor > 0.0)
               dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
               idx = 1
               ;* Remove leading zeroes
               while(substring(idx, 1, dilution_val) = "0")
                  l = movestring(" ", 1, dilution_val, idx, 1)
                  idx = idx + 1
               endwhile
               idx = 6
               ;* Remove trailing zeroes
               while(substring(idx, 1, dilution_val) = "0")
                  l = movestring(" ", 1, dilution_val, idx, 1)
                  idx = idx - 1
               endwhile
               ;* Remove decimal point if not needed
               if (substring(idx, 1, dilution_val )= ".")
                  l = movestring(" ", 1, dilution_val, idx, 1)
               endif
               rpt->orders[o_cnt].assays[a_cnt].prev_dilution_value =
                 concat("x", trim(dilution_val,3))
            endif
            if (pr.result_type_cd = result_type_text_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 i18n_captions->text
 
               if (rpt->text_freetext_ind = 1 and pr.long_text_id > 0.0)
                 rpt->orders[o_cnt].assays[a_cnt].prev_text_long_text_id = pr.long_text_id
                 found_prev_text_ind = 1
               endif
            endif
            if (pr.result_type_cd = result_type_alpha_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 pr.result_value_alpha
            endif
            if (pr.result_type_cd = result_type_numeric_cd)
               if (pr.less_great_flag > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.result_value_numeric
               else
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.numeric_raw_value
               endif
            endif
            if (pr.result_type_cd = result_type_interp_cd)
               if (trim(pr.result_value_alpha) > " ")
                  rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                    pr.result_value_alpha
               else
                  rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                    i18n_captions->text
               endif
            endif
            if (pr.result_type_cd = result_type_date_cd)
             if(LOCALE = localeObjectName)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
             else
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 format(pr.result_value_dt_tm, "YYYY/MM/DD;;d")
             endif
            endif
            if (pr.result_type_cd = result_type_freetext_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 pr.ascii_text
            endif
            if (pr.result_type_cd = result_type_calc_cd)
               if (pr.less_great_flag > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.result_value_numeric
               else
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.numeric_raw_value
               endif
            endif
            ;*
            ;* Build result flags string
            ;*
            if (pr.normal_cd > 0.0
            and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                RESULT_PRCSS_NORMAL_LOW_CDF,
                                RESULT_PRCSS_ALP_ABNORMAL_CDF))
               normflag = substring(1,1,normal_disp)
            else
               normflag = " "
            endif
            if (pr.critical_cd > 0.0
            and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                  RESULT_PRCSS_ALP_CRITICAL_CDF))
               critflag = substring(1,1,critical_disp)
            else
               critflag = " "
            endif
            if (pr.review_cd > 0.0
            and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                RESULT_PRCSS_ALP_REVIEW_CDF))
               revwflag = substring(1,1,review_disp)
            else
               revwflag = " "
            endif
            if (pr.linear_cd > 0.0
            and linear_mean = RESULT_PRCSS_LINEAR_CDF)
               linearflag = substring(1,1,linear_disp)
            else
               linearflag = " "
            endif
            if (pr.feasible_cd > 0.0
            and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
               feasflag = substring(1,1,feasible_disp)
            else
               feasflag = " "
            endif
            if (pr.delta_cd > 0.0
            and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
               deltaflag = substring(1,1,delta_disp)
            else
               deltaflag = " "
            endif
            if(pr.notify_cd in(notify_cd, alp_notify_cd))
              notifyflag = substring(1, 1, notify_disp)
            else
              notifyflag = " "
            endif
 
            if (rc_exists = "Y")
               rcommentflag = "Y"
               rnoteflag = "Y"
            else
               rcommentflag = "N"
               rnoteflag = "N"
            endif
            if (r.result_status_cd = corrected_cd)
               correctflag = "Y"
            else
               correctflag = "N"
            endif
            if ((pr.nomenclature_id > 0.0) and (pr.long_text_id > 0.0))
               rpt->orders[o_cnt].assays[a_cnt].prev_interp_text_ind = 1
               if (rpt->interp_text_ind = 1)
                  found_prev_text_ind = 1
                  rpt->orders[o_cnt].assays[a_cnt].prev_text_long_text_id = pr.long_text_id
               endif
            else
               rpt->orders[o_cnt].assays[a_cnt].prev_interp_text_ind = 0
            endif
            rpt->orders[o_cnt].assays[a_cnt].prev_result_flags =
              bldresultflagstr(normflag, critflag, revwflag,
              linearflag, feasflag, deltaflag, rcommentflag,
              rnoteflag, correctflag, notifyflag, rpt->orders[o_cnt].assays[a_cnt].prev_interp_text_ind)
            ;*
            ;* Calculate previous result elapsed age.
            ;*
            if (c.drawn_dt_tm > 0)
               specimen_age = cnvtage(c.drawn_dt_tm,
                 rpt->orders[o_cnt].drawn_dt_tm,0)
               ptr = 0
               if (findstring("Years", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_years, "]")
               elseif (findstring("Months", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_months, "]")
               elseif (findstring("Weeks", specimen_age) > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_weeks, "]")
               elseif (findstring("Days", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_days, "]")
               else
                  time_hrs = substring(1, 2, specimen_age)
                  time_mins = substring(4, 2, specimen_age)
                  if (cnvtint(time_hrs) >= 2)
                     rpt->orders[o_cnt].assays[a_cnt]
                       .prev_elapse_time = concat("[",
                       build(cnvtint(time_hrs)), " ",
                       i18n_captions->abbrev_hours, "]")
                  else
                     rpt->orders[o_cnt].assays[a_cnt]
                       .prev_elapse_time = concat("[",
                       build(cnvtint(time_mins)), " ",
                       i18n_captions->abbrev_minutes, "]")
                  endif
               endif
            endif
 
         with
            nocounter
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
 
      /***********************************************************************
      * Format Numeric & Calculated Previous Results                         *
      ***********************************************************************/
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d_dm.seq
           ,dm_exists = decode(dm.seq, "Y", "N")
           ,dm.service_resource_cd
           ,dm.task_assay_cd
           ,dm.data_map_type_flag
           ,dm.max_digits
           ,dm.min_decimal_places
           ,dm.min_digits
           ,d_rg.seq
           ,rg_exists = decode(rg.seq, "Y", "N")
           ,rg.parent_service_resource_cd
           ,rg.child_service_resource_cd
           ,rg.resource_group_type_cd
           ,rg.root_service_resource_cd
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d_dm with seq = 1)
           ,data_map dm
           ,(dummyt d_rg with seq = 1)
           ,resource_group rg
           ,discrete_task_assay dta
 
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
              and rpt->orders[d1.seq].assays[d2.seq]
                   .prev_result_id > 0.0
              and rpt->orders[d1.seq].assays[d2.seq]
                   .prev_result_type_cd in (result_type_numeric_cd,
                                            result_type_calc_cd)
         join dta
            where dta.task_assay_cd = rpt->orders[d1.seq].assays[d2.seq].task_assay_cd
         join d_dm
            where d_dm.seq = 1
         join dm
            where dm.task_assay_cd = rpt->orders[d1.seq]
                             .assays[d2.seq].task_assay_cd
              and dm.data_map_type_flag = 0
              and dm.active_ind = 1
         join d_rg
            where d_rg.seq = 1
         join rg
            where rg.parent_service_resource_cd =
                             dm.service_resource_cd
              and rg.child_service_resource_cd =
                             rpt->service_resource_cd
              and rg.resource_group_type_cd =
                            serv_res_subsection_cd
              and rg.root_service_resource_cd + 0 = 0.0
 
         order by
            d1.seq
           ,d2.seq
 
         head report
            data_map_level = 0
            arg_max_digits = 0
            arg_min_digits = 0
            arg_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
 
         head d1.seq
            o_cnt = d1.seq
 
         head d2.seq
            a_cnt = d2.seq
            ;*
            ;* Set default data map parameters
            ;*
            data_map_level = 0
            arg_max_digits = 8
            arg_min_digits = 1
            arg_min_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
 
         detail
            ;*
            ;* Check for exact match on data map
            ;*
            if (data_map_level <= 2
            and dm.service_resource_cd > 0.0
            and dm.service_resource_cd = rpt->service_resource_cd)
               data_map_level = 3
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for subsection level data map
            ;*
            if (data_map_level <= 1
            and dm.service_resource_cd > 0.0
            and rg_exists = "Y"
            and rg.parent_service_resource_cd =
                             dm.service_resource_cd
            and rg.child_service_resource_cd =
                             rpt->service_resource_cd)
               data_map_level = 2
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for default all resources level data map
            ;*
            if (data_map_level = 0
            and dm.service_resource_cd = 0.0)
               data_map_level = 1
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
 
         foot d2.seq
            arg_less_great_flag = rpt->orders[o_cnt].assays[a_cnt]
              .prev_less_great_flag
            arg_raw_numeric_result = rpt->orders[o_cnt].assays[a_cnt]
              .prev_numeric_raw_value
            rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
              uar_AccFormatResultStringSciNote(arg_min_digits,
                             arg_max_digits,
                             arg_min_decimal_places,
                             arg_raw_numeric_result,
                             arg_less_great_flag,
                             dta.sci_notation_ind)
 
         with
            nocounter
           ,outerjoin = d_dm
           ,dontcare = dm
           ,outerjoin = d_rg
           ,dontcare = rg
 
      /***********************************************************************
      * Load Previous Text results.                                                   *
      ***********************************************************************/
 
      if (found_prev_text_ind = 1)
        select into "nl:"
           d1.seq
          ,d2.seq
          ,d3.seq
          ,d4.seq
          ,lt.long_text_id
 
        from
           (dummyt d1 with seq = value(rpt->orders_cnt))
          ,(dummyt d2 with seq = value(max_a_cnt))
          ,long_text lt
 
        plan d1
           where d1.seq <= rpt->orders_cnt
             and rpt->orders[d1.seq].order_id > 0.0
        join d2
           where d2.seq <= rpt->orders[d1.seq].assays_cnt
        join lt
           where lt.long_text_id = rpt->orders[d1.seq].assays[d2.seq].prev_text_long_text_id
 
        detail
           if (lt.long_text_id > 0.0)
             
             if (rpt->orders[d1.seq].assays[d2.seq].prev_interp_text_ind = 1)
                rpt->orders[d1.seq].assays[d2.seq].prev_interp_text = lt.long_text
             else
                call RTF_TO_TEXT(lt.long_text, 0, 0)
             	rpt->orders[d1.seq].assays[d2.seq].prev_result_value = NoRtfText
             endif
           endif
        with
           nocounter
      endif
 
      /***********************************************************************
      * Load Quality Control (QC) information.                               *
      ***********************************************************************/
      #Load_QC_Info
         ;If we are filtering qc assays at the orderable level, call glb_get_assays_by_cat_serv_res
         if(rpt->procedure_inc_flag = 1 and rpt->filter_qc_assays_ind = 1)
            ;Clear the structures
            set stat = initrec(req250073)
            set stat = initrec(reply250073)
 
            ;Fill out the request
            set req250073->service_resource_cd = rpt->service_resource_cd
            set stat = alterlist(req250073->order_catalog, rpt->procs_cnt)
            for (cnt = 1 to rpt->procs_cnt)
               set req250073->order_catalog[cnt].catalog_cd = rpt->procs[cnt].procedure_cd
            endfor
 
            ;Execute the script
            execute glb_get_assays_by_cat_serv_res with replace("REQUEST", "REQ250073"), replace("REPLY", "REPLY250073")
 
            ;If the script failed, don't fail the report, instead don't filter qc assays.
            if(reply250073->status_data.status = "F")
               set rpt->filter_qc_assays_ind = 0
            endif
         endif
 
         select into "nl:"
           task_assay_disp = uar_get_code_display(arl.task_assay_cd)
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,assay_resource_lot arl
           ,assay_processing_r apr
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].accession_id > 0.0
         join arl
            where arl.lot_id = rpt->orders[d1.seq].lot_id
              and arl.service_resource_cd = rpt->orders[d1.seq].service_resource_cd
              and arl.task_assay_cd > 0.0
              and arl.active_ind = 1
         join apr
            where apr.task_assay_cd = arl.task_assay_cd
              and apr.service_resource_cd = arl.service_resource_cd
              and apr.active_ind = 1
         order by
            d1.seq
           ,apr.display_sequence
 
         head report
            o_cnt = 0
            a_cnt = 0
            dta_match_found = 0
            idx = 0
            pos = 0
 
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
 
         detail
            dta_match_found = 0
 
            if (rpt->procedure_inc_flag = 2)
               ;* Detail (i.e. task assay) level.  Validate
               ;* that the task assay qualifies for the report.
               if (rpt->procs_cnt > 0)
                  for (cnt = 1 to rpt->procs_cnt)
                     if (rpt->procs[cnt].procedure_cd = arl.task_assay_cd)
                        dta_match_found = 1
                     endif
                  endfor
                  for (cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                     if (rpt->orders[o_cnt].assays[cnt].task_assay_cd = arl.task_assay_cd)
                        dta_match_found = 0
                        cnt = rpt->orders[o_cnt].assays_cnt + 1
                     endif
                  endfor
               endif
            elseif(rpt->procedure_inc_flag = 1 and rpt->filter_qc_assays_ind = 1)
               ;Orderable level with filter qc assays indicator set
               ;Check to see if the assay is in the list
               pos = locateval(idx, 1, size(reply250073->assays, 5), arl.task_assay_cd, reply250073->assays[idx].task_assay_cd)
               if(pos > 0)
                  dta_match_found = 1
               endif
            else
               ;* All level and Orderable level w/o qc assay filtering.
               ;* All discrete task assays qualify for the report.
               dta_match_found = 1
            endif
 
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = arl.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp = task_assay_disp
               rpt->orders[o_cnt].assays[a_cnt].qc_abs_low = arl.abs_low
               rpt->orders[o_cnt].assays[a_cnt].qc_abs_high = arl.abs_high
               rpt->orders[o_cnt].assays[a_cnt].qc_result_type_cd = if(apr.qc_result_type_cd > 0.0)
                                                                       apr.qc_result_type_cd
                                                                    else
                                                                       apr.default_result_type_cd
                                                                    endif
            endif
 
         foot d1.seq
            ;* If no task assays qualified for report, skip printing
            ;* of QC accession.
            if (a_cnt = 0)
               rpt->orders[o_cnt].accession_id = 0.0
            endif
         with
            nocounter
 
         ;Clear the data_map structures
         set stat = initrec(req250145)
         set stat = initrec(reply250145)
 
         ;Cycle through the orders and results to fill out the data map request for numeric qc results
         select into "nl:"
            accession_id = rpt->orders[d1.seq].accession_id,
            task_assay_cd = rpt->orders[d1.seq].assays[d2.seq].task_assay_cd
         from (dummyt d1 with seq = value(rpt->orders_cnt)),
              (dummyt d2 with seq = value(max_a_cnt))
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].accession_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
              and rpt->orders[d1.seq].assays[d2.seq].qc_result_type_cd = result_type_numeric_cd
         order by
            accession_id,
            task_assay_cd
         head report
            dm_cnt = 0
            stat = 0
         head accession_id
            row+0
         head task_assay_cd
            dm_cnt = dm_cnt + 1
            if(mod(dm_cnt, 5) = 1)
              stat = alterlist(req250145->qual, dm_cnt + 4)
            endif
            req250145->qual[dm_cnt].accession_id = rpt->orders[d1.seq].accession_id
            req250145->qual[dm_cnt].service_resource_cd = rpt->orders[d1.seq].service_resource_cd
            req250145->qual[dm_cnt].task_assay_cd = rpt->orders[d1.seq]->assays[d2.seq].task_assay_cd
            req250145->qual[dm_cnt].data_map_type_flag = 1
         foot task_assay_cd
            row+0
         foot accession_id
            row+0
         foot report
            stat = alterlist(req250145->qual, dm_cnt)
         with nocounter
 
         ;Only execute glb_get_data_map if items were added to the request
         if(size(req250145->qual, 5) > 0)
           execute glb_get_data_map with replace("REQUEST", "REQ250145"), replace("REPLY", "REPLY250145")
 
           if(reply250145->status_data.status = "F")
             ;* Script failure.
             set reply->status_data.subeventstatus[1].OperationName = "EXECUTE"
             set reply->status_data.subeventstatus[1].OperationStatus = "F"
             set reply->status_data.subeventstatus[1].TargetObjectName = "GLB_GET_DATA_MAP"
             set reply->status_data.subeventstatus[1].TargetObjectValue = "Unable to retrieve data maps."
             go to Exit_Script
           else
             ;Update the reply with the data map
             for(i = 1 to size(reply250145->qual, 5))
               ;locate the order and assay positions within the reply
               set o_pos = locateval(cnt, 1, rpt->orders_cnt, reply250145->qual[i].accession_id, rpt->orders[cnt].accession_id)
 
               if(o_pos != 0)
                  set a_pos = locateval(cnt, 1, rpt->orders[o_pos].assays_cnt,
                          reply250145->qual[i].task_assay_cd, rpt->orders[o_pos].assays[cnt].task_assay_cd)
 
                  if(a_pos != 0)
                    while(o_pos != 0)
                      ;Populate the reply with the data_map
                      if(reply250145->qual[i].data_map_ind = 1)
                        set rpt->orders[o_pos]->assays[a_pos].data_map_ind = 1
                        set rpt->orders[o_pos]->assays[a_pos].max_digits = reply250145->qual[i].max_digits
                        set rpt->orders[o_pos]->assays[a_pos].min_decimal_places = reply250145->qual[i].min_decimal_places
                        set rpt->orders[o_pos]->assays[a_pos].min_digits = reply250145->qual[i].min_digits
                      endif
                      set o_pos = locateval(cnt, o_pos + 1, rpt->orders_cnt, reply250145->qual[i].accession_id,
                                                                                                    rpt->orders[cnt].accession_id)
                    endwhile
                  endif
               endif
             endfor
           endif
         endif
 
      /***********************************************************************
      * Report Preparation                                                   *
      ***********************************************************************/
      #Report_Prep
 
          ; Initializes the report names.
          set rpt->download_name = fillstring(10, " ")
          set rpt->saved_name = fillstring(10, " ")
 
          select into "nl:"
            event_flag = we.event_type_flag
          from
            worklist_event we,
            prsnl ps
          plan we where
            we.worklist_id = rpt->worklist_id and
            we.event_type_flag in (1, 2, 4)
          join ps where
            ps.person_id = we.event_prsnl_id
          order by we.event_dt_tm desc
          head report
            download_ind = 0
            saved_ind = 0
          detail
            if(event_flag = 1 and download_ind = 0)
              if(LOCALE = localeObjectName)
              rpt->download_dt_tm = format(we.event_dt_tm, "@SHORTDATETIME")
              else
               rpt->download_dt_tm = format(we.event_dt_tm, "YYYY/MM/DD HH:MM:SS;;Q")
              endif
              rpt->download_name = substring(1, 10, ps.username)
              download_ind = 1
            elseif (event_flag in (2, 4) and saved_ind = 0)
             if(LOCALE = localeObjectName)
              rpt->saved_dt_tm = format(we.event_dt_tm, "@SHORTDATETIME")
             else
              rpt->saved_dt_tm = format(we.event_dt_tm, "YYYY/MM/DD HH:MM:SS;;Q")
             endif
              if (ps.person_id > 0.0)
              	rpt->saved_name = substring(1, 10, ps.username)
              else
              	rpt->saved_name = substring(1, 10, i18n_captions->system)
              endif
              saved_ind = 1
            endif
          with nocounter
 
          call echorecord(rpt)
 
         ;* Debug logic to dump internal rpt record.
         if (rpt->printer = "DEBUGDUMP")
            set trace callecho
            call echorecord(rpt,"worklist_rpt.dat")
         endif
 
         if (rpt->printer = "MINE")
            set reply->file_name = rpt->printer
         else
            set reply->file_name = concat("CER_PRINT:WORKLIST", format(cnvtdatetime(curdate, curtime3),
                                          "YYYYMMDDHHMMSSCC;;Q"), ".DAT")
            if (request->print_preview_ind = 0)
               set stat = remove(value(reply->file_name))
            endif
         endif
 
         if (rpt->landscape_ind = 1)
            set max_nbr_cols = 180
            set max_nbr_rows = 48
         else
            set max_nbr_cols = 125
            set max_nbr_rows = 60
         endif
 
         ;*
         ;* Load username for report page heading
         ;*
         set username = fillstring(10," ")
         select into "nl:"
            p.username
         from
            prsnl p
         where p.person_id = reqinfo->updt_id
         detail
            username = trim(p.username)
         with
            nocounter
 
         ;*
         ;* Load institution for report title
         ;*
         set vctext->rpt_title = " "
         set serv_res_mean = fillstring(12, " ")
         set serv_res_mean = uar_get_code_meaning(rpt->service_resource_cd)
         if (serv_res_mean = SERV_RES_SUBSECTION_CDF)
            select into "nl:"
               sect.parent_service_resource_cd
              ,dept.parent_service_resource_cd
              ,inst.parent_service_resource_cd
              ,inst_desc =
                uar_get_code_description(inst.parent_service_resource_cd)
 
            from
               resource_group sect
              ,resource_group dept
              ,resource_group inst
 
            plan sect
              where sect.child_service_resource_cd =
                             rpt->service_resource_cd
                and sect.resource_group_type_cd =
                             serv_res_section_cd
                and sect.root_service_resource_cd + 0 = 0.0
                and sect.active_ind = 1
            join dept
              where dept.child_service_resource_cd =
                             sect.parent_service_resource_cd
                and dept.resource_group_type_cd =
                             serv_res_department_cd
                and dept.root_service_resource_cd + 0 = 0.0
                and dept.active_ind = 1
            join inst
              where inst.child_service_resource_cd =
                             dept.parent_service_resource_cd
                and inst.resource_group_type_cd =
                             serv_res_institution_cd
                and inst.root_service_resource_cd + 0 = 0.0
                and inst.active_ind = 1
            detail
               vctext->rpt_title = inst_desc
            with
               nocounter
              ,maxqual(inst, 1)
         endif
         if (serv_res_mean in (SERV_RES_INSTRUMENT_CDF,
                               SERV_RES_BENCH_CDF))
            select into "nl:"
               subsect.parent_service_resource_cd
              ,sect.parent_service_resource_cd
              ,dept.parent_service_resource_cd
              ,inst.parent_service_resource_cd
              ,inst_desc =
                uar_get_code_description(inst.parent_service_resource_cd)
 
            from
               resource_group subsect
              ,resource_group sect
              ,resource_group dept
              ,resource_group inst
 
            plan subsect
              where subsect.child_service_resource_cd =
                             rpt->service_resource_cd
                and subsect.resource_group_type_cd =
                             serv_res_subsection_cd
                and subsect.root_service_resource_cd + 0 = 0.0
                and subsect.active_ind = 1
            join sect
              where sect.child_service_resource_cd =
                             subsect.parent_service_resource_cd
                and sect.resource_group_type_cd =
                             serv_res_section_cd
                and sect.root_service_resource_cd + 0 = 0.0
                and sect.active_ind = 1
            join dept
              where dept.child_service_resource_cd =
                             sect.parent_service_resource_cd
                and dept.resource_group_type_cd =
                             serv_res_department_cd
                and dept.root_service_resource_cd + 0 = 0.0
                and dept.active_ind = 1
            join inst
              where inst.child_service_resource_cd =
                             dept.parent_service_resource_cd
                and inst.resource_group_type_cd =
                             serv_res_institution_cd
                and inst.root_service_resource_cd + 0 = 0.0
                and inst.active_ind = 1
            detail
               vctext->rpt_title = inst_desc
            with
               nocounter
              ,maxqual(inst, 1)
         endif
 
      /***********************************************************************
      * Print Report                                                         *
      ***********************************************************************/
      #Print_Report
         select
         if (rpt->landscape_ind = 1)
            with
               nocounter
              ,nullreport
              ,maxcol = value(max_nbr_cols)
              ,maxrow = value(max_nbr_rows)
              ,compress
              ,landscape
              ,outerjoin = d_a
              ,dontcare = d2
              ,outerjoin = d_r
              ,dontcare = d3
 
         endif
         into value(reply->file_name)
            cur_date = format(curdate, "@SHORTDATE4YR;;Q")
           ,cur_date_locale = format(curdate,"YYYY/MM/DD;;Q")
           ,cur_time = format(curtime, "@TIMENOSECONDS;;M")
           ,d1.seq
           ,accn = uar_fmt_accession(rpt->orders[d1.seq].accession,
                                size(rpt->orders[d1.seq].accession,1))
           ,d_a.seq
           ,d2.seq
           ,d_r.seq
           ,d3.seq
 
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d_a with seq = 1)
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d_r with seq = 1)
           ,(dummyt d3 with seq = value(max_r_cnt))
 
         plan d1
           where d1.seq <= rpt->orders_cnt
         join d_a
           where d_a.seq = 1
         join d2
           where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d_r
           where d_r.seq = 1
         join d3
           where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
 
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
 
      /***********************************************************************
      * Head Report                                                          *
      ***********************************************************************/
         head report
            ;*
            ;* Initialize report variables
            ;*
            spacing = 0                ;Spacing between rows
            l_cap_col = 0              ;Left caption column
            l_txt_col = 0              ;Left text column
            r_cap_col = 0              ;Right caption column
            r_txt_col = 0              ;Right text column
            cap_size = 0               ;Caption size
            cap_pos = 0                ;Caption column position
            accn_col = 0               ;Accession column
            accn_col_len = 0           ;Accession column length
            seq_col = 0                ;sequence column
            seq_col_len = 0            ;Sequence column length
            demog_col = 0              ;Demographics column
            demog_col_len = 0          ;Demographics column length
            loc_col = 0                ;Location column
            loc_col_len = 0            ;Location column length
            coll_col = 0               ;Collected column
            coll_col_len = 0           ;Collected column length
            tech_col = 0               ;Technologist column
            tech_col_len = 0           ;Technologist column length
            proc_col = 0               ;Procedure column
            proc_col_len = 0           ;Procedure column length
            rslt_col = 0               ;Result column
            rslt_col_len = 0           ;Result column length
            perf_col = 0               ;Performing tech column
            perf_col_len = 0           ;Performing tech column length
            verf_col = 0               ;Verifying tech column
            verf_col_len = 0           ;Verifying tech column length
            col_ptr = 0                ;Column pointer
            start_col = 0              ;Start column for lines
            col_len = 0                ;Column length
            txt_len = 0                ;Text length
            new_pg_first_accn_row = 0  ;First accession row on a page
            print_accn_ind = 0         ;Print accession, demog, etc.
            beg_accn_row = 0           ;Beginning accession information row
            curr_accn_row = 0          ;Current accession information row
            curr_det_row = 0           ;Current detail information row
            curr_det_col = 0           ;Current detail information column
            curr_det_len = 0           ;Current detail field length
            min_accn_rows = 0          ;Minimum number of accession info rows
            min_det_rows = 0           ;Minimum number of detail info rows
            comments_col_len = 0       ;Text/Order Comments column length
            r_comments_col_len = 0     ;Result comments column length
            saved_curr_page = 0
            ;*
            ;* Declare Interp Text Print Variables
            ;*
            noflines = 0
            index = 0
            interp_text_width = 72
            ;*
            ;* Print hyphen line macro
            ;*
            macro(print_hyphen_line)
               for (col_ptr = start_col to (start_col + col_len - 1))
                  col col_ptr, "-"
               endfor
            endmacro
 
            ;*
            ;* Print underline macro
            ;*
            macro(print_underline)
               for (col_ptr = start_col to (start_col + col_len - 1))
                  col col_ptr, "_"
               endfor
            endmacro
            ;*
            ;* Print sequence numbers macro
            ;*
            macro(print_seq_number)
               vctext->txt = concat("[",
               trim(substring(TEXTLEN(trim(rpt->orders[o_cnt].sequence_ident,3))-2,3,
               trim(rpt->orders[o_cnt].sequence_ident,3))), "]")
               col seq_col, vctext->txt
            endmacro
            ;*
            ;* Center column text macro
            ;*
 
            macro(center_col_text)
               txt_len = size(vctext->txt)
               if (txt_len > col_len)
                  vctext->txt = substring(1, col_len, vctext->txt)
               endif
               col_ptr = start_col + (col_len / 2) - (txt_len / 2)
               col col_ptr, vctext->txt
            endmacro
 
            ;*
            ;* Initialize new accession macro
            ;*
            macro(init_new_accn)
               ;*
               ;* Confirm new accession demographics will fit on
               ;* report page.
               ;*
               min_accn_rows = 2 * spacing
               if (rpt->result_space_ind = 0)
                  ;* Vertical/Horizontal Worklist.
                  ;* Account for 3 demographic lines.
                  min_accn_rows = min_accn_rows + (3 * spacing)
               elseif (rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
                  ;* Vertical Worksheet.
                  ;* Account for 3 demographic lines.
                  min_accn_rows = min_accn_rows + (3 * spacing)
               elseif (rpt->report_format_ind = 1
               and rpt->result_space_ind = 1)
                  ;* Horizontal worksheet.
                  ;* Account for 2 header lines and 4 demographic lines.
                  min_accn_rows = min_accn_rows + 2 + (4 * spacing)
               endif
               if (rpt->visit_reason_ind = 1
               and trim(rpt->orders[o_cnt].visit_reason,3) > " ")
                  min_accn_rows = min_accn_rows + spacing
               endif
               if (rpt->person_comments_ind = 1
               and rpt->orders[o_cnt].person_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].person_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].person_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               if (rpt->person_comments_ind = 1
               and rpt->orders[o_cnt].encntr_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].encntr_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].encntr_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               if (rpt->order_comments_ind = 1
               and rpt->orders[o_cnt].order_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].order_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].order_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               ;*
               ;* Determine if accession is the first accession to
               ;* print on the page.  If so, the pointers are already
               ;* set.
               ;*
               if (curr_accn_row != new_pg_first_accn_row OR curr_det_row != new_pg_first_accn_row
                   OR saved_curr_page < CURPAGE)
                  if (curr_accn_row >= curr_det_row)
                     ;* Accession data is longer than detail result data
                     if ((curr_accn_row + min_accn_rows) >= max_nbr_rows)
                        break
                     else
                        ;* Set row for printing of new accession.
                        row curr_accn_row
                        row + (2 * spacing)
                        ;* Reset accession and detail pointers
                        beg_accn_row = row
                        curr_accn_row = row
                        curr_det_row = row
                        if (rpt->result_space_ind = 1)
                           curr_det_col = rslt_col
                        else
                           curr_det_col = proc_col
                        endif
                     endif
                  else
                     ;* Detail result data is longer than accession data
                     if ((curr_det_row + min_accn_rows) >= max_nbr_rows)
                        break
                     else
                        ;* Set row for printing of new accession.
                        row curr_det_row
                        row + (2 * spacing)
                        ;* Reset accession and detail pointers
                        beg_accn_row = row
                        curr_accn_row = row
                        curr_det_row = row
                        if (rpt->result_space_ind = 1)
                           curr_det_col = rslt_col
                        else
                           curr_det_col = proc_col
                        endif
                     endif
                  endif
               endif
            ;** Save Current Page.
               saved_curr_page = CURPAGE
            endmacro
 
            ;*
            ;* Print visit reason macro
            ;*
            macro(print_visit_reason)
               if (trim(rpt->orders[o_cnt].visit_reason,3) > " ")
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  vctext->txt = concat(i18n_captions->visit_reason,
                    " ", rpt->orders[o_cnt].visit_reason)
                  vctext->txt = substring(1, comments_col_len,
                    vctext->txt)
                  col accn_col, vctext->txt
               endif
            endmacro
 
            ;*
            ;* Print person comments macro
            ;*
            macro(print_person_comments)
               if (rpt->orders[o_cnt].person_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].person_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].person_comment[cnt]
                        .comment_type_cd = info_type_comment_cd)
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->person_comments)
                     else
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->person_notes)
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .person_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro
 
            ;*
            ;* Print encounter comments macro
            ;*
            macro(print_encntr_comments)
               if (rpt->orders[o_cnt].encntr_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].encntr_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].encntr_comment[cnt]
                        .comment_type_cd = info_type_comment_cd)
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->encounter_comments)
                     else
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->encounter_notes)
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .encntr_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro
 
            ;*
            ;* Print order comments macro
            ;*
            macro(print_order_comments)
               if (rpt->orders[o_cnt].order_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].order_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].order_comment[cnt]
                        .comment_type_cd = comment_type_ord_comment_cd)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].order_mne,3), " ",
                          substring(1, comments_col_len,
                          i18n_captions->order_comments))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].order_mne,3), " ",
                          substring(1, comments_col_len,
                          i18n_captions->order_notes))
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .order_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro
 
            ;*
            ;* Print result comments macro
            ;*
            macro(print_result_comments)
               if (rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                             .result_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_comment_cnt)
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     if (rpt->orders[o_cnt].assays[a_cnt]
                        .results[r_cnt].result_comment[cnt]
                        .comment_type_cd = comment_type_res_comment_cd)
                        vctext->txt = concat(trim(rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp,3), " ",
                          substring(1, r_comments_col_len,
                          i18n_captions->result_comments))
                     else
                        vctext->txt = concat(trim(rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp,3), " ",
                          substring(1, r_comments_col_len,
                          i18n_captions->result_notes))
                     endif
                     row curr_det_row
                     if (rpt->report_format_ind = 1
                     and rpt->result_space_ind = 1)
                        ;* Horizontal Worksheet
                        col rslt_col, vctext->txt
                     else
                        col proc_col, vctext->txt
                     endif
                     col_len = r_comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_comment[cnt].comment, 1,
                       col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_det_row = curr_det_row + spacing
                        if (curr_det_row >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                        row curr_det_row
                        if (rpt->report_format_ind = 1
                        and rpt->result_space_ind = 1)
                           ;* Horizontal Worksheet
                           col rslt_col
                        else
                           col proc_col
                        endif
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro
 
            ;*
            ;* Calculate left column offsets
            ;*
            l_cap_col = 0
            l_txt_col = 0
            cap_size = size(i18n_captions->rpt_report)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_name)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_id)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_test_site)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->saved_by)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->saved_when)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
 
            ;*
            ;* Calculate right caption column offset
            ;*
            r_cap_col = max_nbr_cols - 20
            r_txt_col = max_nbr_cols - 20
            cap_size = size(i18n_captions->rpt_date)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_time)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_by)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_page)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->downloaded_when)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->downloaded_by)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
 
            ;*
            ;* Calculate column positions and lengths
            ;*
            if (rpt->result_space_ind = 0
            and rpt->landscape_ind = 0)
               ;* Vertical/horizontal worklist.  No landscape.
               accn_col = 0
               accn_col_len = 23
 
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 1)
                  accn_col = 6
                  seq_col = 0
                  seq_col_len = 3
               endif
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 21
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 16
                  coll_col = loc_col + loc_col_len + 1
                  if(LOCALE = localeObjectName)
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 48
                  else
                  coll_col_len = 15
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 45
                  endif
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 38
                  coll_col = demog_col + demog_col_len + 1
                  if(LOCALE = localeObjectName)
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 48
                  else
                  coll_col_len = 15
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 45
                  endif
               endif
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 1)
                  proc_col_len = 42
               endif
               if (rpt->report_format_ind = 0)
                  curr_det_len = proc_col_len
               else
                  curr_det_len = 15
               endif
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 0)
                 if(LOCALE = localeObjectName)
                  seq_col = coll_col + 7
                 else
                 seq_col = coll_col + 10
                 endif
                  coll_col_len = coll_col_len + 1
                  proc_col_len = proc_col_len - 4
               endif
               comments_col_len = 75
               r_comments_col_len = 48
            endif
            if (rpt->result_space_ind = 0
            and rpt->landscape_ind = 1)
               ;* Vertical/horizontal worklist.  Landscape.
               accn_col = 0
               accn_col_len = 30
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 1)
                  accn_col = 6
                  seq_col = 0
                  seq_col_len = 3
               endif
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 33
                  coll_col = loc_col + loc_col_len + 1
                  if(LOCALE = localeObjectName)
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 60
                  else
                  coll_col_len = 15
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 57
                  endif
                  comments_col_len = 118
                  r_comments_col_len = 60
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  coll_col = demog_col + demog_col_len + 1
                  if(LOCALE = localeObjectName)
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 94
                  else
                  coll_col_len = 15
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 91
                  endif
                  comments_col_len = 84
                  r_comments_col_len = 94
               endif
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 1)
                if(LOCALE = localeObjectName)
                  if (proc_col_len = 60)
                  proc_col_len = 54
                  else
                  proc_col_len = 88
                  endif
                else
                  if (proc_col_len = 57)
                  proc_col_len = 51
                  else
                  proc_col_len = 85
                  endif
                endif
               endif
               if (rpt->report_format_ind = 0)
                  curr_det_len = proc_col_len
               else
                  curr_det_len = 19
               endif
               if (size(trim(rpt->orders[1].sequence_ident)) > 0
               and rpt->print_seq_left_ind = 0)
                 if(LOCALE = localeObjectName)
                  seq_col = coll_col + 7
                 else
                  seq_col = coll_col + 10
                 endif
                  coll_col_len = coll_col_len + 1
                  proc_col_len = proc_col_len - 4
               endif
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 0)
               ;* Vertical worksheet.  No landscape.
               accn_col = 0
               accn_col_len = 23
               interp_text_col = 49
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  ;* Show location column
                  if(LOCALE = localeObjectName)
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 21
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 15
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
                  else
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 19
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 14
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 15
                  endif
               else
                  ;* Hide location column
                  if(LOCALE = localeObjectName)
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 37
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
                  else
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 34
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 15
                  endif
               endif
               proc_col = coll_col + coll_col_len + 1
               proc_col_len = 15
               rslt_col = proc_col + proc_col_len + 1
               rslt_col_len = 19
               perf_col = rslt_col + rslt_col_len + 1
               perf_col_len = 6
               verf_col = perf_col + perf_col_len + 1
               verf_col_len = 6
               curr_det_len = rslt_col_len
               comments_col_len = 74
               r_comments_col_len = 49
 
               seq_col = 0
               if(LOCALE = localeObjectName)
               seq_col = coll_col + 7
               else
               seq_col = coll_col + 10
               endif
               coll_col_len = coll_col_len + 1
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 1)
               ;* Vertical worksheet.  Landscape.
               accn_col = 0
               accn_col_len = 30
               interp_text_col = 100
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  if(LOCALE = localeObjectName)
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 33
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
                  else
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 30
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 15
                  endif
               else
                  ;* Hide location column
                  if(LOCALE = localeObjectName)
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 74
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
                  else
                   demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 71
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 15
                  endif
               endif
               proc_col = coll_col + coll_col_len + 1
               proc_col_len = 20
               rslt_col = proc_col + proc_col_len + 1
               rslt_col_len = 25
               perf_col = rslt_col + rslt_col_len + 1
               perf_col_len = 6
               verf_col = perf_col + perf_col_len + 1
               verf_col_len = 6
               curr_det_len = rslt_col_len
               comments_col_len = 118
               r_comments_col_len = 60
 			   if(LOCALE = localeObjectName)
               seq_col = coll_col + 7
               else
               seq_col = coll_col + 10
               endif
               coll_col_len = coll_col_len + 1
               proc_col_len = proc_col_len - 4
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 0)
               ;* Horizontal worksheet.  No landscape.
               accn_col = 0
               accn_col_len = 23
               demog_col = accn_col + accn_col_len + 1
               demog_col_len = 27
               tech_col = demog_col + demog_col_len + 1
               tech_col_len = 8
               rslt_col = tech_col + tech_col_len + 1
               rslt_col_len = 15
               curr_det_len = rslt_col_len
               comments_col_len = 51
               r_comments_col_len = 58
               seq_col = rslt_col
               seq_col_len = 3
               rslt_col = seq_col + 6
             endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 1)
               ;* Horizontal worksheet.  Landscape.
               accn_col = 0
               accn_col_len = 23
               demog_col = accn_col + accn_col_len + 1
               demog_col_len = 21
               tech_col = demog_col + demog_col_len + 1
               tech_col_len = 5
               rslt_col = tech_col + tech_col_len + 1
               rslt_col_len = 15
               curr_det_len = rslt_col_len
               comments_col_len = 45
               r_comments_col_len = 121
               seq_col = rslt_col
               seq_col_len = 3
               rslt_col = seq_col + 6
            endif
            if (rpt->spacing_ind = 0)
               spacing = 1
            else
               spacing = 2
            endif
 
      /***********************************************************************
      * Head Page                                                            *
      ***********************************************************************/
         head page
            ;*
            ;* Print page headings
            ;*
            call center(vctext->rpt_title, 0, value(max_nbr_cols))
            col l_cap_col, i18n_captions->rpt_report
            col l_txt_col, i18n_captions->rpt_report_desc
            col r_cap_col, i18n_captions->rpt_date
            if(LOCALE = localeObjectName)
            col r_txt_col, cur_date
            else
            col r_txt_col, cur_date_locale
            endif
            row + 1
            col l_cap_col, i18n_captions->rpt_name
            col l_txt_col, rpt->worklist_ref_disp
            col r_cap_col, i18n_captions->rpt_time
            col r_txt_col, cur_time
            row + 1
            col l_cap_col, i18n_captions->rpt_id
            col l_txt_col, rpt->worklist_alias
            if (rpt->result_space_ind = 1)
               ;* Worksheet
               call center(i18n_captions->rpt_worksheet,
                 0, value(max_nbr_cols))
            else
               ;* Worklist
               call center(i18n_captions->rpt_worklist,
                 0, value(max_nbr_cols))
            endif
            col r_cap_col, i18n_captions->rpt_by
            col r_txt_col, username
            row + 1
            col l_cap_col, i18n_captions->rpt_test_site
            col l_txt_col, rpt->service_resource_disp
 
            if (request->pending_only_ind = 1)
                call center(i18n_captions->pending_only, 0, value(max_nbr_cols))
            endif
 
            col r_cap_col, i18n_captions->rpt_page
            col r_txt_col, curpage "##########;L;I"
            if (rpt->cross_resource_ind = 1)
               row + 1
               cap_size = size(i18n_captions->rpt_cross_test_site)
               col_ptr = max_nbr_cols - cap_size - 5
               col col_ptr, "* ="
               col + 1, i18n_captions->rpt_cross_test_site
            endif
 
 
            row +1
 
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo(r_cap_col)
            call echo(r_txt_col)
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
            call echo("******************************")
 
            col l_cap_col, i18n_captions->saved_by
            col l_txt_col, rpt->saved_name
            col r_cap_col, i18n_captions->downloaded_by
            col r_txt_col, rpt->download_name
 
            row +1
            col l_cap_col, i18n_captions->saved_when
            col l_txt_col, rpt->saved_dt_tm
            col r_cap_col, i18n_captions->downloaded_when
            col r_txt_col, rpt->download_dt_tm
 
            row + 2
 
            ;*
            ;* Print column headings
            ;*
            if (rpt->result_space_ind = 0)
               ;* Vertical/horizontal worklist.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  col loc_col, i18n_captions->location
               endif
               col coll_col, i18n_captions->collected
               col proc_col, i18n_captions->orderable_procedure
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* Vertical worksheet.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  col loc_col, i18n_captions->location
               endif
               col coll_col, i18n_captions->collected
               col proc_col, i18n_captions->procedure
               start_col = rslt_col
               col_len = rslt_col_len
               vctext->txt = i18n_captions->result
               center_col_text
               start_col = perf_col
               col_len = perf_col_len
               vctext->txt = i18n_captions->perf
               center_col_text
               start_col = verf_col
               col_len = verf_col_len
               vctext->txt = i18n_captions->verf
               center_col_text
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal worksheet.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               start_col = tech_col
               col_len = tech_col_len
               vctext->txt = i18n_captions->tech
               center_col_text
            endif
            row + 1
 
            ;*
            ;* Print column heading hyphens
            ;*
            if (rpt->result_space_ind = 0)
               ;* Vertical/horizontal worklist.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  start_col = loc_col
                  col_len = loc_col_len
                  print_hyphen_line
               endif
               start_col = coll_col
               col_len = coll_col_len
               print_hyphen_line
               start_col = proc_col
               col_len = proc_col_len
               print_hyphen_line
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* Vertical worksheet.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1
               or rpt->client_alias_ind = 1)
                  start_col = loc_col
                  col_len = loc_col_len
                  print_hyphen_line
               endif
               start_col = coll_col
               col_len = coll_col_len
               print_hyphen_line
               start_col = proc_col
               col_len = proc_col_len
               print_hyphen_line
               start_col = rslt_col
               col_len = rslt_col_len
               print_hyphen_line
               start_col = perf_col
               col_len = perf_col_len
               print_hyphen_line
               start_col = verf_col
               col_len = verf_col_len
               print_hyphen_line
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal worksheet.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               start_col = tech_col
               col_len = tech_col_len
               print_hyphen_line
            endif
            row + spacing
            ;* Set default row pointers for new page.
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal Worksheet.
               ;* Note: header lines are reprinted.  Adjust begin row
               ;*       to allow for header lines.
               beg_accn_row = row - spacing - 1
               curr_accn_row = beg_accn_row
               curr_det_row = beg_accn_row
            else
               beg_accn_row = row
               curr_accn_row = beg_accn_row
               curr_det_row = beg_accn_row
            endif
            new_pg_first_accn_row = beg_accn_row
            if (rpt->result_space_ind = 1)
               curr_det_col = rslt_col
            else
               curr_det_col = proc_col
            endif
 
      /***********************************************************************
      * Head Order/QC Accession                                              *
      ***********************************************************************/
         head d1.seq
            o_cnt = d1.seq
            ;*
            ;*  Print QC data on a Vertical/Horizontal Worklist.
            ;*
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->result_space_ind = 0)
               ;* New QC accession
               print_accn_ind = 1
               init_new_accn
               ;* Print first QC data row.
               row beg_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
            endif
            ;*
            ;*  Print QC data on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* New QC accession
               print_accn_ind = 1
               init_new_accn
               ;* Print first QC data row.
               row beg_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Set detail information pointers
               curr_det_col = rslt_col
               curr_det_row = beg_accn_row
            endif
 
            ;*
            ;*  Print QC data on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* New QC accession.
               print_accn_ind = 1
               init_new_accn
               ;* Reprint column headers.
               row beg_accn_row
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               start_col = tech_col
               col_len = tech_col_len
               vctext->txt = i18n_captions->tech
               center_col_text
               ;* Reprint column header lines.
               curr_accn_row = curr_accn_row + 1
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               start_col = tech_col
               col_len = tech_col_len
               print_hyphen_line
               ;* Print first QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               start_col = tech_col
               col_len = tech_col_len
               print_underline
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Set detail information pointers
               curr_det_col = rslt_col
               curr_det_row = beg_accn_row
            endif
 
            if(rpt->facility_ind = 1 AND rpt->orders[o_cnt].facility_cd > 0.0)
                print_facility = 1
            else
                print_facility = 0
            endif
 
            if(rpt->nurse_unit_ind = 1 AND rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                print_nurse_unit = 1
            else
                print_nurse_unit = 0
            endif
 
            if(rpt->room_bed_ind = 1 AND size(rpt->orders[o_cnt].roombed_disp) > 0)
                print_roombed = 1
            else
                print_roombed = 0
            endif
 
            if(rpt->client_alias_ind = 1 AND size(rpt->orders[o_cnt].client_alias) > 0)
                print_client_alias = 1
            else
                print_client_alias = 0
            endif
 
            ;*
            ;*  Print Patient Data on a Vertical/Horizontal Worklist.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->result_space_ind = 0)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if(textlen(trim(rpt->orders[o_cnt].accession))>0)
                  	if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
                  	endif
                  endif	
               endif
               if (print_accn_ind = 1)
                  ;* New accession.
                  init_new_accn
                  ;* Print first accession/demographic/etc data row.
                  row beg_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt
                  

                  if(print_facility = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].facility_disp)
                        col loc_col, vctext->txt
                  elseif(print_nurse_unit = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                  elseif(print_roombed = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                  elseif(print_client_alias = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].client_alias)
                        col loc_col, vctext->txt
                  endif

                  if (rpt->orders[o_cnt].drawn_dt_tm > 0 and rpt->collect_dt_tm_ind = 1)
                     if (rpt->print_seq_left_ind = 1 or trim(rpt->orders[o_cnt].sequence_ident) = "")
                      if (LOCALE = localeObjectName)
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "DDMMMYY HHMM;;Q")
                       else
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "YYYY/MM/DD HHMM;;Q")
                       endif
                        col coll_col, vctext->txt
                     else
                       if (LOCALE = localeObjectName)
                     vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "DDMMMYY;;Q")
                       else
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "YYYY/MM/DD;;Q")
                       endif
                        col coll_col, vctext->txt
                        curr_accn_row = curr_accn_row + spacing
                        row curr_accn_row
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "HHMM;;Q")
                        col coll_col, vctext->txt
                        curr_accn_row = curr_accn_row - spacing
                        row curr_accn_row
                     endif
                  endif
                  ;* Print second accession/demographic/etc data row.
                  if ((rpt->ordering_physician_ind = 1) or
                      (rpt->mrn_ind = 1) or
                      (rpt->mrn_ind = 0 and rpt->fin_ind = 1) or
                      (rpt->facility_ind = 1 or rpt->nurse_unit_ind = 1 or rpt->client_alias_ind = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    if (rpt->ordering_physician_ind = 1)
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].provider_name)
                      col accn_col vctext->txt
                    endif
                    if (rpt->mrn_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].med_rec_nbr)
                      col demog_col vctext->txt
                    endif
                    if (rpt->mrn_ind = 0 and rpt->fin_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].fin)
                      col demog_col vctext->txt
                    endif


                    if(print_facility = 1)
                        if(print_nurse_unit = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].nurse_unit_disp)
                                    col loc_col, vctext->txt
                        elseif(print_roombed = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].roombed_disp)
                                    col loc_col, vctext->txt
                        elseif(print_client_alias = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].client_alias)
                                    col loc_col, vctext->txt
                        endif
                    elseif(print_nurse_unit = 1)
                        if(print_roombed = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].roombed_disp)
                                    col loc_col, vctext->txt
                        elseif(print_client_alias = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].client_alias)
                                    col loc_col, vctext->txt
                        endif
                    elseif(print_roombed = 1 and print_client_alias = 1)
                        vctext->txt = substring(1, loc_col_len,
                              rpt->orders[o_cnt].client_alias)
                        col loc_col, vctext->txt
                    endif
 
                  endif
                  ;* Print line for FIN
                  if (rpt->mrn_ind = 1 and rpt->fin_ind = 1 and trim(rpt->orders[o_cnt].fin) > "")
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    vctext->txt = substring(1, demog_col_len,
                      rpt->orders[o_cnt].fin)
                    col demog_col vctext->txt
                  endif
 
                  ;* Print third accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt =
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  vctext->txt = substring(1, accn_col_len, vctext->txt)
                  col accn_col vctext->txt
                  vctext->txt = " "
                  if (rpt->age_ind = 1)
                    vctext->txt = rpt->orders[o_cnt].age
                    if (rpt->sex_ind = 1)
                      vctext->txt = concat(vctext->txt, " ",
                        rpt->orders[o_cnt].sex_disp)
                    endif
                  endif
                  if (rpt->sex_ind = 1 and rpt->age_ind = 0)
                    vctext->txt = rpt->orders[o_cnt].sex_disp
                  endif
                  if (rpt->facility_ind = 0
                  and rpt->nurse_unit_ind = 0 
                  and rpt->client_alias_ind = 0
                  and rpt->room_bed_ind = 1)
                     vctext->txt = concat(vctext->txt, " ",
                       rpt->orders[o_cnt].roombed_disp)
                  endif
                  vctext->txt = substring(1, demog_col_len, vctext->txt)
                  col demog_col vctext->txt
 

                  if(print_facility = 1 and print_nurse_unit = 1)
                      if(print_roombed = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].roombed_disp)
                          col loc_col, vctext->txt
                      elseif(print_client_alias = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                          col loc_col, vctext->txt
                      endif
                  elseif(print_facility = 1 or print_nurse_unit = 1)
                      if(print_roombed = 1 and print_client_alias = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                          col loc_col, vctext->txt
                      endif
                  endif
 
 
                  ;* Print line for RACE and/or Specimen Type
                  if ((rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "") or
                      (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > "") or
                      (print_facility = 1 and print_nurse_unit = 1 and print_roombed = 1 and print_client_alias = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                  endif
                  if (rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "")
                    vctext->txt = substring(1, demog_col_len,
                      rpt->orders[o_cnt].race)
                    col demog_col vctext->txt
                  endif
                  if (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > "")
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].specimen_type_disp)
                      col accn_col vctext->txt
                  endif
                  if(print_facility = 1 and print_nurse_unit = 1 and 
                     print_roombed = 1 and print_client_alias = 1)
                  	vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                  	col loc_col, vctext->txt
                  endif
 
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = proc_col
                  curr_det_row = beg_accn_row
               endif
               ;* Print orderable procedures either vertically
               ;* or horizontally depending on report format.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  if (rpt->report_format_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  endif
                  if (rpt->report_format_ind = 1)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if (((curr_det_col + curr_det_len) > max_nbr_cols)
                     or (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                        curr_det_col = proc_col
                        curr_det_row = curr_det_row + spacing
                     endif
                  endif
               endif
               if (curr_det_row >= max_nbr_rows)
                  break
               endif
               if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                     row curr_det_row
                     if ((print_accn_ind = 1 and rpt->accn_seq_ind = 1)
                     OR (rpt->accn_seq_ind = 0)
                     OR (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                        print_seq_number
                   endif
               endif
               row curr_det_row
               vctext->txt = substring(1, curr_det_len,
                 rpt->orders[o_cnt].order_mne)
               col curr_det_col, vctext->txt
            endif
            ;*
            ;*  Print Patient Data on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if(textlen(trim(rpt->orders[o_cnt].accession))>0)
                  	if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
                  	endif
                  endif
               endif
               if (print_accn_ind = 1)
                  ;* New accession.
                  init_new_accn
                  ;* Print first accession/demographic/etc data row.
                  row beg_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt


                  if(print_facility = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].facility_disp)
                        col loc_col, vctext->txt
                  elseif(print_nurse_unit = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                  elseif(print_roombed = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                  elseif(print_client_alias = 1)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].client_alias)
                        col loc_col, vctext->txt
                  endif


                  if (rpt->orders[o_cnt].drawn_dt_tm > 0 and rpt->collect_dt_tm_ind = 1)
                     if (trim(rpt->orders[o_cnt].sequence_ident) = "")
                       if (LOCALE = localeObjectName)
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "DDMMMYY HHMM;;Q")
                       else
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "YYYY/MM/DD HHMM;;Q")
                       endif
                        col coll_col, vctext->txt
                     else
                      if (LOCALE = localeObjectName)
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "DDMMMYY;;Q")
                      else
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "YYYY/MM/DD;;Q")
                      endif
                       col coll_col, vctext->txt
                       curr_accn_row = curr_accn_row + spacing
                       row curr_accn_row
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "HHMM;;Q")
                       col coll_col, vctext->txt
                       curr_accn_row = curr_accn_row - spacing
                       row curr_accn_row
                     endif
                   endif
 
                  ;* Print second accession/demographic/etc data row.
                  if ((rpt->ordering_physician_ind = 1) or
                      (rpt->mrn_ind = 1) or
                      (rpt->mrn_ind = 0 and rpt->fin_ind = 1) or
                      (rpt->facility_ind = 1 or  rpt->nurse_unit_ind = 1 or rpt->client_alias_ind = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    if (rpt->ordering_physician_ind = 1)
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].provider_name)
                      col accn_col vctext->txt
                    endif
                    if (rpt->mrn_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].med_rec_nbr)
                      col demog_col vctext->txt
                    endif
                    if (rpt->mrn_ind = 0 and rpt->fin_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].fin)
                      col demog_col vctext->txt
                    endif


                    if(print_facility = 1)
                        if(print_nurse_unit = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].nurse_unit_disp)
                                    col loc_col, vctext->txt
                        elseif(print_roombed = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].roombed_disp)
                                    col loc_col, vctext->txt
                        elseif(print_client_alias = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].client_alias)
                                    col loc_col, vctext->txt
                        endif
                    elseif(print_nurse_unit = 1)
                        if(print_roombed = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].roombed_disp)
                                    col loc_col, vctext->txt
                        elseif(print_client_alias = 1)
                            vctext->txt = substring(1, loc_col_len,
                                      rpt->orders[o_cnt].client_alias)
                                    col loc_col, vctext->txt
                        endif
                    elseif(print_roombed = 1 and print_client_alias = 1)
                        vctext->txt = substring(1, loc_col_len,
                              rpt->orders[o_cnt].client_alias)
                            col loc_col, vctext->txt
                    endif

                  endif
                  ;* Print line for FIN
                  if (rpt->mrn_ind = 1 and rpt->fin_ind = 1 and trim(rpt->orders[o_cnt].fin) > "")
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    vctext->txt = substring(1, demog_col_len,
                      rpt->orders[o_cnt].fin)
                    col demog_col vctext->txt
                  endif
                  ;* Print third accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt =
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  vctext->txt = substring(1, accn_col_len, vctext->txt)
                  col accn_col vctext->txt
                  vctext->txt = " "
                  if (rpt->age_ind = 1)
                    vctext->txt = rpt->orders[o_cnt].age
                    if (rpt->sex_ind = 1)
                      vctext->txt = concat(vctext->txt, " ",
                        rpt->orders[o_cnt].sex_disp)
                    endif
                  endif
                  if (rpt->sex_ind = 1 and rpt->age_ind = 0)
                    vctext->txt = rpt->orders[o_cnt].sex_disp
                  endif

                  if (rpt->facility_ind = 0
                      and rpt->nurse_unit_ind = 0 
                      and rpt->client_alias_ind = 0
                      and rpt->room_bed_ind = 1)
                        vctext->txt = concat(vctext->txt, " ",
                         rpt->orders[o_cnt].roombed_disp)
                  endif
 
                  vctext->txt = substring(1, demog_col_len, vctext->txt)
                  col demog_col vctext->txt
 
                  if(print_facility = 1 and print_nurse_unit = 1)
                      if(print_roombed = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].roombed_disp)
                          col loc_col, vctext->txt
                      elseif(print_client_alias = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                          col loc_col, vctext->txt
                      endif
                  elseif(print_facility = 1 or print_nurse_unit = 1)
                      if(print_roombed = 1 and print_client_alias = 1)
                          vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                          col loc_col, vctext->txt
                      endif
                  endif
 
 
                  ;* Print line for RACE and/or Specimen Type
                  if ((rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "") or
                      (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > "") or
                      (print_facility = 1 and print_nurse_unit = 1 and print_roombed = 1 and print_client_alias = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                  endif
                  if (rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "")
                    vctext->txt = substring(1, demog_col_len,
                      rpt->orders[o_cnt].race)
                    col demog_col vctext->txt
                  endif
                  if (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > "")
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].specimen_type_disp)
                      col accn_col vctext->txt
                  endif
                  if(print_facility = 1 and print_nurse_unit = 1 and 
                     print_roombed = 1 and print_client_alias = 1)
                    vctext->txt = substring(1, loc_col_len,
                            rpt->orders[o_cnt].client_alias)
                    col loc_col, vctext->txt
                  endif
 
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = rslt_col
                  curr_det_row = beg_accn_row
               endif
               ;* Check for additional order comments on subsequent orders.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
               endif
            endif
 
            ;*
            ;*  Print Patient Data on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if(textlen(trim(rpt->orders[o_cnt].accession))>0)
                  	if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
	                  endif
	          endif
               endif
               if (print_accn_ind = 1)
                  ;* New accession.  Set row pointers.
                  init_new_accn
                  ;* Reprint column headers.
                  row beg_accn_row
                  col accn_col, i18n_captions->accession
                  col demog_col, i18n_captions->demographics
                  start_col = tech_col
                  col_len = tech_col_len
                  vctext->txt = i18n_captions->tech
                  center_col_text
                  ;* Reprint column header lines.
                  curr_accn_row = curr_accn_row + 1
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  start_col = accn_col
                  col_len = accn_col_len
                  print_hyphen_line
                  start_col = demog_col
                  col_len = demog_col_len
                  print_hyphen_line
                  start_col = tech_col
                  col_len = tech_col_len
                  print_hyphen_line
                  ;* Print first accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt
                  start_col = tech_col
                  col_len = tech_col_len
                  print_underline
                  ;* Print second accession/demographic/etc data row.
                  if ((rpt->orders[o_cnt].drawn_dt_tm > 0 and rpt->collect_dt_tm_ind = 1) or
                      (rpt->mrn_ind = 1) or
                      (rpt->mrn_ind = 0 and rpt->fin_ind = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    if (rpt->orders[o_cnt].drawn_dt_tm > 0 and rpt->collect_dt_tm_ind = 1)
                     if (trim(rpt->orders[o_cnt].sequence_ident) = "")
                      if (LOCALE = localeObjectName)
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "DDMMMYY HHMM;;Q")
                       else
                        vctext->txt = format(
                        cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                        "YYYY/MM/DD HHMM;;Q")
                       endif
                        col coll_col, vctext->txt
                     else
                      if (LOCALE = localeObjectName)
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "DDMMMYY;;Q")
                      else
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "YYYY/MM/DD;;Q")
                      endif
                       col coll_col, vctext->txt
                       curr_accn_row = curr_accn_row + spacing
                       row curr_accn_row
                       vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "HHMM;;Q")
                       col coll_col, vctext->txt
                       curr_accn_row = curr_accn_row - spacing
                       row curr_accn_row
                     endif
                   endif
                    if (rpt->mrn_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].med_rec_nbr)
                      col demog_col vctext->txt
                    endif
                    if (rpt->mrn_ind = 0 and rpt->fin_ind = 1)
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].fin)
                      col demog_col vctext->txt
                    endif
                    ;* Print line for FIN
                    if (rpt->mrn_ind = 1 and rpt->fin_ind = 1 and trim(rpt->orders[o_cnt].fin) > "")
                      curr_accn_row = curr_accn_row + spacing
                      if (curr_accn_row >= max_nbr_rows)
                         break
                      endif
                      row curr_accn_row
                      vctext->txt = substring(1, demog_col_len,
                        rpt->orders[o_cnt].fin)
                      col demog_col vctext->txt
                    endif
 
                  endif
                  ;* Print third accession/demographic/etc data row.
                  if ((rpt->ordering_physician_ind = 1) or
                      (rpt->age_ind = 1) or
                      (rpt->sex_ind = 1 and rpt->age_ind = 0) or
                      (rpt->room_bed_ind = 1))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                    if (rpt->ordering_physician_ind = 1)
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].provider_name)
                      col accn_col vctext->txt
                    endif
                    if (rpt->age_ind = 1)
                      vctext->txt = rpt->orders[o_cnt].age
                      if (rpt->sex_ind = 1)
                        vctext->txt = concat(vctext->txt, " ",
                          rpt->orders[o_cnt].sex_disp)
                      endif
                    endif
                    if (rpt->sex_ind = 1 and rpt->age_ind = 0)
                      vctext->txt = rpt->orders[o_cnt].sex_disp
                    endif
                    if (rpt->room_bed_ind = 1)
                      if (rpt->sex_ind = 1 or rpt->age_ind = 1)
                        vctext->txt = concat(vctext->txt, " ",
                          rpt->orders[o_cnt].roombed_disp)
                      else
                        vctext->txt = rpt->orders[o_cnt].roombed_disp
                      endif
                    endif
                    vctext->txt = substring(1, demog_col_len, vctext->txt)
                    col demog_col vctext->txt
                  endif
                  ;* Print forth accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt =
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  if (rpt->facility_ind = 1
                  and rpt->orders[o_cnt].facility_cd > 0.0)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].facility_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].facility_disp
                     endif
                  endif
                  if (rpt->nurse_unit_ind = 1
                  and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].nurse_unit_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].nurse_unit_disp
                     endif
                  endif
                  
                  if(print_client_alias = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].client_alias)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].client_alias
                     endif
                  endif

                  vctext->txt = substring(1, comments_col_len,
                    vctext->txt)
                  col accn_col vctext->txt
                  vctext->txt = " "
                  ;* Print line for RACE and/or Specimen Type
                  if ((rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "") or
                      (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > ""))
                    curr_accn_row = curr_accn_row + spacing
                    if (curr_accn_row >= max_nbr_rows)
                       break
                    endif
                    row curr_accn_row
                  endif
                  if (rpt->race_ind = 1 and trim(rpt->orders[o_cnt].race) > "")
                    vctext->txt = substring(1, demog_col_len,
                      rpt->orders[o_cnt].race)
                    col demog_col vctext->txt
                  endif
                  if (rpt->specimen_type_ind = 1 and trim(rpt->orders[o_cnt].specimen_type_disp) > "")
                      vctext->txt = substring(1, accn_col_len,
                        rpt->orders[o_cnt].specimen_type_disp)
                      col accn_col vctext->txt
                  endif
 
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = rslt_col
                  curr_det_row = beg_accn_row
               endif
               ;* Check for additional order comments on subsequent orders.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
               endif
            endif
 
      /***********************************************************************
      * Head Discrete Task Assay List                                        *
      ***********************************************************************/
         head d2.seq
            begin_seq_print_accn_ind = print_accn_ind
            if (rpt->orders[o_cnt].assays_cnt > 0)
               a_cnt = d2.seq
               ;*
               ;*  Print QC discrete task assays on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
 
                  if (print_accn_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row >= max_nbr_rows)
                     break
                     new_pg_first_accn_row = 0
                  endif
                  row curr_det_row
                  vctext->txt = substring(1, proc_col_len,
                     rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  col proc_col, vctext->txt
                 endif
               ;*
               ;*  Print Patient discrete task assays on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
                  if (print_accn_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row >= max_nbr_rows)
                     break
                     new_pg_first_accn_row = 0
                  endif
                  row curr_det_row
                  if (rpt->orders[o_cnt].assays[a_cnt]
                             .cross_resource_ind = 1)
                     col proc_col - 1, "*"
                  endif
                  row curr_det_row
                  vctext->txt = substring(1, proc_col_len,
                    rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  col proc_col, vctext->txt
               endif
               ;* Print sequence number
                  row curr_det_row
                  if (trim(rpt->orders[o_cnt].sequence_ident,3) > " " 
                  and rpt->report_format_ind = 0)
                  if (((begin_seq_print_accn_ind = 1 and rpt->accn_seq_ind = 1)
                    OR (rpt->accn_seq_ind = 0)
                    OR (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                    and (a_cnt = 1))
                      print_seq_number
                  endif
               endif
            endif
 
      /***********************************************************************
      * Head Results List                                                    *
      ***********************************************************************/
         head d3.seq
            if (rpt->orders[o_cnt].assays_cnt > 0)
               ;*
               ;*  Print QC result underline on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  start_col = perf_col
                  col_len = perf_col_len
                  print_underline
                  start_col = verf_col
                  col_len = verf_col_len
                  print_underline
               endif
               ;*
               ;*  Print QC Range on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0 and rpt->report_format_ind = 0 and rpt->result_space_ind = 1 and
                   rpt->orders[o_cnt].assays[a_cnt].qc_result_type_cd = result_type_numeric_cd and rpt->qc_ranges_ind = 1)
                  curr_det_row = curr_det_row + spacing
                  if (curr_det_row >= max_nbr_rows)
                     break
                     new_pg_first_accn_row = 0
                  endif
 
                  if(rpt->orders[d1.seq].assays[d2.seq].data_map_ind = 1)
                     max_digits = rpt->orders[d1.seq].assays[d2.seq].max_digits
                     min_digits = rpt->orders[d1.seq].assays[d2.seq].min_digits
                     min_decimal_places = rpt->orders[d1.seq].assays[d2.seq].min_decimal_places
                  else
                     max_digits = 8
                     min_digits = 1
                     min_decimal_places = 0
                  endif
 
                  vctext->txt = build2(i18n_captions->qc_range, " ",
                           build2(uar_AccFormatResultStringSciNote(min_digits, max_digits, min_decimal_places,
                                                rpt->orders[d1.seq].assays[d2.seq].qc_abs_low, 0, 0),
                                  " - ",
                                  uar_AccFormatResultStringSciNote(min_digits, max_digits, min_decimal_places,
                                                rpt->orders[d1.seq].assays[d2.seq].qc_abs_high, 0, 0)))
                  vctext->txt = substring(1, max_nbr_cols - proc_col, vctext->txt)
 
                  row curr_det_row
                  col proc_col, vctext->txt
               endif
               ;*
               ;*  Print Patient results on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                  r_cnt = d3.seq
                  if (r_cnt > 1)
                     ;* Repeat.  Update row.
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  row curr_det_row
                  if (rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_factor > 0.0)
                     vctext->txt = concat(
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_value,3), " ",
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].dilution_value,3), " ",
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_flags,3))
                  else
                     vctext->txt = concat(
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_value,3), " ",
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_flags,3))
                  endif
                  vctext->txt = substring(1, rslt_col_len,
                    vctext->txt)
                  col rslt_col, vctext->txt
                  vctext->txt = substring(1, perf_col_len,
                    rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .perf_username)
                  col perf_col, vctext->txt
                  if (rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                     vctext->txt = substring(1, verf_col_len,
                       rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .verf_username)
                     col verf_col, vctext->txt
                  endif
                  if (textlen(trim(rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text, 3)) > 0 )
                     call RTF_TO_TEXT(rpt->orders[o_cnt].assays[a_cnt].results[r_cnt].interp_text, 1, interp_text_width)
                     noflines = size(tmptext->qual, 5)
                     for (index = 1 to noflines)
                        curr_det_row = curr_det_row + spacing
                        if (curr_det_row >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                        row curr_det_row
                        if (index = 1)
                           vctext->txt = concat(i18n_captions->interp_text_flag, tmptext->qual[index].text)
                           col interp_text_col, vctext->txt
                        else
                           vctext->txt = tmptext->qual[index].text
                           col interp_text_col+3, vctext->txt
                        endif
                     endfor
                  endif
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0
                  and r_cnt = rpt->orders[o_cnt].assays[a_cnt]
                             .results_cnt)
                     ;* Print previous result after last repeat.
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col rslt_col, vctext->txt
                  endif
 
                  if (textlen(trim(rpt->orders[o_cnt].assays[a_cnt].prev_interp_text, 3)) > 0 )
                     call RTF_TO_TEXT(rpt->orders[o_cnt].assays[a_cnt].prev_interp_text, 1, interp_text_width)
                     noflines = size(tmptext->qual, 5)
                     for (index = 1 to noflines)
                        curr_det_row = curr_det_row + spacing
                        if (curr_det_row >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                        row curr_det_row
                        if (index = 1)
                           vctext->txt = concat(i18n_captions->interp_text_flag, tmptext->qual[index].text)
                           col interp_text_col, vctext->txt
                        else
                           vctext->txt = tmptext->qual[index].text
                           col interp_text_col+3, vctext->txt
                        endif
                     endfor
                  endif
               endif
               ;*
               ;*  Print Patient result underline on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  start_col = perf_col
                  col_len = perf_col_len
                  print_underline
                  start_col = verf_col
                  col_len = verf_col_len
                  print_underline
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                     ;* Print previous result
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col rslt_col, vctext->txt
                  endif
               endif
               ;*
               ;*  Print QC result underline on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  begin_seq_print_accn_ind = print_accn_ind
                  if (print_accn_ind = 0)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if ((((curr_det_col + curr_det_len) > max_nbr_cols)
                     or (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident) and (a_cnt = 1)))
                        curr_det_col = rslt_col
                        curr_det_row = curr_det_row + (2 * spacing)
                     endif
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row != beg_accn_row
                  and curr_det_col != rslt_col)
                     ;* Reset current detail row for next result
                     if (rpt->previous_result_ind = 1)
                        curr_det_row = curr_det_row - (2 * spacing) - 1
                     else
                        curr_det_row = curr_det_row - spacing - 1
                     endif
                  endif
                  if (rpt->previous_result_ind = 1)
                     min_det_rows = 1 + (2 * spacing)
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  else
                     min_det_rows = 1 + spacing
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  ;* Print sequence number
                     row curr_det_row
                     if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                       if (((begin_seq_print_accn_ind = 1 and rpt->accn_seq_ind = 1)
                       OR (rpt->accn_seq_ind = 0)
                       OR (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                       and (a_cnt = 1))
                         print_seq_number
                       endif
                     endif
                  ;* Print discrete task assay column header
                  start_col = curr_det_col
                  col_len = curr_det_len
                  vctext->txt = substring(1, curr_det_len,
                    rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  center_col_text
                  ;* Print discrete task assay column hyphen line.
                  curr_det_row = curr_det_row + 1
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_hyphen_line
                  ;* Print result line
                  curr_det_row = curr_det_row + spacing
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  if (rpt->previous_result_ind = 1)
                     curr_det_row = curr_det_row + spacing
                  endif
               endif
               ;*
               ;*  Print Patient results on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                  ;* Only display original result in the event repeats
                  ;* exist when printing a Horizontal worksheet. Designate
                  ;* that repeats exist with (r).
                  r_cnt = d3.seq
                  if (r_cnt = 1)
                     begin_seq_print_accn_ind = print_accn_ind
                     if (print_accn_ind = 0)
                        curr_det_col = curr_det_col + curr_det_len + 1
                        if (((curr_det_col + curr_det_len) > max_nbr_cols)
                        or ((rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident) and (a_cnt = 1)))
                        	curr_det_col = rslt_col
                        	curr_det_row = curr_det_row + (2 * spacing)
                        endif
                     else
                        print_accn_ind = 0
                     endif
                     if (curr_det_row != beg_accn_row
                     and curr_det_col != rslt_col)
                        ;* Reset current detail row for next result
                        if (rpt->previous_result_ind = 1)
                           curr_det_row =
                             curr_det_row - (2 * spacing) - 1
                        else
                           curr_det_row =
                             curr_det_row - spacing - 1
                        endif
                     endif
                     if (rpt->previous_result_ind = 1)
                        min_det_rows = 1 + (2 * spacing)
                        if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                     else
                        min_det_rows = 1 + spacing
                        if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                     endif
                     ;* Print sequence number
                     row curr_det_row
                     if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                       if (((begin_seq_print_accn_ind = 1 and rpt->accn_seq_ind = 1)
                       OR (rpt->accn_seq_ind = 0)
                       OR (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                       and (a_cnt = 1))
                         print_seq_number
                       endif
                     endif
                     ;* Print discrete task assay column header.
                     start_col = curr_det_col
                     col_len = curr_det_len
                     if (rpt->orders[o_cnt].assays[a_cnt]
                             .cross_resource_ind = 1)
                        vctext->txt = concat("*", substring(1,
                          curr_det_len, rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp))
                     else
                        vctext->txt = substring(1, curr_det_len,
                          rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                     endif
                     center_col_text
                     ;* Print discrete task assay column hyphen line.
                     curr_det_row = curr_det_row + 1
                     row curr_det_row
                     start_col = curr_det_col
                     col_len = curr_det_len
                     print_hyphen_line
                     ;* Print result
                     curr_det_row = curr_det_row + spacing
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt].results_cnt = 1)
                        ;* No repeats exist.  Build result value.
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .results[r_cnt].dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3))
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3))
                        endif
                     else
                        ;* Repeats exist. Append (r) to result.
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .results[r_cnt].dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3), " ",
                             i18n_captions->repeats)
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3), " ",
                             i18n_captions->repeats)
                        endif
                     endif
                     vctext->txt = substring(1, curr_det_len,
                       vctext->txt)
                     col curr_det_col, vctext->txt
                     if (rpt->previous_result_ind = 1
                     and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                        ;* Print previous result
                        curr_det_row = curr_det_row + spacing
                        row curr_det_row
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .prev_dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_dilution_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_flags,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_elapse_time,3))
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_flags,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_elapse_time,3))
                        endif
                        vctext->txt = substring(1, rslt_col_len,
                          vctext->txt)
                        col curr_det_col, vctext->txt
                     elseif (rpt->previous_result_ind = 1
                     and rpt->orders[o_cnt].assays[a_cnt]
                              .prev_result_id = 0.0)
                        curr_det_row = curr_det_row + spacing
                     endif
                  endif
               endif
               ;*
               ;*  Print Patient result underline on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  begin_seq_print_accn_ind = print_accn_ind
                  if (print_accn_ind = 0)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if (((curr_det_col + curr_det_len) > max_nbr_cols)
                     or ((rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident) and (a_cnt = 1)))
                        curr_det_col = rslt_col
                        curr_det_row = curr_det_row + (2 * spacing)
                     endif
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row != beg_accn_row
                  and curr_det_col != rslt_col)
                     ;* Reset current detail row for next result
                     if (rpt->previous_result_ind = 1)
                        curr_det_row = curr_det_row - (2 * spacing) - 1
                     else
                        curr_det_row = curr_det_row - spacing - 1
                     endif
                  endif
                  if (rpt->previous_result_ind = 1)
                     min_det_rows = 1 + (2 * spacing)
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  else
                     min_det_rows = 1 + spacing
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  ;* Print sequence number
                  row curr_det_row
                  if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                       if (((begin_seq_print_accn_ind = 1 and rpt->accn_seq_ind = 1)
                       OR (rpt->accn_seq_ind = 0)
                       OR (rpt->orders[o_cnt].sequence_ident != rpt->orders[o_cnt - 1 ].sequence_ident))
                       and (a_cnt = 1))
                         print_seq_number
                       endif
                   endif
                  ;* Print discrete task assay column header.
                  start_col = curr_det_col
                  col_len = curr_det_len
                  if (rpt->orders[o_cnt].assays[a_cnt]
                          .cross_resource_ind = 1)
                     vctext->txt = concat("*", substring(1,
                       curr_det_len, rpt->orders[o_cnt]
                       .assays[a_cnt].task_assay_disp))
                  else
                     vctext->txt = substring(1, curr_det_len,
                       rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  endif
                  center_col_text
 
                  ;* Print discrete task assay column hyphen line.
                  curr_det_row = curr_det_row + 1
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_hyphen_line
                  ;* Print result line
                  curr_det_row = curr_det_row + spacing
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                     ;* Print previous result
                     curr_det_row = curr_det_row + spacing
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col curr_det_col, vctext->txt
                  elseif (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                           .prev_result_id = 0.0)
                     curr_det_row = curr_det_row + spacing
                  endif
               endif
            endif
 
      /***********************************************************************
      * Foot Results List                                                    *
      ***********************************************************************/
         foot d3.seq
            row+0
 
      /***********************************************************************
      * Foot Discrete Task Assay List                                        *
      ***********************************************************************/
         foot d2.seq
            row+0
 
      /***********************************************************************
      * Foot Order/QC Accession List                                         *
      ***********************************************************************/
         foot d1.seq
            ;*
            ;*  Print Patient result comments on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->orders[o_cnt].assays_cnt > 0
            and rpt->result_comments_ind = 1)
               for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                  if (rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                     for (r_cnt = 1 to rpt->orders[o_cnt]
                             .assays[a_cnt].results_cnt)
                        print_result_comments
                     endfor
                  endif
               endfor
            endif
            ;*
            ;*  Print Patient result comments on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->orders[o_cnt].assays_cnt > 0
            and rpt->result_comments_ind = 1)
               for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                  if (rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                     for (r_cnt = 1 to rpt->orders[o_cnt]
                             .assays[a_cnt].results_cnt)
                        print_result_comments
                     endfor
                  endif
               endfor
            endif
 
      /***********************************************************************
      * Foot Report                                                          *
      ***********************************************************************/
         foot report
            ;*
            ;* Print blank lines for notations at the end of the report.
            ;*
            if (rpt->blank_lines > 0)
               if (curr_accn_row >= curr_det_row)
                  min_accn_rows = spacing + (rpt->blank_lines * spacing)
                  if ((curr_accn_row + min_accn_rows) >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
               else
                  min_det_rows = spacing + (rpt->blank_lines * spacing)
                  if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                     break
                  endif
                  row curr_det_row
               endif
               curr_accn_row = row
               curr_det_row = row
               for (cnt = 1 to rpt->blank_lines)
                  curr_accn_row = curr_accn_row + spacing
                  curr_det_row = curr_accn_row
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  start_col = 0
                  col_len = max_nbr_cols - 1
                  print_underline
               endfor
            endif
 
            ;*
            ;* Print end of report line
            ;*
            if (curr_accn_row >= curr_det_row)
               if ((curr_accn_row + 2) >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               row + 2
            else
               if ((curr_det_row + 2) >= max_nbr_rows)
                  break
               endif
               row curr_det_row
               row + 2
            endif
            call center(uar_i18ngetmessage(i18nHandle,
              "end_report", "***** END OF REPORT *****"),
              0, value(max_nbr_cols))
 
         with
            nocounter
           ,nullreport
           ,maxcol = value(max_nbr_cols)
           ,maxrow = value(max_nbr_rows)
           ,outerjoin = d_a
           ,dontcare = d2
           ,outerjoin = d_r
           ,dontcare = d3
 
         ;*
         ;* Spool report to the printer
         ;*
         if (rpt->printer != "MINE"
         and rpt->printer != "DEBUG"
         and rpt->printer != "DEBUGDUMP")
            if (request->print_preview_ind = 0)
                if (rpt->landscape_ind = 1)
                   set spool = value(reply->file_name) value(rpt->printer)
                   with landscape, copy = value(rpt->copies)
                else
                   set spool = value(reply->file_name) value(rpt->printer)
                   with copy = value(rpt->copies)
                endif
            endif
         endif
 
      /***********************************************************************
      * If running from Operations, autosave the worklist.                   *
      ***********************************************************************/
         if ( (trim(request->batch_selection) > " " or request->group_cnt > 0)
         and (print_grp->group[grp_nbr].ref_data_loaded_ind = 0
         and rpt->orders_cnt > 0))
            ;*
            ;* Call GLB_ADD_WKLST_ELE
            ;*
            set req250085->worklist_prsnl_id = 0.0  ;Not used
            set req250085->status_cd = 0.0          ;Not used
            set req250085->service_resource_cd =
              rpt->service_resource_cd
            set req250085->worklist_ref_id =
              rpt->worklist_ref_id
            if (rpt->result_space_ind = 1)
               ;* Worksheet
               set req250085->worklist_type_flag = 0
            else
               ;* Worklist
               set req250085->worklist_type_flag = 1
            endif
            set req250085->worklist_alias =
              rpt->worklist_alias
            if (rpt->include_flag != 1)
               case (rpt->procedure_inc_flag)
                 of 1:  ;* Group (i.e. orderable level) procedures
                    if (rpt->procs_cnt > 0)
                       set stat =
                         alterlist(req250085->components, rpt->procs_cnt)
                       for (cnt = 1 to rpt->procs_cnt)
                          set req250085->components[cnt].worklist_seq = cnt
                          set req250085->components[cnt].catalog_cd =
                            rpt->procs[cnt].procedure_cd
                          set req250085->components[cnt].task_assay_cd = 0.0
                       endfor
                    endif
                 of 2:  ;* Detail (i.e. task assay level) procedures
                    if (rpt->procs_cnt > 0)
                       set stat =
                         alterlist(req250085->components, rpt->procs_cnt)
                       for (cnt = 1 to rpt->procs_cnt)
                          set req250085->components[cnt].worklist_seq = cnt
                          set req250085->components[cnt].catalog_cd = 0.0
                          set req250085->components[cnt].task_assay_cd =
                            rpt->procs[cnt].procedure_cd
                       endfor
                    endif
                 else   ;* All procedures
                    set stat = alterlist(req250085->components, 1)
                    set req250085->components[1].worklist_seq = 1
                    set req250085->components[1].catalog_cd = 0.0
                    set req250085->components[1].task_assay_cd = 0.0
               endcase
            endif
            set stat = alterlist(req250085->orders, rpt->orders_cnt)
            for (cnt = 1 to rpt->orders_cnt)
               set req250085->orders[cnt].order_id =
                 rpt->orders[cnt].order_id
               set req250085->orders[cnt].accession_id =
                 rpt->orders[cnt].accession_id
               set req250085->orders[cnt].sequence = cnt
               set req250085->orders[cnt].sequence_ident =
                 rpt->orders[cnt].sequence_ident
            endfor
            execute GLB_ADD_WKLST_ELE with
              replace(request, req250085),
              replace(reply, reply250085)
            if (reply250085->status_data.status = "F")
               ;* Script failure.
               set reply->status_data.subeventstatus[1]
                 .OperationName = "EXECUTE"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "GLB_ADD_WKLST_ELE"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue =
                 "Unable to save worklist."
               go to Exit_Script
            endif
         endif
 
      /***********************************************************************
      * Next worklist.                                                       *
      ***********************************************************************/
      #Next_Worklist
         ;*
         ;* Check for creation of additional worklists
         ;*
         set grp_nbr = grp_nbr + 1
         if (grp_nbr <= print_grp->group_cnt)
            go to Process_Worklistn ;;Solution_Test/script/Centers Custom Programming Services/glb_rpt_worklist_chem_gb/glb_rpt_worklist_chem_gb.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-2000 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/
/*****************************************************************************

        Source file name:       glb_rpt_worklist_chem_gb.prg
        Object name:            glb_rpt_worklist_chem_gb
        Request #:              250197

        Product:                General Lab
        Product Team:           PathNet
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Print a worklist or worksheet.

        Tables read:            assay_processing_r
                                assay_resource_lot
                                code_value
                                container
                                data_map
                                encntr_alias
                                encntr_info
                                encounter
                                long_text
                                orders
                                order_comment
                                order_procedure_exception
                                order_serv_res_container
                                perform_result
                                person
                                person_info
                                profile_task_r
                                prsnl
                                resource_group
                                result
                                result_comment
                                result_event
                                worklist_group
                                worklist_ref
                                [Call to GLB_GET_WKLST_REF]
                                worklist_ref
                                worklist
                                [Call to GLB_GET_WKLST_REF_DETAILS]
                                accession,
                                worklist_ref_priority,
                                worklist_ref_procedure,
                                worklist_ref_qc
                                [Call to GLB_GET_ELIG_ALL]
                                accession_order_r
                                code_value
                                encntr_alias
                                orders
                                order_laboratory
                                order_procedure_exception
                                order_serv_res_container
                                pending_collection
                                person
                                profile_task_r
                                resource_group
                                worklist
                                worklist_order_r
                                worklist_ref
                                [Call to GLB_GET_WKLST_QC_ACCNS]            
                                accession
                                code_value
                                control_lot
                                control_material
                                resource_accession_r
                                resource_group
                                resource_lot_r
                                worklist_ref_qc

        Tables updated:         [Call to GLB_ADD_WKLST_ELE]
                                worklist         
                                worklist_elements         
                                worklist_order_r
                                worklist_accession_r

        Executing from:         Worklist Request or Operations

        Special Notes:          This script can be run from a client app
                                or from Operations.  If running from
                                Operations, the request->batch_selection
                                should contain the description associated
                                with a given set of worklist operation
                                parameters from code set 1950.
                                
*****************************************************************************/
/*~DB~************************************************************************
      *                      GENERATED MODIFICATION CONTROL LOG              *
      ************************************************************************
      *                                                                      *
      *Mod Date     Engineer             Comment                             *
      *--- -------- -------------------- ----------------------------------- *
      *000 03/22/00 Hal Patchen          Initial Release                     *
      *001 12/02/02 Nirmal Sanganee      Extra Join on Profile_Task_Assay    *
      *002 09/01/06 Steve Harlow         Feature 107371 Correct age in German*
      *   Since this will be on a custom package we can hardcode the age.
      *   Per client manager Roland Sasone 9/4/2006:
      *   I talked to the client and that's how they would like it:
      *      Hours: "Std." 
      *      Day(s): "Tag(e)" (remark: "Tag" is singular, "Tage" is plural) 
      *      Month(s): "Mon."
      *      Year(s): "Jahr(e)" (remark: "Jahr" is singular, "Jahre" is plural)
      *Note: Had to rename object in able to check into SOLUTION_TEST.
  ~DE~************************************************************************

~END~ ******************  END OF ALL MODCONTROL BLOCKS  *********************/

         drop program GLB_RPT_WORKLIST_CHEM_GB:dba go
         create program GLB_RPT_WORKLIST_CHEM_GB:dba

      /***********************************************************************
      * Internationalization                                                 *
      ***********************************************************************/
      ;* i18n include file                                                   
%i cclsource:i18n_uar.inc                                             

      ;* Initialize variable that keeps handle to i18n data                  
      set i18nHandle = 0                                                    

      ;* Call uar_i18nlocalizationinit                                       
      set h = uar_i18nlocalizationinit(i18nHandle, curprog, "", curcclrev)

      record i18n_captions 
      (
         1  rpt_report                 = vc
         1  rpt_report_desc            = vc
         1  rpt_name                   = vc
         1  rpt_id                     = vc
         1  rpt_test_site              = vc
         1  rpt_worklist               = vc
         1  rpt_worksheet              = vc
         1  rpt_date                   = vc
         1  rpt_time                   = vc
         1  rpt_by                     = vc
         1  rpt_page                   = vc
         1  rpt_cross_test_site        = vc
         1  accession                  = vc
         1  demographics               = vc
         1  location                   = vc
         1  collected                  = vc
         1  procedure                  = vc
         1  orderable_procedure        = vc
         1  result                     = vc
         1  tech                       = vc
         1  perf                       = vc
         1  verf                       = vc
         1  control                    = vc
         1  lot                        = vc
         1  dr                         = vc
         1  visit_reason               = vc
         1  person_comments            = vc
         1  person_notes               = vc
         1  encounter_comments         = vc
         1  encounter_notes            = vc
         1  order_comments             = vc
         1  order_notes                = vc
         1  result_comments            = vc
         1  result_notes               = vc
         1  text                       = vc
         1  repeats                    = vc
         1  abbrev_years               = vc
         1  abbrev_months              = vc
         1  abbrev_weeks               = vc
         1  abbrev_days                = vc
         1  abbrev_hours               = vc
         1  abbrev_minutes             = vc
      )
      
      set i18n_captions->rpt_report = uar_i18ngetmessage(i18nHandle, 
        "rpt_report", "REPORT:")
      set i18n_captions->rpt_report_desc = 
        uar_i18ngetmessage(i18nHandle, 
        "rpt_report_desc", "GLB_RPT_WORKLIST")
      set i18n_captions->rpt_name = uar_i18ngetmessage(i18nHandle, 
        "rpt_name", "NAME:")
      set i18n_captions->rpt_id = uar_i18ngetmessage(i18nHandle, 
        "rpt_id", "ID:")
      set i18n_captions->rpt_test_site = uar_i18ngetmessage(i18nHandle, 
        "rpt_test_site", "TEST SITE:")
      set i18n_captions->rpt_worklist = uar_i18ngetmessage(i18nHandle, 
        "rpt_worklist", "LABORATORY WORKLIST")
      set i18n_captions->rpt_worksheet = uar_i18ngetmessage(i18nHandle, 
        "rpt_worksheet", "LABORATORY WORKSHEET")
      set i18n_captions->rpt_date = uar_i18ngetmessage(i18nHandle, 
        "rpt_date", "DATE:")
      set i18n_captions->rpt_time = uar_i18ngetmessage(i18nHandle, 
        "rpt_time", "TIME:")
      set i18n_captions->rpt_by = uar_i18ngetmessage(i18nHandle, 
        "rpt_by", "BY:")
      set i18n_captions->rpt_page = uar_i18ngetmessage(i18nHandle, 
        "rpt_page", "PAGE:")
      set i18n_captions->rpt_cross_test_site = 
        uar_i18ngetmessage(i18nHandle, 
        "rpt_cross_test_site", "CROSS TEST SITE")
      set i18n_captions->accession = uar_i18ngetmessage(i18nHandle, 
        "accession", "ACCESSION")
      set i18n_captions->demographics = uar_i18ngetmessage(i18nHandle, 
        "demographics", "DEMOGRAPHICS")
      set i18n_captions->location = uar_i18ngetmessage(i18nHandle, 
        "location", "LOCATION")
      set i18n_captions->collected = uar_i18ngetmessage(i18nHandle, 
        "collected", "COLLECTED")
      set i18n_captions->procedure = uar_i18ngetmessage(i18nHandle, 
        "procedure", "PROCEDURE")
      set i18n_captions->orderable_procedure = 
        uar_i18ngetmessage(i18nHandle, 
        "orderable_procedure", "ORDERABLE PROCEDURE")
      set i18n_captions->result = uar_i18ngetmessage(i18nHandle, 
        "result", "RESULT")
      set i18n_captions->tech = uar_i18ngetmessage(i18nHandle, 
        "tech", "TECH")
      set i18n_captions->perf = uar_i18ngetmessage(i18nHandle, 
        "perf", "PERF")
      set i18n_captions->verf = uar_i18ngetmessage(i18nHandle, 
        "verf", "VERF")
      set i18n_captions->control = uar_i18ngetmessage(i18nHandle, 
        "control", "CONTROL:")
      set i18n_captions->lot = uar_i18ngetmessage(i18nHandle, 
        "lot", "LOT:")
      set i18n_captions->dr = uar_i18ngetmessage(i18nHandle, 
        "dr", "DR:")
      set i18n_captions->visit_reason = uar_i18ngetmessage(i18nHandle, 
        "visit_reason", "VISIT REASON:")
      set i18n_captions->person_comments = 
        uar_i18ngetmessage(i18nHandle, 
        "person_comments", "PATIENT COMMENTS:")
      set i18n_captions->person_notes = 
        uar_i18ngetmessage(i18nHandle, 
        "person_notes", "PATIENT NOTES:")
      set i18n_captions->encounter_comments = 
        uar_i18ngetmessage(i18nHandle, 
        "encounter_comments", "ENCOUNTER COMMENTS:")
      set i18n_captions->encounter_notes = 
        uar_i18ngetmessage(i18nHandle, 
        "encounter_notes", "ENCOUNTER NOTES:")
      set i18n_captions->order_comments = 
        uar_i18ngetmessage(i18nHandle, 
        "order_comments", "ORDER COMMENTS:")
      set i18n_captions->order_notes = uar_i18ngetmessage(i18nHandle, 
        "order_notes", "ORDER NOTES:")
      set i18n_captions->result_comments = 
        uar_i18ngetmessage(i18nHandle, 
        "result_comments", "RESULT COMMENTS:")
      set i18n_captions->result_notes = uar_i18ngetmessage(i18nHandle, 
        "result_notes", "RESULT NOTES:")
      set i18n_captions->text = uar_i18ngetmessage(i18nHandle, 
        "text", "(Text)")
      set i18n_captions->repeats = uar_i18ngetmessage(i18nHandle, 
        "repeats", "(r)")
      set i18n_captions->abbrev_years = uar_i18ngetmessage(i18nHandle, 
        "abbrev_years", "YRS")
      set i18n_captions->abbrev_months = uar_i18ngetmessage(i18nHandle, 
        "abbrev_months", "MOS")
      set i18n_captions->abbrev_weeks = uar_i18ngetmessage(i18nHandle, 
        "abbrev_weeks", "WKS")
      set i18n_captions->abbrev_days = uar_i18ngetmessage(i18nHandle, 
        "abbrev_days", "DYS")
      set i18n_captions->abbrev_hours = uar_i18ngetmessage(i18nHandle, 
        "abbrev_hours", "HRS")
      set i18n_captions->abbrev_minutes = uar_i18ngetmessage(i18nHandle,
        "abbrev_minutes", "MINS")

      /***********************************************************************
      * Request Record                                                       *
      ***********************************************************************/
      /*
      record request
      (
         1  worklist_ref_id            = f8
         1  worklist_ref_disp          = vc
         1  worklist_id                = f8
         1  worklist_alias             = vc
         1  service_resource_cd        = f8
         1  service_resource_disp      = vc
         1  parent_ind                 = i2
         1  group_cnt                  = i4
         1  group[*]
            2  child_worklist_ref_id   = f8
         1  procedure_inc_flag         = i2  ;0=All, 1=Group, 2=Detail
         1  include_flag               = i2  ;0=No QC, 1=QC Only, 2=Include QC
         1  report_format_ind          = i2  ;0=Vertical 1=Horizontal
         1  cumulative_ind             = i2
         1  in_lab_ind                 = i2
         1  person_comments_ind        = i2
         1  order_comments_ind         = i2
         1  result_comments_ind        = i2
         1  result_space_ind           = i2  ;0=Worklist 1=Worksheet
         1  previous_result_ind        = i2
         1  visit_reason_ind           = i2
         1  order_status_ind           = i2
         1  reporting_priority_ind     = i2
         1  facility_ind               = i2
         1  nurse_unit_ind             = i2
         1  cross_resource_ind         = i2
         1  look_ahead_hours           = i4
         1  priority_ind               = i2
         1  qual_cnt                   = i4
         1  qual[*]
            2  accession_id            = f8
            2  order_id                = f8
            2  accession               = vc
            2  catalog_cd              = f8
            2  order_mne               = vc
            2  person_id               = f8
            2  name_full_formatted     = vc
            2  order_status_cd         = f8
            2  order_status_disp       = vc
            2  dept_status_cd          = f8
            2  dept_status_disp        = vc
            2  reporting_priority_cd   = f8
            2  reporting_priority_disp = vc
            2  control_id              = f8
            2  control_name            = vc
            2  lot_id                  = f8
            2  lot_number              = vc
            2  service_resource_cd     = f8  ;QC Accn serv resource
            2  sequence_ident          = c20
         1  procs_cnt                  = i4
         1  procs[*]
            2  procedure_cd            = f8
            2  procedure_disp          = vc
         1  priors_cnt                 = i4
         1  priors[*]
            2  priority_cd             = f8
            2  priority_disp           = vc
         1  printer                    = vc
         1  copies                     = i4
         1  spacing_ind                = i2  ;0=Single spaced 1=Double spaced
         1  landscape_ind              = i2
         1  blank_lines                = i4
         1  batch_selection            = vc  ;OPS worklist name/group name
         1  output_dist                = vc  ;OPS output device
         1  ops_date                   = dq8 ;OPS operations date
      )
      */
      
      /***********************************************************************
      * Reply Record                                                         *
      ***********************************************************************/
      record reply
      (
%i cclsource:status_block.inc
      )
      
      /***********************************************************************
      * GLB_GET_WKLST_REF Request 250183                                     *
      ***********************************************************************/
      record req250183
      (
         1  worklist_ref_id            = f8    ;optional
         1  service_resource_cd        = f8    ;optional
         1  display_key                = c20   ;optional
         1  include_inactive_ind       = i2    ;optional
      )

      /***********************************************************************
      * GLB_GET_WKLST_REF Reply Record                                       *
      ***********************************************************************/
      record reply250183
      ( 
         1  qual_cnt                   = i4
         1  qual[*]
            2  worklist_ref_id         = f8
            2  display_key             = vc
            2  display                 = vc
            2  service_resource_cd     = f8
            2  service_resource_disp   = vc
            2  service_resource_mean   = vc
            2  parent_ind              = i2
            2  procedure_inc_flag      = i2
            2  include_flag            = i2
            2  report_format_ind       = i2
            2  cumulative_ind          = i2
            2  in_lab_ind              = i2
            2  person_comments_ind     = i2
            2  order_comments_ind      = i2
            2  result_comments_ind     = i2
            2  result_space_ind        = i2
            2  previous_result_ind     = i2
            2  visit_reason_ind        = i2
            2  order_status_ind        = i2
            2  reporting_priority_ind  = i2
            2  facility_ind            = i2
            2  nurse_unit_ind          = i2
            2  cross_resource_ind      = i2
            2  look_ahead_hours        = i4
            2  priority_ind            = i2
            2  printer                 = vc
            2  copies                  = i4
            2  spacing_ind             = i2
            2  landscape_ind           = i2
            2  blank_lines             = i4
            2  worklist_exists_ind     = i2
            2  active_ind              = i2
            2  active_status_cd        = f8
            2  active_status_dt_tm     = dq8
            2  active_status_prsnl_id  = f8
            2  updt_dt_tm              = dq8
            2  updt_id                 = f8
            2  updt_task               = i4
            2  updt_cnt                = i4
            2  updt_applctx            = i4
%i cclsource:status_block.inc
      )

      /***********************************************************************
      * GLB_GET_WKLST_REF_DETAILS Request 250184                             *
      ***********************************************************************/
      record req250184
      (
         1  worklist_ref_id            = f8
      )

      /***********************************************************************
      * GLB_GET_WKLST_REF_DETAILS Reply 250184                               *
      ***********************************************************************/
      record reply250184
      (
         1  procs_cnt                    = i4
         1  procs[*]
            2  catalog_cd                = f8
            2  catalog_disp              = vc
            2  task_assay_cd             = f8
            2  task_assay_disp           = vc
         1  priorities_cnt               = i4
         1  priorities[*]
            2  priority_cd               = f8
            2  priority_disp             = vc
            2  priority_mean             = vc
         1  qc_cnt                       = i4
         1  qc[*]
            2  accession_id              = f8
            2  accession                 = c20
            2  pos                       = i4
            2  begin_ind                 = i2
            2  end_ind                   = i2
            2  interval_ind              = i2
            2  interval                  = i4
%i cclsource:status_block.inc
      )

      /***********************************************************************
      * GLB_GET_ELIG_ALL Request 250083                                      *
      ***********************************************************************/
      record req250083
      (
         1  worklist_ref_id            = f8
         1  service_resource_cd        = f8
         1  procedure_inc_flag         = i2
         1  priority_ind               = i2
         1  cumulative_ind             = i2
         1  in_lab_ind                 = i2
         1  lookahead_dt_tm_end        = dq8
         1  procs[*]
            2  procedure_cd            = f8
            2  grpdetail               = i2
         1  pris[*]
            2  priority_cd             = f8
      )

      /***********************************************************************
      * GLB_GET_ELIG_ALL Reply 250083                                        *
      ***********************************************************************/
      record reply250083
      (
         1  n_orders                   = i4
         1  qual[20]
            2  order_id                = f8   
            2  encntr_id               = f8
            2  order_status_cd         = f8
            2  order_status_disp       = vc
            2  dept_status_cd          = f8
            2  dept_status_disp        = vc
            2  report_priority_cd      = f8
            2  report_priority_disp    = vc
            2  report_priority_mean    = vc
            2  accession               = c20
            2  person_id               = f8
            2  name_full_formatted     = vc
            2  med_rec_nbr             = vc
            2  catalog_cd              = f8
            2  order_mnemonic          = vc
            2  service_resource_cd     = f8
            2  service_resource_disp   = vc
%i cclsource:status_block.inc
      )

      /***********************************************************************
      * GLB_GET_WKLST_QC_ACCNS Request 250102                                *
      ***********************************************************************/
      record req250102
      (
         1  worklist_ref_id            = f8
         1  service_resource_cd        = f8
      )

      /***********************************************************************
      * GLB_GET_WKLST_QC_ACCNS Reply 250102                                        *
      ***********************************************************************/
      record reply250102
      (
         1  qual[*]
            2  accession               = c20
            2  unformat_accn           = c20
            2  accession_id            = f8
            2  pos                     = i4
            2  begin_ind               = i2
            2  end_ind                 = i2
            2  interval_ind            = i2
            2  interval                = i4
            2  service_resource_cd     = f8
            2  service_resource_disp   = vc
            2  control_id              = f8
            2  control_name            = c20
            2  lot_id                  = f8
            2  lot_number              = vc
%i cclsource:status_block.inc
      )

      /***********************************************************************
      * GLB_ADD_WKLST_ELE Request 250085                                     *
      ***********************************************************************/
      record req250085
      (
         1  worklist_prsnl_id          = f8
         1  status_cd                  = f8
         1  service_resource_cd        = f8
         1  worklist_ref_id            = f8
         1  worklist_type_flag         = i4
         1  worklist_alias             = c25
         1  components[*]
            2  worklist_seq            = i4
            2  catalog_cd              = f8
            2  task_assay_cd           = f8
         1  orders[*]
            2  order_id                = f8
            2  accession_id            = f8
            2  sequence                = i4
            2  sequence_ident          = c20
      )

      /***********************************************************************
      * GLB_ADD_WKLST_ELE Reply 250085                                       *
      ***********************************************************************/
      record reply250085
      (
         1  worklist_id                = f8
%i cclsource:status_block.inc
      )

      /***********************************************************************
      * Print Group Record                                                   *
      ***********************************************************************/
      record print_grp
      (
         1  group_cnt                  = i4
         1  group[*]
            2  child_worklist_ref_id   = f8
            2  ref_data_loaded_ind     = i2
      )
      
      /***********************************************************************
      * Task_Assay_CD Record                                                 *
      ***********************************************************************/
      record temp_task_assay_cd
      (
         
         1  qual[*]
            2  task_assay_cd          = f8
      )     
      
      
      
      
      /***********************************************************************
      * Adjust orders list subroutine                                        *
      ***********************************************************************/
%i cclsource:aps_uar_rtf.inc   ;* For converting rtf to ascii
         declare adjust_orders_list( arg_o_cnt ) = i2
         subroutine adjust_orders_list( arg_o_cnt )
            set ocnt = 0
            ;*
            ;* Extend orders list
            ;*
            set ocnt = rpt->orders_cnt
            set ocnt = ocnt + 1
            set stat = alterlist(rpt->orders, ocnt)
            set rpt->orders_cnt = ocnt
            ;*
            ;* If new item is at end of the orders list,
            ;* no data needs to be moved.
            ;*
            if (arg_o_cnt >= rpt->orders_cnt)
               return(1)
            endif
            ;*
            ;* Move data down in orders list until the
            ;* new item position (i.e. arg_o_cnt) is reached.
            ;*
            set ocnt = rpt->orders_cnt - 1
            while (ocnt > (arg_o_cnt - 1))
               set rpt->orders[ocnt + 1].accession_id =
                 rpt->orders[ocnt].accession_id
               set rpt->orders[ocnt + 1].order_id =
                 rpt->orders[ocnt].order_id
               set rpt->orders[ocnt + 1].accession =
                 rpt->orders[ocnt].accession
               set rpt->orders[ocnt + 1].catalog_cd =
                 rpt->orders[ocnt].catalog_cd
               set rpt->orders[ocnt + 1].order_mne =
                 rpt->orders[ocnt].order_mne
               set rpt->orders[ocnt + 1].person_id =
                 rpt->orders[ocnt].person_id
               set rpt->orders[ocnt + 1].name_full_formatted =
                 rpt->orders[ocnt].name_full_formatted
               set rpt->orders[ocnt + 1].order_status_cd =
                 rpt->orders[ocnt].order_status_cd
               set rpt->orders[ocnt + 1].order_status_disp =
                 rpt->orders[ocnt].order_status_disp
               set rpt->orders[ocnt + 1].dept_status_cd =
                 rpt->orders[ocnt].dept_status_cd
               set rpt->orders[ocnt + 1].dept_status_disp =
                 rpt->orders[ocnt].dept_status_disp
               set rpt->orders[ocnt + 1].reporting_priority_cd =
                 rpt->orders[ocnt].reporting_priority_cd
               set rpt->orders[ocnt + 1].reporting_priority_disp =
                 rpt->orders[ocnt].reporting_priority_disp
               set rpt->orders[ocnt + 1].control_id =
                 rpt->orders[ocnt].control_id
               set rpt->orders[ocnt + 1].control_name =
                 rpt->orders[ocnt].control_name
               set rpt->orders[ocnt + 1].lot_id =
                 rpt->orders[ocnt].lot_id
               set rpt->orders[ocnt + 1].lot_number =
                 rpt->orders[ocnt].lot_number
               set rpt->orders[ocnt + 1].service_resource_cd =
                 rpt->orders[ocnt].service_resource_cd
               set rpt->orders[ocnt + 1].sequence_ident =
                 rpt->orders[ocnt].sequence_ident
               ;*
               ;* Clear open array occurance.
               ;*
               set rpt->orders[ocnt].accession_id = 0.0
               set rpt->orders[ocnt].order_id = 0.0
               set rpt->orders[ocnt].accession = " "
               set rpt->orders[ocnt].catalog_cd = 0.0
               set rpt->orders[ocnt].order_mne = " "
               set rpt->orders[ocnt].person_id = 0.0
               set rpt->orders[ocnt].name_full_formatted = " "
               set rpt->orders[ocnt].order_status_cd = 0.0
               set rpt->orders[ocnt].order_status_disp = " "
               set rpt->orders[ocnt].dept_status_cd = 0.0
               set rpt->orders[ocnt].dept_status_disp = " "
               set rpt->orders[ocnt].reporting_priority_cd = 0.0
               set rpt->orders[ocnt].reporting_priority_disp = " "
               set rpt->orders[ocnt].control_id = 0.0
               set rpt->orders[ocnt].control_name = " "
               set rpt->orders[ocnt].lot_id = 0.0
               set rpt->orders[ocnt].lot_number = " "
               set rpt->orders[ocnt].service_resource_cd = 0.0
               set rpt->orders[ocnt].sequence_ident = " "
               set ocnt = ocnt - 1
            endwhile
            return(1)
         end
         
      /***********************************************************************
      * Build Result Flags String Subroutine                                 *
      ***********************************************************************/
         ;* Build a string of result flags to follow a result on a report.
         ;* Prints only the 1st char of each result flag.
         ;* When calling this function, remember that the contents of the 
         ;* display field for the 1902 codeset can be an empty string.
         ;* This routine will check to see whether the display flag = " ", 
         ;* and if not, will look at the 1st character in the string.
         declare bldresultflagstr(fnorm, fcrit, frevw, flin, ffeas, 
                                  fdelta, fcomment, fnote, fcorr) = c10

         subroutine bldresultflagstr(fnorm, fcrit, frevw, flin, ffeas, 
                                     fdelta, fcomment, fnote, fcorr)

            set flagstr = fillstring(10, " ")
            set flag_cnt = 1

            ;* Add abnormal flag
            if (fnorm != " ")
               set move_len = movestring(fnorm, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add critical flag
            if (fcrit != " ")
               set move_len = movestring(fcrit, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add review flag
            if (frevw != " ")
               set move_len = movestring(frevw, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add linear flag
            if (flin != " ")
               set move_len = movestring(flin, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add feasible flag
            if (ffeas != " ")
               set move_len = movestring(ffeas, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add delta flag
            if (fdelta != " ")
               set move_len = movestring(fdelta, 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ;* Add corrected flag
            if (fcorr = "Y")
               set move_len = movestring("c", 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif

            ; add footnote flag
            if ((fcomment = "Y") or (fnote = "Y"))
               set move_len = movestring("f", 1, flagstr, flag_cnt, 1)
               set flag_cnt = flag_cnt + 1
            endif
    
            return(flagstr)
         end

      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
      #Script
         set reply->status_data.status = "F"
         ;*
         ;* Code set variables
         ;*
         set COMMENT_TYPE_CODESET          = 14
         set COMMENT_TYPE_ORD_COMMENT_CDF  = "ORD COMMENT"
         set COMMENT_TYPE_ORD_NOTE_CDF     = "ORD NOTE"
         set COMMENT_TYPE_RES_COMMENT_CDF  = "RES COMMENT"
         set COMMENT_TYPE_RES_NOTE_CDF     = "RES NOTE"
         set SERV_RES_TYPE_CODESET         = 223
         set SERV_RES_INSTITUTION_CDF      = "INSTITUTION"
         set SERV_RES_DEPARTMENT_CDF       = "DEPARTMENT"
         set SERV_RES_SECTION_CDF          = "SECTION"
         set SERV_RES_SUBSECTION_CDF       = "SUBSECTION"
         set SERV_RES_INSTRUMENT_CDF       = "INSTRUMENT"
         set SERV_RES_BENCH_CDF            = "BENCH"
         set RESULT_TYPE_CODESET           = 289
         set RESULT_TYPE_TEXT_CDF          = "1"
         set RESULT_TYPE_ALPHA_CDF         = "2"
         set RESULT_TYPE_NUMERIC_CDF       = "3"
         set RESULT_TYPE_INTERP_CDF        = "4"
         set RESULT_TYPE_DATE_CDF          = "6"
         set RESULT_TYPE_FREETEXT_CDF      = "7"
         set RESULT_TYPE_CALC_CDF          = "8"
         set ENCNTR_ALIAS_TYPE_CODESET     = 319
         set ALIAS_TYPE_MRN_CDF            = "MRN"
         set INFO_TYPE_CODESET             = 355
         set INFO_TYPE_COMMENT_CDF         = "COMMENT"
         set INFO_TYPE_NOTE_CDF            = "NOTE"
         set RESULT_STATUS_CODESET         = 1901
         set RESULT_STATUS_PERFORMED_CDF   = "PERFORMED"
         set RESULT_STATUS_VERIFIED_CDF    = "VERIFIED"
         set RESULT_STATUS_AUTOVERIFIED_CDF = "AUTOVERIFIED"
         set RESULT_STATUS_CORRECTED_CDF   = "CORRECTED"
         set RESULT_PRCSS_CODESET          = 1902
         set RESULT_PRCSS_ALP_ABNORMAL_CDF = "ALP_ABNORMAL"
         set RESULT_PRCSS_ALP_CRITICAL_CDF = "ALP_CRITICAL"
         set RESULT_PRCSS_ALP_REVIEW_CDF   = "ALP_REVIEW"
         set RESULT_PRCSS_NORMAL_HIGH_CDF  = "NORMAL_HIGH"
         set RESULT_PRCSS_NORMAL_LOW_CDF   = "NORMAL_LOW"
         set RESULT_PRCSS_CRITICAL_CDF     = "CRITICAL"
         set RESULT_PRCSS_REVIEW_CDF       = "REVIEW"
         set RESULT_PRCSS_LINEAR_CDF       = "LINEAR"
         set RESULT_PRCSS_FEASIBLE_CDF     = "FEASIBLE"
         set RESULT_PRCSS_DELTA_FAIL_CDF   = "DELTA_FAIL"
         set GLB_OPS_PARAMS_CODESET        = 1950
         set GLB_OPS_PARAMS_WLR_CDF        = "WLR"
         set code_set = 0
         set meaning = fillstring(12, " ")
         set code_cnt = 1
         ;*
         ;* Initialize variables.
         ;*
         set grp_nbr = 0
         set displaykey = fillstring(100, " ")
         set ops_worklist_ref_id = 0.0
         set o_cnt = 0
         set a_cnt = 0
         set r_cnt = 0
         set max_a_cnt = 0
         set max_r_cnt = 0
         set max_pc_cnt = 0
         set max_ec_cnt = 0
         set max_oc_cnt = 0
         set max_rc_cnt = 0
         set cnt = 0
         set q_cnt = 0
         set ptr = 0
         set idx = 0
         set interval_cnt = 0
         set arg_min_digits = 0
         set arg_max_digits = 0
         set arg_min_dec_places = 0
         set arg_less_great_flag = 0
         set arg_raw_value = 0.0
         set nbr_mins = 0.0
         set max_nbr_cols = 0
         set max_nbr_rows = 0
         set time_hrs = "  "
         set time_mins = "  "
         set serv_res_mean = fillstring(12, " ")
         set dilution_val = fillstring(6, " ")
         set username = fillstring(10, " ")
         
         record vctext
         (
            1  txt                     = vc
            1  rpt_title               = vc
         )
         
         record curr
         (
            1  system_dt_tm            = dq8
         )
         set curr->system_dt_tm = cnvtdatetime(curdate, curtime3)

         set modify = cnvtage(90, 0, 24)

      /***********************************************************************
      * Load Code Values                                                     *
      ***********************************************************************/
         ;*
         ;* Load Service Resource Types - Institution, Department, Section,
         ;* Subsection, Instrument, Bench code values.
         ;*
         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_INSTITUTION_CDF
         set serv_res_institution_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_institution_cd)

         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_DEPARTMENT_CDF
         set serv_res_department_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_department_cd)

         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_SUBSECTION_CDF
         set serv_res_subsection_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_subsection_cd)

         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_SECTION_CDF
         set serv_res_section_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_section_cd)

         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_INSTRUMENT_CDF
         set serv_res_instrument_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_instrument_cd)

         set code_set = SERV_RES_TYPE_CODESET
         set meaning = SERV_RES_BENCH_CDF
         set serv_res_bench_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, serv_res_bench_cd)

         ;*
         ;* Load Result Types - Text, Alpha, Numeric, Interpretation,
         ;* Date, Freetext, and Calculation code values.
         ;*
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_TEXT_CDF
         set result_type_text_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_text_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_ALPHA_CDF
         set result_type_alpha_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_alpha_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_NUMERIC_CDF
         set result_type_numeric_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_numeric_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_INTERP_CDF
         set result_type_interp_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_interp_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_DATE_CDF
         set result_type_date_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_date_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_FREETEXT_CDF
         set result_type_freetext_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_freetext_cd)
      
         set code_set = RESULT_TYPE_CODESET
         set meaning = RESULT_TYPE_CALC_CDF
         set result_type_calc_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, result_type_calc_cd)
      
         ;*
         ;* Load Encounter Alias Type - Med Rec Nbr code value.
         ;*
         set code_set = ENCNTR_ALIAS_TYPE_CODESET
         set meaning = ALIAS_TYPE_MRN_CDF
         set alias_type_mrn_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, alias_type_mrn_cd)
      
         ;*
         ;* Load Info Type Code - Comment and Note code values.
         ;*
         set code_set = INFO_TYPE_CODESET
         set meaning = INFO_TYPE_COMMENT_CDF
         set info_type_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, info_type_comment_cd)
      
         set code_set = INFO_TYPE_CODESET
         set meaning = INFO_TYPE_NOTE_CDF
         set info_type_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, info_type_note_cd)
      
         ;*
         ;* Load Comment Type - Order Comment, Order Note, Result Comment
         ;* Result Note code values.
         ;*
         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_ORD_COMMENT_CDF
         set comment_type_ord_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_ord_comment_cd)

         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_ORD_NOTE_CDF
         set comment_type_ord_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_ord_note_cd)

         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_RES_COMMENT_CDF
         set comment_type_res_comment_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_res_comment_cd)

         set code_set = COMMENT_TYPE_CODESET
         set meaning = COMMENT_TYPE_RES_NOTE_CDF
         set comment_type_res_note_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, comment_type_res_note_cd)
      
         ;*
         ;* Load Result Statuses - Performed, Verified, Auto-verified,
         ;* and corrected code values.
         ;*
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_PERFORMED_CDF
         set performed_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, performed_cd)
      
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_VERIFIED_CDF
         set verified_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, verified_cd)
      
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_AUTOVERIFIED_CDF
         set autoverified_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, autoverified_cd)
      
         set code_set = RESULT_STATUS_CODESET
         set meaning = RESULT_STATUS_CORRECTED_CDF
         set corrected_cd = 0.0
         set stat = uar_get_meaning_by_codeset(
           code_set, meaning, code_cnt, corrected_cd)
      
      /***********************************************************************
      * Build Print Group when running from Operations                       *
      ***********************************************************************/
         if (trim(request->batch_selection) > " ")
            set displaykey = 
              trim(cnvtupper(cnvtalphanum(request->batch_selection)))
            set ops_worklist_ref_id = 0.0
    
            select into "nl:"
               cv.code_value
            from
               code_value cv
            plan cv
              where cv.code_set = GLB_OPS_PARAMS_CODESET
                and cv.cdf_meaning = GLB_OPS_PARAMS_WLR_CDF
                and cv.display_key = displaykey
                and cv.active_ind = 1
            detail
               ops_worklist_ref_id = cnvtreal(trim(cv.definition))
            with
               nocounter
    
            if (curqual = 0)
               ;* Operation parameters not found
               set reply->status_data.subeventstatus[1]
                 .OperationName = "SELECT"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "CODE_VALUE"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue = 
                 "Unable to load operation parameters."
               go to Exit_Script
            endif
    
            select into "nl:"
               wr.worklist_ref_id
              ,d.seq
              ,wg_exists = decode(wg.seq, "Y", "N")
              ,wg.child_worklist_ref_id
            from
               worklist_ref wr
              ,(dummyt d with seq = 1)
              ,worklist_group wg
            plan wr
              where wr.worklist_ref_id = ops_worklist_ref_id
                and wr.active_ind = 1
            join d
              where d.seq = 1
            join wg
              where wg.parent_worklist_ref_id = wr.worklist_ref_id
                and wg.active_ind = 1
                and wr.parent_ind = 1
            head report
               grp_nbr = 0
            detail
               grp_nbr = grp_nbr + 1
               stat = alterlist(print_grp->group, grp_nbr)
               print_grp->group_cnt = grp_nbr
               if (wg_exists = "Y")
                  print_grp->group[grp_nbr].child_worklist_ref_id =
                    wg.child_worklist_ref_id
               else
                  print_grp->group[grp_nbr].child_worklist_ref_id =
                    wr.worklist_ref_id
               endif
               print_grp->group[grp_nbr].ref_data_loaded_ind = 0
            with
               nocounter
              ,outerjoin = d
              ,dontcare = wg

            if (curqual = 0)
               set reply->status_data.status = "Z"
               go to Exit_Script
            endif
            set grp_nbr = 1
            go to Process_Worklist
         endif
         
      /***********************************************************************
      * Build Print Group when running from Client Application               *
      ***********************************************************************/
         if (request->parent_ind = 1)
            set print_grp->group_cnt = request->group_cnt
            set stat = alterlist(print_grp->group, request->group_cnt)
            for (grp_nbr = 1 to request->group_cnt)
               set print_grp->group[grp_nbr].child_worklist_ref_id =
                  request->group[grp_nbr].child_worklist_ref_id
               set print_grp->group[grp_nbr].ref_data_loaded_ind = 0
            endfor
         else
            set print_grp->group_cnt = 1
            set stat = alterlist(print_grp->group, 1)
            set print_grp->group[1].child_worklist_ref_id = 
               request->worklist_ref_id
            set print_grp->group[grp_nbr].ref_data_loaded_ind = 1
         endif

      /***********************************************************************
      * Process Next Worklist in Group                                       *
      ***********************************************************************/
         set grp_nbr = 1
         
      #Process_Worklist
         set o_cnt = 0
         set a_cnt = 0
         set r_cnt = 0
         set max_a_cnt = 0
         set max_r_cnt = 0
         set max_pc_cnt = 0
         set max_ec_cnt = 0
         set max_oc_cnt = 0
         set max_rc_cnt = 0
         set cnt = 0
         
         free set rpt
         record rpt
         (
            1  worklist_ref_id         = f8
            1  worklist_ref_disp       = vc
            1  worklist_id             = f8
            1  worklist_alias          = vc
            1  service_resource_cd     = f8
            1  service_resource_disp   = vc
            1  parent_ind              = i2
            1  procedure_inc_flag      = i2  ;0=All, 1=Group, 2=Detail
            1  include_flag            = i2  ;0=No QC, 1=QC Only, 2=Include QC
            1  report_format_ind       = i2  ;0=Vertical 1=Horizontal
            1  cumulative_ind          = i2
            1  in_lab_ind              = i2
            1  person_comments_ind     = i2
            1  order_comments_ind      = i2
            1  result_comments_ind     = i2
            1  result_space_ind        = i2  ;0=Worklist 1=Worksheet
            1  previous_result_ind     = i2
            1  visit_reason_ind        = i2
            1  order_status_ind        = i2
            1  reporting_priority_ind  = i2
            1  facility_ind            = i2
            1  nurse_unit_ind          = i2
            1  cross_resource_ind      = i2
            1  look_ahead_hours        = i4
            1  priority_ind            = i2
            1  orders_cnt              = i4
            1  orders[*]
               2  accession_id            = f8
               2  order_id                = f8
               2  accession               = vc
               2  catalog_cd              = f8
               2  order_mne               = vc
               2  resource_route_level_flag = i2
               2  person_id               = f8
               2  name_full_formatted     = vc
               2  encntr_id               = f8
               2  med_rec_nbr             = vc
               2  sex_cd                  = f8
               2  sex_disp                = vc
               2  age                     = vc
               2  location_cd             = f8
               2  location_mean           = vc
               2  facility_cd             = f8
               2  facility_disp           = vc
               2  nurse_unit_cd           = f8
               2  nurse_unit_disp         = vc
               2  room_cd                 = f8
               2  room_disp               = vc
               2  bed_cd                  = f8
               2  bed_disp                = vc
               2  roombed_disp            = vc
               2  order_status_cd         = f8
               2  order_status_disp       = vc
               2  dept_status_cd          = f8
               2  dept_status_disp        = vc
               2  last_update_provider_id = f8
               2  provider_name           = vc
               2  reporting_priority_cd   = f8
               2  reporting_priority_disp = vc
               2  drawn_dt_tm             = dq8
               2  visit_reason            = vc
               2  person_info_id          = f8
               2  person_comment_cnt      = i4
               2  person_comment[*]
                  3  comment_type_cd      = f8
                  3  long_text_id         = f8
                  3  comment              = vc
               2  encntr_comment_cnt      = i4
               2  encntr_comment[*]
                  3  comment_type_cd      = f8
                  3  long_text_id         = f8
                  3  comment              = vc
               2  order_comment_cnt       = i4
               2  order_comment[*]
                  3  comment_type_cd         = f8
                  3  long_text_id            = f8
                  3  comment                 = vc
               2  control_id              = f8
               2  control_name            = vc
               2  lot_id                  = f8
               2  lot_number              = vc
               2  service_resource_cd     = f8  ;QC Accn serv resource
               2  sequence_ident          = c20
               2  assays_cnt              = i4
               2  assays[*]
                  3  task_assay_cd           = f8
                  3  task_assay_disp         = vc
                  3  cross_resource_ind      = i2
                  3  results_cnt             = i4
                  3  results[*]
                     4  result_id               = f8
                     4  perform_result_id       = f8
                     4  result_status_cd        = f8
                     4  result_type_cd          = f8
                     4  less_great_flag         = i2
                     4  numeric_raw_value       = f8
                     4  result_value            = vc
                     4  result_flags            = c10
                     4  dilution_factor         = f8
                     4  dilution_value          = vc
                     4  perf_tech_id            = f8
                     4  perf_dt_tm              = dq8
                     4  perf_username           = vc
                     4  verf_tech_id            = f8
                     4  verf_dt_tm              = dq8
                     4  verf_username           = vc
                     4  result_comment_cnt      = i4
                     4  result_comment[*]
                        5  comment_type_cd         = f8
                        5  long_text_id            = f8
                        5  comment                 = vc
                  3  prev_result_id          = f8
                  3  prev_perform_result_id  = f8
                  3  prev_result_status_cd   = f8
                  3  prev_result_type_cd     = f8
                  3  prev_less_great_flag    = i2
                  3  prev_numeric_raw_value  = f8
                  3  prev_result_value       = vc
                  3  prev_result_flags       = c10
                  3  prev_dilution_factor    = f8
                  3  prev_dilution_value     = vc
                  3  prev_elapse_time        = vc
            1  procs_cnt                     = i4
            1  procs[*]
               2  procedure_cd            = f8
               2  procedure_disp          = vc
            1  priors_cnt                 = i4
            1  priors[*]
               2  priority_cd             = f8
               2  priority_disp           = vc
            1  qc_accns_cnt               = i4
            1  qc_accns[*]
               2  accession_id            = f8
               2  accession               = c20
               2  pos                     = i4
               2  begin_ind               = i2
               2  end_ind                 = i2
               2  interval_ind            = i2
               2  interval                = i4
            1  printer                 = vc
            1  copies                  = i4
            1  spacing_ind             = i2  ;0=Single spaced 1=Double spaced
            1  landscape_ind           = i2
            1  blank_lines             = i4
         )

      /***********************************************************************
      * If reference data was passed in script.  Build report record.        *
      ***********************************************************************/
         if (print_grp->group[grp_nbr].ref_data_loaded_ind = 1)
            set rpt->worklist_ref_id = request->worklist_ref_id
            set rpt->worklist_ref_disp = request->worklist_ref_disp
            set rpt->worklist_id = request->worklist_id
            set rpt->worklist_alias = request->worklist_alias
            set rpt->service_resource_cd = request->service_resource_cd
            set rpt->service_resource_disp =
              request->service_resource_disp
            set rpt->parent_ind = request->parent_ind
            set rpt->procedure_inc_flag = request->procedure_inc_flag
            set rpt->include_flag = request->include_flag
            set rpt->report_format_ind = request->report_format_ind
            set rpt->cumulative_ind = request->cumulative_ind
            set rpt->in_lab_ind = request->in_lab_ind
            set rpt->person_comments_ind = request->person_comments_ind
            set rpt->order_comments_ind = request->order_comments_ind
            set rpt->result_comments_ind = request->result_comments_ind
            set rpt->result_space_ind = request->result_space_ind
            set rpt->previous_result_ind = request->previous_result_ind
            set rpt->visit_reason_ind = request->visit_reason_ind
            set rpt->order_status_ind = request->order_status_ind
            set rpt->reporting_priority_ind = 
              request->reporting_priority_ind
            set rpt->facility_ind = request->facility_ind
            set rpt->nurse_unit_ind = request->nurse_unit_ind
            set rpt->cross_resource_ind = request->cross_resource_ind
            set rpt->look_ahead_hours = request->look_ahead_hours
            set rpt->priority_ind = request->priority_ind
            set rpt->orders_cnt = request->qual_cnt
            set stat = alterlist(rpt->orders, request->qual_cnt)
            if (request->qual_cnt > 0)
               for (o_cnt = 1 to request->qual_cnt)
                  set rpt->orders[o_cnt].accession_id =
                    request->qual[o_cnt].accession_id
                  set rpt->orders[o_cnt].order_id =
                    request->qual[o_cnt].order_id
                  set rpt->orders[o_cnt].accession =
                    request->qual[o_cnt].accession
                  set rpt->orders[o_cnt].catalog_cd =
                    request->qual[o_cnt].catalog_cd
                  set rpt->orders[o_cnt].order_mne =
                    request->qual[o_cnt].order_mne
                  set rpt->orders[o_cnt].person_id =
                    request->qual[o_cnt].person_id
                  set rpt->orders[o_cnt].name_full_formatted =
                    request->qual[o_cnt].name_full_formatted
                  set rpt->orders[o_cnt].order_status_cd =
                    request->qual[o_cnt].order_status_cd
                  set rpt->orders[o_cnt].order_status_disp =
                    request->qual[o_cnt].order_status_disp
                  set rpt->orders[o_cnt].dept_status_cd =
                    request->qual[o_cnt].dept_status_cd
                  set rpt->orders[o_cnt].dept_status_disp =
                    request->qual[o_cnt].dept_status_disp
                  set rpt->orders[o_cnt].reporting_priority_cd =
                    request->qual[o_cnt].reporting_priority_cd
                  set rpt->orders[o_cnt].reporting_priority_disp =
                    request->qual[o_cnt].reporting_priority_disp
                  set rpt->orders[o_cnt].control_id =
                    request->qual[o_cnt].control_id
                  set rpt->orders[o_cnt].control_name =
                    request->qual[o_cnt].control_name
                  set rpt->orders[o_cnt].lot_id =
                    request->qual[o_cnt].lot_id
                  set rpt->orders[o_cnt].lot_number =
                    request->qual[o_cnt].lot_number
                  set rpt->orders[o_cnt].service_resource_cd =
                    request->qual[o_cnt].service_resource_cd
                  set rpt->orders[o_cnt].sequence_ident =
                    request->qual[o_cnt].sequence_ident
                  set rpt->orders[o_cnt].assays_cnt = 0
               endfor
            endif
            if (request->procs_cnt > 0)
               for (cnt = 1 to request->procs_cnt)
                  set rpt->procs_cnt = request->procs_cnt
                  set stat = alterlist(rpt->procs, request->procs_cnt)
                  set rpt->procs[cnt].procedure_cd =
                    request->procs[cnt].procedure_cd
                  set rpt->procs[cnt].procedure_disp =
                    request->procs[cnt].procedure_disp
               endfor
            endif
            if (request->priors_cnt > 0)
               for (cnt = 1 to request->priors_cnt)
                  set rpt->priors_cnt = request->priors_cnt
                  set stat = alterlist(rpt->priors, request->priors_cnt)
                  set rpt->priors[cnt].priority_cd =
                    request->priors[cnt].priority_cd
                  set rpt->priors[cnt].priority_disp =
                    request->priors[cnt].priority_disp
               endfor
            endif
            set rpt->printer = request->printer
            set rpt->copies = request->copies
            set rpt->spacing_ind = request->spacing_ind
            set rpt->landscape_ind = request->landscape_ind
            set rpt->blank_lines = request->blank_lines
         endif

      /***********************************************************************
      * Load reference data if necessary (i.e. Processing a worklist group   *
      * or running from operations).                                         *
      ***********************************************************************/
         if (print_grp->group[grp_nbr].ref_data_loaded_ind = 0)
            ;*
            ;* Call GLB_GET_WKLST_REF
            ;*
            set req250183->worklist_ref_id = 
              print_grp->group[grp_nbr].child_worklist_ref_id
            set req250183->service_resource_cd = 0.0
            set req250183->display_key = " "
            set req250183->include_inactive_ind = 0
            execute GLB_GET_WKLST_REF with 
              replace(request, req250183), 
              replace(reply, reply250183)
            if (reply250183->status_data.status = "F")
               ;* Script failure.
               set reply->status_data.subeventstatus[1]
                 .OperationName = "EXECUTE"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "GLB_GET_WKLST_REF"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue = 
                 "Unable to load worklist reference data."
               go to Exit_Script
            endif
            if (reply250183->status_data.status = "Z")
               ;* No worklist ref info found.
               go to Next_Worklist
            endif
            set rpt->worklist_ref_id = 
              reply250183->qual[1].worklist_ref_id
            set rpt->worklist_ref_disp = 
              reply250183->qual[1].display
            set rpt->worklist_id = 0.0
            if (trim(request->batch_selection) > " ")
               set rpt->worklist_alias = concat(
                 trim(substring(1,10, reply250183->qual[1].display)), 
                 " ID", format(
                 cnvtdatetime(request->ops_date), "YYYYMMDDHHMM;;Q"))
            else
               set rpt->worklist_alias = concat(
                 trim(substring(1,10, reply250183->qual[1].display)), 
                 " ID", format(
                 cnvtdatetime(curdate,curtime3), "YYYYMMDDHHMM;;Q"))
            endif
            set rpt->service_resource_cd = 
              reply250183->qual[1].service_resource_cd
            set rpt->service_resource_disp = 
              uar_get_code_display(
              reply250183->qual[1].service_resource_cd)
            set rpt->parent_ind = 
              reply250183->qual[1].parent_ind
            set rpt->procedure_inc_flag = 
              reply250183->qual[1].procedure_inc_flag
            set rpt->include_flag = 
              reply250183->qual[1].include_flag
            set rpt->report_format_ind = 
              reply250183->qual[1].report_format_ind
            set rpt->cumulative_ind =
              reply250183->qual[1].cumulative_ind
            set rpt->in_lab_ind = 
              reply250183->qual[1].in_lab_ind
            set rpt->person_comments_ind = 
              reply250183->qual[1].person_comments_ind
            set rpt->order_comments_ind = 
              reply250183->qual[1].order_comments_ind
            set rpt->result_comments_ind = 
              reply250183->qual[1].result_comments_ind
            set rpt->result_space_ind = 
              reply250183->qual[1].result_space_ind
            set rpt->previous_result_ind = 
              reply250183->qual[1].previous_result_ind
            set rpt->visit_reason_ind = 
              reply250183->qual[1].visit_reason_ind
            set rpt->order_status_ind = 
              reply250183->qual[1].order_status_ind
            set rpt->reporting_priority_ind = 
              reply250183->qual[1].reporting_priority_ind
            set rpt->facility_ind = 
              reply250183->qual[1].facility_ind
            set rpt->nurse_unit_ind = 
              reply250183->qual[1].nurse_unit_ind
            set rpt->cross_resource_ind = 
              reply250183->qual[1].cross_resource_ind
            set rpt->look_ahead_hours = 
              reply250183->qual[1].look_ahead_hours
            set rpt->priority_ind = 
              reply250183->qual[1].priority_ind
            set rpt->orders_cnt = 0
            set rpt->priors_cnt = 0
            if (trim(request->batch_selection) > " ")
               set rpt->printer = request->output_dist
            else
               set rpt->printer = reply250183->qual[1].printer
            endif
            set rpt->copies = 
              reply250183->qual[1].copies
            set rpt->spacing_ind = 
              reply250183->qual[1].spacing_ind
            set rpt->landscape_ind = 
              reply250183->qual[1].landscape_ind
            set rpt->blank_lines = 
              reply250183->qual[1].blank_lines
            ;*
            ;* Call GLB_GET_WKLST_REF_DETAILS
            ;*
            if (rpt->procedure_inc_flag > 0
            or  rpt->priority_ind > 0
            or  rpt->include_flag > 0)
               set req250184->worklist_ref_id = 
                 print_grp->group[grp_nbr].child_worklist_ref_id
               execute GLB_GET_WKLST_REF_DETAILS with 
                 replace(request, req250184), 
                 replace(reply, reply250184)
               if (reply250184->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_WKLST_REF_DETAILS"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue = 
                    "Unable to load worklist reference detail data."
                  go to Exit_Script
               endif
               if (reply250184->status_data.status = "Z")
                  ;* No worklist ref detail info found.
                  go to Next_Worklist
               endif
               if (reply250184->procs_cnt > 0)
                  set cnt = reply250184->procs_cnt
                  set rpt->procs_cnt = cnt
                  set stat = alterlist(rpt->procs, cnt)
                  for (cnt = 1 to reply250184->procs_cnt)
                     if (rpt->procedure_inc_flag = 1)
                        set rpt->procs[cnt].procedure_cd = 
                          reply250184->procs[cnt].catalog_cd
                        set rpt->procs[cnt].procedure_disp =
                          uar_get_code_display(
                          reply250184->procs[cnt].catalog_cd)
                     endif
                     if (rpt->procedure_inc_flag = 2)
                        set rpt->procs[cnt].procedure_cd = 
                          reply250184->procs[cnt].task_assay_cd
                        set rpt->procs[cnt].procedure_disp =
                          uar_get_code_display(
                          reply250184->procs[cnt].task_assay_cd)
                     endif
                  endfor
               endif
               if (reply250184->priorities_cnt > 0)
                  set cnt = reply250184->priorities_cnt
                  set rpt->priors_cnt = cnt
                  set stat = alterlist(rpt->priors, cnt)
                  for (cnt = 1 to reply250184->priorities_cnt)
                     set rpt->priors[cnt].priority_cd = 
                       reply250184->priorities[cnt].priority_cd
                     set rpt->priors[cnt].priority_disp =
                       uar_get_code_display(
                       reply250184->priorities[cnt].priority_cd)
                  endfor
               endif
               if (reply250184->qc_cnt > 0)
                  set cnt = reply250184->qc_cnt
                  set rpt->qc_accns_cnt = cnt
                  set stat = alterlist(rpt->qc_accns, cnt)
                  for (cnt = 1 to reply250184->qc_cnt)
                     set rpt->qc_accns[cnt].accession_id = 
                       reply250184->qc[cnt].accession_id
                     set rpt->qc_accns[cnt].accession = 
                       reply250184->qc[cnt].accession
                     set rpt->qc_accns[cnt].pos = 
                       reply250184->qc[cnt].pos
                     set rpt->qc_accns[cnt].begin_ind = 
                       reply250184->qc[cnt].begin_ind
                     set rpt->qc_accns[cnt].end_ind = 
                       reply250184->qc[cnt].end_ind
                     set rpt->qc_accns[cnt].interval_ind = 
                       reply250184->qc[cnt].interval_ind
                     set rpt->qc_accns[cnt].interval = 
                       reply250184->qc[cnt].interval
                  endfor
               endif
            endif
            ;*
            ;* Call GLB_GET_ELIG_ALL
            ;*
            if (rpt->include_flag != 1)
               set req250083->worklist_ref_id = 
                 rpt->worklist_ref_id
               set req250083->service_resource_cd = 
                 rpt->service_resource_cd
               set req250083->procedure_inc_flag = 
                 rpt->procedure_inc_flag
               set req250083->priority_ind = 
                 rpt->priority_ind
               set req250083->cumulative_ind = 
                 rpt->cumulative_ind
               set req250083->in_lab_ind = 
                 rpt->in_lab_ind
               set nbr_mins = cnvtreal(rpt->look_ahead_hours) * 60.0
               set req250083->lookahead_dt_tm_end = datetimeadd(
                 cnvtdatetime(curr->system_dt_tm), (nbr_mins / 1440.0))
               if (rpt->procedure_inc_flag = 1
               and rpt->procs_cnt > 0)
                  set cnt = rpt->procs_cnt
                  set stat = alterlist(req250083->procs, cnt)
                  for (cnt = 1 to rpt->procs_cnt)
                     set req250083->procs[cnt].procedure_cd = 
                       rpt->procs[cnt].procedure_cd
                     set req250083->procs[cnt].grpdetail = 0
                  endfor
               endif
               if (rpt->procedure_inc_flag = 2
               and rpt->procs_cnt > 0)
                  set cnt = rpt->procs_cnt
                  set stat = alterlist(req250083->procs, cnt)
                  for (cnt = 1 to rpt->procs_cnt)
                     set req250083->procs[cnt].procedure_cd = 
                       rpt->procs[cnt].procedure_cd
                     set req250083->procs[cnt].grpdetail = 1
                  endfor
               endif
               if (rpt->priority_ind = 1
               and rpt->priors_cnt > 0)
                  set cnt = rpt->priors_cnt
                  set stat = alterlist(req250083->pris, cnt)
                  for (cnt = 1 to rpt->priors_cnt)
                     set req250083->pris[cnt].priority_cd = 
                       rpt->priors[cnt].priority_cd
                  endfor
               endif
               execute GLB_GET_ELIG_ALL with 
                 replace(request, req250083), 
                 replace(reply, reply250083)
               if (reply250083->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_ELIG_ALL"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue = 
                    "Unable to load eligible orders for worklist."
                  go to Exit_Script
               endif
               if (reply250083->status_data.status = "S"
               and reply250083->n_orders > 0)
                  select into "nl:"
                     d.seq
                    ,accn = 
                      reply250083->qual[d.seq].accession
                    ,catalogcd = 
                      reply250083->qual[d.seq].catalog_cd
                    ,orderstatus_disp = uar_get_code_display(
                      reply250083->qual[d.seq].order_status_cd)
                    ,deptstatus_disp = uar_get_code_display(
                      reply250083->qual[d.seq].dept_status_cd)
                    ,reportpriority_disp = uar_get_code_display(
                      reply250083->qual[d.seq].report_priority_cd)
                    ,reportpriority_mean = uar_get_code_meaning(
                      reply250083->qual[d.seq].report_priority_cd)
                  from
                     (dummyt d with seq = value(reply250083->n_orders))
                  plan d
                    where d.seq <= reply250083->n_orders
                  order by
                     reportpriority_mean
                    ,accn
                    ,catalogcd
                  head report
                     o_cnt = 0
                  detail
                     o_cnt = o_cnt + 1
                     if (mod(o_cnt, 100) = 1)
                        stat = alterlist(rpt->orders, o_cnt + 100)
                     endif
                     rpt->orders_cnt = o_cnt
                     rpt->orders[o_cnt].accession_id = 0.0
                     rpt->orders[o_cnt].order_id =
                       reply250083->qual[d.seq].order_id
                     rpt->orders[o_cnt].accession =
                       reply250083->qual[d.seq].accession
                     rpt->orders[o_cnt].catalog_cd =
                       reply250083->qual[d.seq].catalog_cd
                     rpt->orders[o_cnt].order_mne =
                       reply250083->qual[d.seq].order_mnemonic
                     rpt->orders[o_cnt].person_id =
                       reply250083->qual[d.seq].person_id
                     rpt->orders[o_cnt].name_full_formatted =
                       reply250083->qual[d.seq].name_full_formatted
                     rpt->orders[o_cnt].order_status_cd =
                       reply250083->qual[d.seq].order_status_cd
                     rpt->orders[o_cnt].order_status_disp =
                       orderstatus_disp
                     rpt->orders[o_cnt].dept_status_cd =
                       reply250083->qual[d.seq].dept_status_cd
                     rpt->orders[o_cnt].dept_status_disp =
                       deptstatus_disp
                     rpt->orders[o_cnt].reporting_priority_cd =
                       reply250083->qual[d.seq].report_priority_cd
                     rpt->orders[o_cnt].reporting_priority_disp =
                       reportpriority_disp
                     rpt->orders[o_cnt].sequence_ident = " "
                  foot report
                     stat = alterlist(rpt->orders, o_cnt)
                  with
                     nocounter
               endif
            endif
            ;*
            ;* Call GLB_GET_WKLST_QC_ACCNS
            ;*
            if (rpt->include_flag in (1, 2)
            and rpt->qc_accns_cnt > 0)
               set req250102->worklist_ref_id = 
                 rpt->worklist_ref_id
               set req250102->service_resource_cd = 
                 rpt->service_resource_cd
               execute GLB_GET_WKLST_QC_ACCNS with 
                 replace(request, req250102), 
                 replace(reply, reply250102)
               if (reply250102->status_data.status = "F")
                  ;* Script failure.
                  set reply->status_data.subeventstatus[1]
                    .OperationName = "EXECUTE"
                  set reply->status_data.subeventstatus[1]
                    .OperationStatus = "F"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectName = "GLB_GET_WKLST_QC_ACCNS"
                  set reply->status_data.subeventstatus[1]
                    .TargetObjectValue = 
                    "Unable to load QC accessions for worklist."
                  go to Exit_Script
               endif
               if (reply250102->status_data.status = "S")
                  ;*
                  ;* Insert QC accessions.
                  ;*
                  set ptr = size(reply250102->qual,5)
                  while (ptr > 0)
                     for (cnt = 1 to size(reply250102->qual,5))
                        if (reply250102->qual[cnt].pos = ptr)
                           ;* Check for QC accession insertion at
                           ;* beginning of orders list.
                           if (reply250102->qual[cnt].begin_ind = 1)
                              set o_cnt = 1
                              set stat = adjust_orders_list(o_cnt)
                              set rpt->orders[o_cnt].accession_id =
                                 reply250102->qual[cnt].accession_id
                              set rpt->orders[o_cnt].accession =
                                 reply250102->qual[cnt].unformat_accn
                              set rpt->orders[o_cnt].control_id = 
                                 reply250102->qual[cnt].control_id
                              set rpt->orders[o_cnt].control_name = 
                                 reply250102->qual[cnt].control_name
                              set rpt->orders[o_cnt].lot_id = 
                                 reply250102->qual[cnt].lot_id
                              set rpt->orders[o_cnt].lot_number = 
                                 reply250102->qual[cnt].lot_number
                              set rpt->orders[o_cnt]
                                 .service_resource_cd = 
                                 reply250102->qual[cnt]
                                 .service_resource_cd
                           endif
                           ;* Check for QC accession insertion at
                           ;* a given patient accession interval into
                           ;* the orders list.
                           if (reply250102->qual[cnt].interval_ind = 1)
                              set interval_cnt = 0
                              set idx = 1
                              while (idx <= rpt->orders_cnt)
                                 if (rpt->orders[idx].order_id > 0.0)
                                    set interval_cnt = interval_cnt + 1
                                    if (reply250102->qual[cnt]
                                       .interval = inteval_cnt)
                                       set o_cnt = idx + 1
                                       set stat = adjust_orders_list(o_cnt)
                                       set rpt->orders[o_cnt]
                                         .accession_id =
                                         reply250102->qual[cnt]
                                         .accession_id
                                       set rpt->orders[o_cnt]
                                         .accession =
                                         reply250102->qual[cnt]
                                         .unformat_accn
                                       set rpt->orders[o_cnt]
                                         .control_id = 
                                         reply250102->qual[cnt]
                                         .control_id
                                       set rpt->orders[o_cnt]
                                         .control_name = 
                                         reply250102->qual[cnt]
                                         .control_name
                                       set rpt->orders[o_cnt]
                                         .lot_id = 
                                         reply250102->qual[cnt]
                                         .lot_id
                                       set rpt->orders[o_cnt]
                                         .lot_number = 
                                         reply250102->qual[cnt]
                                         .lot_number
                                       set rpt->orders[o_cnt]
                                        .service_resource_cd = 
                                        reply250102->qual[cnt]
                                        .service_resource_cd
                                    endif
                                 endif
                                 set idx = idx + 1
                              endwhile
                           endif
                        endif
                     endfor
                     set ptr = ptr - 1
                  endwhile
                  for (ptr = 1 to size(reply250102->qual,5))
                     for (cnt = 1 to size(reply250102->qual,5))
                        if (reply250102->qual[cnt].pos = ptr)
                           ;* Check for QC accession insertion at
                           ;* end of orders list.
                           if (reply250102->qual[cnt].end_ind = 1)
                              set o_cnt = rpt->orders_cnt + 1
                              set stat = adjust_orders_list(o_cnt)
                              set rpt->orders[o_cnt].accession_id =
                                 reply250102->qual[cnt].accession_id
                              set rpt->orders[o_cnt].accession =
                                 reply250102->qual[cnt].unformat_accn
                              set rpt->orders[o_cnt].control_id = 
                                 reply250102->qual[cnt].control_id
                              set rpt->orders[o_cnt].control_name = 
                                 reply250102->qual[cnt].control_name
                              set rpt->orders[o_cnt].lot_id = 
                                 reply250102->qual[cnt].lot_id
                              set rpt->orders[o_cnt].lot_number = 
                                 reply250102->qual[cnt].lot_number
                              set rpt->orders[o_cnt]
                                 .service_resource_cd = 
                                 reply250102->qual[cnt]
                                 .service_resource_cd
                           endif
                        endif
                     endfor
                  endfor
               endif
            endif
         endif
         
      /***********************************************************************
      * Load Additional Order Information.                                   *
      ***********************************************************************/
         if (rpt->orders_cnt = 0)
            go to Report_Prep
         endif
         
         if (rpt->include_flag = 1)
            go to Load_QC_Info
         endif
         
         select into "nl:"
            d1.seq
           ,o.order_id
           ,ol.resource_route_level_flag
           ,p.person_id
           ,sexdisp = uar_get_code_display(p.sex_cd)
           ,e.encntr_id
           ,locationmean = uar_get_code_meaning(e.location_cd)
           ,facilitydisp = uar_get_code_display(e.loc_facility_cd)
           ,nurseunitdisp = uar_get_code_display(e.loc_nurse_unit_cd)
           ,roomdisp = uar_get_code_display(e.loc_room_cd)
           ,beddisp = uar_get_code_display(e.loc_bed_cd)
           ,d_pl.seq
           ,pl_exists = decode(pl.seq, "Y", "N")
           ,providername = concat(i18n_captions->dr,
             trim(pl.name_full_formatted))
           ,d_ea.seq
           ,ea_exists = decode(ea.seq, "Y", "N")
           ,mrn = cnvtalias(ea.alias, ea.alias_pool_cd)
           ,d_osrc.seq
           ,osrc_exists = decode(osrc.seq, "Y", "N")
           ,osrc.order_id
           ,c_exists = decode(c.seq, "Y", "N")
           ,c.container_id

         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,orders o
           ,order_laboratory ol
           ,person p
           ,encounter e
           ,(dummyt d_pl with seq = 1)
           ,prsnl pl
           ,(dummyt d_ea with seq = 1)
           ,encntr_alias ea
           ,(dummyt d_osrc with seq = 1)
           ,order_serv_res_container osrc
           ,container c
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join o
            where o.order_id = rpt->orders[d1.seq].order_id
         join ol
            where ol.order_id = o.order_id
         join p
            where p.person_id = o.person_id
         join e
            where e.encntr_id = o.encntr_id
         join d_pl
            where d_pl.seq = 1
         join pl
            where pl.person_id = o.last_update_provider_id
         join d_ea
            where d_ea.seq = 1
         join ea
            where ea.encntr_id = o.encntr_id
              and ea.encntr_alias_type_cd = alias_type_mrn_cd
         join d_osrc
            where d_osrc.seq = 1
         join osrc
            where osrc.order_id = o.order_id
         join c
            where c.container_id = osrc.container_id
            
         order by
            d1.seq
            
         head report
            person_age = fillstring(12, " ")
            
         head d1.seq
            o_cnt = d1.seq
            rpt->orders[o_cnt].catalog_cd = o.catalog_cd
            rpt->orders[o_cnt].resource_route_level_flag =
              ol.resource_route_level_flag
            rpt->orders[o_cnt].encntr_id = o.encntr_id
            rpt->orders[o_cnt].sex_cd = p.sex_cd
            rpt->orders[o_cnt].sex_disp = sexdisp
            rpt->orders[o_cnt].location_cd = e.location_cd
            rpt->orders[o_cnt].location_mean = locationmean
            rpt->orders[o_cnt].facility_cd = e.loc_facility_cd
            rpt->orders[o_cnt].facility_disp = facilitydisp
            rpt->orders[o_cnt].nurse_unit_cd = e.loc_nurse_unit_cd
            rpt->orders[o_cnt].nurse_unit_disp = nurseunitdisp
            rpt->orders[o_cnt].room_cd = e.loc_room_cd
            rpt->orders[o_cnt].room_disp = roomdisp
            rpt->orders[o_cnt].bed_cd = e.loc_bed_cd
            rpt->orders[o_cnt].bed_disp = beddisp
            if (e.loc_room_cd > 0.0
            and e.loc_bed_cd > 0.0)
               rpt->orders[o_cnt].roombed_disp = concat(
                 trim(roomdisp), "-", trim(beddisp))
            elseif (e.loc_room_cd > 0.0
            and e.loc_bed_cd = 0.0)
               rpt->orders[o_cnt].roombed_disp = trim(roomdisp)
            elseif (e.loc_room_cd = 0.0
            and e.loc_bed_cd = 0.0)
               rpt->orders[o_cnt].roombed_disp = trim(beddisp)
            endif
            rpt->orders[o_cnt].visit_reason = e.reason_for_visit
            rpt->orders[o_cnt].last_update_provider_id = 
              o.last_update_provider_id
            if (pl_exists = "Y")
               rpt->orders[o_cnt].provider_name = providername
            else
               rpt->orders[o_cnt].provider_name = i18n_captions->dr
            endif
            if (ea_exists = "Y")
               rpt->orders[o_cnt].med_rec_nbr = mrn
            endif
            if (osrc_exists = "Y"
            and c_exists = "Y")
               rpt->orders[o_cnt].drawn_dt_tm = 
                 cnvtdatetime(c.drawn_dt_tm)
            endif
            ;*
            ;* Calculate person age.
            ;*
            ;*  Hours: "Std." 
            ;*  Day(s): "Tag(e)" (remark: "Tag" is singular, "Tage" is plural) 
            ;*  Month(s): "Mon."
            ;*  Year(s): "Jahr(e)" (remark: "Jahr" is singular, "Jahre" is plural)
            person_age = fillstring(12, " ")
            if (p.birth_dt_tm > 0)
               person_age = cnvtage(p.birth_dt_tm,curr->system_dt_tm,0)
               ptr = 0
               if (findstring("Jahr", person_age) > 0)
                  if (cnvtint(substring(1,3,person_age)) = 1)
                     rpt->orders[o_cnt].age = "1 Jahr"
                  else
                     rpt->orders[o_cnt].age = concat(trim(substring(1,3,person_age),3)," Jahre")
                  endif
               elseif (findstring("Monate", person_age) > 0)
                  rpt->orders[o_cnt].age = concat(trim(substring(1,3,person_age),3)," Mon.")
               elseif (findstring("Woche", person_age) > 0)
                  if (cnvtint(substring(1,3,person_age)) = 1)
                     rpt->orders[o_cnt].age = "1 Woche"
                  else
                     rpt->orders[o_cnt].age = concat(trim(substring(1,3,person_age),3)," Wochen")
                  endif
               elseif (findstring("Tag", person_age) > 0)
                  if (cnvtint(substring(1,3,person_age)) = 1)
                     rpt->orders[o_cnt].age = "1 Tag"
                  else
                     rpt->orders[o_cnt].age = concat(trim(substring(1,3,person_age),3)," Tage")
                  endif
               else
                  rpt->orders[o_cnt].age = concat(trim(substring(1,5,person_age),3)," Std.")
               endif
            endif

         with
            nocounter
           ,outerjoin = d_pl
           ,dontcare = pl
           ,outerjoin = d_ea
           ,dontcare = ea
           ,outerjoin = d_osrc
           ,dontcare = osrc
           ,dontcare = c
      
      /***********************************************************************
      * Load Person Comments.                                                *
      ***********************************************************************/
         if (rpt->person_comments_ind = 0)
            go to Load_Order_Comments
         endif
         
         set max_pc_cnt = 0

         ;*
         ;* Determine if person comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,pi.person_id
           ,pi.beg_effective_dt_tm
           
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,person_info pi
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join pi
            where pi.person_id = rpt->orders[d1.seq].person_id
              and pi.info_type_cd = info_type_comment_cd
              and pi.active_ind = 1
              
         order by
            d1.seq
           ,pi.person_id
           ,cnvtdatetime(pi.beg_effective_dt_tm) desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].person_comment_cnt
            cnt = cnt + 1
            if (cnt > max_pc_cnt)
               max_pc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].person_comment, cnt)
            rpt->orders[o_cnt].person_comment_cnt = cnt
            rpt->orders[o_cnt].person_comment[cnt].comment_type_cd = 
              pi.info_type_cd
            rpt->orders[o_cnt].person_comment[cnt].long_text_id = 
              pi.long_text_id

         with
            nocounter
         
         ;*
         ;* Determine if person notes exist.
         ;*
         select into "nl:"
            d1.seq
           ,pi.person_id
           ,pi.beg_effective_dt_tm
           
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,person_info pi
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join pi
            where pi.person_id = rpt->orders[d1.seq].person_id
              and pi.info_type_cd = info_type_note_cd
              and pi.active_ind = 1
              
         order by
            d1.seq
           ,pi.person_id
           ,cnvtdatetime(pi.beg_effective_dt_tm) desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].person_comment_cnt
            cnt = cnt + 1
            if (cnt > max_pc_cnt)
               max_pc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].person_comment, cnt)
            rpt->orders[o_cnt].person_comment_cnt = cnt
            rpt->orders[o_cnt].person_comment[cnt].comment_type_cd = 
              pi.info_type_cd
            rpt->orders[o_cnt].person_comment[cnt].long_text_id = 
              pi.long_text_id

         with
            nocounter
         
         ;*
         ;* Load person comments & notes
         ;*
         if (max_pc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq  
              ,lt.long_text_id
               
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_pc_cnt))
              ,long_text lt
           
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].person_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].person_comment_cnt
            join lt
               where lt.long_text_id = 
                 rpt->orders[d1.seq].person_comment[d2.seq].long_text_id
              
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].person_comment[cnt].comment = 
                 lt.long_text
            
            with
               nocounter
         endif

      /***********************************************************************
      * Load Encounter Comments.                                             *
      ***********************************************************************/
         if (rpt->person_comments_ind = 0)
            go to Load_Order_Comments
         endif
         
         set max_ec_cnt = 0

         ;*
         ;* Determine if encounter comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,ei.encntr_id
           ,ei.beg_effective_dt_tm
           
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,encntr_info ei
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ei
            where ei.encntr_id = rpt->orders[d1.seq].encntr_id
              and ei.info_type_cd = info_type_comment_cd
              and ei.active_ind = 1
              
         order by
            d1.seq
           ,ei.encntr_id
           ,cnvtdatetime(ei.beg_effective_dt_tm) desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].encntr_comment_cnt
            cnt = cnt + 1
            if (cnt > max_ec_cnt)
               max_ec_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].encntr_comment, cnt)
            rpt->orders[o_cnt].encntr_comment_cnt = cnt
            rpt->orders[o_cnt].encntr_comment[cnt].comment_type_cd = 
              ei.info_type_cd
            rpt->orders[o_cnt].encntr_comment[cnt].long_text_id = 
              ei.long_text_id

         with
            nocounter
         
         ;*
         ;* Determine if encounter notes exist.
         ;*
         select into "nl:"
            d1.seq
           ,ei.encntr_id
           ,ei.beg_effective_dt_tm
           
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,encntr_info ei
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ei
            where ei.encntr_id = rpt->orders[d1.seq].encntr_id
              and ei.info_type_cd = info_type_note_cd
              and ei.active_ind = 1
              
         order by
            d1.seq
           ,ei.encntr_id
           ,cnvtdatetime(ei.beg_effective_dt_tm) desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].encntr_comment_cnt
            cnt = cnt + 1
            if (cnt > max_ec_cnt)
               max_ec_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].encntr_comment, cnt)
            rpt->orders[o_cnt].encntr_comment_cnt = cnt
            rpt->orders[o_cnt].encntr_comment[cnt].comment_type_cd = 
              ei.info_type_cd
            rpt->orders[o_cnt].encntr_comment[cnt].long_text_id = 
              ei.long_text_id

         with
            nocounter
         
         ;*
         ;* Load encounter comments & notes
         ;*
         if (max_ec_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq  
              ,lt.long_text_id
               
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_ec_cnt))
              ,long_text lt
           
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].encntr_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].encntr_comment_cnt
            join lt
               where lt.long_text_id = 
                 rpt->orders[d1.seq].encntr_comment[d2.seq].long_text_id
              
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].encntr_comment[cnt].comment = 
                 lt.long_text
            
            with
               nocounter
         endif

      /***********************************************************************
      * Load Order Comments and Order Footnotes.                             *
      ***********************************************************************/
      #Load_Order_Comments
         if (rpt->order_comments_ind = 0)
            go to Load_Cross_Res_Results
         endif
         
         set max_oc_cnt = 0
         ;*
         ;* Determine if order comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,oc.order_id
           ,oc.action_sequence
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,order_comment oc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join oc
            where oc.order_id = rpt->orders[d1.seq].order_id
              and oc.action_sequence >= 0
              and oc.comment_type_cd = comment_type_ord_comment_cd
              
         order by
            d1.seq
           ,oc.order_id
           ,oc.action_sequence desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].order_comment_cnt
            cnt = cnt + 1
            if (cnt > max_oc_cnt)
               max_oc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].order_comment, cnt)
            rpt->orders[o_cnt].order_comment_cnt = cnt
            rpt->orders[o_cnt].order_comment[cnt].comment_type_cd = 
              oc.comment_type_cd
            rpt->orders[o_cnt].order_comment[cnt].long_text_id = 
              oc.long_text_id
            
         with
            nocounter
         
         ;*
         ;* Determine if order footnotes exist.
         ;*
         select into "nl:"
            d1.seq
           ,oc.order_id
           ,oc.action_sequence
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,order_comment oc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join oc
            where oc.order_id = rpt->orders[d1.seq].order_id
              and oc.action_sequence >= 0
              and oc.comment_type_cd = comment_type_ord_note_cd
              
         order by
            d1.seq
           ,oc.order_id
           ,oc.action_sequence desc
           
         head d1.seq
            o_cnt = d1.seq
            cnt = rpt->orders[o_cnt].order_comment_cnt
            cnt = cnt + 1
            if (cnt > max_oc_cnt)
               max_oc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].order_comment, cnt)
            rpt->orders[o_cnt].order_comment_cnt = cnt
            rpt->orders[o_cnt].order_comment[cnt].comment_type_cd = 
              oc.comment_type_cd
            rpt->orders[o_cnt].order_comment[cnt].long_text_id = 
              oc.long_text_id
            
         with
            nocounter
         
         ;*
         ;* Load order comments and order footnotes
         ;*
         if (max_oc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,lt.long_text_id
            
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_oc_cnt))
              ,long_text lt
           
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
                 and rpt->orders[d1.seq].order_comment_cnt > 0
            join d2
               where d2.seq <= rpt->orders[d1.seq].order_comment_cnt
            join lt
               where lt.long_text_id = 
                 rpt->orders[d1.seq].order_comment[d2.seq].long_text_id
              
            detail
               o_cnt = d1.seq
               cnt = d2.seq
               rpt->orders[o_cnt].order_comment[cnt].comment = 
                 lt.long_text
            
            with
               nocounter
         endif
       
      /***********************************************************************
      * Load Cross Resource Results.                                         *
      ***********************************************************************/
      #Load_Cross_Res_Results
         set max_a_cnt = 0
         set max_r_cnt = 0
         
         if (rpt->result_space_ind = 0)
            go to Load_QC_Info
         endif
         
         if (rpt->cross_resource_ind = 0)
            go to Load_Current_Results
         endif
         
         select into "nl:"
            d1.seq
           ,ptr.catalog_cd
           ,ptr.task_assay_cd
           ,task_assay_disp = uar_get_code_display(ptr.task_assay_cd)
           ,ope.service_resource_cd
           ,apr.display_sequence
           ,d_r.seq
           ,r_exists = decode(r.seq, "Y", "N")
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,re.event_personnel_id
           ,pl_pr.username
           ,pl_re.username
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,profile_task_r ptr
           ,order_procedure_exception ope
           ,assay_processing_r apr
           ,(dummyt d_r with seq = 1)
           ,result r
           ,perform_result pr
           ,result_event re
           ,prsnl pl_pr
           ,prsnl pl_re
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ptr
            where ptr.catalog_cd = rpt->orders[d1.seq].catalog_cd
         join ope
            where ope.order_id = rpt->orders[d1.seq].order_id
              and ope.task_assay_cd = ptr.task_assay_cd
              and ope.service_resource_cd != rpt->service_resource_cd
         join apr
            where apr.task_assay_cd = ptr.task_assay_cd
              and apr.service_resource_cd = ope.service_resource_cd
              and apr.active_ind = 1
         join d_r
            where d_r.seq = 1
         join r
            where r.order_id = rpt->orders[d1.seq].order_id
              and r.task_assay_cd = ptr.task_assay_cd
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join re
            where re.result_id = pr.result_id
              and re.perform_result_id = pr.perform_result_id
              and re.event_type_cd = r.result_status_cd
         join pl_pr
            where pl_pr.person_id = pr.perform_personnel_id
         join pl_re
            where pl_re.person_id = re.event_personnel_id
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id
         
         order by
            d1.seq
           ,ptr.catalog_cd
           ,apr.display_sequence
           ,ptr.task_assay_cd
           ,r.result_id
           ,pr.repeat_nbr
         
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
            r_cnt = 0
            idx = 0
            dta_match_found = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            correctflag = " "
            a_cnt = rpt->orders[o_cnt].assays_cnt
            
         head ptr.task_assay_cd
            dta_match_found = 0
            if (rpt->procedure_inc_flag = 2)
               ;* Detail (i.e. task assay) level.  Validate
               ;* that the task assay qualifies for the report.
               if (rpt->procs_cnt > 0)
                 for (cnt = 1 to rpt->procs_cnt)   
                     if (rpt->procs[cnt].procedure_cd = ptr.task_assay_cd)
                        dta_match_found = 1
                     endif
                  endfor
               endif
            else
               ;* Group (i.e. orderable) level.
               ;* All discrete task assays qualify for the report.
               dta_match_found = 1
            endif
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = 
                  ptr.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
               rpt->orders[o_cnt].assays[a_cnt].cross_resource_ind = 1
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_perform_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_status_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_type_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_less_great_flag = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_numeric_raw_value = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_flags = fillstring(10, " ")
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_factor = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_elapse_time = " "
            endif

         head r.result_id
            r_cnt = rpt->orders[o_cnt].assays[a_cnt].results_cnt
            
         head pr.repeat_nbr
            if (dta_match_found = 1
            and r_exists = "Y"
            and r.result_id > 0.0)
               r_cnt = r_cnt + 1
               if (r_cnt > max_r_cnt)
                  max_r_cnt = r_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
                 .results, r_cnt)
               rpt->orders[o_cnt].assays[a_cnt].results_cnt = r_cnt
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_id = r.result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perform_result_id = pr.perform_result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_status_cd = r.result_status_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_type_cd = pr.result_type_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .less_great_flag = pr.less_great_flag
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .dilution_factor = pr.dilution_factor
               if (pr.dilution_factor > 0.0)
                  dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
                  idx = 1
                  ;* Remove leading zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx + 1
                  endwhile
                  idx = 6
                  ;* Remove trailing zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx - 1
                  endwhile
                  ;* Remove decimal point if not needed
                  if (substring(idx, 1, dilution_val )= ".")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                  endif
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .dilution_value = concat("x", trim(dilution_val,3))
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_tech_id = pr.perform_personnel_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_dt_tm = cnvtdatetime(pr.perform_dt_tm)
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_username = pl_pr.username
               if (r.result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = re.event_personnel_id
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_dt_tm = cnvtdatetime(re.event_dt_tm)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = pl_re.username
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = 0.0
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = " "
               endif
               if (pr.result_type_cd = result_type_text_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = i18n_captions->text
               endif
               if (pr.result_type_cd = result_type_alpha_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.result_value_alpha
               endif
               if (pr.result_type_cd = result_type_numeric_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               if (pr.result_type_cd = result_type_interp_cd)
                  if (trim(pr.result_value_alpha) > " ")
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = pr.result_value_alpha
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = i18n_captions->text
                  endif
               endif
               if (pr.result_type_cd = result_type_date_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = 
                    format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
               endif
               if (pr.result_type_cd = result_type_freetext_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.ascii_text
               endif
               if (pr.result_type_cd = result_type_calc_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               ;*
               ;* Build result flags string
               ;*
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = fillstring(10, " ")
               if (pr.normal_cd > 0.0
               and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                   RESULT_PRCSS_NORMAL_LOW_CDF,
                                   RESULT_PRCSS_ALP_ABNORMAL_CDF))
                  normflag = substring(1,1,normal_disp)
               else
                  normflag = " "
               endif
               if (pr.critical_cd > 0.0
               and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                     RESULT_PRCSS_ALP_CRITICAL_CDF))
                  critflag = substring(1,1,critical_disp)
               else
                  critflag = " "
               endif
               if (pr.review_cd > 0.0
               and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                   RESULT_PRCSS_ALP_REVIEW_CDF))
                  revwflag = substring(1,1,review_disp)
               else
                  revwflag = " "
               endif
               if (pr.linear_cd > 0.0
               and linear_mean = RESULT_PRCSS_LINEAR_CDF)
                  linearflag = substring(1,1,linear_disp)
               else
                  linearflag = " "
               endif
               if (pr.feasible_cd > 0.0
               and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
                  feasflag = substring(1,1,feasible_disp)
               else
                  feasflag = " "
               endif
               if (pr.delta_cd > 0.0
               and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
                  deltaflag = substring(1,1,delta_disp)
               else
                  deltaflag = " "
               endif
               if (rc_exists = "Y")
                  rcommentflag = "Y"
                  rnoteflag = "Y"
               else
                  rcommentflag = "N"
                  rnoteflag = "N"
               endif
               if (r.result_status_cd = corrected_cd)
                  correctflag = "Y"
               else
                  correctflag = "N"
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = bldresultflagstr(normflag, 
                 critflag, revwflag, linearflag, feasflag, 
                 deltaflag, rcommentflag, rnoteflag, correctflag)
            endif
            
         with
            nocounter
           ,outerjoin = d_r
           ,dontcare = r
           ,dontcare = pr
           ,dontcare = re
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
           
      /***********************************************************************
      * Load Current Results.                                                *
      ***********************************************************************/
      #Load_Current_Results
         select into "nl:"
            d1.seq
           ,ptr.catalog_cd
           ,ptr.task_assay_cd
           ,task_assay_disp = uar_get_code_display(ptr.task_assay_cd)
           ,apr.service_resource_cd
           ,apr.display_sequence
           ,d_ope.seq
           ,ope_exists = decode(ope.seq, "Y", "N")
           ,d_r.seq
           ,r_exists = decode(r.seq, "Y", "N")
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,re.event_personnel_id
           ,pl_pr.username
           ,pl_re.username
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,profile_task_r ptr
           ,assay_processing_r apr
           ,(dummyt d_ope with seq = 1)
           ,order_procedure_exception ope
           ,(dummyt d_r with seq = 1)
           ,result r
           ,perform_result pr
           ,result_event re
           ,prsnl pl_pr
           ,prsnl pl_re
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join ptr
            where ptr.catalog_cd = rpt->orders[d1.seq].catalog_cd
         join apr
            where apr.task_assay_cd = ptr.task_assay_cd
              and apr.service_resource_cd = rpt->service_resource_cd
              and apr.active_ind = 1
         join d_ope
            where d_ope.seq = 1
         join ope
            where ope.order_id = rpt->orders[d1.seq].order_id
              and ope.task_assay_cd = apr.task_assay_cd
              and ope.service_resource_cd +0 = rpt->service_resource_cd
              and rpt->orders[d1.seq].resource_route_level_flag = 2
         join d_r
            where d_r.seq = 1
         join r
            where r.order_id = rpt->orders[d1.seq].order_id
              and r.task_assay_cd = ptr.task_assay_cd
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join re
            where re.result_id = pr.result_id
              and re.perform_result_id = pr.perform_result_id
              and re.event_type_cd = r.result_status_cd
         join pl_pr
            where pl_pr.person_id = pr.perform_personnel_id
         join pl_re
            where pl_re.person_id = re.event_personnel_id
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id
         
         order by
            d1.seq
           ,ptr.catalog_cd
           ,apr.display_sequence
           ,ptr.task_assay_cd
           ,r.result_id
           ,pr.repeat_nbr
         
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
            r_cnt = 0
            idx = 0
            dta_match_found = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            correctflag = " "
            a_cnt = rpt->orders[o_cnt].assays_cnt
            
         head ptr.task_assay_cd
            ;* Determine if discrete task assay qualifies.
            dta_match_found = 0
            if (rpt->procedure_inc_flag = 2)
               ;* Detail (i.e. task assay) level.  Validate
               ;* that the task assay qualifies for the report.
               if (rpt->procs_cnt > 0)
                  for (cnt = 1 to rpt->procs_cnt)
                     if (rpt->procs[cnt].procedure_cd = ptr.task_assay_cd)
                        dta_match_found = 1
                     endif
                  endfor
               endif
            else
               ;* Group (i.e. orderable) level.
               ;* All discrete task assays qualify for the report.
               dta_match_found = 1
            endif
            ;* Validate that task assay wasn't previously loaded
            ;* during cross resource results load.
            if (rpt->orders[o_cnt].assays_cnt > 0)
            	for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
            		if (rpt->orders[o_cnt].assays[a_cnt]
            		  .task_assay_cd = ptr.task_assay_cd
            		and rpt->orders[o_cnt].assays[a_cnt]
            		  .cross_resource_ind = 1)
            		   dta_match_found = 0
            		endif
            	endfor
            endif
            ;* Validate that the task assay was routed to the
            ;* service resource associate with the worklist 
            ;* for level 2 orders.
            if (rpt->orders[o_cnt].resource_route_level_flag = 2
            and ope_exists = "N")
               dta_match_found = 0
            endif
            ;* Check for new assay to add to report.
            if (dta_match_found = 1)
               a_cnt = rpt->orders[o_cnt].assays_cnt
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = 
                  ptr.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
               rpt->orders[o_cnt].assays[a_cnt].cross_resource_ind = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_perform_result_id = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_status_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_type_cd = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_less_great_flag = 0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_numeric_raw_value = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_result_flags = fillstring(10, " ")
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_factor = 0.0
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_dilution_value = ""
               rpt->orders[o_cnt].assays[a_cnt]
                 .prev_elapse_time = " "
            endif

         head r.result_id
            if (dta_match_found = 1)
               r_cnt = rpt->orders[o_cnt].assays[a_cnt].results_cnt
            endif
            
         head pr.repeat_nbr
            if (dta_match_found = 1
            and r_exists = "Y"
            and r.result_id > 0.0)
               r_cnt = r_cnt + 1
               if (r_cnt > max_r_cnt)
                  max_r_cnt = r_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
                 .results, r_cnt)
               rpt->orders[o_cnt].assays[a_cnt].results_cnt = r_cnt
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_id = r.result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perform_result_id = pr.perform_result_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_status_cd = r.result_status_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_type_cd = pr.result_type_cd
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .less_great_flag = pr.less_great_flag
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .dilution_factor = pr.dilution_factor
               if (pr.dilution_factor > 0.0)
                  dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
                  idx = 1
                  ;* Remove leading zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx + 1
                  endwhile
                  idx = 6
                  ;* Remove trailing zeroes
                  while(substring(idx, 1, dilution_val) = "0")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                     idx = idx - 1
                  endwhile
                  ;* Remove decimal point if not needed
                  if (substring(idx, 1, dilution_val )= ".")
                     l = movestring(" ", 1, dilution_val, idx, 1)
                  endif
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .dilution_value = concat("x", trim(dilution_val,3))
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_tech_id = pr.perform_personnel_id
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_dt_tm = cnvtdatetime(pr.perform_dt_tm)
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .perf_username = pl_pr.username
               if (r.result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = re.event_personnel_id
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_dt_tm = cnvtdatetime(re.event_dt_tm)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = pl_re.username
               else
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_tech_id = 0.0
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .verf_username = " "
               endif
               if (pr.result_type_cd = result_type_text_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = i18n_captions->text
               endif
               if (pr.result_type_cd = result_type_alpha_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.result_value_alpha
               endif
               if (pr.result_type_cd = result_type_numeric_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               if (pr.result_type_cd = result_type_interp_cd)
                  if (trim(pr.result_value_alpha) > " ")
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = pr.result_value_alpha
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .result_value = i18n_captions->text
                  endif
               endif
               if (pr.result_type_cd = result_type_date_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = 
                    format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
               endif
               if (pr.result_type_cd = result_type_freetext_cd)
                  rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_value = pr.ascii_text
               endif
               if (pr.result_type_cd = result_type_calc_cd)
                  if (pr.less_great_flag > 0)
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.result_value_numeric
                  else
                     rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .numeric_raw_value = pr.numeric_raw_value
                  endif
               endif
               ;*
               ;* Build result flags string
               ;*
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = fillstring(10, " ")
               if (pr.normal_cd > 0.0
               and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                   RESULT_PRCSS_NORMAL_LOW_CDF,
                                   RESULT_PRCSS_ALP_ABNORMAL_CDF))
                  normflag = substring(1,1,normal_disp)
               else
                  normflag = " "
               endif
               if (pr.critical_cd > 0.0
               and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                     RESULT_PRCSS_ALP_CRITICAL_CDF))
                  critflag = substring(1,1,critical_disp)
               else
                  critflag = " "
               endif
               if (pr.review_cd > 0.0
               and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                   RESULT_PRCSS_ALP_REVIEW_CDF))
                  revwflag = substring(1,1,review_disp)
               else
                  revwflag = " "
               endif
               if (pr.linear_cd > 0.0
               and linear_mean = RESULT_PRCSS_LINEAR_CDF)
                  linearflag = substring(1,1,linear_disp)
               else
                  linearflag = " "
               endif
               if (pr.feasible_cd > 0.0
               and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
                  feasflag = substring(1,1,feasible_disp)
               else
                  feasflag = " "
               endif
               if (pr.delta_cd > 0.0
               and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
                  deltaflag = substring(1,1,delta_disp)
               else
                  deltaflag = " "
               endif
               if (rc_exists = "Y")
                  rcommentflag = "Y"
                  rnoteflag = "Y"
               else
                  rcommentflag = "N"
                  rnoteflag = "N"
               endif
               if (r.result_status_cd = corrected_cd)
                  correctflag = "Y"
               else
                  correctflag = "N"
               endif
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_flags = bldresultflagstr(normflag, 
                 critflag, revwflag, linearflag, feasflag, 
                 deltaflag, rcommentflag, rnoteflag, correctflag)
            endif
            
         with
            nocounter
           ,outerjoin = d_ope
           ,dontcare = ope
           ,outerjoin = d_r
           ,dontcare = r
           ,dontcare = pr
           ,dontcare = re
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
           
         if (max_a_cnt = 0)
            go to Load_QC_Info
         endif

         if (max_r_cnt = 0)
            go to Load_Prev_Results
         endif
         
      /***********************************************************************
      * Format Numeric & Calculated Current Results                          *
      ***********************************************************************/
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,d_dm.seq
           ,dm_exists = decode(dm.seq, "Y", "N")
           ,dm.service_resource_cd
           ,dm.task_assay_cd
           ,dm.data_map_type_flag
           ,dm.max_digits
           ,dm.min_decimal_places
           ,dm.min_digits
           ,d_rg.seq
           ,rg_exists = decode(rg.seq, "Y", "N")
           ,rg.parent_service_resource_cd
           ,rg.child_service_resource_cd
           ,rg.resource_group_type_cd
           ,rg.root_service_resource_cd

         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,(dummyt d_dm with seq = 1)
           ,data_map dm
           ,(dummyt d_rg with seq = 1)
           ,resource_group rg

         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
              and rpt->orders[d1.seq].assays[d2.seq].results[d3.seq]
                   .result_type_cd in (result_type_numeric_cd,
                                       result_type_calc_cd)
         join d_dm 
            where d_dm.seq = 1
         join dm  
            where dm.task_assay_cd = rpt->orders[d1.seq]
                             .assays[d2.seq].task_assay_cd
              and dm.data_map_type_flag = 0
              and dm.active_ind = 1
         join d_rg 
            where d_rg.seq = 1
         join rg
            where rg.parent_service_resource_cd = 
                             dm.service_resource_cd
              and rg.child_service_resource_cd = 
                             rpt->service_resource_cd 
              and rg.resource_group_type_cd =
                            serv_res_subsection_cd
              and rg.root_service_resource_cd + 0 = 0.0
              
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
           
         head report
            data_map_level = 0
            arg_max_digits = 0
            arg_min_digits = 0
            arg_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
            
         head d1.seq
            o_cnt = d1.seq
            
         head d2.seq
            a_cnt = d2.seq
            
         head d3.seq
            r_cnt = d3.seq
            ;*
            ;* Set default data map parameters
            ;*
            data_map_level = 0
            arg_max_digits = 8
            arg_min_digits = 1
            arg_min_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0

         detail
            ;*
            ;* Check for exact match on data map
            ;*
            if (data_map_level <= 2
            and dm.service_resource_cd > 0.0
            and dm.service_resource_cd = rpt->service_resource_cd)
               data_map_level = 3
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for subsection level data map
            ;*
            if (data_map_level <= 1
            and dm.service_resource_cd > 0.0
            and rg_exists = "Y"
            and rg.parent_service_resource_cd =
                             dm.service_resource_cd
            and rg.child_service_resource_cd =
                             rpt->service_resource_cd)
               data_map_level = 2
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for default all resources level data map
            ;*
            if (data_map_level = 0
            and dm.service_resource_cd = 0.0)
               data_map_level = 1
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif

         foot d3.seq
            arg_less_great_flag = rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].less_great_flag
            arg_raw_numeric_result = rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].numeric_raw_value
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_value = uar_fmt_result(arg_min_digits,
                                             arg_max_digits, 
                                             arg_min_decimal_places,
                                             arg_less_great_flag,
                                             arg_raw_numeric_result)
         with
            nocounter
           ,outerjoin = d_dm
           ,dontcare = dm
           ,outerjoin = d_rg
           ,dontcare = rg

      /***********************************************************************
      * Load Result Comments and Result Footnotes.                           *
      ***********************************************************************/
         if (rpt->result_comments_ind = 0)
            go to Load_Prev_Results
         endif

         set max_rc_cnt = 0
         ;*
         ;* Determine if result comments exist.
         ;*
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,result_comment rc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
         join rc
            where rc.result_id = rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_id
              and rc.action_sequence >= 0
              and rc.comment_type_cd = comment_type_res_comment_cd
              
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence desc
           
         head d1.seq
            o_cnt = d1.seq

         head d2.seq
            a_cnt = d2.seq
            
         head d3.seq
            r_cnt = d3.seq
            cnt = rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt
            cnt = cnt + 1
            if (cnt > max_rc_cnt)
               max_rc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].result_comment, cnt)
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt = cnt
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].comment_type_cd = rc.comment_type_cd
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].long_text_id = rc.long_text_id
            
         with
            nocounter
         
         ;*
         ;* Determine if result footnotes exist.
         ;*
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d3 with seq = value(max_r_cnt))
           ,result_comment rc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d3
            where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt
         join rc
            where rc.result_id = rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_id
              and rc.action_sequence >= 0
              and rc.comment_type_cd = comment_type_res_note_cd
              
         order by
            d1.seq
           ,d2.seq
           ,d3.seq
           ,rc.result_id
           ,rc.action_sequence desc
           
         head d1.seq
            o_cnt = d1.seq

         head d2.seq
            a_cnt = d2.seq
            
         head d3.seq
            r_cnt = d3.seq
            cnt = rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt
            cnt = cnt + 1
            if (cnt > max_rc_cnt)
               max_rc_cnt = cnt
            endif
            stat = alterlist(rpt->orders[o_cnt].assays[a_cnt]
              .results[r_cnt].result_comment, cnt)
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment_cnt = cnt
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].comment_type_cd = rc.comment_type_cd
            rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
              .result_comment[cnt].long_text_id = rc.long_text_id
            
         with
            nocounter
         
         ;*
         ;* Load result comments and result footnotes
         ;*
            if (max_rc_cnt > 0)
            select into "nl:"
               d1.seq
              ,d2.seq
              ,d3.seq
              ,d4.seq
              ,lt.long_text_id
            
            from
               (dummyt d1 with seq = value(rpt->orders_cnt))
              ,(dummyt d2 with seq = value(max_a_cnt))
              ,(dummyt d3 with seq = value(max_r_cnt))
              ,(dummyt d4 with seq = value(max_rc_cnt))
              ,long_text lt
           
            plan d1
               where d1.seq <= rpt->orders_cnt
                 and rpt->orders[d1.seq].order_id > 0.0
            join d2
               where d2.seq <= rpt->orders[d1.seq].assays_cnt
            join d3
               where d3.seq <= rpt->orders[d1.seq].assays[d2.seq]
                             .results_cnt
                 and rpt->orders[d1.seq].assays[d2.seq].results[d3.seq]
                             .result_comment_cnt > 0
            join d4
               where d4.seq <= rpt->orders[d1.seq].assays[d2.seq]
                             .results[d3.seq].result_comment_cnt
            join lt
               where lt.long_text_id = rpt->orders[d1.seq]
                             .assays[d2.seq].results[d3.seq]
                             .result_comment[d4.seq].long_text_id
              
            detail
               o_cnt = d1.seq
               a_cnt = d2.seq
               r_cnt = d3.seq
               cnt = d4.seq
               rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                 .result_comment[cnt].comment = lt.long_text
            
            with
               nocounter
         endif
         
      /***********************************************************************
      * Load Previous Results.                                               *
      ***********************************************************************/
      #Load_Prev_Results
         if (rpt->previous_result_ind = 0)
            go to Load_QC_Info
         endif
         
         select into "nl:"
            d1.seq
           ,d2.seq
           ,r.result_id
           ,pr.perform_result_id
           ,pr.repeat_nbr
           ,normal_disp = uar_get_code_display(pr.normal_cd)
           ,normal_mean = uar_get_code_meaning(pr.normal_cd)
           ,critical_disp = uar_get_code_display(pr.critical_cd)
           ,critical_mean = uar_get_code_meaning(pr.critical_cd)
           ,review_disp = uar_get_code_display(pr.review_cd)
           ,review_mean = uar_get_code_meaning(pr.review_cd)
           ,linear_disp = uar_get_code_display(pr.linear_cd)
           ,linear_mean = uar_get_code_meaning(pr.linear_cd)
           ,feasible_disp = uar_get_code_display(pr.feasible_cd)
           ,feasible_mean = uar_get_code_meaning(pr.feasible_cd)
           ,delta_disp = uar_get_code_display(pr.delta_cd)
           ,delta_mean = uar_get_code_meaning(pr.delta_cd)
           ,c.drawn_dt_tm
           ,d_rc.seq
           ,rc_exists = decode(rc.seq, "Y", "N")
           ,rc.result_id
            
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,result r
           ,perform_result pr
           ,container c
           ,(dummyt d_rc with seq = 1)
           ,result_comment rc
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join r
            where r.person_id = rpt->orders[d1.seq].person_id
              and r.task_assay_cd = 
                rpt->orders[d1.seq].assays[d2.seq].task_assay_cd
              and r.result_status_cd in (verified_cd, 
                                         autoverified_cd, 
                                         corrected_cd)
              and r.order_id + 0 != rpt->orders[d1.seq].order_id
         join pr
            where pr.result_id = r.result_id
              and pr.result_status_cd = r.result_status_cd
         join c
            where c.container_id = pr.container_id
              and c.drawn_dt_tm < 
                cnvtdatetime(rpt->orders[d1.seq].drawn_dt_tm)
         join d_rc
            where d_rc.seq = 1
         join rc
            where rc.result_id = pr.result_id
         
         order by
            d1.seq
           ,d2.seq
           ,cnvtdatetime(c.drawn_dt_tm) desc
         
         head d1.seq
            o_cnt = d1.seq
            idx = 0
            normflag = " "
            critflag = " "
            revwflag = " "
            linearflag = " "
            feasflag = " "
            rcommentflag = " "
            rnoteflag = " "
            correctflag = " "
            specimen_age = fillstring(12, " ")
            
         head d2.seq
            a_cnt = d2.seq
            rpt->orders[o_cnt].assays[a_cnt].prev_result_id = 
               r.result_id
            rpt->orders[o_cnt].assays[a_cnt].prev_perform_result_id =
               pr.perform_result_id
            rpt->orders[o_cnt].assays[a_cnt].prev_result_status_cd =
               pr.result_status_cd
            rpt->orders[o_cnt].assays[a_cnt].prev_result_type_cd =
               pr.result_type_cd
            rpt->orders[o_cnt].assays[a_cnt].prev_less_great_flag = 
               pr.less_great_flag
            rpt->orders[o_cnt].assays[a_cnt].prev_dilution_factor = 
               pr.dilution_factor
            if (pr.dilution_factor > 0.0)
               dilution_val = cnvtstring(pr.dilution_factor,6,2,l)
               idx = 1
               ;* Remove leading zeroes
               while(substring(idx, 1, dilution_val) = "0")
                  l = movestring(" ", 1, dilution_val, idx, 1)
                  idx = idx + 1
               endwhile
               idx = 6
               ;* Remove trailing zeroes
               while(substring(idx, 1, dilution_val) = "0")
                  l = movestring(" ", 1, dilution_val, idx, 1)
                  idx = idx - 1
               endwhile
               ;* Remove decimal point if not needed
               if (substring(idx, 1, dilution_val )= ".")
                  l = movestring(" ", 1, dilution_val, idx, 1)
               endif
               rpt->orders[o_cnt].assays[a_cnt].prev_dilution_value = 
                 concat("x", trim(dilution_val,3))
            endif
            if (pr.result_type_cd = result_type_text_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 i18n_captions->text
            endif
            if (pr.result_type_cd = result_type_alpha_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
                 pr.result_value_alpha
            endif
            if (pr.result_type_cd = result_type_numeric_cd)
               if (pr.less_great_flag > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.result_value_numeric
               else
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.numeric_raw_value
               endif
            endif
            if (pr.result_type_cd = result_type_interp_cd)
               if (trim(pr.result_value_alpha) > " ")
                  rpt->orders[o_cnt].assays[a_cnt].prev_result_value = 
                    pr.result_value_alpha
               else
                  rpt->orders[o_cnt].assays[a_cnt].prev_result_value = 
                    i18n_captions->text
               endif
            endif
            if (pr.result_type_cd = result_type_date_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value = 
                 format(pr.result_value_dt_tm, "@DATECONDENSED;;d")
            endif
            if (pr.result_type_cd = result_type_freetext_cd)
               rpt->orders[o_cnt].assays[a_cnt].prev_result_value = 
                 pr.ascii_text
            endif
            if (pr.result_type_cd = result_type_calc_cd)
               if (pr.less_great_flag > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.result_value_numeric
               else
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_numeric_raw_value = pr.numeric_raw_value
               endif
            endif
            ;*
            ;* Build result flags string
            ;*
            if (pr.normal_cd > 0.0
            and normal_mean in (RESULT_PRCSS_NORMAL_HIGH_CDF,
                                RESULT_PRCSS_NORMAL_LOW_CDF,
                                RESULT_PRCSS_ALP_ABNORMAL_CDF))
               normflag = substring(1,1,normal_disp)
            else
               normflag = " "
            endif
            if (pr.critical_cd > 0.0
            and critical_mean in (RESULT_PRCSS_CRITICAL_CDF,
                                  RESULT_PRCSS_ALP_CRITICAL_CDF))
               critflag = substring(1,1,critical_disp)
            else
               critflag = " "
            endif
            if (pr.review_cd > 0.0
            and review_mean in (RESULT_PRCSS_REVIEW_CDF,
                                RESULT_PRCSS_ALP_REVIEW_CDF))
               revwflag = substring(1,1,review_disp)
            else
               revwflag = " "
            endif
            if (pr.linear_cd > 0.0
            and linear_mean = RESULT_PRCSS_LINEAR_CDF)
               linearflag = substring(1,1,linear_disp)
            else
               linearflag = " "
            endif
            if (pr.feasible_cd > 0.0
            and feasible_mean = RESULT_PRCSS_FEASIBLE_CDF)
               feasflag = substring(1,1,feasible_disp)
            else
               feasflag = " "
            endif
            if (pr.delta_cd > 0.0
            and delta_mean = RESULT_PRCSS_DELTA_FAIL_CDF)
               deltaflag = substring(1,1,delta_disp)
            else
               deltaflag = " "
            endif
            if (rc_exists = "Y")
               rcommentflag = "Y"
               rnoteflag = "Y"
            else
               rcommentflag = "N"
               rnoteflag = "N"
            endif
            if (r.result_status_cd = corrected_cd)
               correctflag = "Y"
            else
               correctflag = "N"
            endif
            rpt->orders[o_cnt].assays[a_cnt].prev_result_flags = 
              bldresultflagstr(normflag, critflag, revwflag, 
              linearflag, feasflag, deltaflag, rcommentflag, 
              rnoteflag, correctflag)
            ;*
            ;* Calculate previous result elapsed age.
            ;*
            if (c.drawn_dt_tm > 0)
               specimen_age = cnvtage(c.drawn_dt_tm, 
                 rpt->orders[o_cnt].drawn_dt_tm,0)
               ptr = 0
               if (findstring("Years", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_years, "]")
               elseif (findstring("Months", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_months, "]")
               elseif (findstring("Weeks", specimen_age) > 0)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_weeks, "]")
               elseif (findstring("Days", specimen_age) >= 3)
                  rpt->orders[o_cnt].assays[a_cnt]
                    .prev_elapse_time = concat("[",
                    trim(substring(1, 4, specimen_age),3),
                    " ", i18n_captions->abbrev_days, "]")
               else
                  time_hrs = substring(1, 2, specimen_age)
                  time_mins = substring(4, 2, specimen_age)
                  if (cnvtint(time_hrs) >= 2)
                     rpt->orders[o_cnt].assays[a_cnt]
                       .prev_elapse_time = concat("[",
                       build(cnvtint(time_hrs)), " ",
                       i18n_captions->abbrev_hours, "]")
                  else
                     rpt->orders[o_cnt].assays[a_cnt]
                       .prev_elapse_time = concat("[",
                       build(cnvtint(time_mins)), " ",
                       i18n_captions->abbrev_minutes, "]")
                  endif
               endif
            endif
            
         with
            nocounter
           ,outerjoin = d_rc
           ,maxread(rc, 1)
           ,dontcare = rc
           
      /***********************************************************************
      * Format Numeric & Calculated Previous Results                         *
      ***********************************************************************/
         select into "nl:"
            d1.seq
           ,d2.seq
           ,d_dm.seq
           ,dm_exists = decode(dm.seq, "Y", "N")
           ,dm.service_resource_cd
           ,dm.task_assay_cd
           ,dm.data_map_type_flag
           ,dm.max_digits
           ,dm.min_decimal_places
           ,dm.min_digits
           ,d_rg.seq
           ,rg_exists = decode(rg.seq, "Y", "N")
           ,rg.parent_service_resource_cd
           ,rg.child_service_resource_cd
           ,rg.resource_group_type_cd
           ,rg.root_service_resource_cd

         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d_dm with seq = 1)
           ,data_map dm
           ,(dummyt d_rg with seq = 1)
           ,resource_group rg

         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].order_id > 0.0
         join d2
            where d2.seq <= rpt->orders[d1.seq].assays_cnt
              and rpt->orders[d1.seq].assays[d2.seq]
                   .prev_result_id > 0.0
              and rpt->orders[d1.seq].assays[d2.seq]
                   .prev_result_type_cd in (result_type_numeric_cd,
                                            result_type_calc_cd)
         join d_dm 
            where d_dm.seq = 1
         join dm  
            where dm.task_assay_cd = rpt->orders[d1.seq]
                             .assays[d2.seq].task_assay_cd
              and dm.data_map_type_flag = 0
              and dm.active_ind = 1
         join d_rg 
            where d_rg.seq = 1
         join rg
            where rg.parent_service_resource_cd = 
                             dm.service_resource_cd
              and rg.child_service_resource_cd = 
                             rpt->service_resource_cd 
              and rg.resource_group_type_cd =
                            serv_res_subsection_cd
              and rg.root_service_resource_cd + 0 = 0.0
              
         order by
            d1.seq
           ,d2.seq
           
         head report
            data_map_level = 0
            arg_max_digits = 0
            arg_min_digits = 0
            arg_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0
            
         head d1.seq
            o_cnt = d1.seq
            
         head d2.seq
            a_cnt = d2.seq
            ;*
            ;* Set default data map parameters
            ;*
            data_map_level = 0
            arg_max_digits = 8
            arg_min_digits = 1
            arg_min_decimal_places = 0
            arg_less_great_flag = 0
            arg_raw_numeric_result = 0.0

         detail
            ;*
            ;* Check for exact match on data map
            ;*
            if (data_map_level <= 2
            and dm.service_resource_cd > 0.0
            and dm.service_resource_cd = rpt->service_resource_cd)
               data_map_level = 3
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for subsection level data map
            ;*
            if (data_map_level <= 1
            and dm.service_resource_cd > 0.0
            and rg_exists = "Y"
            and rg.parent_service_resource_cd =
                             dm.service_resource_cd
            and rg.child_service_resource_cd =
                             rpt->service_resource_cd)
               data_map_level = 2
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif
            ;*
            ;* Check for default all resources level data map
            ;*
            if (data_map_level = 0
            and dm.service_resource_cd = 0.0)
               data_map_level = 1
               arg_max_digits = dm.max_digits
               arg_min_digits = dm.min_digits
               arg_min_decimal_places = dm.min_decimal_places
            endif

         foot d2.seq
            arg_less_great_flag = rpt->orders[o_cnt].assays[a_cnt]
              .prev_less_great_flag
            arg_raw_numeric_result = rpt->orders[o_cnt].assays[a_cnt]
              .prev_numeric_raw_value
            rpt->orders[o_cnt].assays[a_cnt].prev_result_value =
              uar_fmt_result(arg_min_digits,
                             arg_max_digits, 
                             arg_min_decimal_places,
                             arg_less_great_flag,
                             arg_raw_numeric_result)

         with
            nocounter
           ,outerjoin = d_dm
           ,dontcare = dm
           ,outerjoin = d_rg
           ,dontcare = rg

      /***********************************************************************
      * Load Quality Control (QC) information.                               *
      ***********************************************************************/
      #Load_QC_Info
      
      if (rpt->procedure_inc_flag = 1)
      ;* Group (i.e. ordereable) level.
      ;* All discrete task assays qualify for the report.  
                  
       set n_cnt = 0
         select into "nl:"
            d1.seq
           ,arl.task_assay_cd
           ,task_assay_disp = uar_get_code_display(arl.task_assay_cd)
           ,apr.display_sequence
           ,ptr.catalog_cd
      
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,assay_resource_lot arl
           ,assay_processing_r apr
           ,profile_task_r  ptr
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].accession_id > 0.0
         join arl
            where arl.lot_id = rpt->orders[d1.seq].lot_id
              and arl.service_resource_cd = 
                             rpt->orders[d1.seq].service_resource_cd
              and arl.task_assay_cd > 0.0
              and arl.active_ind = 1
         join apr
            where apr.task_assay_cd = arl.task_assay_cd
              and apr.service_resource_cd = arl.service_resource_cd
              and apr.active_ind = 1           
         join ptr
            where ptr.task_assay_cd = arl.task_assay_cd   
              and ptr.active_ind = 1
         order by
            d1.seq
           ,apr.display_sequence  
              
         head report
            o_cnt = 0
            a_cnt = 0
            dta_match_found = 0
            
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
         
         detail
            dta_match_found = 0 
            if (rpt->procs_cnt > 0)
              for (cnt = 1 to rpt->procs_cnt)
                if (rpt->procs[cnt].procedure_cd = ptr.catalog_cd)                        
                  dta_match_found = 1                       
                endif
              endfor
            endif           
            
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = 
                  arl.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
            endif
         
         foot d1.seq
       
         
      ;* If no task assays qualified for report, skip printing
      ;* of QC accession.
            if (a_cnt = 0)
               rpt->orders[o_cnt].accession_id = 0.0
            endif
            
         with
            nocounter
            
      elseif(rpt->procedure_inc_flag = 2) 
      ;* Detail (i.e. task assay) level.  Validate
      ;* that the task assay qualifies for the report.        
      
        set n_cnt = 0
         select into "nl:"
            d1.seq
           ,arl.task_assay_cd
           ,task_assay_disp = uar_get_code_display(arl.task_assay_cd)
           ,apr.display_sequence          
      
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,assay_resource_lot arl
           ,assay_processing_r apr           
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].accession_id > 0.0
         join arl
            where arl.lot_id = rpt->orders[d1.seq].lot_id
              and arl.service_resource_cd = 
                             rpt->orders[d1.seq].service_resource_cd
              and arl.task_assay_cd > 0.0
              and arl.active_ind = 1
         join apr
            where apr.task_assay_cd = arl.task_assay_cd
              and apr.service_resource_cd = arl.service_resource_cd
              and apr.active_ind = 1 
              
         order by
            d1.seq
           ,apr.display_sequence
         
         head report
            o_cnt = 0
            a_cnt = 0
            dta_match_found = 0
            
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
         detail
            dta_match_found = 0
            if (rpt->procs_cnt > 0)
               for (cnt = 1 to rpt->procs_cnt)
                  if (rpt->procs[cnt].procedure_cd = arl.task_assay_cd)                        
                      dta_match_found = 1                       
                  endif
               endfor            
            endif
           
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = 
                  arl.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
            endif
         
         foot d1.seq
            ;* If no task assays qualified for report, skip printing
            ;* of QC accession.
            if (a_cnt = 0)
               rpt->orders[o_cnt].accession_id = 0.0
            endif          
         with
            nocounter  
      
      else
      ;* ALL (i.e. ALL) level.
      ;* All discrete task assays qualify for the report.       
        set n_cnt = 0
         select into "nl:"
            d1.seq
           ,arl.task_assay_cd
           ,task_assay_disp = uar_get_code_display(arl.task_assay_cd)
           ,apr.display_sequence          
      
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,assay_resource_lot arl
           ,assay_processing_r apr           
           
         plan d1
            where d1.seq <= rpt->orders_cnt
              and rpt->orders[d1.seq].accession_id > 0.0
         join arl
            where arl.lot_id = rpt->orders[d1.seq].lot_id
              and arl.service_resource_cd = 
                             rpt->orders[d1.seq].service_resource_cd
              and arl.task_assay_cd > 0.0
              and arl.active_ind = 1
         join apr
            where apr.task_assay_cd = arl.task_assay_cd
              and apr.service_resource_cd = arl.service_resource_cd
              and apr.active_ind = 1 
              
         order by
            d1.seq
           ,apr.display_sequence
         
         head report
            o_cnt = 0
            a_cnt = 0
            dta_match_found = 0
            
         head d1.seq
            o_cnt = d1.seq
            a_cnt = 0
         detail
            dta_match_found = 1           
            if (dta_match_found = 1)
               a_cnt = a_cnt + 1
               if (a_cnt > max_a_cnt)
                  max_a_cnt = a_cnt
               endif
               stat = alterlist(rpt->orders[o_cnt].assays, a_cnt)
               rpt->orders[o_cnt].assays_cnt = a_cnt
               rpt->orders[o_cnt].assays[a_cnt].task_assay_cd = 
                  arl.task_assay_cd
               rpt->orders[o_cnt].assays[a_cnt].task_assay_disp =
                  task_assay_disp
            endif
         
         foot d1.seq
            ;* If no task assays qualified for report, skip printing
            ;* of QC accession.
            if (a_cnt = 0)
               rpt->orders[o_cnt].accession_id = 0.0
            endif
         with
           nocounter
      
      endif
      
      /***********************************************************************
      * Report Preparation                                                   *
      ***********************************************************************/
      #Report_Prep
         ;* Debug logic to dump internal rpt record.
         if (rpt->printer = "DEBUGDUMP")
            set trace callecho
            call echorecord(rpt,"worklist_rpt.dat")
         endif

         if (rpt->printer = "MINE")
            set temp_file = rpt->printer
         else
            set temp_file = concat("WORKLIST", format(
              cnvtdatetime(curdate, curtime3), "YYYYMMDDHHMMSSCC;;Q"),
              ".DAT")
            set stat = remove(value(temp_file))
         endif
         
         if (rpt->landscape_ind = 1)
            set max_nbr_cols = 180
            set max_nbr_rows = 48
         else
            set max_nbr_cols = 125
            set max_nbr_rows = 60
         endif
         
         ;*
         ;* Load username for report page heading
         ;*
         set username = fillstring(10," ")
         select into "nl:"
            p.username
         from
            prsnl p
         where p.person_id = reqinfo->updt_id
         detail
            username = trim(p.username)
         with
            nocounter
         
         ;*
         ;* Load institution for report title
         ;*
         set vctext->rpt_title = " "
         set serv_res_mean = fillstring(12, " ")
         set serv_res_mean = uar_get_code_meaning(rpt->service_resource_cd)
         if (serv_res_mean = SERV_RES_SUBSECTION_CDF)
            select into "nl:"
               sect.parent_service_resource_cd
              ,dept.parent_service_resource_cd
              ,inst.parent_service_resource_cd
              ,inst_desc = 
                uar_get_code_description(inst.parent_service_resource_cd)

            from
               resource_group sect
              ,resource_group dept
              ,resource_group inst

            plan sect
              where sect.child_service_resource_cd = 
                             rpt->service_resource_cd
                and sect.resource_group_type_cd = 
                             serv_res_section_cd
                and sect.root_service_resource_cd + 0 = 0.0
                and sect.active_ind = 1
            join dept
              where dept.child_service_resource_cd = 
                             sect.parent_service_resource_cd
                and dept.resource_group_type_cd = 
                             serv_res_department_cd
                and dept.root_service_resource_cd + 0 = 0.0
                and dept.active_ind = 1
            join inst
              where inst.child_service_resource_cd = 
                             dept.parent_service_resource_cd
                and inst.resource_group_type_cd = 
                             serv_res_institution_cd
                and inst.root_service_resource_cd + 0 = 0.0
                and inst.active_ind = 1

            detail
               vctext->rpt_title = inst_desc
               
            with
               nocounter
              ,maxqual(inst, 1)
         endif
         if (serv_res_mean in (SERV_RES_INSTRUMENT_CDF,
                               SERV_RES_BENCH_CDF))
            select into "nl:"
               subsect.parent_service_resource_cd
              ,sect.parent_service_resource_cd
              ,dept.parent_service_resource_cd
              ,inst.parent_service_resource_cd
              ,inst_desc = 
                uar_get_code_description(inst.parent_service_resource_cd)

            from
               resource_group subsect
              ,resource_group sect
              ,resource_group dept
              ,resource_group inst

            plan subsect
              where subsect.child_service_resource_cd = 
                             rpt->service_resource_cd
                and subsect.resource_group_type_cd = 
                             serv_res_subsection_cd
                and subsect.root_service_resource_cd + 0 = 0.0
                and subsect.active_ind = 1
            join sect
              where sect.child_service_resource_cd = 
                             subsect.parent_service_resource_cd
                and sect.resource_group_type_cd = 
                             serv_res_section_cd
                and sect.root_service_resource_cd + 0 = 0.0
                and sect.active_ind = 1
            join dept
              where dept.child_service_resource_cd = 
                             sect.parent_service_resource_cd
                and dept.resource_group_type_cd = 
                             serv_res_department_cd
                and dept.root_service_resource_cd + 0 = 0.0
                and dept.active_ind = 1
            join inst
              where inst.child_service_resource_cd = 
                             dept.parent_service_resource_cd
                and inst.resource_group_type_cd = 
                             serv_res_institution_cd
                and inst.root_service_resource_cd + 0 = 0.0
                and inst.active_ind = 1

            detail
               vctext->rpt_title = inst_desc
               
            with
               nocounter
              ,maxqual(inst, 1)
         endif
                  
      /***********************************************************************
      * Print Report                                                         *
      ***********************************************************************/
      #Print_Report      

         select
         if (rpt->landscape_ind = 1)
            with
               nocounter
              ,nullreport
              ,maxcol = value(max_nbr_cols)
              ,maxrow = value(max_nbr_rows)
              ,compress
              ,landscape
              ,outerjoin = d_a
              ,dontcare = d2
              ,outerjoin = d_r
              ,dontcare = d3

         endif
         into value(temp_file)
            cur_date = format(curdate, "@SHORTDATE4YR;;Q")
           ,cur_time = format(curtime, "@TIMENOSECONDS;;M")
           ,d1.seq
           ,accn = uar_fmt_accession(rpt->orders[d1.seq].accession, 
                                size(rpt->orders[d1.seq].accession,1))
           ,d_a.seq
           ,d2.seq
           ,d_r.seq
           ,d3.seq
           
         from
            (dummyt d1 with seq = value(rpt->orders_cnt))
           ,(dummyt d_a with seq = 1)
           ,(dummyt d2 with seq = value(max_a_cnt))
           ,(dummyt d_r with seq = 1)
           ,(dummyt d3 with seq = value(max_r_cnt))
            
         plan d1
           where d1.seq <= rpt->orders_cnt
         join d_a
           where d_a.seq = 1
         join d2
           where d2.seq <= rpt->orders[d1.seq].assays_cnt
         join d_r
           where d_r.seq = 1
         join d3
           where d3.seq <= rpt->orders[d1.seq].assays[d2.seq].results_cnt

         order by
            d1.seq
           ,d2.seq
           ,d3.seq
            
      /***********************************************************************
      * Head Report                                                          *
      ***********************************************************************/
         head report
            ;*
            ;* Initialize report variables
            ;*
            spacing = 0                ;Spacing between rows
            l_cap_col = 0              ;Left caption column
            l_txt_col = 0              ;Left text column
            r_cap_col = 0              ;Right caption column
            r_txt_col = 0              ;Right text column
            cap_size = 0               ;Caption size
            cap_pos = 0                ;Caption column position
            accn_col = 0               ;Accession column
            accn_col_len = 0           ;Accession column length
            demog_col = 0              ;Demographics column
            demog_col_len = 0          ;Demographics column length
            loc_col = 0                ;Location column
            loc_col_len = 0            ;Location column length
            coll_col = 0               ;Collected column
            coll_col_len = 0           ;Collected column length
            tech_col = 0               ;Technologist column
            tech_col_len = 0           ;Technologist column length
            proc_col = 0               ;Procedure column
            proc_col_len = 0           ;Procedure column length
            rslt_col = 0               ;Result column
            rslt_col_len = 0           ;Result column length
            perf_col = 0               ;Performing tech column
            perf_col_len = 0           ;Performing tech column length
            verf_col = 0               ;Verifying tech column
            verf_col_len = 0           ;Verifying tech column length
            col_ptr = 0                ;Column pointer
            start_col = 0              ;Start column for lines
            col_len = 0                ;Column length
            txt_len = 0                ;Text length
            new_pg_first_accn_row = 0  ;First accession row on a page
            print_accn_ind = 0         ;Print accession, demog, etc.
            beg_accn_row = 0           ;Beginning accession information row
            curr_accn_row = 0          ;Current accession information row
            curr_det_row = 0           ;Current detail information row
            curr_det_col = 0           ;Current detail information column
            curr_det_len = 0           ;Current detail field length
            min_accn_rows = 0          ;Minimum number of accession info rows
            min_det_rows = 0           ;Minimum number of detail info rows
            comments_col_len = 0       ;Text/Order Comments column length
            r_comments_col_len = 0     ;Result comments column length
            saved_curr_page = 0
            ;*
            ;* Print hyphen line macro
            ;*
            macro(print_hyphen_line)
               for (col_ptr = start_col to (start_col + col_len - 1))
                  col col_ptr, "-"
               endfor
            endmacro

            ;*
            ;* Print underline macro
            ;*
            macro(print_underline)
               for (col_ptr = start_col to (start_col + col_len - 1))
                  col col_ptr, "_"
               endfor
            endmacro

            ;*
            ;* Center column text macro
            ;*
            macro(center_col_text)
               txt_len = size(vctext->txt)
               if (txt_len > col_len)
                  vctext->txt = substring(1, col_len, vctext->txt)
               endif
               col_ptr = start_col + (col_len / 2) - (txt_len / 2)
               col col_ptr, vctext->txt
            endmacro
            
            ;*
            ;* Initialize new accession macro
            ;*
            macro(init_new_accn)
               ;*
               ;* Confirm new accession demographics will fit on
               ;* report page.
               ;*
               min_accn_rows = 2 * spacing
               if (rpt->result_space_ind = 0)
                  ;* Vertical/Horizontal Worklist.  
                  ;* Account for 3 demographic lines.
                  min_accn_rows = min_accn_rows + (3 * spacing)
               elseif (rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
                  ;* Vertical Worksheet.
                  ;* Account for 3 demographic lines.
                  min_accn_rows = min_accn_rows + (3 * spacing)
               elseif (rpt->report_format_ind = 1
               and rpt->result_space_ind = 1)
                  ;* Horizontal worksheet.  
                  ;* Account for 2 header lines and 4 demographic lines.
                  min_accn_rows = min_accn_rows + 2 + (4 * spacing)
               endif
               if (rpt->visit_reason_ind = 1
               and trim(rpt->orders[o_cnt].visit_reason,3) > " ")
                  min_accn_rows = min_accn_rows + spacing
               endif
               if (rpt->person_comments_ind = 1
               and rpt->orders[o_cnt].person_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].person_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].person_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               if (rpt->person_comments_ind = 1
               and rpt->orders[o_cnt].encntr_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].encntr_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].encntr_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               if (rpt->order_comments_ind = 1
               and rpt->orders[o_cnt].order_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].order_comment_cnt)
                     min_accn_rows = min_accn_rows + spacing
                     txt_len = size(rpt->orders[o_cnt].order_comment[cnt]
                       .comment) / (comments_col_len - 2)
                     min_accn_rows = min_accn_rows + (txt_len * spacing)
                  endfor
               endif
               ;*
               ;* Determine if accession is the first accession to 
               ;* print on the page.  If so, the pointers are already
               ;* set.
               ;*
               if (curr_accn_row != new_pg_first_accn_row OR curr_det_row != new_pg_first_accn_row
                   OR saved_curr_page < CURPAGE)
                  if (curr_accn_row >= curr_det_row)
                     ;* Accession data is longer than detail result data
                     if ((curr_accn_row + min_accn_rows) >= max_nbr_rows)
                        break
                     else
                        ;* Set row for printing of new accession.
                        row curr_accn_row
                        row + (2 * spacing)
                        ;* Reset accession and detail pointers
                        beg_accn_row = row
                        curr_accn_row = row
                        curr_det_row = row
                        if (rpt->result_space_ind = 1)
                           curr_det_col = rslt_col
                        else
                           curr_det_col = proc_col
                        endif
                     endif
                  else
                     ;* Detail result data is longer than accession data
                     if ((curr_det_row + min_accn_rows) >= max_nbr_rows)
                        break
                     else
                        ;* Set row for printing of new accession.
                        row curr_det_row
                        row + (2 * spacing)
                        ;* Reset accession and detail pointers
                        beg_accn_row = row
                        curr_accn_row = row
                        curr_det_row = row
                        if (rpt->result_space_ind = 1)
                           curr_det_col = rslt_col
                        else
                           curr_det_col = proc_col
                        endif
                     endif
                  endif
               endif
	       ;** Save Current Page.
               saved_curr_page = CURPAGE
            endmacro
            
            ;*
            ;* Print visit reason macro
            ;*
            macro(print_visit_reason)
               if (trim(rpt->orders[o_cnt].visit_reason,3) > " ")
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  vctext->txt = concat(i18n_captions->visit_reason,
                    " ", rpt->orders[o_cnt].visit_reason)
                  vctext->txt = substring(1, comments_col_len,
                    vctext->txt)
                  col accn_col, vctext->txt
               endif
            endmacro
            
            ;*
            ;* Print person comments macro
            ;*
            macro(print_person_comments)
               if (rpt->orders[o_cnt].person_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].person_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].person_comment[cnt]
                        .comment_type_cd = info_type_comment_cd)
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->person_comments)
                     else
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->person_notes)
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .person_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro

            ;*
            ;* Print encounter comments macro
            ;*
            macro(print_encntr_comments)
               if (rpt->orders[o_cnt].encntr_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].encntr_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].encntr_comment[cnt]
                        .comment_type_cd = info_type_comment_cd)
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->encounter_comments)
                     else
                        vctext->txt = substring(1, comments_col_len,
                          i18n_captions->encounter_notes)
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .encntr_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro

            ;*
            ;* Print order comments macro
            ;*
            macro(print_order_comments)
               if (rpt->orders[o_cnt].order_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].order_comment_cnt)
                     curr_accn_row = curr_accn_row + spacing
                     if (curr_accn_row >= max_nbr_rows)
                        break
                     endif
                     row curr_accn_row
                     if (rpt->orders[o_cnt].order_comment[cnt]
                        .comment_type_cd = comment_type_ord_comment_cd)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].order_mne,3), " ",
                          substring(1, comments_col_len,
                          i18n_captions->order_comments))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].order_mne,3), " ",
                          substring(1, comments_col_len,
                          i18n_captions->order_notes))
                     endif
                     col accn_col, vctext->txt
                     col_len = comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt]
                       .order_comment[cnt].comment, 1, col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_accn_row = curr_accn_row + spacing
                        if (curr_accn_row >= max_nbr_rows)
                           break
                        endif
                        row curr_accn_row
                        col accn_col
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro

            ;*
            ;* Print result comments macro
            ;*
            macro(print_result_comments)
               if (rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                             .result_comment_cnt > 0)
                  for (cnt = 1 to rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_comment_cnt)
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     if (rpt->orders[o_cnt].assays[a_cnt]
                        .results[r_cnt].result_comment[cnt]
                        .comment_type_cd = comment_type_res_comment_cd)
                        vctext->txt = concat(trim(rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp,3), " ",
                          substring(1, r_comments_col_len,
                          i18n_captions->result_comments))
                     else
                        vctext->txt = concat(trim(rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp,3), " ",
                          substring(1, r_comments_col_len,
                          i18n_captions->result_notes))
                     endif
                     row curr_det_row
                     if (rpt->report_format_ind = 1
                     and rpt->result_space_ind = 1)
                        ;* Horizontal Worksheet
                        col rslt_col, vctext->txt
                     else
                        col proc_col, vctext->txt
                     endif
                     col_len = r_comments_col_len - 2
                     call rtf_to_text(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_comment[cnt].comment, 1, 
                       col_len)
                     for (q_cnt = 1 to size(tmptext->qual,5))
                        curr_det_row = curr_det_row + spacing
                        if (curr_det_row >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                        row curr_det_row
                        if (rpt->report_format_ind = 1
                        and rpt->result_space_ind = 1)
                           ;* Horizontal Worksheet
                           col rslt_col
                        else
                           col proc_col
                        endif
                        col + 2, tmptext->qual[q_cnt].text
                     endfor
                  endfor
               endif
            endmacro

            ;*
            ;* Calculate left column offsets
            ;*
            l_cap_col = 0
            l_txt_col = 0
            cap_size = size(i18n_captions->rpt_report)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_name)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_id)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            cap_size = size(i18n_captions->rpt_test_site)
            if (cap_size + 1 > l_txt_col)
               l_txt_col = cap_size + 1
            endif
            
            ;*
            ;* Calculate right caption column offset
            ;*
            r_cap_col = max_nbr_cols - 11
            r_txt_col = max_nbr_cols - 11 
            cap_size = size(i18n_captions->rpt_date)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_time)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_by)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            cap_size = size(i18n_captions->rpt_page)
            cap_pos = r_txt_col - cap_size
            if (cap_pos - 1 < r_cap_col)
               r_cap_col = cap_pos - 1
            endif
            
            ;*
            ;* Calculate column positions and lengths
            ;*
            if (rpt->result_space_ind = 0
            and rpt->landscape_ind = 0)
               ;* Vertical/horizontal worklist.  No landscape.
               accn_col = 0
               accn_col_len = 23
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 21
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 16
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 48
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 38
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 48
               endif
               if (rpt->report_format_ind = 0)
                  curr_det_len = proc_col_len
               else
                  curr_det_len = 15
               endif
               comments_col_len = 75
               r_comments_col_len = 48
            endif
            if (rpt->result_space_ind = 0
            and rpt->landscape_ind = 1)
               ;* Vertical/horizontal worklist.  Landscape.
               accn_col = 0
               accn_col_len = 30
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 33
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 60
                  comments_col_len = 118
                  r_comments_col_len = 60
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
                  proc_col = coll_col + coll_col_len + 1
                  proc_col_len = 94
                  comments_col_len = 84
                  r_comments_col_len = 94
               endif
               if (rpt->report_format_ind = 0)
                  curr_det_len = proc_col_len
               else
                  curr_det_len = 19
               endif
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 0)
               ;* Vertical worksheet.  No landscape.
               accn_col = 0
               accn_col_len = 23
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 21
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 15
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 37
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
               endif
               proc_col = coll_col + coll_col_len + 1
               proc_col_len = 15
               rslt_col = proc_col + proc_col_len + 1
               rslt_col_len = 19
               perf_col = rslt_col + rslt_col_len + 1
               perf_col_len = 6
               verf_col = perf_col + perf_col_len + 1
               verf_col_len = 6
               curr_det_len = rslt_col_len
               comments_col_len = 74
               r_comments_col_len = 49
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 1)
               ;* Vertical worksheet.  Landscape.
               accn_col = 0
               accn_col_len = 30
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  ;* Show location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 40
                  loc_col = demog_col + demog_col_len + 1
                  loc_col_len = 33
                  coll_col = loc_col + loc_col_len + 1
                  coll_col_len = 12
               else
                  ;* Hide location column
                  demog_col = accn_col + accn_col_len + 1
                  demog_col_len = 74
                  coll_col = demog_col + demog_col_len + 1
                  coll_col_len = 12
               endif
               proc_col = coll_col + coll_col_len + 1
               proc_col_len = 20
               rslt_col = proc_col + proc_col_len + 1
               rslt_col_len = 25
               perf_col = rslt_col + rslt_col_len + 1
               perf_col_len = 6
               verf_col = perf_col + perf_col_len + 1
               verf_col_len = 6
               curr_det_len = rslt_col_len
               comments_col_len = 118
               r_comments_col_len = 60
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 0)
               ;* Horizontal worksheet.  No landscape.
               accn_col = 0
               accn_col_len = 23
               demog_col = accn_col + accn_col_len + 1
               demog_col_len = 27
               tech_col = demog_col + demog_col_len + 1
               tech_col_len = 8
               rslt_col = tech_col + tech_col_len + 1
               rslt_col_len = 15
               curr_det_len = rslt_col_len
               comments_col_len = 51
               r_comments_col_len = 63
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->landscape_ind = 1)
               ;* Horizontal worksheet.  Landscape.
               accn_col = 0
               accn_col_len = 23
               demog_col = accn_col + accn_col_len + 1
               demog_col_len = 21
               tech_col = demog_col + demog_col_len + 1
               tech_col_len = 5
               rslt_col = tech_col + tech_col_len + 1
               rslt_col_len = 15
               curr_det_len = rslt_col_len
               comments_col_len = 45
               r_comments_col_len = 127
            endif
            if (rpt->spacing_ind = 0)
               spacing = 1
            else
               spacing = 2
            endif

      /***********************************************************************
      * Head Page                                                            *
      ***********************************************************************/
         head page
            ;*
            ;* Print page headings
            ;*
            call center(vctext->rpt_title, 0, value(max_nbr_cols))
            col l_cap_col, i18n_captions->rpt_report
            col l_txt_col, i18n_captions->rpt_report_desc
            col r_cap_col, i18n_captions->rpt_date
            col r_txt_col, cur_date
            row + 1
            col l_cap_col, i18n_captions->rpt_name
            col l_txt_col, rpt->worklist_ref_disp
            col r_cap_col, i18n_captions->rpt_time
            col r_txt_col, cur_time
            row + 1
            col l_cap_col, i18n_captions->rpt_id
            col l_txt_col, rpt->worklist_alias
            if (rpt->result_space_ind = 1)
               ;* Worksheet
               call center(i18n_captions->rpt_worksheet, 
                 0, value(max_nbr_cols))
            else
               ;* Worklist
               call center(i18n_captions->rpt_worklist,
                 0, value(max_nbr_cols))
            endif
            col r_cap_col, i18n_captions->rpt_by
            col r_txt_col, username
            row + 1
            col l_cap_col, i18n_captions->rpt_test_site
            col l_txt_col, rpt->service_resource_disp
            col r_cap_col, i18n_captions->rpt_page
            col r_txt_col, curpage "##########;L;I"
            if (rpt->cross_resource_ind = 1)
               row + 1
               cap_size = size(i18n_captions->rpt_cross_test_site)
               col_ptr = max_nbr_cols - cap_size - 5
               col col_ptr, "* ="
               col + 1, i18n_captions->rpt_cross_test_site
            endif
            row + 2
            
            ;*
            ;* Print column headings
            ;*
            if (rpt->result_space_ind = 0)
               ;* Vertical/horizontal worklist.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  col loc_col, i18n_captions->location
               endif
               col coll_col, i18n_captions->collected
               col proc_col, i18n_captions->orderable_procedure
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* Vertical worksheet.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  col loc_col, i18n_captions->location
               endif
               col coll_col, i18n_captions->collected
               col proc_col, i18n_captions->procedure
               start_col = rslt_col
               col_len = rslt_col_len
               vctext->txt = i18n_captions->result
               center_col_text
               start_col = perf_col
               col_len = perf_col_len
               vctext->txt = i18n_captions->perf
               center_col_text
               start_col = verf_col
               col_len = verf_col_len
               vctext->txt = i18n_captions->verf
               center_col_text
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal worksheet.
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               start_col = tech_col
               col_len = tech_col_len
               vctext->txt = i18n_captions->tech
               center_col_text
            endif
            row + 1
            
            ;*
            ;* Print column heading hyphens
            ;*
            if (rpt->result_space_ind = 0)
               ;* Vertical/horizontal worklist.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  start_col = loc_col
                  col_len = loc_col_len
                  print_hyphen_line
               endif
               start_col = coll_col
               col_len = coll_col_len
               print_hyphen_line
               start_col = proc_col
               col_len = proc_col_len
               print_hyphen_line
            endif
            if (rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* Vertical worksheet.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               if (rpt->facility_ind = 1
               or rpt->nurse_unit_ind = 1)
                  start_col = loc_col
                  col_len = loc_col_len
                  print_hyphen_line
               endif
               start_col = coll_col
               col_len = coll_col_len
               print_hyphen_line
               start_col = proc_col
               col_len = proc_col_len
               print_hyphen_line
               start_col = rslt_col
               col_len = rslt_col_len
               print_hyphen_line
               start_col = perf_col
               col_len = perf_col_len
               print_hyphen_line
               start_col = verf_col
               col_len = verf_col_len
               print_hyphen_line
            endif
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal worksheet.
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               start_col = tech_col
               col_len = tech_col_len
               print_hyphen_line
            endif
            row + spacing
            ;* Set default row pointers for new page.
            if (rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* Horizontal Worksheet.
               ;* Note: header lines are reprinted.  Adjust begin row
               ;*       to allow for header lines.
               beg_accn_row = row - spacing - 1
               curr_accn_row = beg_accn_row
               curr_det_row = beg_accn_row
            else
               beg_accn_row = row
               curr_accn_row = beg_accn_row
               curr_det_row = beg_accn_row
            endif
            new_pg_first_accn_row = beg_accn_row
            if (rpt->result_space_ind = 1)
               curr_det_col = rslt_col
            else
               curr_det_col = proc_col
            endif
         
      /***********************************************************************
      * Head Order/QC Accession                                              *
      ***********************************************************************/
         head d1.seq     
            o_cnt = d1.seq            
            ;*
            ;*  Print QC data on a Vertical/Horizontal Worklist.
            ;*              
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->result_space_ind = 0)
               ;* New QC accession
               print_accn_ind = 1
               init_new_accn
               ;* Print first QC data row.
               row beg_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                  vctext->txt = concat("[", 
                    trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                  col coll_col vctext->txt
               endif
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
            endif          
            ;*
            ;*  Print QC data on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               ;* New QC accession
               print_accn_ind = 1
               init_new_accn
               ;* Print first QC data row.
               row beg_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                  vctext->txt = concat("[", 
                    trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                  col coll_col vctext->txt
               endif
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Set detail information pointers
               curr_det_col = rslt_col
               curr_det_row = beg_accn_row
            endif
            
            ;*
            ;*  Print QC data on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].accession_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               ;* New QC accession.
               print_accn_ind = 1
               init_new_accn
               ;* Reprint column headers.
               row beg_accn_row
               col accn_col, i18n_captions->accession
               col demog_col, i18n_captions->demographics
               start_col = tech_col
               col_len = tech_col_len
               vctext->txt = i18n_captions->tech
               center_col_text
               ;* Reprint column header lines.
               curr_accn_row = curr_accn_row + 1
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               start_col = accn_col
               col_len = accn_col_len
               print_hyphen_line
               start_col = demog_col
               col_len = demog_col_len
               print_hyphen_line
               start_col = tech_col
               col_len = tech_col_len
               print_hyphen_line
               ;* Print first QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               col accn_col, accn
               vctext->txt = concat(trim(i18n_captions->control,3), " ",
                 trim(rpt->orders[o_cnt].control_name,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               start_col = tech_col
               col_len = tech_col_len
               print_underline
               ;* Print second QC data row.
               curr_accn_row = curr_accn_row + spacing
               if (curr_accn_row >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                  vctext->txt = concat("[", 
                    trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                  col accn_col + 15 vctext->txt
               endif
               vctext->txt = concat(trim(i18n_captions->lot,3), " ",
                 trim(rpt->orders[o_cnt].lot_number,3))
               vctext->txt = substring(1, demog_col_len, vctext->txt)
               col demog_col, vctext->txt
               ;* Set detail information pointers
               curr_det_col = rslt_col
               curr_det_row = beg_accn_row
            endif
            
            ;*
            ;*  Print Patient Data on a Vertical/Horizontal Worklist.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->result_space_ind = 0)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
                  endif
               endif
               if (print_accn_ind = 1)
                  ;* New accession.
                  init_new_accn
                  ;* Print first accession/demographic/etc data row.
                  row beg_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len, 
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].facility_disp)
                        col loc_col, vctext->txt
                     elseif (rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                     elseif (size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  if (rpt->orders[o_cnt].drawn_dt_tm > 0)
                     vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "DDMMMYY HHMM;;Q")
                     col coll_col, vctext->txt
                  endif
                  ;* Print second accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  vctext->txt = substring(1, accn_col_len,
                    rpt->orders[o_cnt].provider_name)
                  col accn_col vctext->txt
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].med_rec_nbr)
                  col demog_col vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0
                     and rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                     elseif (rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0
                     and size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                     vctext->txt = concat("[", 
                       trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                     col coll_col vctext->txt
                  endif
                  ;* Print third accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt = 
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  vctext->txt = substring(1, accn_col_len, vctext->txt)
                  col accn_col vctext->txt
                  vctext->txt = concat(rpt->orders[o_cnt].age, " ",
                    rpt->orders[o_cnt].sex_disp)
                  if (rpt->facility_ind = 0
                  and rpt->nurse_unit_ind = 0)
                     vctext->txt = concat(vctext->txt, " ",
                       rpt->orders[o_cnt].roombed_disp)
                  endif
                  vctext->txt = substring(1, demog_col_len, vctext->txt)
                  col demog_col vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0
                     and rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0
                     and size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = proc_col
                  curr_det_row = beg_accn_row
               endif
               ;* Print orderable procedures either vertically
               ;* or horizontally depending on report format.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  if (rpt->report_format_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  endif
                  if (rpt->report_format_ind = 1)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if ((curr_det_col + curr_det_len) > max_nbr_cols)
                        curr_det_col = proc_col
                        curr_det_row = curr_det_row + spacing
                     endif
                  endif
               endif
               if (curr_det_row >= max_nbr_rows)
                  break
               endif
               row curr_det_row
               vctext->txt = substring(1, curr_det_len,
                 rpt->orders[o_cnt].order_mne)
               col curr_det_col, vctext->txt
            endif            
            ;*
            ;*  Print Patient Data on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
                  endif
               endif
               if (print_accn_ind = 1)
                  ;* New accession.
                  init_new_accn
                  ;* Print first accession/demographic/etc data row.
                  row beg_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len, 
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].facility_disp)
                        col loc_col, vctext->txt
                     elseif (rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                     elseif (size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  if (rpt->orders[o_cnt].drawn_dt_tm > 0)
                     vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "DDMMMYY HHMM;;Q")
                     col coll_col, vctext->txt
                  endif
                  ;* Print second accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  vctext->txt = substring(1, accn_col_len,
                    rpt->orders[o_cnt].provider_name)
                  col accn_col vctext->txt
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].med_rec_nbr)
                  col demog_col vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0
                     and rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].nurse_unit_disp)
                        col loc_col, vctext->txt
                     elseif (rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0
                     and size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                     vctext->txt = concat("[", 
                       trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                     col coll_col vctext->txt
                  endif
                  ;* Print third accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt = 
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  vctext->txt = substring(1, accn_col_len, vctext->txt)
                  col accn_col vctext->txt
                  vctext->txt = concat(rpt->orders[o_cnt].age, " ",
                    rpt->orders[o_cnt].sex_disp)
                  if (rpt->facility_ind = 0
                  and rpt->nurse_unit_ind = 0)
                     vctext->txt = concat(vctext->txt, " ",
                       rpt->orders[o_cnt].roombed_disp)
                  endif
                  vctext->txt = substring(1, demog_col_len, vctext->txt)
                  col demog_col vctext->txt
                  if (rpt->facility_ind = 1
                  or  rpt->nurse_unit_ind = 1)
                     if (rpt->facility_ind = 1
                     and rpt->orders[o_cnt].facility_cd > 0.0
                     and rpt->nurse_unit_ind = 1
                     and rpt->orders[o_cnt].nurse_unit_cd > 0.0
                     and size(rpt->orders[o_cnt].roombed_disp) > 0)
                        vctext->txt = substring(1, loc_col_len,
                          rpt->orders[o_cnt].roombed_disp)
                        col loc_col, vctext->txt
                     endif
                  endif
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = rslt_col
                  curr_det_row = beg_accn_row
               endif
               ;* Check for additional order comments on subsequent orders.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
               endif
            endif
            
            ;*
            ;*  Print Patient Data on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1)
               print_accn_ind = 1
               if (o_cnt > 1)
                  ;* Check for new accession.
                  if (rpt->orders[o_cnt].accession =
                             rpt->orders[o_cnt - 1].accession)
                     print_accn_ind = 0
                  endif
               endif
               if (print_accn_ind = 1)
                  ;* New accession.  Set row pointers.
                  init_new_accn
                  ;* Reprint column headers.
                  row beg_accn_row
                  col accn_col, i18n_captions->accession
                  col demog_col, i18n_captions->demographics
                  start_col = tech_col
                  col_len = tech_col_len
                  vctext->txt = i18n_captions->tech
                  center_col_text
                  ;* Reprint column header lines.
                  curr_accn_row = curr_accn_row + 1
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  start_col = accn_col
                  col_len = accn_col_len
                  print_hyphen_line
                  start_col = demog_col
                  col_len = demog_col_len
                  print_hyphen_line
                  start_col = tech_col
                  col_len = tech_col_len
                  print_hyphen_line
                  ;* Print first accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  col accn_col, accn
                  vctext->txt = substring(1, demog_col_len, 
                    rpt->orders[o_cnt].name_full_formatted)
                  col demog_col, vctext->txt
                  start_col = tech_col
                  col_len = tech_col_len
                  print_underline
                  ;* Print second accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->orders[o_cnt].drawn_dt_tm > 0)
                     vctext->txt = format(
                       cnvtdatetime(rpt->orders[o_cnt].drawn_dt_tm),
                       "DDMMMYY HHMM;;Q")
                     col accn_col, vctext->txt
                  endif
                  if (trim(rpt->orders[o_cnt].sequence_ident,3) > " ")
                     vctext->txt = concat("[", 
                       trim(rpt->orders[o_cnt].sequence_ident,3), "]")
                     col accn_col + 15, vctext->txt
                  endif
                  vctext->txt = substring(1, demog_col_len,
                    rpt->orders[o_cnt].med_rec_nbr)
                  col demog_col vctext->txt
                  ;* Print third accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  vctext->txt = substring(1, accn_col_len,
                    rpt->orders[o_cnt].provider_name)
                  col accn_col vctext->txt
                  vctext->txt = concat(rpt->orders[o_cnt].age, " ",
                    rpt->orders[o_cnt].sex_disp, " ",
                    rpt->orders[o_cnt].roombed_disp)
                  vctext->txt = substring(1, demog_col_len, vctext->txt)
                  col demog_col vctext->txt
                  ;* Print forth accession/demographic/etc data row.
                  curr_accn_row = curr_accn_row + spacing
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  if (rpt->reporting_priority_ind = 1)
                     vctext->txt = 
                       rpt->orders[o_cnt].reporting_priority_disp
                  else
                     vctext->txt = " "
                  endif
                  if (rpt->order_status_ind = 1)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].dept_status_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].dept_status_disp
                     endif
                  endif
                  if (rpt->facility_ind = 1
                  and rpt->orders[o_cnt].facility_cd > 0.0)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].facility_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].facility_disp
                     endif
                  endif
                  if (rpt->nurse_unit_ind = 1
                  and rpt->orders[o_cnt].nurse_unit_cd > 0.0)
                     if (size(vctext->txt) > 0)
                        vctext->txt = concat(vctext->txt, "/",
                          rpt->orders[o_cnt].nurse_unit_disp)
                     else
                        vctext->txt =
                          rpt->orders[o_cnt].nurse_unit_disp
                     endif
                  endif
                  vctext->txt = substring(1, comments_col_len, 
                    vctext->txt)
                  col accn_col vctext->txt
                  ;* Print visit reason
                  if (rpt->visit_reason_ind = 1)
                     print_visit_reason
                  endif
                  ;* Print person comments
                  if (rpt->person_comments_ind = 1)
                     print_person_comments
                  endif
                  ;* Print encounter comments
                  if (rpt->person_comments_ind = 1)
                     print_encntr_comments
                  endif
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
                  ;* Set detail information pointers
                  curr_det_col = rslt_col
                  curr_det_row = beg_accn_row
               endif
               ;* Check for additional order comments on subsequent orders.
               if (print_accn_ind = 0)
                  ;* Print order comments
                  if (rpt->order_comments_ind = 1)
                     print_order_comments
                  endif
               endif
            endif
         
      /***********************************************************************
      * Head Discrete Task Assay List                                        *
      ***********************************************************************/
         head d2.seq                 
            if (rpt->orders[o_cnt].assays_cnt > 0)                 
               a_cnt = d2.seq
               ;*
               ;*  Print QC discrete task assays on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
              
                  if (print_accn_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row >= max_nbr_rows)
                     break
                     new_pg_first_accn_row = 0
                  endif
                  row curr_det_row
                  vctext->txt = substring(1, proc_col_len,
                     rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  col proc_col, vctext->txt              
                 endif
               ;*
               ;*  Print Patient discrete task assays on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1)
                  if (print_accn_ind = 0)
                     curr_det_row = curr_det_row + spacing
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row >= max_nbr_rows)
                     break
                     new_pg_first_accn_row = 0
                  endif
                  row curr_det_row
                  if (rpt->orders[o_cnt].assays[a_cnt]
                             .cross_resource_ind = 1)
                     col proc_col - 1, "*"
                  endif
                  row curr_det_row
                  vctext->txt = substring(1, proc_col_len,
                    rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  col proc_col, vctext->txt
               endif
            endif
           
      /***********************************************************************
      * Head Results List                                                    *
      ***********************************************************************/
         head d3.seq
            if (rpt->orders[o_cnt].assays_cnt > 0)
               ;*
               ;*  Print QC result underline on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  start_col = perf_col
                  col_len = perf_col_len
                  print_underline
                  start_col = verf_col
                  col_len = verf_col_len
                  print_underline
               endif
               ;*
               ;*  Print Patient results on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                  r_cnt = d3.seq
                  if (r_cnt > 1)
                     ;* Repeat.  Update row.
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  row curr_det_row
                  if (rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_factor > 0.0)
                     vctext->txt = concat(
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_value,3), " ",
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].dilution_value,3), " ", 
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_flags,3))
                  else
                     vctext->txt = concat(
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_value,3), " ",
                       trim(rpt->orders[o_cnt].assays[a_cnt]
                       .results[r_cnt].result_flags,3))
                  endif
                  vctext->txt = substring(1, rslt_col_len,
                    vctext->txt)
                  col rslt_col, vctext->txt
                  vctext->txt = substring(1, perf_col_len,
                    rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .perf_username)
                  col perf_col, vctext->txt
                  if (rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                    .result_status_cd in (verified_cd,
                                          autoverified_cd,
                                          corrected_cd))
                     vctext->txt = substring(1, verf_col_len,
                       rpt->orders[o_cnt].assays[a_cnt].results[r_cnt]
                       .verf_username)
                     col verf_col, vctext->txt
                  endif
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0
                  and r_cnt = rpt->orders[o_cnt].assays[a_cnt]
                             .results_cnt)
                     ;* Print previous result after last repeat.
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col rslt_col, vctext->txt
                  endif
               endif
               ;*
               ;*  Print Patient result underline on a Vertical Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 0
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  start_col = perf_col
                  col_len = perf_col_len
                  print_underline
                  start_col = verf_col
                  col_len = verf_col_len
                  print_underline
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                     ;* Print previous result
                     curr_det_row = curr_det_row + spacing
                     if (curr_det_row >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col rslt_col, vctext->txt
                  endif
               endif
               ;*
               ;*  Print QC result underline on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].accession_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  if (print_accn_ind = 0)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if ((curr_det_col + curr_det_len) > max_nbr_cols)
                        curr_det_col = rslt_col
                        curr_det_row = curr_det_row + (2 * spacing)
                     endif
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row != beg_accn_row
                  and curr_det_col != rslt_col)
                     ;* Reset current detail row for next result
                     if (rpt->previous_result_ind = 1)
                        curr_det_row = curr_det_row - (2 * spacing) - 1
                     else
                        curr_det_row = curr_det_row - spacing - 1
                     endif
                  endif
                  if (rpt->previous_result_ind = 1)
                     min_det_rows = 1 + (2 * spacing)
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  else
                     min_det_rows = 1 + spacing
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  ;* Print discrete task assay column header.
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  vctext->txt = substring(1, curr_det_len,
                    rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  center_col_text
                  ;* Print discrete task assay column hyphen line.
                  curr_det_row = curr_det_row + 1
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_hyphen_line
                  ;* Print result line
                  curr_det_row = curr_det_row + spacing
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  if (rpt->previous_result_ind = 1)
                     curr_det_row = curr_det_row + spacing
                  endif
               endif
               ;*
               ;*  Print Patient results on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                  ;* Only display original result in the event repeats
                  ;* exist when printing a Horizontal worksheet. Designate
                  ;* that repeats exist with (r).
                  r_cnt = d3.seq
                  if (r_cnt = 1)
                     if (print_accn_ind = 0)
                        curr_det_col = curr_det_col + curr_det_len + 1
                        if ((curr_det_col + curr_det_len) > max_nbr_cols)
                           curr_det_col = rslt_col
                           curr_det_row = curr_det_row + (2 * spacing)
                        endif
                     else
                        print_accn_ind = 0
                     endif
                     if (curr_det_row != beg_accn_row
                     and curr_det_col != rslt_col)
                        ;* Reset current detail row for next result
                        if (rpt->previous_result_ind = 1)
                           curr_det_row = 
                             curr_det_row - (2 * spacing) - 1
                        else
                           curr_det_row = 
                             curr_det_row - spacing - 1
                        endif
                     endif
                     if (rpt->previous_result_ind = 1)
                        min_det_rows = 1 + (2 * spacing)
                        if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                     else
                        min_det_rows = 1 + spacing
                        if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                           break
                           new_pg_first_accn_row = 0
                        endif
                     endif
                     ;* Print discrete task assay column header.
                     row curr_det_row
                     start_col = curr_det_col
                     col_len = curr_det_len
                     if (rpt->orders[o_cnt].assays[a_cnt]
                             .cross_resource_ind = 1)
                        vctext->txt = concat("*", substring(1, 
                          curr_det_len, rpt->orders[o_cnt]
                          .assays[a_cnt].task_assay_disp))
                     else
                        vctext->txt = substring(1, curr_det_len,
                          rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                     endif
                     center_col_text
                     ;* Print discrete task assay column hyphen line.
                     curr_det_row = curr_det_row + 1
                     row curr_det_row
                     start_col = curr_det_col
                     col_len = curr_det_len
                     print_hyphen_line
                     ;* Print result
                     curr_det_row = curr_det_row + spacing
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt].results_cnt = 1)
                        ;* No repeats exist.  Build result value.
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .results[r_cnt].dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_value,3), " ", 
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3))
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3))
                        endif
                     else
                        ;* Repeats exist. Append (r) to result.
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .results[r_cnt].dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].dilution_value,3), " ", 
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3), " ",
                             i18n_captions->repeats)
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .results[r_cnt].result_flags,3), " ",
                             i18n_captions->repeats)
                        endif
                     endif
                     vctext->txt = substring(1, curr_det_len,
                       vctext->txt)
                     col curr_det_col, vctext->txt
                     if (rpt->previous_result_ind = 1
                     and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                        ;* Print previous result
                        curr_det_row = curr_det_row + spacing
                        row curr_det_row
                        if (rpt->orders[o_cnt].assays[a_cnt]
                                   .prev_dilution_factor > 0.0)
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_value,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_dilution_value,3), " ", 
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_flags,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_elapse_time,3))
                        else
                           vctext->txt = concat(
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_value,3), " ", 
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_flags,3), " ",
                             trim(rpt->orders[o_cnt].assays[a_cnt]
                             .prev_elapse_time,3))
                        endif
                        vctext->txt = substring(1, rslt_col_len,
                          vctext->txt)
                        col curr_det_col, vctext->txt
                     elseif (rpt->previous_result_ind = 1
                     and rpt->orders[o_cnt].assays[a_cnt]
                              .prev_result_id = 0.0)
                        curr_det_row = curr_det_row + spacing
                     endif
                  endif
               endif
               ;*
               ;*  Print Patient result underline on a Horizontal Worksheet.
               ;*
               if (rpt->orders[o_cnt].order_id > 0.0
               and rpt->report_format_ind = 1
               and rpt->result_space_ind = 1
               and rpt->orders[o_cnt].assays[a_cnt].results_cnt = 0)
                  if (print_accn_ind = 0)
                     curr_det_col = curr_det_col + curr_det_len + 1
                     if ((curr_det_col + curr_det_len) > max_nbr_cols)
                        curr_det_col = rslt_col
                        curr_det_row = curr_det_row + (2 * spacing)
                     endif
                  else
                     print_accn_ind = 0
                  endif
                  if (curr_det_row != beg_accn_row
                  and curr_det_col != rslt_col)
                     ;* Reset current detail row for next result
                     if (rpt->previous_result_ind = 1)
                        curr_det_row = curr_det_row - (2 * spacing) - 1
                     else
                        curr_det_row = curr_det_row - spacing - 1
                     endif
                  endif
                  if (rpt->previous_result_ind = 1)
                     min_det_rows = 1 + (2 * spacing)
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  else
                     min_det_rows = 1 + spacing
                     if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                        break
                        new_pg_first_accn_row = 0
                     endif
                  endif
                  ;* Print discrete task assay column header.
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  if (rpt->orders[o_cnt].assays[a_cnt]
                          .cross_resource_ind = 1)
                     vctext->txt = concat("*", substring(1, 
                       curr_det_len, rpt->orders[o_cnt]
                       .assays[a_cnt].task_assay_disp))
                  else
                     vctext->txt = substring(1, curr_det_len,
                       rpt->orders[o_cnt].assays[a_cnt].task_assay_disp)
                  endif
                  center_col_text
                  ;* Print discrete task assay column hyphen line.
                  curr_det_row = curr_det_row + 1
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_hyphen_line
                  ;* Print result line
                  curr_det_row = curr_det_row + spacing
                  row curr_det_row
                  start_col = curr_det_col
                  col_len = curr_det_len
                  print_underline
                  if (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                             .prev_result_id > 0.0)
                     ;* Print previous result
                     curr_det_row = curr_det_row + spacing
                     row curr_det_row
                     if (rpt->orders[o_cnt].assays[a_cnt]
                                .prev_dilution_factor > 0.0)
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_dilution_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     else
                        vctext->txt = concat(
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_value,3), " ", 
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_result_flags,3), " ",
                          trim(rpt->orders[o_cnt].assays[a_cnt]
                          .prev_elapse_time,3))
                     endif
                     vctext->txt = substring(1, rslt_col_len,
                       vctext->txt)
                     col curr_det_col, vctext->txt
                  elseif (rpt->previous_result_ind = 1
                  and rpt->orders[o_cnt].assays[a_cnt]
                           .prev_result_id = 0.0)
                     curr_det_row = curr_det_row + spacing
                  endif
               endif
            endif
            
      /***********************************************************************
      * Foot Results List                                                    *
      ***********************************************************************/
         foot d3.seq
            row+0
         
      /***********************************************************************
      * Foot Discrete Task Assay List                                        *
      ***********************************************************************/
         foot d2.seq
            row+0
         
      /***********************************************************************
      * Foot Order/QC Accession List                                         *
      ***********************************************************************/
         foot d1.seq
            ;*
            ;*  Print Patient result comments on a Vertical Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 0
            and rpt->result_space_ind = 1
            and rpt->orders[o_cnt].assays_cnt > 0
            and rpt->result_comments_ind = 1)
               for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                  if (rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                     for (r_cnt = 1 to rpt->orders[o_cnt]
                             .assays[a_cnt].results_cnt)
                        print_result_comments
                     endfor
                  endif
               endfor
            endif
            ;*
            ;*  Print Patient result comments on a Horizontal Worksheet.
            ;*
            if (rpt->orders[o_cnt].order_id > 0.0
            and rpt->report_format_ind = 1
            and rpt->result_space_ind = 1
            and rpt->orders[o_cnt].assays_cnt > 0
            and rpt->result_comments_ind = 1)
               for (a_cnt = 1 to rpt->orders[o_cnt].assays_cnt)
                  if (rpt->orders[o_cnt].assays[a_cnt].results_cnt > 0)
                     for (r_cnt = 1 to rpt->orders[o_cnt]
                             .assays[a_cnt].results_cnt)
                        print_result_comments
                     endfor
                  endif
               endfor
            endif
         
      /***********************************************************************
      * Foot Report                                                          *
      ***********************************************************************/
         foot report
            ;*
            ;* Print blank lines for notations at the end of the report.
            ;*
            if (rpt->blank_lines > 0)
               if (curr_accn_row >= curr_det_row)
                  min_accn_rows = spacing + (rpt->blank_lines * spacing)
                  if ((curr_accn_row + min_accn_rows) >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
               else
                  min_det_rows = spacing + (rpt->blank_lines * spacing)
                  if ((curr_det_row + min_det_rows) >= max_nbr_rows)
                     break
                  endif
                  row curr_det_row
               endif
               curr_accn_row = row
               curr_det_row = row
               for (cnt = 1 to rpt->blank_lines)
                  curr_accn_row = curr_accn_row + spacing
                  curr_det_row = curr_accn_row
                  if (curr_accn_row >= max_nbr_rows)
                     break
                  endif
                  row curr_accn_row
                  start_col = 0
                  col_len = max_nbr_cols - 1
                  print_underline
               endfor
            endif
            
            ;*
            ;* Print end of report line
            ;*
            if (curr_accn_row >= curr_det_row)
               if ((curr_accn_row + 2) >= max_nbr_rows)
                  break
               endif
               row curr_accn_row
               row + 2
            else
               if ((curr_det_row + 2) >= max_nbr_rows)
                  break
               endif
               row curr_det_row
               row + 2
            endif
            call center(uar_i18ngetmessage(i18nHandle, 
              "end_report", "***** END OF REPORT *****"),
              0, value(max_nbr_cols))
              
         with
            nocounter
           ,nullreport
           ,maxcol = value(max_nbr_cols)
           ,maxrow = value(max_nbr_rows)
           ,outerjoin = d_a
           ,dontcare = d2
           ,outerjoin = d_r
           ,dontcare = d3

         ;*
         ;* Spool report to the printer
         ;*
         if (rpt->printer != "MINE"
         and rpt->printer != "DEBUG"
         and rpt->printer != "DEBUGDUMP")
            if (rpt->landscape_ind = 1)
               set spool = value(temp_file) value(rpt->printer) 
                 with landscape, copy = value(rpt->copies)
            else
               set spool = value(temp_file) value(rpt->printer) 
                 with copy = value(rpt->copies)
            endif
         endif

      /***********************************************************************
      * If running from Operations, autosave the worklist.                   *
      ***********************************************************************/
         if (trim(request->batch_selection) > " "
         and print_grp->group[grp_nbr].ref_data_loaded_ind = 0
         and rpt->orders_cnt > 0)
            ;*
            ;* Call GLB_ADD_WKLST_ELE
            ;*
            set req250085->worklist_prsnl_id = 0.0  ;Not used
            set req250085->status_cd = 0.0          ;Not used
            set req250085->service_resource_cd = 
              rpt->service_resource_cd
            set req250085->worklist_ref_id = 
              rpt->worklist_ref_id
            if (rpt->result_space_ind = 1)
               ;* Worksheet
               set req250085->worklist_type_flag = 0
            else
               ;* Worklist
               set req250085->worklist_type_flag = 1
            endif
            set req250085->worklist_alias =
              rpt->worklist_alias
            if (rpt->include_flag != 1)
               case (rpt->procedure_inc_flag)
                 of 1:  ;* Group (i.e. orderable level) procedures
                    if (rpt->procs_cnt > 0)
                       set stat = 
                         alterlist(req250085->components, rpt->procs_cnt)
                       for (cnt = 1 to rpt->procs_cnt)
                          set req250085->components[cnt].worklist_seq = cnt
                          set req250085->components[cnt].catalog_cd = 
                            rpt->procs[cnt].procedure_cd 
                          set req250085->components[cnt].task_assay_cd = 0.0
                       endfor
                    endif
                 of 2:  ;* Detail (i.e. task assay level) procedures
                    if (rpt->procs_cnt > 0)
                       set stat = 
                         alterlist(req250085->components, rpt->procs_cnt)
                       for (cnt = 1 to rpt->procs_cnt)
                          set req250085->components[cnt].worklist_seq = cnt
                          set req250085->components[cnt].catalog_cd = 0.0
                          set req250085->components[cnt].task_assay_cd =
                            rpt->procs[cnt].procedure_cd 
                       endfor
                    endif
                 else   ;* All procedures
                    set stat = alterlist(req250085->components, 1)
                    set req250085->components[1].worklist_seq = 1
                    set req250085->components[1].catalog_cd = 0.0
                    set req250085->components[1].task_assay_cd = 0.0
               endcase
            endif
            set stat = alterlist(req250085->orders, rpt->orders_cnt)
            for (cnt = 1 to rpt->orders_cnt)
               set req250085->orders[cnt].order_id =
                 rpt->orders[cnt].order_id 
               set req250085->orders[cnt].accession_id =
                 rpt->orders[cnt].accession_id 
               set req250085->orders[cnt].sequence = cnt
               set req250085->orders[cnt].sequence_ident =
                 rpt->orders[cnt].sequence_ident 
            endfor 
            execute GLB_ADD_WKLST_ELE with 
              replace(request, req250085), 
              replace(reply, reply250085)
            if (reply250085->status_data.status = "F")
               ;* Script failure.
               set reply->status_data.subeventstatus[1]
                 .OperationName = "EXECUTE"
               set reply->status_data.subeventstatus[1]
                 .OperationStatus = "F"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectName = "GLB_ADD_WKLST_ELE"
               set reply->status_data.subeventstatus[1]
                 .TargetObjectValue = 
                 "Unable to save worklist."
               go to Exit_Script
            endif
         endif
         
      /***********************************************************************
      * Next worklist.                                                       *
      ***********************************************************************/
      #Next_Worklist
         ;*
         ;* Check for creation of additional worklists
         ;*
         set grp_nbr = grp_nbr + 1
         if (grp_nbr <= print_grp->group_cnt)
            go to Process_Worklist
         endif
         
      /***********************************************************************
      * Exit Script                                                          *
      ***********************************************************************/
         set reply->status_data.status = "S"

      #Exit_Script
         
         end
         go

;Generated by GNU enscript 1.6.4.

         endif
 
      /***********************************************************************
      * Exit Script                                                          *
      ***********************************************************************/
         set reply->status_data.status = "S"
 
      #Exit_Script
 
         end
         go

;Generated by GNU enscript 1.6.4.
