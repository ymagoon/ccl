 ;;Solution_Test/script/PathNet -- Gen Lab/glb_upd_qc_results/glb_upd_qc_results.prg Turn on black mode

/*~BB~************************************************************************
      *                                                                      *
      *  Copyright Notice:  (c) 1983 Laboratory Information Systems &        *
      *                              Technology, Inc.                        *
      *       Revision      (c) 1984-1995 Cerner Corporation                 *
      *                                                                      *
      *  Cerner (R) Proprietary Rights Notice:  All rights reserved.         *
      *  This material contains the valuable properties and trade secrets of *
      *  Cerner Corporation of Kansas City, Missouri, United States of       *
      *  America (Cerner), embodying substantial creative efforts and        *
      *  confidential information, ideas and expressions, no part of which   *
      *  may be reproduced or transmitted in any form or by any means, or    *
      *  retained in any storage or retrieval system without the express     *
      *  written permission of Cerner.                                       *
      *                                                                      *
      *  Cerner is a registered mark of Cerner Corporation.                  *
      *                                                                      *
  ~BE~***********************************************************************/
/*****************************************************************************
        Source file name:       GLB_UPD_QC_RESULTS.PRG
        Object name:            GLB_UPD_QC_RESULTS
        Request #:              257524

        Product:                General Lab - Quality Control
        Product Team:           GLB
        HNA Version:            500
        CCL Version:            4.0

        Program purpose:        Update QC Results and comments
                                into the database

        Tables read:            qc_comment
                                qc_result_event

        Tables updated:         qc_result
                                qc_comment
                                qc_result_event
                                qc_inc_component
                                qc_result_grp
                                qc_result_grp_r

        Executing from:         General Lab QC Result Entry

        Special Notes:          n/a
******************************************************************************/
;~DB~************************************************************************
;    *                      GENERATED MODIFICATION CONTROL LOG              *
;    ************************************************************************
;    *                                                                      *
;    *Mod Date     Engineer             Comment                             *
;    *--- -------- -------------------- ----------------------------------- *
;     ### 08/10/96 Kevin Brunner        Initial Release                     *
;     001 09/15/97 Kevin Brunner        Add processing of arl_id            *
;     002 10/10/97 Kevin Brunner        Change the event sequence processing*
;     003 11/26/97 Kevin Brunner        Add rule processing fails           *
;     004 12/11/97 Kevin Brunner        Add autoverify logic                *
;     005 03/20/98 Kevin Brunner        Footnote logic change on update     *
;    *006 12/21/98 Hal Patchen          Add instr_accn_queue logic          *
;    *007 06/22/00 Gary Runde           Write perform_personnel_id of user  *
;                                       assigned to instrument              *
;    *008 07/21/00 Chris Heil           Write autoverification error codes  *
;    *009 09/22/00 Gary Runde           Set av_status_flag to a two when    *
;                                       QC is out of control                *
;    *010 09/27/00 Gary Runde           Call evaluate qc scheduler script   *
;    *011 11/06/00 Gary Runde           Delete qc_result_rule_r rows for    *
;                                       result in case rows already exist   *
;    *012 03/21/01 Gary Runde           Check before turning off AV         *
;    *013 05/02/01 Gary Runde           Call EvalQCSchedule for verf alpha  *
;    *014 05/17/01 Mike Gabrick         Check for PERF results when writing *
;                                       instrument queue.                   *
;    *015 02/18/03 Nick Smith           Fix spelling of ..._auto_verf_cd    *
;    *016 05/08/07 Vibhor Mathur        Get the updt_cnt value from 		*
;										qc_result table whenever its updated*
;    *017 07/15/07 Ryan Manuel          Add logic that determines whether   *
;                                       QC will be turned off based on only *
;                                       current QC result.                  *
;	   *018 08/10/10 Steve Hendrick		    Add logic to add QC accession to an *
;										                    automatic worklist if one exists for*
;										                    the current service resource.       *
;    *019 09/02/10 Steve Hendrick       Populate qc_group_id in structure   *
;                                       items_for_automatic_worklist        *
;    *020 09/16/10 Ryan Manuel          Added accession_key to support calls*
;                                       from BRV                            *
;    *021 12/10/10 Steve Hendrick       Carry forward automatic worklist ID *
;                                       if result type and result value have*
;                                       not changed.                        *
;~DE~************************************************************************
;~END~ ******************  END OF ALL MODCONTROL BLOCKS  ********************

      drop program GLB_UPD_QC_RESULTS:dba go
      create program GLB_UPD_QC_RESULTS:dba

/********************************************************************/
/*  Request Record                                                  */
/********************************************************************/
/*
      record request
      (
         1 event_dt_tm                  = dq8
         1 event_personnel_id           = f8
         1 event_reason                 = vc
         1 qc_group_id                  = f8
         1 qc_status_flag               = i2
         1 accession_id                 = f8
         1 qc_results[x]
           2 qc_result_id               = f8
           2 control_id                 = f8
           2 lot_id                     = f8
           2 service_resource_cd        = f8
           2 task_assay_cd              = f8
           2 result_status_cd           = f8
           2 perform_personnel_id       = f8
           2 perform_dt_tm              = dq8
           2 result_type_cd             = f8
           2 result_value_numeric       = f8
           2 result_value_alpha         = c25
           2 nomenclature_id            = f8
           2 resource_error_codes       = vc
           2 multiplex_resource_cd      = f8
           2 rule_id                    = f8
           2 arl_id                     = f8    ;001...
           2 mean                       = f8
           2 prev_result_id             = f8
           2 clinical_std_dev           = f8
           2 statistical_std_dev        = f8
           2 abs_low                    = f8
           2 abs_high                   = f8
           2 result_control_cd          = f8
           2 numeric_raw_value          = f8
           2 preactive_ind              = i2
           2 qc_result_updt_cnt         = i4
           2 perform_result_key         = f8
           2 result_process_cd          = f8
           2 ascii_text                 = c60
           2 interface_flag             = i2
           2 interface_av_ind           = i2
           2 component_cnt              = i4
           2 components[x]
             3 used_qc_result_id        = f8
           2 ignore_cmt_ind             = i2
           2 comment_ind                = i2
           2 comment_cnt                = i4
           2 comments[x]
             3 comment_type_cd          = f8
             3 perform_prsnl_id         = f8
             3 comment_dt_tm            = dq8
             3 comment_text             = vc
           2 trouble_step_cnt           = i4
           2 trouble_steps[x]
             3 trouble_id               = f8
             3 active_ind               = i2
             3 trouble_updt_cnt         = i4
           2 rule_fail_cnt              = i4     ;003...
           2 rule_fails[x]                        ;003...
             3 sequence                 = i2     ;003...
             3 status_flag              = i2     ;003...
           2 auto_verify_code_cnt       = i4
           2 auto_verify_codes[x]
             3  auto_verify_cd          = f8
           2 qc_group_assay_id          = f8
         1 qc_inquiry_ind               = i2
         1 accession_key                = vc ; This is used by BRE/BRV
      )
*/
;record reqinfo
;( 1 commit_ind  = i2
;  1 updt_id     = f8
;  1 position_cd = f8
;  1 updt_app    = i4
;  1 updt_task   = i4
;  1 updt_req    = i4
;  1 updt_applctx= i4
;)

/********************************************************************/
/*  Reply Record                                                    */
/********************************************************************/

      record reply
      (
          1  qc_group_id                 = f8
          1  qc_results[10]
            2  qc_result_id              = f8
            2  task_assay_cd             = f8
            2  qc_result_updt_cnt        = i4
            2  updt_id                   = f8
            2  perform_result_key        = f8
         1 status_data
           2 status                = c1
           2 subeventstatus[1]
             3 OperationName       = c15
             3 OperationStatus     = c1
             3 TargetObjectName    = c15
             3 TargetObjectValue   = vc
         1 accession_key = vc
      )


%i cclsource:glb_script_logging.inc
%i cclsource:glb_eval_qc_scheduler.inc                                               ;010

  record current
  (
    1 result_type_cd            = f8
    1 nomenclature_id           = f8
    1 numeric_raw_value         = f8
    1 worklist_id               = f8
    1 copy_forward_worklist_id  = f8
  )

      /***********************************************************************
      * Insert result group subroutine                                       *
      ***********************************************************************/
        declare insert_group( none ) = i4
        subroutine insert_group( none )

; Generate sequence for result insert
          select into "nl:"
             next_seq_nbr = seq(pathnet_seq,nextval) "######################;rp0"
          from dual
          detail
             ginsert_qc_group_id = next_seq_nbr
          with nocounter, format

       /* Insert result record */
          insert into
            qc_result_grp qrg
          set
           qrg.qc_group_id          = ginsert_qc_group_id,
           qrg.accession_id         = request->accession_id,
           qrg.group_dt_tm          = cnvtdatetime(curdate, curtime3),
           qrg.status_flag          = request->qc_status_flag,
           qrg.updt_dt_tm = cnvtdatetime(curdate, curtime3),
           qrg.updt_id = reqinfo->updt_id,
           qrg.updt_task = reqinfo->updt_task,
           qrg.updt_applctx = reqinfo->updt_applctx,
           qrg.updt_cnt = 0

          plan qrg

          with
           nocounter

          return(curqual)
        end

      /***********************************************************************
      * Update result group subroutine                                       *
      *   - not currently locking the row on update - may need to?           *
      ***********************************************************************/
         declare update_group( arg_group_id, arg_group_status ) = i4
         subroutine update_group( arg_group_id, arg_group_status )
            update into
               qc_result_grp qrg1
            set
               qrg1.status_flag = arg_group_status,
               qrg1.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               qrg1.updt_id = reqinfo->updt_id,
               qrg1.updt_task = reqinfo->updt_task,
               qrg1.updt_applctx = reqinfo->updt_applctx,
               qrg1.updt_cnt = qrg1.updt_cnt + 1
            plan qrg1  where qrg1.qc_group_id = arg_group_id
            with nocounter
            return(curqual)
         end

/*********007 start new code ************************/
      /********************************************************************************
      * Get person_id of user assigned to instrument to write perform_personnel_id    *
      ********************************************************************************/
         subroutine get_perform_personnel_id( nonePerfID )

             ;if the interface flag is greater than zero then this came from the instrument
             if ((request->qc_results[ridx].interface_flag > 0) and
                 (request->qc_results[ridx].perform_personnel_id = 0.0))
                   ;if from instrument read the INSTRUMENT_ASSIGNMENT table to see
                   ;if anyone is logged into this instrument currently
                   select into "nl:"
                      ia.service_resource_cd,
                      ia.prsnl_id
                   from
                      instrument_assignment ia
                   plan ia where ia.service_resource_cd =
                                      request->qc_results[ridx].service_resource_cd
                             and ia.active_ind = 1
                             and cnvtdatetime(curdate,curtime3) between
                                      ia.beg_effective_dt_tm and ia.end_effective_dt_tm
                   detail
                       ;if a person is found, then use it as the perform_personnel_id on the
                       ;perform_result table
                       request->qc_results[ridx].perform_personnel_id =
                                      ia.prsnl_id
                   with nocounter
             endif
         end
/*********007 end new code ************************/


      /***********************************************************************
      * Insert result subroutine                                             *
      ***********************************************************************/
        declare insert_result( none ) = i4
        subroutine insert_result( none )

          declare nCarryForwardWklstID = i2 with protect, noconstant(0)
; Generate sequence for result insert
          select into "nl:"
             next_seq_nbr = seq(pathnet_seq,nextval) "######################;rp0"
          from dual
          detail
             ginsert_qc_result_id = next_seq_nbr
          with nocounter, format

          /************************************/                     ;007
          /* Get assigned user                */                     ;007
          /************************************/                     ;007
          call get_perform_personnel_id(0)                           ;007

          ;if there is an existing result and it is on an automatic worklist, we want to carry forward the worklist ID 
          ;if the result value and result type have not changed.
          set nCarryForwardWklstID = 0
          if (request->qc_results[ridx].qc_result_id > 0.0 and                            ;existing result
                (current->worklist_id > 0.0 or current->copy_forward_worklist_id > 0.0))  ;  and is associated w/ auto wklst
            if ( (request->qc_results[ridx].result_type_cd = current->result_type_cd      ;result type not changed
                     and request->qc_results[ridx].result_type_cd = result_type_alpha_cd  ;result type is alpha
                     and request->qc_results[ridx].nomenclature_id = current->nomenclature_id) ;result value has not changed
                     
                 or (request->qc_results[ridx].result_type_cd = current->result_type_cd              ;result type not changed
                     and request->qc_results[ridx].result_type_cd = result_type_numeric_cd           ;result type is numeric
                     and request->qc_results[ridx].numeric_raw_value = current->numeric_raw_value )) ;result value has not changed
            
                set nCarryForwardWklstID = 1                           
            
            endif
          endif
       /* Insert result record */
          insert into
            qc_result q1
          set
           q1.qc_result_id          = ginsert_qc_result_id,
           q1.qc_group_id           = curr_group_id,
           q1.control_id            = request->qc_results[ridx].control_id,
           q1.lot_id                = request->qc_results[ridx].lot_id,
           q1.service_resource_cd   = request->qc_results[ridx].service_resource_cd,
           q1.task_assay_cd         = request->qc_results[ridx].task_assay_cd,
           q1.result_status_cd      = request->qc_results[ridx].result_status_cd,
           q1.perform_personnel_id  = request->qc_results[ridx].perform_personnel_id,
           q1.perform_dt_tm    = if (request->qc_results[ridx].perform_dt_tm > 0)
                                   cnvtdatetime(request->qc_results[ridx].perform_dt_tm)
                                 else
                                   cnvtdatetime(curdate,curtime3)
                                 endif,
           q1.result_type_cd        = request->qc_results[ridx].result_type_cd,
           q1.result_value_numeric  = request->qc_results[ridx].result_value_numeric,
           q1.result_value_alpha    = request->qc_results[ridx].result_value_alpha,
           q1.resource_error_codes  = request->qc_results[ridx].resource_error_codes,
           q1.multiplex_resource_cd = request->qc_results[ridx].multiplex_resource_cd,
           q1.prev_result_id        = prev_qc_result_id,
           q1.numeric_raw_value     = request->qc_results[ridx].numeric_raw_value,
           q1.arl_id                = request->qc_results[ridx].arl_id,  ;001...
           q1.mean                  = request->qc_results[ridx].mean,
           q1.clinical_std_dev      = request->qc_results[ridx].clinical_std_dev,
           q1.statistical_std_dev   = request->qc_results[ridx].statistical_std_dev,
           q1.abs_low               = request->qc_results[ridx].abs_low,
           q1.abs_high              = request->qc_results[ridx].abs_high,
           q1.rule_id               = request->qc_results[ridx].rule_id,
           q1.result_control_cd     = request->qc_results[ridx].result_control_cd,
           q1.preactive_ind         = request->qc_results[ridx].preactive_ind,
           q1.nomenclature_id       = request->qc_results[ridx].nomenclature_id,
           q1.result_process_cd     = request->qc_results[ridx].result_process_cd,
           q1.ascii_text            = request->qc_results[ridx].ascii_text,
           q1.interface_flag        = request->qc_results[ridx].interface_flag,
           q1.qc_group_assay_id     = request->qc_results[ridx].qc_group_assay_id,
           q1.comment_ind           = if (check_for_comment( 0 ) = 0)
                                        0
                                      else
                                        1
                                      endif,
           q1.updt_dt_tm            = cnvtdatetime(curdate,curtime3),
           q1.updt_cnt              = 0,
           q1.updt_task             = reqinfo->updt_task,
           q1.updt_id               = reqinfo->updt_id,
           q1.updt_applctx          = reqinfo->updt_applctx,
           q1.worklist_id           = if ( nCarryForwardWklstID = 1 )
                                        current->worklist_id
                                      else
                                        0.0
                                      endif,
           q1.copy_forward_worklist_id = if ( nCarryForwardWklstID = 1 )
                                           current->copy_forward_worklist_id
                                         else
                                           0.0
                                         endif

          plan q1

          with
           nocounter

          return(curqual)
        end

/*************009 BEGIN NEW CODE *****************************/
      /***********************************************************************
      * Update AVStatus subroutine                                             *
      ***********************************************************************/
         subroutine update_av_status ( noneGR1 )

            ;check for out of control result
            if (request->qc_results[ridx].result_control_cd = out_control_cd )

                ;012 GR4187 BEGIN NEW CODE

                ;check to see if the AV requires QC and the validate QC Schedule ind
                ;values before turning off AV for this QC result

                set av_req_qc_ind = 0
                set val_qc_schedule_ind = 0

                ;check the lab_instrument table to see if QC is required
                select into "nl:"
                  l.service_resource_cd,
                  l.av_req_qc_ind
                from
                  lab_instrument l
                plan l
                  where l.service_resource_cd = request->qc_results[ridx].service_resource_cd
                    and l.active_ind = 1
                head l.service_resource_cd
                  av_req_qc_ind = l.av_req_qc_ind
                with nocounter

                ;get the validate_qc_schedule_ind from the auto_verify table
                select into "nl:"
                  av.validate_qc_schedule_ind,
                  av.service_resource_cd,
                  av.task_assay_cd
                from
                  auto_verify av
                plan av
                  where av.service_resource_cd = request->qc_results[ridx].service_resource_cd
                    and av.task_assay_cd = request->qc_results[ridx].task_assay_cd
                    and cnvtdatetime(curdate, curtime3) between
                                 av.beg_effective_dt_tm and
                                 av.end_effective_dt_tm
                    and av.active_ind = 1
                head av.service_resource_cd
                  val_qc_schedule_ind = av.validate_qc_schedule_ind
                with nocounter

                if ((av_req_qc_ind = 1) and (val_qc_schedule_ind = 1))

                ;012 GR4187 END NEW CODE

                   ;if this result is out of control
                   ;set the av_status_flag on the auto_verify table to be a two
                   ;which means autoverification will stop
                   update into auto_verify av
                   set
                      av.av_status_flag   = 2,
                      av.updt_applctx     = reqinfo->updt_applctx,
                      av.updt_cnt         = av.updt_cnt + 1,
                      av.updt_dt_tm       = cnvtdatetime(curdate, curtime3),
                      av.updt_id          = reqinfo->updt_id,
                      av.updt_task        = reqinfo->updt_task
                   where av.service_resource_cd = request->qc_results[ridx].service_resource_cd
                     and av.task_assay_cd = request->qc_results[ridx].task_assay_cd
                     and cnvtdatetime(curdate, curtime3) between av.beg_effective_dt_tm and
                                                                 av.end_effective_dt_tm
                     and av.active_ind = 1
                   with nocounter

                   ;write the new av_status_event row
                   set av_status_id = 0.0
                   select into "nl:"
                      next_seq_nbr = seq(pathnet_seq,nextval) "######################;rp0"
                   from
                      dual
                   detail
                      av_status_id = next_seq_nbr
                   with nocounter, format

                   insert into av_status_event ae
                   set
                      ae.accession_id           = 0.0,
                      ae.av_event_id            = av_status_id,
                      ae.av_ind                 = 2,
                      ae.task_assay_cd          = request->qc_results[ridx].task_assay_cd,
                      ae.person_id              = 0.0,
                      ae.service_resource_cd    = request->qc_results[ridx].service_resource_cd,
                      ae.updt_applctx           = reqinfo->updt_applctx,
                      ae.updt_cnt               = 0,
                      ae.updt_dt_tm             = cnvtdatetime(curdate, curtime3),
                      ae.updt_id                = reqinfo->updt_id,
                      ae.updt_task              = reqinfo->updt_task
                   plan ae
                   with nocounter
                endif                                                       ;012
            endif
         end
/*************009 END NEW CODE *****************************/

      /***********************************************************************
      * Update result subroutine                                             *
      ***********************************************************************/
         declare update_result( arg_qc_result_id, arg_curr_status_cd ) = i4
         subroutine update_result( arg_qc_result_id, arg_curr_status_cd )
            set stat = initrec (current)
; Lock row for update
            set curr_updt_cnt = -1
            select into "nl:"
               qr1.qc_result_id,
               qr1.qc_group_id
            from qc_result qr1
            plan qr1
              where qr1.qc_result_id = arg_qc_result_id
            detail
              current->result_type_cd = qr1.result_type_cd 
              current->nomenclature_id = qr1.nomenclature_id 
              current->numeric_raw_value = qr1.numeric_raw_value 
              current->worklist_id = qr1.worklist_id 
              current->copy_forward_worklist_id = qr1.copy_forward_worklist_id 
              curr_updt_cnt = qr1.updt_cnt
              if (request->qc_group_id = -1)
                curr_group_id = qr1.qc_group_id
              endif
              cur_comment_ind = qr1.comment_ind   ;005...
            with
              nocounter,
              forupdate(qr1)

; Check to see if result has been updated.
            if (curr_updt_cnt !=
                request->qc_results[ridx].qc_result_updt_cnt)
               return(0)
            endif

            update into
               qc_result qr
            set
               qr.result_status_cd = arg_curr_status_cd,
               qr.result_control_cd = request->qc_results[ridx].result_control_cd,
               qr.qc_group_assay_id = request->qc_results[ridx].qc_group_assay_id,
               qr.comment_ind       = if (cur_comment_ind != 1 and check_for_comment( 0 ) = 0)
                                        0
                                      else
                                        1
                                      endif,
               qr.updt_dt_tm = cnvtdatetime(curdate, curtime3),
               qr.updt_id = reqinfo->updt_id,
               qr.updt_task = reqinfo->updt_task,
               qr.updt_applctx = reqinfo->updt_applctx,
               qr.updt_cnt = qr.updt_cnt + 1
            plan qr  where qr.qc_result_id = arg_qc_result_id
                       and qr.updt_cnt =
                          request->qc_results[ridx].qc_result_updt_cnt
            with nocounter
            
            select into "nl:"
            qr.updt_cnt
            from qc_result qr where qr.qc_result_id = arg_qc_result_id
            detail
            gresult_updt_cnt = qr.updt_cnt
            with nocounter
            
            return(curqual)
         end

      /***********************************************************************
      * Insert result event subroutine                                       *
      ***********************************************************************/
        declare insert_result_event( arg_qc_result_id, arg_event_seq, arg_curr_status_cd ) = i4
        subroutine insert_result_event( arg_qc_result_id, arg_event_seq, arg_curr_status_cd )
          insert into
            qc_result_event qre
          set
           qre.qc_result_id          = arg_qc_result_id,
           qre.event_sequence        = arg_event_seq,
           qre.event_personnel_id    = request->event_personnel_id,
           qre.event_reason          = request->event_reason,
           qre.event_dt_tm           = if (arg_curr_status_cd = result_status_performed_cd)
                                         if ((request->qc_results[ridx].perform_dt_tm > 0))
                                           cnvtdatetime(request->qc_results[ridx].perform_dt_tm)
                                         else
                                           cnvtdatetime(curdate,curtime3)
                                         endif
                                       else
                                         cnvtdatetime(request->event_dt_tm)
                                       endif,
           qre.event_type_cd         = arg_curr_status_cd,
           qre.updt_dt_tm            = cnvtdatetime(curdate,curtime3),
           qre.updt_cnt              = 0,
           qre.updt_task             = reqinfo->updt_task,
           qre.updt_id               = reqinfo->updt_id,
           qre.updt_applctx          = reqinfo->updt_applctx

          plan qre

          with
           nocounter
           
          if (curqual > 0)
            ;update the qc_result event_dt_tm if the field exists and 
            ;we are not inserting performed or old performed status
            if ((nEvent_Dt_tm_Column_Exists = 1) and 
               (arg_curr_status_cd not in (result_status_old_perf_cd, result_status_performed_cd)))
  
              update into qc_result qr
              set 
                qr.event_dt_tm = cnvtdatetime(request->event_dt_tm)
              plan qr
                where qr.qc_result_id = arg_qc_result_id
              with nocounter
              
              return (curqual)
            else
              return (1)
            endif
          else
            return (0)
          endif
        end

      /***********************************************************************
      * Find last event sequence                                             *
      ***********************************************************************/
        declare check_event_sequence = i4
        declare find_sequence ( arg_qc_result_id ) = i4
        subroutine find_sequence( arg_qc_result_id )
          set check_event_sequence = 0
          select into "nl:"
            qre1.qc_result_id,
            qre1.event_sequence
          from qc_result_event qre1
          plan qre1
            where qre1.qc_result_id = arg_qc_result_id
          order
            qre1.event_sequence ;002... desc

          detail
            check_event_sequence = qre1.event_sequence + 1

          with
            nocounter ;002... ,
;002...             maxqual(qre1,1)
          return (check_event_sequence)
        end

      /***********************************************************************
      * Check result value to see if changed.                                *
      ***********************************************************************/
        declare check_return = i4
        declare check_result ( arg_qc_result_id ) = i4
        subroutine check_result( arg_qc_result_id )
          set check_return = 1
          select into "nl:"
            q2.qc_result_id,
            q2.result_value_numeric,
            q2.nomenclature_id
          from qc_result q2
          plan q2
            where q2.qc_result_id = arg_qc_result_id

          detail
          if (request->qc_results[ridx].result_type_cd = result_type_numeric_cd)
            if (ROUND(request->qc_results[ridx].result_value_numeric, 10) = ROUND(q2.result_value_numeric, 10))
              gresult_updt_cnt = q2.updt_cnt + 1
              check_return = 0
            else
              gresult_updt_cnt = q2.updt_cnt + 1
              check_return = 1
            endif
          elseif (request->qc_results[ridx].result_type_cd = result_type_alpha_cd)
            if (request->qc_results[ridx].nomenclature_id = q2.nomenclature_id)
              gresult_updt_cnt = q2.updt_cnt + 1
              check_return = 0
            else
              gresult_updt_cnt = q2.updt_cnt + 1
              check_return = 1
            endif
          else
              gresult_updt_cnt = q2.updt_cnt + 1
              check_return = 1
          endif

          with
            nocounter

          return(check_return)
        end
			 	   
      /***********************************************************************
      * Find last action sequence for comment                                *
      ***********************************************************************/
        declare check_action_sequence = i4
        declare find_cmt_sequence ( arg_qc_result_id, arg_comment_type_cd ) = i4
        subroutine find_cmt_sequence( arg_qc_result_id, arg_comment_type_cd )
          set check_action_sequence = 0
          select into "nl:"
            qcc1.qc_result_id,
            qcc1.comment_type_cd,
            qcc1.action_sequence
          from qc_comment qcc1
          plan qcc1
            where qcc1.qc_result_id = arg_qc_result_id
              and qcc1.comment_type_cd = arg_comment_type_cd
          order
            qcc1.action_sequence ;002... desc

          detail
            check_action_sequence = qcc1.action_sequence + 1

          with
            nocounter ;002... ,
;002...             maxqual(qcc1,1)

          return (check_action_sequence)
        end

      /***********************************************************************
      * Insert auto_verify_code subroutine                                   *
      ***********************************************************************/
         declare insert_auto_verify_cd( arg_qc_result_id ) = i4
         subroutine insert_auto_verify_cd( arg_qc_result_id )

            if (request->qc_results[ridx]->auto_verify_code_cnt > 0)
                insert into auto_verify_code avc,
                            (dummyt d1 with seq = value(request->qc_results[ridx]->
                                                        auto_verify_code_cnt)) set
                  avc.parent_entity_id = arg_qc_result_id,
                  avc.parent_entity_name = "QC_RESULT",
                  avc.auto_verify_cd = request->qc_results[ridx]->
                                                auto_verify_codes[d1.seq]->auto_verify_cd,
                  avc.updt_dt_tm = cnvtdatetime(curdate, curtime3),
                  avc.updt_id = reqinfo->updt_id,
                  avc.updt_task = reqinfo->updt_task,
                  avc.updt_applctx = reqinfo->updt_applctx,
                  avc.updt_cnt = 0
                plan d1
                join avc
                with nocounter
    
                return(curqual)
            else
                return(1)
            endif
         end

      /***********************************************************************
      * Insert result comment                                                *
      ***********************************************************************/
        declare insert_result_comment( arg_qc_result_id, arg_comment_type_cd, arg_comment_sequence ) = i4
        subroutine insert_result_comment( arg_qc_result_id, arg_comment_type_cd, arg_comment_sequence )

          set long_text_seq = 0.0
          select into "nl:"
             y = seq(long_data_seq,nextval) "###################;rp0"
          from dual
          detail
             long_text_seq = y
          with nocounter, format

          if (curqual = 0)
             go to seq_failed
          endif

          insert
             into long_text l
          set
             l.long_text_id           = long_text_seq,
             l.long_text              = request->qc_results[ridx].comments[cidx].comment_text,
             l.active_ind             = 1,
             l.active_status_cd       = 0.0,
             l.active_status_dt_tm    = cnvtdatetime(curdate,curtime3),
             l.active_status_prsnl_id = request->qc_results[ridx].comments[cidx].perform_prsnl_id,
             l.parent_entity_name     = "QC_COMMENT",
             l.parent_entity_id       = arg_qc_result_id,
             l.updt_dt_tm             = cnvtdatetime(curdate,curtime3),
             l.updt_cnt               = 0,
             l.updt_task              = reqinfo->updt_task,
             l.updt_id                = reqinfo->updt_id,
             l.updt_applctx           = reqinfo->updt_applctx
          with
            nocounter

          insert
             into qc_comment qcc
          set
             qcc.qc_result_id     = arg_qc_result_id,
             qcc.comment_type_cd  = arg_comment_type_cd,
             qcc.action_sequence  = arg_comment_sequence,
             qcc.long_text_id      = long_text_seq,
             qcc.perform_prsnl_id  = request->qc_results[ridx].comments[cidx].perform_prsnl_id,
             qcc.comment_dt_tm    = if (request->qc_results[ridx].comments[cidx].comment_dt_tm > 0)
                                     cnvtdatetime(request->qc_results[ridx].comments[cidx].comment_dt_tm)
                                   else
                                     cnvtdatetime(curdate,curtime3)
                                   endif,
             qcc.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
             qcc.updt_cnt         = 0,
             qcc.updt_task        = reqinfo->updt_task,
             qcc.updt_id          = reqinfo->updt_id,
             qcc.updt_applctx     = reqinfo->updt_applctx

          plan qcc

          with
            nocounter

          return(curqual)
        end

      /***********************************************************************
      * Check for trouble step record already written                        *
      ***********************************************************************/
        declare find_trouble ( arg_qc_result_id, arg_trouble_id ) = i4
        subroutine find_trouble( arg_qc_result_id, arg_trouble_id )
          select into "nl:"
            qrtr.qc_result_id,
            qrtr.trouble_id

          from qc_result_trouble_r qrtr

          plan qrtr
            where qrtr.qc_result_id = arg_qc_result_id
              and qrtr.trouble_id = arg_trouble_id

          with
            nocounter

          return (curqual)
        end

      /***********************************************************************
      * Insert trouble shooting step and result relationship                 *
      ***********************************************************************/
        declare insert_trouble_step( arg_qc_result_id, arg_trouble_id ) = i4
        subroutine insert_trouble_step( arg_qc_result_id, arg_trouble_id )
          insert
             into qc_result_trouble_r qrtr
          set
             qrtr.qc_result_id    = arg_qc_result_id,
             qrtr.trouble_id      = arg_trouble_id,
             qrtr.active_ind      = request->qc_results[ridx].trouble_steps[tidx].active_ind,
             qrtr.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
             qrtr.updt_cnt         = 0,
             qrtr.updt_task        = reqinfo->updt_task,
             qrtr.updt_id          = reqinfo->updt_id,
             qrtr.updt_applctx     = reqinfo->updt_applctx

          plan qrtr

          with
            nocounter

          return(curqual)
        end

      /***********************************************************************
      * Update trouble shooting step and result relationship                 *
      ***********************************************************************/
        declare update_trouble_step( arg_qc_result_id, arg_trouble_id ) = i4
        subroutine update_trouble_step( arg_qc_result_id, arg_trouble_id )
          update
             into qc_result_trouble_r qrtr1
          set
             qrtr1.active_ind      = request->qc_results[ridx].trouble_steps[tidx].active_ind,
             qrtr1.updt_dt_tm       = cnvtdatetime(curdate,curtime3),
             qrtr1.updt_cnt         = request->qc_results[ridx].trouble_steps[tidx].trouble_updt_cnt + 1,
             qrtr1.updt_task        = reqinfo->updt_task,
             qrtr1.updt_id          = reqinfo->updt_id,
             qrtr1.updt_applctx     = reqinfo->updt_applctx

          plan qrtr1
            where qrtr1.qc_result_id = arg_qc_result_id
              and qrtr1.trouble_id = arg_trouble_id
              and qrtr1.updt_cnt = request->qc_results[ridx].trouble_steps[tidx].trouble_updt_cnt

          with
            nocounter

          return(curqual)
        end

      /***********************************************************************
      * Insert rule fail and result relationship      ;003...                *
      ***********************************************************************/
        declare insert_rule_fail( arg_qc_result_id ) = i4
        subroutine insert_rule_fail( arg_qc_result_id )
          ;delete rows from qc_result_rule_r in case the av server wrote     ;011
          ;something before on perform                                       ;011
          delete from qc_result_rule_r qrr                                   ;011
          where qrr.qc_result_id = arg_qc_result_id                          ;011
          with nocounter                                                     ;011

          insert
             into qc_result_rule_r qrr
          set
             qrr.rule_id             = request->qc_results[ridx].rule_id,
             qrr.qc_result_id        = arg_qc_result_id,
             qrr.sequence            = request->qc_results[ridx].rule_fails[rfidx].sequence,
             qrr.status_flag         = request->qc_results[ridx].rule_fails[rfidx].status_flag,
             qrr.updt_dt_tm          = cnvtdatetime(curdate,curtime),
             qrr.updt_cnt            = 0,
             qrr.updt_task           = reqinfo->updt_task,
             qrr.updt_id             = reqinfo->updt_id,
             qrr.updt_applctx        = reqinfo->updt_applctx

          plan qrr

          with
            nocounter

          return(curqual)
        end

     /************************************************************************
     * Check for comments and set the indicator                              *
     ************************************************************************/
        declare check_for_comment( none1 ) = i4
        subroutine check_for_comment( none1 )
        declare comment_return = i4
      set comment_return = 0
      if (chk_comment_ind = 1)
        if (request->qc_results[ridx].ignore_cmt_ind != 1)
          set comments_to_add = request->qc_results[ridx].comment_cnt
          set comment_return = 0
          for (cidx = 1 to comments_to_add)
            if (trim(request->qc_results[ridx]->comments[cidx].comment_text) > " ")
              set comment_return = 1
            endif
          endfor
          set trouble_to_add = request->qc_results[ridx].trouble_step_cnt
          for (tidx = 1 to trouble_to_add)
            if (request->qc_results[ridx].trouble_steps[tidx].active_ind = 1)
              set comment_return = 1
            endif
          endfor
        else
          set comment_return = request->qc_results[ridx].comment_ind
        endif
      endif
        return(comment_return)
        end

      /***********************************************************************
      * Script                                                               *
      ***********************************************************************/
     #Script
      set failed = "F"
      
      set chk_comment_ind = 1  ;005...
      set cur_comment_ind = 0  ;005...
      set reply->status_data->status = "F"

      declare qc_result_id = f8 with protect, noconstant(0.0)
      declare results_to_add           = i4
      declare comments_to_add          = i4
      declare trouble_to_add           = i4
      declare rule_fail_to_add         = i4  ;003...
      declare ginsert_qc_result_id     = f8
      declare ginsert_qc_group_id      = f8
      declare curr_group_id            = f8
      declare curr_updt_cnt            = i4
      declare gresult_updt_cnt         = i4
      declare prev_qc_result_id        = f8
      declare comment_result_id        = f8
      declare pass_sequence            = i4
      declare temp_type_cd             = f8
      declare temp_sequence            = i4
      declare temp_trouble_id          = f8
      declare status_group_flag        = i2
      declare found_performed_results  = f8  ;014

      declare result_type_text_cd      = f8
      declare result_type_alpha_cd     = f8
      declare result_type_numeric_cd   = f8
      declare result_type_date_cd      = f8
      declare result_type_freetext_cd  = f8
      declare result_type_calc_cd      = f8
      declare result_status_pending_cd = f8
      declare result_status_in_lab_cd  = f8
      declare result_status_old_perf_cd = f8
      declare result_status_performed_cd = f8
      declare result_status_verified_cd = f8
      declare result_status_auto_verf_cd = f8
      declare result_status_corrected_cd = f8
      declare result_status_change_cd   = f8
      declare result_status_old_chg_cd  = f8
      declare result_status_accept_cd   = f8
      declare result_status_reject_cd   = f8
      declare result_status_discard_cd   = f8

      declare nEvent_Dt_tm_Column_Exists = i2 with protect, noconstant(0)
      
      declare av_not_latest_result_ind = i2 with protect, noconstant(0)

      set results_to_add = size(request->qc_results, 5)
      set stat = alter(reply->qc_results, results_to_add)
      set reply->accession_key = request->accession_key

      ;get the code value for out_control_cd                                         ;009
      set out_control_cd = 0.0                                                       ;009
      call uar_get_meaning_by_codeset(1902, "OUT_CONTROL", 1, out_control_cd)        ;009

      ;get the code value for in_control_cd                                         ;010
      set in_control_cd = 0.0                                                       ;010
      call uar_get_meaning_by_codeset(1902, "IN_CONTROL", 1, in_control_cd)         ;010

     declare RESULT_TYPE_CODESET         = i4  with protect, constant(289)
     declare RESULT_TYPE_TEXT_CDF        = c12 with protect, constant("1")
     declare RESULT_TYPE_ALPHA_CDF       = c12 with protect, constant("2")
     declare RESULT_TYPE_NUMERIC_CDF     = c12 with protect, constant("3")
     declare RESULT_TYPE_DATE_CDF        = c12 with protect, constant("6")
     declare RESULT_TYPE_FREETEXT_CDF    = c12 with protect, constant("7")
     declare RESULT_TYPE_CALC_CDF        = c12 with protect, constant("8")
     declare RESULT_STATUS_CODESET       = i4 with protect, constant(1901)
     declare RESULT_STATUS_PENDING_CDF   = c12 with protect, constant("PENDING")
     declare RESULT_STATUS_IN_LAB_CDF    = c12 with protect, constant("INLAB")
     declare RESULT_STATUS_PERFORMED_CDF = c12 with protect, constant("PERFORMED")
     declare RESULT_STATUS_OLD_PERF_CDF  = c12 with protect, constant("OLDPERFORMED")
     declare RESULT_STATUS_VERIFIED_CDF  = c12 with protect, constant("VERIFIED")
     declare RESULT_STATUS_AUTO_VERF_CDF = c12 with protect, constant("AUTOVERIFIED")
     declare RESULT_STATUS_CORRECTED_CDF = c12 with protect, constant("CORRECTED")
     declare RESULT_STATUS_CHANGE_CDF    = c12 with protect, constant("CHANGE")
     declare RESULT_STATUS_OLD_CHG_CDF   = c12 with protect, constant("OLD CHANGE")
     declare RESULT_STATUS_ACCEPT_CDF    = c12 with protect, constant("ACCEPT")
     declare RESULT_STATUS_REJECT_CDF    = c12 with protect, constant("REJECT")
     declare RESULT_STATUS_DISCARD_CDF   = c12 with protect, constant("DISCARD")

     set long_text_id                = 0.00

      /***********************************************************************
      * check for the event_dt_tm to see if exists on the qc_result table    *
      ***********************************************************************/
      set nEvent_Dt_tm_Column_Exists = 0
      select into "nl:"
      from user_tab_columns u
      plan u
        where u.table_name = "QC_RESULT"
          and u.column_name = "EVENT_DT_TM"
      detail
        nEvent_Dt_tm_Column_Exists = 1
      with nocounter 

      /***********************************************************************
      * Load result type and result status code sets                         *
      ***********************************************************************/
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_TEXT_CDF, 1, result_type_text_cd)
      
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_ALPHA_CDF, 1, result_type_alpha_cd)
      
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_NUMERIC_CDF, 1, result_type_numeric_cd)
      
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_DATE_CDF, 1, RESULT_TYPE_DATE_CD)
      
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_FREETEXT_CDF, 1, RESULT_TYPE_FREETEXT_CD)
      
      call uar_get_meaning_by_codeset(RESULT_TYPE_CODESET, RESULT_TYPE_CALC_CDF, 1, RESULT_TYPE_CALC_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_PENDING_CDF, 1, RESULT_STATUS_PENDING_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_IN_LAB_CDF, 1, RESULT_STATUS_IN_LAB_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_PERFORMED_CDF, 1, RESULT_STATUS_PERFORMED_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_OLD_PERF_CDF, 1, RESULT_STATUS_OLD_PERF_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_VERIFIED_CDF, 1, RESULT_STATUS_VERIFIED_CD)
      set result_status_verified_disp = uar_get_code_display(result_status_verified_cd)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_AUTO_VERF_CDF, 1, RESULT_STATUS_AUTO_VERF_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_CORRECTED_CDF, 1, RESULT_STATUS_CORRECTED_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_CHANGE_CDF, 1, RESULT_STATUS_CHANGE_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_OLD_CHG_CDF, 1, RESULT_STATUS_OLD_CHG_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_ACCEPT_CDF, 1, RESULT_STATUS_ACCEPT_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_REJECT_CDF, 1, RESULT_STATUS_REJECT_CD)
      
      call uar_get_meaning_by_codeset(RESULT_STATUS_CODESET, RESULT_STATUS_DISCARD_CDF, 1, RESULT_STATUS_DISCARD_CD)

; Insert a new group_id if not already defined.
; Check for -1 to see if called from correction application.
      if (request->qc_group_id = -1)
        set curr_group_id = -1.0
      else
        if (request->qc_group_id = 0)
          if (insert_group( 0 ) = 0)
            go to q_group_insert_failed
          else
            set reply->qc_group_id = ginsert_qc_group_id
            set curr_group_id = ginsert_qc_group_id
          endif
        else
          set curr_group_id = request->qc_group_id
          set status_group_flag = request->qc_status_flag
          if (status_group_flag = 1 or status_group_flag = 2)
            if (update_group( curr_group_id, status_group_flag ) = 0)
              go to q_group_update_failed
            endif
          endif
          set reply->qc_group_id = curr_group_id
        endif
      endif

; Update/insert qc results into tables
      set qc_cnt = 0
      set found_performed_results = 0               ;014

      for (ridx = 1 to results_to_add)
        set gresult_updt_cnt = 0
        set prev_qc_result_id = 0.0
        set ginsert_qc_result_id = 0.0
        set comment_result_id = 0.0

        call echo(build("RIDX=",
        ridx,
        char(0)))

        /* If performed result exists, set flag */          ;014
        if (request->qc_results[ridx].result_status_cd =      ;014
            result_status_performed_cd)               ;014
          set found_performed_results = 1             ;014
        endif                           ;014

        if (request->qc_results[ridx].qc_result_id > 0.0)

          /* Previous result id is same as result id until new one inserted */
          set prev_qc_result_id = request->qc_results[ridx].qc_result_id

          /* Result performed with new value */
          if (request->qc_results[ridx].result_status_cd = result_status_performed_cd)
            set chk_comment_ind = 0  ;005...
            if (update_result( prev_qc_result_id, result_status_old_perf_cd ) = 0)
              go to q_update_failed
            endif
            set chk_comment_ind = 1  ;005...
            set gresult_updt_cnt = 0
            set pass_sequence = find_sequence( prev_qc_result_id)
            if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_old_perf_cd ) = 0)
              go to q_insert_event_failed
            endif
            if (insert_result( 0 ) = 0)
              go to q_insert_failed
            endif
            if (insert_auto_verify_cd (ginsert_qc_result_id) = 0)
              go to q_insert_auto_verify_code_failed
            endif
            set comment_result_id = ginsert_qc_result_id
            if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
              go to q_insert_event_failed
            endif

          /* Result verified - may or may not have a new value */
          elseif (request->qc_results[ridx].result_status_cd = result_status_verified_cd)
            if (check_result( prev_qc_result_id ) = 0)
              set comment_result_id = prev_qc_result_id
              if (update_result( prev_qc_result_id, result_status_verified_cd ) = 0)
                go to q_update_failed
              endif
              set pass_sequence = find_sequence( prev_qc_result_id)
              if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_verified_cd ) = 0)
                go to q_insert_event_failed
              endif
            else
              set chk_comment_ind = 0  ;005...
              if (update_result( prev_qc_result_id, result_status_old_perf_cd ) = 0)
                go to q_update_failed
              endif
              set chk_comment_ind = 1  ;005...
              set pass_sequence = find_sequence( prev_qc_result_id)
              if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_old_perf_cd ) = 0)
                go to q_insert_event_failed
              endif
              if (insert_result( 0 ) = 0)
                go to q_insert_failed
              endif
              if (insert_auto_verify_cd (ginsert_qc_result_id) = 0)
                go to q_insert_auto_verify_code_failed
              endif
              set comment_result_id = ginsert_qc_result_id
              if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
                go to q_insert_event_failed
              endif
              if (insert_result_event( ginsert_qc_result_id, 1, result_status_verified_cd ) = 0)
                go to q_insert_event_failed
              endif
            endif
;004... add auto verify logic
          /* Result auto verified - may or may not have a new value */
          elseif (request->qc_results[ridx].result_status_cd = result_status_auto_verf_cd)
            if (check_result( prev_qc_result_id ) = 0)
              set comment_result_id = prev_qc_result_id
              if (update_result( prev_qc_result_id, result_status_auto_verf_cd ) = 0)
                go to q_update_failed
              endif
              set pass_sequence = find_sequence( prev_qc_result_id)
              if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_auto_verf_cd ) = 0)
                go to q_insert_event_failed
              endif
            else
              set chk_comment_ind = 0  ;005...
              if (update_result( prev_qc_result_id, result_status_old_perf_cd ) = 0)
                go to q_update_failed
              endif
              set chk_comment_ind = 1  ;005...
              set pass_sequence = find_sequence( prev_qc_result_id)
              if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_old_perf_cd ) = 0)
                go to q_insert_event_failed
              endif
              if (insert_result( 0 ) = 0)
                go to q_insert_failed
              endif
              if (insert_auto_verify_cd (ginsert_qc_result_id) = 0)
                go to q_insert_auto_verify_code_failed
              endif
              set comment_result_id = ginsert_qc_result_id
              if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
                go to q_insert_event_failed
              endif
              if (insert_result_event( ginsert_qc_result_id, 1, result_status_auto_verf_cd ) = 0)  ;015
                go to q_insert_event_failed
              endif
            endif
;004... end
          /* Result changed to a new value after verified */
          elseif (request->qc_results[ridx].result_status_cd = result_status_change_cd)
            set chk_comment_ind = 0  ;005...
            if (update_result( prev_qc_result_id, result_status_old_chg_cd ) = 0)
              go to q_update_failed
            endif
            set chk_comment_ind = 1  ;005...
            set pass_sequence = find_sequence( prev_qc_result_id)
            if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_old_chg_cd ) = 0)
              go to q_insert_event_failed
            endif
            if (insert_result( 0 ) = 0)
              go to q_insert_failed
            endif
            if (insert_auto_verify_cd (ginsert_qc_result_id) = 0)
              go to q_insert_auto_verify_code_failed
            endif
            set comment_result_id = ginsert_qc_result_id
            if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
              go to q_insert_event_failed
            endif
            if (insert_result_event( ginsert_qc_result_id, 1, result_status_verified_cd ) = 0)
              go to q_insert_event_failed
            endif
            if (insert_result_event( ginsert_qc_result_id, 2, result_status_change_cd ) = 0)
              go to q_insert_event_failed
            endif

          /* Out of control result accepted */
          elseif (request->qc_results[ridx].result_status_cd = result_status_accept_cd)
            if (update_result( prev_qc_result_id, result_status_accept_cd ) = 0)
              go to q_update_failed
            endif
            set comment_result_id = prev_qc_result_id
            set pass_sequence = find_sequence( prev_qc_result_id)
            if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_accept_cd ) = 0)
              go to q_insert_event_failed
            endif

          /* Out of control result rejected */
          elseif (request->qc_results[ridx].result_status_cd = result_status_reject_cd)
            if (update_result( prev_qc_result_id, result_status_reject_cd ) = 0)
              go to q_update_failed
            endif
            set comment_result_id = prev_qc_result_id
            set pass_sequence = find_sequence( prev_qc_result_id)
            if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_reject_cd ) = 0)
              go to q_insert_event_failed
            endif
          /* Out of control result discarded */
          elseif (request->qc_results[ridx].result_status_cd = result_status_discard_cd)
            if (update_result( prev_qc_result_id, result_status_discard_cd ) = 0)
              go to q_update_failed
            endif
            set comment_result_id = prev_qc_result_id
            set pass_sequence = find_sequence( prev_qc_result_id)
            if (insert_result_event( prev_qc_result_id, pass_sequence, result_status_discard_cd ) = 0)
              go to q_insert_event_failed
            endif
          endif

        else

          /* Insert result new result */
          if (insert_result( 0 ) = 0)
            go to q_insert_failed
          endif

          if (insert_auto_verify_cd (ginsert_qc_result_id) = 0)
            go to q_insert_auto_verify_code_failed
          endif

          /* Insert result events */
          /*   if performed insert performed only */
          /*   if verified insert performed and verified */
          set comment_result_id = ginsert_qc_result_id
          if (request->qc_results[ridx].result_status_cd =
                 result_status_performed_cd)
            if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
              go to q_insert_event_failed
            endif
          else
            if (insert_result_event( ginsert_qc_result_id, 0, result_status_performed_cd ) = 0)
              go to q_insert_event_failed
            endif
;004... autoverify
            if (request->qc_results[ridx].result_status_cd =
                   result_status_auto_verf_cd)
              if (insert_result_event( ginsert_qc_result_id, 1, result_status_auto_verf_cd ) = 0)
                go to q_insert_event_failed
              endif
            else
;004... end
              if (insert_result_event( ginsert_qc_result_id, 1, result_status_verified_cd ) = 0)
                go to q_insert_event_failed
              endif
            endif  ;004...
          endif
        endif

        set comments_to_add = request->qc_results[ridx].comment_cnt
        for (cidx = 1 to comments_to_add)
          set temp_type_cd = request->qc_results[ridx].comments[cidx].comment_type_cd
          set temp_sequence = find_cmt_sequence( comment_result_id, temp_type_cd )
          if (insert_result_comment( comment_result_id, temp_type_cd, temp_sequence ) = 0)
            go to q_comment_insert_failed
           endif
        endfor

        set trouble_to_add = request->qc_results[ridx].trouble_step_cnt
        for (tidx = 1 to trouble_to_add)
          set temp_trouble_id = request->qc_results[ridx].trouble_steps[tidx].trouble_id
          if (find_trouble( comment_result_id, temp_trouble_id ) = 0)
            if (insert_trouble_step( comment_result_id, temp_trouble_id ) = 0)
              go to q_trouble_insert_failed
            endif
          else
            if (update_trouble_step( comment_result_id, temp_trouble_id ) = 0)
              go to q_trouble_update_failed
            endif
          endif
        endfor

;003...  Add rule fail processing
        set rule_fail_to_add = request->qc_results[ridx].rule_fail_cnt
        for (rfidx = 1 to rule_fail_to_add)
            if (insert_rule_fail( comment_result_id ) = 0)
              go to q_rule_fail_insert_failed
            endif
        endfor
;003... end

        set qc_cnt = qc_cnt + 1
        set reply->qc_results[qc_cnt].qc_result_id = comment_result_id
        set reply->qc_results[qc_cnt].task_assay_cd = request->qc_results[ridx].task_assay_cd
        set reply->qc_results[qc_cnt].qc_result_updt_cnt = gresult_updt_cnt
        set reply->qc_results[qc_cnt].updt_id = reqinfo->updt_id
        set reply->qc_results[qc_cnt].perform_result_key =
            request->qc_results[ridx].perform_result_key

;        if ( check_group_result ( curr_group_id, comment_result_id ) = 0 )
;          call insert_group_result( curr_group_id, comment_result_id )
;        endif

        ;call sub to update the av_status_flag on the auto_verify table          ;009
        ;if this QC result is out of control                                     ;009

        set av_latest_result_ind = 1
        
        if (request->qc_inquiry_ind = 1)
            select into "nl:"
            from qc_result qr
            plan qr where qr.control_id = request->qc_results[ridx].control_id
                      and qr.task_assay_cd = request->qc_results[ridx].task_assay_cd
                      and qr.service_resource_cd = request->qc_results[ridx].service_resource_cd
                      and qr.perform_dt_tm > cnvtdatetime(request->qc_results[ridx].perform_dt_tm)
            detail
              av_latest_result_ind = 0
            with nocounter
        endif
        
        if (av_latest_result_ind = 1)
            call update_av_status (0)                                                ;009
    
            ;just call check for the first result since all results have same control ID              ;010
            if (ridx = 1)                                                                             ;010
               ;call sub to see if this control is on the QC schedule or not                          ;010
               set found_on_schedule = 0                                                              ;010
               set found_on_schedule = OnQCSchedule (request->qc_results[ridx].service_resource_cd,   ;010
                                                     request->qc_results[ridx].control_id)            ;010
            endif                                                                                     ;010
    
            ;check to see whether we need to call the evaluate QC Schedule subs                       ;010
            ;only call check QC Schedule for verf and autoverf results                                ;010
            ;call check QC Schedule for accepted and changed results that are in control              ;010
            if ((request->qc_results[ridx].result_status_cd = result_status_auto_verf_cd)             ;010
            ;add check for alpha verified alpha results since the QcCorrection dll does not get       ;013
            ;called when you just verify a alpha result in control                                    ;013
            or  (request->qc_results[ridx].result_type_cd = result_type_alpha_cd and                  ;013
                request->qc_results[ridx].result_status_cd = result_status_verified_cd)               ;013
            or  (request->qc_results[ridx].result_status_cd = result_status_accept_cd)                ;010
            or  ((request->qc_results[ridx].result_status_cd = result_status_change_cd)               ;010
            and (request->qc_results[ridx].result_control_cd = in_control_cd)))                       ;010
                ;if this control was found on the schedule then call sub to check schedule            ;010
                if (found_on_schedule = 1)                                                            ;010
                    commit                                                                             ;GR4187
                    call CheckQCSchedule (request->qc_results[ridx].service_resource_cd,               ;010
                                         request->qc_results[ridx].task_assay_cd)                     ;010
                endif                                                                                 ;010
            else
                if (request->qc_results[ridx].result_control_cd = out_control_cd)
                
                	;Current QC_STEP_STATUS row ID
                    declare step_status_id      = f8 with protect, noconstant(0.0)                    
                    
                    ;Expand variables
                    declare lAssayIdx           = i4 with protect, noconstant(0)
                    declare lEIdx               = i4 with protect, noconstant(0)
                    declare qss_found           = i2 with protect, noconstant(0)

                	record equiv_assays
                    (
                      1 qual[*]
                        2  task_assay_cd        = f8
                        2  step_status_id       = f8
                    )
             
                    set lAssayIdx = 1
                    set stat = alterlist(equiv_assays->qual, lAssayIdx)
                    set equiv_assays->qual[lAssayIdx].task_assay_cd = request->qc_results[ridx].task_assay_cd        

                    ;Get all the equivalent assays for this assay
                    select into "nl:"
                    from related_assay ra1,
                         related_assay ra2
                    plan ra1 
                      where ra1.task_assay_cd = equiv_assays->qual[1].task_assay_cd
                    join ra2
                      where ra2.related_entity_id = ra1.related_entity_id
                      and ra2.task_assay_cd != ra1.task_assay_cd
                    order by ra2.task_assay_cd
                    head ra2.task_assay_cd
                      lAssayIdx = lAssayIdx + 1
                      if (lAssayIdx > size(equiv_assays->qual, 5))
                        stat = alterlist(equiv_assays->qual, lAssayIdx + 3)
                      endif
                      equiv_assays->qual[lAssayIdx].task_assay_cd = ra2.task_assay_cd
                    with nocounter
                    
                    set stat = alterlist(equiv_assays->qual,lAssayIdx)
                                          
                    ;Find the most current QC Step Status row for the resource across the valid equivalent assays
                    select into "nl:"
                      qss.verify_results_nbr,
                      qss.current_results_nbr,
                      qss.qc_step_status_id
                    from qc_step_status qss
                    plan qss
                      where expand(lEIdx, 1, lAssayIdx,qss.task_assay_cd, equiv_assays->qual[lEIdx].task_assay_cd)
                      and qss.service_resource_cd = request->qc_results[ridx].service_resource_cd
                      and cnvtdatetime(curdate, curtime3) <= qss.step_expire_dt_tm
                    ; Order by service_resource_cd to use it in the head to get only one row for the resource, 
                    ; step_complete_dt_tm desc to find the step completed, most recently, and the step_expire_dt_tm in the event
                    ; that both QC assays were on the same step(step_complete_dt_tm is the same), but one has been expired.
                    ; Finally, task_assay_cd in case all the other attributes are the same.  
                    order qss.service_resource_cd, qss.step_complete_dt_tm desc, qss.step_expire_dt_tm, qss.task_assay_cd
                    head qss.service_resource_cd
                      if (((qss.verify_results_nbr > 0 and qss.current_results_nbr < qss.verify_results_nbr)
                      or (qss.verify_results_nbr = -1))
                      and qss.step_expire_dt_tm > cnvtdatetime(curdate,curtime3))
                        qss_found = 1
                        step_status_id = qss.qc_step_status_id
                      endif
                    with nocounter                      
                   
                    ;If we found a current QC_STEP_STATUS row, expire it.
                    if (qss_found = 1)
                    
                      select into "nl:"
                      from qc_step_status qss
                        where qss.qc_step_status_id = step_status_id
                      with nocounter, forupdate(qss)
                    
                      update into
                        qc_step_status qss
                      set qss.step_expire_dt_tm = cnvtdatetime(curdate,curtime3),
                          qss.updt_dt_tm = cnvtdatetime(curdate,curtime3),
                          qss.updt_id = reqinfo->updt_id,
                          qss.updt_task = reqinfo->updt_task,
                          qss.updt_applctx = reqinfo->updt_applctx,
                          qss.updt_cnt = qss.updt_cnt + 1,
                          qss.updt_task = reqinfo->updt_task
                        where qss.qc_step_status_id = step_status_id
                      with nocounter  
                    endif ;qss_found = 1
                endif ;result_control_cd = out_control_cd    
            endif ;result_status                                                                        ;010
        endif ;av_latest_result_ind
      endfor

/********************************************************************/
/* Update instrument accession queue.                               */
/********************************************************************/
      record q_rec                                                     ;006
      (                                                                ;006
        1  que_found  = i2                                             ;006
        1  in_process = i2                                             ;006
        1  max_seq    = i4                                             ;006
        1  curr_req   = vc                                             ;006
      )                                                                ;006
                                                                       ;006
      set qc_accn = fillstring(20, " ")                                ;006
      set qc_cnt = 0                                                   ;006
                                                                       ;006
      if ((request->qc_results[1].interface_flag = 1)                  ;006
      or (request->qc_results[1].interface_flag = 7))                 ;014
         ;* This came from an instrument.  Check to see if accession   ;006
         ;* should be queued.                                          ;006
         call echo("  --> Instrument Request")                         ;006
         go to Instr_Req                                               ;006
      else                                                             ;006
         ;* This didn't come from an instrument.  Check to see if a    ;006
         ;* queue record needs to be deleted.                          ;006
         call echo("  --> Non-Instrument Request")                     ;006
         go to Non_Instr_Req                                           ;006
      endif                                                            ;006
                                                                       ;006
     #Instr_Req                                                        ;006


declare PopulateQCForAutomaticWorklist() = NULL
subroutine PopulateQCForAutomaticWorklist(NULL)
  declare nQC_ACCN_IDX = i2 with protect, constant(1)
  declare lQCResultsIdx = i4 with protect, noconstant(0)
  declare lQCResultsCnt = i4 with protect, noconstant(0)
  declare lIdx = i4 with protect, noconstant(0)
  declare dCurrentServiceResourceCd = f8 with protect, noconstant(0.0)
  declare lItemServiceResourceIdx = i4 with protect, noconstant(0)
  declare lItemServiceResourceCnt = i4 with protect, noconstant(0)
  declare dCurrentQCResultId = f8 with protect, noconstant(0.0)
  declare lItemQCResultIdx = i4 with protect, noconstant(0)
  declare lItemQCResultCnt = i4 with protect, noconstant(0)
  
  set lQCResultsCnt = size(request->qc_results, 5)
  for (lQCResultsIdx = 1 to lQCResultsCnt)

      if (request->qc_results[lQCResultsIdx]->service_resource_cd != dCurrentServiceResourceCd)
        set dCurrentServiceResourceCd = request->qc_results[lQCResultsIdx]->service_resource_cd
        
        ;is service resource already in the items_for_automatic_worklist structure?
        set lItemServiceResourceIdx = locateval(lIdx, 1, lItemServiceResourceCnt,
                                                dCurrentServiceResourceCd,
                                                items_for_automatic_worklist->service_resources[lIdx].service_resource_cd)
        set lItemQCResultIdx = 0   ;new svc res for list has no QC results yet
        if (lItemServiceResourceIdx <= 0)
          set lItemServiceResourceCnt = lItemServiceResourceCnt + 1
          set lItemServiceResourceIdx = lItemServiceResourceCnt
          set stat = alterlist(items_for_automatic_worklist->service_resources, lItemServiceResourceCnt)
          set items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].service_resource_cd = 
                                                                                       dCurrentServiceResourceCd
        endif
      endif
      
      ;check to see if the qc_result_id has already been inserted in the items_for_automatic_worklist struct
      if (lItemQCResultIdx = 0 or 
          reply->qc_results[lQCResultsIdx].qc_result_id != dCurrentQCResultId)
        ;first qc_result_id, so add the single accession level for the QC accession
        if(size(items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].accessions,5) = 0)
            set stat = alterlist(items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].accessions, 1)
                                              
            set items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].
                                              accessions[nQC_ACCN_IDX].accession_id = request->accession_id
            set items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].
                                              accessions[nQC_ACCN_IDX].qc_group_id = reply->qc_group_id

        endif   
        set dCurrentQCResultId = reply->qc_results[lQCResultsIdx].qc_result_id
        set lItemQCResultCnt = size(items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].
                                                                  accessions[nQC_ACCN_IDX].qc_results, 5)
        set lItemQCResultCnt = lItemQCResultCnt + 1
        set lItemQcResultIdx = lItemQCResultCnt
        set stat = alterlist(items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].
                                                           accessions[nQC_ACCN_IDX].qc_results, lItemQCResultCnt)
        set items_for_automatic_worklist->service_resources[lItemServiceResourceIdx].accessions[nQC_ACCN_IDX].
                                          qc_results[lItemQCResultIdx].qc_result_id = dCurrentQCResultId

      endif
  endfor
end

%i cclsource:glb_add_auto_wklst_ele.inc

call PopulateQCForAutomaticWorklist(0)
call AddItemsToAutomaticWorklist(0)

;      if (request->qc_results[1].result_status_cd !=                  ;006     ;014
;                             result_status_performed_cd)              ;006     ;014
         ;* This is not a Perform request.                             ;006
         ;* Process as a non-instrument request.                       ;006

;check the found_perform_results flag instead of just checking for the first        ;014
;order/assay to be performed                                                      ;014
;a problem was found where the queue was not getting written because the first    ;014
;assay was getting autoverf but nothing else                                      ;014

    if (found_performed_results = 0)                                              ;014
         call echo(build("  Not A Perform Request -> Process As Non-", ;006
           "Instrument"))                                              ;006
         call echo(build("  --> result_status_cd = ",                  ;006
           request->qc_results[1]->result_status_cd))                  ;006
         go to Non_Instr_Req                                           ;006
      endif                                                            ;006
                                                                       ;006
      select into "nl:"                                                ;006
         a.accession                                                   ;006
      from accession a                                                 ;006
      where a.accession_id = request->accession_id                     ;006
      detail                                                           ;006
         qc_accn = a.accession                                         ;006
      with nocounter                                                   ;006
                                                                       ;006
      set q_rec->que_found  = 0                                        ;006
      set q_rec->in_process = 0                                        ;006
      set q_rec->max_seq    = 0                                        ;006
      set q_rec->curr_req   = " "                                      ;006
                                                                       ;006
      set qc_cnt = size(request->qc_results, 5)                        ;006
      call echo(build("  Processing Accession:", qc_accn))             ;006
      if (qc_cnt > 0                                                   ;006
      and qc_accn > " ")                                               ;006
         call echo(build("  Processing Resource:",                     ;006
           request->qc_results[1].service_resource_cd ))               ;006
         select into "nl:"                                             ;006
            iaq.service_resource_cd                                    ;006
           ,iaq.sequence                                               ;006
           ,iaq.accession                                              ;006
         from instr_accn_queue iaq                                     ;006
         where iaq.service_resource_cd =                               ;006
                        request->qc_results[1].service_resource_cd     ;006
                                                                       ;006
         head iaq.service_resource_cd                                  ;006
            q_rec->que_found = 0                                       ;006
                                                                       ;006
         detail                                                        ;006
            if (iaq.accession = qc_accn)                               ;006
               q_rec->que_found = 1                                    ;006
               if (iaq.in_process_prsnl_id > 0)                        ;006
                  q_rec->in_process = 1                                ;006
               endif                                                   ;006
            endif                                                      ;006
                                                                       ;006
         foot iaq.service_resource_cd                                  ;006
            q_rec->max_seq = max(iaq.sequence)                         ;006
                                                                       ;006
         with nocounter                                                ;006
                                                                       ;006
         call echo(build("  --> max_seq = ", q_rec->max_seq))          ;006
                                                                       ;006
         if (q_rec->que_found = 1                                      ;006
         and q_rec->in_process = 0)                                    ;006
            call echo("  --> Record Already In Queue -> Skipping")     ;006
         else                                                          ;006
            if (q_rec->in_process = 1)                                 ;006
               call echo(build("  --> Locked Record Already In Queue", ;006
                 " -> Deleting"))                                      ;006
               delete from instr_accn_queue iaq                        ;006
               where iaq.service_resource_cd =                         ;006
                        request->qc_results[1].service_resource_cd     ;006
                 and iaq.accession = qc_accn                           ;006
               with nocounter                                          ;006
               if ( curqual = 0 )                                      ;006
                  call echo("  Failure Deleting Record From Queue")    ;006
               else                                                    ;006
                  call echo("  Record Deleted From Queue")             ;006
               endif                                                   ;006
            endif                                                      ;006
            call echo("  --> Attempting To Insert Into Queue")         ;006
            insert into instr_accn_queue iaq                           ;006
            set                                                        ;006
              iaq.service_resource_cd =                                ;006
                request->qc_results[1]->service_resource_cd,           ;006
              iaq.sequence = q_rec->max_seq + 1,                       ;006
              iaq.accession = qc_accn,                                 ;006
              iaq.qc_group_id = reply->qc_group_id                     ;006
            with nocounter                                             ;006
            if ( curqual = 0 )                                         ;006
               call echo("  Failure Writing Record To Queue")          ;006
            else                                                       ;006
               call echo("  Record Inserted Into Queue")               ;006
            endif                                                      ;006
         endif                                                         ;006
      else                                                             ;006
         call echo(build("  No QC Results For QCGroupId = ",           ;006
           request->qc_group_id))                                      ;006
      endif                                                            ;006
                                                                       ;006
      go to Exit_Script                                                ;006
                                                                       ;006
                                                                       ;006
     #Non_Instr_Req                                                    ;006
      set q_rec->que_found = 0                                         ;006
      set q_rec->max_seq   = 0                                         ;006
      set q_rec->curr_req  = " "                                       ;006
                                                                       ;006
      call echo(build("  --> result_status_cd = ",                     ;006
        request->qc_results[1]->result_status_cd))                     ;006
                                                                       ;006
      select into "nl:"                                                ;006
         a.accession                                                   ;006
      from accession a                                                 ;006
      where a.accession_id = request->accession_id                     ;006
      detail                                                           ;006
         qc_accn = a.accession                                         ;006
      with nocounter                                                   ;006
                                                                       ;006
                                                                       ;006
;* Check Instrument Accession Queue for accession/service resource     ;006
;* and remove queue record.                                            ;006
      call echo(build("  Checking Queue For Accession :", qc_accn))    ;006
      call echo(build("  Checking Queue for Resource :",               ;006
        request->qc_results[1].service_resource_cd))                   ;006
      select into "nl:"                                                ;006
         iaq.service_resource_cd                                       ;006
        ,iaq.accession                                                 ;006
      from                                                             ;006
         instr_accn_queue iaq                                          ;006
      plan iaq where iaq.service_resource_cd =                         ;006
                        request->qc_results[1].service_resource_cd     ;006
                 and iaq.accession = qc_accn                           ;006
      with nocounter                                                   ;006
      if (curqual > 0)                                                 ;006
         call echo("  --> Record Found In Queue... Deleting")          ;006
         delete from instr_accn_queue iaq                              ;006
         plan iaq where iaq.service_resource_cd =                      ;006
                      request->qc_results[1].service_resource_cd       ;006
                    and iaq.accession = qc_accn                        ;006
         with nocounter                                                ;006
         if (curqual > 0)                                              ;006
            call echo("  ----> Record Deleted From Queue")             ;006
         else                                                          ;006
            call echo("  ----> Error Deleting Record From Queue")      ;006
         endif                                                         ;006
      else                                                             ;006
         call echo("  --> Record Not In Queue")                        ;006
      endif                                                            ;006

      go to exit_script

/********************************************************************/
/* Executed if qc_result table update is unsuccessful.              */
/********************************************************************/
     #q_update_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "update"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result table"
      set failed = "T"
      go to exit_script

;009/********************************************************************/
;009/* Executed if qc_comment table insert is unsuccessful.             */
;009/********************************************************************/
;009     #q_comment_insert_failed
;009      set reply->status_data->subeventstatus[1]->operationname =
;009         "insert"
;009      set reply->status_data->subeventstatus[1]->operationstatus =
;009         "F"
;009      set reply->status_data->subeventstatus[1]->targetobjectname =
;009         "table"
;009      set reply->status_data->subeventstatus[1]->targetObjectValue =
;009         "qc_comment table"
;009      set failed = "T"
;009      go to exit_script

/********************************************************************/
/* Executed if long_text table sequence is unsuccessful.            */
/********************************************************************/
     #seq_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "sequence"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "long_text table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_result_grp table insert is unsuccessful.          */
/********************************************************************/
     #q_group_insert_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_grp table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_result_grp table update is unsuccessful.          */
/********************************************************************/
     #q_group_update_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "update"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_grp table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_result table insert is unsuccessful.              */
/********************************************************************/
     #q_insert_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_result_event table insert is unsuccessful.        */
/********************************************************************/
     #q_insert_event_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_event table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if auto_verify_code table insert is unsuccessful.       */
/********************************************************************/
     #q_insert_auto_verify_code_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "auto_verify_code table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_comment table insert is unsuccessful.             */
/********************************************************************/
     #q_comment_insert_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_comment table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_trouble_step table insert is unsuccessful.        */
/********************************************************************/
     #q_trouble_insert_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_trouble_r table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_trouble_step table insert is unsuccessful.        */
/********************************************************************/
     #q_rule_fail_insert_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "insert"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_rule_r table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Executed if qc_trouble_step table update is unsuccessful.        */
/********************************************************************/
     #q_trouble_update_failed
      set reply->status_data->subeventstatus[1]->operationname =
         "update"
      set reply->status_data->subeventstatus[1]->operationstatus =
         "F"
      set reply->status_data->subeventstatus[1]->targetobjectname =
         "table"
      set reply->status_data->subeventstatus[1]->targetObjectValue =
         "qc_result_trouble_r table"
      set failed = "T"
      go to exit_script

/********************************************************************/
/* Script exit.                                                     */
/********************************************************************/
     #exit_script
      if (failed = "F")
         set reply->status_data->status = "S"
         commit
      else
         rollback
      endif

      free set q_rec
END
GO

;Generated by GNU enscript 1.6.4.
